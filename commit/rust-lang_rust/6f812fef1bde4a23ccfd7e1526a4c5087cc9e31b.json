{"sha": "6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmODEyZmVmMWJkZTRhMjNjY2ZkN2UxNTI2YTRjNTA4N2NjOWUzMWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-23T02:26:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-26T23:21:04Z"}, "message": "rustc: Remove uses of oldmap::HashMap", "tree": {"sha": "0c699de23f4063b7bb0f94bb90f3c5824cc6f447", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c699de23f4063b7bb0f94bb90f3c5824cc6f447"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "html_url": "https://github.com/rust-lang/rust/commit/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31f6e6432485cfb880af0c8d98dc0cbdaec74383", "url": "https://api.github.com/repos/rust-lang/rust/commits/31f6e6432485cfb880af0c8d98dc0cbdaec74383", "html_url": "https://github.com/rust-lang/rust/commit/31f6e6432485cfb880af0c8d98dc0cbdaec74383"}], "stats": {"total": 1756, "additions": 877, "deletions": 879}, "files": [{"sha": "d0c318d16a2b5862984f3e29e5c280d0fc7bac52", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -642,7 +642,7 @@ pub fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n \n pub fn get_symbol_hash(ccx: @CrateContext, t: ty::t) -> @str {\n     match ccx.type_hashcodes.find(&t) {\n-      Some(h) => h,\n+      Some(&h) => h,\n       None => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);\n         ccx.type_hashcodes.insert(t, hash);"}, {"sha": "1de69ed85a8404d3a70281b61b86c14a26bc2c7c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -246,7 +246,7 @@ pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n \n         // These next two const passes can probably be merged\n         time(time_passes, ~\"const marking\", ||\n-             middle::const_eval::process_crate(crate, def_map, ty_cx));\n+             middle::const_eval::process_crate(crate, ty_cx));\n \n         time(time_passes, ~\"const checking\", ||\n              middle::check_const::check_crate(sess, crate, ast_map, def_map,\n@@ -546,11 +546,11 @@ pub fn build_session_options(+binary: ~str,\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n-            let lint_name = @str::replace(*lint_name, ~\"-\", ~\"_\");\n+            let lint_name = str::replace(*lint_name, ~\"-\", ~\"_\");\n             match lint_dict.find(&lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n-                                           level_name, *lint_name));\n+                                           level_name, lint_name));\n               }\n               Some(lint) => {\n                 lint_opts.push((lint.lint, *level));"}, {"sha": "e97252c5341db262d2069ef491b27891125e2d73", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -10,12 +10,12 @@\n \n use core::prelude::*;\n \n+use core::hashmap::linear::LinearMap;\n use core::libc::{c_char, c_int, c_uint, c_longlong, c_ulonglong};\n use core::option;\n use core::ptr;\n use core::str;\n use core::vec;\n-use std::oldmap::HashMap;\n \n pub type Opcode = u32;\n pub type Bool = c_uint;\n@@ -1467,8 +1467,8 @@ pub fn SetLinkage(Global: ValueRef, Link: Linkage) {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    type_names: HashMap<TypeRef, @str>,\n-    named_types: HashMap<@str, TypeRef>\n+    type_names: @mut LinearMap<TypeRef, @str>,\n+    named_types: @mut LinearMap<@str, TypeRef>\n }\n \n pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n@@ -1477,17 +1477,17 @@ pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n }\n \n pub fn type_has_name(tn: @TypeNames, t: TypeRef) -> Option<@str> {\n-    return tn.type_names.find(&t);\n+    return tn.type_names.find(&t).map_consume(|x| *x);\n }\n \n pub fn name_has_type(tn: @TypeNames, s: @str) -> Option<TypeRef> {\n-    return tn.named_types.find(&s);\n+    return tn.named_types.find(&s).map_consume(|x| *x);\n }\n \n pub fn mk_type_names() -> @TypeNames {\n     @TypeNames {\n-        type_names: HashMap(),\n-        named_types: HashMap()\n+        type_names: @mut LinearMap::new(),\n+        named_types: @mut LinearMap::new()\n     }\n }\n "}, {"sha": "ce37054cba244cef401889f37edeb0aca37258f2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -19,14 +19,14 @@ use metadata::filesearch::FileSearch;\n use metadata::loader;\n \n use core::either;\n+use core::hashmap::linear::LinearMap;\n use core::vec;\n use syntax::attr;\n use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n use syntax::parse::token::ident_interner;\n use syntax::visit;\n use syntax::{ast, ast_util};\n-use std::oldmap::HashMap;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n@@ -307,7 +307,7 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n-    let cnum_map = HashMap();\n+    let mut cnum_map = LinearMap::new();\n     for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n@@ -334,7 +334,7 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n           }\n         }\n     }\n-    return cnum_map;\n+    return @mut cnum_map;\n }\n \n // Local Variables:"}, {"sha": "d4360a7d49160db46c13a58beeb4d1eb968e9b11", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -17,8 +17,8 @@ use core::prelude::*;\n use metadata::cstore;\n use metadata::decoder;\n \n+use core::hashmap::linear::LinearMap;\n use core::vec;\n-use std::oldmap;\n use std;\n use syntax::{ast, attr};\n use syntax::parse::token::ident_interner;\n@@ -27,7 +27,7 @@ use syntax::parse::token::ident_interner;\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = oldmap::HashMap<ast::crate_num, ast::crate_num>;\n+pub type cnum_map = @mut LinearMap<ast::crate_num, ast::crate_num>;\n \n pub struct crate_metadata {\n     name: @~str,\n@@ -37,7 +37,7 @@ pub struct crate_metadata {\n }\n \n pub struct CStore {\n-    priv metas: oldmap::HashMap<ast::crate_num, @crate_metadata>,\n+    priv metas: LinearMap <ast::crate_num, @crate_metadata>,\n     priv extern_mod_crate_map: extern_mod_crate_map,\n     priv used_crate_files: ~[Path],\n     priv used_libraries: ~[~str],\n@@ -46,111 +46,102 @@ pub struct CStore {\n }\n \n // Map from node_id's of local extern mod statements to crate numbers\n-type extern_mod_crate_map = oldmap::HashMap<ast::node_id, ast::crate_num>;\n+type extern_mod_crate_map = LinearMap<ast::node_id, ast::crate_num>;\n \n pub fn mk_cstore(intr: @ident_interner) -> CStore {\n-    let meta_cache = oldmap::HashMap();\n-    let crate_map = oldmap::HashMap();\n     return CStore {\n-        metas: meta_cache,\n-        extern_mod_crate_map: crate_map,\n+        metas: LinearMap::new(),\n+        extern_mod_crate_map: LinearMap::new(),\n         used_crate_files: ~[],\n         used_libraries: ~[],\n         used_link_args: ~[],\n         intr: intr\n     };\n }\n \n-pub fn get_crate_data(cstore: @mut CStore, cnum: ast::crate_num)\n+pub fn get_crate_data(cstore: &CStore, cnum: ast::crate_num)\n                    -> @crate_metadata {\n-    return cstore.metas.get(&cnum);\n+    return *cstore.metas.get(&cnum);\n }\n \n-pub fn get_crate_hash(cstore: @mut CStore, cnum: ast::crate_num) -> @~str {\n+pub fn get_crate_hash(cstore: &CStore, cnum: ast::crate_num) -> @~str {\n     let cdata = get_crate_data(cstore, cnum);\n     decoder::get_crate_hash(cdata.data)\n }\n \n-pub fn get_crate_vers(cstore: @mut CStore, cnum: ast::crate_num) -> @~str {\n+pub fn get_crate_vers(cstore: &CStore, cnum: ast::crate_num) -> @~str {\n     let cdata = get_crate_data(cstore, cnum);\n     decoder::get_crate_vers(cdata.data)\n }\n \n-pub fn set_crate_data(cstore: @mut CStore,\n+pub fn set_crate_data(cstore: &mut CStore,\n                       cnum: ast::crate_num,\n                       data: @crate_metadata) {\n-    let metas = cstore.metas;\n-    metas.insert(cnum, data);\n+    cstore.metas.insert(cnum, data);\n }\n \n-pub fn have_crate_data(cstore: @mut CStore, cnum: ast::crate_num) -> bool {\n+pub fn have_crate_data(cstore: &CStore, cnum: ast::crate_num) -> bool {\n     cstore.metas.contains_key(&cnum)\n }\n \n-pub fn iter_crate_data(cstore: @mut CStore,\n+pub fn iter_crate_data(cstore: &CStore,\n                        i: &fn(ast::crate_num, @crate_metadata)) {\n-    let metas = cstore.metas;\n-    for metas.each |&k, &v| {\n+    for cstore.metas.each |&(&k, &v)| {\n         i(k, v);\n     }\n }\n \n-pub fn add_used_crate_file(cstore: @mut CStore, lib: &Path) {\n-    let cstore = &mut *cstore;\n+pub fn add_used_crate_file(cstore: &mut CStore, lib: &Path) {\n     if !vec::contains(cstore.used_crate_files, lib) {\n         cstore.used_crate_files.push(copy *lib);\n     }\n }\n \n-pub fn get_used_crate_files(cstore: @mut CStore) -> ~[Path] {\n+pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n     return /*bad*/copy cstore.used_crate_files;\n }\n \n-pub fn add_used_library(cstore: @mut CStore, lib: @~str) -> bool {\n+pub fn add_used_library(cstore: &mut CStore, lib: @~str) -> bool {\n     fail_unless!(*lib != ~\"\");\n \n-    let cstore = &mut *cstore;\n     if cstore.used_libraries.contains(&*lib) { return false; }\n     cstore.used_libraries.push(/*bad*/ copy *lib);\n     true\n }\n \n-pub fn get_used_libraries(cstore: @mut CStore) -> ~[~str] {\n+pub fn get_used_libraries(cstore: &CStore) -> ~[~str] {\n     /*bad*/copy cstore.used_libraries\n }\n \n-pub fn add_used_link_args(cstore: @mut CStore, args: &str) {\n+pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n     for args.each_split_char(' ') |s| {\n         cstore.used_link_args.push(s.to_owned());\n     }\n }\n \n-pub fn get_used_link_args(cstore: @mut CStore) -> ~[~str] {\n+pub fn get_used_link_args(cstore: &CStore) -> ~[~str] {\n     /*bad*/copy cstore.used_link_args\n }\n \n-pub fn add_extern_mod_stmt_cnum(cstore: @mut CStore,\n+pub fn add_extern_mod_stmt_cnum(cstore: &mut CStore,\n                                 emod_id: ast::node_id,\n                                 cnum: ast::crate_num) {\n-    let extern_mod_crate_map = cstore.extern_mod_crate_map;\n-    extern_mod_crate_map.insert(emod_id, cnum);\n+    cstore.extern_mod_crate_map.insert(emod_id, cnum);\n }\n \n-pub fn find_extern_mod_stmt_cnum(cstore: @mut CStore,\n+pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n                                  emod_id: ast::node_id)\n                        -> Option<ast::crate_num> {\n-    let extern_mod_crate_map = cstore.extern_mod_crate_map;\n-    extern_mod_crate_map.find(&emod_id)\n+    cstore.extern_mod_crate_map.find(&emod_id).map_consume(|x| *x)\n }\n \n // returns hashes of crates directly used by this crate. Hashes are sorted by\n // (crate name, crate version, crate hash) in lexicographic order (not semver)\n-pub fn get_dep_hashes(cstore: @mut CStore) -> ~[~str] {\n+pub fn get_dep_hashes(cstore: &CStore) -> ~[~str] {\n     struct crate_hash { name: @~str, vers: @~str, hash: @~str }\n     let mut result = ~[];\n \n-    let extern_mod_crate_map = cstore.extern_mod_crate_map;\n-    for extern_mod_crate_map.each_value |&cnum| {\n+    for cstore.extern_mod_crate_map.each_value |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         let vers = decoder::get_crate_vers(cdata.data);"}, {"sha": "0e9246eedbc8734395fec772e826b04b18777869", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -1132,7 +1132,7 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n     }\n \n     match cdata.cnum_map.find(&did.crate) {\n-      option::Some(n) => ast::def_id { crate: n, node: did.node },\n+      option::Some(&n) => ast::def_id { crate: n, node: did.node },\n       option::None => fail!(~\"didn't find a crate in the cnum_map\")\n     }\n }"}, {"sha": "675a7837173a5b44ccff7825584eb051855da4cd", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -17,23 +17,23 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n+use middle::trans::reachable;\n use middle::ty::node_id_to_type;\n use middle::ty;\n use middle;\n use util::ppaux::ty_to_str;\n \n use core::flate;\n use core::hash::{Hash, HashUtil};\n+use core::hashmap::linear::{LinearMap, LinearSet};\n use core::int;\n use core::io::{Writer, WriterUtil};\n use core::io;\n use core::str;\n use core::to_bytes::IterBytes;\n use core::uint;\n use core::vec;\n-use std::oldmap::HashMap;\n use std::serialize::Encodable;\n-use std::{ebml, oldmap};\n use std;\n use syntax::ast::*;\n use syntax::ast;\n@@ -49,7 +49,7 @@ use syntax;\n use writer = std::ebml::writer;\n \n // used by astencode:\n-type abbrev_map = oldmap::HashMap<ty::t, tyencode::ty_abbrev>;\n+type abbrev_map = @mut LinearMap<ty::t, tyencode::ty_abbrev>;\n \n pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n                                    ebml_w: writer::Encoder,\n@@ -59,10 +59,10 @@ pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n pub struct EncodeParams {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n-    reachable: HashMap<ast::node_id, ()>,\n+    reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: HashMap<ast::node_id, ~str>,\n-    discrim_symbols: HashMap<ast::node_id, ~str>,\n+    item_symbols: @mut LinearMap<ast::node_id, ~str>,\n+    discrim_symbols: @mut LinearMap<ast::node_id, ~str>,\n     link_meta: LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item\n@@ -86,18 +86,18 @@ pub struct EncodeContext {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n-    reachable: HashMap<ast::node_id, ()>,\n+    reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: HashMap<ast::node_id, ~str>,\n-    discrim_symbols: HashMap<ast::node_id, ~str>,\n+    item_symbols: @mut LinearMap<ast::node_id, ~str>,\n+    discrim_symbols: @mut LinearMap<ast::node_id, ~str>,\n     link_meta: LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item,\n     type_abbrevs: abbrev_map\n }\n \n pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n-    ecx.reachable.contains_key(&id)\n+    ecx.reachable.contains(&id)\n }\n \n fn encode_name(ecx: @EncodeContext, ebml_w: writer::Encoder, name: ident) {\n@@ -188,7 +188,7 @@ fn encode_type_param_bounds(ebml_w: writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n     let ty_param_bounds =\n-        @params.map_to_vec(|param| ecx.tcx.ty_param_bounds.get(&param.id));\n+        @params.map_to_vec(|param| *ecx.tcx.ty_param_bounds.get(&param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n@@ -229,7 +229,7 @@ fn encode_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n-        Some(ref x) => {\n+        Some(x) => {\n             debug!(\"encode_symbol(id=%?, str=%s)\", id, *x);\n             ebml_w.writer.write(str::to_bytes(*x));\n         }\n@@ -244,7 +244,7 @@ fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n fn encode_discriminant(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(&id)));\n+    ebml_w.writer.write(str::to_bytes(*ecx.discrim_symbols.get(&id)));\n     ebml_w.end_tag();\n }\n \n@@ -1320,7 +1320,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x74, //'t' as u8,\n       0, 0, 0, 1 ];\n \n-pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n+pub fn encode_metadata(+parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n     let mut stats = Stats {\n         inline_bytes: 0,\n@@ -1334,18 +1334,21 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         total_bytes: 0,\n         n_inlines: 0\n     };\n+    let EncodeParams{item_symbols, diag, tcx, reachable, reexports2,\n+                     discrim_symbols, cstore, encode_inlined_item,\n+                     link_meta, _} = parms;\n     let ecx = @EncodeContext {\n-        diag: parms.diag,\n-        tcx: parms.tcx,\n+        diag: diag,\n+        tcx: tcx,\n         stats: @mut stats,\n-        reachable: parms.reachable,\n-        reexports2: parms.reexports2,\n-        item_symbols: parms.item_symbols,\n-        discrim_symbols: parms.discrim_symbols,\n-        link_meta: /*bad*/copy parms.link_meta,\n-        cstore: parms.cstore,\n-        encode_inlined_item: parms.encode_inlined_item,\n-        type_abbrevs: ty::new_ty_hash()\n+        reachable: reachable,\n+        reexports2: reexports2,\n+        item_symbols: item_symbols,\n+        discrim_symbols: discrim_symbols,\n+        link_meta: link_meta,\n+        cstore: cstore,\n+        encode_inlined_item: encode_inlined_item,\n+        type_abbrevs: @mut LinearMap::new()\n      };\n \n     let ebml_w = writer::Encoder(wr as @io::Writer);\n@@ -1385,7 +1388,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     ecx.stats.total_bytes = wr.pos;\n \n-    if (parms.tcx.sess.meta_stats()) {\n+    if (tcx.sess.meta_stats()) {\n \n         do wr.bytes.each |e| {\n             if *e == 0 {"}, {"sha": "1eb82c6277eb56ee2737528a2e5418022f6f9426", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -337,7 +337,7 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n                                          pos: pos,\n                                          len: len };\n         match st.tcx.rcache.find(&key) {\n-          Some(tt) => return tt,\n+          Some(&tt) => return tt,\n           None => {\n             let ps = @mut PState {pos: pos ,.. copy *st};\n             let tt = parse_ty(ps, conv);"}, {"sha": "021d472fa0ef09e8389159638d5b91d274eca07e", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -16,11 +16,11 @@ use core::prelude::*;\n use middle::ty::{Vid, param_ty};\n use middle::ty;\n \n+use core::hashmap::linear::LinearMap;\n use core::io::WriterUtil;\n use core::io;\n use core::uint;\n use core::vec;\n-use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::diagnostic::span_handler;\n use syntax::print::pprust::*;\n@@ -47,7 +47,7 @@ pub struct ty_abbrev {\n \n pub enum abbrev_ctxt {\n     ac_no_abbrevs,\n-    ac_use_abbrevs(HashMap<ty::t, ty_abbrev>),\n+    ac_use_abbrevs(@mut LinearMap<ty::t, ty_abbrev>),\n }\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {"}, {"sha": "e1863a9f4002345fe3810fcd78d151ccfa03b4fa", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -861,7 +861,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for tcx.freevars.find(&id).each |fv| {\n+    for tcx.freevars.find(&id).each |&fv| {\n         do ebml_w.tag(c::tag_table_freevars) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -873,7 +873,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n     }\n \n     let lid = ast::def_id { crate: ast::local_crate, node: id };\n-    for tcx.tcache.find(&lid).each |tpbt| {\n+    for tcx.tcache.find(&lid).each |&tpbt| {\n         do ebml_w.tag(c::tag_table_tcache) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -882,7 +882,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for tcx.ty_param_bounds.find(&id).each |pbs| {\n+    for tcx.ty_param_bounds.find(&id).each |&pbs| {\n         do ebml_w.tag(c::tag_table_param_bounds) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -905,7 +905,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n     //    }\n     //}\n \n-    if maps.mutbl_map.contains_key(&id) {\n+    if maps.mutbl_map.contains(&id) {\n         do ebml_w.tag(c::tag_table_mutbl) {\n             ebml_w.id(id);\n         }\n@@ -915,7 +915,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         do ebml_w.tag(c::tag_table_last_use) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec(/*bad*/ copy *m) |id| {\n+                do ebml_w.emit_from_vec(/*bad*/ copy **m) |id| {\n                     id.encode(&ebml_w);\n                 }\n             }\n@@ -931,7 +931,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for maps.vtable_map.find(&id).each |dr| {\n+    for maps.vtable_map.find(&id).each |&dr| {\n         do ebml_w.tag(c::tag_table_vtable_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -949,13 +949,13 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for maps.moves_map.find(&id).each |_| {\n+    if maps.moves_map.contains(&id) {\n         do ebml_w.tag(c::tag_table_moves_map) {\n             ebml_w.id(id);\n         }\n     }\n \n-    for maps.capture_map.find(&id).each |cap_vars| {\n+    for maps.capture_map.find(&id).each |&cap_vars| {\n         do ebml_w.tag(c::tag_table_capture_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -1097,9 +1097,9 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                tag, id, id0);\n \n         if tag == (c::tag_table_mutbl as uint) {\n-            dcx.maps.mutbl_map.insert(id, ());\n+            dcx.maps.mutbl_map.insert(id);\n         } else if tag == (c::tag_table_moves_map as uint) {\n-            dcx.maps.moves_map.insert(id, ());\n+            dcx.maps.moves_map.insert(id);\n         } else {\n             let val_doc = entry_doc[c::tag_table_val as uint];\n             let val_dsr = &reader::Decoder(val_doc);"}, {"sha": "045a3b2b67719fedcbdfedc08b2da2304b39adbb", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -31,8 +31,8 @@ use middle::mem_categorization::{lp_comp, lp_deref, lp_local};\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use core::hashmap::linear::LinearSet;\n use core::uint;\n-use std::oldmap::HashMap;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n use syntax::ast_util;\n@@ -44,7 +44,7 @@ struct CheckLoanCtxt {\n     bccx: @BorrowckCtxt,\n     req_maps: ReqMaps,\n \n-    reported: HashMap<ast::node_id, ()>,\n+    reported: LinearSet<ast::node_id>,\n \n     declared_purity: @mut ast::purity,\n     fn_args: @mut @~[ast::node_id]\n@@ -63,12 +63,12 @@ enum purity_cause {\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-                   req_maps: ReqMaps,\n+                   +req_maps: ReqMaps,\n                    crate: @ast::crate) {\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n         req_maps: req_maps,\n-        reported: HashMap(),\n+        reported: LinearSet::new(),\n         declared_purity: @mut ast::impure_fn,\n         fn_args: @mut @~[]\n     };\n@@ -104,9 +104,9 @@ pub impl assignment_type {\n }\n \n pub impl CheckLoanCtxt {\n-    fn tcx(@mut self) -> ty::ctxt { self.bccx.tcx }\n+    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn purity(@mut self, scope_id: ast::node_id) -> Option<purity_cause> {\n+    fn purity(&mut self, scope_id: ast::node_id) -> Option<purity_cause> {\n         let default_purity = match *self.declared_purity {\n           // an unsafe declaration overrides all\n           ast::unsafe_fn => return None,\n@@ -122,43 +122,38 @@ pub impl CheckLoanCtxt {\n         // purity.  if so, that overrides the declaration.\n \n         let mut scope_id = scope_id;\n-        let region_map = self.tcx().region_map;\n-        let pure_map = self.req_maps.pure_map;\n         loop {\n-            match pure_map.find(&scope_id) {\n+            match self.req_maps.pure_map.find(&scope_id) {\n               None => (),\n-              Some(ref e) => return Some(pc_cmt((*e)))\n+              Some(e) => return Some(pc_cmt(*e))\n             }\n \n-            match region_map.find(&scope_id) {\n+            match self.tcx().region_map.find(&scope_id) {\n               None => return default_purity,\n-              Some(next_scope_id) => scope_id = next_scope_id\n+              Some(&next_scope_id) => scope_id = next_scope_id\n             }\n         }\n     }\n \n-    fn walk_loans(@mut self,\n-                  scope_id: ast::node_id,\n+    fn walk_loans(&self,\n+                  mut scope_id: ast::node_id,\n                   f: &fn(v: &Loan) -> bool) {\n-        let mut scope_id = scope_id;\n-        let region_map = self.tcx().region_map;\n-        let req_loan_map = self.req_maps.req_loan_map;\n \n         loop {\n-            for req_loan_map.find(&scope_id).each |loans| {\n+            for self.req_maps.req_loan_map.find(&scope_id).each |loans| {\n                 for loans.each |loan| {\n                     if !f(loan) { return; }\n                 }\n             }\n \n-            match region_map.find(&scope_id) {\n+            match self.tcx().region_map.find(&scope_id) {\n               None => return,\n-              Some(next_scope_id) => scope_id = next_scope_id,\n+              Some(&next_scope_id) => scope_id = next_scope_id,\n             }\n         }\n     }\n \n-    fn walk_loans_of(@mut self,\n+    fn walk_loans_of(&mut self,\n                      scope_id: ast::node_id,\n                      lp: @loan_path,\n                      f: &fn(v: &Loan) -> bool) {\n@@ -175,7 +170,7 @@ pub impl CheckLoanCtxt {\n     // note: we take opt_expr and expr_id separately because for\n     // overloaded operators the callee has an id but no expr.\n     // annoying.\n-    fn check_pure_callee_or_arg(@mut self,\n+    fn check_pure_callee_or_arg(&mut self,\n                                 pc: purity_cause,\n                                 opt_expr: Option<@ast::expr>,\n                                 callee_id: ast::node_id,\n@@ -202,7 +197,7 @@ pub impl CheckLoanCtxt {\n           Some(expr) => {\n             match expr.node {\n               ast::expr_path(_) if pc == pc_pure_fn => {\n-                let def = self.tcx().def_map.get(&expr.id);\n+                let def = *self.tcx().def_map.get(&expr.id);\n                 let did = ast_util::def_id_of_def(def);\n                 let is_fn_arg =\n                     did.crate == ast::local_crate &&\n@@ -242,7 +237,7 @@ pub impl CheckLoanCtxt {\n \n     // True if the expression with the given `id` is a stack closure.\n     // The expression must be an expr_fn_block(*)\n-    fn is_stack_closure(@mut self, id: ast::node_id) -> bool {\n+    fn is_stack_closure(&mut self, id: ast::node_id) -> bool {\n         let fn_ty = ty::node_id_to_type(self.tcx(), id);\n         match ty::get(fn_ty).sty {\n             ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n@@ -251,10 +246,10 @@ pub impl CheckLoanCtxt {\n         }\n     }\n \n-    fn is_allowed_pure_arg(@mut self, expr: @ast::expr) -> bool {\n+    fn is_allowed_pure_arg(&mut self, expr: @ast::expr) -> bool {\n         return match expr.node {\n           ast::expr_path(_) => {\n-            let def = self.tcx().def_map.get(&expr.id);\n+            let def = *self.tcx().def_map.get(&expr.id);\n             let did = ast_util::def_id_of_def(def);\n             did.crate == ast::local_crate &&\n                 (*self.fn_args).contains(&(did.node))\n@@ -264,18 +259,18 @@ pub impl CheckLoanCtxt {\n         };\n     }\n \n-    fn check_for_conflicting_loans(@mut self, scope_id: ast::node_id) {\n+    fn check_for_conflicting_loans(&mut self, scope_id: ast::node_id) {\n         debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n \n         let new_loans = match self.req_maps.req_loan_map.find(&scope_id) {\n             None => return,\n-            Some(loans) => loans\n+            Some(&loans) => loans\n         };\n         let new_loans: &mut ~[Loan] = new_loans;\n \n         debug!(\"new_loans has length %?\", new_loans.len());\n \n-        let par_scope_id = self.tcx().region_map.get(&scope_id);\n+        let par_scope_id = *self.tcx().region_map.get(&scope_id);\n         for self.walk_loans(par_scope_id) |old_loan| {\n             debug!(\"old_loan=%?\", self.bccx.loan_to_repr(old_loan));\n \n@@ -294,7 +289,7 @@ pub impl CheckLoanCtxt {\n         }\n     }\n \n-    fn report_error_if_loans_conflict(@mut self,\n+    fn report_error_if_loans_conflict(&self,\n                                       old_loan: &Loan,\n                                       new_loan: &Loan) {\n         if old_loan.lp != new_loan.lp {\n@@ -330,19 +325,19 @@ pub impl CheckLoanCtxt {\n         }\n     }\n \n-    fn is_local_variable(@mut self, cmt: cmt) -> bool {\n+    fn is_local_variable(&self, cmt: cmt) -> bool {\n         match cmt.cat {\n           cat_local(_) => true,\n           _ => false\n         }\n     }\n \n-    fn check_assignment(@mut self, at: assignment_type, ex: @ast::expr) {\n+    fn check_assignment(&mut self, at: assignment_type, ex: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n         let cmt = match self.bccx.tcx.adjustments.find(&ex.id) {\n             None => self.bccx.cat_expr_unadjusted(ex),\n-            Some(adj) => self.bccx.cat_expr_autoderefd(ex, adj)\n+            Some(&adj) => self.bccx.cat_expr_autoderefd(ex, adj)\n         };\n \n         debug!(\"check_assignment(cmt=%s)\",\n@@ -369,14 +364,15 @@ pub impl CheckLoanCtxt {\n         match self.purity(ex.id) {\n           None => (),\n           Some(pc_cmt(_)) => {\n+            let purity = self.purity(ex.id).get();\n             // Subtle: Issue #3162.  If we are enforcing purity\n             // because there is a reference to aliasable, mutable data\n             // that we require to be immutable, we can't allow writes\n             // even to data owned by the current stack frame.  This is\n             // because that aliasable data might have been located on\n             // the current stack frame, we don't know.\n             self.report_purity_error(\n-                self.purity(ex.id).get(),\n+                purity,\n                 ex.span,\n                 at.ing_form(self.bccx.cmt_to_str(cmt)));\n           }\n@@ -404,7 +400,7 @@ pub impl CheckLoanCtxt {\n         self.add_write_guards_if_necessary(cmt);\n     }\n \n-    fn add_write_guards_if_necessary(@mut self, cmt: cmt) {\n+    fn add_write_guards_if_necessary(&mut self, cmt: cmt) {\n         match cmt.cat {\n             cat_deref(base, deref_count, ptr_kind) => {\n                 self.add_write_guards_if_necessary(base);\n@@ -415,7 +411,7 @@ pub impl CheckLoanCtxt {\n                             id: base.id,\n                             derefs: deref_count\n                         };\n-                        self.bccx.write_guard_map.insert(key, ());\n+                        self.bccx.write_guard_map.insert(key);\n                     }\n                     _ => {}\n                 }\n@@ -427,7 +423,7 @@ pub impl CheckLoanCtxt {\n         }\n     }\n \n-    fn check_for_loan_conflicting_with_assignment(@mut self,\n+    fn check_for_loan_conflicting_with_assignment(&mut self,\n                                                   at: assignment_type,\n                                                   ex: @ast::expr,\n                                                   cmt: cmt,\n@@ -466,16 +462,15 @@ pub impl CheckLoanCtxt {\n         }\n     }\n \n-    fn report_purity_error(@mut self, pc: purity_cause, sp: span, msg: ~str) {\n+    fn report_purity_error(&mut self, pc: purity_cause, sp: span, msg: ~str) {\n         match pc {\n           pc_pure_fn => {\n             self.tcx().sess.span_err(\n                 sp,\n                 fmt!(\"%s prohibited in pure context\", msg));\n           }\n           pc_cmt(ref e) => {\n-            let reported = self.reported;\n-            if reported.insert((*e).cmt.id, ()) {\n+            if self.reported.insert((*e).cmt.id) {\n                 self.tcx().sess.span_err(\n                     (*e).cmt.span,\n                     fmt!(\"illegal borrow unless pure: %s\",\n@@ -522,7 +517,7 @@ pub impl CheckLoanCtxt {\n         }\n     }\n \n-    fn analyze_move_out_from_cmt(@mut self, cmt: cmt) -> MoveError {\n+    fn analyze_move_out_from_cmt(&mut self, cmt: cmt) -> MoveError {\n         debug!(\"check_move_out_from_cmt(cmt=%s)\",\n                self.bccx.cmt_to_repr(cmt));\n \n@@ -555,7 +550,7 @@ pub impl CheckLoanCtxt {\n         return MoveOk;\n     }\n \n-    fn check_call(@mut self,\n+    fn check_call(&mut self,\n                   expr: @ast::expr,\n                   callee: Option<@ast::expr>,\n                   callee_id: ast::node_id,\n@@ -695,7 +690,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n \n     self.check_for_conflicting_loans(expr.id);\n \n-    if self.bccx.moves_map.contains_key(&expr.id) {\n+    if self.bccx.moves_map.contains(&expr.id) {\n         self.check_move_out_from_expr(expr);\n     }\n "}, {"sha": "bd6a9ab30976d781cb1f5b5901e4f2ba3fc5ae93", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -32,9 +32,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{expr_repr, region_to_str};\n \n-use core::hashmap::linear::LinearSet;\n+use core::hashmap::linear::{LinearSet, LinearMap};\n use core::vec;\n-use std::oldmap::HashMap;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n use syntax::codemap::span;\n@@ -80,7 +79,8 @@ struct GatherLoanCtxt {\n pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n     let glcx = @mut GatherLoanCtxt {\n         bccx: bccx,\n-        req_maps: ReqMaps { req_loan_map: HashMap(), pure_map: HashMap() },\n+        req_maps: ReqMaps { req_loan_map: LinearMap::new(),\n+                            pure_map: LinearMap::new() },\n         item_ub: 0,\n         root_ub: 0,\n         ignore_adjustments: LinearSet::new()\n@@ -90,7 +90,8 @@ pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n                                           visit_stmt: add_stmt_to_map,\n                                           .. *visit::default_visitor()});\n     visit::visit_crate(*crate, glcx, v);\n-    return glcx.req_maps;\n+    let @GatherLoanCtxt{req_maps, _} = glcx;\n+    return req_maps;\n }\n \n fn req_loans_in_fn(fk: &visit::fn_kind,\n@@ -132,7 +133,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n     {\n         let mut this = &mut *self;\n         if !this.ignore_adjustments.contains(&ex.id) {\n-            for tcx.adjustments.find(&ex.id).each |adjustments| {\n+            for tcx.adjustments.find(&ex.id).each |&adjustments| {\n                 this.guarantee_adjustments(ex, *adjustments);\n             }\n         }\n@@ -257,7 +258,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         // (if used like `a.b(...)`), the call where it's an argument\n         // (if used like `x(a.b)`), or the block (if used like `let x\n         // = a.b`).\n-        let scope_r = ty::re_scope(self.tcx().region_map.get(&ex.id));\n+        let scope_r = ty::re_scope(*self.tcx().region_map.get(&ex.id));\n         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n         visit::visit_expr(ex, self, vt);\n@@ -429,8 +430,7 @@ pub impl GatherLoanCtxt {\n                             // if the scope is some block/expr in the\n                             // fn, then just require that this scope\n                             // be pure\n-                            let pure_map = self.req_maps.pure_map;\n-                            pure_map.insert(pure_id, *e);\n+                            self.req_maps.pure_map.insert(pure_id, *e);\n                             self.bccx.stats.req_pure_paths += 1;\n \n                             debug!(\"requiring purity for scope %?\",\n@@ -575,12 +575,11 @@ pub impl GatherLoanCtxt {\n         match self.req_maps.req_loan_map.find(&scope_id) {\n             Some(req_loans) => {\n                 req_loans.push_all(loans);\n+                return;\n             }\n-            None => {\n-                let req_loan_map = self.req_maps.req_loan_map;\n-                req_loan_map.insert(scope_id, @mut loans);\n-            }\n+            None => {}\n         }\n+        self.req_maps.req_loan_map.insert(scope_id, @mut loans);\n     }\n \n     fn gather_pat(@mut self,\n@@ -683,7 +682,7 @@ fn add_stmt_to_map(stmt: @ast::stmt,\n                    vt: visit::vt<@mut GatherLoanCtxt>) {\n     match stmt.node {\n         ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n-            self.bccx.stmt_map.insert(id, ());\n+            self.bccx.stmt_map.insert(id);\n         }\n         _ => ()\n     }"}, {"sha": "c0551436edef96a322f4f6a86511ccab00d46ae7", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -130,7 +130,7 @@ pub impl LoanContext {\n           }\n           cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n               // FIXME(#4903)\n-            let local_scope_id = self.bccx.tcx.region_map.get(&local_id);\n+            let local_scope_id = *self.bccx.tcx.region_map.get(&local_id);\n             self.issue_loan(cmt, ty::re_scope(local_scope_id), loan_kind,\n                             owns_lent_data)\n           }"}, {"sha": "cdec64b7b4c989f0a5cb51d3db275cecc93134fe", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -234,10 +234,10 @@ use middle::moves;\n use util::common::{indenter, stmt_set};\n use util::ppaux::note_and_explain_region;\n \n+use core::hashmap::linear::{LinearSet, LinearMap};\n use core::io;\n use core::result::{Result, Ok, Err};\n use core::to_bytes;\n-use std::oldmap::{HashMap, Set};\n use syntax::ast::{mutability, m_mutbl, m_imm, m_const};\n use syntax::ast;\n use syntax::codemap::span;\n@@ -260,9 +260,9 @@ pub fn check_crate(\n         moves_map: moves_map,\n         capture_map: capture_map,\n         root_map: root_map(),\n-        mutbl_map: HashMap(),\n-        write_guard_map: HashMap(),\n-        stmt_map: HashMap(),\n+        mutbl_map: @mut LinearSet::new(),\n+        write_guard_map: @mut LinearSet::new(),\n+        stmt_map: @mut LinearSet::new(),\n         stats: @mut BorrowStats {\n             loaned_paths_same: 0,\n             loaned_paths_imm: 0,\n@@ -333,7 +333,7 @@ pub struct RootInfo {\n // a map mapping id's of expressions of gc'd type (@T, @[], etc) where\n // the box needs to be kept live to the id of the scope for which they\n // must stay live.\n-pub type root_map = HashMap<root_map_key, RootInfo>;\n+pub type root_map = @mut LinearMap<root_map_key, RootInfo>;\n \n // the keys to the root map combine the `id` of the expression with\n // the number of types that it is autodereferenced.  So, for example,\n@@ -348,11 +348,11 @@ pub struct root_map_key {\n \n // set of ids of local vars / formal arguments that are modified / moved.\n // this is used in trans for optimization purposes.\n-pub type mutbl_map = HashMap<ast::node_id, ()>;\n+pub type mutbl_map = @mut LinearSet<ast::node_id>;\n \n // A set containing IDs of expressions of gc'd type that need to have a write\n // guard.\n-pub type write_guard_map = HashMap<root_map_key, ()>;\n+pub type write_guard_map = @mut LinearSet<root_map_key>;\n \n // Errors that can occur\n #[deriving(Eq)]\n@@ -405,8 +405,8 @@ pub struct Loan {\n /// - `pure_map`: map from block/expr that must be pure to the error message\n ///   that should be reported if they are not pure\n pub struct ReqMaps {\n-    req_loan_map: HashMap<ast::node_id, @mut ~[Loan]>,\n-    pure_map: HashMap<ast::node_id, bckerr>\n+    req_loan_map: LinearMap<ast::node_id, @mut ~[Loan]>,\n+    pure_map: LinearMap<ast::node_id, bckerr>\n }\n \n pub fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T,\n@@ -450,7 +450,7 @@ impl to_bytes::IterBytes for root_map_key {\n }\n \n pub fn root_map() -> root_map {\n-    return HashMap();\n+    return @mut LinearMap::new();\n }\n \n // ___________________________________________________________________________\n@@ -541,7 +541,7 @@ pub impl BorrowckCtxt {\n     fn add_to_mutbl_map(&self, cmt: cmt) {\n         match cmt.cat {\n           cat_local(id) | cat_arg(id) => {\n-            self.mutbl_map.insert(id, ());\n+            self.mutbl_map.insert(id);\n           }\n           cat_stack_upvar(cmt) => {\n             self.add_to_mutbl_map(cmt);"}, {"sha": "2ce47d8d0a17c0374166d4985d615ebebc9bd9f1", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -108,7 +108,7 @@ pub impl<'self> PreserveCtxt<'self> {\n                 // Maybe if we pass in the parent instead here,\n                 // we can prevent the \"scope not found\" error\n                 debug!(\"scope_region thing: %? \", cmt.id);\n-                ty::re_scope(self.tcx().region_map.get(&cmt.id))\n+                ty::re_scope(*self.tcx().region_map.get(&cmt.id))\n             };\n \n             self.compare_scope(cmt, scope_region)\n@@ -128,26 +128,26 @@ pub impl<'self> PreserveCtxt<'self> {\n                     cmt.span,\n                     ~\"preserve() called with local and !root_managed_data\");\n             }\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = *self.tcx().region_map.get(&local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_binding(local_id) => {\n             // Bindings are these kind of weird implicit pointers (cc\n             // #2329).  We require (in gather_loans) that they be\n             // rooted in an immutable location.\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = *self.tcx().region_map.get(&local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_arg(local_id) => {\n             // This can happen as not all args are lendable (e.g., &&\n             // modes).  In that case, the caller guarantees stability\n             // for at least the scope of the fn.  This is basically a\n             // deref of a region ptr.\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = *self.tcx().region_map.get(&local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_self(local_id) => {\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n+            let local_scope_id = *self.tcx().region_map.get(&local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n@@ -371,7 +371,7 @@ pub impl<'self> PreserveCtxt<'self> {\n                 // scope_id;`. Though that would potentially re-introduce\n                 // the ICE. See #3511 for more details.\n                 let scope_to_use = if\n-                    self.bccx.stmt_map.contains_key(&scope_id) {\n+                    self.bccx.stmt_map.contains(&scope_id) {\n                     // Root it in its parent scope, b/c\n                     // trans won't introduce a new scope for the\n                     // stmt"}, {"sha": "5a5ba6918d71863c9b78c55bceacfef424775829", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -124,12 +124,12 @@ pub fn check_expr(sess: Session,\n                               items without type parameters\");\n             }\n             match def_map.find(&e.id) {\n-              Some(def_const(_)) |\n-              Some(def_fn(_, _)) |\n-              Some(def_variant(_, _)) |\n-              Some(def_struct(_)) => { }\n+              Some(&def_const(_)) |\n+              Some(&def_fn(_, _)) |\n+              Some(&def_variant(_, _)) |\n+              Some(&def_struct(_)) => { }\n \n-              Some(def) => {\n+              Some(&def) => {\n                 debug!(\"(checking const) found bad def: %?\", def);\n                 sess.span_err(\n                     e.span,\n@@ -143,8 +143,8 @@ pub fn check_expr(sess: Session,\n           }\n           expr_call(callee, _, NoSugar) => {\n             match def_map.find(&callee.id) {\n-                Some(def_struct(*)) => {}    // OK.\n-                Some(def_variant(*)) => {}    // OK.\n+                Some(&def_struct(*)) => {}    // OK.\n+                Some(&def_variant(*)) => {}    // OK.\n                 _ => {\n                     sess.span_err(\n                         e.span,\n@@ -238,7 +238,7 @@ pub fn check_item_recursion(sess: Session,\n         match e.node {\n           expr_path(*) => {\n             match env.def_map.find(&e.id) {\n-              Some(def_const(def_id)) => {\n+              Some(&def_const(def_id)) => {\n                 if ast_util::is_local(def_id) {\n                   match env.ast_map.get(&def_id.node) {\n                     ast_map::node_item(it, _) => {"}, {"sha": "3f3ffe1598ae7ccbb492a13e9dd9d4a927298136", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -55,7 +55,7 @@ pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n         return false;\n     }\n \n-    !cx.moves_map.contains_key(&expr.id)\n+    !cx.moves_map.contains(&expr.id)\n }\n \n pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n@@ -303,8 +303,8 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n       pat_wild => { None }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(def_variant(_, id)) => Some(variant(id)),\n-          Some(def_const(did)) => {\n+          Some(&def_variant(_, id)) => Some(variant(id)),\n+          Some(&def_const(did)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).get();\n             Some(val(eval_const_expr(cx.tcx, const_expr)))\n           }\n@@ -317,7 +317,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n       }\n       pat_struct(*) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(def_variant(_, id)) => Some(variant(id)),\n+          Some(&def_variant(_, id)) => Some(variant(id)),\n           _ => Some(single)\n         }\n       }\n@@ -339,7 +339,7 @@ pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n       pat_wild => { true }\n       pat_ident(_, _, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(def_variant(_, _)) | Some(def_const(*)) => { false }\n+          Some(&def_variant(_, _)) | Some(&def_const(*)) => { false }\n           _ => { true }\n         }\n       }\n@@ -490,14 +490,14 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_ident(_, _, _) => {\n                 match cx.tcx.def_map.find(&pat_id) {\n-                    Some(def_variant(_, id)) => {\n+                    Some(&def_variant(_, id)) => {\n                         if variant(id) == ctor_id {\n                             Some(vec::from_slice(r.tail()))\n                         } else {\n                             None\n                         }\n                     }\n-                    Some(def_const(did)) => {\n+                    Some(&def_const(did)) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n@@ -527,7 +527,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 }\n             }\n             pat_enum(_, args) => {\n-                match cx.tcx.def_map.get(&pat_id) {\n+                match *cx.tcx.def_map.get(&pat_id) {\n                     def_const(did) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n@@ -569,7 +569,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n-                match cx.tcx.def_map.get(&pat_id) {\n+                match *cx.tcx.def_map.get(&pat_id) {\n                     def_variant(_, variant_id) => {\n                         if variant(variant_id) == ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n@@ -714,12 +714,12 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n \n pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n     match cx.tcx.def_map.find(&pat.id) {\n-      Some(def_variant(enum_id, _)) => {\n+      Some(&def_variant(enum_id, _)) => {\n         if vec::len(*ty::enum_variants(cx.tcx, enum_id)) != 1u {\n             return true;\n         }\n       }\n-      Some(def_const(*)) => return true,\n+      Some(&def_const(*)) => return true,\n       _ => ()\n     }\n \n@@ -766,7 +766,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                     by_ref_span = Some(span);\n                 }\n                 bind_infer => {\n-                    if cx.moves_map.contains_key(&id) {\n+                    if cx.moves_map.contains(&id) {\n                         any_by_move = true;\n                     }\n                 }\n@@ -806,7 +806,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     pat_ident(_, _, sub) => {\n-                        if cx.moves_map.contains_key(&p.id) {\n+                        if cx.moves_map.contains(&p.id) {\n                             check_move(p, sub);\n                         }\n                     }\n@@ -832,7 +832,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                                 behind_bad_pointer);\n \n                         if behind_bad_pointer &&\n-                            cx.moves_map.contains_key(&pat.id)\n+                            cx.moves_map.contains(&pat.id)\n                         {\n                             cx.tcx.sess.span_err(\n                                 pat.span,"}, {"sha": "8cf6e931c92cb99124a8f2ccbb98dfad35285547", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -12,16 +12,16 @@ use core::prelude::*;\n \n use metadata::csearch;\n use middle::astencode;\n-use middle::resolve;\n use middle::ty;\n use middle;\n \n use core::float;\n use core::vec;\n+use std::oldmap::HashMap;\n use syntax::{ast, ast_map, ast_util, visit};\n use syntax::ast::*;\n \n-use std::oldmap::HashMap;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -77,12 +77,11 @@ pub fn join_all(cs: &[constness]) -> constness {\n }\n \n pub fn classify(e: @expr,\n-                def_map: resolve::DefMap,\n                 tcx: ty::ctxt)\n              -> constness {\n     let did = ast_util::local_def(e.id);\n     match tcx.ccache.find(&did) {\n-      Some(x) => x,\n+      Some(&x) => x,\n       None => {\n         let cn =\n             match e.node {\n@@ -97,23 +96,23 @@ pub fn classify(e: @expr,\n               ast::expr_copy(inner) |\n               ast::expr_unary(_, inner) |\n               ast::expr_paren(inner) => {\n-                classify(inner, def_map, tcx)\n+                classify(inner, tcx)\n               }\n \n               ast::expr_binary(_, a, b) => {\n-                join(classify(a, def_map, tcx),\n-                     classify(b, def_map, tcx))\n+                join(classify(a, tcx),\n+                     classify(b, tcx))\n               }\n \n               ast::expr_tup(ref es) |\n               ast::expr_vec(ref es, ast::m_imm) => {\n-                join_all(vec::map(*es, |e| classify(*e, def_map, tcx)))\n+                join_all(vec::map(*es, |e| classify(*e, tcx)))\n               }\n \n               ast::expr_vstore(e, vstore) => {\n                   match vstore {\n                       ast::expr_vstore_fixed(_) |\n-                      ast::expr_vstore_slice => classify(e, def_map, tcx),\n+                      ast::expr_vstore_slice => classify(e, tcx),\n                       ast::expr_vstore_uniq |\n                       ast::expr_vstore_box |\n                       ast::expr_vstore_mut_box |\n@@ -124,7 +123,7 @@ pub fn classify(e: @expr,\n               ast::expr_struct(_, ref fs, None) => {\n                 let cs = do vec::map((*fs)) |f| {\n                     if f.node.mutbl == ast::m_imm {\n-                        classify(f.node.expr, def_map, tcx)\n+                        classify(f.node.expr, tcx)\n                     } else {\n                         non_const\n                     }\n@@ -134,7 +133,7 @@ pub fn classify(e: @expr,\n \n               ast::expr_cast(base, _) => {\n                 let ty = ty::expr_ty(tcx, e);\n-                let base = classify(base, def_map, tcx);\n+                let base = classify(base, tcx);\n                 if ty::type_is_integral(ty) {\n                     join(integral_const, base)\n                 } else if ty::type_is_fp(ty) {\n@@ -145,16 +144,16 @@ pub fn classify(e: @expr,\n               }\n \n               ast::expr_field(base, _, _) => {\n-                classify(base, def_map, tcx)\n+                classify(base, tcx)\n               }\n \n               ast::expr_index(base, idx) => {\n-                join(classify(base, def_map, tcx),\n-                     classify(idx, def_map, tcx))\n+                join(classify(base, tcx),\n+                     classify(idx, tcx))\n               }\n \n               ast::expr_addr_of(ast::m_imm, base) => {\n-                classify(base, def_map, tcx)\n+                classify(base, tcx)\n               }\n \n               // FIXME: (#3728) we can probably do something CCI-ish\n@@ -173,7 +172,7 @@ pub fn classify(e: @expr,\n \n pub fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n     match tcx.def_map.find(&e.id) {\n-        Some(ast::def_const(def_id)) => lookup_const_by_id(tcx, def_id),\n+        Some(&ast::def_const(def_id)) => lookup_const_by_id(tcx, def_id),\n         _ => None\n     }\n }\n@@ -192,14 +191,14 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         }\n     } else {\n         let maps = astencode::Maps {\n-            mutbl_map: HashMap(),\n-            root_map: HashMap(),\n-            last_use_map: HashMap(),\n+            mutbl_map: @mut LinearSet::new(),\n+            root_map: @mut LinearMap::new(),\n+            last_use_map: @mut LinearMap::new(),\n             method_map: HashMap(),\n-            vtable_map: HashMap(),\n-            write_guard_map: HashMap(),\n-            moves_map: HashMap(),\n-            capture_map: HashMap()\n+            vtable_map: @mut LinearMap::new(),\n+            write_guard_map: @mut LinearSet::new(),\n+            moves_map: @mut LinearSet::new(),\n+            capture_map: @mut LinearMap::new()\n         };\n         match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, /*bar*/ copy c, d)) {\n@@ -227,10 +226,9 @@ pub fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n }\n \n pub fn process_crate(crate: @ast::crate,\n-                     def_map: resolve::DefMap,\n                      tcx: ty::ctxt) {\n     let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_expr_post: |e| { classify(e, def_map, tcx); },\n+        visit_expr_post: |e| { classify(e, tcx); },\n         .. *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), v);"}, {"sha": "19d3e1f431db28eaf12c6bea466c7450dbaeb101", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -12,13 +12,12 @@\n // A pass that annotates for each loops and functions with the free\n // variables that they contain.\n \n+use core::prelude::*;\n+\n use middle::resolve;\n use middle::ty;\n \n-use core::int;\n-use core::option::*;\n-use core::vec;\n-use std::oldmap::*;\n+use core::hashmap::linear::LinearMap;\n use syntax::codemap::span;\n use syntax::{ast, ast_util, visit};\n \n@@ -31,7 +30,7 @@ pub struct freevar_entry {\n     span: span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_info = @~[@freevar_entry];\n-pub type freevar_map = HashMap<ast::node_id, freevar_info>;\n+pub type freevar_map = @mut LinearMap<ast::node_id, freevar_info>;\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n@@ -40,7 +39,7 @@ pub type freevar_map = HashMap<ast::node_id, freevar_info>;\n // in order to start the search.\n fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n     -> freevar_info {\n-    let seen = HashMap();\n+    let seen = @mut LinearMap::new();\n     let refs = @mut ~[];\n \n     fn ignore_item(_i: @ast::item, &&_depth: int, _v: visit::vt<int>) { }\n@@ -53,7 +52,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n                   let mut i = 0;\n                   match def_map.find(&expr.id) {\n                     None => fail!(~\"path not found\"),\n-                    Some(df) => {\n+                    Some(&df) => {\n                       let mut def = df;\n                       while i < depth {\n                         match def {\n@@ -93,7 +92,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n // one pass. This could be improved upon if it turns out to matter.\n pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n    freevar_map {\n-    let freevars = HashMap();\n+    let freevars = @mut LinearMap::new();\n \n     let walk_fn: @fn(&visit::fn_kind,\n                      &ast::fn_decl,\n@@ -116,7 +115,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     match tcx.freevars.find(&fid) {\n       None => fail!(~\"get_freevars: \"+int::to_str(fid)+~\" has no freevars\"),\n-      Some(d) => return d\n+      Some(&d) => return d\n     }\n }\n "}, {"sha": "ab3dc75c79f17c891b0a6093dc462a31907595a8", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -18,9 +18,6 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::{ty_to_str, tys_to_str};\n \n-use core::str;\n-use core::vec;\n-use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;\n use syntax::codemap::{span, spanned};\n@@ -58,8 +55,6 @@ use syntax::{visit, ast_util};\n \n pub static try_adding: &'static str = \"Try adding a move\";\n \n-pub type rval_map = HashMap<node_id, ()>;\n-\n pub struct Context {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n@@ -133,13 +128,13 @@ fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n             item_impl(_, Some(trait_ref), self_type, _) => {\n                 match cx.tcx.def_map.find(&trait_ref.ref_id) {\n                     None => cx.tcx.sess.bug(~\"trait ref not in def map!\"),\n-                    Some(trait_def) => {\n+                    Some(&trait_def) => {\n                         let trait_def_id = ast_util::def_id_of_def(trait_def);\n                         if cx.tcx.lang_items.drop_trait() == trait_def_id {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n                                 ty_path(_, path_node_id) => {\n-                                    let struct_def = cx.tcx.def_map.get(\n+                                    let struct_def = *cx.tcx.def_map.get(\n                                         &path_node_id);\n                                     let struct_did =\n                                         ast_util::def_id_of_def(struct_def);\n@@ -281,7 +276,7 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n     for cx.tcx.node_type_substs.find(&type_parameter_id).each |ts| {\n         let bounds = match e.node {\n           expr_path(_) => {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(&e.id));\n+            let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&e.id));\n             ty::lookup_item_type(cx.tcx, did).bounds\n           }\n           _ => {\n@@ -340,7 +335,7 @@ fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n     match aty.node {\n       ty_path(_, id) => {\n         for cx.tcx.node_type_substs.find(&id).each |ts| {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(&id));\n+            let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&id));\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n             for vec::each2(*ts, *bounds) |ty, bound| {\n                 check_bounds(cx, aty.id, aty.span, *ty, *bound)\n@@ -405,7 +400,7 @@ pub fn check_bounds(cx: Context,\n fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n-        match cx.tcx.def_map.get(&ex.id) {\n+        match *cx.tcx.def_map.get(&ex.id) {\n           def_variant(edid, vdid) => {\n             vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n           }"}, {"sha": "9de7b5088f3a08025d127f35a0f11159026aba30", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -31,8 +31,8 @@ use syntax::ast_util::{local_def};\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::{visit_crate, visit_item};\n \n+use core::hashmap::linear::LinearMap;\n use core::ptr;\n-use std::oldmap::HashMap;\n \n pub enum LangItem {\n     ConstTraitLangItem,         // 0\n@@ -259,7 +259,7 @@ fn LanguageItemCollector<'r>(crate: @crate,\n                              session: Session,\n                              items: &'r mut LanguageItems)\n                           -> LanguageItemCollector<'r> {\n-    let item_refs = HashMap();\n+    let mut item_refs = LinearMap::new();\n \n     item_refs.insert(@~\"const\", ConstTraitLangItem as uint);\n     item_refs.insert(@~\"copy\", CopyTraitLangItem as uint);\n@@ -317,7 +317,7 @@ struct LanguageItemCollector {\n     crate: @crate,\n     session: Session,\n \n-    item_refs: HashMap<@~str, uint>,\n+    item_refs: LinearMap<@~str, uint>,\n }\n \n pub impl<'self> LanguageItemCollector<'self> {\n@@ -362,7 +362,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n             None => {\n                 // Didn't match.\n             }\n-            Some(item_index) => {\n+            Some(&item_index) => {\n                 self.collect_item(item_index, item_def_id)\n             }\n         }\n@@ -397,7 +397,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n     }\n \n     fn check_completeness(&self) {\n-        for self.item_refs.each |&key, &item_ref| {\n+        for self.item_refs.each |&(&key, &item_ref)| {\n             match self.items.items[item_ref] {\n                 None => {\n                     self.session.err(fmt!(\"no item found for `%s`\", *key));"}, {"sha": "a75ade0c585d3da0d101da2da5da35d94099503e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 52, "deletions": 49, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -15,6 +15,7 @@ use driver::session;\n use middle::ty;\n use util::ppaux::{ty_to_str};\n \n+use core::hashmap::linear::LinearMap;\n use core::char;\n use core::cmp;\n use core::either;\n@@ -30,8 +31,6 @@ use core::u32;\n use core::u64;\n use core::uint;\n use core::vec;\n-use std::oldmap::{Map, HashMap};\n-use std::oldmap;\n use std::smallintmap::SmallIntMap;\n use syntax::attr;\n use syntax::codemap::span;\n@@ -110,150 +109,150 @@ struct LintSpec {\n     default: level\n }\n \n-pub type LintDict = HashMap<@~str, @LintSpec>;\n+pub type LintDict = @LinearMap<~str, LintSpec>;\n \n /*\n   Pass names should not contain a '-', as the compiler normalizes\n   '-' to '_' in command-line flags\n  */\n pub fn get_lint_dict() -> LintDict {\n     let v = ~[\n-        (@~\"ctypes\",\n-         @LintSpec {\n+        (~\"ctypes\",\n+         LintSpec {\n             lint: ctypes,\n             desc: \"proper use of core::libc types in foreign modules\",\n             default: warn\n          }),\n \n-        (@~\"unused_imports\",\n-         @LintSpec {\n+        (~\"unused_imports\",\n+         LintSpec {\n             lint: unused_imports,\n             desc: \"imports that are never used\",\n             default: warn\n          }),\n \n-        (@~\"while_true\",\n-         @LintSpec {\n+        (~\"while_true\",\n+         LintSpec {\n             lint: while_true,\n             desc: \"suggest using loop { } instead of while(true) { }\",\n             default: warn\n          }),\n \n-        (@~\"path_statement\",\n-         @LintSpec {\n+        (~\"path_statement\",\n+         LintSpec {\n             lint: path_statement,\n             desc: \"path statements with no effect\",\n             default: warn\n          }),\n \n-        (@~\"unrecognized_lint\",\n-         @LintSpec {\n+        (~\"unrecognized_lint\",\n+         LintSpec {\n             lint: unrecognized_lint,\n             desc: \"unrecognized lint attribute\",\n             default: warn\n          }),\n \n-        (@~\"non_implicitly_copyable_typarams\",\n-         @LintSpec {\n+        (~\"non_implicitly_copyable_typarams\",\n+         LintSpec {\n             lint: non_implicitly_copyable_typarams,\n             desc: \"passing non implicitly copyable types as copy type params\",\n             default: warn\n          }),\n \n-        (@~\"vecs_implicitly_copyable\",\n-         @LintSpec {\n+        (~\"vecs_implicitly_copyable\",\n+         LintSpec {\n             lint: vecs_implicitly_copyable,\n             desc: \"make vecs and strs not implicitly copyable \\\n                   (only checked at top level)\",\n             default: warn\n          }),\n \n-        (@~\"implicit_copies\",\n-         @LintSpec {\n+        (~\"implicit_copies\",\n+         LintSpec {\n             lint: implicit_copies,\n             desc: \"implicit copies of non implicitly copyable data\",\n             default: warn\n          }),\n \n-        (@~\"deprecated_mode\",\n-         @LintSpec {\n+        (~\"deprecated_mode\",\n+         LintSpec {\n             lint: deprecated_mode,\n             desc: \"warn about deprecated uses of modes\",\n             default: warn\n          }),\n \n-        (@~\"foreign_mode\",\n-         @LintSpec {\n+        (~\"foreign_mode\",\n+         LintSpec {\n             lint: foreign_mode,\n             desc: \"warn about deprecated uses of modes in foreign fns\",\n             default: warn\n          }),\n \n-        (@~\"deprecated_pattern\",\n-         @LintSpec {\n+        (~\"deprecated_pattern\",\n+         LintSpec {\n             lint: deprecated_pattern,\n             desc: \"warn about deprecated uses of pattern bindings\",\n             default: allow\n          }),\n \n-        (@~\"non_camel_case_types\",\n-         @LintSpec {\n+        (~\"non_camel_case_types\",\n+         LintSpec {\n             lint: non_camel_case_types,\n             desc: \"types, variants and traits should have camel case names\",\n             default: allow\n          }),\n \n-        (@~\"managed_heap_memory\",\n-         @LintSpec {\n+        (~\"managed_heap_memory\",\n+         LintSpec {\n             lint: managed_heap_memory,\n             desc: \"use of managed (@ type) heap memory\",\n             default: allow\n          }),\n \n-        (@~\"owned_heap_memory\",\n-         @LintSpec {\n+        (~\"owned_heap_memory\",\n+         LintSpec {\n             lint: owned_heap_memory,\n             desc: \"use of owned (~ type) heap memory\",\n             default: allow\n          }),\n \n-        (@~\"heap_memory\",\n-         @LintSpec {\n+        (~\"heap_memory\",\n+         LintSpec {\n             lint: heap_memory,\n             desc: \"use of any (~ type or @ type) heap memory\",\n             default: allow\n          }),\n \n-        (@~\"legacy modes\",\n-         @LintSpec {\n+        (~\"legacy modes\",\n+         LintSpec {\n             lint: legacy_modes,\n             desc: \"allow legacy modes\",\n             default: forbid\n          }),\n \n-        (@~\"type_limits\",\n-         @LintSpec {\n+        (~\"type_limits\",\n+         LintSpec {\n             lint: type_limits,\n             desc: \"comparisons made useless by limits of the types involved\",\n             default: warn\n          }),\n \n-        (@~\"default_methods\",\n-         @LintSpec {\n+        (~\"default_methods\",\n+         LintSpec {\n             lint: default_methods,\n             desc: \"allow default methods\",\n             default: deny\n          }),\n \n-        (@~\"deprecated_mutable_fields\",\n-         @LintSpec {\n+        (~\"deprecated_mutable_fields\",\n+         LintSpec {\n             lint: deprecated_mutable_fields,\n             desc: \"deprecated mutable fields in structures\",\n             default: deny\n         }),\n \n-        (@~\"deprecated_drop\",\n-         @LintSpec {\n+        (~\"deprecated_drop\",\n+         LintSpec {\n             lint: deprecated_drop,\n             desc: \"deprecated \\\"drop\\\" notation for the destructor\",\n             default: deny\n@@ -275,12 +274,16 @@ pub fn get_lint_dict() -> LintDict {\n          }),\n         */\n     ];\n-    oldmap::hash_from_vec(v)\n+    let mut map = LinearMap::new();\n+    do vec::consume(v) |_, (k, v)| {\n+        map.insert(k, v);\n+    }\n+    return @map;\n }\n \n // This is a highly not-optimal set of data structure decisions.\n type LintModes = @mut SmallIntMap<level>;\n-type LintModeMap = HashMap<ast::node_id, LintModes>;\n+type LintModeMap = @mut LinearMap<ast::node_id, LintModes>;\n \n // settings_map maps node ids of items with non-default lint settings\n // to their settings; default_settings contains the settings for everything\n@@ -293,7 +296,7 @@ pub struct LintSettings {\n pub fn mk_lint_settings() -> LintSettings {\n     LintSettings {\n         default_settings: @mut SmallIntMap::new(),\n-        settings_map: HashMap()\n+        settings_map: @mut LinearMap::new()\n     }\n }\n \n@@ -310,7 +313,7 @@ pub fn get_lint_settings_level(settings: LintSettings,\n                                item_id: ast::node_id)\n                             -> level {\n     match settings.settings_map.find(&item_id) {\n-      Some(modes) => get_lint_level(modes, lint_mode),\n+      Some(&modes) => get_lint_level(modes, lint_mode),\n       None => get_lint_level(settings.default_settings, lint_mode)\n     }\n }\n@@ -392,7 +395,7 @@ pub impl Context {\n                 (ref meta, level, lintname) => (meta, level, lintname)\n             };\n \n-            match self.dict.find(&lintname) {\n+            match self.dict.find(lintname) {\n               None => {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n@@ -735,7 +738,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n               ast::ty_path(_, id) => {\n-                match cx.def_map.get(&id) {\n+                match *cx.def_map.get(&id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,"}, {"sha": "a92234ba1298e4a63611d9f03ce77818450378c0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -112,13 +112,13 @@ use middle::moves;\n use util::ppaux::ty_to_str;\n \n use core::cmp;\n+use core::hashmap::linear::LinearMap;\n use core::io::WriterUtil;\n use core::io;\n use core::ptr;\n use core::to_str;\n use core::uint;\n use core::vec;\n-use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n@@ -135,7 +135,7 @@ use syntax::{visit, ast_util};\n //\n // Very subtle (#2633): borrowck will remove entries from this table\n // if it detects an outstanding loan (that is, the addr is taken).\n-pub type last_use_map = HashMap<node_id, @mut ~[node_id]>;\n+pub type last_use_map = @mut LinearMap<node_id, @mut ~[node_id]>;\n \n struct Variable(uint);\n struct LiveNode(uint);\n@@ -212,7 +212,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         .. *visit::default_visitor()\n     });\n \n-    let last_use_map = HashMap();\n+    let last_use_map = @mut LinearMap::new();\n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n                                    variable_moves_map,\n@@ -304,9 +304,9 @@ struct IrMaps {\n \n     num_live_nodes: uint,\n     num_vars: uint,\n-    live_node_map: HashMap<node_id, LiveNode>,\n-    variable_map: HashMap<node_id, Variable>,\n-    capture_info_map: HashMap<node_id, @~[CaptureInfo]>,\n+    live_node_map: LinearMap<node_id, LiveNode>,\n+    variable_map: LinearMap<node_id, Variable>,\n+    capture_info_map: LinearMap<node_id, @~[CaptureInfo]>,\n     var_kinds: ~[VarKind],\n     lnks: ~[LiveNodeKind],\n }\n@@ -325,9 +325,9 @@ fn IrMaps(tcx: ty::ctxt,\n         last_use_map: last_use_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n-        live_node_map: HashMap(),\n-        variable_map: HashMap(),\n-        capture_info_map: HashMap(),\n+        live_node_map: LinearMap::new(),\n+        variable_map: LinearMap::new(),\n+        capture_info_map: LinearMap::new(),\n         var_kinds: ~[],\n         lnks: ~[]\n     }\n@@ -374,7 +374,7 @@ pub impl IrMaps {\n \n     fn variable(&mut self, node_id: node_id, span: span) -> Variable {\n         match self.variable_map.find(&node_id) {\n-          Some(var) => var,\n+          Some(&var) => var,\n           None => {\n             self.tcx.sess.span_bug(\n                 span, fmt!(\"No variable registered for id %d\", node_id));\n@@ -396,7 +396,7 @@ pub impl IrMaps {\n \n     fn captures(&mut self, expr: @expr) -> @~[CaptureInfo] {\n         match self.capture_info_map.find(&expr.id) {\n-          Some(caps) => caps,\n+          Some(&caps) => caps,\n           None => {\n             self.tcx.sess.span_bug(expr.span, ~\"no registered caps\");\n           }\n@@ -416,7 +416,7 @@ pub impl IrMaps {\n           Local(LocalInfo {id: id, kind: FromLetWithInitializer, _}) |\n           Local(LocalInfo {id: id, kind: FromMatch(_), _}) => {\n             let v = match self.last_use_map.find(&expr_id) {\n-              Some(v) => v,\n+              Some(&v) => v,\n               None => {\n                 let v = @mut ~[];\n                 self.last_use_map.insert(expr_id, v);\n@@ -562,7 +562,7 @@ fn visit_expr(expr: @expr, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n-        let def = self.tcx.def_map.get(&expr.id);\n+        let def = *self.tcx.def_map.get(&expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n         if relevant_def(def).is_some() {\n             self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -657,7 +657,7 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-type LiveNodeMap = HashMap<node_id, LiveNode>;\n+type LiveNodeMap = @mut LinearMap<node_id, LiveNode>;\n \n struct Liveness {\n     tcx: ty::ctxt,\n@@ -684,15 +684,16 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n         users: @mut vec::from_elem(ir.num_live_nodes * ir.num_vars,\n                                    invalid_users()),\n         loop_scope: @mut ~[],\n-        break_ln: HashMap(),\n-        cont_ln: HashMap()\n+        break_ln: @mut LinearMap::new(),\n+        cont_ln: @mut LinearMap::new()\n     }\n }\n \n pub impl Liveness {\n     fn live_node(&self, node_id: node_id, span: span) -> LiveNode {\n-        match self.ir.live_node_map.find(&node_id) {\n-          Some(ln) => ln,\n+        let ir: &mut IrMaps = self.ir;\n+        match ir.live_node_map.find(&node_id) {\n+          Some(&ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n             // above and the propagation code below; the two sets of\n@@ -708,7 +709,7 @@ pub impl Liveness {\n     fn variable_from_path(&self, expr: @expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n-            let def = self.tcx.def_map.get(&expr.id);\n+            let def = *self.tcx.def_map.get(&expr.id);\n             relevant_def(def).map(\n                 |rdef| self.variable(*rdef, expr.span)\n             )\n@@ -724,7 +725,7 @@ pub impl Liveness {\n     fn variable_from_def_map(&self, node_id: node_id,\n                              span: span) -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n-          Some(def) => {\n+          Some(&def) => {\n             relevant_def(def).map(\n                 |rdef| self.variable(*rdef, span)\n             )\n@@ -845,7 +846,7 @@ pub impl Liveness {\n             Some(_) => // Refers to a labeled loop. Use the results of resolve\n                       // to find with one\n                 match self.tcx.def_map.find(&id) {\n-                    Some(def_label(loop_id)) => loop_id,\n+                    Some(&def_label(loop_id)) => loop_id,\n                     _ => self.tcx.sess.span_bug(sp, ~\"Label on break/loop \\\n                                                     doesn't refer to a loop\")\n                 },\n@@ -1226,7 +1227,7 @@ pub impl Liveness {\n               // look it up in the break loop nodes table\n \n               match self.break_ln.find(&sc) {\n-                  Some(b) => b,\n+                  Some(&b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n                                 ~\"Break to unknown label\")\n               }\n@@ -1240,7 +1241,7 @@ pub impl Liveness {\n               // look it up in the continue loop nodes table\n \n               match self.cont_ln.find(&sc) {\n-                  Some(b) => b,\n+                  Some(&b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n                                 ~\"Loop to unknown label\")\n               }\n@@ -1448,7 +1449,7 @@ pub impl Liveness {\n \n     fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n                   -> LiveNode {\n-        let def = self.tcx.def_map.get(&expr.id);\n+        let def = *self.tcx.def_map.get(&expr.id);\n         match relevant_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1587,7 +1588,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n \n             match self.ir.variable_moves_map.find(&expr.id) {\n                 None => {}\n-                Some(entire_expr) => {\n+                Some(&entire_expr) => {\n                     debug!(\"(checking expr) is a move: `%s`\",\n                            expr_to_str(expr, self.tcx.sess.intr()));\n                     self.check_move_from_var(ln, *var, entire_expr);\n@@ -1723,7 +1724,7 @@ pub impl Liveness {\n     fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n-            match self.tcx.def_map.get(&expr.id) {\n+            match *self.tcx.def_map.get(&expr.id) {\n               def_local(nid, false) => {\n                 // Assignment to an immutable variable or argument:\n                 // only legal if there is no later assignment."}, {"sha": "b7ec6208d56072e3730a306d0a239716018b5e8f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -359,15 +359,15 @@ pub impl mem_categorization_ctxt {\n                 self.cat_expr_unadjusted(expr)\n             }\n \n-            Some(@ty::AutoAddEnv(*)) => {\n+            Some(&@ty::AutoAddEnv(*)) => {\n                 // Convert a bare fn to a closure by adding NULL env.\n                 // Result is an rvalue.\n                 let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n                 self.cat_rvalue(expr, expr_ty)\n             }\n \n             Some(\n-                @ty::AutoDerefRef(\n+                &@ty::AutoDerefRef(\n                     ty::AutoDerefRef {\n                         autoref: Some(_), _})) => {\n                 // Equivalent to &*expr or something similar.\n@@ -377,7 +377,7 @@ pub impl mem_categorization_ctxt {\n             }\n \n             Some(\n-                @ty::AutoDerefRef(\n+                &@ty::AutoDerefRef(\n                     ty::AutoDerefRef {\n                         autoref: None, autoderefs: autoderefs})) => {\n                 // Equivalent to *expr or something similar.\n@@ -431,7 +431,7 @@ pub impl mem_categorization_ctxt {\n           }\n \n           ast::expr_path(_) => {\n-            let def = self.tcx.def_map.get(&expr.id);\n+            let def = *self.tcx.def_map.get(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -902,21 +902,21 @@ pub impl mem_categorization_ctxt {\n           }\n           ast::pat_enum(_, Some(ref subpats)) => {\n             match self.tcx.def_map.find(&pat.id) {\n-                Some(ast::def_variant(enum_did, _)) => {\n+                Some(&ast::def_variant(enum_did, _)) => {\n                     // variant(x, y, z)\n                     for subpats.each |subpat| {\n                         let subcmt = self.cat_variant(*subpat, enum_did, cmt);\n                         self.cat_pattern(subcmt, *subpat, op);\n                     }\n                 }\n-                Some(ast::def_struct(*)) => {\n+                Some(&ast::def_struct(*)) => {\n                     for subpats.each |subpat| {\n                         let cmt_field = self.cat_anon_struct_field(*subpat,\n                                                                    cmt);\n                         self.cat_pattern(cmt_field, *subpat, op);\n                     }\n                 }\n-                Some(ast::def_const(*)) => {\n+                Some(&ast::def_const(*)) => {\n                     for subpats.each |subpat| {\n                         self.cat_pattern(cmt, *subpat, op);\n                     }\n@@ -1124,7 +1124,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n         }\n       }\n       ty::ty_enum(*) => {\n-        match tcx.def_map.get(&node_id) {\n+        match *tcx.def_map.get(&node_id) {\n           ast::def_variant(_, variant_id) => {\n             for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n                 if fld.ident == f_name {"}, {"sha": "16f133b8794d8c0bd045b902b03dd5c1444b0e79", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -216,8 +216,8 @@ use middle::typeck::check::{DerefArgs, DoDerefArgs, DontDerefArgs};\n use util::ppaux;\n use util::common::indenter;\n \n+use core::hashmap::linear::{LinearSet, LinearMap};\n use core::vec;\n-use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n@@ -242,14 +242,14 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = HashMap<node_id, @[CaptureVar]>;\n+pub type CaptureMap = @mut LinearMap<node_id, @[CaptureVar]>;\n \n-pub type MovesMap = HashMap<node_id, ()>;\n+pub type MovesMap = @mut LinearSet<node_id>;\n \n /**\n  * For each variable which will be moved, links to the\n  * expression */\n-pub type VariableMovesMap = HashMap<node_id, @expr>;\n+pub type VariableMovesMap = @mut LinearMap<node_id, @expr>;\n \n /** See the section Output on the module comment for explanation. */\n pub struct MoveMaps {\n@@ -260,7 +260,7 @@ pub struct MoveMaps {\n \n struct VisitContext {\n     tcx: ty::ctxt,\n-    method_map: HashMap<node_id,method_map_entry>,\n+    method_map: method_map,\n     move_maps: MoveMaps\n }\n \n@@ -282,9 +282,9 @@ pub fn compute_moves(tcx: ty::ctxt,\n         tcx: tcx,\n         method_map: method_map,\n         move_maps: MoveMaps {\n-            moves_map: HashMap(),\n-            variable_moves_map: HashMap(),\n-            capture_map: HashMap()\n+            moves_map: @mut LinearSet::new(),\n+            variable_moves_map: @mut LinearMap::new(),\n+            capture_map: @mut LinearMap::new()\n         }\n     };\n     visit::visit_crate(*crate, visit_cx, visitor);\n@@ -402,15 +402,15 @@ pub impl VisitContext {\n                expr_mode);\n \n         match expr_mode {\n-            MoveInWhole => { self.move_maps.moves_map.insert(expr.id, ()); }\n+            MoveInWhole => { self.move_maps.moves_map.insert(expr.id); }\n             MoveInPart(_) | Read => {}\n         }\n \n         // `expr_mode` refers to the post-adjustment value.  If one of\n         // those adjustments is to take a reference, then it's only\n         // reading the underlying expression, not moving it.\n         let comp_mode = match self.tcx.adjustments.find(&expr.id) {\n-            Some(@ty::AutoDerefRef(\n+            Some(&@ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoref: Some(_), _})) => Read,\n             _ => expr_mode.component_mode(expr)\n@@ -725,7 +725,7 @@ pub impl VisitContext {\n             };\n \n             match mode {\n-                MoveInWhole => { self.move_maps.moves_map.insert(id, ()); }\n+                MoveInWhole => { self.move_maps.moves_map.insert(id); }\n                 MoveInPart(_) | Read => {}\n             }\n         }\n@@ -795,7 +795,7 @@ pub impl VisitContext {\n             for arm.pats.each |pat| {\n                 let mut found = false;\n                 do pat_bindings(self.tcx.def_map, *pat) |_, node_id, _, _| {\n-                    if moves_map.contains_key(&node_id) {\n+                    if moves_map.contains(&node_id) {\n                         found = true;\n                     }\n                 }"}, {"sha": "6bf75b50cb48bf1c9f44d377d8b059b28c45c7e7", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -12,17 +12,17 @@ use core::prelude::*;\n \n use middle::resolve;\n \n+use core::hashmap::linear::LinearMap;\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::codemap::{span, respan};\n-use std::oldmap::HashMap;\n \n-pub type PatIdMap = HashMap<ident, node_id>;\n+pub type PatIdMap = LinearMap<ident, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n-    let map = HashMap();\n+    let mut map = LinearMap::new();\n     do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };\n@@ -33,7 +33,7 @@ pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n         pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n             match dm.find(&pat.id) {\n-                Some(def_variant(*)) | Some(def_struct(*)) => true,\n+                Some(&def_variant(*)) | Some(&def_struct(*)) => true,\n                 _ => false\n             }\n         }\n@@ -45,7 +45,7 @@ pub fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n     match pat.node {\n         pat_ident(_, _, None) | pat_enum(*) => {\n             match dm.find(&pat.id) {\n-                Some(def_const(*)) => true,\n+                Some(&def_const(*)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "4e349d1506d4dd49d6021932772de19c12810700", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -484,7 +484,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                     }\n                 }\n                 expr_path(path) => {\n-                    check_path(expr.span, tcx.def_map.get(&expr.id), path);\n+                    check_path(expr.span, *tcx.def_map.get(&expr.id), path);\n                 }\n                 expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n@@ -502,7 +502,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(&(id.node)) {\n-                                match tcx.def_map.get(&expr.id) {\n+                                match *tcx.def_map.get(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for (*fields).each |field| {\n                                                 debug!(\"(privacy checking) \\\n@@ -570,7 +570,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     !privileged_items.contains(\n                                         &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n-                                    Some(def_variant(_, variant_id)) => {\n+                                    Some(&def_variant(_, variant_id)) => {\n                                         for fields.each |field| {\n                                             debug!(\"(privacy checking) \\\n                                                     checking field in \\"}, {"sha": "f49a37d73018f9573eb2f04f86115a1f6be021c3", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -26,8 +26,8 @@ use middle::ty::{region_variance, rv_covariant, rv_invariant};\n use middle::ty::{rv_contravariant};\n use middle::ty;\n \n+use core::hashmap::linear::{LinearMap, LinearSet};\n use core::vec;\n-use std::oldmap::HashMap;\n use syntax::ast_map;\n use syntax::codemap::span;\n use syntax::print::pprust;\n@@ -46,7 +46,7 @@ Encodes the bounding lifetime for a given AST node:\n - Variables and bindings are mapped to the block in which they are declared.\n \n */\n-pub type region_map = HashMap<ast::node_id, ast::node_id>;\n+pub type region_map = @mut LinearMap<ast::node_id, ast::node_id>;\n \n pub struct ctxt {\n     sess: Session,\n@@ -62,7 +62,7 @@ pub struct ctxt {\n     // the condition in a while loop is always a parent.  In those\n     // cases, we add the node id of such an expression to this set so\n     // that when we visit it we can view it as a parent.\n-    root_exprs: HashMap<ast::node_id, ()>,\n+    root_exprs: @mut LinearSet<ast::node_id>,\n \n     // The parent scope is the innermost block, statement, call, or match\n     // expression during the execution of which the current expression\n@@ -106,7 +106,7 @@ pub fn scope_contains(region_map: region_map, superscope: ast::node_id,\n     while superscope != subscope {\n         match region_map.find(&subscope) {\n             None => return false,\n-            Some(scope) => subscope = scope\n+            Some(&scope) => subscope = scope\n         }\n     }\n     return true;\n@@ -150,7 +150,7 @@ pub fn nearest_common_ancestor(region_map: region_map,\n         loop {\n             match region_map.find(&scope) {\n                 None => return result,\n-                Some(superscope) => {\n+                Some(&superscope) => {\n                     result.push(superscope);\n                     scope = superscope;\n                 }\n@@ -228,7 +228,7 @@ pub fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n       ast::pat_ident(*) => {\n         let defn_opt = cx.def_map.find(&pat.id);\n         match defn_opt {\n-          Some(ast::def_variant(_,_)) => {\n+          Some(&ast::def_variant(_,_)) => {\n             /* Nothing to do; this names a variant. */\n           }\n           _ => {\n@@ -280,12 +280,12 @@ pub fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n         new_cx.parent = Some(expr.id);\n       }\n       ast::expr_while(cond, _) => {\n-        new_cx.root_exprs.insert(cond.id, ());\n+        new_cx.root_exprs.insert(cond.id);\n       }\n       _ => {}\n     };\n \n-    if new_cx.root_exprs.contains_key(&expr.id) {\n+    if new_cx.root_exprs.contains(&expr.id) {\n         new_cx.parent = Some(expr.id);\n     }\n \n@@ -350,8 +350,8 @@ pub fn resolve_crate(sess: Session,\n                   -> region_map {\n     let cx: ctxt = ctxt {sess: sess,\n                          def_map: def_map,\n-                         region_map: HashMap(),\n-                         root_exprs: HashMap(),\n+                         region_map: @mut LinearMap::new(),\n+                         root_exprs: @mut LinearSet::new(),\n                          parent: None};\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_block: resolve_block,\n@@ -387,15 +387,15 @@ pub fn resolve_crate(sess: Session,\n // a worklist.  We can then process the worklist, propagating indirect\n // dependencies until a fixed point is reached.\n \n-pub type region_paramd_items = HashMap<ast::node_id, region_variance>;\n+pub type region_paramd_items = @mut LinearMap<ast::node_id, region_variance>;\n \n #[deriving(Eq)]\n pub struct region_dep {\n     ambient_variance: region_variance,\n     id: ast::node_id\n }\n \n-pub type dep_map = HashMap<ast::node_id, @mut ~[region_dep]>;\n+pub type dep_map = @mut LinearMap<ast::node_id, @mut ~[region_dep]>;\n \n pub struct DetermineRpCtxt {\n     sess: Session,\n@@ -464,7 +464,8 @@ pub impl DetermineRpCtxt {\n     /// the new variance is joined with the old variance.\n     fn add_rp(&mut self, id: ast::node_id, variance: region_variance) {\n         fail_unless!(id != 0);\n-        let old_variance = self.region_paramd_items.find(&id);\n+        let old_variance = self.region_paramd_items.find(&id).\n+                                map_consume(|x| *x);\n         let joined_variance = match old_variance {\n           None => variance,\n           Some(v) => join_variance(v, variance)\n@@ -496,7 +497,7 @@ pub impl DetermineRpCtxt {\n                                        self.sess.parse_sess.interner),\n                copy self.ambient_variance);\n         let vec = match self.dep_map.find(&from) {\n-            Some(vec) => vec,\n+            Some(&vec) => vec,\n             None => {\n                 let vec = @mut ~[];\n                 let dep_map = self.dep_map;\n@@ -689,7 +690,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     match ty.node {\n       ast::ty_path(path, id) => {\n         match cx.def_map.find(&id) {\n-          Some(ast::def_ty(did)) | Some(ast::def_struct(did)) => {\n+          Some(&ast::def_ty(did)) | Some(&ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n                 if cx.region_is_relevant(path.rp) {\n                     cx.add_dep(did.node);\n@@ -782,15 +783,15 @@ pub fn determine_rp_in_struct_field(\n \n pub fn determine_rp_in_crate(sess: Session,\n                              ast_map: ast_map::map,\n-                             def_map: resolve::DefMap,\n+                             +def_map: resolve::DefMap,\n                              crate: @ast::crate)\n                           -> region_paramd_items {\n     let cx = @mut DetermineRpCtxt {\n         sess: sess,\n         ast_map: ast_map,\n         def_map: def_map,\n-        region_paramd_items: HashMap(),\n-        dep_map: HashMap(),\n+        region_paramd_items: @mut LinearMap::new(),\n+        dep_map: @mut LinearMap::new(),\n         worklist: ~[],\n         item_id: 0,\n         anon_implies_rp: false,\n@@ -822,7 +823,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         let cx = &mut *cx;\n         while cx.worklist.len() != 0 {\n             let c_id = cx.worklist.pop();\n-            let c_variance = cx.region_paramd_items.get(&c_id);\n+            let c_variance = *cx.region_paramd_items.get(&c_id);\n             debug!(\"popped %d from worklist\", c_id);\n             match cx.dep_map.find(&c_id) {\n               None => {}\n@@ -839,7 +840,7 @@ pub fn determine_rp_in_crate(sess: Session,\n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n-        for region_paramd_items.each |&key, &value| {\n+        for region_paramd_items.each |&(&key, &value)| {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "f956c8cb10c124d4ee54ec692bbbf45761a8fa1c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -77,19 +77,18 @@ use syntax::opt_vec::OptVec;\n \n use core::option::{Some, get, is_some, is_none};\n use core::str::{connect, each_split_str};\n-use core::hashmap::linear::LinearMap;\n-use std::oldmap::HashMap;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n \n // Definition mapping\n-pub type DefMap = HashMap<node_id,def>;\n+pub type DefMap = @mut LinearMap<node_id,def>;\n \n pub struct binding_info {\n     span: span,\n     binding_mode: binding_mode,\n }\n \n // Map from the name in a pattern to its binding mode.\n-pub type BindingMap = HashMap<ident,binding_info>;\n+pub type BindingMap = LinearMap<ident,binding_info>;\n \n // Implementation resolution\n //\n@@ -110,11 +109,11 @@ pub struct Impl {\n }\n \n // Trait method resolution\n-pub type TraitMap = @HashMap<node_id,@mut ~[def_id]>;\n+pub type TraitMap = LinearMap<node_id,@mut ~[def_id]>;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-pub type ExportMap2 = HashMap<node_id, ~[Export2]>;\n+pub type ExportMap2 = @mut LinearMap<node_id, ~[Export2]>;\n \n pub struct Export2 {\n     name: @~str,        // The name of the target.\n@@ -335,13 +334,13 @@ pub fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode)\n \n /// One local scope.\n pub struct Rib {\n-    bindings: HashMap<ident,def_like>,\n+    bindings: @mut LinearMap<ident,def_like>,\n     kind: RibKind,\n }\n \n pub fn Rib(kind: RibKind) -> Rib {\n     Rib {\n-        bindings: HashMap(),\n+        bindings: @mut LinearMap::new(),\n         kind: kind\n     }\n }\n@@ -475,7 +474,7 @@ pub struct Module {\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n \n-    anonymous_children: @HashMap<node_id,@mut Module>,\n+    anonymous_children: @mut LinearMap<node_id,@mut Module>,\n \n     // The status of resolving each import in this module.\n     import_resolutions: @mut LinearMap<ident, @mut ImportResolution>,\n@@ -497,7 +496,7 @@ pub fn Module(parent_link: ParentLink,\n         kind: kind,\n         children: @mut LinearMap::new(),\n         imports: @mut ~[],\n-        anonymous_children: @HashMap(),\n+        anonymous_children: @mut LinearMap::new(),\n         import_resolutions: @mut LinearMap::new(),\n         glob_count: 0,\n         resolved_import_count: 0\n@@ -709,20 +708,20 @@ pub fn NameBindings() -> NameBindings {\n \n /// Interns the names of the primitive types.\n pub struct PrimitiveTypeTable {\n-    primitive_types: HashMap<ident,prim_ty>,\n+    primitive_types: LinearMap<ident,prim_ty>,\n }\n \n pub impl PrimitiveTypeTable {\n-    fn intern(&self, intr: @ident_interner, string: @~str,\n+    fn intern(&mut self, intr: @ident_interner, string: @~str,\n               primitive_type: prim_ty) {\n         let ident = intr.intern(string);\n         self.primitive_types.insert(ident, primitive_type);\n     }\n }\n \n pub fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n-    let table = PrimitiveTypeTable {\n-        primitive_types: HashMap()\n+    let mut table = PrimitiveTypeTable {\n+        primitive_types: LinearMap::new()\n     };\n \n     table.intern(intr, @~\"bool\",    ty_bool);\n@@ -777,8 +776,8 @@ pub fn Resolver(session: Session,\n \n         graph_root: graph_root,\n \n-        trait_info: @HashMap(),\n-        structs: @HashMap(),\n+        trait_info: LinearMap::new(),\n+        structs: LinearSet::new(),\n \n         unresolved_imports: 0,\n \n@@ -801,9 +800,9 @@ pub fn Resolver(session: Session,\n         attr_main_fn: None,\n         main_fns: ~[],\n \n-        def_map: @HashMap(),\n-        export_map2: @HashMap(),\n-        trait_map: @HashMap(),\n+        def_map: @mut LinearMap::new(),\n+        export_map2: @mut LinearMap::new(),\n+        trait_map: LinearMap::new(),\n \n         intr: session.intr()\n     };\n@@ -821,8 +820,8 @@ pub struct Resolver {\n \n     graph_root: @mut NameBindings,\n \n-    trait_info: @HashMap<def_id,@HashMap<ident,()>>,\n-    structs: @HashMap<def_id,()>,\n+    trait_info: LinearMap<def_id, LinearSet<ident>>,\n+    structs: LinearSet<def_id>,\n \n     // The number of imports that are currently unresolved.\n     unresolved_imports: uint,\n@@ -863,8 +862,8 @@ pub struct Resolver {\n     // The functions named 'main'\n     main_fns: ~[Option<(node_id, span)>],\n \n-    def_map: @DefMap,\n-    export_map2: @ExportMap2,\n+    def_map: DefMap,\n+    export_map2: ExportMap2,\n     trait_map: TraitMap,\n }\n \n@@ -1192,7 +1191,7 @@ pub impl Resolver {\n                 }\n \n                 // Record the def ID of this struct.\n-                self.structs.insert(local_def(item.id), ());\n+                self.structs.insert(local_def(item.id));\n \n                 visit_item(item, new_parent, visitor);\n             }\n@@ -1305,8 +1304,8 @@ pub impl Resolver {\n                 }\n \n                 // Add the names of all the methods to the trait info.\n-                let method_names = @HashMap();\n-                for (*methods).each |method| {\n+                let mut method_names = LinearSet::new();\n+                for methods.each |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n@@ -1329,7 +1328,7 @@ pub impl Resolver {\n                                                               ty_m.span);\n                         }\n                         _ => {\n-                            method_names.insert(ident, ());\n+                            method_names.insert(ident);\n                         }\n                     }\n                 }\n@@ -1378,7 +1377,7 @@ pub impl Resolver {\n                                   def_variant(item_id,\n                                               local_def(variant.node.id)),\n                                   variant.span);\n-                self.structs.insert(local_def(variant.node.id), ());\n+                self.structs.insert(local_def(variant.node.id));\n             }\n             enum_variant_kind(ref enum_definition) => {\n                 child.define_type(privacy,\n@@ -1565,7 +1564,7 @@ pub impl Resolver {\n \n     fn handle_external_def(@mut self,\n                            def: def,\n-                           modules: HashMap<def_id, @mut Module>,\n+                           modules: &mut LinearMap<def_id, @mut Module>,\n                            child_name_bindings: @mut NameBindings,\n                            final_ident: &str,\n                            ident: ident,\n@@ -1585,17 +1584,17 @@ pub impl Resolver {\n                         %s\", final_ident);\n                 let parent_link = self.get_parent_link(new_parent, ident);\n \n-                match modules.find(&def_id) {\n-                  None => {\n+                // FIXME (#5074): this should be a match on find\n+                if !modules.contains_key(&def_id) {\n                     child_name_bindings.define_module(Public,\n                                                       parent_link,\n                                                       Some(def_id),\n                                                       NormalModuleKind,\n                                                       dummy_sp());\n                     modules.insert(def_id,\n                                    child_name_bindings.get_module());\n-                  }\n-                  Some(existing_module) => {\n+                } else {\n+                    let existing_module = *modules.get(&def_id);\n                     // Create an import resolution to\n                     // avoid creating cycles in the\n                     // module graph.\n@@ -1623,7 +1622,6 @@ pub impl Resolver {\n                             ... creating import resolution\");\n \n                     new_parent.import_resolutions.insert(ident, resolution);\n-                  }\n                 }\n               }\n             }\n@@ -1646,7 +1644,7 @@ pub impl Resolver {\n                 // Nothing to do.\n               }\n               Some(method_names) => {\n-                let interned_method_names = @HashMap();\n+                let mut interned_method_names = LinearSet::new();\n                 for method_names.each |method_data| {\n                     let (method_name, self_ty) = *method_data;\n                     debug!(\"(building reduced graph for \\\n@@ -1656,7 +1654,7 @@ pub impl Resolver {\n \n                     // Add it to the trait info if not static.\n                     if self_ty != sty_static {\n-                        interned_method_names.insert(method_name, ());\n+                        interned_method_names.insert(method_name);\n                     }\n                 }\n                 self.trait_info.insert(def_id, interned_method_names);\n@@ -1670,7 +1668,7 @@ pub impl Resolver {\n                     crate) building type %s\",\n                    final_ident);\n             child_name_bindings.define_type(Public, def, dummy_sp());\n-            self.structs.insert(def_id, ());\n+            self.structs.insert(def_id);\n           }\n           def_self(*) | def_arg(*) | def_local(*) |\n           def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n@@ -1686,7 +1684,7 @@ pub impl Resolver {\n      * crate.\n      */\n     fn build_reduced_graph_for_external_crate(@mut self, root: @mut Module) {\n-        let modules = HashMap();\n+        let mut modules = LinearMap::new();\n \n         // Create all the items reachable by paths.\n         for each_path(self.session.cstore, root.def_id.get().crate)\n@@ -1758,7 +1756,7 @@ pub impl Resolver {\n                                        dummy_sp());\n \n                     self.handle_external_def(def,\n-                                             modules,\n+                                             &mut modules,\n                                              child_name_bindings,\n                                              *self.session.str_of(\n                                                  final_ident),\n@@ -3338,8 +3336,9 @@ pub impl Resolver {\n                   // If the def is a ty param, and came from the parent\n                   // item, it's ok\n                   match def {\n-                    def_ty_param(did, _) if self.def_map.find(&did.node)\n-                      == Some(def_typaram_binder(item_id)) => {\n+                    def_ty_param(did, _)\n+                        if self.def_map.find(&did.node).map_consume(|x| *x)\n+                            == Some(def_typaram_binder(item_id)) => {\n                       // ok\n                     }\n                     _ => {\n@@ -3412,7 +3411,7 @@ pub impl Resolver {\n         while i != 0 {\n             i -= 1;\n             match ribs[i].bindings.find(&name) {\n-                Some(def_like) => {\n+                Some(&def_like) => {\n                     return self.upvarify(ribs, i, def_like, span,\n                                          allow_capturing_self);\n                 }\n@@ -3995,8 +3994,8 @@ pub impl Resolver {\n     }\n \n     fn binding_mode_map(@mut self, pat: @pat) -> BindingMap {\n-        let result = HashMap();\n-        do pat_bindings(*self.def_map, pat) |binding_mode, _id, sp, path| {\n+        let mut result = LinearMap::new();\n+        do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n             let ident = path_to_ident(path);\n             result.insert(ident,\n                           binding_info {span: sp,\n@@ -4011,7 +4010,7 @@ pub impl Resolver {\n         for arm.pats.eachi() |i, p| {\n             let map_i = self.binding_mode_map(*p);\n \n-            for map_0.each |&key, &binding_0| {\n+            for map_0.each |&(&key, &binding_0)| {\n                 match map_i.find(&key) {\n                   None => {\n                     self.session.span_err(\n@@ -4032,7 +4031,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            for map_i.each |&key, &binding| {\n+            for map_i.each |&(&key, &binding)| {\n                 if !map_0.contains_key(&key) {\n                     self.session.span_err(\n                         binding.span,\n@@ -4047,7 +4046,7 @@ pub impl Resolver {\n     fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n-        let bindings_list = HashMap();\n+        let bindings_list = @mut LinearMap::new();\n         for arm.pats.each |pattern| {\n             self.resolve_pattern(*pattern, RefutableMode, Immutable,\n                                  Some(bindings_list), visitor);\n@@ -4071,7 +4070,7 @@ pub impl Resolver {\n         let orig_module = self.current_module;\n         match self.current_module.anonymous_children.find(&block.node.id) {\n             None => { /* Nothing to do. */ }\n-            Some(anonymous_module) => {\n+            Some(&anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving \\\n                         down\");\n                 self.current_module = anonymous_module;\n@@ -4106,7 +4105,7 @@ pub impl Resolver {\n                             .primitive_types\n                             .find(&name) {\n \n-                        Some(primitive_type) => {\n+                        Some(&primitive_type) => {\n                             result_def =\n                                 Some(def_prim_ty(primitive_type));\n                         }\n@@ -4167,7 +4166,7 @@ pub impl Resolver {\n                        mutability: Mutability,\n                        // Maps idents to the node ID for the (outermost)\n                        // pattern that binds them\n-                       bindings_list: Option<HashMap<ident,node_id>>,\n+                       bindings_list: Option<@mut LinearMap<ident,node_id>>,\n                        visitor: ResolveVisitor) {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n@@ -4271,7 +4270,7 @@ pub impl Resolver {\n                                     bindings_list.insert(ident, pat_id);\n                                 }\n                                 Some(b) => {\n-                                  if b.find(&ident) == Some(pat_id) {\n+                                  if b.find(&ident) == Some(&pat_id) {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n@@ -4371,21 +4370,19 @@ pub impl Resolver {\n                 }\n \n                 pat_struct(path, _, _) => {\n+                    let structs: &mut LinearSet<def_id> = &mut self.structs;\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n-                                if self.structs.contains_key(&class_id)\n-                                     => {\n+                                if structs.contains(&class_id) => {\n                             let class_def = def_struct(class_id);\n                             self.record_def(pattern.id, class_def);\n                         }\n                         Some(definition @ def_struct(class_id))\n-                                if self.structs.contains_key(&class_id)\n-                                     => {\n+                                if structs.contains(&class_id) => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         Some(definition @ def_variant(_, variant_id))\n-                                if self.structs.contains_key(&variant_id)\n-                                     => {\n+                                if structs.contains(&variant_id) => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n@@ -4869,14 +4866,15 @@ pub impl Resolver {\n \n             expr_struct(path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n+                let structs: &mut LinearSet<def_id> = &mut self.structs;\n                 match self.resolve_path(path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))\n-                            if self.structs.contains_key(&class_id) => {\n+                            if structs.contains(&class_id) => {\n                         let class_def = def_struct(class_id);\n                         self.record_def(expr.id, class_def);\n                     }\n                     Some(definition @ def_variant(_, class_id))\n-                            if self.structs.contains_key(&class_id) => {\n+                            if structs.contains(&class_id) => {\n                         self.record_def(expr.id, definition);\n                     }\n                     _ => {\n@@ -5095,7 +5093,7 @@ pub impl Resolver {\n         return found_traits;\n     }\n \n-    fn add_trait_info_if_containing_method(@mut self,\n+    fn add_trait_info_if_containing_method(&self,\n                                            found_traits: &mut ~[def_id],\n                                            trait_def_id: def_id,\n                                            name: ident)\n@@ -5107,7 +5105,7 @@ pub impl Resolver {\n                *self.session.str_of(name));\n \n         match self.trait_info.find(&trait_def_id) {\n-            Some(trait_info) if trait_info.contains_key(&name) => {\n+            Some(trait_info) if trait_info.contains(&name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n@@ -5351,10 +5349,11 @@ pub fn resolve_crate(session: Session,\n                   -> CrateMap {\n     let resolver = @mut Resolver(session, lang_items, crate);\n     resolver.resolve();\n+    let @Resolver{def_map, export_map2, trait_map, _} = resolver;\n     CrateMap {\n-        def_map: *resolver.def_map,\n-        exp_map2: *resolver.export_map2,\n-        trait_map: resolver.trait_map\n+        def_map: def_map,\n+        exp_map2: export_map2,\n+        trait_map: trait_map\n     }\n }\n "}, {"sha": "d4081352468da0072f1839128464194fc9ba0cf0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -167,7 +167,7 @@ use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n \n-use std::oldmap::HashMap;\n+use core::hashmap::linear::LinearMap;\n use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_util::path_to_ident;\n@@ -282,7 +282,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n     -> Opt {\n     let ccx = bcx.ccx();\n-    match ccx.tcx.def_map.get(&pat_id) {\n+    match *ccx.tcx.def_map.get(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n             for vec::each(*variants) |v| {\n@@ -323,7 +323,7 @@ pub struct BindingInfo {\n     ty: ty::t,\n }\n \n-pub type BindingsMap = HashMap<ident, BindingInfo>;\n+pub type BindingsMap = LinearMap<ident, BindingInfo>;\n \n pub struct ArmData {\n     bodycx: block,\n@@ -517,7 +517,7 @@ pub fn enter_opt<'r>(bcx: block,\n         match p.node {\n             ast::pat_enum(*) |\n             ast::pat_ident(_, _, None) if pat_is_const(tcx.def_map, p) => {\n-                let const_def = tcx.def_map.get(&p.id);\n+                let const_def = *tcx.def_map.get(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(~[])\n@@ -553,7 +553,7 @@ pub fn enter_opt<'r>(bcx: block,\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n-                    match tcx.def_map.get(&p.id) {\n+                    match *tcx.def_map.get(&p.id) {\n                         ast::def_variant(_, found_struct_id) => {\n                             struct_id = found_struct_id;\n                         }\n@@ -801,15 +801,15 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n                 match ccx.tcx.def_map.find(&cur.id) {\n-                    Some(ast::def_variant(*)) => {\n+                    Some(&ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(ast::def_struct(*)) => {\n+                    Some(&ast::def_struct(*)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n-                    Some(ast::def_const(const_did)) => {\n+                    Some(&ast::def_const(const_did)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -820,11 +820,11 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n                 // This could be one of: a tuple-like enum variant, a\n                 // struct-like enum variant, or a struct.\n                 match ccx.tcx.def_map.find(&cur.id) {\n-                    Some(ast::def_variant(*)) => {\n+                    Some(&ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(ast::def_const(const_did)) => {\n+                    Some(&ast::def_const(const_did)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -959,7 +959,7 @@ pub fn root_pats_as_necessary(bcx: block,\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         match bcx.ccx().maps.root_map.find(&key) {\n             None => (),\n-            Some(root_info) => {\n+            Some(&root_info) => {\n                 // Note: the scope_id will always be the id of the match.  See\n                 // the extended comment in rustc::middle::borrowck::preserve()\n                 // for details (look for the case covering cat_discr).\n@@ -1013,7 +1013,7 @@ pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {\n                 match bcx.tcx().def_map.find(&pat.id) {\n-                    Some(ast::def_struct(*)) => true,\n+                    Some(&ast::def_struct(*)) => true,\n                     _ => false\n                 }\n             }\n@@ -1620,7 +1620,7 @@ pub fn trans_match_inner(scope_cx: block,\n         // to an alloca() that will be the value for that local variable.\n         // Note that we use the names because each binding will have many ids\n         // from the various alternatives.\n-        let bindings_map = HashMap();\n+        let mut bindings_map = LinearMap::new();\n         do pat_bindings(tcx.def_map, arm.pats[0]) |bm, p_id, _s, path| {\n             let ident = path_to_ident(path);\n             let variable_ty = node_id_type(bcx, p_id);\n@@ -1633,7 +1633,7 @@ pub fn trans_match_inner(scope_cx: block,\n                     // but during matching we need to store a *T as explained\n                     // above\n                     let is_move =\n-                        scope_cx.ccx().maps.moves_map.contains_key(&p_id);\n+                        scope_cx.ccx().maps.moves_map.contains(&p_id);\n                     llmatch = alloca(bcx, T_ptr(llvariable_ty));\n                     trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n                 }\n@@ -1765,7 +1765,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n         }\n         ast::pat_enum(_, ref sub_pats) => {\n             match bcx.tcx().def_map.find(&pat.id) {\n-                Some(ast::def_variant(enum_id, var_id)) => {\n+                Some(&ast::def_variant(enum_id, var_id)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ty::enum_variant_with_id(ccx.tcx,\n                                                          enum_id,\n@@ -1784,7 +1784,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                         }\n                     }\n                 }\n-                Some(ast::def_struct(*)) => {\n+                Some(&ast::def_struct(*)) => {\n                     match *sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here.\n@@ -1804,7 +1804,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                         }\n                     }\n                 }\n-                Some(ast::def_const(*)) => {\n+                Some(&ast::def_const(*)) => {\n                     bcx = bind_irrefutable_pat(bcx, pat, val, make_copy, binding_mode);\n                 }\n                 _ => {"}, {"sha": "a4f0c7c73cd4efb65cdafe4cf586d888f0bde599", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -67,7 +67,7 @@ use util::ppaux::{ty_to_str, ty_to_short_str};\n use util::ppaux;\n \n use core::hash;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n use core::int;\n use core::io;\n use core::libc::{c_uint, c_ulonglong};\n@@ -383,7 +383,7 @@ pub fn get_tydesc_simple(ccx: @CrateContext, t: ty::t) -> ValueRef {\n \n pub fn get_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     match ccx.tydescs.find(&t) {\n-      Some(inf) => inf,\n+      Some(&inf) => inf,\n       _ => {\n         ccx.stats.n_static_tydescs += 1u;\n         let inf = glue::declare_tydesc(ccx, t);\n@@ -467,10 +467,12 @@ pub fn set_glue_inlining(f: ValueRef, t: ty::t) {\n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: @CrateContext, +sym: ~str) {\n-    if ccx.all_llvm_symbols.contains_key(&sym) {\n+    // XXX: this should not be necessary\n+    use core::container::Set;\n+    if ccx.all_llvm_symbols.contains(&sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n-    ccx.all_llvm_symbols.insert(sym, ());\n+    ccx.all_llvm_symbols.insert(sym);\n }\n \n \n@@ -1100,7 +1102,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n     }\n \n     let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n-      Some(local_mem(v)) => v,\n+      Some(&local_mem(v)) => v,\n       _ => { bcx.tcx().sess.span_bug(local.span,\n                         ~\"init_local: Someone forgot to document why it's\\\n                          safe to assume local.node.init must be local_mem!\");\n@@ -1453,7 +1455,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n       | session::arch_mips => ~\"llvm.memcpy.p0i8.p0i8.i32\",\n       session::arch_x86_64 => ~\"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n-    let memcpy = ccx.intrinsics.get(&key);\n+    let memcpy = *ccx.intrinsics.get(&key);\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n@@ -1502,7 +1504,7 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n         }\n     }\n \n-    let llintrinsicfn = ccx.intrinsics.get(&intrinsic_key);\n+    let llintrinsicfn = *ccx.intrinsics.get(&intrinsic_key);\n     let llptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n     let llzeroval = C_u8(0);\n     let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n@@ -1601,9 +1603,9 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n           llself: None,\n           personality: None,\n           loop_ret: None,\n-          llargs: @HashMap(),\n-          lllocals: @HashMap(),\n-          llupvars: @HashMap(),\n+          llargs: @mut LinearMap::new(),\n+          lllocals: @mut LinearMap::new(),\n+          llupvars: @mut LinearMap::new(),\n           id: id,\n           impl_id: impl_id,\n           param_substs: param_substs,\n@@ -1905,7 +1907,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n         let llarg = match fcx.llargs.find(&va.id) {\n-            Some(local_mem(x)) => x,\n+            Some(&local_mem(x)) => x,\n             _ => fail!(~\"trans_enum_variant: how do we know this works?\"),\n         };\n         let arg_ty = arg_tys[i].ty;\n@@ -1969,7 +1971,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n \n     for fields.eachi |i, field| {\n         let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr, 0, i);\n-        let llarg = match fcx.llargs.get(&field.node.id) {\n+        let llarg = match *fcx.llargs.get(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n                 ccx.tcx.sess.bug(~\"trans_tuple_struct: llarg wasn't \\\n@@ -2347,7 +2349,7 @@ pub fn get_dtor_symbol(ccx: @CrateContext,\n                     -> ~str {\n   let t = ty::node_id_to_type(ccx.tcx, id);\n   match ccx.item_symbols.find(&id) {\n-     Some(ref s) => (/*bad*/copy *s),\n+     Some(s) => (/*bad*/copy *s),\n      None if substs.is_none() => {\n        let s = mangle_exported_name(\n            ccx,\n@@ -2382,7 +2384,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n     let tcx = ccx.tcx;\n     match ccx.item_vals.find(&id) {\n-      Some(v) => v,\n+      Some(&v) => v,\n       None => {\n \n         let mut exprt = false;\n@@ -2538,7 +2540,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             ccx.sess.bug(~\"get_item_val(): unexpected variant\")\n           }\n         };\n-        if !(exprt || ccx.reachable.contains_key(&id)) {\n+        if !(exprt || ccx.reachable.contains(&id)) {\n             lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n         }\n         ccx.item_vals.insert(id, val);\n@@ -2617,7 +2619,7 @@ pub fn p2i(ccx: @CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n+pub fn declare_intrinsics(llmod: ModuleRef) -> LinearMap<~str, ValueRef> {\n     let T_memcpy32_args: ~[TypeRef] =\n         ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n     let T_memcpy64_args: ~[TypeRef] =\n@@ -2750,7 +2752,7 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n     let bswap64 = decl_cdecl_fn(llmod, ~\"llvm.bswap.i64\",\n                                 T_fn(~[T_i64()], T_i64()));\n \n-    let intrinsics = HashMap();\n+    let mut intrinsics = LinearMap::new();\n     intrinsics.insert(~\"llvm.gcroot\", gcroot);\n     intrinsics.insert(~\"llvm.gcread\", gcread);\n     intrinsics.insert(~\"llvm.memcpy.p0i8.p0i8.i32\", memcpy32);\n@@ -2811,7 +2813,7 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n }\n \n pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n-                              intrinsics: HashMap<~str, ValueRef>) {\n+                              intrinsics: &mut LinearMap<~str, ValueRef>) {\n     let declare =\n         decl_cdecl_fn(llmod, ~\"llvm.dbg.declare\",\n                       T_fn(~[T_metadata(), T_metadata()], T_void()));\n@@ -2826,7 +2828,7 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n pub fn trap(bcx: block) {\n     let v: ~[ValueRef] = ~[];\n     match bcx.ccx().intrinsics.find(&~\"llvm.trap\") {\n-      Some(x) => { Call(bcx, x, v); },\n+      Some(&x) => { Call(bcx, x, v); },\n       _ => bcx.sess().bug(~\"unbound llvm.trap in trap\")\n     }\n }\n@@ -2861,8 +2863,8 @@ pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n         lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     }\n     let mut elts: ~[ValueRef] = ~[];\n-    for ccx.module_data.each |&key, &val| {\n-        let elt = C_struct(~[p2i(ccx, C_cstr(ccx, @/*bad*/ copy key)),\n+    for ccx.module_data.each |&(key, &val)| {\n+        let elt = C_struct(~[p2i(ccx, C_cstr(ccx, @/*bad*/ copy *key)),\n                             p2i(ccx, val)]);\n         elts.push(elt);\n     }\n@@ -3036,9 +3038,9 @@ pub fn trans_crate(sess: session::Session,\n         let targ_cfg = sess.targ_cfg;\n         let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n         let tn = mk_type_names();\n-        let intrinsics = declare_intrinsics(llmod);\n+        let mut intrinsics = declare_intrinsics(llmod);\n         if sess.opts.extra_debuginfo {\n-            declare_dbg_intrinsics(llmod, intrinsics);\n+            declare_dbg_intrinsics(llmod, &mut intrinsics);\n         }\n         let int_type = T_int(targ_cfg);\n         let float_type = T_float(targ_cfg);\n@@ -3061,34 +3063,34 @@ pub fn trans_crate(sess: session::Session,\n               tn: tn,\n               externs: HashMap(),\n               intrinsics: intrinsics,\n-              item_vals: HashMap(),\n+              item_vals: @mut LinearMap::new(),\n               exp_map2: emap2,\n               reachable: reachable,\n-              item_symbols: HashMap(),\n+              item_symbols: @mut LinearMap::new(),\n               link_meta: link_meta,\n-              enum_sizes: ty::new_ty_hash(),\n-              discrims: HashMap(),\n-              discrim_symbols: HashMap(),\n-              tydescs: ty::new_ty_hash(),\n+              enum_sizes: @mut LinearMap::new(),\n+              discrims: @mut LinearMap::new(),\n+              discrim_symbols: @mut LinearMap::new(),\n+              tydescs: @mut LinearMap::new(),\n               finished_tydescs: @mut false,\n-              external: HashMap(),\n-              monomorphized: HashMap(),\n-              monomorphizing: HashMap(),\n-              type_use_cache: HashMap(),\n-              vtables: oldmap::HashMap(),\n-              const_cstr_cache: HashMap(),\n-              const_globals: HashMap(),\n-              const_values: HashMap(),\n-              module_data: HashMap(),\n+              external: @mut LinearMap::new(),\n+              monomorphized: @mut LinearMap::new(),\n+              monomorphizing: @mut LinearMap::new(),\n+              type_use_cache: @mut LinearMap::new(),\n+              vtables: @mut LinearMap::new(),\n+              const_cstr_cache: @mut LinearMap::new(),\n+              const_globals: @mut LinearMap::new(),\n+              const_values: @mut LinearMap::new(),\n+              module_data: @mut LinearMap::new(),\n               lltypes: ty::new_ty_hash(),\n               llsizingtypes: ty::new_ty_hash(),\n               adt_reprs: @mut LinearMap::new(),\n               names: new_namegen(sess.parse_sess.interner),\n               next_addrspace: new_addrspace_gen(),\n               symbol_hasher: symbol_hasher,\n-              type_hashcodes: ty::new_ty_hash(),\n-              type_short_names: ty::new_ty_hash(),\n-              all_llvm_symbols: HashMap(),\n+              type_hashcodes: @mut LinearMap::new(),\n+              type_short_names: @mut LinearMap::new(),\n+              all_llvm_symbols: @mut LinearSet::new(),\n               tcx: tcx,\n               maps: maps,\n               stats: @mut Stats {\n@@ -3101,7 +3103,7 @@ pub fn trans_crate(sess: session::Session,\n                 n_inlines: 0u,\n                 n_closures: 0u,\n                 llvm_insn_ctxt: @mut ~[],\n-                llvm_insns: HashMap(),\n+                llvm_insns: @mut LinearMap::new(),\n                 fn_times: @mut ~[]\n               },\n               upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n@@ -3151,7 +3153,7 @@ pub fn trans_crate(sess: session::Session,\n         }\n \n         if ccx.sess.count_llvm_insns() {\n-            for ccx.stats.llvm_insns.each |&k, &v| {\n+            for ccx.stats.llvm_insns.each |&(&k, &v)| {\n                 io::println(fmt!(\"%-7u %s\", v, k));\n             }\n         }"}, {"sha": "e8b85c54d487922f30aea3fc021c41bacaeaa61c", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -18,13 +18,13 @@ use syntax::codemap::span;\n \n use core::prelude::*;\n use core::cast;\n+use core::hashmap::linear::LinearMap;\n use core::libc::{c_uint, c_int, c_ulonglong, c_char};\n use core::libc;\n use core::option::Some;\n use core::ptr;\n use core::str;\n use core::vec;\n-use std::oldmap::HashMap;\n \n pub fn terminate(cx: block, _: &str) {\n     unsafe {\n@@ -55,7 +55,7 @@ pub fn count_insn(cx: block, category: &str) {\n         // Build version of path with cycles removed.\n \n         // Pass 1: scan table mapping str -> rightmost pos.\n-        let mm = HashMap();\n+        let mut mm = LinearMap::new();\n         let len = vec::len(*v);\n         let mut i = 0u;\n         while i < len {\n@@ -70,7 +70,7 @@ pub fn count_insn(cx: block, category: &str) {\n         let mut s = ~\".\";\n         i = 0u;\n         while i < len {\n-            i = mm.get(&v[i]);\n+            i = *mm.get(&v[i]);\n             s += ~\"/\";\n             s += v[i];\n             i += 1u;\n@@ -80,7 +80,7 @@ pub fn count_insn(cx: block, category: &str) {\n         s += category;\n \n         let n = match h.find(&s) {\n-          Some(n) => n,\n+          Some(&n) => n,\n           _ => 0u\n         };\n         h.insert(s, n+1u);"}, {"sha": "e2a5b5f500976f40d26d494870c2eaa95f0f87be", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -700,7 +700,7 @@ pub fn trans_arg_expr(bcx: block,\n         match autoref_arg {\n             DoAutorefArg => {\n                 fail_unless!(!\n-                    bcx.ccx().maps.moves_map.contains_key(&arg_expr.id));\n+                    bcx.ccx().maps.moves_map.contains(&arg_expr.id));\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {"}, {"sha": "74d338bbbb5eddbf0413e3951a2b5520b6f42ebe", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -411,7 +411,7 @@ pub fn trans_expr_fn(bcx: block,\n \n     let Result {bcx: bcx, val: closure} = match sigil {\n         ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n-            let cap_vars = ccx.maps.capture_map.get(&user_id);\n+            let cap_vars = *ccx.maps.capture_map.get(&user_id);\n             let ret_handle = match is_loop_body {Some(x) => x,\n                                                  None => None};\n             let ClosureResult {llbox, cdata_ty, bcx}"}, {"sha": "437562e3a1344df9a70ce303b787389828b28b1c", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -45,7 +45,7 @@ use util::ppaux::{expr_repr, ty_to_str};\n \n use core::cast;\n use core::hash;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::ptr;\n use core::str;\n@@ -134,7 +134,7 @@ pub struct Stats {\n     n_inlines: uint,\n     n_closures: uint,\n     llvm_insn_ctxt: @mut ~[~str],\n-    llvm_insns: HashMap<~str, uint>,\n+    llvm_insns: @mut LinearMap<~str, uint>,\n     fn_times: @mut ~[(~str, int)] // (ident, time)\n }\n \n@@ -165,30 +165,30 @@ pub struct CrateContext {\n      td: TargetData,\n      tn: @TypeNames,\n      externs: ExternMap,\n-     intrinsics: HashMap<~str, ValueRef>,\n-     item_vals: HashMap<ast::node_id, ValueRef>,\n+     intrinsics: LinearMap<~str, ValueRef>,\n+     item_vals: @mut LinearMap<ast::node_id, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n      reachable: reachable::map,\n-     item_symbols: HashMap<ast::node_id, ~str>,\n+     item_symbols: @mut LinearMap<ast::node_id, ~str>,\n      link_meta: LinkMeta,\n-     enum_sizes: HashMap<ty::t, uint>,\n-     discrims: HashMap<ast::def_id, ValueRef>,\n-     discrim_symbols: HashMap<ast::node_id, ~str>,\n-     tydescs: HashMap<ty::t, @mut tydesc_info>,\n+     enum_sizes: @mut LinearMap<ty::t, uint>,\n+     discrims: @mut LinearMap<ast::def_id, ValueRef>,\n+     discrim_symbols: @mut LinearMap<ast::node_id, ~str>,\n+     tydescs: @mut LinearMap<ty::t, @mut tydesc_info>,\n      // Set when running emit_tydescs to enforce that no more tydescs are\n      // created.\n      finished_tydescs: @mut bool,\n      // Track mapping of external ids to local items imported for inlining\n-     external: HashMap<ast::def_id, Option<ast::node_id>>,\n+     external: @mut LinearMap<ast::def_id, Option<ast::node_id>>,\n      // Cache instances of monomorphized functions\n-     monomorphized: HashMap<mono_id, ValueRef>,\n-     monomorphizing: HashMap<ast::def_id, uint>,\n+     monomorphized: @mut LinearMap<mono_id, ValueRef>,\n+     monomorphizing: @mut LinearMap<ast::def_id, uint>,\n      // Cache computed type parameter uses (see type_use.rs)\n-     type_use_cache: HashMap<ast::def_id, ~[type_use::type_uses]>,\n+     type_use_cache: @mut LinearMap<ast::def_id, ~[type_use::type_uses]>,\n      // Cache generated vtables\n-     vtables: HashMap<mono_id, ValueRef>,\n+     vtables: @mut LinearMap<mono_id, ValueRef>,\n      // Cache of constant strings,\n-     const_cstr_cache: HashMap<@~str, ValueRef>,\n+     const_cstr_cache: @mut LinearMap<@~str, ValueRef>,\n \n      // Reverse-direction for const ptrs cast from globals.\n      // Key is an int, cast from a ValueRef holding a *T,\n@@ -198,20 +198,20 @@ pub struct CrateContext {\n      // when we ptrcast, and we have to ptrcast during translation\n      // of a [T] const because we form a slice, a [*T,int] pair, not\n      // a pointer to an LLVM array type.\n-     const_globals: HashMap<int, ValueRef>,\n+     const_globals: @mut LinearMap<int, ValueRef>,\n \n      // Cache of emitted const values\n-     const_values: HashMap<ast::node_id, ValueRef>,\n-     module_data: HashMap<~str, ValueRef>,\n+     const_values: @mut LinearMap<ast::node_id, ValueRef>,\n+     module_data: @mut LinearMap<~str, ValueRef>,\n      lltypes: HashMap<ty::t, TypeRef>,\n      llsizingtypes: HashMap<ty::t, TypeRef>,\n      adt_reprs: @mut LinearMap<ty::t, @adt::Repr>,\n      names: namegen,\n      next_addrspace: addrspace_gen,\n      symbol_hasher: @hash::State,\n-     type_hashcodes: HashMap<ty::t, @str>,\n-     type_short_names: HashMap<ty::t, ~str>,\n-     all_llvm_symbols: Set<~str>,\n+     type_hashcodes: @mut LinearMap<ty::t, @str>,\n+     type_short_names: @mut LinearMap<ty::t, ~str>,\n+     all_llvm_symbols: @mut LinearSet<~str>,\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n      stats: @mut Stats,\n@@ -310,12 +310,12 @@ pub struct fn_ctxt_ {\n     loop_ret: Option<(ValueRef, ValueRef)>,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: @HashMap<ast::node_id, local_val>,\n+    llargs: @mut LinearMap<ast::node_id, local_val>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: @HashMap<ast::node_id, local_val>,\n+    lllocals: @mut LinearMap<ast::node_id, local_val>,\n     // Same as above, but for closure upvars\n-    llupvars: @HashMap<ast::node_id, ValueRef>,\n+    llupvars: @mut LinearMap<ast::node_id, ValueRef>,\n \n     // The node_id of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n@@ -712,7 +712,7 @@ pub impl block_ {\n \n     fn def(@mut self, nid: ast::node_id) -> ast::def {\n         match self.tcx().def_map.find(&nid) {\n-            Some(v) => v,\n+            Some(&v) => v,\n             None => {\n                 self.tcx().sess.bug(fmt!(\n                     \"No def associated with node id %?\", nid));\n@@ -1132,7 +1132,7 @@ pub fn C_u8(i: uint) -> ValueRef {\n pub fn C_cstr(cx: @CrateContext, s: @~str) -> ValueRef {\n     unsafe {\n         match cx.const_cstr_cache.find(&s) {\n-            Some(llval) => return llval,\n+            Some(&llval) => return llval,\n             None => ()\n         }\n \n@@ -1400,7 +1400,7 @@ pub fn node_vtables(bcx: block, id: ast::node_id)\n                  -> Option<typeck::vtable_res> {\n     let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n     raw_vtables.map(\n-        |vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n+        |&vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n \n pub fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)"}, {"sha": "a929a53a769b93929bbd6acd86e602892e414939", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -110,7 +110,7 @@ fn const_addr_of(cx: @CrateContext, cv: ValueRef) -> ValueRef {\n \n fn const_deref_ptr(cx: @CrateContext, v: ValueRef) -> ValueRef {\n     let v = match cx.const_globals.find(&(v as int)) {\n-        Some(v) => v,\n+        Some(&v) => v,\n         None => v\n     };\n     unsafe {\n@@ -167,22 +167,22 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n             _ => cx.tcx.sess.bug(~\"expected a const to be an item\")\n         }\n     }\n-    cx.const_values.get(&def_id.node)\n+    *cx.const_values.get(&def_id.node)\n }\n \n pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     let mut llconst = const_expr_unadjusted(cx, e);\n     let ety = ty::expr_ty(cx.tcx, e);\n     match cx.tcx.adjustments.find(&e.id) {\n         None => { }\n-        Some(@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n+        Some(&@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n             llconst = C_struct(~[llconst, C_null(T_opaque_box_ptr(cx))])\n         }\n-        Some(@ty::AutoAddEnv(ref r, ref s)) => {\n+        Some(&@ty::AutoAddEnv(ref r, ref s)) => {\n             cx.sess.span_bug(e.span, fmt!(\"unexpected static function: \\\n                                            region %? sigil %?\", *r, *s))\n         }\n-        Some(@ty::AutoDerefRef(ref adj)) => {\n+        Some(&@ty::AutoDerefRef(ref adj)) => {\n             let mut ty = ety;\n             let mut maybe_ptr = None;\n             for adj.autoderefs.times {\n@@ -496,7 +496,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n           ast::expr_path(pth) => {\n             fail_unless!(pth.types.len() == 0);\n             match cx.tcx.def_map.find(&e.id) {\n-                Some(ast::def_fn(def_id, _purity)) => {\n+                Some(&ast::def_fn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n                         base::trans_external_path(cx, def_id, ty)\n@@ -505,18 +505,18 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                         base::get_item_val(cx, def_id.node)\n                     }\n                 }\n-                Some(ast::def_const(def_id)) => {\n+                Some(&ast::def_const(def_id)) => {\n                     get_const_val(cx, def_id)\n                 }\n-                Some(ast::def_variant(enum_did, variant_did)) => {\n+                Some(&ast::def_variant(enum_did, variant_did)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                          enum_did,\n                                                          variant_did);\n                     adt::trans_const(cx, repr, vinfo.disr_val, [])\n                 }\n-                Some(ast::def_struct(_)) => {\n+                Some(&ast::def_struct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let llty = type_of::type_of(cx, ety);\n                     C_null(llty)\n@@ -529,13 +529,13 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n           }\n           ast::expr_call(callee, ref args, _) => {\n               match cx.tcx.def_map.find(&callee.id) {\n-                  Some(ast::def_struct(_)) => {\n+                  Some(&ast::def_struct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       adt::trans_const(cx, repr, 0,\n                                        args.map(|a| const_expr(cx, *a)))\n                   }\n-                  Some(ast::def_variant(enum_did, variant_did)) => {\n+                  Some(&ast::def_variant(enum_did, variant_did)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n@@ -561,7 +561,7 @@ pub fn trans_const(ccx: @CrateContext, _e: @ast::expr, id: ast::node_id) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.const_values.get(&id);\n+        let v = *ccx.const_values.get(&id);\n         llvm::LLVMSetInitializer(g, v);\n         llvm::LLVMSetGlobalConstant(g, True);\n     }"}, {"sha": "1c201d0def69b3f468e15b03d0141b244995f386", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -196,7 +196,7 @@ pub fn trans_log(log_ex: @ast::expr,\n     };\n \n     let global = if ccx.module_data.contains_key(&modname) {\n-        ccx.module_data.get(&modname)\n+        *ccx.module_data.get(&modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, ~\"loglevel\");"}, {"sha": "bb7fae9ae33aaaff231e031f603f8e94fa500a56", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -105,6 +105,7 @@ use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n use core::cmp;\n+use core::container::Set; // XXX: this should not be necessary\n use core::to_bytes;\n use core::uint;\n use syntax::ast;\n@@ -230,7 +231,7 @@ pub impl Datum {\n          * `id` is located in the move table, but copies otherwise.\n          */\n \n-        if bcx.ccx().maps.moves_map.contains_key(&id) {\n+        if bcx.ccx().maps.moves_map.contains(&id) {\n             self.move_to(bcx, action, dst)\n         } else {\n             self.copy_to(bcx, action, dst)\n@@ -646,16 +647,15 @@ pub impl Datum {\n         let key = root_map_key { id: expr_id, derefs: derefs };\n         let bcx = match ccx.maps.root_map.find(&key) {\n             None => bcx,\n-            Some(root_info) => self.root(bcx, root_info)\n+            Some(&root_info) => self.root(bcx, root_info)\n         };\n \n         // Perform the write guard, if necessary.\n         //\n         // (Note: write-guarded values are always boxes)\n-        let bcx = match ccx.maps.write_guard_map.find(&key) {\n-            None => bcx,\n-            Some(_) => self.perform_write_guard(bcx)\n-        };\n+        let bcx = if ccx.maps.write_guard_map.contains(&key) {\n+            self.perform_write_guard(bcx)\n+        } else { bcx };\n \n         match ty::get(self.ty).sty {\n             ty::ty_box(_) | ty::ty_uniq(_) => {"}, {"sha": "50c7017029be6a3edfe66e49b375a1141290fe32", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -20,11 +20,10 @@ use middle::trans;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use core::hashmap::linear::LinearMap;\n use core::libc;\n use core::option;\n use core::sys;\n-use std::oldmap::HashMap;\n-use std::oldmap;\n use syntax::codemap::{span, CharPos};\n use syntax::parse::token::ident_interner;\n use syntax::{ast, codemap, ast_util, ast_map};\n@@ -107,19 +106,18 @@ pub struct DebugContext {\n \n pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> DebugContext {\n     DebugContext {\n-        llmetadata: oldmap::HashMap(),\n+        llmetadata: @mut LinearMap::new(),\n         names: new_namegen(intr),\n         crate_file: crate\n     }\n }\n \n fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n-    let existing = if cache.contains_key(&mdtag) {\n-        cache.get(&mdtag)\n-    } else {\n-        ~[]\n+    let mut existing = match cache.pop(&mdtag) {\n+        Some(arr) => arr, None => ~[]\n     };\n-    cache.insert(mdtag, vec::append_one(existing, val));\n+    existing.push(val);\n+    cache.insert(mdtag, existing);\n }\n \n struct Metadata<T> {\n@@ -153,7 +151,7 @@ struct RetvalMetadata {\n     id: ast::node_id\n }\n \n-type metadata_cache = HashMap<int, ~[debug_metadata]>;\n+type metadata_cache = @mut LinearMap<int, ~[debug_metadata]>;\n \n enum debug_metadata {\n     file_metadata(@Metadata<FileMetadata>),\n@@ -318,7 +316,7 @@ fn create_block(cx: block) -> @Metadata<BlockMetadata> {\n     };\n     let file_node = create_file(cx.ccx(), fname);\n     let unique_id = match cache.find(&LexicalBlockTag) {\n-      option::Some(v) => vec::len(v) as int,\n+      option::Some(v) => v.len() as int,\n       option::None => 0\n     };\n     let lldata = ~[lltag(tg),\n@@ -746,21 +744,21 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n \n         let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n-          option::Some(local_mem(v)) => v,\n+          option::Some(&local_mem(v)) => v,\n           option::Some(_) => {\n             bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                     something weird\");\n           }\n           option::None => {\n-            match bcx.fcx.lllocals.get(&local.node.pat.id) {\n+            match *bcx.fcx.lllocals.get(&local.node.pat.id) {\n               local_imm(v) => v,\n               _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                                                          something weird\")\n             }\n           }\n         };\n         let declargs = ~[llmdnode(~[llptr]), mdnode];\n-        trans::build::Call(bcx, cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+        trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n                            declargs);\n         return mdval;\n     }\n@@ -807,12 +805,12 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n                 };\n                 update_cache(cache, tg, argument_metadata(mdval));\n \n-                let llptr = match fcx.llargs.get(&arg.id) {\n+                let llptr = match *fcx.llargs.get(&arg.id) {\n                   local_mem(v) | local_imm(v) => v,\n                 };\n                 let declargs = ~[llmdnode(~[llptr]), mdnode];\n                 trans::build::Call(bcx,\n-                                   cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+                                   *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n                                    declargs);\n                 return Some(mdval);\n             }"}, {"sha": "2fad2bd9b606de1011c1c38ba379332d2ee1b229", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -150,7 +150,7 @@ use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n-use std::oldmap::HashMap;\n+use core::hashmap::linear::LinearMap;\n use syntax::print::pprust::{expr_to_str};\n use syntax::ast;\n use syntax::codemap;\n@@ -198,14 +198,14 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         None => {\n             trans_to_datum_unadjusted(bcx, expr)\n         }\n-        Some(@AutoAddEnv(*)) => {\n+        Some(&@AutoAddEnv(*)) => {\n             let mut bcx = bcx;\n             let mut datum = unpack_datum!(bcx, {\n                 trans_to_datum_unadjusted(bcx, expr)\n             });\n             add_env(bcx, expr, datum)\n         }\n-        Some(@AutoDerefRef(ref adj)) => {\n+        Some(&@AutoDerefRef(ref adj)) => {\n             let mut bcx = bcx;\n             let mut datum = unpack_datum!(bcx, {\n                 trans_to_datum_unadjusted(bcx, expr)\n@@ -925,7 +925,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     // at the end of the scope with id `scope_id`:\n     let root_key = root_map_key { id: expr.id, derefs: 0u };\n     for bcx.ccx().maps.root_map.find(&root_key).each |&root_info| {\n-        bcx = unrooted_datum.root(bcx, root_info);\n+        bcx = unrooted_datum.root(bcx, *root_info);\n     }\n \n     return DatumBlock {bcx: bcx, datum: unrooted_datum};\n@@ -1131,7 +1131,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.find(&nid) {\n-                Some(val) => {\n+                Some(&val) => {\n                     Datum {\n                         val: val,\n                         ty: local_ty,\n@@ -1146,10 +1146,10 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             }\n         }\n         ast::def_arg(nid, _, _) => {\n-            take_local(bcx, *bcx.fcx.llargs, nid)\n+            take_local(bcx, bcx.fcx.llargs, nid)\n         }\n         ast::def_local(nid, _) | ast::def_binding(nid, _) => {\n-            take_local(bcx, *bcx.fcx.lllocals, nid)\n+            take_local(bcx, bcx.fcx.lllocals, nid)\n         }\n         ast::def_self(nid, _) => {\n             let self_info: ValSelfData = match bcx.fcx.llself {\n@@ -1181,11 +1181,11 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n     };\n \n     fn take_local(bcx: block,\n-                  table: HashMap<ast::node_id, local_val>,\n+                  table: &LinearMap<ast::node_id, local_val>,\n                   nid: ast::node_id) -> Datum {\n         let (v, mode) = match table.find(&nid) {\n-            Some(local_mem(v)) => (v, ByRef),\n-            Some(local_imm(v)) => (v, ByValue),\n+            Some(&local_mem(v)) => (v, ByRef),\n+            Some(&local_imm(v)) => (v, ByValue),\n             None => {\n                 bcx.sess().bug(fmt!(\n                     \"trans_local_var: no llval for local/arg %? found\", nid));\n@@ -1227,7 +1227,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                         ty_to_str(tcx, ty)));\n                 }\n                 Some(node_id) => {\n-                    match tcx.def_map.get(&node_id) {\n+                    match *tcx.def_map.get(&node_id) {\n                         ast::def_variant(enum_id, variant_id) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);"}, {"sha": "05acdae1bb017fbab2be49b96fdd7ee2788b72b3", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -605,7 +605,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                         abi::tydesc_field_visit_glue, None);\n         }\n         ~\"frame_address\" => {\n-            let frameaddress = ccx.intrinsics.get(&~\"llvm.frameaddress\");\n+            let frameaddress = *ccx.intrinsics.get(&~\"llvm.frameaddress\");\n             let frameaddress_val = Call(bcx, frameaddress, ~[C_i32(0i32)]);\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n@@ -644,7 +644,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let size = get_param(decl, first_real_arg + 2);\n             let align = C_i32(1);\n             let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get(\n+            let llfn = *bcx.ccx().intrinsics.get(\n                 &~\"llvm.memmove.p0i8.p0i8.i32\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n         }\n@@ -654,249 +654,249 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let size = get_param(decl, first_real_arg + 2);\n             let align = C_i32(1);\n             let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get(\n+            let llfn = *bcx.ccx().intrinsics.get(\n                 &~\"llvm.memmove.p0i8.p0i8.i64\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n         }\n         ~\"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get(&~\"llvm.sqrt.f32\");\n+            let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f32\");\n             Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n         }\n         ~\"sqrtf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get(&~\"llvm.sqrt.f64\");\n+            let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f64\");\n             Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n         }\n         ~\"powif32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get(&~\"llvm.powi.f32\");\n+            let powif = *ccx.intrinsics.get(&~\"llvm.powi.f32\");\n             Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n         }\n         ~\"powif64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get(&~\"llvm.powi.f64\");\n+            let powif = *ccx.intrinsics.get(&~\"llvm.powi.f64\");\n             Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n         }\n         ~\"sinf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get(&~\"llvm.sin.f32\");\n+            let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f32\");\n             Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n         }\n         ~\"sinf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get(&~\"llvm.sin.f64\");\n+            let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f64\");\n             Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n         }\n         ~\"cosf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get(&~\"llvm.cos.f32\");\n+            let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f32\");\n             Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n         }\n         ~\"cosf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get(&~\"llvm.cos.f64\");\n+            let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f64\");\n             Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n         }\n         ~\"powf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get(&~\"llvm.pow.f32\");\n+            let powf = *ccx.intrinsics.get(&~\"llvm.pow.f32\");\n             Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n         }\n         ~\"powf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get(&~\"llvm.pow.f64\");\n+            let powf = *ccx.intrinsics.get(&~\"llvm.pow.f64\");\n             Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n         }\n         ~\"expf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get(&~\"llvm.exp.f32\");\n+            let expf = *ccx.intrinsics.get(&~\"llvm.exp.f32\");\n             Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n         }\n         ~\"expf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get(&~\"llvm.exp.f64\");\n+            let expf = *ccx.intrinsics.get(&~\"llvm.exp.f64\");\n             Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n         }\n         ~\"exp2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get(&~\"llvm.exp2.f32\");\n+            let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f32\");\n             Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n         }\n         ~\"exp2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get(&~\"llvm.exp2.f64\");\n+            let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f64\");\n             Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n         }\n         ~\"logf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get(&~\"llvm.log.f32\");\n+            let logf = *ccx.intrinsics.get(&~\"llvm.log.f32\");\n             Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n         }\n         ~\"logf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get(&~\"llvm.log.f64\");\n+            let logf = *ccx.intrinsics.get(&~\"llvm.log.f64\");\n             Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n         }\n         ~\"log10f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get(&~\"llvm.log10.f32\");\n+            let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f32\");\n             Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n         }\n         ~\"log10f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get(&~\"llvm.log10.f64\");\n+            let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f64\");\n             Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n         }\n         ~\"log2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get(&~\"llvm.log2.f32\");\n+            let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f32\");\n             Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n         }\n         ~\"log2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get(&~\"llvm.log2.f64\");\n+            let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f64\");\n             Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n         }\n         ~\"fmaf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get(&~\"llvm.fma.f32\");\n+            let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f32\");\n             Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n         }\n         ~\"fmaf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get(&~\"llvm.fma.f64\");\n+            let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f64\");\n             Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n         }\n         ~\"fabsf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get(&~\"llvm.fabs.f32\");\n+            let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f32\");\n             Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n         }\n         ~\"fabsf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get(&~\"llvm.fabs.f64\");\n+            let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f64\");\n             Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n         }\n         ~\"floorf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get(&~\"llvm.floor.f32\");\n+            let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f32\");\n             Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n         }\n         ~\"floorf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get(&~\"llvm.floor.f64\");\n+            let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f64\");\n             Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n         }\n         ~\"ceilf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get(&~\"llvm.ceil.f32\");\n+            let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f32\");\n             Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n         }\n         ~\"ceilf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get(&~\"llvm.ceil.f64\");\n+            let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f64\");\n             Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n         }\n         ~\"truncf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get(&~\"llvm.trunc.f32\");\n+            let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f32\");\n             Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n         }\n         ~\"truncf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get(&~\"llvm.trunc.f64\");\n+            let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f64\");\n             Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n         }\n         ~\"ctpop8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i8\");\n+            let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i8\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i16\");\n+            let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i16\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i32\");\n+            let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i32\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i64\");\n+            let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i64\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n+            let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n+            let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n+            let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n+            let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n+            let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n+            let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n+            let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n+            let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"bswap16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i16\");\n+            let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i16\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         ~\"bswap32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i32\");\n+            let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i32\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         ~\"bswap64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i64\");\n+            let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i64\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         _ => {"}, {"sha": "906519543d2ea0625b3772685f307d5749cf7360", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -32,13 +32,13 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(&fn_id) {\n-      Some(Some(node_id)) => {\n+      Some(&Some(node_id)) => {\n         // Already inline\n         debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n                ty::item_path_str(ccx.tcx, fn_id), node_id);\n         local_def(node_id)\n       }\n-      Some(None) => fn_id, // Not inlinable\n+      Some(&None) => fn_id, // Not inlinable\n       None => { // Not seen yet\n         match csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,"}, {"sha": "047968ed56979aefd3b85a69915d8c06534e1af6", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -10,6 +10,7 @@\n \n // Information concerning the machine representation of various types.\n \n+use core::prelude::*;\n \n use lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n use lib::llvm::{True, False, Bool};\n@@ -119,7 +120,7 @@ pub fn llalign_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n // Computes the size of the data part of an enum.\n pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(&t) {\n-        return cx.enum_sizes.get(&t);\n+        return *cx.enum_sizes.get(&t);\n     }\n \n     debug!(\"static_size_of_enum %s\", ty_to_str(cx.tcx, t));"}, {"sha": "66a28a03bd8454796ccd6c2efeb502c73b004c38", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -323,7 +323,7 @@ pub fn trans_static_method_callee(bcx: block,\n             name=%s\", method_id, callee_id, *ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n-        bcx.fcx, ccx.maps.vtable_map.get(&callee_id));\n+        bcx.fcx, *ccx.maps.vtable_map.get(&callee_id));\n \n     match vtbls[bound_index] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n@@ -764,7 +764,7 @@ pub fn get_vtable(ccx: @CrateContext,\n     // XXX: Bad copy.\n     let hash_id = vtable_id(ccx, copy origin);\n     match ccx.vtables.find(&hash_id) {\n-      Some(val) => val,\n+      Some(&val) => val,\n       None => match origin {\n         typeck::vtable_static(id, substs, sub_vtables) => {\n             make_impl_vtable(ccx, id, substs, sub_vtables)"}, {"sha": "77e521b4af06b39d1daaf81144aabd093f06c0e9", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -77,7 +77,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n            substs.map(|s| ty_to_str(ccx.tcx, *s)), hash_id);\n \n     match ccx.monomorphized.find(&hash_id) {\n-      Some(val) => {\n+      Some(&val) => {\n         debug!(\"leaving monomorphic fn %s\",\n                ty::item_path_str(ccx.tcx, fn_id));\n         return (val, must_cast);\n@@ -142,7 +142,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     ccx.stats.n_monos += 1;\n \n-    let depth = option::get_or_default(ccx.monomorphizing.find(&fn_id), 0u);\n+    let depth = match ccx.monomorphizing.find(&fn_id) {\n+        Some(&d) => d, None => 0\n+    };\n     // Random cut-off -- code that needs to instantiate the same function\n     // recursively more than thirty times can probably safely be assumed to be\n     // causing an infinite expansion."}, {"sha": "c025d970db70f166ad387d91c158ec9ceff3f7d5", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -21,7 +21,7 @@ use middle::ty;\n use middle::typeck;\n \n use core::prelude::*;\n-use std::oldmap::HashMap;\n+use core::hashmap::linear::LinearSet;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::def_id_of_def;\n@@ -30,27 +30,29 @@ use syntax::codemap;\n use syntax::print::pprust::expr_to_str;\n use syntax::{visit, ast_util, ast_map};\n \n-pub type map = HashMap<node_id, ()>;\n+pub type map = @LinearSet<node_id>;\n \n struct ctx {\n     exp_map2: resolve::ExportMap2,\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    rmap: map\n+    rmap: &'self mut LinearSet<node_id>,\n }\n \n pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n                       tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n-    let rmap = HashMap();\n-    let cx = ctx {\n-        exp_map2: exp_map2,\n-        tcx: tcx,\n-        method_map: method_map,\n-        rmap: rmap\n-    };\n-    traverse_public_mod(cx, ast::crate_node_id, crate_mod);\n-    traverse_all_resources_and_impls(cx, crate_mod);\n-    rmap\n+    let mut rmap = LinearSet::new();\n+    {\n+        let cx = ctx {\n+            exp_map2: exp_map2,\n+            tcx: tcx,\n+            method_map: method_map,\n+            rmap: &mut rmap\n+        };\n+        traverse_public_mod(cx, ast::crate_node_id, crate_mod);\n+        traverse_all_resources_and_impls(cx, crate_mod);\n+    }\n+    return @rmap;\n }\n \n fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n@@ -77,10 +79,10 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n       ast_map::node_item(item, _) => traverse_public_item(cx, item),\n       ast_map::node_method(_, impl_id, _) => traverse_def_id(cx, impl_id),\n       ast_map::node_foreign_item(item, _, _, _) => {\n-        cx.rmap.insert(item.id, ());\n+        cx.rmap.insert(item.id);\n       }\n       ast_map::node_variant(ref v, _, _) => {\n-        cx.rmap.insert((*v).node.id, ());\n+        cx.rmap.insert(v.node.id);\n       }\n       _ => ()\n     }\n@@ -96,14 +98,16 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n }\n \n fn traverse_public_item(cx: ctx, item: @item) {\n-    if cx.rmap.contains_key(&item.id) { return; }\n-    cx.rmap.insert(item.id, ());\n+    // XXX: it shouldn't be necessary to do this\n+    let rmap: &mut LinearSet<node_id> = cx.rmap;\n+    if rmap.contains(&item.id) { return; }\n+    rmap.insert(item.id);\n     match item.node {\n       item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n       item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n               for nm.items.each |item| {\n-                  cx.rmap.insert(item.id, ());\n+                  cx.rmap.insert(item.id);\n               }\n           }\n       }\n@@ -119,17 +123,17 @@ fn traverse_public_item(cx: ctx, item: @item) {\n                 m.generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(m.attrs) != attr::ia_none\n             {\n-                cx.rmap.insert(m.id, ());\n+                cx.rmap.insert(m.id);\n                 traverse_inline_body(cx, &m.body);\n             }\n         }\n       }\n       item_struct(ref struct_def, ref generics) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n-            cx.rmap.insert(ctor_id, ());\n+            cx.rmap.insert(ctor_id);\n         }\n         for struct_def.dtor.each |dtor| {\n-            cx.rmap.insert(dtor.node.id, ());\n+            cx.rmap.insert(dtor.node.id);\n             if generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(dtor.node.attrs) != attr::ia_none\n             {\n@@ -151,17 +155,19 @@ fn mk_ty_visitor() -> visit::vt<ctx> {\n                                   ..*visit::default_visitor()})\n }\n \n-fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n-    if cx.rmap.contains_key(&ty.id) { return; }\n-    cx.rmap.insert(ty.id, ());\n+fn traverse_ty(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n+    // XXX: it shouldn't be necessary to do this\n+    let rmap: &mut LinearSet<node_id> = cx.rmap;\n+    if rmap.contains(&ty.id) { return; }\n+    rmap.insert(ty.id);\n \n     match ty.node {\n       ty_path(p, p_id) => {\n         match cx.tcx.def_map.find(&p_id) {\n           // Kind of a hack to check this here, but I'm not sure what else\n           // to do\n-          Some(def_prim_ty(_)) => { /* do nothing */ }\n-          Some(d) => traverse_def_id(cx, def_id_of_def(d)),\n+          Some(&def_prim_ty(_)) => { /* do nothing */ }\n+          Some(&d) => traverse_def_id(cx, def_id_of_def(d)),\n           None    => { /* do nothing -- but should we fail here? */ }\n         }\n         for p.types.each |t| {\n@@ -173,11 +179,11 @@ fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n }\n \n fn traverse_inline_body(cx: ctx, body: &blk) {\n-    fn traverse_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n+    fn traverse_expr(e: @expr, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n         match e.node {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {\n-                Some(d) => {\n+                Some(&d) => {\n                   traverse_def_id(cx, def_id_of_def(d));\n                 }\n                 None      => cx.tcx.sess.span_bug(e.span, fmt!(\"Unbound node \\"}, {"sha": "ab8d03014d62f4083277292d7f5590344cb31ce7", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::prelude::*;\n \n use lib::llvm::llvm;\n use lib::llvm::{TypeRef};"}, {"sha": "ba05d5bca21deb47d805ccc67d1d6d86371f95f2", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -27,6 +27,7 @@\n // much information, but have the disadvantage of being very\n // invasive.)\n \n+use core::prelude::*;\n \n use middle::freevars;\n use middle::trans::common::*;\n@@ -59,7 +60,7 @@ pub struct Context {\n pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n     -> ~[type_uses] {\n     match ccx.type_use_cache.find(&fn_id) {\n-      Some(uses) => return uses,\n+      Some(uses) => return /*bad*/ copy *uses,\n       None => ()\n     }\n \n@@ -295,7 +296,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n       }\n       expr_path(_) => {\n         for cx.ccx.tcx.node_type_substs.find(&e.id).each |ts| {\n-            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(&e.id));\n+            let id = ast_util::def_id_of_def(*cx.ccx.tcx.def_map.get(&e.id));\n             let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n             for vec::each2(uses_for_ts, *ts) |uses, subst| {\n                 type_needs(cx, *uses, *subst)"}, {"sha": "a6b6c71f387a8673d1b5ad770349e5dd0184a2fe", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 55, "deletions": 59, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -37,7 +37,7 @@ use core::result;\n use core::to_bytes;\n use core::uint;\n use core::vec;\n-use core::hashmap::linear::LinearMap;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n use std::oldmap::HashMap;\n use std::oldmap;\n use std::smallintmap::SmallIntMap;\n@@ -118,7 +118,7 @@ pub struct creader_cache_key {\n     len: uint\n }\n \n-type creader_cache = HashMap<creader_cache_key, t>;\n+type creader_cache = @mut LinearMap<creader_cache_key, t>;\n \n impl to_bytes::IterBytes for creader_cache_key {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n@@ -222,7 +222,7 @@ pub enum AutoRefKind {\n // This is a map from ID of each implementation to the method info and trait\n // method ID of each of the default methods belonging to the trait that that\n // implementation implements.\n-pub type ProvidedMethodsMap = HashMap<def_id,@mut ~[@ProvidedMethodInfo]>;\n+pub type ProvidedMethodsMap = @mut LinearMap<def_id,@mut ~[@ProvidedMethodInfo]>;\n \n // Stores the method info and definition ID of the associated trait method for\n // each instantiation of each provided method.\n@@ -245,7 +245,7 @@ pub type ctxt = @ctxt_;\n \n struct ctxt_ {\n     diag: @syntax::diagnostic::span_handler,\n-    interner: HashMap<intern_key, t_box>,\n+    interner: @mut LinearMap<intern_key, t_box>,\n     next_id: @mut uint,\n     vecs_implicitly_copyable: bool,\n     legacy_modes: bool,\n@@ -276,32 +276,32 @@ struct ctxt_ {\n     short_names_cache: HashMap<t, @~str>,\n     needs_unwind_cleanup_cache: HashMap<t, bool>,\n     tc_cache: @mut LinearMap<uint, TypeContents>,\n-    ast_ty_to_ty_cache: HashMap<node_id, ast_ty_to_ty_cache_entry>,\n-    enum_var_cache: HashMap<def_id, @~[VariantInfo]>,\n-    trait_method_cache: HashMap<def_id, @~[method]>,\n-    ty_param_bounds: HashMap<ast::node_id, param_bounds>,\n-    inferred_modes: HashMap<ast::node_id, ast::mode>,\n-    adjustments: HashMap<ast::node_id, @AutoAdjustment>,\n+    ast_ty_to_ty_cache: @mut LinearMap<node_id, ast_ty_to_ty_cache_entry>,\n+    enum_var_cache: @mut LinearMap<def_id, @~[VariantInfo]>,\n+    trait_method_cache: @mut LinearMap<def_id, @~[method]>,\n+    ty_param_bounds: @mut LinearMap<ast::node_id, param_bounds>,\n+    inferred_modes: @mut LinearMap<ast::node_id, ast::mode>,\n+    adjustments: @mut LinearMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n     // A mapping from an implementation ID to the method info and trait\n     // method ID of the provided (a.k.a. default) methods in the traits that\n     // that implementation implements.\n     provided_methods: ProvidedMethodsMap,\n-    provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>,\n-    supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n+    provided_method_sources: @mut LinearMap<ast::def_id, ProvidedMethodSource>,\n+    supertraits: @mut LinearMap<ast::def_id, @~[InstantiatedTraitRef]>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n     // present in this map, it does not have a destructor. This map is\n     // populated during the coherence phase of typechecking.\n-    destructor_for_type: HashMap<ast::def_id, ast::def_id>,\n+    destructor_for_type: @mut LinearMap<ast::def_id, ast::def_id>,\n \n     // A method will be in this list if and only if it is a destructor.\n-    destructors: HashMap<ast::def_id, ()>,\n+    destructors: @mut LinearSet<ast::def_id>,\n \n     // Maps a trait onto a mapping from self-ty to impl\n-    trait_impls: HashMap<ast::def_id, HashMap<t, @Impl>>\n+    trait_impls: @mut LinearMap<ast::def_id, @mut LinearMap<t, @Impl>>\n }\n \n enum tbox_flag {\n@@ -778,14 +778,14 @@ pub struct ty_param_substs_and_ty {\n     ty: ty::t\n }\n \n-type type_cache = HashMap<ast::def_id, ty_param_bounds_and_ty>;\n+type type_cache = @mut LinearMap<ast::def_id, ty_param_bounds_and_ty>;\n \n-type constness_cache = HashMap<ast::def_id, const_eval::constness>;\n+type constness_cache = @mut LinearMap<ast::def_id, const_eval::constness>;\n \n pub type node_type_table = @mut SmallIntMap<t>;\n \n fn mk_rcache() -> creader_cache {\n-    return oldmap::HashMap();\n+    return @mut LinearMap::new();\n }\n \n pub fn new_ty_hash<V:Copy>() -> oldmap::HashMap<t, V> {\n@@ -811,13 +811,12 @@ pub fn mk_ctxt(s: session::Session,\n         }\n     }\n \n-    let interner = oldmap::HashMap();\n     let vecs_implicitly_copyable =\n         get_lint_level(s.lint_settings.default_settings,\n                        lint::vecs_implicitly_copyable) == allow;\n     @ctxt_ {\n         diag: s.diagnostic(),\n-        interner: interner,\n+        interner: @mut LinearMap::new(),\n         next_id: @mut 0,\n         vecs_implicitly_copyable: vecs_implicitly_copyable,\n         legacy_modes: legacy_modes,\n@@ -831,26 +830,26 @@ pub fn mk_ctxt(s: session::Session,\n         items: amap,\n         intrinsic_defs: oldmap::HashMap(),\n         freevars: freevars,\n-        tcache: HashMap(),\n+        tcache: @mut LinearMap::new(),\n         rcache: mk_rcache(),\n-        ccache: HashMap(),\n+        ccache: @mut LinearMap::new(),\n         short_names_cache: new_ty_hash(),\n         needs_unwind_cleanup_cache: new_ty_hash(),\n         tc_cache: @mut LinearMap::new(),\n-        ast_ty_to_ty_cache: HashMap(),\n-        enum_var_cache: HashMap(),\n-        trait_method_cache: HashMap(),\n-        ty_param_bounds: HashMap(),\n-        inferred_modes: HashMap(),\n-        adjustments: HashMap(),\n+        ast_ty_to_ty_cache: @mut LinearMap::new(),\n+        enum_var_cache: @mut LinearMap::new(),\n+        trait_method_cache: @mut LinearMap::new(),\n+        ty_param_bounds: @mut LinearMap::new(),\n+        inferred_modes: @mut LinearMap::new(),\n+        adjustments: @mut LinearMap::new(),\n         normalized_cache: new_ty_hash(),\n         lang_items: lang_items,\n-        provided_methods: HashMap(),\n-        provided_method_sources: HashMap(),\n-        supertraits: HashMap(),\n-        destructor_for_type: HashMap(),\n-        destructors: HashMap(),\n-        trait_impls: HashMap()\n+        provided_methods: @mut LinearMap::new(),\n+        provided_method_sources: @mut LinearMap::new(),\n+        supertraits: @mut LinearMap::new(),\n+        destructor_for_type: @mut LinearMap::new(),\n+        destructors: @mut LinearSet::new(),\n+        trait_impls: @mut LinearMap::new()\n      }\n }\n \n@@ -863,7 +862,7 @@ fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     let key = intern_key { sty: to_unsafe_ptr(&st), o_def_id: o_def_id };\n     match cx.interner.find(&key) {\n-      Some(t) => unsafe { return cast::reinterpret_cast(&t); },\n+      Some(&t) => unsafe { return cast::reinterpret_cast(&t); },\n       _ => ()\n     }\n \n@@ -1161,7 +1160,7 @@ pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n // with id `id`.\n pub fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n     match cx.region_map.find(&id) {\n-      Some(encl_scope) => ty::re_scope(encl_scope),\n+      Some(&encl_scope) => ty::re_scope(encl_scope),\n       None => ty::re_static\n     }\n }\n@@ -2016,7 +2015,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 fail_unless!(p.def_id.crate == ast::local_crate);\n \n                 param_bounds_to_contents(\n-                    cx, cx.ty_param_bounds.get(&p.def_id.node))\n+                    cx, *cx.ty_param_bounds.get(&p.def_id.node))\n             }\n \n             ty_self(_) => {\n@@ -2711,10 +2710,6 @@ impl to_bytes::IterBytes for sty {\n     }\n }\n \n-pub fn br_hashmap<V:Copy>() -> HashMap<bound_region, V> {\n-    oldmap::HashMap()\n-}\n-\n pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     //io::println(fmt!(\"%?/%?\", id, cx.node_types.len()));\n     match cx.node_types.find(&(id as uint)) {\n@@ -2882,7 +2877,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n     return match cx.adjustments.find(&expr.id) {\n         None => unadjusted_ty,\n \n-        Some(@AutoAddEnv(r, s)) => {\n+        Some(&@AutoAddEnv(r, s)) => {\n             match ty::get(unadjusted_ty).sty {\n                 ty::ty_bare_fn(ref b) => {\n                     ty::mk_closure(\n@@ -2900,7 +2895,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n             }\n         }\n \n-        Some(@AutoDerefRef(ref adj)) => {\n+        Some(&@AutoDerefRef(ref adj)) => {\n             let mut adjusted_ty = unadjusted_ty;\n \n             for uint::range(0, adj.autoderefs) |i| {\n@@ -3037,7 +3032,7 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n \n pub fn resolve_expr(tcx: ctxt, expr: @ast::expr) -> ast::def {\n     match tcx.def_map.find(&expr.id) {\n-        Some(def) => def,\n+        Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, fmt!(\n                 \"No def-map entry for expr %?\", expr.id));\n@@ -3270,19 +3265,20 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n \n // Maintains a little union-set tree for inferred modes.  `canon()` returns\n // the current head value for `m0`.\n-fn canon<T:Copy + cmp::Eq>(tbl: HashMap<ast::node_id, ast::inferable<T>>,\n+fn canon<T:Copy + cmp::Eq>(tbl: &mut LinearMap<ast::node_id, ast::inferable<T>>,\n                          +m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n-      ast::infer(id) => match tbl.find(&id) {\n-        None => m0,\n-        Some(ref m1) => {\n-            let cm1 = canon(tbl, (*m1));\n+        ast::infer(id) => {\n+            let m1 = match tbl.find(&id) {\n+                None => return m0,\n+                Some(&m1) => m1\n+            };\n+            let cm1 = canon(tbl, m1);\n             // path compression:\n-            if cm1 != (*m1) { tbl.insert(id, cm1); }\n+            if cm1 != m1 { tbl.insert(id, cm1); }\n             cm1\n-        }\n-      },\n-      _ => m0\n+        },\n+        _ => m0\n     }\n }\n \n@@ -3565,7 +3561,7 @@ pub fn trait_supertraits(cx: ctxt,\n                       -> @~[InstantiatedTraitRef] {\n     // Check the cache.\n     match cx.supertraits.find(&id) {\n-        Some(instantiated_trait_info) => { return instantiated_trait_info; }\n+        Some(&instantiated_trait_info) => { return instantiated_trait_info; }\n         None => {}  // Continue.\n     }\n \n@@ -3598,7 +3594,7 @@ pub fn trait_supertraits(cx: ctxt,\n pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n     match cx.trait_method_cache.find(&id) {\n       // Local traits are supposed to have been added explicitly.\n-      Some(ms) => ms,\n+      Some(&ms) => ms,\n       _ => {\n         // If the lookup in trait_method_cache fails, assume that the trait\n         // method we're trying to look up is in a different crate, and look\n@@ -3736,7 +3732,7 @@ pub impl DtorKind {\n    Otherwise return none. */\n pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n     match cx.destructor_for_type.find(&struct_id) {\n-        Some(method_def_id) => return TraitDtor(method_def_id),\n+        Some(&method_def_id) => return TraitDtor(method_def_id),\n         None => {}  // Continue.\n     }\n \n@@ -3834,7 +3830,7 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n \n pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n     match cx.enum_var_cache.find(&id) {\n-      Some(variants) => return variants,\n+      Some(&variants) => return variants,\n       _ => { /* fallthrough */ }\n     }\n \n@@ -3920,7 +3916,7 @@ pub fn lookup_item_type(cx: ctxt,\n                         did: ast::def_id)\n                      -> ty_param_bounds_and_ty {\n     match cx.tcache.find(&did) {\n-      Some(tpt) => {\n+      Some(&tpt) => {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already\n         return tpt;\n@@ -4299,7 +4295,7 @@ pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n             }\n         };\n \n-        let mut supertrait_map = HashMap();\n+        let mut supertrait_map = LinearMap::new();\n         let mut seen_def_ids = ~[];\n         let mut i = 0;\n         let trait_ty_id = ty_to_def_id(bound_trait_ty).expect("}, {"sha": "4f8f600485e546825b279ced4f0374d542a96739", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -235,11 +235,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n             }\n             ast::ty_path(path, id) if a_seq_ty.mutbl == ast::m_imm => {\n                 match tcx.def_map.find(&id) {\n-                    Some(ast::def_prim_ty(ast::ty_str)) => {\n+                    Some(&ast::def_prim_ty(ast::ty_str)) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n                     }\n-                    Some(ast::def_ty(type_def_id)) => {\n+                    Some(&ast::def_ty(type_def_id)) => {\n                         let result = ast_path_to_substs_and_ty(\n                             self, rscope,\n                             type_def_id, path);\n@@ -303,8 +303,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     let tcx = self.tcx();\n \n     match tcx.ast_ty_to_ty_cache.find(&ast_ty.id) {\n-      Some(ty::atttce_resolved(ty)) => return ty,\n-      Some(ty::atttce_unresolved) => {\n+      Some(&ty::atttce_resolved(ty)) => return ty,\n+      Some(&ty::atttce_unresolved) => {\n         tcx.sess.span_fatal(ast_ty.span, ~\"illegal recursive type; \\\n                                           insert an enum in the cycle, \\\n                                           if this is desired\");\n@@ -359,7 +359,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n           None => tcx.sess.span_fatal(\n               ast_ty.span, fmt!(\"unbound path %s\",\n                                 path_to_str(path, tcx.sess.intr()))),\n-          Some(d) => d\n+          Some(&d) => d\n         };\n         match a_def {\n           ast::def_ty(did) | ast::def_struct(did) => {"}, {"sha": "cc2cf7a23c5986bc1ab5a1525fb099bd5136e73b", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -18,8 +18,8 @@ use middle::typeck::check::{instantiate_path, lookup_def};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n use middle::typeck::require_same_types;\n \n+use core::hashmap::linear::{LinearMap, LinearSet};\n use core::vec;\n-use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n@@ -228,7 +228,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n /// `class_fields` describes the type of each field of the struct.\n /// `class_id` is the ID of the struct.\n /// `substitutions` are the type substitutions applied to this struct type\n-/// (e.g. K,V in HashMap<K,V>).\n+/// (e.g. K,V in LinearMap<K,V>).\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(pcx: pat_ctxt,\n                                span: span,\n@@ -241,23 +241,23 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Index the class fields.\n-    let field_map = HashMap();\n+    let mut field_map = LinearMap::new();\n     for class_fields.eachi |i, class_field| {\n         field_map.insert(class_field.ident, i);\n     }\n \n     // Typecheck each field.\n-    let found_fields = HashMap();\n+    let mut found_fields = LinearSet::new();\n     for fields.each |field| {\n         match field_map.find(&field.ident) {\n-            Some(index) => {\n+            Some(&index) => {\n                 let class_field = class_fields[index];\n                 let field_type = ty::lookup_field_type(tcx,\n                                                        class_id,\n                                                        class_field.id,\n                                                        substitutions);\n                 check_pat(pcx, field.pat, field_type);\n-                found_fields.insert(index, ());\n+                found_fields.insert(index);\n             }\n             None => {\n                 let name = pprust::path_to_str(path, tcx.sess.intr());\n@@ -272,7 +272,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     // Report an error if not all the fields were specified.\n     if !etc {\n         for class_fields.eachi |i, field| {\n-            if found_fields.contains_key(&i) {\n+            if found_fields.contains(&i) {\n                 loop;\n             }\n             tcx.sess.span_err(span,\n@@ -293,11 +293,11 @@ pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n \n     // Check to ensure that the struct is the one specified.\n     match tcx.def_map.find(&pat_id) {\n-        Some(ast::def_struct(supplied_def_id))\n+        Some(&ast::def_struct(supplied_def_id))\n                 if supplied_def_id == class_id => {\n             // OK.\n         }\n-        Some(ast::def_struct(*)) | Some(ast::def_variant(*)) => {\n+        Some(&ast::def_struct(*)) | Some(&ast::def_variant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n                               fmt!(\"mismatched types: expected `%s` but \\\n@@ -334,15 +334,15 @@ pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n \n     // Find the variant that was specified.\n     match tcx.def_map.find(&pat_id) {\n-        Some(ast::def_variant(found_enum_id, variant_id))\n+        Some(&ast::def_variant(found_enum_id, variant_id))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n             let class_fields = ty::lookup_struct_fields(tcx, variant_id);\n \n             check_struct_pat_fields(pcx, span, path, fields, class_fields,\n                                     variant_id, substitutions, etc);\n         }\n-        Some(ast::def_struct(*)) | Some(ast::def_variant(*)) => {\n+        Some(&ast::def_struct(*)) | Some(&ast::def_variant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n                               fmt!(\"mismatched types: expected `%s` but \\\n@@ -394,7 +394,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       }\n       ast::pat_enum(*) |\n       ast::pat_ident(*) if pat_is_const(tcx.def_map, pat) => {\n-        let const_did = ast_util::def_id_of_def(tcx.def_map.get(&pat.id));\n+        let const_did = ast_util::def_id_of_def(*tcx.def_map.get(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n@@ -421,7 +421,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           }\n         }\n \n-        let canon_id = pcx.map.get(&ast_util::path_to_ident(name));\n+        let canon_id = *pcx.map.get(&ast_util::path_to_ident(name));\n         if canon_id != pat.id {\n             let ct = fcx.local_ty(pat.span, canon_id);\n             demand::eqtype(fcx, pat.span, ct, typ);"}, {"sha": "3c436ffdf878edbae84b01066ab4a9bd2f07eea2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -95,10 +95,10 @@ use middle::typeck::{method_self, method_static, method_trait, method_super};\n use util::common::indenter;\n use util::ppaux::expr_repr;\n \n+use core::hashmap::linear::LinearSet;\n use core::result;\n use core::uint;\n use core::vec;\n-use std::oldmap::HashMap;\n use syntax::ast::{def_id, sty_by_ref, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, node_id, by_copy, by_ref};\n use syntax::ast::{m_const, m_mutbl, m_imm};\n@@ -131,14 +131,15 @@ pub fn lookup(\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<method_map_entry> {\n+    let mut impl_dups = LinearSet::new();\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n         self_expr: self_expr,\n         callee_id: callee_id,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: HashMap(),\n+        impl_dups: &mut impl_dups,\n         inherent_candidates: @mut ~[],\n         extension_candidates: @mut ~[],\n         deref_args: deref_args,\n@@ -158,7 +159,7 @@ pub struct LookupContext {\n     callee_id: node_id,\n     m_name: ast::ident,\n     supplied_tps: &'self [ty::t],\n-    impl_dups: HashMap<def_id, ()>,\n+    impl_dups: &'self mut LinearSet<def_id>,\n     inherent_candidates: @mut ~[Candidate],\n     extension_candidates: @mut ~[Candidate],\n     deref_args: check::DerefArgs,\n@@ -344,8 +345,8 @@ pub impl<'self> LookupContext<'self> {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.find(\n-            &self.expr.id);\n+        let trait_map: &mut resolve::TraitMap = &mut self.fcx.ccx.trait_map;\n+        let opt_applicable_traits = trait_map.find(&self.expr.id);\n         for opt_applicable_traits.each |applicable_traits| {\n             for applicable_traits.each |trait_did| {\n                 let coherence_info = self.fcx.ccx.coherence_info;\n@@ -362,7 +363,7 @@ pub impl<'self> LookupContext<'self> {\n \n                 // Look for default methods.\n                 match self.tcx().provided_methods.find(trait_did) {\n-                    Some(methods) => {\n+                    Some(&methods) => {\n                         self.push_candidates_from_provided_methods(\n                             self.extension_candidates, self_ty, *trait_did,\n                             methods);\n@@ -384,7 +385,7 @@ pub impl<'self> LookupContext<'self> {\n         let mut next_bound_idx = 0; // count only trait bounds\n         let bounds = tcx.ty_param_bounds.get(&param_ty.def_id.node);\n \n-        for vec::each(*bounds) |bound| {\n+        for bounds.each |bound| {\n             let bound_trait_ty = match *bound {\n                 ty::bound_trait(bound_t) => bound_t,\n \n@@ -639,7 +640,7 @@ pub impl<'self> LookupContext<'self> {\n \n     fn push_candidates_from_impl(&self, candidates: &mut ~[Candidate],\n                                  impl_info: &resolve::Impl) {\n-        if !self.impl_dups.insert(impl_info.did, ()) {\n+        if !self.impl_dups.insert(impl_info.did) {\n             return; // already visited\n         }\n \n@@ -1195,7 +1196,7 @@ pub impl<'self> LookupContext<'self> {\n         match candidate.origin {\n             method_static(method_id) | method_self(method_id, _)\n                 | method_super(method_id, _) => {\n-                bad = self.tcx().destructors.contains_key(&method_id);\n+                bad = self.tcx().destructors.contains(&method_id);\n             }\n             method_param(method_param { trait_id: trait_id, _ }) |\n             method_trait(trait_id, _, _) => {"}, {"sha": "f534519d1474e66203c4ecc377cdc080df86f7d6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -112,15 +112,14 @@ use util::ppaux::{bound_region_to_str, expr_repr, pat_repr};\n use util::ppaux;\n \n use core::either;\n+use core::hashmap::linear::LinearMap;\n use core::option;\n use core::ptr;\n use core::result::{Result, Ok, Err};\n use core::result;\n use core::str;\n use core::vec;\n use std::list::Nil;\n-use std::oldmap::HashMap;\n-use std::oldmap;\n use syntax::ast::{provided, required, ty_i};\n use syntax::ast;\n use syntax::ast_map;\n@@ -160,12 +159,12 @@ pub struct SelfInfo {\n /// share the inherited fields.\n pub struct inherited {\n     infcx: @mut infer::InferCtxt,\n-    locals: HashMap<ast::node_id, ty::t>,\n+    locals: @mut LinearMap<ast::node_id, ty::t>,\n \n     // Temporary tables:\n-    node_types: HashMap<ast::node_id, ty::t>,\n-    node_type_substs: HashMap<ast::node_id, ty::substs>,\n-    adjustments: HashMap<ast::node_id, @ty::AutoAdjustment>,\n+    node_types: @mut LinearMap<ast::node_id, ty::t>,\n+    node_type_substs: @mut LinearMap<ast::node_id, ty::substs>,\n+    adjustments: @mut LinearMap<ast::node_id, @ty::AutoAdjustment>,\n     method_map: method_map,\n     vtable_map: vtable_map,\n }\n@@ -222,12 +221,12 @@ pub struct FnCtxt {\n pub fn blank_inherited(ccx: @mut CrateCtxt) -> @inherited {\n     @inherited {\n         infcx: infer::new_infer_ctxt(ccx.tcx),\n-        locals: HashMap(),\n-        node_types: oldmap::HashMap(),\n-        node_type_substs: oldmap::HashMap(),\n-        adjustments: oldmap::HashMap(),\n-        method_map: oldmap::HashMap(),\n-        vtable_map: oldmap::HashMap(),\n+        locals: @mut LinearMap::new(),\n+        node_types: @mut LinearMap::new(),\n+        node_type_substs: @mut LinearMap::new(),\n+        adjustments: @mut LinearMap::new(),\n+        method_map: @mut LinearMap::new(),\n+        vtable_map: @mut LinearMap::new(),\n     }\n }\n \n@@ -399,7 +398,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get(&self_info.self_id)));\n+                       *fcx.inh.locals.get(&self_info.self_id)));\n         }\n \n         // Add formal parameters.\n@@ -432,7 +431,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             debug!(\"Local variable %s is assigned type %s\",\n                    fcx.pat_to_str(local.node.pat),\n                    fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get(&local.node.id)));\n+                       *fcx.inh.locals.get(&local.node.id)));\n             visit::visit_local(local, e, v);\n         };\n \n@@ -445,7 +444,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 debug!(\"Pattern binding %s is assigned to %s\",\n                        *tcx.sess.str_of(path.idents[0]),\n                        fcx.infcx().ty_to_str(\n-                           fcx.inh.locals.get(&p.id)));\n+                           *fcx.inh.locals.get(&p.id)));\n               }\n               _ => {}\n             }\n@@ -506,11 +505,12 @@ pub fn check_method(ccx: @mut CrateCtxt,\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n                                  fields: ~[(ast::ident, span)]) {\n-    let field_names = HashMap();\n+    let mut field_names = LinearMap::new();\n \n     for fields.each |p| {\n         let (id, sp) = *p;\n-        match field_names.find(&id) {\n+        let orig_sp = field_names.find(&id).map_consume(|x| *x);\n+        match orig_sp {\n           Some(orig_sp) => {\n             tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n                                    name %s in record type declaration\",\n@@ -572,7 +572,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n       ast::item_impl(_, _, ty, ref ms) => {\n-        let rp = ccx.tcx.region_paramd_items.find(&it.id);\n+        let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n                *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(&rscope::type_rscope(rp), ty);\n@@ -679,7 +679,7 @@ pub impl FnCtxt {\n \n     fn local_ty(&self, span: span, nid: ast::node_id) -> ty::t {\n         match self.inh.locals.find(&nid) {\n-            Some(t) => t,\n+            Some(&t) => t,\n             None => {\n                 self.tcx().sess.span_bug(\n                     span,\n@@ -766,7 +766,7 @@ pub impl FnCtxt {\n \n     fn expr_ty(&self, ex: @ast::expr) -> ty::t {\n         match self.inh.node_types.find(&ex.id) {\n-            Some(t) => t,\n+            Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n                     fmt!(\"no type for %s in fcx %s\",\n@@ -776,7 +776,7 @@ pub impl FnCtxt {\n     }\n     fn node_ty(&self, id: ast::node_id) -> ty::t {\n         match self.inh.node_types.find(&id) {\n-            Some(t) => t,\n+            Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n                     fmt!(\"no type for node %d: %s in fcx %s\",\n@@ -789,7 +789,7 @@ pub impl FnCtxt {\n     }\n     fn node_ty_substs(&self, id: ast::node_id) -> ty::substs {\n         match self.inh.node_type_substs.find(&id) {\n-            Some(ref ts) => (/*bad*/copy *ts),\n+            Some(ts) => (/*bad*/copy *ts),\n             None => {\n                 self.tcx().sess.bug(\n                     fmt!(\"no type substs for node %d: %s in fcx %s\",\n@@ -800,10 +800,14 @@ pub impl FnCtxt {\n             }\n         }\n     }\n-    fn opt_node_ty_substs(&self, id: ast::node_id) -> Option<ty::substs> {\n-        self.inh.node_type_substs.find(&id)\n-    }\n \n+    fn opt_node_ty_substs(&self, id: ast::node_id,\n+                          f: &fn(&ty::substs) -> bool) {\n+        match self.inh.node_type_substs.find(&id) {\n+            Some(s) => { f(s); }\n+            None => ()\n+        }\n+    }\n \n     fn mk_subty(&self,\n                 a_is_expected: bool,\n@@ -1059,7 +1063,8 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     let tcx = vcx.tcx();\n \n     let (n_tps, region_param, raw_ty) = if did.crate == ast::local_crate {\n-        let region_param = tcx.region_paramd_items.find(&did.node);\n+        let region_param = tcx.region_paramd_items.find(&did.node).\n+                               map_consume(|x| *x);\n         match tcx.items.find(&did.node) {\n           Some(ast_map::node_item(@ast::item {\n                   node: ast::item_impl(ref ts, _, st, _),\n@@ -1769,7 +1774,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                       check_completeness: bool)  {\n         let tcx = fcx.ccx.tcx;\n \n-        let class_field_map = HashMap();\n+        let mut class_field_map = LinearMap::new();\n         let mut fields_found = 0;\n         for field_types.each |field| {\n             // XXX: Check visibility here.\n@@ -1782,7 +1787,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         for ast_fields.each |field| {\n             let mut expected_field_type = ty::mk_err(tcx);\n \n-            match class_field_map.find(&field.node.ident) {\n+            let pair = class_field_map.find(&field.node.ident).\n+                                       map_consume(|x| *x);\n+            match pair {\n                 None => {\n                     tcx.sess.span_err(\n                         field.span,\n@@ -1825,7 +1832,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 let mut missing_fields = ~[];\n                 for field_types.each |class_field| {\n                     let name = class_field.ident;\n-                    let (_, seen) = class_field_map.get(&name);\n+                    let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n                         missing_fields.push(\n                             ~\"`\" + *tcx.sess.str_of(name) + ~\"`\");\n@@ -1862,7 +1869,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let type_parameter_count, region_parameterized, raw_type;\n         if class_id.crate == ast::local_crate {\n             region_parameterized =\n-                tcx.region_paramd_items.find(&class_id.node);\n+                tcx.region_paramd_items.find(&class_id.node).\n+                    map_consume(|x| *x);\n             match tcx.items.find(&class_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n                         node: ast::item_struct(_, ref generics),\n@@ -1950,7 +1958,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let type_parameter_count, region_parameterized, raw_type;\n         if enum_id.crate == ast::local_crate {\n             region_parameterized =\n-                tcx.region_paramd_items.find(&enum_id.node);\n+                tcx.region_paramd_items.find(&enum_id.node).map_consume(|x| *x);\n             match tcx.items.find(&enum_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n                         node: ast::item_enum(_, ref generics),\n@@ -2730,11 +2738,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::expr_struct(path, ref fields, base_expr) => {\n         // Resolve the path.\n         match tcx.def_map.find(&id) {\n-            Some(ast::def_struct(type_def_id)) => {\n+            Some(&ast::def_struct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          *fields, base_expr);\n             }\n-            Some(ast::def_variant(enum_id, variant_id)) => {\n+            Some(&ast::def_variant(enum_id, variant_id)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, *fields);\n             }\n@@ -2834,7 +2842,7 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n     }\n \n     let region =\n-        ty::re_scope(tcx.region_map.get(&local.node.id));\n+        ty::re_scope(*tcx.region_map.get(&local.node.id));\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),\n@@ -3350,7 +3358,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: &ast::blk) -> bool {\n         match e.node {\n             ast::expr_break(Some(_)) =>\n                 match cx.def_map.find(&e.id) {\n-                    Some(ast::def_label(loop_id)) if id == loop_id => true,\n+                    Some(&ast::def_label(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 },\n             _ => false"}, {"sha": "02102110d9bc3f718ffb2812fd3027006957d79d", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -180,7 +180,7 @@ pub fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n-    for rcx.fcx.inh.adjustments.find(&expr.id).each |adjustment| {\n+    for rcx.fcx.inh.adjustments.find(&expr.id).each |&adjustment| {\n         match *adjustment {\n             @ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n@@ -331,7 +331,7 @@ pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n \n     let adjustment = rcx.fcx.inh.adjustments.find(&expr.id);\n     let region = match adjustment {\n-        Some(@ty::AutoDerefRef(\n+        Some(&@ty::AutoDerefRef(\n             ty::AutoDerefRef {\n                 autoref: Some(ref auto_ref), _})) => {\n             auto_ref.region\n@@ -727,7 +727,7 @@ pub mod guarantor {\n         debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n \n         match rcx.fcx.inh.adjustments.find(&expr.id) {\n-            Some(@ty::AutoAddEnv(*)) => {\n+            Some(&@ty::AutoAddEnv(*)) => {\n                 // This is basically an rvalue, not a pointer, no regions\n                 // involved.\n                 expr_ct.cat = ExprCategorization {\n@@ -736,7 +736,7 @@ pub mod guarantor {\n                 };\n             }\n \n-            Some(@ty::AutoDerefRef(ref adjustment)) => {\n+            Some(&@ty::AutoDerefRef(ref adjustment)) => {\n                 debug!(\"adjustment=%?\", adjustment);\n \n                 expr_ct = apply_autoderefs("}, {"sha": "8146213d3be6e2cb68ec6e5a9594f7943bc34f75", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -192,7 +192,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n     match ty::get(ty).sty {\n         ty::ty_param(param_ty {idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n-            let bounds = tcx.ty_param_bounds.get(&did.node);\n+            let bounds = *tcx.ty_param_bounds.get(&did.node);\n             for ty::iter_bound_traits_and_supertraits(\n                 tcx, bounds) |ity| {\n                 debug!(\"checking bounds trait %?\",\n@@ -511,9 +511,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n     let cx = fcx.ccx;\n     match ex.node {\n       ast::expr_path(*) => {\n-        match fcx.opt_node_ty_substs(ex.id) {\n-          Some(ref substs) => {\n-              let def = cx.tcx.def_map.get(&ex.id);\n+        for fcx.opt_node_ty_substs(ex.id) |substs| {\n+            let def = *cx.tcx.def_map.get(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def %? %?, %?, %?\", ex.id, did, def,\n@@ -531,8 +530,6 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                     insert_vtables(fcx, ex.id, vtbls);\n                 }\n             }\n-          }\n-          _ => ()\n         }\n       }\n "}, {"sha": "1d6c74fd899b7604601cf50362d84d8f7a4cfbd9", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -119,7 +119,7 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n     match fcx.inh.adjustments.find(&id) {\n         None => (),\n \n-        Some(@ty::AutoAddEnv(r, s)) => {\n+        Some(&@ty::AutoAddEnv(r, s)) => {\n             match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n                 Err(e) => {\n                     // This should not, I think, happen:\n@@ -135,7 +135,7 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n             }\n         }\n \n-        Some(@ty::AutoDerefRef(adj)) => {\n+        Some(&@ty::AutoDerefRef(adj)) => {\n             let resolved_autoref = match adj.autoref {\n                 Some(ref autoref) => {\n                     match resolve_region(fcx.infcx(), autoref.region,\n@@ -176,18 +176,15 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n         debug!(\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n-        match fcx.opt_node_ty_substs(id) {\n-          Some(ref substs) => {\n-            let mut new_tps = ~[];\n-            for (*substs).tps.each |subst| {\n-                match resolve_type_vars_in_type(fcx, sp, *subst) {\n-                  Some(t) => new_tps.push(t),\n-                  None => { wbcx.success = false; return None; }\n-                }\n-            }\n-            write_substs_to_tcx(tcx, id, new_tps);\n+        for fcx.opt_node_ty_substs(id) |substs| {\n+          let mut new_tps = ~[];\n+          for substs.tps.each |subst| {\n+              match resolve_type_vars_in_type(fcx, sp, *subst) {\n+                Some(t) => new_tps.push(t),\n+                None => { wbcx.success = false; return None; }\n+              }\n           }\n-          None => ()\n+          write_substs_to_tcx(tcx, id, new_tps);\n         }\n         return Some(t);\n       }"}, {"sha": "e1d22f4e13d32cc0c1cc418bd6afced9ad843124", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -58,7 +58,6 @@ use util::ppaux::ty_to_str;\n use core::result::Ok;\n use core::hashmap::linear::{LinearMap, LinearSet};\n use core::uint;\n-use std::oldmap::HashMap;\n \n pub struct UniversalQuantificationResult {\n     monotype: t,\n@@ -187,7 +186,7 @@ pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n \n-        base_type_def_ids: HashMap()\n+        base_type_def_ids: @mut LinearMap::new(),\n     }\n }\n \n@@ -198,7 +197,7 @@ pub struct CoherenceChecker {\n     // A mapping from implementations to the corresponding base type\n     // definition ID.\n \n-    base_type_def_ids: HashMap<def_id,def_id>,\n+    base_type_def_ids: @mut LinearMap<def_id,def_id>,\n }\n \n pub impl CoherenceChecker {\n@@ -475,7 +474,7 @@ pub impl CoherenceChecker {\n                ty_to_str(self.crate_context.tcx, self_t));\n         match self.crate_context.tcx.trait_impls.find(&trait_t) {\n             None => {\n-                let m = HashMap();\n+                let m = @mut LinearMap::new();\n                 m.insert(self_t, the_impl);\n                 self.crate_context.tcx.trait_impls.insert(trait_t, m);\n             }\n@@ -505,14 +504,14 @@ pub impl CoherenceChecker {\n             f: &fn(x: &ty::method) -> bool) {\n         // Make a list of all the names of the provided methods.\n         // XXX: This is horrible.\n-        let provided_method_idents = HashMap();\n+        let mut provided_method_idents = LinearSet::new();\n         let tcx = self.crate_context.tcx;\n         for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n-            provided_method_idents.insert(*ident, ());\n+            provided_method_idents.insert(*ident);\n         }\n \n         for ty::trait_methods(tcx, trait_did).each |method| {\n-            if provided_method_idents.contains_key(&method.ident) {\n+            if provided_method_idents.contains(&method.ident) {\n                 if !f(method) {\n                     break;\n                 }\n@@ -622,7 +621,7 @@ pub impl CoherenceChecker {\n \n     fn get_self_type_for_implementation(&self, implementation: @Impl)\n                                      -> ty_param_bounds_and_ty {\n-        return self.crate_context.tcx.tcache.get(&implementation.did);\n+        return *self.crate_context.tcx.tcache.get(&implementation.did);\n     }\n \n     // Privileged scope checking\n@@ -694,7 +693,7 @@ pub impl CoherenceChecker {\n \n     fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n-        let trait_def = def_map.get(&trait_ref.ref_id);\n+        let trait_def = *def_map.get(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n     }\n@@ -773,7 +772,7 @@ pub impl CoherenceChecker {\n                                     has no provided methods\", trait_did.node);\n                             /* fall through */\n                         }\n-                        Some(all_provided) => {\n+                        Some(&all_provided) => {\n                             debug!(\"(creating impl) trait with node_id `%d` \\\n                                     has provided methods\", trait_did.node);\n                             // Add all provided methods.\n@@ -815,7 +814,7 @@ pub impl CoherenceChecker {\n \n     // External crate handling\n \n-    fn add_impls_for_module(&self, impls_seen: HashMap<def_id,()>,\n+    fn add_impls_for_module(&self, impls_seen: &mut LinearSet<def_id>,\n                             crate_store: @mut CStore,\n                             module_def_id: def_id) {\n         let implementations = get_impls_for_mod(crate_store,\n@@ -828,16 +827,11 @@ pub impl CoherenceChecker {\n \n             // Make sure we don't visit the same implementation\n             // multiple times.\n-            match impls_seen.find(&implementation.did) {\n-                None => {\n-                    // Good. Continue.\n-                    impls_seen.insert(implementation.did, ());\n-                }\n-                Some(_) => {\n-                    // Skip this one.\n-                    loop;\n-                }\n+            if !impls_seen.insert(implementation.did) {\n+                // Skip this one.\n+                loop;\n             }\n+            // Good. Continue.\n \n             let self_type = lookup_item_type(self.crate_context.tcx,\n                                              implementation.did);\n@@ -939,19 +933,19 @@ pub impl CoherenceChecker {\n     // Adds implementations and traits from external crates to the coherence\n     // info.\n     fn add_external_crates(&self) {\n-        let impls_seen = HashMap();\n+        let mut impls_seen = LinearSet::new();\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            self.add_impls_for_module(impls_seen,\n+            self.add_impls_for_module(&mut impls_seen,\n                                       crate_store,\n                                       def_id { crate: crate_number,\n                                                node: 0 });\n \n             for each_path(crate_store, crate_number) |_p, def_like| {\n                 match def_like {\n                     dl_def(def_mod(def_id)) => {\n-                        self.add_impls_for_module(impls_seen,\n+                        self.add_impls_for_module(&mut impls_seen,\n                                                   crate_store,\n                                                   def_id);\n                     }\n@@ -1003,7 +997,7 @@ pub impl CoherenceChecker {\n                 ty::ty_struct(type_def_id, _) => {\n                     tcx.destructor_for_type.insert(type_def_id,\n                                                    method_def_id);\n-                    tcx.destructors.insert(method_def_id, ());\n+                    tcx.destructors.insert(method_def_id);\n                 }\n                 _ => {\n                     // Destructors only work on nominal types."}, {"sha": "cc40a65ff2c28b3207ce913556e1e6022c7d514f", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -280,7 +280,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n \n     let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(&id);\n+    let region_paramd = tcx.region_paramd_items.find(&id).map_consume(|x| *x);\n     match tcx.items.get(&id) {\n       ast_map::node_item(@ast::item {\n                 node: ast::item_trait(ref generics, _, ref ms),\n@@ -615,7 +615,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.find(&it.id);\n+    let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     debug!(\"convert: item %s with id %d rp %?\",\n            *tcx.sess.str_of(it.ident), it.id, rp);\n     match it.node {\n@@ -828,10 +828,10 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.tcache.find(&def_id) {\n-      Some(tpt) => return tpt,\n+      Some(&tpt) => return tpt,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id);\n+    let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     match it.node {\n       ast::item_const(t, _) => {\n         let typ = ccx.to_ty(&empty_rscope, t);\n@@ -857,11 +857,11 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n       }\n       ast::item_ty(t, ref generics) => {\n         match tcx.tcache.find(&local_def(it.id)) {\n-          Some(tpt) => return tpt,\n+          Some(&tpt) => return tpt,\n           None => { }\n         }\n \n-        let rp = tcx.region_paramd_items.find(&it.id);\n+        let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         let tpt = {\n             let ty = {\n                 let t0 = ccx.to_ty(&type_rscope(rp), t);\n@@ -991,7 +991,7 @@ pub fn ty_param_bounds(ccx: &CrateCtxt,\n                     -> @~[ty::param_bounds] {\n     @do generics.ty_params.map_to_vec |param| {\n         match ccx.tcx.ty_param_bounds.find(&param.id) {\n-          Some(bs) => bs,\n+          Some(&bs) => bs,\n           None => {\n             let bounds = compute_bounds(ccx, param.bounds);\n             ccx.tcx.ty_param_bounds.insert(param.id, bounds);"}, {"sha": "45c7ad2f8f81d1a9f1b6b03b6160fbf465c3b560", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 58, "deletions": 48, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -549,11 +549,11 @@ use util::ppaux::note_and_explain_region;\n \n use core::cell::{Cell, empty_cell};\n use core::cmp;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n use core::result::{Err, Ok, Result};\n use core::to_bytes;\n use core::uint;\n use core::vec;\n-use std::oldmap::HashMap;\n use syntax::codemap::span;\n \n enum Constraint {\n@@ -619,15 +619,19 @@ enum UndoLogEntry {\n     Snapshot,\n     AddVar(RegionVid),\n     AddConstraint(Constraint),\n-    AddCombination(CombineMap, TwoRegions)\n+    AddCombination(CombineMapType, TwoRegions)\n }\n \n-type CombineMap = HashMap<TwoRegions, RegionVid>;\n+enum CombineMapType {\n+    Lub, Glb\n+}\n+\n+type CombineMap = LinearMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n     var_spans: ~[span],\n-    constraints: HashMap<Constraint, span>,\n+    constraints: LinearMap<Constraint, span>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n     skolemization_count: uint,\n@@ -654,22 +658,15 @@ pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n         tcx: tcx,\n         var_spans: ~[],\n         values: empty_cell(),\n-        constraints: HashMap(),\n-        lubs: CombineMap(),\n-        glbs: CombineMap(),\n+        constraints: LinearMap::new(),\n+        lubs: LinearMap::new(),\n+        glbs: LinearMap::new(),\n         skolemization_count: 0,\n         bound_count: 0,\n         undo_log: ~[]\n     }\n }\n \n-// Note: takes two regions but doesn't care which is `a` and which is\n-// `b`!  Not obvious that this is the most efficient way to go about\n-// it.\n-fn CombineMap() -> CombineMap {\n-    return HashMap();\n-}\n-\n pub impl RegionVarBindings {\n     fn in_snapshot(&mut self) -> bool {\n         self.undo_log.len() > 0\n@@ -706,8 +703,11 @@ pub impl RegionVarBindings {\n               AddConstraint(ref constraint) => {\n                 self.constraints.remove(constraint);\n               }\n-              AddCombination(map, ref regions) => {\n-                map.remove(regions);\n+              AddCombination(Glb, ref regions) => {\n+                self.glbs.remove(regions);\n+              }\n+              AddCombination(Lub, ref regions) => {\n+                self.lubs.remove(regions);\n               }\n             }\n         }\n@@ -825,7 +825,7 @@ pub impl RegionVarBindings {\n \n           (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n             self.combine_vars(\n-                self.lubs, a, b, span,\n+                Lub, a, b, span,\n                 |this, old_r, new_r| this.make_subregion(span, old_r, new_r))\n           }\n \n@@ -852,7 +852,7 @@ pub impl RegionVarBindings {\n \n           (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n             self.combine_vars(\n-                self.glbs, a, b, span,\n+                Glb, a, b, span,\n                 |this, old_r, new_r| this.make_subregion(span, new_r, old_r))\n           }\n \n@@ -905,7 +905,7 @@ pub impl RegionVarBindings {\n     }\n \n     fn combine_vars(&mut self,\n-                    combines: CombineMap,\n+                    t: CombineMapType,\n                     a: Region,\n                     b: Region,\n                     span: span,\n@@ -914,21 +914,35 @@ pub impl RegionVarBindings {\n                                 new_r: Region) -> cres<()>)\n                  -> cres<Region> {\n         let vars = TwoRegions { a: a, b: b };\n-        match combines.find(&vars) {\n-          Some(c) => Ok(re_infer(ReVar(c))),\n-          None => {\n-            let c = self.new_region_var(span);\n-            combines.insert(vars, c);\n-            if self.in_snapshot() {\n-                self.undo_log.push(AddCombination(combines, vars));\n-            }\n-            do relate(self, a, re_infer(ReVar(c))).then {\n-                do relate(self, b, re_infer(ReVar(c))).then {\n-                    debug!(\"combine_vars() c=%?\", c);\n-                    Ok(re_infer(ReVar(c)))\n+        let c;\n+        {\n+            // FIXME (#3850): shouldn't need a scope, nor should this need to be\n+            //                done twice to get the maps out\n+            {\n+                let combines = match t {\n+                    Glb => &self.glbs, Lub => &self.lubs\n+                };\n+                match combines.find(&vars) {\n+                  Some(&c) => return Ok(re_infer(ReVar(c))),\n+                  None => ()\n                 }\n             }\n-          }\n+            c = self.new_region_var(span);\n+            {\n+                let combines = match t {\n+                    Glb => &mut self.glbs, Lub => &mut self.lubs\n+                };\n+                combines.insert(vars, c);\n+            }\n+        }\n+        if self.in_snapshot() {\n+            self.undo_log.push(AddCombination(t, vars));\n+        }\n+        do relate(self, a, re_infer(ReVar(c))).then {\n+            do relate(self, b, re_infer(ReVar(c))).then {\n+                debug!(\"combine_vars() c=%?\", c);\n+                Ok(re_infer(ReVar(c)))\n+            }\n         }\n     }\n \n@@ -1206,11 +1220,7 @@ struct SpannedRegion {\n     span: span,\n }\n \n-type TwoRegionsMap = HashMap<TwoRegions, ()>;\n-\n-fn TwoRegionsMap() -> TwoRegionsMap {\n-    return HashMap();\n-}\n+type TwoRegionsMap = LinearSet<TwoRegions>;\n \n pub impl RegionVarBindings {\n     fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n@@ -1239,7 +1249,7 @@ pub impl RegionVarBindings {\n \n         // It would be nice to write this using map():\n         let mut edges = vec::with_capacity(num_edges);\n-        for self.constraints.each |constraint, span| {\n+        for self.constraints.each |&(constraint, span)| {\n             edges.push(GraphEdge {\n                 next_edge: [uint::max_value, uint::max_value],\n                 constraint: *constraint,\n@@ -1439,7 +1449,7 @@ pub impl RegionVarBindings {\n         &mut self,\n         graph: &Graph) -> ~[GraphNodeValue]\n     {\n-        let dup_map = TwoRegionsMap();\n+        let mut dup_map = LinearSet::new();\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n                 Value(_) => {\n@@ -1478,11 +1488,11 @@ pub impl RegionVarBindings {\n                     match node.classification {\n                         Expanding => {\n                             self.report_error_for_expanding_node(\n-                                graph, dup_map, node_vid);\n+                                graph, &mut dup_map, node_vid);\n                         }\n                         Contracting => {\n                             self.report_error_for_contracting_node(\n-                                graph, dup_map, node_vid);\n+                                graph, &mut dup_map, node_vid);\n                         }\n                     }\n                 }\n@@ -1494,17 +1504,17 @@ pub impl RegionVarBindings {\n \n     // Used to suppress reporting the same basic error over and over\n     fn is_reported(&mut self,\n-                   dup_map: TwoRegionsMap,\n+                   dup_map: &mut TwoRegionsMap,\n                    r_a: Region,\n                    r_b: Region)\n                 -> bool {\n         let key = TwoRegions { a: r_a, b: r_b };\n-        !dup_map.insert(key, ())\n+        !dup_map.insert(key)\n     }\n \n     fn report_error_for_expanding_node(&mut self,\n                                        graph: &Graph,\n-                                       dup_map: TwoRegionsMap,\n+                                       dup_map: &mut TwoRegionsMap,\n                                        node_idx: RegionVid) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n@@ -1557,7 +1567,7 @@ pub impl RegionVarBindings {\n \n     fn report_error_for_contracting_node(&mut self,\n                                          graph: &Graph,\n-                                         dup_map: TwoRegionsMap,\n+                                         dup_map: &mut TwoRegionsMap,\n                                          node_idx: RegionVid) {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n@@ -1614,9 +1624,9 @@ pub impl RegionVarBindings {\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction)\n                              -> ~[SpannedRegion] {\n-        let set = HashMap();\n+        let mut set = LinearSet::new();\n         let mut stack = ~[orig_node_idx];\n-        set.insert(orig_node_idx.to_uint(), ());\n+        set.insert(orig_node_idx.to_uint());\n         let mut result = ~[];\n         while !vec::is_empty(stack) {\n             let node_idx = stack.pop();\n@@ -1627,7 +1637,7 @@ pub impl RegionVarBindings {\n                       Incoming => from_vid,\n                       Outgoing => to_vid\n                     };\n-                    if set.insert(vid.to_uint(), ()) {\n+                    if set.insert(vid.to_uint()) {\n                         stack.push(vid);\n                     }\n                   }"}, {"sha": "817aafc2b199bf888e2a99227409361c1866f134", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -55,12 +55,12 @@ use middle::ty;\n use util::common::time;\n use util::ppaux;\n \n+use core::hashmap::linear::LinearMap;\n use core::result;\n use core::vec;\n use std::list::{List, Nil, Cons};\n use std::list;\n use std::oldmap::HashMap;\n-use std::oldmap;\n use syntax::codemap::{span, spanned, respan};\n use syntax::print::pprust::*;\n use syntax::{ast, ast_util, ast_map};\n@@ -171,7 +171,7 @@ pub impl vtable_origin {\n     }\n }\n \n-pub type vtable_map = HashMap<ast::node_id, vtable_res>;\n+pub type vtable_map = @mut LinearMap<ast::node_id, vtable_res>;\n \n pub struct CrateCtxt {\n     // A mapping from method call sites to traits that have that method.\n@@ -209,7 +209,7 @@ pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n \n pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     match tcx.def_map.find(&id) {\n-      Some(x) => x,\n+      Some(&x) => x,\n       _ => {\n         tcx.sess.span_fatal(sp, ~\"internal error looking up a definition\")\n       }\n@@ -337,14 +337,14 @@ fn check_for_main_fn(ccx: @mut CrateCtxt) {\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n-                   trait_map: resolve::TraitMap,\n+                   +trait_map: resolve::TraitMap,\n                    crate: @ast::crate)\n                 -> (method_map, vtable_map) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = @mut CrateCtxt {\n         trait_map: trait_map,\n-        method_map: oldmap::HashMap(),\n-        vtable_map: oldmap::HashMap(),\n+        method_map: HashMap(),\n+        vtable_map: @mut LinearMap::new(),\n         coherence_info: @coherence::CoherenceInfo(),\n         tcx: tcx\n     };"}, {"sha": "f26a97b48a1ff09e0c808e24b51aa1d20e5fa34f", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -123,6 +123,8 @@ pub mod lib {\n     pub mod llvm;\n }\n \n+use core::prelude::*;\n+\n use driver::driver::{host_triple, optgroups, early_error};\n use driver::driver::{str_input, file_input, build_session_options};\n use driver::driver::{build_session, build_configuration, parse_pretty};\n@@ -166,7 +168,7 @@ Available lint options:\n \n     let lint_dict = lint::get_lint_dict();\n     let mut max_key = 0;\n-    for lint_dict.each_key |&k| { max_key = uint::max(k.len(), max_key); }\n+    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n     fn padded(max: uint, s: &str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n@@ -175,7 +177,7 @@ Available lint options:\n                      padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n     io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n                      padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n-    for lint_dict.each |&k, &v| {\n+    for lint_dict.each |&(k, v)| {\n         let k = str::replace(*k, ~\"_\", ~\"-\");\n         io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),"}, {"sha": "2a2d921ba86362bcfa8ffbd0e274c2b3bd607b7b", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=6f812fef1bde4a23ccfd7e1526a4c5087cc9e31b", "patch": "@@ -14,8 +14,8 @@ use syntax::ast;\n use syntax::codemap::{span};\n use syntax::visit;\n \n+use core::hashmap::linear::LinearSet;\n use core::str;\n-use std::oldmap::HashMap;\n use std;\n \n pub fn time<T>(do_it: bool, what: ~str, thunk: &fn() -> T) -> T {\n@@ -55,8 +55,6 @@ pub fn indenter() -> _indenter {\n     _indenter(())\n }\n \n-pub type flag = HashMap<~str, ()>;\n-\n pub fn field_expr(f: ast::field) -> @ast::expr { return f.node.expr; }\n \n pub fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n@@ -116,7 +114,7 @@ pub fn pluralize(n: uint, +s: ~str) -> ~str {\n }\n \n // A set of node IDs (used to keep track of which node IDs are for statements)\n-pub type stmt_set = HashMap<ast::node_id, ()>;\n+pub type stmt_set = @mut LinearSet<ast::node_id>;\n \n //\n // Local Variables:"}]}