{"sha": "47f1d6747c01a36534ebd08bab497e7abd02c7cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZjFkNjc0N2MwMWEzNjUzNGViZDA4YmFiNDk3ZTdhYmQwMmM3Y2Q=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2015-03-08T15:41:28Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2015-03-11T20:17:25Z"}, "message": "First-class struct and tuple constants\n\nFixes #23260", "tree": {"sha": "ca29a8431e7c2fb2de0ad479c4119648fb384fdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca29a8431e7c2fb2de0ad479c4119648fb384fdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47f1d6747c01a36534ebd08bab497e7abd02c7cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47f1d6747c01a36534ebd08bab497e7abd02c7cd", "html_url": "https://github.com/rust-lang/rust/commit/47f1d6747c01a36534ebd08bab497e7abd02c7cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47f1d6747c01a36534ebd08bab497e7abd02c7cd/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f899513a30165946a75ff7f515ab37a226e72172", "url": "https://api.github.com/repos/rust-lang/rust/commits/f899513a30165946a75ff7f515ab37a226e72172", "html_url": "https://github.com/rust-lang/rust/commit/f899513a30165946a75ff7f515ab37a226e72172"}], "stats": {"total": 98, "additions": 64, "deletions": 34}, "files": [{"sha": "96433729a9b96ff675d29d4d7f8183b3a380cf4c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/47f1d6747c01a36534ebd08bab497e7abd02c7cd/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f1d6747c01a36534ebd08bab497e7abd02c7cd/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=47f1d6747c01a36534ebd08bab497e7abd02c7cd", "patch": "@@ -17,7 +17,7 @@ use metadata::csearch;\n use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n-use middle::astconv_util::{ast_ty_to_prim_ty};\n+use middle::astconv_util::ast_ty_to_prim_ty;\n \n use syntax::ast::{self, Expr};\n use syntax::codemap::Span;\n@@ -132,16 +132,16 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n     }\n }\n \n-// FIXME (#33): this doesn't handle big integer/float literals correctly\n-// (nor does the rest of our literal handling).\n #[derive(Clone, PartialEq)]\n pub enum const_val {\n     const_float(f64),\n     const_int(i64),\n     const_uint(u64),\n     const_str(InternedString),\n-    const_binary(Rc<Vec<u8> >),\n-    const_bool(bool)\n+    const_binary(Rc<Vec<u8>>),\n+    const_bool(bool),\n+    Struct(ast::NodeId),\n+    Tuple(ast::NodeId)\n }\n \n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat> {\n@@ -226,9 +226,13 @@ pub enum ErrKind {\n     NegateOnString,\n     NegateOnBoolean,\n     NegateOnBinary,\n+    NegateOnStruct,\n+    NegateOnTuple,\n     NotOnFloat,\n     NotOnString,\n     NotOnBinary,\n+    NotOnStruct,\n+    NotOnTuple,\n \n     AddiWithOverflow(i64, i64),\n     SubiWithOverflow(i64, i64),\n@@ -242,7 +246,8 @@ pub enum ErrKind {\n     ModuloWithOverflow,\n     MissingStructField,\n     NonConstPath,\n-    NonConstStruct,\n+    ExpectedConstTuple,\n+    ExpectedConstStruct,\n     TupleIndexOutOfBounds,\n \n     MiscBinaryOp,\n@@ -262,9 +267,13 @@ impl ConstEvalErr {\n             NegateOnString => \"negate on string\".into_cow(),\n             NegateOnBoolean => \"negate on boolean\".into_cow(),\n             NegateOnBinary => \"negate on binary literal\".into_cow(),\n+            NegateOnStruct => \"negate on struct\".into_cow(),\n+            NegateOnTuple => \"negate on tuple\".into_cow(),\n             NotOnFloat => \"not on float or string\".into_cow(),\n             NotOnString => \"not on float or string\".into_cow(),\n             NotOnBinary => \"not on binary literal\".into_cow(),\n+            NotOnStruct => \"not on struct\".into_cow(),\n+            NotOnTuple => \"not on tuple\".into_cow(),\n \n             AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n             SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n@@ -278,7 +287,8 @@ impl ConstEvalErr {\n             ModuloWithOverflow   => \"attempted remainder with overflow\".into_cow(),\n             MissingStructField  => \"nonexistent struct field\".into_cow(),\n             NonConstPath        => \"non-constant path in constant expr\".into_cow(),\n-            NonConstStruct      => \"non-constant struct in constant expr\".into_cow(),\n+            ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n+            ExpectedConstStruct => \"expected constant struct\".into_cow(),\n             TupleIndexOutOfBounds => \"tuple index out of bounds\".into_cow(),\n \n             MiscBinaryOp => \"bad operands for binary\".into_cow(),\n@@ -341,6 +351,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           const_str(_) => signal!(e, NegateOnString),\n           const_bool(_) => signal!(e, NegateOnBoolean),\n           const_binary(_) => signal!(e, NegateOnBinary),\n+          const_val::Tuple(_) => signal!(e, NegateOnTuple),\n+          const_val::Struct(..) => signal!(e, NegateOnStruct),\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n@@ -351,6 +363,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           const_str(_) => signal!(e, NotOnString),\n           const_float(_) => signal!(e, NotOnFloat),\n           const_binary(_) => signal!(e, NotOnBinary),\n+          const_val::Tuple(_) => signal!(e, NotOnTuple),\n+          const_val::Struct(..) => signal!(e, NotOnStruct),\n         }\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n@@ -540,33 +554,52 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             None => const_int(0)\n         }\n       }\n+      ast::ExprTup(_) => {\n+        const_val::Tuple(e.id)\n+      }\n+      ast::ExprStruct(..) => {\n+        const_val::Struct(e.id)\n+      }\n       ast::ExprTupField(ref base, index) => {\n-        // Get the base tuple if it is constant\n-        if let Some(&ast::ExprTup(ref fields)) = lookup_const(tcx, &**base).map(|s| &s.node) {\n-            // Check that the given index is within bounds and evaluate its value\n-            if fields.len() > index.node {\n-                return eval_const_expr_partial(tcx, &*fields[index.node], None);\n+        if let Ok(c) = eval_const_expr_partial(tcx, base, None) {\n+            if let const_val::Tuple(tup_id) = c {\n+                if let ast::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n+                    if index.node < fields.len() {\n+                        return eval_const_expr_partial(tcx, &fields[index.node], None)\n+                    } else {\n+                        signal!(e, TupleIndexOutOfBounds);\n+                    }\n+                } else {\n+                    unreachable!()\n+                }\n             } else {\n-                signal!(e, TupleIndexOutOfBounds);\n+                signal!(base, ExpectedConstTuple);\n             }\n+        } else {\n+            signal!(base, NonConstPath)\n         }\n-\n-        signal!(e, NonConstStruct);\n       }\n       ast::ExprField(ref base, field_name) => {\n         // Get the base expression if it is a struct and it is constant\n-        if let Some(&ast::ExprStruct(_, ref fields, _)) = lookup_const(tcx, &**base)\n-                                                            .map(|s| &s.node) {\n-            // Check that the given field exists and evaluate it\n-            if let Some(f) = fields.iter().find(|f|\n-                                           f.ident.node.as_str() == field_name.node.as_str()) {\n-                return eval_const_expr_partial(tcx, &*f.expr, None);\n+        if let Ok(c) = eval_const_expr_partial(tcx, base, None) {\n+            if let const_val::Struct(struct_id) = c {\n+                if let ast::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n+                    // Check that the given field exists and evaluate it\n+                    if let Some(f) = fields.iter().find(|f| f.ident.node.as_str()\n+                                                         == field_name.node.as_str()) {\n+                        return eval_const_expr_partial(tcx, &*f.expr, None)\n+                    } else {\n+                        signal!(e, MissingStructField);\n+                    }\n+                } else {\n+                    unreachable!()\n+                }\n             } else {\n-                signal!(e, MissingStructField);\n+                signal!(base, ExpectedConstStruct);\n             }\n+        } else {\n+            signal!(base, NonConstPath);\n         }\n-\n-        signal!(e, NonConstStruct);\n       }\n       _ => signal!(e, MiscCatchAll)\n     };"}, {"sha": "a871602b86519f47d6ab3520fb7b09aa042b59d6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47f1d6747c01a36534ebd08bab497e7abd02c7cd/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f1d6747c01a36534ebd08bab497e7abd02c7cd/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=47f1d6747c01a36534ebd08bab497e7abd02c7cd", "patch": "@@ -5853,16 +5853,13 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             let found = match val {\n                 const_eval::const_uint(count) => return count as uint,\n                 const_eval::const_int(count) if count >= 0 => return count as uint,\n-                const_eval::const_int(_) =>\n-                    \"negative integer\",\n-                const_eval::const_float(_) =>\n-                    \"float\",\n-                const_eval::const_str(_) =>\n-                    \"string\",\n-                const_eval::const_bool(_) =>\n-                    \"boolean\",\n-                const_eval::const_binary(_) =>\n-                    \"binary array\"\n+                const_eval::const_int(_) => \"negative integer\",\n+                const_eval::const_float(_) => \"float\",\n+                const_eval::const_str(_) => \"string\",\n+                const_eval::const_bool(_) => \"boolean\",\n+                const_eval::const_binary(_) => \"binary array\",\n+                const_eval::Struct(..) => \"struct\",\n+                const_eval::Tuple(_) => \"tuple\"\n             };\n             span_err!(tcx.sess, count_expr.span, E0306,\n                 \"expected positive integer for repeat count, found {}\","}]}