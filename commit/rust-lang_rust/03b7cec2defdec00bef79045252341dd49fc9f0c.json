{"sha": "03b7cec2defdec00bef79045252341dd49fc9f0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYjdjZWMyZGVmZGVjMDBiZWY3OTA0NTI1MjM0MWRkNDlmYzlmMGM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-05T15:51:58Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-29T11:46:37Z"}, "message": "Replace LockCell with atomic types", "tree": {"sha": "fc57e9c01c3868a7b8dcec4b693e8c5ee82d82a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc57e9c01c3868a7b8dcec4b693e8c5ee82d82a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b7cec2defdec00bef79045252341dd49fc9f0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b7cec2defdec00bef79045252341dd49fc9f0c", "html_url": "https://github.com/rust-lang/rust/commit/03b7cec2defdec00bef79045252341dd49fc9f0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b7cec2defdec00bef79045252341dd49fc9f0c/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35a64f8bbfab3e063754cc9fc51a6ad795269b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a64f8bbfab3e063754cc9fc51a6ad795269b50", "html_url": "https://github.com/rust-lang/rust/commit/35a64f8bbfab3e063754cc9fc51a6ad795269b50"}], "stats": {"total": 275, "additions": 100, "deletions": 175}, "files": [{"sha": "3b1ffece45627f053b973e3ba3ecbc4dc9c71e25", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=03b7cec2defdec00bef79045252341dd49fc9f0c", "patch": "@@ -16,7 +16,10 @@ use util::common::{duration_to_secs_str, ErrorReported};\n use util::common::ProfileQueriesMsg;\n \n use rustc_data_structures::base_n;\n-use rustc_data_structures::sync::{self, Lrc, Lock, LockCell, OneThread, Once, RwLock};\n+use rustc_data_structures::sync::{\n+    self, Lrc, Lock, OneThread, Once, RwLock, AtomicU64, AtomicUsize, AtomicBool, Ordering,\n+    Ordering::SeqCst,\n+};\n \n use errors::{self, DiagnosticBuilder, DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n@@ -41,7 +44,6 @@ use std::io::Write;\n use std::path::PathBuf;\n use std::time::Duration;\n use std::sync::mpsc;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n \n mod code_stats;\n pub mod config;\n@@ -138,15 +140,15 @@ pub struct Session {\n     /// If -zfuel=crate=n is specified, Some(crate).\n     optimization_fuel_crate: Option<String>,\n     /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n-    optimization_fuel_limit: LockCell<u64>,\n+    optimization_fuel_limit: AtomicU64,\n     /// We're rejecting all further optimizations.\n-    out_of_fuel: LockCell<bool>,\n+    out_of_fuel: AtomicBool,\n \n     // The next two are public because the driver needs to read them.\n     /// If -zprint-fuel=crate, Some(crate).\n     pub print_fuel_crate: Option<String>,\n     /// Always set to zero and incremented so that we can print fuel expended by a crate.\n-    pub print_fuel: LockCell<u64>,\n+    pub print_fuel: AtomicU64,\n \n     /// Loaded up early on in the initialization of this `Session` to avoid\n     /// false positives about a job server in our environment.\n@@ -857,32 +859,43 @@ impl Session {\n                  self.perf_stats.normalize_projection_ty.load(Ordering::Relaxed));\n     }\n \n-    /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n-    /// This expends fuel if applicable, and records fuel if applicable.\n-    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n+    #[inline(never)]\n+    #[cold]\n+    pub fn consider_optimizing_cold<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n         let mut ret = true;\n         if let Some(ref c) = self.optimization_fuel_crate {\n             if c == crate_name {\n                 assert_eq!(self.query_threads(), 1);\n-                let fuel = self.optimization_fuel_limit.get();\n+                let fuel = self.optimization_fuel_limit.load(SeqCst);\n                 ret = fuel != 0;\n-                if fuel == 0 && !self.out_of_fuel.get() {\n+                if fuel == 0 && !self.out_of_fuel.load(SeqCst) {\n                     eprintln!(\"optimization-fuel-exhausted: {}\", msg());\n-                    self.out_of_fuel.set(true);\n+                    self.out_of_fuel.store(true, SeqCst);\n                 } else if fuel > 0 {\n-                    self.optimization_fuel_limit.set(fuel - 1);\n+                    self.optimization_fuel_limit.store(fuel - 1, SeqCst);\n                 }\n             }\n         }\n         if let Some(ref c) = self.print_fuel_crate {\n             if c == crate_name {\n                 assert_eq!(self.query_threads(), 1);\n-                self.print_fuel.set(self.print_fuel.get() + 1);\n+                self.print_fuel.store(self.print_fuel.load(SeqCst) + 1, SeqCst);\n             }\n         }\n         ret\n     }\n \n+    /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n+    /// This expends fuel if applicable, and records fuel if applicable.\n+    #[inline(always)]\n+    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n+        if likely!(self.optimization_fuel_crate.is_none() && self.print_fuel_crate.is_none()) {\n+            true\n+        } else {\n+            self.consider_optimizing_cold(crate_name, msg)\n+        }\n+    }\n+\n     /// Returns the number of query threads that should be used for this\n     /// compilation\n     pub fn query_threads_from_opts(opts: &config::Options) -> usize {\n@@ -1128,9 +1141,9 @@ pub fn build_session_(\n \n     let optimization_fuel_crate = sopts.debugging_opts.fuel.as_ref().map(|i| i.0.clone());\n     let optimization_fuel_limit =\n-        LockCell::new(sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0));\n+        AtomicU64::new(sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0));\n     let print_fuel_crate = sopts.debugging_opts.print_fuel.clone();\n-    let print_fuel = LockCell::new(0);\n+    let print_fuel = AtomicU64::new(0);\n \n     let working_dir = env::current_dir().unwrap_or_else(|e|\n         p_s.span_diagnostic\n@@ -1195,7 +1208,7 @@ pub fn build_session_(\n         optimization_fuel_limit,\n         print_fuel_crate,\n         print_fuel,\n-        out_of_fuel: LockCell::new(false),\n+        out_of_fuel: AtomicBool::new(false),\n         // Note that this is unsafe because it may misinterpret file descriptors\n         // on Unix as jobserver file descriptors. We hopefully execute this near\n         // the beginning of the process though to ensure we don't get false"}, {"sha": "ec71f5158948ced3e91dc5f973e318543d1ffd3d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=03b7cec2defdec00bef79045252341dd49fc9f0c", "patch": "@@ -21,6 +21,7 @@\n #![feature(hash_raw_entry)]\n #![feature(stmt_expr_attributes)]\n #![feature(core_intrinsics)]\n+#![feature(integer_atomics)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "5379e1871aefb194a02b9b0d32ecb8ad4d6f6c78", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 61, "deletions": 149, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=03b7cec2defdec00bef79045252341dd49fc9f0c", "patch": "@@ -10,10 +10,6 @@\n //! It internally uses `parking_lot::RwLock` if cfg!(parallel_queries) is true,\n //! `RefCell` otherwise.\n //!\n-//! `LockCell` is a thread safe version of `Cell`, with `set` and `get` operations.\n-//! It can never deadlock. It uses `Cell` when\n-//! cfg!(parallel_queries) is false, otherwise it is a `Lock`.\n-//!\n //! `MTLock` is a mutex which disappears if cfg!(parallel_queries) is false.\n //!\n //! `MTRef` is a immutable reference if cfg!(parallel_queries), and an mutable reference otherwise.\n@@ -23,11 +19,7 @@\n \n use std::collections::HashMap;\n use std::hash::{Hash, BuildHasher};\n-use std::cmp::Ordering;\n use std::marker::PhantomData;\n-use std::fmt::Debug;\n-use std::fmt::Formatter;\n-use std::fmt;\n use std::ops::{Deref, DerefMut};\n use owning_ref::{Erased, OwningRef};\n \n@@ -54,6 +46,9 @@ pub fn serial_scope<F, R>(f: F) -> R\n     f(&SerialScope)\n }\n \n+pub use std::sync::atomic::Ordering::SeqCst;\n+pub use std::sync::atomic::Ordering;\n+\n cfg_if! {\n     if #[cfg(not(parallel_queries))] {\n         pub auto trait Send {}\n@@ -69,6 +64,62 @@ cfg_if! {\n             }\n         }\n \n+        use std::ops::Add;\n+\n+        #[derive(Debug)]\n+        pub struct Atomic<T: Copy>(Cell<T>);\n+\n+        impl<T: Copy> Atomic<T> {\n+            pub fn new(v: T) -> Self {\n+                Atomic(Cell::new(v))\n+            }\n+        }\n+\n+        impl<T: Copy + PartialEq> Atomic<T> {\n+            pub fn into_inner(self) -> T {\n+                self.0.into_inner()\n+            }\n+\n+            pub fn load(&self, _: Ordering) -> T {\n+                self.0.get()\n+            }\n+\n+            pub fn store(&self, val: T, _: Ordering) {\n+                self.0.set(val)\n+            }\n+\n+            pub fn swap(&self, val: T, _: Ordering) -> T {\n+                self.0.replace(val)\n+            }\n+\n+            pub fn compare_exchange(&self,\n+                                    current: T,\n+                                    new: T,\n+                                    _: Ordering,\n+                                    _: Ordering)\n+                                    -> Result<T, T> {\n+                let read = self.0.get();\n+                if read == current {\n+                    self.0.set(new);\n+                    Ok(read)\n+                } else {\n+                    Err(read)\n+                }\n+            }\n+        }\n+\n+        impl<T: Add<Output=T> + Copy> Atomic<T> {\n+            pub fn fetch_add(&self, val: T, _: Ordering) -> T {\n+                let old = self.0.get();\n+                self.0.set(old + val);\n+                old\n+            }\n+        }\n+\n+        pub type AtomicUsize = Atomic<usize>;\n+        pub type AtomicBool = Atomic<bool>;\n+        pub type AtomicU64 = Atomic<u64>;\n+\n         pub use self::serial_join as join;\n         pub use self::serial_scope as scope;\n \n@@ -160,47 +211,6 @@ cfg_if! {\n                 MTLock(self.0.clone())\n             }\n         }\n-\n-        pub struct LockCell<T>(Cell<T>);\n-\n-        impl<T> LockCell<T> {\n-            #[inline(always)]\n-            pub fn new(inner: T) -> Self {\n-                LockCell(Cell::new(inner))\n-            }\n-\n-            #[inline(always)]\n-            pub fn into_inner(self) -> T {\n-                self.0.into_inner()\n-            }\n-\n-            #[inline(always)]\n-            pub fn set(&self, new_inner: T) {\n-                self.0.set(new_inner);\n-            }\n-\n-            #[inline(always)]\n-            pub fn get(&self) -> T where T: Copy {\n-                self.0.get()\n-            }\n-\n-            #[inline(always)]\n-            pub fn set_mut(&mut self, new_inner: T) {\n-                self.0.set(new_inner);\n-            }\n-\n-            #[inline(always)]\n-            pub fn get_mut(&mut self) -> T where T: Copy {\n-                self.0.get()\n-            }\n-        }\n-\n-        impl<T> LockCell<Option<T>> {\n-            #[inline(always)]\n-            pub fn take(&self) -> Option<T> {\n-                unsafe { (*self.0.as_ptr()).take() }\n-            }\n-        }\n     } else {\n         pub use std::marker::Send as Send;\n         pub use std::marker::Sync as Sync;\n@@ -213,6 +223,8 @@ cfg_if! {\n         pub use parking_lot::MutexGuard as LockGuard;\n         pub use parking_lot::MappedMutexGuard as MappedLockGuard;\n \n+        pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU64};\n+\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n \n@@ -278,47 +290,6 @@ cfg_if! {\n                 v.erase_send_sync_owner()\n             }}\n         }\n-\n-        pub struct LockCell<T>(Lock<T>);\n-\n-        impl<T> LockCell<T> {\n-            #[inline(always)]\n-            pub fn new(inner: T) -> Self {\n-                LockCell(Lock::new(inner))\n-            }\n-\n-            #[inline(always)]\n-            pub fn into_inner(self) -> T {\n-                self.0.into_inner()\n-            }\n-\n-            #[inline(always)]\n-            pub fn set(&self, new_inner: T) {\n-                *self.0.lock() = new_inner;\n-            }\n-\n-            #[inline(always)]\n-            pub fn get(&self) -> T where T: Copy {\n-                *self.0.lock()\n-            }\n-\n-            #[inline(always)]\n-            pub fn set_mut(&mut self, new_inner: T) {\n-                *self.0.get_mut() = new_inner;\n-            }\n-\n-            #[inline(always)]\n-            pub fn get_mut(&mut self) -> T where T: Copy {\n-                *self.0.get_mut()\n-            }\n-        }\n-\n-        impl<T> LockCell<Option<T>> {\n-            #[inline(always)]\n-            pub fn take(&self) -> Option<T> {\n-                self.0.lock().take()\n-            }\n-        }\n     }\n }\n \n@@ -466,65 +437,6 @@ impl<T> Once<T> {\n     }\n }\n \n-impl<T: Copy + Debug> Debug for LockCell<T> {\n-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n-        f.debug_struct(\"LockCell\")\n-            .field(\"value\", &self.get())\n-            .finish()\n-    }\n-}\n-\n-impl<T:Default> Default for LockCell<T> {\n-    /// Creates a `LockCell<T>`, with the `Default` value for T.\n-    #[inline]\n-    fn default() -> LockCell<T> {\n-        LockCell::new(Default::default())\n-    }\n-}\n-\n-impl<T:PartialEq + Copy> PartialEq for LockCell<T> {\n-    #[inline]\n-    fn eq(&self, other: &LockCell<T>) -> bool {\n-        self.get() == other.get()\n-    }\n-}\n-\n-impl<T:Eq + Copy> Eq for LockCell<T> {}\n-\n-impl<T:PartialOrd + Copy> PartialOrd for LockCell<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &LockCell<T>) -> Option<Ordering> {\n-        self.get().partial_cmp(&other.get())\n-    }\n-\n-    #[inline]\n-    fn lt(&self, other: &LockCell<T>) -> bool {\n-        self.get() < other.get()\n-    }\n-\n-    #[inline]\n-    fn le(&self, other: &LockCell<T>) -> bool {\n-        self.get() <= other.get()\n-    }\n-\n-    #[inline]\n-    fn gt(&self, other: &LockCell<T>) -> bool {\n-        self.get() > other.get()\n-    }\n-\n-    #[inline]\n-    fn ge(&self, other: &LockCell<T>) -> bool {\n-        self.get() >= other.get()\n-    }\n-}\n-\n-impl<T:Ord + Copy> Ord for LockCell<T> {\n-    #[inline]\n-    fn cmp(&self, other: &LockCell<T>) -> Ordering {\n-        self.get().cmp(&other.get())\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct Lock<T>(InnerLock<T>);\n "}, {"sha": "af8c50a454eb5d928953236a9fa952c2d4284ba0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=03b7cec2defdec00bef79045252341dd49fc9f0c", "patch": "@@ -16,6 +16,7 @@\n #![feature(slice_sort_by_cached_key)]\n #![feature(set_stdio)]\n #![feature(no_debug)]\n+#![feature(integer_atomics)]\n \n #![recursion_limit=\"256\"]\n \n@@ -59,7 +60,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_data_structures::sync::{self, Lrc};\n+use rustc_data_structures::sync::{self, Lrc, Ordering::SeqCst};\n use rustc_data_structures::OnDrop;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n@@ -934,7 +935,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 let sess = state.session;\n                 eprintln!(\"Fuel used by {}: {}\",\n                     sess.print_fuel_crate.as_ref().unwrap(),\n-                    sess.print_fuel.get());\n+                    sess.print_fuel.load(SeqCst));\n             }\n         }\n         control"}, {"sha": "a074441f8a179b0624064c76e1dcb23b896cd884", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b7cec2defdec00bef79045252341dd49fc9f0c/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=03b7cec2defdec00bef79045252341dd49fc9f0c", "patch": "@@ -26,15 +26,13 @@ use self::Level::*;\n \n use emitter::{Emitter, EmitterWriter};\n \n-use rustc_data_structures::sync::{self, Lrc, Lock, LockCell};\n+use rustc_data_structures::sync::{self, Lrc, Lock, AtomicUsize, AtomicBool, SeqCst};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stable_hasher::StableHasher;\n \n use std::borrow::Cow;\n use std::cell::Cell;\n use std::{error, fmt};\n-use std::sync::atomic::AtomicUsize;\n-use std::sync::atomic::Ordering::SeqCst;\n use std::panic;\n \n use termcolor::{ColorSpec, Color};\n@@ -271,7 +269,7 @@ pub struct Handler {\n \n     err_count: AtomicUsize,\n     emitter: Lock<Box<dyn Emitter + sync::Send>>,\n-    continue_after_error: LockCell<bool>,\n+    continue_after_error: AtomicBool,\n     delayed_span_bugs: Lock<Vec<Diagnostic>>,\n \n     // This set contains the `DiagnosticId` of all emitted diagnostics to avoid\n@@ -370,7 +368,7 @@ impl Handler {\n             flags,\n             err_count: AtomicUsize::new(0),\n             emitter: Lock::new(e),\n-            continue_after_error: LockCell::new(true),\n+            continue_after_error: AtomicBool::new(true),\n             delayed_span_bugs: Lock::new(Vec::new()),\n             taught_diagnostics: Default::default(),\n             emitted_diagnostic_codes: Default::default(),\n@@ -379,7 +377,7 @@ impl Handler {\n     }\n \n     pub fn set_continue_after_error(&self, continue_after_error: bool) {\n-        self.continue_after_error.set(continue_after_error);\n+        self.continue_after_error.store(continue_after_error, SeqCst);\n     }\n \n     /// Resets the diagnostic error count as well as the cached emitted diagnostics.\n@@ -658,7 +656,7 @@ impl Handler {\n         let mut db = DiagnosticBuilder::new(self, lvl, msg);\n         db.set_span(msp.clone());\n         db.emit();\n-        if !self.continue_after_error.get() {\n+        if !self.continue_after_error.load(SeqCst) {\n             self.abort_if_errors();\n         }\n     }\n@@ -669,7 +667,7 @@ impl Handler {\n         let mut db = DiagnosticBuilder::new_with_code(self, lvl, Some(code), msg);\n         db.set_span(msp.clone());\n         db.emit();\n-        if !self.continue_after_error.get() {\n+        if !self.continue_after_error.load(SeqCst) {\n             self.abort_if_errors();\n         }\n     }"}]}