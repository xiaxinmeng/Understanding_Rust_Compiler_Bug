{"sha": "696367fb8de63a3ff264c65981457b9fbd0e7b06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NjM2N2ZiOGRlNjNhM2ZmMjY0YzY1OTgxNDU3YjlmYmQwZTdiMDY=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-08-21T13:34:00Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-09-09T19:34:41Z"}, "message": "Decouple string and argument pieces", "tree": {"sha": "4b5d33c711873f1fd881300a13f91b7a90d12be7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b5d33c711873f1fd881300a13f91b7a90d12be7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/696367fb8de63a3ff264c65981457b9fbd0e7b06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/696367fb8de63a3ff264c65981457b9fbd0e7b06", "html_url": "https://github.com/rust-lang/rust/commit/696367fb8de63a3ff264c65981457b9fbd0e7b06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/696367fb8de63a3ff264c65981457b9fbd0e7b06/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f34760e4173dda94162502153fe4c5a2a96fc9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f34760e4173dda94162502153fe4c5a2a96fc9d", "html_url": "https://github.com/rust-lang/rust/commit/6f34760e4173dda94162502153fe4c5a2a96fc9d"}], "stats": {"total": 179, "additions": 134, "deletions": 45}, "files": [{"sha": "9f64e1aa4928ef7ff3137f380e07046606af53bd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/696367fb8de63a3ff264c65981457b9fbd0e7b06/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696367fb8de63a3ff264c65981457b9fbd0e7b06/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=696367fb8de63a3ff264c65981457b9fbd0e7b06", "patch": "@@ -113,6 +113,19 @@ impl<'a> Arguments<'a> {\n     /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n     /// which is valid because the compiler performs all necessary validation to\n     /// ensure that the resulting call to format/write would be safe.\n+    #[cfg(not(stage0))]\n+    #[doc(hidden)] #[inline]\n+    pub unsafe fn new<'a>(pieces: &'static [&'static str],\n+                          fmt: &'static [rt::Argument<'static>],\n+                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n+        Arguments {\n+            pieces: mem::transmute(pieces),\n+            fmt: mem::transmute(fmt),\n+            args: args\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     #[doc(hidden)] #[inline]\n     pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n                           args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -129,6 +142,14 @@ impl<'a> Arguments<'a> {\n /// and pass it to a function or closure, passed as the first argument. The\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n+#[cfg(not(stage0))]\n+pub struct Arguments<'a> {\n+    pieces: &'a [&'a str],\n+    fmt: &'a [rt::Argument<'a>],\n+    args: &'a [Argument<'a>],\n+}\n+\n+#[cfg(stage0)] #[doc(hidden)]\n pub struct Arguments<'a> {\n     fmt: &'a [rt::Piece<'a>],\n     args: &'a [Argument<'a>],\n@@ -263,6 +284,37 @@ uniform_fn_call_workaround! {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n+#[cfg(not(stage0))]\n+pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n+    let mut formatter = Formatter {\n+        flags: 0,\n+        width: None,\n+        precision: None,\n+        buf: output,\n+        align: rt::AlignUnknown,\n+        fill: ' ',\n+        args: args.args,\n+        curarg: args.args.iter(),\n+    };\n+\n+    let mut pieces = args.pieces.iter();\n+\n+    for arg in args.fmt.iter() {\n+        try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n+        try!(formatter.run(arg));\n+    }\n+\n+    match pieces.next() {\n+        Some(piece) => {\n+            try!(formatter.buf.write(piece.as_bytes()));\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+#[cfg(stage0)] #[doc(hidden)]\n pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n@@ -285,7 +337,26 @@ impl<'a> Formatter<'a> {\n     // First up is the collection of functions used to execute a format string\n     // at runtime. This consumes all of the compile-time statics generated by\n     // the format! syntax extension.\n+    #[cfg(not(stage0))]\n+    fn run(&mut self, arg: &rt::Argument) -> Result {\n+        // Fill in the format parameters into the formatter\n+        self.fill = arg.format.fill;\n+        self.align = arg.format.align;\n+        self.flags = arg.format.flags;\n+        self.width = self.getcount(&arg.format.width);\n+        self.precision = self.getcount(&arg.format.precision);\n+\n+        // Extract the correct argument\n+        let value = match arg.position {\n+            rt::ArgumentNext => { *self.curarg.next().unwrap() }\n+            rt::ArgumentIs(i) => self.args[i],\n+        };\n+\n+        // Then actually do some printing\n+        (value.formatter)(value.value, self)\n+    }\n \n+    #[cfg(stage0)] #[doc(hidden)]\n     fn run(&mut self, piece: &rt::Piece) -> Result {\n         match *piece {\n             rt::String(s) => self.buf.write(s.as_bytes()),"}, {"sha": "59fbde88d8be3ad9e1979e250334e0ba8c44b4c0", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696367fb8de63a3ff264c65981457b9fbd0e7b06/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696367fb8de63a3ff264c65981457b9fbd0e7b06/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=696367fb8de63a3ff264c65981457b9fbd0e7b06", "patch": "@@ -14,7 +14,7 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub enum Piece<'a> {\n     String(&'a str),"}, {"sha": "fc4d8c83c514e24f7b073c4a188e576e65b20928", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/696367fb8de63a3ff264c65981457b9fbd0e7b06/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696367fb8de63a3ff264c65981457b9fbd0e7b06/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=696367fb8de63a3ff264c65981457b9fbd0e7b06", "patch": "@@ -49,11 +49,13 @@ struct Context<'a, 'b:'a> {\n     name_types: HashMap<String, ArgumentType>,\n     name_ordering: Vec<String>,\n \n-    /// The latest consecutive literal strings\n-    literal: Option<String>,\n+    /// The latest consecutive literal strings, or empty if there weren't any.\n+    literal: String,\n \n-    /// Collection of the compiled `rt::Piece` structures\n+    /// Collection of the compiled `rt::Argument` structures\n     pieces: Vec<Gc<ast::Expr>>,\n+    /// Collection of string literals\n+    str_pieces: Vec<Gc<ast::Expr>>,\n     name_positions: HashMap<String, uint>,\n     method_statics: Vec<Gc<ast::Item>>,\n \n@@ -370,28 +372,22 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    /// Translate the accumulated string literals to a static `rt::Piece`\n-    fn trans_literal_string(&mut self) -> Option<Gc<ast::Expr>> {\n+    /// Translate the accumulated string literals to a literal expression\n+    fn trans_literal_string(&mut self) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n-        self.literal.take().map(|s| {\n-            let s = token::intern_and_get_ident(s.as_slice());\n-            self.ecx.expr_call_global(sp,\n-                                      self.rtpath(\"String\"),\n-                                      vec!(\n-                self.ecx.expr_str(sp, s)\n-            ))\n-        })\n+        let s = token::intern_and_get_ident(self.literal.as_slice());\n+        self.literal.clear();\n+        self.ecx.expr_str(sp, s)\n     }\n \n-    /// Translate a `parse::Piece` to a static `rt::Piece`\n+    /// Translate a `parse::Piece` to a static `rt::Argument` or append\n+    /// to the `literal` string.\n     fn trans_piece(&mut self, piece: &parse::Piece) -> Option<Gc<ast::Expr>> {\n+        // let mut is_not_default = true;\n         let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n-                match self.literal {\n-                    Some(ref mut sb) => sb.push_str(s),\n-                    ref mut empty => *empty = Some(String::from_str(s)),\n-                }\n+                self.literal.push_str(s);\n                 None\n             }\n             parse::Argument(ref arg) => {\n@@ -450,10 +446,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n \n                 let path = self.ecx.path_global(sp, self.rtpath(\"Argument\"));\n-                let s = self.ecx.expr_struct(sp, path, vec!(\n+                Some(self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt)));\n-                Some(self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), vec!(s)))\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt))))\n             }\n         }\n     }\n@@ -476,14 +471,38 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // Next, build up the static array which will become our precompiled\n         // format \"string\"\n+        let fmt = self.ecx.expr_vec(self.fmtsp, self.str_pieces.clone());\n+        let piece_ty = self.ecx.ty_rptr(self.fmtsp,\n+                                        self.ecx.ty_ident(self.fmtsp,\n+                                             self.ecx.ident_of(\"str\")),\n+                                        Some(self.ecx.lifetime(self.fmtsp,\n+                                             self.ecx.ident_of(\n+                                                 \"'static\").name)),\n+                                        ast::MutImmutable);\n+\n+        let ty = ast::TyFixedLengthVec(\n+            piece_ty,\n+            self.ecx.expr_uint(self.fmtsp, self.str_pieces.len())\n+        );\n+        let ty = self.ecx.ty(self.fmtsp, ty);\n+        let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n+        let static_str_name = self.ecx.ident_of(\"__STATIC_FMTSTR\");\n+        let item = self.ecx.item(self.fmtsp, static_str_name,\n+                                 self.static_attrs(), st);\n+        let decl = respan(self.fmtsp, ast::DeclItem(item));\n+        lets.push(box(GC) respan(self.fmtsp,\n+                                 ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n+\n+        // Then, build up the static array which will become our precompiled\n+        // format \"string\"\n         let fmt = self.ecx.expr_vec(self.fmtsp, self.pieces.clone());\n         let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n                 self.fmtsp,\n                 true, vec!(\n                     self.ecx.ident_of(\"std\"),\n                     self.ecx.ident_of(\"fmt\"),\n                     self.ecx.ident_of(\"rt\"),\n-                    self.ecx.ident_of(\"Piece\")),\n+                    self.ecx.ident_of(\"Argument\")),\n                 vec!(self.ecx.lifetime(self.fmtsp,\n                                        self.ecx.ident_of(\"'static\").name)),\n                 Vec::new()\n@@ -494,8 +513,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         );\n         let ty = self.ecx.ty(self.fmtsp, ty);\n         let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n-        let static_name = self.ecx.ident_of(\"__STATIC_FMTSTR\");\n-        let item = self.ecx.item(self.fmtsp, static_name,\n+        let static_args_name = self.ecx.ident_of(\"__STATIC_FMTARGS\");\n+        let item = self.ecx.item(self.fmtsp, static_args_name,\n                                  self.static_attrs(), st);\n         let decl = respan(self.fmtsp, ast::DeclItem(item));\n         lets.push(box(GC) respan(self.fmtsp,\n@@ -545,13 +564,14 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n-        let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n+        let pieces = self.ecx.expr_ident(self.fmtsp, static_str_name);\n+        let fmt = self.ecx.expr_ident(self.fmtsp, static_args_name);\n         let args_slice = self.ecx.expr_ident(self.fmtsp, slicename);\n         let result = self.ecx.expr_call_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"Arguments\"),\n-                self.ecx.ident_of(\"new\")), vec!(fmt, args_slice));\n+                self.ecx.ident_of(\"new\")), vec!(pieces, fmt, args_slice));\n \n         // We did all the work of making sure that the arguments\n         // structure is safe, so we can safely have an unsafe block.\n@@ -718,8 +738,9 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n-        literal: None,\n+        literal: String::new(),\n         pieces: Vec::new(),\n+        str_pieces: Vec::new(),\n         method_statics: Vec::new(),\n         fmtsp: sp,\n     };\n@@ -739,8 +760,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                 cx.verify_piece(&piece);\n                 match cx.trans_piece(&piece) {\n                     Some(piece) => {\n-                        cx.trans_literal_string().map(|piece|\n-                                                      cx.pieces.push(piece));\n+                        let s = cx.trans_literal_string();\n+                        cx.str_pieces.push(s);\n                         cx.pieces.push(piece);\n                     }\n                     None => {}\n@@ -758,7 +779,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n         None => {}\n     }\n-    cx.trans_literal_string().map(|piece| cx.pieces.push(piece));\n+    if !cx.literal.is_empty() {\n+        let s = cx.trans_literal_string();\n+        cx.str_pieces.push(s);\n+    }\n \n     // Make sure that all arguments were used and all arguments have types.\n     for (i, ty) in cx.arg_types.iter().enumerate() {"}, {"sha": "376a3a38fda1ed3d566a8dc2550ff1b6008f37e5", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/696367fb8de63a3ff264c65981457b9fbd0e7b06/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/696367fb8de63a3ff264c65981457b9fbd0e7b06/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=696367fb8de63a3ff264c65981457b9fbd0e7b06", "patch": "@@ -39,26 +39,20 @@\n          () => {\n              #[inline]\n              #[allow(dead_code)]\n-             static __STATIC_FMTSTR:\n-                    [::std::fmt::rt::Piece<'static>, ..(1u as uint)] =\n-                 ([((::std::fmt::rt::String as\n-                        fn(&'static str) -> core::fmt::rt::Piece<'static>)((\"test\"\n-                                                                               as\n-                                                                               &'static str))\n-                       as core::fmt::rt::Piece<'static>)] as\n-                     [core::fmt::rt::Piece<'static>, .. 1]);\n+             static __STATIC_FMTSTR: [&'static str, ..(1u as uint)] =\n+                 ([(\"test\" as &'static str)] as [&'static str, .. 1]);\n              let __args_vec =\n                  (&([] as [core::fmt::Argument<'_>, .. 0]) as\n                      &[core::fmt::Argument<'_>, .. 0]);\n              let __args =\n                  (unsafe {\n                       ((::std::fmt::Arguments::new as\n-                           unsafe fn(&'static [core::fmt::rt::Piece<'static>], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n-                                                                                                                                               as\n-                                                                                                                                               [core::fmt::rt::Piece<'static>, .. 1]),\n-                                                                                                                                           (__args_vec\n-                                                                                                                                               as\n-                                                                                                                                               &[core::fmt::Argument<'_>, .. 0]))\n+                           unsafe fn(&'static [&'static str], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n+                                                                                                                              as\n+                                                                                                                              [&'static str, .. 1]),\n+                                                                                                                          (__args_vec\n+                                                                                                                              as\n+                                                                                                                              &[core::fmt::Argument<'_>, .. 0]))\n                           as core::fmt::Arguments<'_>)\n                   } as core::fmt::Arguments<'_>);\n "}]}