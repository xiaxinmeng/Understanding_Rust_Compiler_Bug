{"sha": "9be7ca00f1ca2425e97da90d65575ac48aa7803c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZTdjYTAwZjFjYTI0MjVlOTdkYTkwZDY1NTc1YWM0OGFhNzgwM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-16T07:20:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-16T07:20:27Z"}, "message": "Auto merge of #86291 - crlf0710:trait_vtbl_refactor, r=bjorn3\n\nRefactor vtable codegen\n\nThis refactor the codegen of vtables of miri interpreter, llvm, cranelift codegen backends.\n\nThis is preparation for the implementation of trait upcasting feature. cc #65991\n\nNote that aside from code reorganization, there's an internal behavior change here that now InstanceDef::Virtual's index now include the three metadata slots, and now the first method is with index 3.\n\ncc  `@RalfJung` `@bjorn3`", "tree": {"sha": "e0e5c1be21ba111197aac1350865940573693a04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0e5c1be21ba111197aac1350865940573693a04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be7ca00f1ca2425e97da90d65575ac48aa7803c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be7ca00f1ca2425e97da90d65575ac48aa7803c", "html_url": "https://github.com/rust-lang/rust/commit/9be7ca00f1ca2425e97da90d65575ac48aa7803c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be7ca00f1ca2425e97da90d65575ac48aa7803c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8923e42a05b59022ffcc163d9e9b13c9de1189c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8923e42a05b59022ffcc163d9e9b13c9de1189c9", "html_url": "https://github.com/rust-lang/rust/commit/8923e42a05b59022ffcc163d9e9b13c9de1189c9"}, {"sha": "d3e123fc4f8c2907db8a88e851ecb5149fa7670f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e123fc4f8c2907db8a88e851ecb5149fa7670f", "html_url": "https://github.com/rust-lang/rust/commit/d3e123fc4f8c2907db8a88e851ecb5149fa7670f"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "4d1ee47b41e170c910d0f91d80d34c6c12717ad4", "filename": "src/vtable.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9be7ca00f1ca2425e97da90d65575ac48aa7803c/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be7ca00f1ca2425e97da90d65575ac48aa7803c/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=9be7ca00f1ca2425e97da90d65575ac48aa7803c", "patch": "@@ -4,10 +4,7 @@\n // FIXME dedup this logic between miri, cg_llvm and cg_clif\n \n use crate::prelude::*;\n-\n-const DROP_FN_INDEX: usize = 0;\n-const SIZE_INDEX: usize = 1;\n-const ALIGN_INDEX: usize = 2;\n+use ty::VtblEntry;\n \n fn vtable_memflags() -> MemFlags {\n     let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n@@ -21,7 +18,7 @@ pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) ->\n         pointer_ty(fx.tcx),\n         vtable_memflags(),\n         vtable,\n-        (DROP_FN_INDEX * usize_size) as i32,\n+        (ty::COMMON_VTABLE_ENTRIES_DROPINPLACE * usize_size) as i32,\n     )\n }\n \n@@ -31,7 +28,7 @@ pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Val\n         pointer_ty(fx.tcx),\n         vtable_memflags(),\n         vtable,\n-        (SIZE_INDEX * usize_size) as i32,\n+        (ty::COMMON_VTABLE_ENTRIES_SIZE * usize_size) as i32,\n     )\n }\n \n@@ -41,7 +38,7 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -\n         pointer_ty(fx.tcx),\n         vtable_memflags(),\n         vtable,\n-        (ALIGN_INDEX * usize_size) as i32,\n+        (ty::COMMON_VTABLE_ENTRIES_SIZE * usize_size) as i32,\n     )\n }\n \n@@ -62,7 +59,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n         pointer_ty(fx.tcx),\n         vtable_memflags(),\n         vtable,\n-        ((idx + 3) * usize_size as usize) as i32,\n+        (idx * usize_size as usize) as i32,\n     );\n     (ptr, func_ref)\n }\n@@ -98,42 +95,49 @@ fn build_vtable<'tcx>(\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n-    let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n-\n-    let methods_root;\n-    let methods = if let Some(trait_ref) = trait_ref {\n-        methods_root = tcx.vtable_methods(trait_ref.with_self_ty(tcx, layout.ty));\n-        methods_root.iter()\n+    let vtable_entries = if let Some(trait_ref) = trait_ref {\n+        tcx.vtable_entries(trait_ref.with_self_ty(tcx, layout.ty))\n     } else {\n-        (&[]).iter()\n+        ty::COMMON_VTABLE_ENTRIES\n     };\n-    let methods = methods.cloned().map(|opt_mth| {\n-        opt_mth.map(|(def_id, substs)| {\n-            import_function(\n-                tcx,\n-                fx.module,\n-                Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n-                    .unwrap()\n-                    .polymorphize(fx.tcx),\n-            )\n-        })\n-    });\n-    components.extend(methods);\n \n     let mut data_ctx = DataContext::new();\n     let mut data = ::std::iter::repeat(0u8)\n-        .take(components.len() * usize_size)\n+        .take(vtable_entries.len() * usize_size)\n         .collect::<Vec<u8>>()\n         .into_boxed_slice();\n \n-    write_usize(fx.tcx, &mut data, SIZE_INDEX, layout.size.bytes());\n-    write_usize(fx.tcx, &mut data, ALIGN_INDEX, layout.align.abi.bytes());\n+    for (idx, entry) in vtable_entries.iter().enumerate() {\n+        match entry {\n+            VtblEntry::MetadataSize => {\n+                write_usize(fx.tcx, &mut data, idx, layout.size.bytes());\n+            }\n+            VtblEntry::MetadataAlign => {\n+                write_usize(fx.tcx, &mut data, idx, layout.align.abi.bytes());\n+            }\n+            VtblEntry::MetadataDropInPlace | VtblEntry::Vacant | VtblEntry::Method(_, _) => {}\n+        }\n+    }\n     data_ctx.define(data);\n \n-    for (i, component) in components.into_iter().enumerate() {\n-        if let Some(func_id) = component {\n-            let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n-            data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n+    for (idx, entry) in vtable_entries.iter().enumerate() {\n+        match entry {\n+            VtblEntry::MetadataDropInPlace => {\n+                let func_ref = fx.module.declare_func_in_data(drop_in_place_fn, &mut data_ctx);\n+                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n+            }\n+            VtblEntry::Method(def_id, substs) => {\n+                let func_id = import_function(\n+                    tcx,\n+                    fx.module,\n+                    Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), *def_id, substs)\n+                        .unwrap()\n+                        .polymorphize(fx.tcx),\n+                );\n+                let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n+                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n+            }\n+            VtblEntry::MetadataSize | VtblEntry::MetadataAlign | VtblEntry::Vacant => {}\n         }\n     }\n "}]}