{"sha": "c8a643f090ed88289c7bc17b48078e39b932c8a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YTY0M2YwOTBlZDg4Mjg5YzdiYzE3YjQ4MDc4ZTM5YjkzMmM4YTQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-01T15:06:11Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-04T16:18:30Z"}, "message": "Move Chalk conversion code to its own module", "tree": {"sha": "8ac8541e91a2d7e0413e4275c2e299a295a84790", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ac8541e91a2d7e0413e4275c2e299a295a84790"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8a643f090ed88289c7bc17b48078e39b932c8a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a643f090ed88289c7bc17b48078e39b932c8a4", "html_url": "https://github.com/rust-lang/rust/commit/c8a643f090ed88289c7bc17b48078e39b932c8a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8a643f090ed88289c7bc17b48078e39b932c8a4/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99492278ac8c8a9caf3981b4406dcac6724a6a93", "url": "https://api.github.com/repos/rust-lang/rust/commits/99492278ac8c8a9caf3981b4406dcac6724a6a93", "html_url": "https://github.com/rust-lang/rust/commit/99492278ac8c8a9caf3981b4406dcac6724a6a93"}], "stats": {"total": 660, "additions": 339, "deletions": 321}, "files": [{"sha": "ff4a81e59bf4ae70ac000b4cbf6a8ccd3a7b7beb", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 4, "deletions": 46, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c8a643f090ed88289c7bc17b48078e39b932c8a4/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a643f090ed88289c7bc17b48078e39b932c8a4/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=c8a643f090ed88289c7bc17b48078e39b932c8a4", "patch": "@@ -323,25 +323,6 @@ impl AstItemDef<ast::TraitDef> for TraitId {\n     }\n }\n \n-fn from_chalk<T: salsa::InternKey>(chalk_id: chalk_ir::RawId) -> T {\n-    T::from_intern_id(salsa::InternId::from(chalk_id.index))\n-}\n-fn to_chalk<T: salsa::InternKey>(salsa_id: T) -> chalk_ir::RawId {\n-    chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n-}\n-\n-impl From<chalk_ir::TraitId> for TraitId {\n-    fn from(trait_id: chalk_ir::TraitId) -> Self {\n-        from_chalk(trait_id.0)\n-    }\n-}\n-\n-impl From<TraitId> for chalk_ir::TraitId {\n-    fn from(trait_id: TraitId) -> Self {\n-        chalk_ir::TraitId(to_chalk(trait_id))\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAliasId(salsa::InternId);\n impl_intern_key!(TypeAliasId);\n@@ -374,37 +355,14 @@ impl MacroCallId {\n     }\n }\n \n-/// This exists just for chalk, because chalk doesn't differentiate between\n-/// enums and structs.\n+/// This exists just for Chalk, because Chalk just has a single `StructId` where\n+/// we have different kinds of ADTs, primitive types and special type\n+/// constructors like tuples and function pointers.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeCtorId(salsa::InternId);\n impl_intern_key!(TypeCtorId);\n \n-impl From<chalk_ir::StructId> for TypeCtorId {\n-    fn from(struct_id: chalk_ir::StructId) -> Self {\n-        from_chalk(struct_id.0)\n-    }\n-}\n-\n-impl From<TypeCtorId> for chalk_ir::StructId {\n-    fn from(adt_id: TypeCtorId) -> Self {\n-        chalk_ir::StructId(to_chalk(adt_id))\n-    }\n-}\n-\n-/// This exists just for chalk, because our ImplIds are only unique per module.\n+/// This exists just for Chalk, because our ImplIds are only unique per module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct GlobalImplId(salsa::InternId);\n impl_intern_key!(GlobalImplId);\n-\n-impl From<chalk_ir::ImplId> for GlobalImplId {\n-    fn from(impl_id: chalk_ir::ImplId) -> Self {\n-        from_chalk(impl_id.0)\n-    }\n-}\n-\n-impl From<GlobalImplId> for chalk_ir::ImplId {\n-    fn from(impl_id: GlobalImplId) -> Self {\n-        chalk_ir::ImplId(to_chalk(impl_id))\n-    }\n-}"}, {"sha": "acb69683cbde98ee83682e797193cf85b47fb77e", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 8, "deletions": 275, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/c8a643f090ed88289c7bc17b48078e39b932c8a4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a643f090ed88289c7bc17b48078e39b932c8a4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=c8a643f090ed88289c7bc17b48078e39b932c8a4", "patch": "@@ -1,288 +1,21 @@\n-//! Chalk integration.\n+//! Trait solving using Chalk.\n use std::sync::{Arc, Mutex};\n \n-use chalk_ir::{TypeId, TraitId, StructId, ImplId, TypeKindId, ProjectionTy, Parameter, Identifier, cast::Cast};\n-use chalk_rust_ir::{AssociatedTyDatum, TraitDatum, StructDatum, ImplDatum};\n+use chalk_ir::cast::Cast;\n \n-use crate::{Crate, Trait, db::HirDatabase, HasGenericParams, ImplBlock};\n-use super::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs, infer::Canonical};\n+use crate::{Crate, Trait, db::HirDatabase, ImplBlock};\n+use super::{TraitRef, Ty, infer::Canonical};\n+\n+use self::chalk::{ToChalk, from_chalk};\n+\n+mod chalk;\n \n #[derive(Debug, Copy, Clone)]\n struct ChalkContext<'a, DB> {\n     db: &'a DB,\n     krate: Crate,\n }\n \n-pub(crate) trait ToChalk {\n-    type Chalk;\n-    fn to_chalk(self, db: &impl HirDatabase) -> Self::Chalk;\n-    fn from_chalk(db: &impl HirDatabase, chalk: Self::Chalk) -> Self;\n-}\n-\n-pub(crate) fn from_chalk<T, ChalkT>(db: &impl HirDatabase, chalk: ChalkT) -> T\n-where\n-    T: ToChalk<Chalk = ChalkT>,\n-{\n-    T::from_chalk(db, chalk)\n-}\n-\n-impl ToChalk for Ty {\n-    type Chalk = chalk_ir::Ty;\n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty {\n-        match self {\n-            Ty::Apply(apply_ty) => chalk_ir::Ty::Apply(apply_ty.to_chalk(db)),\n-            Ty::Param { idx, .. } => {\n-                chalk_ir::PlaceholderIndex { ui: chalk_ir::UniverseIndex::ROOT, idx: idx as usize }\n-                    .to_ty()\n-            }\n-            Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n-            Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n-            Ty::Unknown => unimplemented!(), // TODO turn into placeholder?\n-        }\n-    }\n-    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty) -> Self {\n-        match chalk {\n-            chalk_ir::Ty::Apply(apply_ty) => {\n-                match apply_ty.name {\n-                    // FIXME handle TypeKindId::Trait/Type here\n-                    chalk_ir::TypeName::TypeKindId(_) => Ty::Apply(from_chalk(db, apply_ty)),\n-                    chalk_ir::TypeName::AssociatedType(_) => unimplemented!(),\n-                    chalk_ir::TypeName::Placeholder(idx) => {\n-                        assert_eq!(idx.ui, chalk_ir::UniverseIndex::ROOT);\n-                        Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n-                    }\n-                }\n-            }\n-            chalk_ir::Ty::Projection(_) => unimplemented!(),\n-            chalk_ir::Ty::UnselectedProjection(_) => unimplemented!(),\n-            chalk_ir::Ty::ForAll(_) => unimplemented!(),\n-            chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n-            chalk_ir::Ty::InferenceVar(_iv) => panic!(\"unexpected chalk infer ty\"),\n-        }\n-    }\n-}\n-\n-impl ToChalk for ApplicationTy {\n-    type Chalk = chalk_ir::ApplicationTy;\n-\n-    fn to_chalk(self: ApplicationTy, db: &impl HirDatabase) -> chalk_ir::ApplicationTy {\n-        let struct_id = self.ctor.to_chalk(db);\n-        let name = chalk_ir::TypeName::TypeKindId(struct_id.into());\n-        let parameters = self.parameters.to_chalk(db);\n-        chalk_ir::ApplicationTy { name, parameters }\n-    }\n-\n-    fn from_chalk(db: &impl HirDatabase, apply_ty: chalk_ir::ApplicationTy) -> ApplicationTy {\n-        let ctor = match apply_ty.name {\n-            chalk_ir::TypeName::TypeKindId(chalk_ir::TypeKindId::StructId(struct_id)) => {\n-                from_chalk(db, struct_id)\n-            }\n-            chalk_ir::TypeName::TypeKindId(_) => unimplemented!(),\n-            chalk_ir::TypeName::Placeholder(_) => unimplemented!(),\n-            chalk_ir::TypeName::AssociatedType(_) => unimplemented!(),\n-        };\n-        let parameters = from_chalk(db, apply_ty.parameters);\n-        ApplicationTy { ctor, parameters }\n-    }\n-}\n-\n-impl ToChalk for Substs {\n-    type Chalk = Vec<chalk_ir::Parameter>;\n-\n-    fn to_chalk(self, db: &impl HirDatabase) -> Vec<chalk_ir::Parameter> {\n-        self.iter().map(|ty| ty.clone().to_chalk(db).cast()).collect()\n-    }\n-\n-    fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter>) -> Substs {\n-        parameters\n-            .into_iter()\n-            .map(|p| match p {\n-                chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n-                chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n-            })\n-            .collect::<Vec<_>>()\n-            .into()\n-    }\n-}\n-\n-impl ToChalk for TraitRef {\n-    type Chalk = chalk_ir::TraitRef;\n-\n-    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef {\n-        let trait_id = self.trait_.to_chalk(db);\n-        let parameters = self.substs.to_chalk(db);\n-        chalk_ir::TraitRef { trait_id, parameters }\n-    }\n-\n-    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef) -> Self {\n-        let trait_ = from_chalk(db, trait_ref.trait_id);\n-        let substs = from_chalk(db, trait_ref.parameters);\n-        TraitRef { trait_, substs }\n-    }\n-}\n-\n-impl ToChalk for Trait {\n-    type Chalk = TraitId;\n-\n-    fn to_chalk(self, _db: &impl HirDatabase) -> TraitId {\n-        self.id.into()\n-    }\n-\n-    fn from_chalk(_db: &impl HirDatabase, trait_id: TraitId) -> Trait {\n-        Trait { id: trait_id.into() }\n-    }\n-}\n-\n-impl ToChalk for TypeCtor {\n-    type Chalk = chalk_ir::StructId;\n-\n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::StructId {\n-        db.intern_type_ctor(self).into()\n-    }\n-\n-    fn from_chalk(db: &impl HirDatabase, struct_id: chalk_ir::StructId) -> TypeCtor {\n-        db.lookup_intern_type_ctor(struct_id.into())\n-    }\n-}\n-\n-impl ToChalk for ImplBlock {\n-    type Chalk = chalk_ir::ImplId;\n-\n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ImplId {\n-        db.intern_impl_block(self).into()\n-    }\n-\n-    fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> ImplBlock {\n-        db.lookup_intern_impl_block(impl_id.into())\n-    }\n-}\n-\n-fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n-    chalk_ir::Binders {\n-        value,\n-        binders: std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n-    }\n-}\n-\n-impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n-where\n-    DB: HirDatabase,\n-{\n-    fn associated_ty_data(&self, _ty: TypeId) -> Arc<AssociatedTyDatum> {\n-        unimplemented!()\n-    }\n-    fn trait_datum(&self, trait_id: TraitId) -> Arc<TraitDatum> {\n-        eprintln!(\"trait_datum {:?}\", trait_id);\n-        let trait_: Trait = from_chalk(self.db, trait_id);\n-        let generic_params = trait_.generic_params(self.db);\n-        let bound_vars = Substs::bound_vars(&generic_params);\n-        let trait_ref = trait_.trait_ref(self.db).subst(&bound_vars).to_chalk(self.db);\n-        let flags = chalk_rust_ir::TraitFlags {\n-            // FIXME set these flags correctly\n-            auto: false,\n-            marker: false,\n-            upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n-            fundamental: false,\n-        };\n-        let where_clauses = Vec::new(); // FIXME add where clauses\n-        let trait_datum_bound = chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags };\n-        let trait_datum = TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()) };\n-        Arc::new(trait_datum)\n-    }\n-    fn struct_datum(&self, struct_id: StructId) -> Arc<StructDatum> {\n-        eprintln!(\"struct_datum {:?}\", struct_id);\n-        let type_ctor = from_chalk(self.db, struct_id);\n-        // TODO might be nicer if we can create a fake GenericParams for the TypeCtor\n-        let (num_params, upstream) = match type_ctor {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n-            | TypeCtor::Never\n-            | TypeCtor::Str => (0, true),\n-            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => (1, true),\n-            TypeCtor::FnPtr | TypeCtor::Tuple => unimplemented!(), // FIXME tuples and FnPtr are currently variadic... we need to make the parameter number explicit\n-            TypeCtor::FnDef(_) => unimplemented!(),\n-            TypeCtor::Adt(adt) => {\n-                let generic_params = adt.generic_params(self.db);\n-                (\n-                    generic_params.count_params_including_parent(),\n-                    adt.krate(self.db) != Some(self.krate),\n-                )\n-            }\n-        };\n-        let flags = chalk_rust_ir::StructFlags {\n-            upstream,\n-            // FIXME set fundamental flag correctly\n-            fundamental: false,\n-        };\n-        let where_clauses = Vec::new(); // FIXME add where clauses\n-        let ty = ApplicationTy {\n-            ctor: type_ctor,\n-            parameters: (0..num_params).map(|i| Ty::Bound(i as u32)).collect::<Vec<_>>().into(),\n-        };\n-        let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n-            self_ty: ty.to_chalk(self.db),\n-            fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n-            where_clauses,\n-            flags,\n-        };\n-        let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n-        Arc::new(struct_datum)\n-    }\n-    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n-        eprintln!(\"impl_datum {:?}\", impl_id);\n-        let impl_block: ImplBlock = from_chalk(self.db, impl_id);\n-        let generic_params = impl_block.generic_params(self.db);\n-        let bound_vars = Substs::bound_vars(&generic_params);\n-        let trait_ref = impl_block\n-            .target_trait_ref(self.db)\n-            .expect(\"FIXME handle unresolved impl block trait ref\")\n-            .subst(&bound_vars);\n-        let impl_type = if impl_block.module().krate(self.db) == Some(self.krate) {\n-            chalk_rust_ir::ImplType::Local\n-        } else {\n-            chalk_rust_ir::ImplType::External\n-        };\n-        let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n-            // FIXME handle negative impls (impl !Sync for Foo)\n-            trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref.to_chalk(self.db)),\n-            where_clauses: Vec::new(),        // FIXME add where clauses\n-            associated_ty_values: Vec::new(), // FIXME add associated type values\n-            impl_type,\n-        };\n-        let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, bound_vars.len()) };\n-        Arc::new(impl_datum)\n-    }\n-    fn impls_for_trait(&self, trait_id: TraitId) -> Vec<ImplId> {\n-        eprintln!(\"impls_for_trait {:?}\", trait_id);\n-        let trait_ = from_chalk(self.db, trait_id);\n-        self.db\n-            .impls_for_trait(self.krate, trait_)\n-            .iter()\n-            // FIXME temporary hack -- as long as we're not lowering where clauses\n-            // correctly, ignore impls with them completely so as to not treat\n-            // impl<T> Trait for T where T: ... as a blanket impl on all types\n-            .filter(|impl_block| impl_block.generic_params(self.db).where_predicates.is_empty())\n-            .map(|impl_block| impl_block.to_chalk(self.db))\n-            .collect()\n-    }\n-    fn impl_provided_for(&self, auto_trait_id: TraitId, struct_id: StructId) -> bool {\n-        eprintln!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, struct_id);\n-        false // FIXME\n-    }\n-    fn type_name(&self, _id: TypeKindId) -> Identifier {\n-        unimplemented!()\n-    }\n-    fn split_projection<'p>(\n-        &self,\n-        projection: &'p ProjectionTy,\n-    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter], &'p [Parameter]) {\n-        eprintln!(\"split_projection {:?}\", projection);\n-        unimplemented!()\n-    }\n-}\n-\n pub(crate) fn solver(_db: &impl HirDatabase, _krate: Crate) -> Arc<Mutex<chalk_solve::Solver>> {\n     // krate parameter is just so we cache a unique solver per crate\n     let solver_choice = chalk_solve::SolverChoice::SLG { max_size: 10 };"}, {"sha": "36cc52704527162f644cccc791d66be394c30e86", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/c8a643f090ed88289c7bc17b48078e39b932c8a4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a643f090ed88289c7bc17b48078e39b932c8a4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=c8a643f090ed88289c7bc17b48078e39b932c8a4", "patch": "@@ -0,0 +1,327 @@\n+//! Conversion code from/to Chalk.\n+use std::sync::Arc;\n+\n+use chalk_ir::{TypeId, ImplId, TypeKindId, ProjectionTy, Parameter, Identifier, cast::Cast, PlaceholderIndex, UniverseIndex, TypeName};\n+use chalk_rust_ir::{AssociatedTyDatum, TraitDatum, StructDatum, ImplDatum};\n+\n+use ra_db::salsa::{InternId, InternKey};\n+\n+use crate::{\n+    Trait, HasGenericParams, ImplBlock,\n+    db::HirDatabase,\n+    ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs},\n+};\n+use super::ChalkContext;\n+\n+pub(super) trait ToChalk {\n+    type Chalk;\n+    fn to_chalk(self, db: &impl HirDatabase) -> Self::Chalk;\n+    fn from_chalk(db: &impl HirDatabase, chalk: Self::Chalk) -> Self;\n+}\n+\n+pub(super) fn from_chalk<T, ChalkT>(db: &impl HirDatabase, chalk: ChalkT) -> T\n+where\n+    T: ToChalk<Chalk = ChalkT>,\n+{\n+    T::from_chalk(db, chalk)\n+}\n+\n+impl ToChalk for Ty {\n+    type Chalk = chalk_ir::Ty;\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty {\n+        match self {\n+            Ty::Apply(apply_ty) => chalk_ir::Ty::Apply(apply_ty.to_chalk(db)),\n+            Ty::Param { idx, .. } => {\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }\n+                    .to_ty()\n+            }\n+            Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n+            Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n+            Ty::Unknown => unimplemented!(), // TODO turn into placeholder?\n+        }\n+    }\n+    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty) -> Self {\n+        match chalk {\n+            chalk_ir::Ty::Apply(apply_ty) => {\n+                match apply_ty.name {\n+                    // FIXME handle TypeKindId::Trait/Type here\n+                    TypeName::TypeKindId(_) => Ty::Apply(from_chalk(db, apply_ty)),\n+                    TypeName::AssociatedType(_) => unimplemented!(),\n+                    TypeName::Placeholder(idx) => {\n+                        assert_eq!(idx.ui, UniverseIndex::ROOT);\n+                        Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n+                    }\n+                }\n+            }\n+            chalk_ir::Ty::Projection(_) => unimplemented!(),\n+            chalk_ir::Ty::UnselectedProjection(_) => unimplemented!(),\n+            chalk_ir::Ty::ForAll(_) => unimplemented!(),\n+            chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n+            chalk_ir::Ty::InferenceVar(_iv) => panic!(\"unexpected chalk infer ty\"),\n+        }\n+    }\n+}\n+\n+impl ToChalk for ApplicationTy {\n+    type Chalk = chalk_ir::ApplicationTy;\n+\n+    fn to_chalk(self: ApplicationTy, db: &impl HirDatabase) -> chalk_ir::ApplicationTy {\n+        let struct_id = self.ctor.to_chalk(db);\n+        let name = TypeName::TypeKindId(struct_id.into());\n+        let parameters = self.parameters.to_chalk(db);\n+        chalk_ir::ApplicationTy { name, parameters }\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, apply_ty: chalk_ir::ApplicationTy) -> ApplicationTy {\n+        let ctor = match apply_ty.name {\n+            TypeName::TypeKindId(TypeKindId::StructId(struct_id)) => {\n+                from_chalk(db, struct_id)\n+            }\n+            TypeName::TypeKindId(_) => unimplemented!(),\n+            TypeName::Placeholder(_) => unimplemented!(),\n+            TypeName::AssociatedType(_) => unimplemented!(),\n+        };\n+        let parameters = from_chalk(db, apply_ty.parameters);\n+        ApplicationTy { ctor, parameters }\n+    }\n+}\n+\n+impl ToChalk for Substs {\n+    type Chalk = Vec<chalk_ir::Parameter>;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter> {\n+        self.iter().map(|ty| ty.clone().to_chalk(db).cast()).collect()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter>) -> Substs {\n+        parameters\n+            .into_iter()\n+            .map(|p| match p {\n+                chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n+                chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n+            })\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+}\n+\n+impl ToChalk for TraitRef {\n+    type Chalk = chalk_ir::TraitRef;\n+\n+    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef {\n+        let trait_id = self.trait_.to_chalk(db);\n+        let parameters = self.substs.to_chalk(db);\n+        chalk_ir::TraitRef { trait_id, parameters }\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef) -> Self {\n+        let trait_ = from_chalk(db, trait_ref.trait_id);\n+        let substs = from_chalk(db, trait_ref.parameters);\n+        TraitRef { trait_, substs }\n+    }\n+}\n+\n+impl ToChalk for Trait {\n+    type Chalk = chalk_ir::TraitId;\n+\n+    fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TraitId {\n+        self.id.into()\n+    }\n+\n+    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> Trait {\n+        Trait { id: trait_id.into() }\n+    }\n+}\n+\n+impl ToChalk for TypeCtor {\n+    type Chalk = chalk_ir::StructId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::StructId {\n+        db.intern_type_ctor(self).into()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, struct_id: chalk_ir::StructId) -> TypeCtor {\n+        db.lookup_intern_type_ctor(struct_id.into())\n+    }\n+}\n+\n+impl ToChalk for ImplBlock {\n+    type Chalk = chalk_ir::ImplId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ImplId {\n+        db.intern_impl_block(self).into()\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> ImplBlock {\n+        db.lookup_intern_impl_block(impl_id.into())\n+    }\n+}\n+\n+fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n+    chalk_ir::Binders {\n+        value,\n+        binders: std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n+    }\n+}\n+\n+impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n+where\n+    DB: HirDatabase,\n+{\n+    fn associated_ty_data(&self, _ty: TypeId) -> Arc<AssociatedTyDatum> {\n+        unimplemented!()\n+    }\n+    fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum> {\n+        eprintln!(\"trait_datum {:?}\", trait_id);\n+        let trait_: Trait = from_chalk(self.db, trait_id);\n+        let generic_params = trait_.generic_params(self.db);\n+        let bound_vars = Substs::bound_vars(&generic_params);\n+        let trait_ref = trait_.trait_ref(self.db).subst(&bound_vars).to_chalk(self.db);\n+        let flags = chalk_rust_ir::TraitFlags {\n+            // FIXME set these flags correctly\n+            auto: false,\n+            marker: false,\n+            upstream: trait_.module(self.db).krate(self.db) != Some(self.krate),\n+            fundamental: false,\n+        };\n+        let where_clauses = Vec::new(); // FIXME add where clauses\n+        let trait_datum_bound = chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags };\n+        let trait_datum = TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()) };\n+        Arc::new(trait_datum)\n+    }\n+    fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum> {\n+        eprintln!(\"struct_datum {:?}\", struct_id);\n+        let type_ctor = from_chalk(self.db, struct_id);\n+        // TODO might be nicer if we can create a fake GenericParams for the TypeCtor\n+        let (num_params, upstream) = match type_ctor {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Never\n+            | TypeCtor::Str => (0, true),\n+            TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => (1, true),\n+            TypeCtor::FnPtr | TypeCtor::Tuple => unimplemented!(), // FIXME tuples and FnPtr are currently variadic... we need to make the parameter number explicit\n+            TypeCtor::FnDef(_) => unimplemented!(),\n+            TypeCtor::Adt(adt) => {\n+                let generic_params = adt.generic_params(self.db);\n+                (\n+                    generic_params.count_params_including_parent(),\n+                    adt.krate(self.db) != Some(self.krate),\n+                )\n+            }\n+        };\n+        let flags = chalk_rust_ir::StructFlags {\n+            upstream,\n+            // FIXME set fundamental flag correctly\n+            fundamental: false,\n+        };\n+        let where_clauses = Vec::new(); // FIXME add where clauses\n+        let ty = ApplicationTy {\n+            ctor: type_ctor,\n+            parameters: (0..num_params).map(|i| Ty::Bound(i as u32)).collect::<Vec<_>>().into(),\n+        };\n+        let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n+            self_ty: ty.to_chalk(self.db),\n+            fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n+            where_clauses,\n+            flags,\n+        };\n+        let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n+        Arc::new(struct_datum)\n+    }\n+    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n+        eprintln!(\"impl_datum {:?}\", impl_id);\n+        let impl_block: ImplBlock = from_chalk(self.db, impl_id);\n+        let generic_params = impl_block.generic_params(self.db);\n+        let bound_vars = Substs::bound_vars(&generic_params);\n+        let trait_ref = impl_block\n+            .target_trait_ref(self.db)\n+            .expect(\"FIXME handle unresolved impl block trait ref\")\n+            .subst(&bound_vars);\n+        let impl_type = if impl_block.module().krate(self.db) == Some(self.krate) {\n+            chalk_rust_ir::ImplType::Local\n+        } else {\n+            chalk_rust_ir::ImplType::External\n+        };\n+        let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n+            // FIXME handle negative impls (impl !Sync for Foo)\n+            trait_ref: chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref.to_chalk(self.db)),\n+            where_clauses: Vec::new(),        // FIXME add where clauses\n+            associated_ty_values: Vec::new(), // FIXME add associated type values\n+            impl_type,\n+        };\n+        let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, bound_vars.len()) };\n+        Arc::new(impl_datum)\n+    }\n+    fn impls_for_trait(&self, trait_id: chalk_ir::TraitId) -> Vec<ImplId> {\n+        eprintln!(\"impls_for_trait {:?}\", trait_id);\n+        let trait_ = from_chalk(self.db, trait_id);\n+        self.db\n+            .impls_for_trait(self.krate, trait_)\n+            .iter()\n+            // FIXME temporary hack -- as long as we're not lowering where clauses\n+            // correctly, ignore impls with them completely so as to not treat\n+            // impl<T> Trait for T where T: ... as a blanket impl on all types\n+            .filter(|impl_block| impl_block.generic_params(self.db).where_predicates.is_empty())\n+            .map(|impl_block| impl_block.to_chalk(self.db))\n+            .collect()\n+    }\n+    fn impl_provided_for(&self, auto_trait_id: chalk_ir::TraitId, struct_id: chalk_ir::StructId) -> bool {\n+        eprintln!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, struct_id);\n+        false // FIXME\n+    }\n+    fn type_name(&self, _id: TypeKindId) -> Identifier {\n+        unimplemented!()\n+    }\n+    fn split_projection<'p>(\n+        &self,\n+        projection: &'p ProjectionTy,\n+    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter], &'p [Parameter]) {\n+        eprintln!(\"split_projection {:?}\", projection);\n+        unimplemented!()\n+    }\n+}\n+\n+fn id_from_chalk<T: InternKey>(chalk_id: chalk_ir::RawId) -> T {\n+    T::from_intern_id(InternId::from(chalk_id.index))\n+}\n+fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n+    chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n+}\n+\n+impl From<chalk_ir::TraitId> for crate::ids::TraitId {\n+    fn from(trait_id: chalk_ir::TraitId) -> Self {\n+        id_from_chalk(trait_id.0)\n+    }\n+}\n+\n+impl From<crate::ids::TraitId> for chalk_ir::TraitId {\n+    fn from(trait_id: crate::ids::TraitId) -> Self {\n+        chalk_ir::TraitId(id_to_chalk(trait_id))\n+    }\n+}\n+\n+impl From<chalk_ir::StructId> for crate::ids::TypeCtorId {\n+    fn from(struct_id: chalk_ir::StructId) -> Self {\n+        id_from_chalk(struct_id.0)\n+    }\n+}\n+\n+impl From<crate::ids::TypeCtorId> for chalk_ir::StructId {\n+    fn from(type_ctor_id: crate::ids::TypeCtorId) -> Self {\n+        chalk_ir::StructId(id_to_chalk(type_ctor_id))\n+    }\n+}\n+\n+impl From<chalk_ir::ImplId> for crate::ids::GlobalImplId {\n+    fn from(impl_id: chalk_ir::ImplId) -> Self {\n+        id_from_chalk(impl_id.0)\n+    }\n+}\n+\n+impl From<crate::ids::GlobalImplId> for chalk_ir::ImplId {\n+    fn from(impl_id: crate::ids::GlobalImplId) -> Self {\n+        chalk_ir::ImplId(id_to_chalk(impl_id))\n+    }\n+}"}]}