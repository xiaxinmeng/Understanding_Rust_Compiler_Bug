{"sha": "08f0f7c54afdce576525ff37c5af871ef3a952e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZjBmN2M1NGFmZGNlNTc2NTI1ZmYzN2M1YWY4NzFlZjNhOTUyZTA=", "commit": {"author": {"name": "petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-07-07T15:20:26Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-08-10T21:32:07Z"}, "message": "Substitute private type aliases in rustdoc", "tree": {"sha": "6003923f89c92796070716530b3d5f353c4275d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6003923f89c92796070716530b3d5f353c4275d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08f0f7c54afdce576525ff37c5af871ef3a952e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08f0f7c54afdce576525ff37c5af871ef3a952e0", "html_url": "https://github.com/rust-lang/rust/commit/08f0f7c54afdce576525ff37c5af871ef3a952e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08f0f7c54afdce576525ff37c5af871ef3a952e0/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7db9e88bfa063ce9d354b304135a1a0c5a2b1f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7db9e88bfa063ce9d354b304135a1a0c5a2b1f5", "html_url": "https://github.com/rust-lang/rust/commit/b7db9e88bfa063ce9d354b304135a1a0c5a2b1f5"}], "stats": {"total": 112, "additions": 110, "deletions": 2}, "files": [{"sha": "93fd36d37af3ce8b4be43df3e396a380a467eff3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08f0f7c54afdce576525ff37c5af871ef3a952e0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f0f7c54afdce576525ff37c5af871ef3a952e0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=08f0f7c54afdce576525ff37c5af871ef3a952e0", "patch": "@@ -1744,6 +1744,7 @@ impl<'a> Resolver<'a> {\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(space, index as u32, def_id, name);\n                     function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n+                    self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }"}, {"sha": "26ea4890b30bf1ef52339e66f118d9ba023a7375", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/08f0f7c54afdce576525ff37c5af871ef3a952e0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f0f7c54afdce576525ff37c5af871ef3a952e0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=08f0f7c54afdce576525ff37c5af871ef3a952e0", "patch": "@@ -36,8 +36,10 @@ use syntax_pos::{self, DUMMY_SP, Pos};\n use rustc_trans::back::link;\n use rustc::middle::cstore;\n use rustc::middle::privacy::AccessLevels;\n+use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n use rustc::ty::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::ty;\n@@ -1636,6 +1638,43 @@ impl PrimitiveType {\n     }\n }\n \n+\n+// Poor man's type parameter substitution at HIR level.\n+// Used to replace private type aliases in public signatures with their aliased types.\n+struct SubstAlias<'a, 'tcx: 'a> {\n+    tcx: &'a ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    // Table type parameter definition -> substituted type\n+    ty_substs: HashMap<Def, hir::Ty>,\n+    // Table node id of lifetime parameter definition -> substituted lifetime\n+    lt_substs: HashMap<ast::NodeId, hir::Lifetime>,\n+}\n+\n+impl<'a, 'tcx: 'a, 'b: 'tcx> Folder for SubstAlias<'a, 'tcx> {\n+    fn fold_ty(&mut self, ty: P<hir::Ty>) -> P<hir::Ty> {\n+        if let hir::TyPath(..) = ty.node {\n+            let def = self.tcx.expect_def(ty.id);\n+            if let Some(new_ty) = self.ty_substs.get(&def).cloned() {\n+                return P(new_ty);\n+            }\n+        }\n+        hir::fold::noop_fold_ty(ty, self)\n+    }\n+    fn fold_lifetime(&mut self, lt: hir::Lifetime) -> hir::Lifetime {\n+        let def = self.tcx.named_region_map.defs.get(&lt.id).cloned();\n+        match def {\n+            Some(DefEarlyBoundRegion(_, _, node_id)) |\n+            Some(DefLateBoundRegion(_, node_id)) |\n+            Some(DefFreeRegion(_, node_id)) => {\n+                if let Some(lt) = self.lt_substs.get(&node_id).cloned() {\n+                    return lt;\n+                }\n+            }\n+            _ => {}\n+        }\n+        hir::fold::noop_fold_lifetime(lt, self)\n+    }\n+}\n+\n impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use rustc::hir::*;\n@@ -1665,8 +1704,46 @@ impl Clean<Type> for hir::Ty {\n                 FixedVector(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(None, ref p) => {\n-                resolve_type(cx, p.clean(cx), self.id)\n+            TyPath(None, ref path) => {\n+                if let Some(tcx) = cx.tcx_opt() {\n+                    // Substitute private type aliases\n+                    let def = tcx.expect_def(self.id);\n+                    if let Def::TyAlias(def_id) = def {\n+                        if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+                            if !cx.access_levels.borrow().is_exported(def_id) {\n+                                let item = tcx.map.expect_item(node_id);\n+                                if let hir::ItemTy(ref ty, ref generics) = item.node {\n+                                    let provided_params = &path.segments.last().unwrap().parameters;\n+                                    let mut ty_substs = HashMap::new();\n+                                    let mut lt_substs = HashMap::new();\n+                                    for (i, ty_param) in generics.ty_params.iter().enumerate() {\n+                                        let ty_param_def = tcx.expect_def(ty_param.id);\n+                                        if let Some(ty) = provided_params.types().get(i).cloned()\n+                                                                                        .cloned() {\n+                                            ty_substs.insert(ty_param_def, ty.unwrap());\n+                                        } else if let Some(default) = ty_param.default.clone() {\n+                                            ty_substs.insert(ty_param_def, default.unwrap());\n+                                        }\n+                                    }\n+                                    for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n+                                        if let Some(lt) = provided_params.lifetimes().get(i)\n+                                                                                     .cloned()\n+                                                                                     .cloned() {\n+                                            lt_substs.insert(lt_param.lifetime.id, lt);\n+                                        }\n+                                    }\n+                                    let mut subst_alias = SubstAlias {\n+                                        tcx: &tcx,\n+                                        ty_substs: ty_substs,\n+                                        lt_substs: lt_substs\n+                                    };\n+                                    return subst_alias.fold_ty(ty.clone()).clean(cx);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                resolve_type(cx, path.clean(cx), self.id)\n             }\n             TyPath(Some(ref qself), ref p) => {\n                 let mut segments: Vec<_> = p.segments.clone().into();"}, {"sha": "65e3e023830948f8d5f262089a4bc95e5cd7c0f3", "filename": "src/test/rustdoc/private-type-alias.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/08f0f7c54afdce576525ff37c5af871ef3a952e0/src%2Ftest%2Frustdoc%2Fprivate-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f0f7c54afdce576525ff37c5af871ef3a952e0/src%2Ftest%2Frustdoc%2Fprivate-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprivate-type-alias.rs?ref=08f0f7c54afdce576525ff37c5af871ef3a952e0", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type MyResultPriv<T> = Result<T, u16>;\n+pub type MyResultPub<T> = Result<T, u64>;\n+\n+// @has private_type_alias/fn.get_result_priv.html '//pre' 'Result<u8, u16>'\n+pub fn get_result_priv() -> MyResultPriv<u8> {\n+    panic!();\n+}\n+\n+// @has private_type_alias/fn.get_result_pub.html '//pre' 'MyResultPub<u32>'\n+pub fn get_result_pub() -> MyResultPub<u32> {\n+    panic!();\n+}\n+\n+\n+type MyLifetimePriv<'a> = &'a isize;\n+\n+// @has private_type_alias/fn.get_lifetime_priv.html '//pre' \"&'static isize\"\n+pub fn get_lifetime_priv() -> MyLifetimePriv<'static> {\n+    panic!();\n+}"}]}