{"sha": "8d997fba1a035b20d208c588cb267385dea74f6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOTk3ZmJhMWEwMzViMjBkMjA4YzU4OGNiMjY3Mzg1ZGVhNzRmNmM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:23Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:58Z"}, "message": "std: put FileMode/Access->whence-mask in uvio, open/unlink as fns in file::", "tree": {"sha": "6e0defb476a6fd716ab0f28ba51a95beb402c515", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e0defb476a6fd716ab0f28ba51a95beb402c515"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d997fba1a035b20d208c588cb267385dea74f6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d997fba1a035b20d208c588cb267385dea74f6c", "html_url": "https://github.com/rust-lang/rust/commit/8d997fba1a035b20d208c588cb267385dea74f6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d997fba1a035b20d208c588cb267385dea74f6c/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6311856bf42828e3c502a28b414586badb1192c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6311856bf42828e3c502a28b414586badb1192c8", "html_url": "https://github.com/rust-lang/rust/commit/6311856bf42828e3c502a28b414586badb1192c8"}], "stats": {"total": 209, "additions": 109, "deletions": 100}, "files": [{"sha": "65db76d5ef768d1a1c17cb6f4db05270dce8e91b", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 51, "deletions": 89, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/8d997fba1a035b20d208c588cb267385dea74f6c/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d997fba1a035b20d208c588cb267385dea74f6c/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=8d997fba1a035b20d208c588cb267385dea74f6c", "patch": "@@ -13,34 +13,45 @@ use super::support::PathLike;\n use super::{Reader, Writer, Seek};\n use super::{SeekSet, SeekCur, SeekEnd, SeekStyle};\n use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n-use rt::io::{io_error, read_error, EndOfFile};\n+use rt::io::{io_error, read_error, EndOfFile,\n+             FileMode, FileAccess, Open, Read, Create, ReadWrite};\n use rt::local::Local;\n use rt::test::*;\n-use libc::{O_RDWR, O_RDONLY, O_WRONLY, S_IWUSR, S_IRUSR,\n-           O_CREAT, O_TRUNC, O_APPEND};\n \n-/// Instructions on how to open a file and return a `FileStream`.\n-enum FileMode {\n-    /// Opens an existing file. IoError if file does not exist.\n-    Open,\n-    /// Creates a file. IoError if file exists.\n-    Create,\n-    /// Opens an existing file or creates a new one.\n-    OpenOrCreate,\n-    /// Opens an existing file or creates a new one, positioned at EOF.\n-    Append,\n-    /// Opens an existing file, truncating it to 0 bytes.\n-    Truncate,\n-    /// Opens an existing file or creates a new one, truncating it to 0 bytes.\n-    CreateOrTruncate,\n+/// Open a file for reading/writing, as indicated by `path`.\n+pub fn open<P: PathLike>(path: &P,\n+                         mode: FileMode,\n+                         access: FileAccess\n+                        ) -> Option<FileStream> {\n+    let open_result = unsafe {\n+        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        (*io).fs_open(path, mode, access)\n+    };\n+    match open_result {\n+        Ok(fd) => Some(FileStream {\n+            fd: fd,\n+            last_nread: -1\n+        }),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n }\n \n-/// How should the file be opened? `FileStream`s opened with `Read` will\n-/// raise an `io_error` condition if written to.\n-enum FileAccess {\n-    Read,\n-    Write,\n-    ReadWrite\n+/// Unlink (remove) a file from the filesystem, as indicated\n+/// by `path`.\n+pub fn unlink<P: PathLike>(path: &P) {\n+    let unlink_result = unsafe {\n+        let io = Local::unsafe_borrow::<IoFactoryObject>();\n+        (*io).fs_unlink(path)\n+    };\n+    match unlink_result {\n+        Ok(_) => (),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+        }\n+    }\n }\n \n /// Abstraction representing *positional* access to a file. In this case,\n@@ -61,55 +72,6 @@ pub struct FileStream {\n }\n \n impl FileStream {\n-    pub fn open<P: PathLike>(path: &P,\n-                             mode: FileMode,\n-                             access: FileAccess\n-                            ) -> Option<FileStream> {\n-        let open_result = unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n-            let mut flags = match mode {\n-                Open => 0,\n-                Create => O_CREAT,\n-                OpenOrCreate => O_CREAT,\n-                Append => O_APPEND,\n-                Truncate => O_TRUNC,\n-                CreateOrTruncate => O_TRUNC | O_CREAT\n-            };\n-            flags = match access {\n-                Read => flags | O_RDONLY,\n-                Write => flags | O_WRONLY,\n-                ReadWrite => flags | O_RDWR\n-            };\n-            let create_mode = match mode {\n-                Create|OpenOrCreate|CreateOrTruncate =>\n-                    S_IRUSR | S_IWUSR,\n-                _ => 0\n-            };\n-            (*io).fs_open(path, flags as int, create_mode as int)\n-        };\n-        match open_result {\n-            Ok(fd) => Some(FileStream {\n-                fd: fd,\n-                last_nread: -1\n-            }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    }\n-    fn unlink<P: PathLike>(path: &P) {\n-        let unlink_result = unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n-            (*io).fs_unlink(path)\n-        };\n-        match unlink_result {\n-            Ok(_) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n }\n \n impl Reader for FileStream {\n@@ -188,20 +150,20 @@ fn file_test_smoke_test_impl() {\n         let message = \"it's alright. have a good time\";\n         let filename = &Path(\"./tmp/file_rt_io_file_test.txt\");\n         {\n-            let mut write_stream = FileStream::open(filename, Create, ReadWrite).unwrap();\n+            let mut write_stream = open(filename, Create, ReadWrite).unwrap();\n             write_stream.write(message.as_bytes());\n         }\n         {\n             use str;\n-            let mut read_stream = FileStream::open(filename, Open, Read).unwrap();\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n             let mut read_buf = [0, .. 1028];\n             let read_str = match read_stream.read(read_buf).unwrap() {\n                 -1|0 => fail!(\"shouldn't happen\"),\n                 n => str::from_bytes(read_buf.slice_to(n))\n             };\n             assert!(read_str == message.to_owned());\n         }\n-        FileStream::unlink(filename);\n+        unlink(filename);\n     }\n }\n \n@@ -217,7 +179,7 @@ fn file_test_invalid_path_opened_without_create_should_raise_condition_impl() {\n         do io_error::cond.trap(|_| {\n             called = true;\n         }).inside {\n-            let result = FileStream::open(filename, Open, Read);\n+            let result = open(filename, Open, Read);\n             assert!(result.is_none());\n         }\n         assert!(called);\n@@ -235,7 +197,7 @@ fn file_test_unlinking_invalid_path_should_raise_condition_impl() {\n         do io_error::cond.trap(|_| {\n             called = true;\n         }).inside {\n-            FileStream::unlink(filename);\n+            unlink(filename);\n         }\n         assert!(called);\n     }\n@@ -252,11 +214,11 @@ fn file_test_io_non_positional_read_impl() {\n         let mut read_mem = [0, .. 8];\n         let filename = &Path(\"./tmp/file_rt_io_file_test_positional.txt\");\n         {\n-            let mut rw_stream = FileStream::open(filename, Create, ReadWrite).unwrap();\n+            let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n             rw_stream.write(message.as_bytes());\n         }\n         {\n-            let mut read_stream = FileStream::open(filename, Open, Read).unwrap();\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n             {\n                 let read_buf = read_mem.mut_slice(0, 4);\n                 read_stream.read(read_buf);\n@@ -266,7 +228,7 @@ fn file_test_io_non_positional_read_impl() {\n                 read_stream.read(read_buf);\n             }\n         }\n-        FileStream::unlink(filename);\n+        unlink(filename);\n         let read_str = str::from_bytes(read_mem);\n         assert!(read_str == message.to_owned());\n     }\n@@ -287,17 +249,17 @@ fn file_test_io_seeking_impl() {\n         let mut tell_pos_post_read;\n         let filename = &Path(\"./tmp/file_rt_io_file_test_seeking.txt\");\n         {\n-            let mut rw_stream = FileStream::open(filename, Create, ReadWrite).unwrap();\n+            let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n             rw_stream.write(message.as_bytes());\n         }\n         {\n-            let mut read_stream = FileStream::open(filename, Open, Read).unwrap();\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n             read_stream.seek(set_cursor as i64, SeekSet);\n             tell_pos_pre_read = read_stream.tell();\n             read_stream.read(read_mem);\n             tell_pos_post_read = read_stream.tell();\n         }\n-        FileStream::unlink(filename);\n+        unlink(filename);\n         let read_str = str::from_bytes(read_mem);\n         assert!(read_str == message.slice(4, 8).to_owned());\n         assert!(tell_pos_pre_read == set_cursor);\n@@ -320,16 +282,16 @@ fn file_test_io_seek_and_write_impl() {\n         let mut read_mem = [0, .. 13];\n         let filename = &Path(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n         {\n-            let mut rw_stream = FileStream::open(filename, Create, ReadWrite).unwrap();\n+            let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n             rw_stream.write(initial_msg.as_bytes());\n             rw_stream.seek(seek_idx as i64, SeekSet);\n             rw_stream.write(overwrite_msg.as_bytes());\n         }\n         {\n-            let mut read_stream = FileStream::open(filename, Open, Read).unwrap();\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n             read_stream.read(read_mem);\n         }\n-        FileStream::unlink(filename);\n+        unlink(filename);\n         let read_str = str::from_bytes(read_mem);\n         io::println(fmt!(\"read_str: '%?' final_msg: '%?'\", read_str, final_msg));\n         assert!(read_str == final_msg.to_owned());\n@@ -350,11 +312,11 @@ fn file_test_io_seek_shakedown_impl() {\n         let mut read_mem = [0, .. 4];\n         let filename = &Path(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n         {\n-            let mut rw_stream = FileStream::open(filename, Create, ReadWrite).unwrap();\n+            let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n             rw_stream.write(initial_msg.as_bytes());\n         }\n         {\n-            let mut read_stream = FileStream::open(filename, Open, Read).unwrap();\n+            let mut read_stream = open(filename, Open, Read).unwrap();\n \n             read_stream.seek(-4, SeekEnd);\n             read_stream.read(read_mem);\n@@ -371,7 +333,7 @@ fn file_test_io_seek_shakedown_impl() {\n             let read_str = str::from_bytes(read_mem);\n             assert!(read_str == chunk_one.to_owned());\n         }\n-        FileStream::unlink(filename);\n+        unlink(filename);\n     }\n }\n #[test]"}, {"sha": "116d240308a36c9cabf988df7d4bfe93c6762f53", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8d997fba1a035b20d208c588cb267385dea74f6c/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d997fba1a035b20d208c588cb267385dea74f6c/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=8d997fba1a035b20d208c588cb267385dea74f6c", "patch": "@@ -540,3 +540,27 @@ pub fn placeholder_error() -> IoError {\n         detail: None\n     }\n }\n+\n+/// Instructions on how to open a file and return a `FileStream`.\n+pub enum FileMode {\n+    /// Opens an existing file. IoError if file does not exist.\n+    Open,\n+    /// Creates a file. IoError if file exists.\n+    Create,\n+    /// Opens an existing file or creates a new one.\n+    OpenOrCreate,\n+    /// Opens an existing file or creates a new one, positioned at EOF.\n+    Append,\n+    /// Opens an existing file, truncating it to 0 bytes.\n+    Truncate,\n+    /// Opens an existing file or creates a new one, truncating it to 0 bytes.\n+    CreateOrTruncate,\n+}\n+\n+/// Access permissions with which the file should be opened.\n+/// `FileStream`s opened with `Read` will raise an `io_error` condition if written to.\n+pub enum FileAccess {\n+    Read,\n+    Write,\n+    ReadWrite\n+}"}, {"sha": "1788b7a04e33446c3e8c04b77671481eed5bea29", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d997fba1a035b20d208c588cb267385dea74f6c/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d997fba1a035b20d208c588cb267385dea74f6c/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=8d997fba1a035b20d208c588cb267385dea74f6c", "patch": "@@ -18,6 +18,7 @@ use rt::uv::uvio;\n use path::Path;\n use super::io::support::PathLike;\n use super::io::{SeekStyle};\n+use super::io::{FileMode, FileAccess};\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n@@ -68,7 +69,7 @@ pub trait IoFactory {\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError>;\n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream;\n-    fn fs_open<P: PathLike>(&mut self, path: &P, flags: int, mode:int)\n+    fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n }"}, {"sha": "b1b5f9f919c3bda1089247d30c72bb417666e3d9", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8d997fba1a035b20d208c588cb267385dea74f6c/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d997fba1a035b20d208c588cb267385dea74f6c/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=8d997fba1a035b20d208c588cb267385dea74f6c", "patch": "@@ -31,7 +31,10 @@ use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use unstable::sync::Exclusive;\n use super::super::io::support::PathLike;\n-use libc::{lseek, c_long};\n+use libc::{lseek, c_long, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n+          S_IRUSR, S_IWUSR};\n+use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n+            CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite};\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -466,8 +469,26 @@ impl IoFactory for UvIoFactory {\n         ~UvFileStream::new(loop_, fd, close_on_drop, home) as ~RtioFileStream\n     }\n \n-    fn fs_open<P: PathLike>(&mut self, path: &P, flags: int, mode: int)\n+    fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError> {\n+        let mut flags = match fm {\n+            Open => 0,\n+            Create => O_CREAT,\n+            OpenOrCreate => O_CREAT,\n+            Append => O_APPEND,\n+            Truncate => O_TRUNC,\n+            CreateOrTruncate => O_TRUNC | O_CREAT\n+        };\n+        flags = match fa {\n+            Read => flags | O_RDONLY,\n+            Write => flags | O_WRONLY,\n+            ReadWrite => flags | O_RDWR\n+        };\n+        let create_mode = match fm {\n+            Create|OpenOrCreate|CreateOrTruncate =>\n+                S_IRUSR | S_IWUSR,\n+            _ => 0\n+        };\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<~RtioFileStream,\n                                            IoError>> = &result_cell;\n@@ -476,7 +497,8 @@ impl IoFactory for UvIoFactory {\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n             let path = path_cell.take();\n-            do file::FsRequest::open(self.uv_loop(), path, flags, mode) |req,err| {\n+            do file::FsRequest::open(self.uv_loop(), path, flags as int, create_mode as int)\n+                  |req,err| {\n                 if err.is_none() {\n                     let loop_ = Loop {handle: req.get_loop().native_handle()};\n                     let home = get_handle_to_current_scheduler!();\n@@ -1699,26 +1721,26 @@ fn test_timer_sleep_simple() {\n }\n \n fn file_test_uvio_full_simple_impl() {\n-    use libc::{O_CREAT, O_RDWR, O_RDONLY,\n-               S_IWUSR, S_IRUSR};\n     use str::StrSlice; // why does this have to be explicitly imported to work?\n                        // compiler was complaining about no trait for str that\n                        // does .as_bytes() ..\n     use path::Path;\n+    use rt::io::{Open, Create, ReadWrite, Read};\n     unsafe {\n         let io = Local::unsafe_borrow::<IoFactoryObject>();\n-        let create_flags = O_RDWR | O_CREAT;\n-        let ro_flags = O_RDONLY;\n         let write_val = \"hello uvio!\";\n-        let mode = S_IWUSR | S_IRUSR;\n         let path = \"./tmp/file_test_uvio_full.txt\";\n         {\n-            let mut fd = (*io).fs_open(&Path(path), create_flags as int, mode as int).unwrap();\n+            let create_fm = Create;\n+            let create_fa = ReadWrite;\n+            let mut fd = (*io).fs_open(&Path(path), create_fm, create_fa).unwrap();\n             let write_buf = write_val.as_bytes();\n             fd.write(write_buf);\n         }\n         {\n-            let mut fd = (*io).fs_open(&Path(path), ro_flags as int, mode as int).unwrap();\n+            let ro_fm = Open;\n+            let ro_fa = Read;\n+            let mut fd = (*io).fs_open(&Path(path), ro_fm, ro_fa).unwrap();\n             let mut read_vec = [0, .. 1028];\n             let nread = fd.read(read_vec).unwrap();\n             let read_val = str::from_bytes(read_vec.slice(0, nread as uint));"}]}