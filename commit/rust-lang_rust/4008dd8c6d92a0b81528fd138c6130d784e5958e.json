{"sha": "4008dd8c6d92a0b81528fd138c6130d784e5958e", "node_id": "C_kwDOAAsO6NoAKDQwMDhkZDhjNmQ5MmEwYjgxNTI4ZmQxMzhjNjEzMGQ3ODRlNTk1OGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-05T01:23:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-05T01:23:09Z"}, "message": "Auto merge of #98846 - RalfJung:alignment-is-a-type-thing, r=oli-obk\n\ninterpret: track place alignment together with the type, not the value\n\nThis matches how I handle alignment in [MiniRust](https://github.com/RalfJung/minirust). I think it makes conceptually a lot more sense.\nFixes https://github.com/rust-lang/rust/issues/63085\n\nr? `@oli-obk`", "tree": {"sha": "6678ddbe228624cfe0621d2523d10a64982a8187", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6678ddbe228624cfe0621d2523d10a64982a8187"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4008dd8c6d92a0b81528fd138c6130d784e5958e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4008dd8c6d92a0b81528fd138c6130d784e5958e", "html_url": "https://github.com/rust-lang/rust/commit/4008dd8c6d92a0b81528fd138c6130d784e5958e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4008dd8c6d92a0b81528fd138c6130d784e5958e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d1848cc60a407d06f90fd16877a19bed6edd9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d1848cc60a407d06f90fd16877a19bed6edd9b", "html_url": "https://github.com/rust-lang/rust/commit/e1d1848cc60a407d06f90fd16877a19bed6edd9b"}, {"sha": "b1568e6f34e500a4d9cdecd9873f4abf67a877a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1568e6f34e500a4d9cdecd9873f4abf67a877a0", "html_url": "https://github.com/rust-lang/rust/commit/b1568e6f34e500a4d9cdecd9873f4abf67a877a0"}], "stats": {"total": 213, "additions": 118, "deletions": 95}, "files": [{"sha": "031d508d70f2d56eb00f2d1365444639c1f4fce5", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4008dd8c6d92a0b81528fd138c6130d784e5958e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4008dd8c6d92a0b81528fd138c6130d784e5958e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=4008dd8c6d92a0b81528fd138c6130d784e5958e", "patch": "@@ -808,7 +808,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n \n         if !unwinding {\n-            let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n+            let op = self.local_to_op(&frame, mir::RETURN_PLACE, None)?;\n             self.copy_op_transmute(&op, &frame.return_place)?;\n             trace!(\"{:?}\", self.dump_place(*frame.return_place));\n         }\n@@ -981,8 +981,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                     LocalValue::Live(Operand::Indirect(mplace)) => {\n                         write!(\n                             fmt,\n-                            \" by align({}){} ref {:?}:\",\n-                            mplace.align.bytes(),\n+                            \" by {} ref {:?}:\",\n                             match mplace.meta {\n                                 MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n                                 MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n@@ -1011,13 +1010,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                 write!(fmt, \": {:?}\", self.ecx.dump_allocs(allocs.into_iter().flatten().collect()))\n             }\n             Place::Ptr(mplace) => match mplace.ptr.provenance.and_then(Provenance::get_alloc_id) {\n-                Some(alloc_id) => write!(\n-                    fmt,\n-                    \"by align({}) ref {:?}: {:?}\",\n-                    mplace.align.bytes(),\n-                    mplace.ptr,\n-                    self.ecx.dump_alloc(alloc_id)\n-                ),\n+                Some(alloc_id) => {\n+                    write!(fmt, \"by ref {:?}: {:?}\", mplace.ptr, self.ecx.dump_alloc(alloc_id))\n+                }\n                 ptr => write!(fmt, \" integral by ref: {:?}\", ptr),\n             },\n         }"}, {"sha": "d48f6521ba2aaaf75d047951318a3c9dc803be11", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4008dd8c6d92a0b81528fd138c6130d784e5958e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4008dd8c6d92a0b81528fd138c6130d784e5958e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=4008dd8c6d92a0b81528fd138c6130d784e5958e", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc_middle::ty::{ConstInt, DelaySpanBugEmitted, Ty};\n use rustc_middle::{mir, ty};\n-use rustc_target::abi::{self, Abi, HasDataLayout, Size, TagEncoding};\n+use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n@@ -177,10 +177,18 @@ pub enum Operand<Tag: Provenance = AllocId> {\n pub struct OpTy<'tcx, Tag: Provenance = AllocId> {\n     op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n+    /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n+    /// it needs to have a different alignment than the field type would usually have.\n+    /// So we represent this here with a separate field that \"overwrites\" `layout.align`.\n+    /// This means `layout.align` should never be used for an `OpTy`!\n+    /// `None` means \"alignment does not matter since this is a by-value operand\"\n+    /// (`Operand::Immediate`); this field is only relevant for `Operand::Indirect`.\n+    /// Also CTFE ignores alignment anyway, so this is for Miri only.\n+    pub align: Option<Align>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(OpTy<'_>, 80);\n+rustc_data_structures::static_assert_size!(OpTy<'_>, 88);\n \n impl<'tcx, Tag: Provenance> std::ops::Deref for OpTy<'tcx, Tag> {\n     type Target = Operand<Tag>;\n@@ -193,28 +201,28 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for OpTy<'tcx, Tag> {\n impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n-        OpTy { op: Operand::Indirect(*mplace), layout: mplace.layout }\n+        OpTy { op: Operand::Indirect(*mplace), layout: mplace.layout, align: Some(mplace.align) }\n     }\n }\n \n impl<'tcx, Tag: Provenance> From<&'_ MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: &MPlaceTy<'tcx, Tag>) -> Self {\n-        OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout }\n+        OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout, align: Some(mplace.align) }\n     }\n }\n \n impl<'tcx, Tag: Provenance> From<&'_ mut MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: &mut MPlaceTy<'tcx, Tag>) -> Self {\n-        OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout }\n+        OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout, align: Some(mplace.align) }\n     }\n }\n \n impl<'tcx, Tag: Provenance> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(val: ImmTy<'tcx, Tag>) -> Self {\n-        OpTy { op: Operand::Immediate(val.imm), layout: val.layout }\n+        OpTy { op: Operand::Immediate(val.imm), layout: val.layout, align: None }\n     }\n }\n \n@@ -450,7 +458,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ),\n         };\n \n-        Ok(OpTy { op: Operand::Immediate(field_val), layout: field_layout })\n+        Ok(OpTy { op: Operand::Immediate(field_val), layout: field_layout, align: None })\n     }\n \n     pub fn operand_index(\n@@ -522,7 +530,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ///\n     /// This is public because it is used by [priroda](https://github.com/oli-obk/priroda) to get an\n     /// OpTy from a local\n-    pub fn access_local(\n+    pub fn local_to_op(\n         &self,\n         frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n@@ -535,7 +543,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         } else {\n             M::access_local(&self, frame, local)?\n         };\n-        Ok(OpTy { op, layout })\n+        Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }\n \n     /// Every place can be read from, so we can turn them into an operand.\n@@ -549,10 +557,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let op = match **place {\n             Place::Ptr(mplace) => Operand::Indirect(mplace),\n             Place::Local { frame, local } => {\n-                *self.access_local(&self.stack()[frame], local, None)?\n+                *self.local_to_op(&self.stack()[frame], local, None)?\n             }\n         };\n-        Ok(OpTy { op, layout: place.layout })\n+        Ok(OpTy { op, layout: place.layout, align: Some(place.align) })\n     }\n \n     /// Evaluate a place with the goal of reading from it.  This lets us sometimes\n@@ -566,7 +574,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // here is not the entire place.\n         let layout = if place.projection.is_empty() { layout } else { None };\n \n-        let base_op = self.access_local(self.frame(), place.local, layout)?;\n+        let base_op = self.local_to_op(self.frame(), place.local, layout)?;\n \n         let op = place\n             .projection\n@@ -603,11 +611,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Constant(ref constant) => {\n                 let val =\n                     self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal)?;\n+\n                 // This can still fail:\n                 // * During ConstProp, with `TooGeneric` or since the `required_consts` were not all\n                 //   checked yet.\n                 // * During CTFE, since promoteds in `const`/`static` initializer bodies can fail.\n-\n                 self.mir_const_to_op(&val, layout)?\n             }\n         };\n@@ -683,7 +691,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.global_base_pointer(Pointer::new(id, offset))?;\n-                Operand::Indirect(MemPlace::from_ptr(ptr.into(), layout.align.abi))\n+                Operand::Indirect(MemPlace::from_ptr(ptr.into()))\n             }\n             ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x)?.into()),\n             ConstValue::Slice { data, start, end } => {\n@@ -700,7 +708,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ))\n             }\n         };\n-        Ok(OpTy { op, layout })\n+        Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }\n \n     /// Read discriminant, return the runtime value as well as the variant index."}, {"sha": "98a3a50afaaba5c927153df1e374e9025c0dba0e", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 90, "deletions": 70, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4008dd8c6d92a0b81528fd138c6130d784e5958e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4008dd8c6d92a0b81528fd138c6130d784e5958e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=4008dd8c6d92a0b81528fd138c6130d784e5958e", "patch": "@@ -57,15 +57,14 @@ impl<Tag: Provenance> MemPlaceMeta<Tag> {\n pub struct MemPlace<Tag: Provenance = AllocId> {\n     /// The pointer can be a pure integer, with the `None` tag.\n     pub ptr: Pointer<Option<Tag>>,\n-    pub align: Align,\n     /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g., `extern type`).\n     pub meta: MemPlaceMeta<Tag>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MemPlace, 48);\n+rustc_data_structures::static_assert_size!(MemPlace, 40);\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n pub enum Place<Tag: Provenance = AllocId> {\n@@ -78,12 +77,17 @@ pub enum Place<Tag: Provenance = AllocId> {\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Place, 56);\n+rustc_data_structures::static_assert_size!(Place, 48);\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n     place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n+    /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n+    /// it needs to have a different alignment than the field type would usually have.\n+    /// So we represent this here with a separate field that \"overwrites\" `layout.align`.\n+    /// This means `layout.align` should never be used for a `PlaceTy`!\n+    pub align: Align,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -102,6 +106,11 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for PlaceTy<'tcx, Tag> {\n pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n     mplace: MemPlace<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n+    /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n+    /// it needs to have a different alignment than the field type would usually have.\n+    /// So we represent this here with a separate field that \"overwrites\" `layout.align`.\n+    /// This means `layout.align` should never be used for a `MPlaceTy`!\n+    pub align: Align,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -118,28 +127,28 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n-        PlaceTy { place: Place::Ptr(*mplace), layout: mplace.layout }\n+        PlaceTy { place: Place::Ptr(*mplace), layout: mplace.layout, align: mplace.align }\n     }\n }\n \n impl<'tcx, Tag: Provenance> From<&'_ MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: &MPlaceTy<'tcx, Tag>) -> Self {\n-        PlaceTy { place: Place::Ptr(**mplace), layout: mplace.layout }\n+        PlaceTy { place: Place::Ptr(**mplace), layout: mplace.layout, align: mplace.align }\n     }\n }\n \n impl<'tcx, Tag: Provenance> From<&'_ mut MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: &mut MPlaceTy<'tcx, Tag>) -> Self {\n-        PlaceTy { place: Place::Ptr(**mplace), layout: mplace.layout }\n+        PlaceTy { place: Place::Ptr(**mplace), layout: mplace.layout, align: mplace.align }\n     }\n }\n \n impl<Tag: Provenance> MemPlace<Tag> {\n     #[inline(always)]\n-    pub fn from_ptr(ptr: Pointer<Option<Tag>>, align: Align) -> Self {\n-        MemPlace { ptr, align, meta: MemPlaceMeta::None }\n+    pub fn from_ptr(ptr: Pointer<Option<Tag>>) -> Self {\n+        MemPlace { ptr, meta: MemPlaceMeta::None }\n     }\n \n     /// Adjust the provenance of the main pointer (metadata is unaffected).\n@@ -170,11 +179,7 @@ impl<Tag: Provenance> MemPlace<Tag> {\n         meta: MemPlaceMeta<Tag>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        Ok(MemPlace {\n-            ptr: self.ptr.offset(offset, cx)?,\n-            align: self.align.restrict_for_offset(offset),\n-            meta,\n-        })\n+        Ok(MemPlace { ptr: self.ptr.offset(offset, cx)?, meta })\n     }\n }\n \n@@ -185,7 +190,7 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n         let align = layout.align.abi;\n         let ptr = Pointer::new(None, Size::from_bytes(align.bytes())); // no provenance, absolute address\n         // `Poison` this to make sure that the pointer value `ptr` is never observable by the program.\n-        MPlaceTy { mplace: MemPlace { ptr, align, meta: MemPlaceMeta::Poison }, layout }\n+        MPlaceTy { mplace: MemPlace { ptr, meta: MemPlaceMeta::Poison }, layout, align }\n     }\n \n     #[inline]\n@@ -196,12 +201,16 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        Ok(MPlaceTy { mplace: self.mplace.offset(offset, meta, cx)?, layout })\n+        Ok(MPlaceTy {\n+            mplace: self.mplace.offset(offset, meta, cx)?,\n+            align: self.align.restrict_for_offset(offset),\n+            layout,\n+        })\n     }\n \n     #[inline]\n     pub fn from_aligned_ptr(ptr: Pointer<Option<Tag>>, layout: TyAndLayout<'tcx>) -> Self {\n-        MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align.abi), layout }\n+        MPlaceTy { mplace: MemPlace::from_ptr(ptr), layout, align: layout.align.abi }\n     }\n \n     #[inline]\n@@ -210,10 +219,10 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n         layout: TyAndLayout<'tcx>,\n         meta: MemPlaceMeta<Tag>,\n     ) -> Self {\n-        let mut mplace = MemPlace::from_ptr(ptr, layout.align.abi);\n+        let mut mplace = MemPlace::from_ptr(ptr);\n         mplace.meta = meta;\n \n-        MPlaceTy { mplace, layout }\n+        MPlaceTy { mplace, layout, align: layout.align.abi }\n     }\n \n     #[inline]\n@@ -250,7 +259,9 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n     /// read from the resulting mplace, not to get its address back.\n     pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n         match **self {\n-            Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n+            Operand::Indirect(mplace) => {\n+                Ok(MPlaceTy { mplace, layout: self.layout, align: self.align.unwrap() })\n+            }\n             Operand::Immediate(_) if self.layout.is_zst() => Ok(MPlaceTy::dangling(self.layout)),\n             Operand::Immediate(imm) => Err(ImmTy::from_immediate(imm, self.layout)),\n         }\n@@ -264,20 +275,19 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n     }\n }\n \n-impl<Tag: Provenance> Place<Tag> {\n+impl<'tcx, Tag: Provenance> PlaceTy<'tcx, Tag> {\n+    /// A place is either an mplace or some local.\n     #[inline]\n-    pub fn assert_mem_place(self) -> MemPlace<Tag> {\n-        match self {\n-            Place::Ptr(mplace) => mplace,\n-            _ => bug!(\"assert_mem_place: expected Place::Ptr, got {:?}\", self),\n+    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Tag>, (usize, mir::Local)> {\n+        match **self {\n+            Place::Ptr(mplace) => Ok(MPlaceTy { mplace, layout: self.layout, align: self.align }),\n+            Place::Local { frame, local } => Err((frame, local)),\n         }\n     }\n-}\n \n-impl<'tcx, Tag: Provenance> PlaceTy<'tcx, Tag> {\n     #[inline]\n     pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n-        MPlaceTy { mplace: self.place.assert_mem_place(), layout: self.layout }\n+        self.try_as_mplace().unwrap()\n     }\n }\n \n@@ -306,16 +316,10 @@ where\n             Immediate::ScalarPair(ptr, meta) => (ptr, MemPlaceMeta::Meta(meta.check_init()?)),\n         };\n \n-        let mplace = MemPlace {\n-            ptr: self.scalar_to_ptr(ptr.check_init()?)?,\n-            // We could use the run-time alignment here. For now, we do not, because\n-            // the point of tracking the alignment here is to make sure that the *static*\n-            // alignment information emitted with the loads is correct. The run-time\n-            // alignment can only be more restrictive.\n-            align: layout.align.abi,\n-            meta,\n-        };\n-        Ok(MPlaceTy { mplace, layout })\n+        let mplace = MemPlace { ptr: self.scalar_to_ptr(ptr.check_init()?)?, meta };\n+        // When deref'ing a pointer, the *static* alignment given by the type is what matters.\n+        let align = layout.align.abi;\n+        Ok(MPlaceTy { mplace, layout, align })\n     }\n \n     /// Take an operand, representing a pointer, and dereference it to a place -- that\n@@ -368,7 +372,7 @@ where\n         let (size, align) = self\n             .size_and_align_of_mplace(&mplace)?\n             .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n-        assert!(mplace.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n+        assert!(mplace.align <= align, \"dynamic alignment less strict than static one?\");\n         let align = M::enforce_alignment(self).then_some(align);\n         self.check_ptr_access_align(mplace.ptr, size, align.unwrap_or(Align::ONE), msg)?;\n         Ok(())\n@@ -533,7 +537,7 @@ where\n \n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n-                let n = self.access_local(self.frame(), local, Some(layout))?;\n+                let n = self.local_to_op(self.frame(), local, Some(layout))?;\n                 let n = self.read_scalar(&n)?;\n                 let n = n.to_machine_usize(self)?;\n                 self.mplace_index(base, n)?\n@@ -608,11 +612,9 @@ where\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n-        Ok(match base.place {\n-            Place::Ptr(mplace) => {\n-                self.mplace_downcast(&MPlaceTy { mplace, layout: base.layout }, variant)?.into()\n-            }\n-            Place::Local { .. } => {\n+        Ok(match base.try_as_mplace() {\n+            Ok(mplace) => self.mplace_downcast(&mplace, variant)?.into(),\n+            Err(..) => {\n                 let layout = base.layout.for_variant(self, variant);\n                 PlaceTy { layout, ..*base }\n             }\n@@ -649,33 +651,44 @@ where\n         self.mplace_to_simd(&mplace)\n     }\n \n+    pub fn local_to_place(\n+        &self,\n+        frame: usize,\n+        local: mir::Local,\n+    ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+        let layout = self.layout_of_local(&self.stack()[frame], local, None)?;\n+        let place = Place::Local { frame, local };\n+        Ok(PlaceTy { place, layout, align: layout.align.abi })\n+    }\n+\n     /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_to_op`.\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn eval_place(\n         &mut self,\n         place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n-        let mut place_ty = PlaceTy {\n-            // This works even for dead/uninitialized locals; we check further when writing\n-            place: Place::Local { frame: self.frame_idx(), local: place.local },\n-            layout: self.layout_of_local(self.frame(), place.local, None)?,\n-        };\n+        let mut place_ty = self.local_to_place(self.frame_idx(), place.local)?;\n \n         for elem in place.projection.iter() {\n             place_ty = self.place_projection(&place_ty, &elem)?\n         }\n \n         trace!(\"{:?}\", self.dump_place(place_ty.place));\n         // Sanity-check the type we ended up with.\n-        debug_assert!(mir_assign_valid_types(\n-            *self.tcx,\n-            self.param_env,\n-            self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n-                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n-            )?)?,\n-            place_ty.layout,\n-        ));\n+        debug_assert!(\n+            mir_assign_valid_types(\n+                *self.tcx,\n+                self.param_env,\n+                self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n+                    place.ty(&self.frame().body.local_decls, *self.tcx).ty\n+                )?)?,\n+                place_ty.layout,\n+            ),\n+            \"eval_place of a MIR place with type {:?} produced an interpret place with type {:?}\",\n+            place.ty(&self.frame().body.local_decls, *self.tcx).ty,\n+            place_ty.layout.ty,\n+        );\n         Ok(place_ty)\n     }\n \n@@ -746,7 +759,7 @@ where\n             }\n             Place::Ptr(mplace) => mplace, // already referring to memory\n         };\n-        let dest = MPlaceTy { mplace, layout: dest.layout };\n+        let dest = MPlaceTy { mplace, layout: dest.layout, align: dest.align };\n \n         // This is already in memory, write there.\n         self.write_immediate_to_mplace_no_validate(src, &dest)\n@@ -808,9 +821,9 @@ where\n     }\n \n     pub fn write_uninit(&mut self, dest: &PlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n-        let mplace = match dest.place {\n-            Place::Ptr(mplace) => MPlaceTy { mplace, layout: dest.layout },\n-            Place::Local { frame, local } => {\n+        let mplace = match dest.try_as_mplace() {\n+            Ok(mplace) => mplace,\n+            Err((frame, local)) => {\n                 match M::access_local_mut(self, frame, local)? {\n                     Ok(local) => match dest.layout.abi {\n                         Abi::Scalar(_) => {\n@@ -830,7 +843,7 @@ where\n                     },\n                     Err(mplace) => {\n                         // The local is in memory, go on below.\n-                        MPlaceTy { mplace, layout: dest.layout }\n+                        MPlaceTy { mplace, layout: dest.layout, align: dest.align }\n                     }\n                 }\n             }\n@@ -948,7 +961,7 @@ where\n         let dest = self.force_allocation(dest)?;\n         self.copy_op_no_validate(\n             src,\n-            &PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout }),\n+            &PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout, align: dest.align }),\n         )?;\n \n         if M::enforce_validity(self) {\n@@ -989,12 +1002,16 @@ where\n                             .size_and_align_of(&meta, &local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n                         let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n-                        let mplace = MemPlace { ptr: ptr.into(), align, meta };\n+                        let mplace = MemPlace { ptr: ptr.into(), meta };\n                         if let LocalValue::Live(Operand::Immediate(value)) = local_val {\n                             // Preserve old value.\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type.\n-                            let mplace = MPlaceTy { mplace, layout: local_layout };\n+                            let mplace = MPlaceTy {\n+                                mplace,\n+                                layout: local_layout,\n+                                align: local_layout.align.abi,\n+                            };\n                             self.write_immediate_to_mplace_no_validate(value, &mplace)?;\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n@@ -1009,7 +1026,7 @@ where\n             Place::Ptr(mplace) => (mplace, None),\n         };\n         // Return with the original layout, so that the caller can go on\n-        Ok((MPlaceTy { mplace, layout: place.layout }, size))\n+        Ok((MPlaceTy { mplace, layout: place.layout, align: place.align }, size))\n     }\n \n     #[inline(always)]\n@@ -1038,15 +1055,14 @@ where\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl);\n         let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n-        let mplace =\n-            MemPlace { ptr: ptr.into(), align: Align::ONE, meta: MemPlaceMeta::Meta(meta) };\n+        let mplace = MemPlace { ptr: ptr.into(), meta: MemPlaceMeta::Meta(meta) };\n \n         let ty = self.tcx.mk_ref(\n             self.tcx.lifetimes.re_static,\n             ty::TypeAndMut { ty: self.tcx.types.str_, mutbl },\n         );\n         let layout = self.layout_of(ty).unwrap();\n-        MPlaceTy { mplace, layout }\n+        MPlaceTy { mplace, layout, align: layout.align.abi }\n     }\n \n     /// Writes the discriminant of the given variant.\n@@ -1166,7 +1182,11 @@ where\n             assert_eq!(align, layout.align.abi);\n         }\n \n-        let mplace = MPlaceTy { mplace: MemPlace { meta: MemPlaceMeta::None, ..**mplace }, layout };\n+        let mplace = MPlaceTy {\n+            mplace: MemPlace { meta: MemPlaceMeta::None, ..**mplace },\n+            layout,\n+            align: layout.align.abi,\n+        };\n         Ok((instance, mplace))\n     }\n }"}]}