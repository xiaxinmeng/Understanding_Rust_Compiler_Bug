{"sha": "f207ecbe021e2a81fbff4ea1904b955a156aa340", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMDdlY2JlMDIxZTJhODFmYmZmNGVhMTkwNGI5NTVhMTU2YWEzNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-03T22:37:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-03T22:37:07Z"}, "message": "Auto merge of #23972 - gkoz:partial_eq_str_string, r=alexcrichton\n\nRight now comparing a `&String` (or a `&Cow`) to a `&str` requires redundant borrowing of the latter. Implementing `PartialEq<str>` tries to avoid this limitation.\r\n\r\n```rust\r\nstruct Foo (String);\r\n\r\nfn main () {\r\n    let s = Foo(\"foo\".to_string());\r\n    match s {\r\n        Foo(ref x) if x == &\"foo\" => println!(\"foo!\"),\r\n        // avoid this -----^\r\n        _ => {}\r\n    }\r\n}\r\n```\r\n\r\nI was hoping that #23521 would solve this but it didn't work out.", "tree": {"sha": "9217d1fca3661cb1fcd22ecc8957b660ae460c55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9217d1fca3661cb1fcd22ecc8957b660ae460c55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f207ecbe021e2a81fbff4ea1904b955a156aa340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f207ecbe021e2a81fbff4ea1904b955a156aa340", "html_url": "https://github.com/rust-lang/rust/commit/f207ecbe021e2a81fbff4ea1904b955a156aa340", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f207ecbe021e2a81fbff4ea1904b955a156aa340/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1b8eb5ad4e4b581a38dd7d94723497b568a60d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b8eb5ad4e4b581a38dd7d94723497b568a60d4", "html_url": "https://github.com/rust-lang/rust/commit/c1b8eb5ad4e4b581a38dd7d94723497b568a60d4"}, {"sha": "52340630a6f76eae4e9b605d17c650d57114951e", "url": "https://api.github.com/repos/rust-lang/rust/commits/52340630a6f76eae4e9b605d17c650d57114951e", "html_url": "https://github.com/rust-lang/rust/commit/52340630a6f76eae4e9b605d17c650d57114951e"}], "stats": {"total": 22, "additions": 12, "deletions": 10}, "files": [{"sha": "8da8cad98a70545df1d24dc7703218de87e7d99c", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f207ecbe021e2a81fbff4ea1904b955a156aa340/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f207ecbe021e2a81fbff4ea1904b955a156aa340/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=f207ecbe021e2a81fbff4ea1904b955a156aa340", "patch": "@@ -796,49 +796,51 @@ impl<'a, 'b> Pattern<'a> for &'b String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for String {\n     #[inline]\n-    fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n+    fn eq(&self, other: &String) -> bool { PartialEq::eq(&self[..], &other[..]) }\n     #[inline]\n-    fn ne(&self, other: &String) -> bool { PartialEq::ne(&**self, &**other) }\n+    fn ne(&self, other: &String) -> bool { PartialEq::ne(&self[..], &other[..]) }\n }\n \n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$rhs> for $lhs {\n             #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n             #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&self[..], &other[..]) }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$lhs> for $rhs {\n             #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n             #[inline]\n-            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&self[..], &other[..]) }\n         }\n \n     }\n }\n \n+impl_eq! { String, str }\n impl_eq! { String, &'a str }\n+impl_eq! { Cow<'a, str>, str }\n impl_eq! { Cow<'a, str>, String }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<&'b str> for Cow<'a, str> {\n     #[inline]\n-    fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n+    fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&self[..], &other[..]) }\n     #[inline]\n-    fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n+    fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&self[..], &other[..]) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<Cow<'a, str>> for &'b str {\n     #[inline]\n-    fn eq(&self, other: &Cow<'a, str>) -> bool { PartialEq::eq(&**self, &**other) }\n+    fn eq(&self, other: &Cow<'a, str>) -> bool { PartialEq::eq(&self[..], &other[..]) }\n     #[inline]\n-    fn ne(&self, other: &Cow<'a, str>) -> bool { PartialEq::ne(&**self, &**other) }\n+    fn ne(&self, other: &Cow<'a, str>) -> bool { PartialEq::ne(&self[..], &other[..]) }\n }\n \n #[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]"}]}