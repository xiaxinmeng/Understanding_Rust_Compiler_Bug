{"sha": "9de34a84bb300bab1bf0227f577331620cd60511", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZTM0YTg0YmIzMDBiYWIxYmYwMjI3ZjU3NzMzMTYyMGNkNjA1MTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-30T14:25:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-30T14:25:48Z"}, "message": "Auto merge of #23673 - nikomatsakis:issue-23319-binops-ng-5, r=pnkfelix\n\nThe current binary operator code assumed that if the LHS was a scalar (`i32` etc), then the RHS had to match. This is not true with multidispatch. This PR generalizes the existing code to (primarily) use the traits -- this also allows us to defer the precise type-checking when the types aren't fully known. The one caveat is the unstable SIMD types, which don't fit in with the current traits -- in that case, the LHS type must be known to be SIMD ahead of time.\r\n\r\nThere is one semi-hacky bit in that during writeback, for builtin operators, if the types resolve to scalars (i32 etc) then we clear the method override. This is because we know what the semantics are and it is more efficient to generate the code directly. It also ensures that we can use these overloaded operators in constants and so forth.\r\n\r\ncc @japaric\r\ncc @aturon \r\n\r\nFixes #23319 (and others).", "tree": {"sha": "6b1519a5381ecfe0d59e7d9b785c0934e096606d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b1519a5381ecfe0d59e7d9b785c0934e096606d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9de34a84bb300bab1bf0227f577331620cd60511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9de34a84bb300bab1bf0227f577331620cd60511", "html_url": "https://github.com/rust-lang/rust/commit/9de34a84bb300bab1bf0227f577331620cd60511", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9de34a84bb300bab1bf0227f577331620cd60511/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14192d6df5cc714e5c9a3ca70b08f2514d977be2", "url": "https://api.github.com/repos/rust-lang/rust/commits/14192d6df5cc714e5c9a3ca70b08f2514d977be2", "html_url": "https://github.com/rust-lang/rust/commit/14192d6df5cc714e5c9a3ca70b08f2514d977be2"}, {"sha": "7595c25ef93bb18b5f96805daee4d1890f5b6a6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7595c25ef93bb18b5f96805daee4d1890f5b6a6b", "html_url": "https://github.com/rust-lang/rust/commit/7595c25ef93bb18b5f96805daee4d1890f5b6a6b"}], "stats": {"total": 1248, "additions": 685, "deletions": 563}, "files": [{"sha": "8f2e71b666c6b6dcdc1cea18da875e6123877b7d", "filename": "src/libcollectionstest/bench.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibcollectionstest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibcollectionstest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbench.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -22,13 +22,13 @@ macro_rules! map_insert_rand_bench {\n             let mut rng = rand::weak_rng();\n \n             for _ in 0..n {\n-                let i = rng.gen() % n;\n+                let i = rng.gen::<usize>() % n;\n                 map.insert(i, i);\n             }\n \n             // measure\n             b.iter(|| {\n-                let k = rng.gen() % n;\n+                let k = rng.gen::<usize>() % n;\n                 map.insert(k, k);\n                 map.remove(&k);\n             });\n@@ -77,7 +77,7 @@ macro_rules! map_find_rand_bench {\n \n             // setup\n             let mut rng = rand::weak_rng();\n-            let mut keys: Vec<_> = (0..n).map(|_| rng.gen() % n).collect();\n+            let mut keys: Vec<_> = (0..n).map(|_| rng.gen::<usize>() % n).collect();\n \n             for &k in &keys {\n                 map.insert(k, k);"}, {"sha": "862eb16d0bfb3fcb26c5f7a11008e5b142d867b1", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -485,6 +485,7 @@ pub trait Neg {\n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(unsigned_negation)]\n         impl Neg for $t {\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             type Output = $t;\n@@ -498,28 +499,7 @@ macro_rules! neg_impl {\n     )*)\n }\n \n-macro_rules! neg_uint_impl {\n-    ($t:ty, $t_signed:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Neg for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn neg(self) -> $t { -(self as $t_signed) as $t }\n-        }\n-\n-        forward_ref_unop! { impl Neg, neg for $t }\n-    }\n-}\n-\n-neg_impl! { isize i8 i16 i32 i64 f32 f64 }\n-\n-neg_uint_impl! { usize, isize }\n-neg_uint_impl! { u8, i8 }\n-neg_uint_impl! { u16, i16 }\n-neg_uint_impl! { u32, i32 }\n-neg_uint_impl! { u64, i64 }\n-\n+neg_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Not` trait is used to specify the functionality of unary `!`.\n ///"}, {"sha": "62189e721e59d70f554bf6e0934a64858ad3c3d7", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -256,7 +256,7 @@ fn ziggurat<R: Rng, P, Z>(\n             return zero_case(rng, u);\n         }\n         // algebraically equivalent to f1 + DRanU()*(f0 - f1) < 1\n-        if f_tab[i + 1] + (f_tab[i] - f_tab[i + 1]) * rng.gen() < pdf(x) {\n+        if f_tab[i + 1] + (f_tab[i] - f_tab[i + 1]) * rng.gen::<f64>() < pdf(x) {\n             return x;\n         }\n     }"}, {"sha": "347d494259d08830fbbbf39df99764512ff68bc1", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -154,7 +154,7 @@ macro_rules! float_impl {\n                 }\n             }\n             fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n-                r.low + r.range * rng.gen()\n+                r.low + r.range * rng.gen::<$ty>()\n             }\n         }\n     }"}, {"sha": "a788386d2424fec79dd3215cb3acc09553883b9d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 74, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -3039,6 +3039,10 @@ pub fn mk_nil<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_tup(cx, Vec::new())\n }\n \n+pub fn mk_bool<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n+    mk_t(cx, ty_bool)\n+}\n+\n pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>,\n                         opt_def_id: Option<ast::DefId>,\n                         fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n@@ -3406,8 +3410,12 @@ pub fn type_is_scalar(ty: Ty) -> bool {\n /// Returns true if this type is a floating point type and false otherwise.\n pub fn type_is_floating_point(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_float(_) => true,\n-        _ => false,\n+        ty_float(_) |\n+        ty_infer(FloatVar(_)) =>\n+            true,\n+\n+        _ =>\n+            false,\n     }\n }\n \n@@ -5805,78 +5813,6 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n     }\n }\n \n-pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool {\n-    #![allow(non_upper_case_globals)]\n-    const tycat_other: isize = 0;\n-    const tycat_bool: isize = 1;\n-    const tycat_char: isize = 2;\n-    const tycat_int: isize = 3;\n-    const tycat_float: isize = 4;\n-    const tycat_raw_ptr: isize = 6;\n-\n-    const opcat_add: isize = 0;\n-    const opcat_sub: isize = 1;\n-    const opcat_mult: isize = 2;\n-    const opcat_shift: isize = 3;\n-    const opcat_rel: isize = 4;\n-    const opcat_eq: isize = 5;\n-    const opcat_bit: isize = 6;\n-    const opcat_logic: isize = 7;\n-    const opcat_mod: isize = 8;\n-\n-    fn opcat(op: ast::BinOp) -> isize {\n-        match op.node {\n-          ast::BiAdd => opcat_add,\n-          ast::BiSub => opcat_sub,\n-          ast::BiMul => opcat_mult,\n-          ast::BiDiv => opcat_mult,\n-          ast::BiRem => opcat_mod,\n-          ast::BiAnd => opcat_logic,\n-          ast::BiOr => opcat_logic,\n-          ast::BiBitXor => opcat_bit,\n-          ast::BiBitAnd => opcat_bit,\n-          ast::BiBitOr => opcat_bit,\n-          ast::BiShl => opcat_shift,\n-          ast::BiShr => opcat_shift,\n-          ast::BiEq => opcat_eq,\n-          ast::BiNe => opcat_eq,\n-          ast::BiLt => opcat_rel,\n-          ast::BiLe => opcat_rel,\n-          ast::BiGe => opcat_rel,\n-          ast::BiGt => opcat_rel\n-        }\n-    }\n-\n-    fn tycat<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> isize {\n-        if type_is_simd(cx, ty) {\n-            return tycat(cx, simd_type(cx, ty))\n-        }\n-        match ty.sty {\n-          ty_char => tycat_char,\n-          ty_bool => tycat_bool,\n-          ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n-          ty_float(_) | ty_infer(FloatVar(_)) => tycat_float,\n-          ty_ptr(_) => tycat_raw_ptr,\n-          _ => tycat_other\n-        }\n-    }\n-\n-    const t: bool = true;\n-    const f: bool = false;\n-\n-    let tbl = [\n-    //           +, -, *, shift, rel, ==, bit, logic, mod\n-    /*other*/   [f, f, f, f,     f,   f,  f,   f,     f],\n-    /*bool*/    [f, f, f, f,     t,   t,  t,   t,     f],\n-    /*char*/    [f, f, f, f,     t,   t,  f,   f,     f],\n-    /*isize*/     [t, t, t, t,     t,   t,  t,   f,     t],\n-    /*float*/   [t, t, t, f,     t,   t,  f,   f,     f],\n-    /*bot*/     [t, t, t, t,     t,   t,  t,   t,     t],\n-    /*raw ptr*/ [f, f, f, f,     t,   t,  f,   f,     f]];\n-\n-    return tbl[tycat(cx, ty) as usize ][opcat(op) as usize];\n-}\n-\n // Returns the repeat count for a repeating vector expression.\n pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> usize {\n     match const_eval::eval_const_expr_partial(tcx, count_expr, Some(tcx.types.usize)) {"}, {"sha": "61e332f87ad1a2683aeb65b8676b7e4cfc570509", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -560,7 +560,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\")\n             }\n         }\n-        ty::ty_bool | ty::ty_uint(_) | ty::ty_char => {\n+        ty::ty_bare_fn(..) | ty::ty_bool | ty::ty_uint(_) | ty::ty_char => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n         }\n         ty::ty_ptr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {"}, {"sha": "0a9df2b5dc180dba91802d120abf6ea96d901e8c", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -351,7 +351,14 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    e: &ast::Expr,\n                                    ety: Ty<'tcx>,\n-                                   param_substs: &'tcx Substs<'tcx>) -> ValueRef {\n+                                   param_substs: &'tcx Substs<'tcx>)\n+                                   -> ValueRef\n+{\n+    debug!(\"const_expr_unadjusted(e={}, ety={}, param_substs={})\",\n+           e.repr(cx.tcx()),\n+           ety.repr(cx.tcx()),\n+           param_substs.repr(cx.tcx()));\n+\n     let map_list = |exprs: &[P<ast::Expr>]| {\n         exprs.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n              .fold(Vec::new(), |mut l, val| { l.push(val); l })\n@@ -366,6 +373,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n             let (te1, ty) = const_expr(cx, &**e1, param_substs);\n+            debug!(\"const_expr_unadjusted: te1={}, ty={}\",\n+                   cx.tn().val_to_string(te1),\n+                   ty.repr(cx.tcx()));\n             let is_simd = ty::type_is_simd(cx.tcx(), ty);\n             let intype = if is_simd {\n                 ty::simd_type(cx.tcx(), ty)"}, {"sha": "46cbd1936002aef12621e03f91d45205ea0eb74b", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -2384,6 +2384,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n+#[derive(Debug)]\n enum OverflowOp {\n     Add,\n     Sub,\n@@ -2413,6 +2414,7 @@ enum OverflowCodegen {\n \n enum OverflowOpViaInputCheck { Shl, Shr, }\n \n+#[derive(Debug)]\n enum OverflowOpViaIntrinsic { Add, Sub, Mul, }\n \n impl OverflowOpViaIntrinsic {\n@@ -2437,7 +2439,8 @@ impl OverflowOpViaIntrinsic {\n                 _ => panic!(\"unsupported target word size\")\n             },\n             ref t @ ty_uint(_) | ref t @ ty_int(_) => t.clone(),\n-            _ => panic!(\"tried to get overflow intrinsic for non-int type\")\n+            _ => panic!(\"tried to get overflow intrinsic for {:?} applied to non-int type\",\n+                        *self)\n         };\n \n         match *self {"}, {"sha": "31ac0a57ba0e14361d7c990855a02f01c1048e42", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::autoderef;\n-use super::AutorefArgs;\n use super::check_argument_types;\n use super::check_expr;\n use super::check_method_argument_types;\n@@ -258,7 +257,6 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                          &fn_sig.inputs,\n                          &expected_arg_tys[..],\n                          arg_exprs,\n-                         AutorefArgs::No,\n                          fn_sig.variadic,\n                          TupleArgumentsFlag::DontTupleArguments);\n \n@@ -288,7 +286,6 @@ fn confirm_deferred_closure_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                          &*fn_sig.inputs,\n                          &*expected_arg_tys,\n                          arg_exprs,\n-                         AutorefArgs::No,\n                          fn_sig.variadic,\n                          TupleArgumentsFlag::TupleArguments);\n \n@@ -308,7 +305,6 @@ fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     method_callee.ty,\n                                     callee_expr,\n                                     arg_exprs,\n-                                    AutorefArgs::No,\n                                     TupleArgumentsFlag::TupleArguments,\n                                     expected);\n     write_call(fcx, call_expr, output_type);"}, {"sha": "1f992b9c3ae6c97dfb0480820f064fbf52eca745", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 368, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -79,7 +79,6 @@ type parameter).\n pub use self::LvaluePreference::*;\n pub use self::Expectation::*;\n pub use self::compare_method::compare_impl_method;\n-use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n \n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n@@ -142,6 +141,7 @@ pub mod wf;\n mod closure;\n mod callee;\n mod compare_method;\n+mod op;\n \n /// closures defined within the function.  For example:\n ///\n@@ -288,15 +288,6 @@ impl UnsafetyState {\n     }\n }\n \n-/// Whether `check_binop` is part of an assignment or not.\n-/// Used to know whether we allow user overloads and to print\n-/// better messages on error.\n-#[derive(PartialEq)]\n-enum IsBinopAssignment{\n-    SimpleBinop,\n-    BinopAssignment,\n-}\n-\n #[derive(Clone)]\n pub struct FnCtxt<'a, 'tcx: 'a> {\n     body_id: ast::NodeId,\n@@ -1325,21 +1316,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// version, this version will also select obligations if it seems\n     /// useful, in an effort to get more type information.\n     fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        debug!(\"resolve_type_vars_if_possible(ty={})\", ty.repr(self.tcx()));\n+\n         // No ty::infer()? Nothing needs doing.\n         if !ty::type_has_ty_infer(ty) {\n+            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n+            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n             return ty;\n         }\n \n         // If not, try resolving any new fcx obligations that have cropped up.\n         vtable::select_new_fcx_obligations(self);\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n+            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n             return ty;\n         }\n \n@@ -1348,7 +1344,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n         vtable::select_fcx_obligations_where_possible(self);\n-        self.infcx().resolve_type_vars_if_possible(&ty)\n+        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+\n+        debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+        ty\n     }\n \n     /// Resolves all type variables in `t` and then, if any were left\n@@ -2092,24 +2091,17 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     match method {\n         Some(method) => {\n-            let ref_ty = // invoked methods have all LB regions instantiated\n-                ty::no_late_bound_regions(\n-                    fcx.tcx(), &ty::ty_fn_ret(method.ty)).unwrap();\n-            match method_call {\n-                Some(method_call) => {\n-                    fcx.inh.method_map.borrow_mut().insert(method_call,\n-                                                           method);\n-                }\n-                None => {}\n-            }\n-            match ref_ty {\n-                ty::FnConverging(ref_ty) => {\n-                    ty::deref(ref_ty, true)\n-                }\n-                ty::FnDiverging => {\n-                    fcx.tcx().sess.bug(\"index/deref traits do not define a `!` return\")\n-                }\n+            // extract method method return type, which will be &T;\n+            // all LB regions should have been instantiated during method lookup\n+            let ret_ty = ty::ty_fn_ret(method.ty);\n+            let ret_ty = ty::no_late_bound_regions(fcx.tcx(), &ret_ty).unwrap().unwrap();\n+\n+            if let Some(method_call) = method_call {\n+                fcx.inh.method_map.borrow_mut().insert(method_call, method);\n             }\n+\n+            // method returns &T, but the type as visible to user is T, so deref\n+            ty::deref(ret_ty, true)\n         }\n         None => None,\n     }\n@@ -2238,7 +2230,6 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          method_fn_ty: Ty<'tcx>,\n                                          callee_expr: &'tcx ast::Expr,\n                                          args_no_rcvr: &'tcx [P<ast::Expr>],\n-                                         autoref_args: AutorefArgs,\n                                          tuple_arguments: TupleArgumentsFlag,\n                                          expected: Expectation<'tcx>)\n                                          -> ty::FnOutput<'tcx> {\n@@ -2255,7 +2246,6 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              &err_inputs[..],\n                              &[],\n                              args_no_rcvr,\n-                             autoref_args,\n                              false,\n                              tuple_arguments);\n         ty::FnConverging(fcx.tcx().types.err)\n@@ -2273,7 +2263,6 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      &fty.sig.0.inputs[1..],\n                                      &expected_arg_tys[..],\n                                      args_no_rcvr,\n-                                     autoref_args,\n                                      fty.sig.0.variadic,\n                                      tuple_arguments);\n                 fty.sig.0.output\n@@ -2293,7 +2282,6 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   fn_inputs: &[Ty<'tcx>],\n                                   expected_arg_tys: &[Ty<'tcx>],\n                                   args: &'tcx [P<ast::Expr>],\n-                                  autoref_args: AutorefArgs,\n                                   variadic: bool,\n                                   tuple_arguments: TupleArgumentsFlag) {\n     let tcx = fcx.ccx.tcx;\n@@ -2406,26 +2394,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             if is_block == check_blocks {\n                 debug!(\"checking the argument\");\n-                let mut formal_ty = formal_tys[i];\n-\n-                match autoref_args {\n-                    AutorefArgs::Yes => {\n-                        match formal_ty.sty {\n-                            ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n-                            ty::ty_err => (),\n-                            _ => {\n-                                // So we hit this case when one implements the\n-                                // operator traits but leaves an argument as\n-                                // just T instead of &T. We'll catch it in the\n-                                // mismatch impl/trait method phase no need to\n-                                // ICE here.\n-                                // See: #11450\n-                                formal_ty = tcx.types.err;\n-                            }\n-                        }\n-                    }\n-                    AutorefArgs::No => {}\n-                }\n+                let formal_ty = formal_tys[i];\n \n                 // The special-cased logic below has three functions:\n                 // 1. Provide as good of an expected type as possible.\n@@ -2622,14 +2591,6 @@ pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     TypeAndSubsts { substs: substs, ty: substd_ty }\n }\n \n-// Controls whether the arguments are automatically referenced. This is useful\n-// for overloaded binary and unary operators.\n-#[derive(Copy, PartialEq)]\n-pub enum AutorefArgs {\n-    Yes,\n-    No,\n-}\n-\n /// Controls whether the arguments are tupled. This is used for the call\n /// operator.\n ///\n@@ -2755,7 +2716,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  fn_ty,\n                                                  expr,\n                                                  &args[1..],\n-                                                 AutorefArgs::No,\n                                                  DontTupleArguments,\n                                                  expected);\n \n@@ -2806,277 +2766,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method<'a, 'tcx, F>(fcx: &'a FnCtxt<'a, 'tcx>,\n-                                     op_ex: &'tcx ast::Expr,\n-                                     lhs_ty: Ty<'tcx>,\n-                                     opname: ast::Name,\n-                                     trait_did: Option<ast::DefId>,\n-                                     lhs: &'a ast::Expr,\n-                                     rhs: Option<&'tcx P<ast::Expr>>,\n-                                     unbound_method: F,\n-                                     autoref_args: AutorefArgs) -> Ty<'tcx> where\n-        F: FnOnce(),\n-    {\n-        let method = match trait_did {\n-            Some(trait_did) => {\n-                // We do eager coercions to make using operators\n-                // more ergonomic:\n-                //\n-                // - If the input is of type &'a T (resp. &'a mut T),\n-                //   then reborrow it to &'b T (resp. &'b mut T) where\n-                //   'b <= 'a.  This makes things like `x == y`, where\n-                //   `x` and `y` are both region pointers, work.  We\n-                //   could also solve this with variance or different\n-                //   traits that don't force left and right to have same\n-                //   type.\n-                let (adj_ty, adjustment) = match lhs_ty.sty {\n-                    ty::ty_rptr(r_in, mt) => {\n-                        let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n-                        fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, *r_in);\n-                        let adjusted_ty = ty::mk_rptr(fcx.tcx(), fcx.tcx().mk_region(r_adj), mt);\n-                        let autoptr = ty::AutoPtr(r_adj, mt.mutbl, None);\n-                        let adjustment = ty::AutoDerefRef { autoderefs: 1, autoref: Some(autoptr) };\n-                        (adjusted_ty, adjustment)\n-                    }\n-                    _ => {\n-                        (lhs_ty, ty::AutoDerefRef { autoderefs: 0, autoref: None })\n-                    }\n-                };\n-\n-                debug!(\"adjusted_ty={} adjustment={:?}\",\n-                       adj_ty.repr(fcx.tcx()),\n-                       adjustment);\n-\n-                method::lookup_in_trait_adjusted(fcx, op_ex.span, Some(lhs), opname,\n-                                                 trait_did, adjustment, adj_ty, None)\n-            }\n-            None => None\n-        };\n-        let args = match rhs {\n-            Some(rhs) => slice::ref_slice(rhs),\n-            None => &[][..]\n-        };\n-        match method {\n-            Some(method) => {\n-                let method_ty = method.ty;\n-                // HACK(eddyb) Fully qualified path to work around a resolve bug.\n-                let method_call = ::middle::ty::MethodCall::expr(op_ex.id);\n-                fcx.inh.method_map.borrow_mut().insert(method_call, method);\n-                match check_method_argument_types(fcx,\n-                                                  op_ex.span,\n-                                                  method_ty,\n-                                                  op_ex,\n-                                                  args,\n-                                                  autoref_args,\n-                                                  DontTupleArguments,\n-                                                  NoExpectation) {\n-                    ty::FnConverging(result_type) => result_type,\n-                    ty::FnDiverging => fcx.tcx().types.err\n-                }\n-            }\n-            None => {\n-                unbound_method();\n-                // Check the args anyway\n-                // so we get all the error messages\n-                let expected_ty = fcx.tcx().types.err;\n-                check_method_argument_types(fcx,\n-                                            op_ex.span,\n-                                            expected_ty,\n-                                            op_ex,\n-                                            args,\n-                                            autoref_args,\n-                                            DontTupleArguments,\n-                                            NoExpectation);\n-                fcx.tcx().types.err\n-            }\n-        }\n-    }\n-\n-    // could be either an expr_binop or an expr_assign_binop\n-    fn check_binop<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                            expr: &'tcx ast::Expr,\n-                            op: ast::BinOp,\n-                            lhs: &'tcx ast::Expr,\n-                            rhs: &'tcx P<ast::Expr>,\n-                            is_binop_assignment: IsBinopAssignment) {\n-        let tcx = fcx.ccx.tcx;\n-\n-        let lvalue_pref = match is_binop_assignment {\n-            BinopAssignment => PreferMutLvalue,\n-            SimpleBinop => NoPreference\n-        };\n-        check_expr_with_lvalue_pref(fcx, lhs, lvalue_pref);\n-\n-        // Callee does bot / err checking\n-        let lhs_t =\n-            structurally_resolve_type_or_else(fcx, lhs.span, fcx.expr_ty(lhs), || {\n-                if ast_util::is_symmetric_binop(op.node) {\n-                    // Try RHS first\n-                    check_expr(fcx, &**rhs);\n-                    fcx.expr_ty(&**rhs)\n-                } else {\n-                    fcx.tcx().types.err\n-                }\n-            });\n-\n-        if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op.node) {\n-            // Shift is a special case: rhs must be usize, no matter what lhs is\n-            check_expr(fcx, &**rhs);\n-            let rhs_ty = fcx.expr_ty(&**rhs);\n-            let rhs_ty = structurally_resolved_type(fcx, rhs.span, rhs_ty);\n-            if ty::type_is_integral(rhs_ty) {\n-                fcx.write_ty(expr.id, lhs_t);\n-            } else {\n-                fcx.type_error_message(\n-                    expr.span,\n-                    |actual| {\n-                        format!(\n-                            \"right-hand-side of a shift operation must have integral type, \\\n-                             not `{}`\",\n-                            actual)\n-                    },\n-                    rhs_ty,\n-                    None);\n-                fcx.write_ty(expr.id, fcx.tcx().types.err);\n-            }\n-            return;\n-        }\n-\n-        if ty::is_binopable(tcx, lhs_t, op) {\n-            let tvar = fcx.infcx().next_ty_var();\n-            demand::suptype(fcx, expr.span, tvar, lhs_t);\n-            check_expr_has_type(fcx, &**rhs, tvar);\n-\n-            let result_t = match op.node {\n-                ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n-                ast::BiGt => {\n-                    if ty::type_is_simd(tcx, lhs_t) {\n-                        if ty::type_is_fp(ty::simd_type(tcx, lhs_t)) {\n-                            fcx.type_error_message(expr.span,\n-                                |actual| {\n-                                    format!(\"binary comparison \\\n-                                             operation `{}` not \\\n-                                             supported for floating \\\n-                                             point SIMD vector `{}`\",\n-                                            ast_util::binop_to_string(op.node),\n-                                            actual)\n-                                },\n-                                lhs_t,\n-                                None\n-                            );\n-                            fcx.tcx().types.err\n-                        } else {\n-                            lhs_t\n-                        }\n-                    } else {\n-                        fcx.tcx().types.bool\n-                    }\n-                },\n-                _ => lhs_t,\n-            };\n-\n-            fcx.write_ty(expr.id, result_t);\n-            return;\n-        }\n-\n-        if op.node == ast::BiOr || op.node == ast::BiAnd {\n-            // This is an error; one of the operands must have the wrong\n-            // type\n-            fcx.write_error(expr.id);\n-            fcx.write_error(rhs.id);\n-            fcx.type_error_message(expr.span,\n-                                   |actual| {\n-                    format!(\"binary operation `{}` cannot be applied \\\n-                             to type `{}`\",\n-                            ast_util::binop_to_string(op.node),\n-                            actual)\n-                },\n-                lhs_t,\n-                None)\n-        }\n-\n-        // Check for overloaded operators if not an assignment.\n-        let result_t = if is_binop_assignment == SimpleBinop {\n-            check_user_binop(fcx, expr, lhs, lhs_t, op, rhs)\n-        } else {\n-            fcx.type_error_message(expr.span,\n-                                   |actual| {\n-                                        format!(\"binary assignment \\\n-                                                 operation `{}=` \\\n-                                                 cannot be applied to \\\n-                                                 type `{}`\",\n-                                                ast_util::binop_to_string(op.node),\n-                                                actual)\n-                                   },\n-                                   lhs_t,\n-                                   None);\n-            check_expr(fcx, &**rhs);\n-            fcx.tcx().types.err\n-        };\n-\n-        fcx.write_ty(expr.id, result_t);\n-        if ty::type_is_error(result_t) {\n-            fcx.write_ty(rhs.id, result_t);\n-        }\n-    }\n-\n-    fn check_user_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  ex: &'tcx ast::Expr,\n-                                  lhs_expr: &'tcx ast::Expr,\n-                                  lhs_resolved_t: Ty<'tcx>,\n-                                  op: ast::BinOp,\n-                                  rhs: &'tcx P<ast::Expr>) -> Ty<'tcx> {\n-        let tcx = fcx.ccx.tcx;\n-        let lang = &tcx.lang_items;\n-        let (name, trait_did) = match op.node {\n-            ast::BiAdd => (\"add\", lang.add_trait()),\n-            ast::BiSub => (\"sub\", lang.sub_trait()),\n-            ast::BiMul => (\"mul\", lang.mul_trait()),\n-            ast::BiDiv => (\"div\", lang.div_trait()),\n-            ast::BiRem => (\"rem\", lang.rem_trait()),\n-            ast::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n-            ast::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n-            ast::BiBitOr => (\"bitor\", lang.bitor_trait()),\n-            ast::BiShl => (\"shl\", lang.shl_trait()),\n-            ast::BiShr => (\"shr\", lang.shr_trait()),\n-            ast::BiLt => (\"lt\", lang.ord_trait()),\n-            ast::BiLe => (\"le\", lang.ord_trait()),\n-            ast::BiGe => (\"ge\", lang.ord_trait()),\n-            ast::BiGt => (\"gt\", lang.ord_trait()),\n-            ast::BiEq => (\"eq\", lang.eq_trait()),\n-            ast::BiNe => (\"ne\", lang.eq_trait()),\n-            ast::BiAnd | ast::BiOr => {\n-                check_expr(fcx, &**rhs);\n-                return tcx.types.err;\n-            }\n-        };\n-        lookup_op_method(fcx, ex, lhs_resolved_t, token::intern(name),\n-                         trait_did, lhs_expr, Some(rhs), || {\n-            fcx.type_error_message(ex.span, |actual| {\n-                format!(\"binary operation `{}` cannot be applied to type `{}`\",\n-                        ast_util::binop_to_string(op.node),\n-                        actual)\n-            }, lhs_resolved_t, None)\n-        }, if ast_util::is_by_value_binop(op.node) { AutorefArgs::No } else { AutorefArgs::Yes })\n-    }\n-\n-    fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 op_str: &str,\n-                                 mname: &str,\n-                                 trait_did: Option<ast::DefId>,\n-                                 ex: &'tcx ast::Expr,\n-                                 rhs_expr: &'tcx ast::Expr,\n-                                 rhs_t: Ty<'tcx>,\n-                                 op: ast::UnOp) -> Ty<'tcx> {\n-       lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n-                        trait_did, rhs_expr, None, || {\n-            fcx.type_error_message(ex.span, |actual| {\n-                format!(\"cannot apply unary operator `{}` to type `{}`\",\n-                        op_str, actual)\n-            }, rhs_t, None);\n-        }, if ast_util::is_by_value_unop(op) { AutorefArgs::No } else { AutorefArgs::Yes })\n-    }\n-\n     // Check field access expressions\n     fn check_field<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                             expr: &'tcx ast::Expr,\n@@ -3479,35 +3168,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprBinary(op, ref lhs, ref rhs) => {\n-        check_binop(fcx, expr, op, &**lhs, rhs, SimpleBinop);\n-\n-        let lhs_ty = fcx.expr_ty(&**lhs);\n-        let rhs_ty = fcx.expr_ty(&**rhs);\n-        if ty::type_is_error(lhs_ty) ||\n-            ty::type_is_error(rhs_ty) {\n-            fcx.write_error(id);\n-        }\n+        op::check_binop(fcx, expr, op, lhs, rhs);\n       }\n       ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n-        check_binop(fcx, expr, op, &**lhs, rhs, BinopAssignment);\n-\n-        let lhs_t = fcx.expr_ty(&**lhs);\n-        let result_t = fcx.expr_ty(expr);\n-        demand::suptype(fcx, expr.span, result_t, lhs_t);\n-\n-        let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, &**lhs) {\n-            span_err!(tcx.sess, lhs.span, E0067, \"illegal left-hand side expression\");\n-        }\n-\n-        fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n-\n-        // Overwrite result of check_binop...this preserves existing behavior\n-        // but seems quite dubious with regard to user-defined methods\n-        // and so forth. - Niko\n-        if !ty::type_is_error(result_t) {\n-            fcx.write_nil(expr.id);\n-        }\n+        op::check_binop_assign(fcx, expr, op, lhs, rhs);\n       }\n       ast::ExprUnary(unop, ref oprnd) => {\n         let expected_inner = expected.to_option(fcx).map_or(NoExpectation, |ty| {\n@@ -3580,19 +3244,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          oprnd_t.sty == ty::ty_bool) {\n-                        oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n-                                                  tcx.lang_items.not_trait(),\n-                                                  expr, &**oprnd, oprnd_t, unop);\n+                        oprnd_t = op::check_user_unop(fcx, \"!\", \"not\",\n+                                                      tcx.lang_items.not_trait(),\n+                                                      expr, &**oprnd, oprnd_t, unop);\n                     }\n                 }\n                 ast::UnNeg => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::type_is_fp(oprnd_t)) {\n-                        oprnd_t = check_user_unop(fcx, \"-\", \"neg\",\n-                                                  tcx.lang_items.neg_trait(),\n-                                                  expr, &**oprnd, oprnd_t, unop);\n+                        oprnd_t = op::check_user_unop(fcx, \"-\", \"neg\",\n+                                                      tcx.lang_items.neg_trait(),\n+                                                      expr, &**oprnd, oprnd_t, unop);\n                     }\n                 }\n             }\n@@ -4073,9 +3737,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n                   match result {\n                       Some((index_ty, element_ty)) => {\n-                          // FIXME: we've already checked idx above, we should\n-                          // probably just demand subtype or something here.\n-                          check_expr_has_type(fcx, &**idx, index_ty);\n+                          let idx_expr_ty = fcx.expr_ty(idx);\n+                          demand::eqtype(fcx, expr.span, index_ty, idx_expr_ty);\n                           fcx.write_ty(id, element_ty);\n                       }\n                       _ => {"}, {"sha": "49e88dc1483eb1ad52af26bdde92ff79ba2c6721", "filename": "src/librustc_typeck/check/op.rs", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -0,0 +1,481 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code related to processing overloaded binary and unary operators.\n+\n+use super::{\n+    check_expr,\n+    check_expr_coercable_to_type,\n+    check_expr_with_lvalue_pref,\n+    demand,\n+    method,\n+    FnCtxt,\n+    PreferMutLvalue,\n+    structurally_resolved_type,\n+};\n+use middle::infer;\n+use middle::traits;\n+use middle::ty::{self, Ty};\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::parse::token;\n+use util::ppaux::{Repr, UserString};\n+\n+/// Check a `a <op>= b`\n+pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                   expr: &'tcx ast::Expr,\n+                                   op: ast::BinOp,\n+                                   lhs_expr: &'tcx ast::Expr,\n+                                   rhs_expr: &'tcx ast::Expr)\n+{\n+    let tcx = fcx.ccx.tcx;\n+\n+    check_expr_with_lvalue_pref(fcx, lhs_expr, PreferMutLvalue);\n+    check_expr(fcx, rhs_expr);\n+\n+    let lhs_ty = structurally_resolved_type(fcx, lhs_expr.span, fcx.expr_ty(lhs_expr));\n+    let rhs_ty = structurally_resolved_type(fcx, rhs_expr.span, fcx.expr_ty(rhs_expr));\n+\n+    if is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op) {\n+        enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+        fcx.write_nil(expr.id);\n+    } else {\n+        // error types are considered \"builtin\"\n+        assert!(!ty::type_is_error(lhs_ty) || !ty::type_is_error(rhs_ty));\n+        span_err!(tcx.sess, lhs_expr.span, E0368,\n+                  \"binary assignment operation `{}=` cannot be applied to types `{}` and `{}`\",\n+                  ast_util::binop_to_string(op.node),\n+                  lhs_ty.user_string(fcx.tcx()),\n+                  rhs_ty.user_string(fcx.tcx()));\n+        fcx.write_error(expr.id);\n+    }\n+\n+    let tcx = fcx.tcx();\n+    if !ty::expr_is_lval(tcx, lhs_expr) {\n+        span_err!(tcx.sess, lhs_expr.span, E0067, \"illegal left-hand side expression\");\n+    }\n+\n+    fcx.require_expr_have_sized_type(lhs_expr, traits::AssignmentLhsSized);\n+}\n+\n+/// Check a potentially overloaded binary operator.\n+pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                             expr: &'tcx ast::Expr,\n+                             op: ast::BinOp,\n+                             lhs_expr: &'tcx ast::Expr,\n+                             rhs_expr: &'tcx ast::Expr)\n+{\n+    let tcx = fcx.ccx.tcx;\n+\n+    debug!(\"check_binop(expr.id={}, expr={}, op={:?}, lhs_expr={}, rhs_expr={})\",\n+           expr.id,\n+           expr.repr(tcx),\n+           op,\n+           lhs_expr.repr(tcx),\n+           rhs_expr.repr(tcx));\n+\n+    check_expr(fcx, lhs_expr);\n+    let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n+\n+    // Annoyingly, SIMD ops don't fit into the PartialEq/PartialOrd\n+    // traits, because their return type is not bool. Perhaps this\n+    // should change, but for now if LHS is SIMD we go down a\n+    // different path that bypassess all traits.\n+    if ty::type_is_simd(fcx.tcx(), lhs_ty) {\n+        check_expr_coercable_to_type(fcx, rhs_expr, lhs_ty);\n+        let rhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n+        let return_ty = enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+        fcx.write_ty(expr.id, return_ty);\n+        return;\n+    }\n+\n+    match BinOpCategory::from(op) {\n+        BinOpCategory::Shortcircuit => {\n+            // && and || are a simple case.\n+            demand::suptype(fcx, lhs_expr.span, ty::mk_bool(tcx), lhs_ty);\n+            check_expr_coercable_to_type(fcx, rhs_expr, ty::mk_bool(tcx));\n+            fcx.write_ty(expr.id, ty::mk_bool(tcx));\n+        }\n+        _ => {\n+            // Otherwise, we always treat operators as if they are\n+            // overloaded. This is the way to be most flexible w/r/t\n+            // types that get inferred.\n+            let (rhs_ty, return_ty) =\n+                check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op);\n+\n+            // Supply type inference hints if relevant. Probably these\n+            // hints should be enforced during select as part of the\n+            // `consider_unification_despite_ambiguity` routine, but this\n+            // more convenient for now.\n+            //\n+            // The basic idea is to help type inference by taking\n+            // advantage of things we know about how the impls for\n+            // scalar types are arranged. This is important in a\n+            // scenario like `1_u32 << 2`, because it lets us quickly\n+            // deduce that the result type should be `u32`, even\n+            // though we don't know yet what type 2 has and hence\n+            // can't pin this down to a specific impl.\n+            let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n+            if\n+                !ty::type_is_ty_var(lhs_ty) &&\n+                !ty::type_is_ty_var(rhs_ty) &&\n+                is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op)\n+            {\n+                let builtin_return_ty =\n+                    enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+                demand::suptype(fcx, expr.span, builtin_return_ty, return_ty);\n+            }\n+\n+            fcx.write_ty(expr.id, return_ty);\n+        }\n+    }\n+}\n+\n+fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                         lhs_expr: &'tcx ast::Expr,\n+                                         lhs_ty: Ty<'tcx>,\n+                                         rhs_expr: &'tcx ast::Expr,\n+                                         rhs_ty: Ty<'tcx>,\n+                                         op: ast::BinOp)\n+                                         -> Ty<'tcx>\n+{\n+    debug_assert!(is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op));\n+\n+    let tcx = fcx.tcx();\n+    match BinOpCategory::from(op) {\n+        BinOpCategory::Shortcircuit => {\n+            demand::suptype(fcx, lhs_expr.span, ty::mk_bool(tcx), lhs_ty);\n+            demand::suptype(fcx, rhs_expr.span, ty::mk_bool(tcx), rhs_ty);\n+            ty::mk_bool(tcx)\n+        }\n+\n+        BinOpCategory::Shift => {\n+            // For integers, the shift amount can be of any integral\n+            // type. For simd, the type must match exactly.\n+            if ty::type_is_simd(tcx, lhs_ty) {\n+                demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n+            }\n+\n+            // result type is same as LHS always\n+            lhs_ty\n+        }\n+\n+        BinOpCategory::Math |\n+        BinOpCategory::Bitwise => {\n+            // both LHS and RHS and result will have the same type\n+            demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n+            lhs_ty\n+        }\n+\n+        BinOpCategory::Comparison => {\n+            // both LHS and RHS and result will have the same type\n+            demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n+\n+            // if this is simd, result is same as lhs, else bool\n+            if ty::type_is_simd(tcx, lhs_ty) {\n+                let unit_ty = ty::simd_type(tcx, lhs_ty);\n+                debug!(\"enforce_builtin_binop_types: lhs_ty={} unit_ty={}\",\n+                       lhs_ty.repr(tcx),\n+                       unit_ty.repr(tcx));\n+                if !ty::type_is_integral(unit_ty) {\n+                    tcx.sess.span_err(\n+                        lhs_expr.span,\n+                        &format!(\"binary comparison operation `{}` not supported \\\n+                                  for floating point SIMD vector `{}`\",\n+                                 ast_util::binop_to_string(op.node),\n+                                 lhs_ty.user_string(tcx)));\n+                    tcx.types.err\n+                } else {\n+                    lhs_ty\n+                }\n+            } else {\n+                ty::mk_bool(tcx)\n+            }\n+        }\n+    }\n+}\n+\n+fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                    expr: &'tcx ast::Expr,\n+                                    lhs_expr: &'tcx ast::Expr,\n+                                    lhs_ty: Ty<'tcx>,\n+                                    rhs_expr: &'tcx ast::Expr,\n+                                    op: ast::BinOp)\n+                                    -> (Ty<'tcx>, Ty<'tcx>)\n+{\n+    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={})\",\n+           expr.id,\n+           lhs_ty.repr(fcx.tcx()));\n+\n+    let (name, trait_def_id) = name_and_trait_def_id(fcx, op);\n+\n+    // NB: As we have not yet type-checked the RHS, we don't have the\n+    // type at hand. Make a variable to represent it. The whole reason\n+    // for this indirection is so that, below, we can check the expr\n+    // using this variable as the expected type, which sometimes lets\n+    // us do better coercions than we would be able to do otherwise,\n+    // particularly for things like `String + &String`.\n+    let rhs_ty_var = fcx.infcx().next_ty_var();\n+\n+    let return_ty = match lookup_op_method(fcx, expr, lhs_ty, vec![rhs_ty_var],\n+                                           token::intern(name), trait_def_id,\n+                                           lhs_expr) {\n+        Ok(return_ty) => return_ty,\n+        Err(()) => {\n+            // error types are considered \"builtin\"\n+            if !ty::type_is_error(lhs_ty) {\n+                span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n+                          \"binary operation `{}` cannot be applied to type `{}`\",\n+                          ast_util::binop_to_string(op.node),\n+                          lhs_ty.user_string(fcx.tcx()));\n+            }\n+            fcx.tcx().types.err\n+        }\n+    };\n+\n+    // see `NB` above\n+    check_expr_coercable_to_type(fcx, rhs_expr, rhs_ty_var);\n+\n+    (rhs_ty_var, return_ty)\n+}\n+\n+pub fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 op_str: &str,\n+                                 mname: &str,\n+                                 trait_did: Option<ast::DefId>,\n+                                 ex: &'tcx ast::Expr,\n+                                 operand_expr: &'tcx ast::Expr,\n+                                 operand_ty: Ty<'tcx>,\n+                                 op: ast::UnOp)\n+                                 -> Ty<'tcx>\n+{\n+    assert!(ast_util::is_by_value_unop(op));\n+    match lookup_op_method(fcx, ex, operand_ty, vec![],\n+                           token::intern(mname), trait_did,\n+                           operand_expr) {\n+        Ok(t) => t,\n+        Err(()) => {\n+            fcx.type_error_message(ex.span, |actual| {\n+                format!(\"cannot apply unary operator `{}` to type `{}`\",\n+                        op_str, actual)\n+            }, operand_ty, None);\n+            fcx.tcx().types.err\n+        }\n+    }\n+}\n+\n+fn name_and_trait_def_id(fcx: &FnCtxt, op: ast::BinOp) -> (&'static str, Option<ast::DefId>) {\n+    let lang = &fcx.tcx().lang_items;\n+    match op.node {\n+        ast::BiAdd => (\"add\", lang.add_trait()),\n+        ast::BiSub => (\"sub\", lang.sub_trait()),\n+        ast::BiMul => (\"mul\", lang.mul_trait()),\n+        ast::BiDiv => (\"div\", lang.div_trait()),\n+        ast::BiRem => (\"rem\", lang.rem_trait()),\n+        ast::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n+        ast::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n+        ast::BiBitOr => (\"bitor\", lang.bitor_trait()),\n+        ast::BiShl => (\"shl\", lang.shl_trait()),\n+        ast::BiShr => (\"shr\", lang.shr_trait()),\n+        ast::BiLt => (\"lt\", lang.ord_trait()),\n+        ast::BiLe => (\"le\", lang.ord_trait()),\n+        ast::BiGe => (\"ge\", lang.ord_trait()),\n+        ast::BiGt => (\"gt\", lang.ord_trait()),\n+        ast::BiEq => (\"eq\", lang.eq_trait()),\n+        ast::BiNe => (\"ne\", lang.eq_trait()),\n+        ast::BiAnd | ast::BiOr => {\n+            fcx.tcx().sess.span_bug(op.span, \"&& and || are not overloadable\")\n+        }\n+    }\n+}\n+\n+fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+                              expr: &'tcx ast::Expr,\n+                              lhs_ty: Ty<'tcx>,\n+                              other_tys: Vec<Ty<'tcx>>,\n+                              opname: ast::Name,\n+                              trait_did: Option<ast::DefId>,\n+                              lhs_expr: &'a ast::Expr)\n+                              -> Result<Ty<'tcx>,()>\n+{\n+    debug!(\"lookup_op_method(expr={}, lhs_ty={}, opname={:?}, trait_did={}, lhs_expr={})\",\n+           expr.repr(fcx.tcx()),\n+           lhs_ty.repr(fcx.tcx()),\n+           opname,\n+           trait_did.repr(fcx.tcx()),\n+           lhs_expr.repr(fcx.tcx()));\n+\n+    let method = match trait_did {\n+        Some(trait_did) => {\n+            // We do eager coercions to make using operators\n+            // more ergonomic:\n+            //\n+            // - If the input is of type &'a T (resp. &'a mut T),\n+            //   then reborrow it to &'b T (resp. &'b mut T) where\n+            //   'b <= 'a.  This makes things like `x == y`, where\n+            //   `x` and `y` are both region pointers, work.  We\n+            //   could also solve this with variance or different\n+            //   traits that don't force left and right to have same\n+            //   type.\n+            let (adj_ty, adjustment) = match lhs_ty.sty {\n+                ty::ty_rptr(r_in, mt) => {\n+                    let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs_expr.span));\n+                    fcx.mk_subr(infer::Reborrow(lhs_expr.span), r_adj, *r_in);\n+                    let adjusted_ty = ty::mk_rptr(fcx.tcx(), fcx.tcx().mk_region(r_adj), mt);\n+                    let autoptr = ty::AutoPtr(r_adj, mt.mutbl, None);\n+                    let adjustment = ty::AutoDerefRef { autoderefs: 1, autoref: Some(autoptr) };\n+                    (adjusted_ty, adjustment)\n+                }\n+                _ => {\n+                    (lhs_ty, ty::AutoDerefRef { autoderefs: 0, autoref: None })\n+                }\n+            };\n+\n+            debug!(\"adjusted_ty={} adjustment={:?}\",\n+                   adj_ty.repr(fcx.tcx()),\n+                   adjustment);\n+\n+            method::lookup_in_trait_adjusted(fcx, expr.span, Some(lhs_expr), opname,\n+                                             trait_did, adjustment, adj_ty, Some(other_tys))\n+        }\n+        None => None\n+    };\n+\n+    match method {\n+        Some(method) => {\n+            let method_ty = method.ty;\n+\n+            // HACK(eddyb) Fully qualified path to work around a resolve bug.\n+            let method_call = ::middle::ty::MethodCall::expr(expr.id);\n+            fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+\n+            // extract return type for method; all late bound regions\n+            // should have been instantiated by now\n+            let ret_ty = ty::ty_fn_ret(method_ty);\n+            Ok(ty::no_late_bound_regions(fcx.tcx(), &ret_ty).unwrap().unwrap())\n+        }\n+        None => {\n+            Err(())\n+        }\n+    }\n+}\n+\n+// Binary operator categories. These categories summarize the behavior\n+// with respect to the builtin operationrs supported.\n+enum BinOpCategory {\n+    /// &&, || -- cannot be overridden\n+    Shortcircuit,\n+\n+    /// <<, >> -- when shifting a single integer, rhs can be any\n+    /// integer type. For simd, types must match.\n+    Shift,\n+\n+    /// +, -, etc -- takes equal types, produces same type as input,\n+    /// applicable to ints/floats/simd\n+    Math,\n+\n+    /// &, |, ^ -- takes equal types, produces same type as input,\n+    /// applicable to ints/floats/simd/bool\n+    Bitwise,\n+\n+    /// ==, !=, etc -- takes equal types, produces bools, except for simd,\n+    /// which produce the input type\n+    Comparison,\n+}\n+\n+impl BinOpCategory {\n+    fn from(op: ast::BinOp) -> BinOpCategory {\n+        match op.node {\n+            ast::BiShl | ast::BiShr =>\n+                BinOpCategory::Shift,\n+\n+            ast::BiAdd |\n+            ast::BiSub |\n+            ast::BiMul |\n+            ast::BiDiv |\n+            ast::BiRem =>\n+                BinOpCategory::Math,\n+\n+            ast::BiBitXor |\n+            ast::BiBitAnd |\n+            ast::BiBitOr =>\n+                BinOpCategory::Bitwise,\n+\n+            ast::BiEq |\n+            ast::BiNe |\n+            ast::BiLt |\n+            ast::BiLe |\n+            ast::BiGe |\n+            ast::BiGt =>\n+                BinOpCategory::Comparison,\n+\n+            ast::BiAnd |\n+            ast::BiOr =>\n+                BinOpCategory::Shortcircuit,\n+        }\n+    }\n+}\n+\n+/// Returns true if this is a built-in arithmetic operation (e.g. u32\n+/// + u32, i16x4 == i16x4) and false if these types would have to be\n+/// overloaded to be legal. There are two reasons that we distinguish\n+/// builtin operations from overloaded ones (vs trying to drive\n+/// everything uniformly through the trait system and intrinsics or\n+/// something like that):\n+///\n+/// 1. Builtin operations can trivially be evaluated in constants.\n+/// 2. For comparison operators applied to SIMD types the result is\n+///    not of type `bool`. For example, `i16x4==i16x4` yields a\n+///    type like `i16x4`. This means that the overloaded trait\n+///    `PartialEq` is not applicable.\n+///\n+/// Reason #2 is the killer. I tried for a while to always use\n+/// overloaded logic and just check the types in constants/trans after\n+/// the fact, and it worked fine, except for SIMD types. -nmatsakis\n+fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n+                          lhs: Ty<'tcx>,\n+                          rhs: Ty<'tcx>,\n+                          op: ast::BinOp)\n+                          -> bool\n+{\n+    match BinOpCategory::from(op) {\n+        BinOpCategory::Shortcircuit => {\n+            true\n+        }\n+\n+        BinOpCategory::Shift => {\n+            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n+                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n+                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+        }\n+\n+        BinOpCategory::Math => {\n+            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n+                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n+                ty::type_is_floating_point(lhs) && ty::type_is_floating_point(rhs) ||\n+                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+        }\n+\n+        BinOpCategory::Bitwise => {\n+            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n+                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n+                ty::type_is_floating_point(lhs) && ty::type_is_floating_point(rhs) ||\n+                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs) ||\n+                ty::type_is_bool(lhs) && ty::type_is_bool(rhs)\n+        }\n+\n+        BinOpCategory::Comparison => {\n+            ty::type_is_error(lhs) || ty::type_is_error(rhs) ||\n+                ty::type_is_scalar(lhs) && ty::type_is_scalar(rhs) ||\n+                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+        }\n+    }\n+}\n+"}, {"sha": "4d7a046fc607bd125df812c1d6fd86d5343b76af", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -26,6 +26,7 @@ use util::ppaux::Repr;\n use std::cell::Cell;\n \n use syntax::ast;\n+use syntax::ast_util;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::print::pprust::pat_to_string;\n use syntax::visit;\n@@ -113,6 +114,31 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n+        // Hacky hack: During type-checking, we treat *all* operators\n+        // as potentially overloaded. But then, during writeback, if\n+        // we observe that something like `a+b` is (known to be)\n+        // operating on scalars, we clear the overload.\n+        match e.node {\n+            ast::ExprBinary(ref op, ref lhs, ref rhs) => {\n+                let lhs_ty = self.fcx.expr_ty(lhs);\n+                let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n+                let rhs_ty = self.fcx.expr_ty(rhs);\n+                let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+                if ty::type_is_scalar(lhs_ty) && ty::type_is_scalar(rhs_ty) {\n+                    self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n+\n+                    // weird but true: the by-ref binops put an\n+                    // adjustment on the lhs but not the rhs; the\n+                    // adjustment for rhs is kind of baked into the\n+                    // system.\n+                    if !ast_util::is_by_value_binop(op.node) {\n+                        self.fcx.inh.adjustments.borrow_mut().remove(&lhs.id);\n+                    }\n+                }\n+            }\n+            _ => { }\n+        }\n+\n         self.visit_node_id(ResolvingExpr(e.span), e.id);\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n                                     MethodCall::expr(e.id));"}, {"sha": "7d01bece01cb808188d027b30b37b22736fbbb49", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -179,7 +179,9 @@ register_diagnostics! {\n     E0321, // extended coherence rules for defaulted traits violated\n     E0322, // cannot implement Sized explicitly\n     E0366, // dropck forbid specialization to concrete type or region\n-    E0367  // dropck forbid specialization to predicate not in struct/enum\n+    E0367, // dropck forbid specialization to predicate not in struct/enum\n+    E0368, // binary operation `<op>=` cannot be applied to types\n+    E0369  // binary operation `<op>` cannot be applied to types\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "b83b42c73e70899895dcd2e8f7ed367ef1859176", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -86,33 +86,17 @@ pub fn is_shift_binop(b: BinOp_) -> bool {\n \n pub fn is_comparison_binop(b: BinOp_) -> bool {\n     match b {\n-        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n-        _ => false\n+        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe =>\n+            true,\n+        BiAnd | BiOr | BiAdd | BiSub | BiMul | BiDiv | BiRem |\n+        BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr =>\n+            false,\n     }\n }\n \n /// Returns `true` if the binary operator takes its arguments by value\n pub fn is_by_value_binop(b: BinOp_) -> bool {\n-    match b {\n-        BiAdd | BiSub | BiMul | BiDiv | BiRem | BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr => {\n-            true\n-        }\n-        _ => false\n-    }\n-}\n-\n-/// Returns `true` if the binary operator is symmetric in the sense that LHS\n-/// and RHS must have the same type. So the type of LHS can serve as an hint\n-/// for the type of RHS and vice versa.\n-pub fn is_symmetric_binop(b: BinOp_) -> bool {\n-    match b {\n-        BiAdd | BiSub | BiMul | BiDiv | BiRem |\n-        BiBitXor | BiBitAnd | BiBitOr |\n-        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => {\n-            true\n-        }\n-        _ => false\n-    }\n+    !is_comparison_binop(b)\n }\n \n /// Returns `true` if the unary operator takes its argument by value"}, {"sha": "72dfc75f41b969747eba45465ab47b37a773825d", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -32,3 +32,22 @@ extern fn eh_personality() {}\n pub trait Copy : PhantomFn<Self> {\n     // Empty.\n }\n+\n+#[lang=\"rem\"]\n+pub trait Rem<RHS=Self> {\n+    type Output = Self;\n+    fn rem(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Rem for isize {\n+    type Output = isize;\n+\n+    #[inline]\n+    fn rem(self, other: isize) -> isize {\n+        // if you use `self % other` here, as one would expect, you\n+        // get back an error because of potential failure/overflow,\n+        // which tries to invoke error fns that don't have the\n+        // appropriate signatures anymore. So...just return 0.\n+        0\n+    }\n+}"}, {"sha": "d6577036b8ebed47d03ac9802dc8ddc03eea3022", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -29,7 +29,7 @@ fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n \n fn random_gradient<R: Rng>(r: &mut R) -> Vec2 {\n-    let v = PI * 2.0 * r.gen();\n+    let v = PI * 2.0 * r.gen::<f32>();\n     Vec2 { x: v.cos(), y: v.sin() }\n }\n "}, {"sha": "fef27af59571b186748d84cc7aed01b6d41b5d48", "filename": "src/test/compile-fail/assignment-operator-unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fassignment-operator-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fassignment-operator-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassignment-operator-unimplemented.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -13,5 +13,5 @@ struct Foo;\n fn main() {\n   let mut a = Foo;\n   let ref b = Foo;\n-  a += *b; //~ Error: binary assignment operation `+=` cannot be applied to type `Foo`\n+  a += *b; //~ Error: binary assignment operation `+=` cannot be applied to types `Foo` and `Foo`\n }"}, {"sha": "04170779ed2f6b05ae583cbdd7019c1bfa8acd6a", "filename": "src/test/compile-fail/associated-types-ICE-when-projecting-out-of-err.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -35,5 +35,6 @@ trait Add<RHS=Self> {\n fn ice<A>(a: A) {\n     let r = loop {};\n     r = r + a;\n-    //~^ ERROR binary operation `+` cannot be applied to type `A`\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }"}, {"sha": "f3fb5a08c854189ecbd74d5e1302c33e1dae045e", "filename": "src/test/compile-fail/binop-logic-float.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-logic-float.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:`||` cannot be applied to type `f32`\n-\n fn main() { let x = 1.0_f32 || 2.0_f32; }\n+//~^ ERROR mismatched types\n+//~| ERROR mismatched types\n+"}, {"sha": "f5e53f84c16e6472dc4b39c3aca8a084cba288e7", "filename": "src/test/compile-fail/binop-logic-int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:`&&` cannot be applied to type `_`\n-\n fn main() { let x = 1 && 2; }\n+//~^ ERROR mismatched types\n+//~| ERROR mismatched types"}, {"sha": "27be1ada445505dbd4c54d5aad0996cf178135ea", "filename": "src/test/compile-fail/fn-compare-mismatch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -13,4 +13,5 @@ fn main() {\n     fn g() { }\n     let x = f == g;\n     //~^ ERROR binary operation `==` cannot be applied\n+    //~| ERROR mismatched types\n }"}, {"sha": "40fc6b1ed6aaacebf6a682e43b67d369b5dff5ab", "filename": "src/test/compile-fail/issue-11771.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fissue-11771.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fissue-11771.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11771.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -11,19 +11,13 @@\n fn main() {\n     let x = ();\n     1 +\n-    x //~  ERROR mismatched types\n-      //~| expected `_`\n-      //~| found `()`\n-      //~| expected integral variable\n-      //~| found ()\n+    x //~^ ERROR E0277\n+      //~| ERROR E0277\n     ;\n \n     let x: () = ();\n     1 +\n-    x //~  ERROR mismatched types\n-      //~| expected `_`\n-      //~| found `()`\n-      //~| expected integral variable\n-      //~| found ()\n+    x //~^ ERROR E0277\n+      //~| ERROR E0277\n     ;\n }"}, {"sha": "a8c8c8b40c1b6c3db69e16abbecb7b8822b75c3f", "filename": "src/test/compile-fail/issue-13352.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -23,4 +23,6 @@ fn main() {\n         unsafe { libc::exit(0 as libc::c_int); }\n     });\n     2_usize + (loop {});\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n }", "previous_filename": "src/test/run-pass/issue-13352.rs"}, {"sha": "ea305c96af4a1efa39f788effa5df7a31b99aad8", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -16,7 +16,8 @@ impl<A> vec_monad<A> for Vec<A> {\n     fn bind<B, F>(&self, mut f: F) where F: FnMut(A) -> Vec<B> {\n         let mut r = panic!();\n         for elt in self { r = r + f(*elt); }\n-        //~^ ERROR binary operation `+` cannot be applied to type `collections::vec::Vec<B>`\n+        //~^ ERROR E0277\n+        //~| ERROR E0277\n    }\n }\n fn main() {"}, {"sha": "1ebef06008ffa4f3c6b345dee1cd6110d7d62132", "filename": "src/test/compile-fail/issue-5239-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5239-1.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let x = |ref x: isize| -> isize { x += 1; };\n-    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&isize`\n+    //~^ ERROR E0368\n }"}, {"sha": "24b66213b39bd410cdffb9d011bd6b38caa63ab4", "filename": "src/test/compile-fail/shift-various-bad-types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -17,19 +17,19 @@ struct Panolpy {\n \n fn foo(p: &Panolpy) {\n     22 >> p.char;\n-    //~^ ERROR right-hand-side of a shift operation must have integral type\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n \n     22 >> p.str;\n-    //~^ ERROR right-hand-side of a shift operation must have integral type\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n \n     22 >> p;\n-    //~^ ERROR right-hand-side of a shift operation must have integral type\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n \n-    // We could be more accepting in the case of a type not yet inferred, but not\n-    // known to be an integer, but meh.\n     let x;\n-    22 >> x;\n-    //~^ ERROR the type of this value must be known in this context\n+    22 >> x; // ambiguity error winds up being suppressed\n \n     22 >> 1;\n     // Integer literal types are OK"}, {"sha": "feffe5c0b06c8e09fc10dcd75c68c9cec4ff21f6", "filename": "src/test/compile-fail/simd-binop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-tidy-linelength\n \n+#![feature(core)]\n \n use std::simd::f32x4;\n "}, {"sha": "75a6b919342bf81b4f447bb6fba66eb3b1827610", "filename": "src/test/pretty/issue-929.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/14192d6df5cc714e5c9a3ca70b08f2514d977be2/src%2Ftest%2Fpretty%2Fissue-929.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14192d6df5cc714e5c9a3ca70b08f2514d977be2/src%2Ftest%2Fpretty%2Fissue-929.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-929.rs?ref=14192d6df5cc714e5c9a3ca70b08f2514d977be2", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn f() { if (1 == panic!()) { } else { } }\n-\n-fn main() { }"}, {"sha": "8cabd3b326296aa34362aeedaa51285fb63bd50b", "filename": "src/test/run-fail/binop-fail-3.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-fail%2Fbinop-fail-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-fail%2Fbinop-fail-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail-3.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// error-pattern:quux\n fn foo() -> ! { panic!(\"quux\"); }\n fn main() {\n-    foo() //~ ERROR the type of this value must be known in this context\n-    ==\n-    foo();\n+    foo() == foo(); // these types wind up being defaulted to ()\n }", "previous_filename": "src/test/compile-fail/binop-fail-3.rs"}, {"sha": "4d502cb2106b116eaa6eb28e8cedfcfcd72449be", "filename": "src/test/run-fail/bounds-check-no-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:index out of bounds: the len is 3 but the index is\n+// error-pattern:assertion failed: index < self.len()\n \n use std::usize;\n use std::mem::size_of;"}, {"sha": "01c85023eda39a23d9ccba58c1e7955efe30d0cc", "filename": "src/test/run-pass/binops-issue-22743.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fbinops-issue-22743.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fbinops-issue-22743.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops-issue-22743.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Mul;\n+\n+#[derive(Copy)]\n+pub struct Foo {\n+    x: f64,\n+}\n+\n+impl Mul<Foo> for f64 {\n+    type Output = Foo;\n+\n+    fn mul(self, rhs: Foo) -> Foo {\n+        // intentionally do something that is not *\n+        Foo { x: self + rhs.x }\n+    }\n+}\n+\n+pub fn main() {\n+    let f: Foo = Foo { x: 5.0 };\n+    let val: f64 = 3.0;\n+    let f2: Foo = val * f;\n+    assert_eq!(f2.x, 8.0);\n+}"}, {"sha": "5e0e5bd03fe6fa5180d10535065c4d929701c0c6", "filename": "src/test/run-pass/dst-raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-raw.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -56,7 +56,7 @@ pub fn main() {\n     }\n \n     // raw slice with explicit cast\n-    let a = &[1, 2, 3] as *const [_];\n+    let a = &[1, 2, 3] as *const [i32];\n     unsafe {\n         let b = (*a)[2];\n         assert!(b == 3);\n@@ -96,7 +96,7 @@ pub fn main() {\n         assert!(len == 3);\n     }\n \n-    let a = &mut [1, 2, 3] as *mut [_];\n+    let a = &mut [1, 2, 3] as *mut [i32];\n     unsafe {\n         let b = (*a)[2];\n         assert!(b == 3);"}, {"sha": "7bd292e66f2585975499986084be4eb6fd63132d", "filename": "src/test/run-pass/early-ret-binop-add.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -10,5 +10,8 @@\n \n // pretty-expanded FIXME #23616\n \n-fn wsucc(n: isize) -> isize { 0 + { return n + 1 } }\n+use std::num::Int;\n+\n+fn wsucc<T:Int>(n: T) -> T { n + { return n } }\n+\n pub fn main() { }"}, {"sha": "6e1cfc7186299e0eabc40c9c20ed32e5ce8e380a", "filename": "src/test/run-pass/issue-1460.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fissue-1460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fissue-1460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1460.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -12,5 +12,5 @@\n // pretty-expanded FIXME #23616\n \n pub fn main() {\n-    {|i| if 1 == i { }};\n+    {|i: u32| if 1 == i { }};\n }"}, {"sha": "33842fab6989cecf2df6720b630aadb74599b6bf", "filename": "src/test/run-pass/issue-16560.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fissue-16560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fissue-16560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16560.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -17,7 +17,7 @@ use std::mem;\n \n fn main() {\n     let y = 0u8;\n-    let closure = move |x| y + x;\n+    let closure = move |x: u8| y + x;\n \n     // Check that both closures are capturing by value\n     assert_eq!(1, mem::size_of_val(&closure));"}, {"sha": "fe540e1aabef8b6a4582d9c13025901fac25ea41", "filename": "src/test/run-pass/issue-21634.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fissue-21634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fissue-21634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21634.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -12,13 +12,13 @@\n // pretty-expanded FIXME #23616\n \n fn main() {\n-    if let Ok(x) = \"3.1415\".parse() {\n+    if let Ok(x) = \"3.1415\".parse::<f64>() {\n         assert_eq!(false, x <= 0.0);\n     }\n-    if let Ok(x) = \"3.1415\".parse() {\n+    if let Ok(x) = \"3.1415\".parse::<f64>() {\n         assert_eq!(3.1415, x + 0.0);\n     }\n-    if let Ok(mut x) = \"3.1415\".parse() {\n+    if let Ok(mut x) = \"3.1415\".parse::<f64>() {\n         assert_eq!(8.1415, { x += 5.0; x });\n     }\n }"}, {"sha": "7d8c4ab210d002e1d09d60564f4d41e565aed1f7", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -25,19 +25,19 @@ fn main() {\n     assert!(thread::spawn(move|| { min_val::<i16>() / -1; }).join().is_err());\n     assert!(thread::spawn(move|| { min_val::<i32>() / -1; }).join().is_err());\n     assert!(thread::spawn(move|| { min_val::<i64>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { 1isize / zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i8 / zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i16 / zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i32 / zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i64 / zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1isize / zero::<isize>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i8 / zero::<i8>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i16 / zero::<i16>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i32 / zero::<i32>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i64 / zero::<i64>(); }).join().is_err());\n     assert!(thread::spawn(move|| { min_val::<isize>() % -1; }).join().is_err());\n     assert!(thread::spawn(move|| { min_val::<i8>() % -1; }).join().is_err());\n     assert!(thread::spawn(move|| { min_val::<i16>() % -1; }).join().is_err());\n     assert!(thread::spawn(move|| { min_val::<i32>() % -1; }).join().is_err());\n     assert!(thread::spawn(move|| { min_val::<i64>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { 1isize % zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i8 % zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i16 % zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i32 % zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i64 % zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1isize % zero::<isize>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i8 % zero::<i8>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i16 % zero::<i16>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i32 % zero::<i32>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i64 % zero::<i64>(); }).join().is_err());\n }"}, {"sha": "f5b9bd4fbaa69b800f332b2e333afe0975358c90", "filename": "src/test/run-pass/lang-item-public.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flang-item-public.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -46,5 +46,5 @@ extern {}\n \n #[start]\n fn main(_: isize, _: *const *const u8) -> isize {\n-    1 % 1\n+    1_isize % 1_isize\n }"}, {"sha": "3efd913cf543c935789d7a69a52dfc0723895fb5", "filename": "src/test/run-pass/reexported-static-methods-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de34a84bb300bab1bf0227f577331620cd60511/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs?ref=9de34a84bb300bab1bf0227f577331620cd60511", "patch": "@@ -19,8 +19,8 @@ use reexported_static_methods::Boz;\n use reexported_static_methods::Bort;\n \n pub fn main() {\n-    assert_eq!(42, Foo::foo());\n-    assert_eq!(84, Baz::bar());\n+    assert_eq!(42_isize, Foo::foo());\n+    assert_eq!(84_isize, Baz::bar());\n     assert!(Boz::boz(1));\n     assert_eq!(\"bort()\".to_string(), Bort::bort());\n }"}]}