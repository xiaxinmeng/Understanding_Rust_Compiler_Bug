{"sha": "339603426e65896a06fcebf63f3d751f242ee820", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzOTYwMzQyNmU2NTg5NmEwNmZjZWJmNjNmM2Q3NTFmMjQyZWU4MjA=", "commit": {"author": {"name": "Nathaniel Herman", "email": "nherman@college.harvard.edu", "date": "2014-01-25T20:33:31Z"}, "committer": {"name": "Nathaniel Herman", "email": "nherman@college.harvard.edu", "date": "2014-01-30T23:41:43Z"}, "message": "Make pop_ref and mut_pop_ref return Option instead of failing on empty vectors", "tree": {"sha": "0cc19e1edca4c43dd845199b8d08831777fe1b9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cc19e1edca4c43dd845199b8d08831777fe1b9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/339603426e65896a06fcebf63f3d751f242ee820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/339603426e65896a06fcebf63f3d751f242ee820", "html_url": "https://github.com/rust-lang/rust/commit/339603426e65896a06fcebf63f3d751f242ee820", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/339603426e65896a06fcebf63f3d751f242ee820/comments", "author": {"login": "nathanielherman", "id": 5169954, "node_id": "MDQ6VXNlcjUxNjk5NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5169954?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathanielherman", "html_url": "https://github.com/nathanielherman", "followers_url": "https://api.github.com/users/nathanielherman/followers", "following_url": "https://api.github.com/users/nathanielherman/following{/other_user}", "gists_url": "https://api.github.com/users/nathanielherman/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathanielherman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathanielherman/subscriptions", "organizations_url": "https://api.github.com/users/nathanielherman/orgs", "repos_url": "https://api.github.com/users/nathanielherman/repos", "events_url": "https://api.github.com/users/nathanielherman/events{/privacy}", "received_events_url": "https://api.github.com/users/nathanielherman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nathanielherman", "id": 5169954, "node_id": "MDQ6VXNlcjUxNjk5NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5169954?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathanielherman", "html_url": "https://github.com/nathanielherman", "followers_url": "https://api.github.com/users/nathanielherman/followers", "following_url": "https://api.github.com/users/nathanielherman/following{/other_user}", "gists_url": "https://api.github.com/users/nathanielherman/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathanielherman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathanielherman/subscriptions", "organizations_url": "https://api.github.com/users/nathanielherman/orgs", "repos_url": "https://api.github.com/users/nathanielherman/repos", "events_url": "https://api.github.com/users/nathanielherman/events{/privacy}", "received_events_url": "https://api.github.com/users/nathanielherman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d451c150570a7da02314795abd6777c80f361e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/d451c150570a7da02314795abd6777c80f361e93", "html_url": "https://github.com/rust-lang/rust/commit/d451c150570a7da02314795abd6777c80f361e93"}], "stats": {"total": 46, "additions": 21, "deletions": 25}, "files": [{"sha": "a4c5038626232c184a48486bd6b527fc46f07557", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/339603426e65896a06fcebf63f3d751f242ee820/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339603426e65896a06fcebf63f3d751f242ee820/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=339603426e65896a06fcebf63f3d751f242ee820", "patch": "@@ -325,7 +325,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n             &mut self.remaining1\n         };\n         self.nelts -= 1;\n-        Some(r.mut_pop_ref().get_mut_ref())\n+        Some(r.mut_pop_ref().unwrap().get_mut_ref())\n     }\n }\n "}, {"sha": "81e3e6c7eda5ff97cfa344f1ec81bd9da1b27e86", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/339603426e65896a06fcebf63f3d751f242ee820/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339603426e65896a06fcebf63f3d751f242ee820/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=339603426e65896a06fcebf63f3d751f242ee820", "patch": "@@ -1017,14 +1017,15 @@ pub trait ImmutableVector<'a, T> {\n      * Equivalent to:\n      *\n      * ```\n+     *     if self.len() == 0 { return None; }\n      *     let tail = &self[self.len() - 1];\n      *     *self = self.slice_to(self.len() - 1);\n-     *     tail\n+     *     Some(tail)\n      * ```\n      *\n-     * Fails if slice is empty.\n+     * Returns `None` if slice is empty.\n      */\n-    fn pop_ref(&mut self) -> &'a T;\n+    fn pop_ref(&mut self) -> Option<&'a T>;\n }\n \n impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n@@ -1191,10 +1192,11 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n         }\n     }\n \n-    fn pop_ref(&mut self) -> &'a T {\n+    fn pop_ref(&mut self) -> Option<&'a T> {\n+        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n-            &*raw::pop_ptr(s)\n+            Some(&*raw::pop_ptr(s))\n         }\n     }\n }\n@@ -2077,14 +2079,15 @@ pub trait MutableVector<'a, T> {\n      * Equivalent to:\n      *\n      * ```\n+     *     if self.len() == 0 { return None; }\n      *     let tail = &mut self[self.len() - 1];\n      *     *self = self.mut_slice_to(self.len() - 1);\n-     *     tail\n+     *     Some(tail)\n      * ```\n      *\n-     * Fails if slice is empty.\n+     * Returns `None` if slice is empty.\n      */\n-    fn mut_pop_ref(&mut self) -> &'a mut T;\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n \n     /// Swaps two elements in a vector.\n     ///\n@@ -2325,10 +2328,11 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         }\n     }\n \n-    fn mut_pop_ref(&mut self) -> &'a mut T {\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n+        if self.len() == 0 { return None; }\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n-            cast::transmute_mut(&*raw::pop_ptr(s))\n+            Some(cast::transmute_mut(&*raw::pop_ptr(s)))\n         }\n     }\n \n@@ -4211,17 +4215,13 @@ mod tests {\n     fn test_pop_ref() {\n         let mut x: &[int] = [1, 2, 3, 4, 5];\n         let h = x.pop_ref();\n-        assert_eq!(*h, 5);\n+        assert_eq!(*h.unwrap(), 5);\n         assert_eq!(x.len(), 4);\n         assert_eq!(x[0], 1);\n         assert_eq!(x[3], 4);\n-    }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_pop_ref_empty() {\n-        let mut x: &[int] = [];\n-        x.pop_ref();\n+        let mut y: &[int] = [];\n+        assert!(y.pop_ref().is_none());\n     }\n \n     #[test]\n@@ -4297,17 +4297,13 @@ mod tests {\n     fn test_mut_pop_ref() {\n         let mut x: &mut [int] = [1, 2, 3, 4, 5];\n         let h = x.mut_pop_ref();\n-        assert_eq!(*h, 5);\n+        assert_eq!(*h.unwrap(), 5);\n         assert_eq!(x.len(), 4);\n         assert_eq!(x[0], 1);\n         assert_eq!(x[3], 4);\n-    }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_mut_pop_ref_empty() {\n-        let mut x: &mut [int] = [];\n-        x.mut_pop_ref();\n+        let mut y: &mut [int] = [];\n+        assert!(y.mut_pop_ref().is_none());\n     }\n }\n "}]}