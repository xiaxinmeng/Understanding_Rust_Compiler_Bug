{"sha": "a535cfb1f04953e2307b0a2d1b3ddcfdf348009f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MzVjZmIxZjA0OTUzZTIzMDdiMGEyZDFiM2RkY2ZkZjM0ODAwOWY=", "commit": {"author": {"name": "Renato Zannon", "email": "renato@rrsz.com.br", "date": "2014-06-10T03:29:36Z"}, "committer": {"name": "Renato Zannon", "email": "renato@rrsz.com.br", "date": "2014-06-10T03:29:42Z"}, "message": "Remove & -> &mut transmute from Arena", "tree": {"sha": "c1276812c3ea9a823d93d11ba8b40ae54790bf09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1276812c3ea9a823d93d11ba8b40ae54790bf09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a535cfb1f04953e2307b0a2d1b3ddcfdf348009f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a535cfb1f04953e2307b0a2d1b3ddcfdf348009f", "html_url": "https://github.com/rust-lang/rust/commit/a535cfb1f04953e2307b0a2d1b3ddcfdf348009f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a535cfb1f04953e2307b0a2d1b3ddcfdf348009f/comments", "author": {"login": "renato-zannon", "id": 486508, "node_id": "MDQ6VXNlcjQ4NjUwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/486508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/renato-zannon", "html_url": "https://github.com/renato-zannon", "followers_url": "https://api.github.com/users/renato-zannon/followers", "following_url": "https://api.github.com/users/renato-zannon/following{/other_user}", "gists_url": "https://api.github.com/users/renato-zannon/gists{/gist_id}", "starred_url": "https://api.github.com/users/renato-zannon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/renato-zannon/subscriptions", "organizations_url": "https://api.github.com/users/renato-zannon/orgs", "repos_url": "https://api.github.com/users/renato-zannon/repos", "events_url": "https://api.github.com/users/renato-zannon/events{/privacy}", "received_events_url": "https://api.github.com/users/renato-zannon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "renato-zannon", "id": 486508, "node_id": "MDQ6VXNlcjQ4NjUwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/486508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/renato-zannon", "html_url": "https://github.com/renato-zannon", "followers_url": "https://api.github.com/users/renato-zannon/followers", "following_url": "https://api.github.com/users/renato-zannon/following{/other_user}", "gists_url": "https://api.github.com/users/renato-zannon/gists{/gist_id}", "starred_url": "https://api.github.com/users/renato-zannon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/renato-zannon/subscriptions", "organizations_url": "https://api.github.com/users/renato-zannon/orgs", "repos_url": "https://api.github.com/users/renato-zannon/repos", "events_url": "https://api.github.com/users/renato-zannon/events{/privacy}", "received_events_url": "https://api.github.com/users/renato-zannon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0855bccd356d191074a83c2aeedabd88d2b7bab", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0855bccd356d191074a83c2aeedabd88d2b7bab", "html_url": "https://github.com/rust-lang/rust/commit/e0855bccd356d191074a83c2aeedabd88d2b7bab"}], "stats": {"total": 90, "additions": 48, "deletions": 42}, "files": [{"sha": "b13eb5dc77ecc5ce8f2ac1d1df631608fda05f64", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a535cfb1f04953e2307b0a2d1b3ddcfdf348009f/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a535cfb1f04953e2307b0a2d1b3ddcfdf348009f/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a535cfb1f04953e2307b0a2d1b3ddcfdf348009f", "patch": "@@ -81,8 +81,8 @@ pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to access the\n     // head.\n-    head: Chunk,\n-    copy_head: Chunk,\n+    head: RefCell<Chunk>,\n+    copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n }\n \n@@ -95,8 +95,8 @@ impl Arena {\n     /// Allocate a new Arena with `initial_size` bytes preallocated.\n     pub fn new_with_size(initial_size: uint) -> Arena {\n         Arena {\n-            head: chunk(initial_size, false),\n-            copy_head: chunk(initial_size, true),\n+            head: RefCell::new(chunk(initial_size, false)),\n+            copy_head: RefCell::new(chunk(initial_size, true)),\n             chunks: RefCell::new(Vec::new()),\n         }\n     }\n@@ -114,7 +114,7 @@ fn chunk(size: uint, is_copy: bool) -> Chunk {\n impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n-            destroy_chunk(&self.head);\n+            destroy_chunk(&*self.head.borrow());\n             for chunk in self.chunks.borrow().iter() {\n                 if !chunk.is_copy.get() {\n                     destroy_chunk(chunk);\n@@ -171,38 +171,40 @@ fn un_bitpack_tydesc_ptr(p: uint) -> (*TyDesc, bool) {\n \n impl Arena {\n     fn chunk_size(&self) -> uint {\n-        self.copy_head.capacity()\n+        self.copy_head.borrow().capacity()\n     }\n+\n     // Functions for the POD part of the arena\n-    fn alloc_copy_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_copy_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.borrow_mut().push(self.copy_head.clone());\n-        self.copy_head =\n+        self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n+\n+        *self.copy_head.borrow_mut() =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), true);\n \n         return self.alloc_copy_inner(n_bytes, align);\n     }\n \n     #[inline]\n-    fn alloc_copy_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n-        unsafe {\n-            let start = round_up(self.copy_head.fill.get(), align);\n-            let end = start + n_bytes;\n-            if end > self.chunk_size() {\n-                return self.alloc_copy_grow(n_bytes, align);\n-            }\n-            self.copy_head.fill.set(end);\n+    fn alloc_copy_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n+        let start = round_up(self.copy_head.borrow().fill.get(), align);\n+\n+        let end = start + n_bytes;\n+        if end > self.chunk_size() {\n+            return self.alloc_copy_grow(n_bytes, align);\n+        }\n \n-            //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n-            //       start, n_bytes, align, head.fill.get());\n+        let copy_head = self.copy_head.borrow();\n+        copy_head.fill.set(end);\n \n-            self.copy_head.as_ptr().offset(start as int)\n+        unsafe {\n+            copy_head.as_ptr().offset(start as int)\n         }\n     }\n \n     #[inline]\n-    fn alloc_copy<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n+    fn alloc_copy<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n                                             mem::min_align_of::<T>());\n@@ -213,42 +215,48 @@ impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_noncopy_grow(&mut self, n_bytes: uint, align: uint)\n-                         -> (*u8, *u8) {\n+    fn alloc_noncopy_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n-        self.chunks.borrow_mut().push(self.head.clone());\n-        self.head =\n+        self.chunks.borrow_mut().push(self.head.borrow().clone());\n+\n+        *self.head.borrow_mut() =\n             chunk(num::next_power_of_two(new_min_chunk_size + 1u), false);\n \n         return self.alloc_noncopy_inner(n_bytes, align);\n     }\n \n     #[inline]\n-    fn alloc_noncopy_inner(&mut self, n_bytes: uint, align: uint)\n-                          -> (*u8, *u8) {\n-        unsafe {\n-            let tydesc_start = self.head.fill.get();\n-            let after_tydesc = self.head.fill.get() + mem::size_of::<*TyDesc>();\n+    fn alloc_noncopy_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+        // Be careful to not maintain any `head` borrows active, because\n+        // `alloc_noncopy_grow` borrows it mutably.\n+        let (start, end, tydesc_start, head_capacity) = {\n+            let head = self.head.borrow();\n+            let fill = head.fill.get();\n+\n+            let tydesc_start = fill;\n+            let after_tydesc = fill + mem::size_of::<*TyDesc>();\n             let start = round_up(after_tydesc, align);\n             let end = start + n_bytes;\n \n-            if end > self.head.capacity() {\n-                return self.alloc_noncopy_grow(n_bytes, align);\n-            }\n+            (start, end, tydesc_start, head.capacity())\n+        };\n \n-            self.head.fill.set(round_up(end, mem::align_of::<*TyDesc>()));\n+        if end > head_capacity {\n+            return self.alloc_noncopy_grow(n_bytes, align);\n+        }\n \n-            //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n-            //       start, n_bytes, align, head.fill);\n+        let head = self.head.borrow();\n+        head.fill.set(round_up(end, mem::align_of::<*TyDesc>()));\n \n-            let buf = self.head.as_ptr();\n+        unsafe {\n+            let buf = head.as_ptr();\n             return (buf.offset(tydesc_start as int), buf.offset(start as int));\n         }\n     }\n \n     #[inline]\n-    fn alloc_noncopy<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n+    fn alloc_noncopy<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n@@ -274,12 +282,10 @@ impl Arena {\n     #[inline]\n     pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n-            // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n-            let this: &mut Arena = mem::transmute::<&_, &mut _>(self);\n             if intrinsics::needs_drop::<T>() {\n-                this.alloc_noncopy(op)\n+                self.alloc_noncopy(op)\n             } else {\n-                this.alloc_copy(op)\n+                self.alloc_copy(op)\n             }\n         }\n     }"}]}