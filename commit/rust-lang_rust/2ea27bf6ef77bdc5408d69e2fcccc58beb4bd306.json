{"sha": "2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "node_id": "C_kwDOAAsO6NoAKDJlYTI3YmY2ZWY3N2JkYzU0MDhkNjllMmZjY2NjNThiZWI0YmQzMDY", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-12-03T02:27:47Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-12-03T02:27:47Z"}, "message": "Merge commit 'a8385522ade6f67853edac730b5bf164ddb298fd' into simd-remove-autosplats", "tree": {"sha": "a0187c96fbf0b7a0cef00c49676bf2485799d365", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0187c96fbf0b7a0cef00c49676bf2485799d365"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "html_url": "https://github.com/rust-lang/rust/commit/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff23ad3179014ba258f2b540fb39dd0f26852b7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff23ad3179014ba258f2b540fb39dd0f26852b7a", "html_url": "https://github.com/rust-lang/rust/commit/ff23ad3179014ba258f2b540fb39dd0f26852b7a"}, {"sha": "a8385522ade6f67853edac730b5bf164ddb298fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8385522ade6f67853edac730b5bf164ddb298fd", "html_url": "https://github.com/rust-lang/rust/commit/a8385522ade6f67853edac730b5bf164ddb298fd"}], "stats": {"total": 1063, "additions": 539, "deletions": 524}, "files": [{"sha": "9612fe871c619535792457795628fc7b687f16b1", "filename": "library/portable-simd/CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FCONTRIBUTING.md?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -15,7 +15,7 @@ SIMD can be quite complex, and even a \"simple\" issue can be huge. If an issue is\n \n ## CI\n \n-We currently have 2 CI matrices through Travis CI and GitHub Actions that will automatically build and test your change in order to verify that `std::simd`'s portable API is, in fact, portable. If your change builds locally, but does not build on either, this is likely due to a platform-specific concern that your code has not addressed. Please consult the build logs and address the error, or ask for help if you need it.\n+We currently use GitHub Actions which will automatically build and test your change in order to verify that `std::simd`'s portable API is, in fact, portable. If your change builds locally, but does not build in CI, this is likely due to a platform-specific concern that your code has not addressed. Please consult the build logs and address the error, or ask for help if you need it.\n \n ## Beyond stdsimd\n "}, {"sha": "db0af2da60641d4685d14589e882eccd534c3376", "filename": "library/portable-simd/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FREADME.md?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -1,5 +1,5 @@\n # The Rust standard library's portable SIMD API\n-[![Build Status](https://travis-ci.com/rust-lang/portable-simd.svg?branch=master)](https://travis-ci.com/rust-lang/portable-simd)\n+![Build Status](https://github.com/rust-lang/portable-simd/actions/workflows/ci.yml/badge.svg?branch=master)\n \n Code repository for the [Portable SIMD Project Group](https://github.com/rust-lang/project-portable-simd).\n Please refer to [CONTRIBUTING.md](./CONTRIBUTING.md) for our contributing guidelines."}, {"sha": "43280feebbd67cdd14ed33a08b579881118d3aa2", "filename": "library/portable-simd/crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -97,7 +97,7 @@ mod nbody {\n         let sun = &mut sun[0];\n         for body in rest {\n             let m_ratio = body.mass / SOLAR_MASS;\n-            sun.v -= body.v * m_ratio;\n+            sun.v -= body.v * Simd::splat(m_ratio);\n         }\n     }\n \n@@ -143,14 +143,14 @@ mod nbody {\n         let mut i = 0;\n         for j in 0..N_BODIES {\n             for k in j + 1..N_BODIES {\n-                let f = r[i] * mag[i];\n-                bodies[j].v -= f * bodies[k].mass;\n-                bodies[k].v += f * bodies[j].mass;\n+                let f = r[i] * Simd::splat(mag[i]);\n+                bodies[j].v -= f * Simd::splat(bodies[k].mass);\n+                bodies[k].v += f * Simd::splat(bodies[j].mass);\n                 i += 1\n             }\n         }\n         for body in bodies {\n-            body.x += dt * body.v\n+            body.x += Simd::splat(dt) * body.v\n         }\n     }\n "}, {"sha": "edef5af3687a27f4cd20099bdb6368ed4362d59d", "filename": "library/portable-simd/crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -8,12 +8,14 @@ where\n {\n     /// Test if each lane is equal to the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n     }\n \n     /// Test if each lane is not equal to the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n     }\n@@ -26,24 +28,28 @@ where\n {\n     /// Test if each lane is less than the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n     }\n \n     /// Test if each lane is greater than the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n     }\n \n     /// Test if each lane is less than or equal to the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n     }\n \n     /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n     }"}, {"sha": "3b316f12b3e56f50216975c555fac45cb2f6b8f8", "filename": "library/portable-simd/crates/core_simd/src/lane_count.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -15,34 +15,28 @@ impl<const LANES: usize> LaneCount<LANES> {\n pub trait SupportedLaneCount: Sealed {\n     #[doc(hidden)]\n     type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n-\n-    #[doc(hidden)]\n-    type IntBitMask;\n }\n \n impl<const LANES: usize> Sealed for LaneCount<LANES> {}\n \n impl SupportedLaneCount for LaneCount<1> {\n     type BitMask = [u8; 1];\n-    type IntBitMask = u8;\n }\n impl SupportedLaneCount for LaneCount<2> {\n     type BitMask = [u8; 1];\n-    type IntBitMask = u8;\n }\n impl SupportedLaneCount for LaneCount<4> {\n     type BitMask = [u8; 1];\n-    type IntBitMask = u8;\n }\n impl SupportedLaneCount for LaneCount<8> {\n     type BitMask = [u8; 1];\n-    type IntBitMask = u8;\n }\n impl SupportedLaneCount for LaneCount<16> {\n     type BitMask = [u8; 2];\n-    type IntBitMask = u16;\n }\n impl SupportedLaneCount for LaneCount<32> {\n     type BitMask = [u8; 4];\n-    type IntBitMask = u32;\n+}\n+impl SupportedLaneCount for LaneCount<64> {\n+    type BitMask = [u8; 8];\n }"}, {"sha": "191e96903133f2ad9fb164266cb1de6d56f29ec9", "filename": "library/portable-simd/crates/core_simd/src/masks.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -129,6 +129,7 @@ where\n     /// # Safety\n     /// All lanes must be either 0 or -1.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         unsafe { Self(mask_impl::Mask::from_int_unchecked(value)) }\n     }\n@@ -139,6 +140,7 @@ where\n     /// # Panics\n     /// Panics if any lane is not 0 or -1.\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_int(value: Simd<T, LANES>) -> Self {\n         assert!(T::valid(value), \"all values must be either 0 or -1\",);\n         unsafe { Self::from_int_unchecked(value) }\n@@ -147,6 +149,7 @@ where\n     /// Converts the mask to a vector of integers, where 0 represents `false` and -1\n     /// represents `true`.\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn to_int(self) -> Simd<T, LANES> {\n         self.0.to_int()\n     }\n@@ -156,6 +159,7 @@ where\n     /// # Safety\n     /// `lane` must be less than `LANES`.\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n         unsafe { self.0.test_unchecked(lane) }\n     }\n@@ -165,6 +169,7 @@ where\n     /// # Panics\n     /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn test(&self, lane: usize) -> bool {\n         assert!(lane < LANES, \"lane index out of range\");\n         unsafe { self.test_unchecked(lane) }\n@@ -195,24 +200,30 @@ where\n \n     /// Convert this mask to a bitmask, with one bit set per lane.\n     #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n     pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n         self.0.to_bitmask()\n     }\n \n     /// Convert a bitmask to a mask.\n     #[cfg(feature = \"generic_const_exprs\")]\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n         Self(mask_impl::Mask::from_bitmask(bitmask))\n     }\n \n     /// Returns true if any lane is set, or false otherwise.\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n         self.0.any()\n     }\n \n     /// Returns true if all lanes are set, or false otherwise.\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n         self.0.all()\n     }\n@@ -245,6 +256,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a defaulted mask with all lanes set to false (0)\"]\n     fn default() -> Self {\n         Self::splat(false)\n     }\n@@ -256,6 +268,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     fn eq(&self, other: &Self) -> bool {\n         self.0 == other.0\n     }\n@@ -267,6 +280,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new Ordering and does not mutate the original value\"]\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         self.0.partial_cmp(&other.0)\n     }\n@@ -291,6 +305,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Self) -> Self {\n         Self(self.0 & rhs.0)\n     }\n@@ -303,6 +318,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: bool) -> Self {\n         self & Self::splat(rhs)\n     }\n@@ -315,6 +331,7 @@ where\n {\n     type Output = Mask<T, LANES>;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n         Mask::splat(self) & rhs\n     }\n@@ -327,6 +344,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Self) -> Self {\n         Self(self.0 | rhs.0)\n     }\n@@ -339,6 +357,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: bool) -> Self {\n         self | Self::splat(rhs)\n     }\n@@ -351,6 +370,7 @@ where\n {\n     type Output = Mask<T, LANES>;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n         Mask::splat(self) | rhs\n     }\n@@ -363,6 +383,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Self) -> Self::Output {\n         Self(self.0 ^ rhs.0)\n     }\n@@ -375,6 +396,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: bool) -> Self::Output {\n         self ^ Self::splat(rhs)\n     }\n@@ -387,6 +409,7 @@ where\n {\n     type Output = Mask<T, LANES>;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Mask<T, LANES>) -> Self::Output {\n         Mask::splat(self) ^ rhs\n     }\n@@ -399,6 +422,7 @@ where\n {\n     type Output = Mask<T, LANES>;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn not(self) -> Self::Output {\n         Self(!self.0)\n     }"}, {"sha": "4c964cb52e1963851689fc06ef70c39dc5fcdb9d", "filename": "library/portable-simd/crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -1,3 +1,4 @@\n+#![allow(unused_imports)]\n use super::MaskElement;\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n@@ -73,6 +74,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn splat(value: bool) -> Self {\n         let mut mask = <LaneCount<LANES> as SupportedLaneCount>::BitMask::default();\n         if value {\n@@ -87,6 +89,7 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n         (self.0.as_ref()[lane / 8] >> (lane % 8)) & 0x1 > 0\n     }\n@@ -99,43 +102,41 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn to_int(self) -> Simd<T, LANES> {\n         unsafe {\n-            let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n-                core::mem::transmute_copy(&self);\n-            intrinsics::simd_select_bitmask(mask, Simd::splat(T::TRUE), Simd::splat(T::FALSE))\n+            crate::intrinsics::simd_select_bitmask(\n+                self.0,\n+                Simd::splat(T::TRUE),\n+                Simd::splat(T::FALSE),\n+            )\n         }\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n-        // TODO remove the transmute when rustc is more flexible\n-        assert_eq!(\n-            core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::BitMask>(),\n-            core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n-        );\n-        unsafe {\n-            let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n-                intrinsics::simd_bitmask(value);\n-            Self(core::mem::transmute_copy(&mask), PhantomData)\n-        }\n+        unsafe { Self(crate::intrinsics::simd_bitmask(value), PhantomData) }\n     }\n \n     #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n     pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n         // Safety: these are the same type and we are laundering the generic\n         unsafe { core::mem::transmute_copy(&self.0) }\n     }\n \n     #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n         // Safety: these are the same type and we are laundering the generic\n         Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn convert<U>(self) -> Mask<U, LANES>\n     where\n         U: MaskElement,\n@@ -144,11 +145,13 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n         self != Self::splat(false)\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n         self == Self::splat(true)\n     }\n@@ -162,6 +165,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(mut self, rhs: Self) -> Self {\n         for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n             *l &= r;\n@@ -178,6 +182,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(mut self, rhs: Self) -> Self {\n         for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n             *l |= r;\n@@ -193,6 +198,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(mut self, rhs: Self) -> Self::Output {\n         for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n             *l ^= r;\n@@ -208,6 +214,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn not(mut self) -> Self::Output {\n         for x in self.0.as_mut() {\n             *x = !*x;"}, {"sha": "5421ccbe3d8f5ce9c5e3b7221609314990412fcf", "filename": "library/portable-simd/crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -23,6 +23,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn clone(&self) -> Self {\n         *self\n     }\n@@ -70,11 +71,14 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn splat(value: bool) -> Self {\n         Self(Simd::splat(if value { T::TRUE } else { T::FALSE }))\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n         T::eq(self.0[lane], T::TRUE)\n     }\n@@ -85,16 +89,19 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn to_int(self) -> Simd<T, LANES> {\n         self.0\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         Self(value)\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn convert<U>(self) -> Mask<U, LANES>\n     where\n         U: MaskElement,\n@@ -104,17 +111,11 @@ where\n \n     #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n+    #[must_use = \"method returns a new array and does not mutate the original value\"]\n     pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n         unsafe {\n-            // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n-            assert_eq!(\n-                core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n-                LaneCount::<LANES>::BITMASK_LEN,\n-            );\n-            let bitmask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n-                intrinsics::simd_bitmask(self.0);\n             let mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN] =\n-                core::mem::transmute_copy(&bitmask);\n+                crate::intrinsics::simd_bitmask(self.0);\n \n             // There is a bug where LLVM appears to implement this operation with the wrong\n             // bit order.\n@@ -131,6 +132,7 @@ where\n \n     #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_bitmask(mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n         unsafe {\n             // There is a bug where LLVM appears to implement this operation with the wrong\n@@ -142,15 +144,7 @@ where\n                 }\n             }\n \n-            // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n-            assert_eq!(\n-                core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n-                LaneCount::<LANES>::BITMASK_LEN,\n-            );\n-            let bitmask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n-                core::mem::transmute_copy(&bitmask);\n-\n-            Self::from_int_unchecked(intrinsics::simd_select_bitmask(\n+            Self::from_int_unchecked(crate::intrinsics::simd_select_bitmask(\n                 bitmask,\n                 Self::splat(true).to_int(),\n                 Self::splat(false).to_int(),\n@@ -159,11 +153,13 @@ where\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n         unsafe { intrinsics::simd_reduce_any(self.to_int()) }\n     }\n \n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n         unsafe { intrinsics::simd_reduce_all(self.to_int()) }\n     }\n@@ -186,6 +182,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Self) -> Self {\n         unsafe { Self(intrinsics::simd_and(self.0, rhs.0)) }\n     }\n@@ -198,6 +195,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Self) -> Self {\n         unsafe { Self(intrinsics::simd_or(self.0, rhs.0)) }\n     }\n@@ -210,6 +208,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Self) -> Self {\n         unsafe { Self(intrinsics::simd_xor(self.0, rhs.0)) }\n     }\n@@ -222,6 +221,7 @@ where\n {\n     type Output = Self;\n     #[inline]\n+    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn not(self) -> Self::Output {\n         Self::splat(true) ^ self\n     }"}, {"sha": "7435b6df9186098a4e1ce5c3b4f8b61ae0a8316b", "filename": "library/portable-simd/crates/core_simd/src/math.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -17,7 +17,7 @@ macro_rules! impl_uint_arith {\n             /// let max = Simd::splat(MAX);\n             /// let unsat = x + max;\n             /// let sat = x.saturating_add(max);\n-            /// assert_eq!(x - 1, unsat);\n+            /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n             /// assert_eq!(sat, max);\n             /// ```\n             #[inline]\n@@ -37,7 +37,7 @@ macro_rules! impl_uint_arith {\n             /// let max = Simd::splat(MAX);\n             /// let unsat = x - max;\n             /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, x + 1);\n+            /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n             /// assert_eq!(sat, Simd::splat(0));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n@@ -105,7 +105,7 @@ macro_rules! impl_int_arith {\n             #[inline]\n             pub fn abs(self) -> Self {\n                 const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> SHR;\n+                let m = self >> Simd::splat(SHR);\n                 (self^m) - m\n             }\n \n@@ -128,7 +128,7 @@ macro_rules! impl_int_arith {\n             pub fn saturating_abs(self) -> Self {\n                 // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n                 const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> SHR;\n+                let m = self >> Simd::splat(SHR);\n                 (self^m).saturating_sub(m)\n             }\n "}, {"sha": "3582c57870b9e83f0420642dc67865d6ed08ec8a", "filename": "library/portable-simd/crates/core_simd/src/ops.rs", "status": "modified", "additions": 19, "deletions": 400, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -1,5 +1,13 @@\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::ops::{Add, Mul};\n+use core::ops::{BitAnd, BitOr, BitXor};\n+use core::ops::{Div, Rem, Sub};\n+use core::ops::{Shl, Shr};\n+\n+mod assign;\n+mod deref;\n+mod unary;\n \n impl<I, T, const LANES: usize> core::ops::Index<I> for Simd<T, LANES>\n where\n@@ -57,166 +65,44 @@ macro_rules! impl_ref_ops {\n             $(#[$attrs])*\n             fn $fn($self_tok, $rhs_arg: $rhs_arg_ty) -> Self::Output $body\n         }\n-\n-        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n-\n-            $(#[$attrs])*\n-            fn $fn($self_tok, $rhs_arg: &$rhs) -> Self::Output {\n-                core::ops::$trait::$fn($self_tok, *$rhs_arg)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::ops::$trait<$rhs> for &'_ $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n-\n-            $(#[$attrs])*\n-            fn $fn($self_tok, $rhs_arg: $rhs) -> Self::Output {\n-                core::ops::$trait::$fn(*$self_tok, $rhs_arg)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for &'_ $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n-\n-            $(#[$attrs])*\n-            fn $fn($self_tok, $rhs_arg: &$rhs) -> Self::Output {\n-                core::ops::$trait::$fn(*$self_tok, *$rhs_arg)\n-            }\n-        }\n     };\n-\n-    // binary assignment op\n-    {\n-        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n-        where\n-            LaneCount<$lanes2:ident>: SupportedLaneCount,\n-        {\n-            $(#[$attrs:meta])*\n-            fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n-        }\n-    } => {\n-        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            $(#[$attrs])*\n-            fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n-        }\n-\n-        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            $(#[$attrs])*\n-            fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n-                core::ops::$trait::$fn($self_tok, *$rhs_arg)\n-            }\n-        }\n-    };\n-\n-    // unary op\n-    {\n-        impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty\n-        where\n-            LaneCount<$lanes2:ident>: SupportedLaneCount,\n-        {\n-            type Output = $output:ty;\n-            fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n-        }\n-    } => {\n-        impl<const $lanes: usize> core::ops::$trait for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = $output;\n-            fn $fn($self_tok) -> Self::Output $body\n-        }\n-\n-        impl<const $lanes: usize> core::ops::$trait for &'_ $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = <$type as core::ops::$trait>::Output;\n-            fn $fn($self_tok) -> Self::Output {\n-                core::ops::$trait::$fn(*$self_tok)\n-            }\n-        }\n-    }\n }\n \n /// Automatically implements operators over vectors and scalars for a particular vector.\n macro_rules! impl_op {\n     { impl Add for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Add::add, AddAssign::add_assign, simd_add }\n+        impl_op! { @binary $scalar, Add::add, simd_add }\n     };\n     { impl Sub for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n+        impl_op! { @binary $scalar, Sub::sub, simd_sub }\n     };\n     { impl Mul for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n+        impl_op! { @binary $scalar, Mul::mul, simd_mul }\n     };\n     { impl Div for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Div::div, DivAssign::div_assign, simd_div }\n+        impl_op! { @binary $scalar, Div::div, simd_div }\n     };\n     { impl Rem for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n+        impl_op! { @binary $scalar, Rem::rem, simd_rem }\n     };\n     { impl Shl for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n+        impl_op! { @binary $scalar, Shl::shl, simd_shl }\n     };\n     { impl Shr for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n+        impl_op! { @binary $scalar, Shr::shr, simd_shr }\n     };\n     { impl BitAnd for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n+        impl_op! { @binary $scalar, BitAnd::bitand, simd_and }\n     };\n     { impl BitOr for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n+        impl_op! { @binary $scalar, BitOr::bitor, simd_or }\n     };\n     { impl BitXor for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n-    };\n-\n-    { impl Not for $scalar:ty } => {\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::Not for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n-                fn not(self) -> Self::Output {\n-                    self ^ Self::splat(!<$scalar>::default())\n-                }\n-            }\n-        }\n-    };\n-\n-    { impl Neg for $scalar:ty } => {\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::Neg for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n-                fn neg(self) -> Self::Output {\n-                    unsafe { intrinsics::simd_neg(self) }\n-                }\n-            }\n-        }\n+        impl_op! { @binary $scalar, BitXor::bitxor, simd_xor }\n     };\n \n     // generic binary op with assignment when output is `Self`\n-    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $intrinsic:ident } => {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<Self> for Simd<$scalar, LANES>\n             where\n@@ -232,60 +118,6 @@ macro_rules! impl_op {\n                 }\n             }\n         }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<$scalar> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n-\n-                #[inline]\n-                fn $trait_fn(self, rhs: $scalar) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(self, Self::splat(rhs))\n-                }\n-            }\n-        }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<Simd<$scalar, LANES>> for $scalar\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Simd<$scalar, LANES>;\n-\n-                #[inline]\n-                fn $trait_fn(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(Simd::splat(self), rhs)\n-                }\n-            }\n-        }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<Self> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                #[inline]\n-                fn $assign_trait_fn(&mut self, rhs: Self) {\n-                    unsafe {\n-                        *self = intrinsics::$intrinsic(*self, rhs);\n-                    }\n-                }\n-            }\n-        }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                #[inline]\n-                fn $assign_trait_fn(&mut self, rhs: $scalar) {\n-                    core::ops::$assign_trait::$assign_trait_fn(self, Self::splat(rhs));\n-                }\n-            }\n-        }\n     };\n }\n \n@@ -298,7 +130,6 @@ macro_rules! impl_float_ops {\n             impl_op! { impl Mul for $scalar }\n             impl_op! { impl Div for $scalar }\n             impl_op! { impl Rem for $scalar }\n-            impl_op! { impl Neg for $scalar }\n         )*\n     };\n }\n@@ -313,7 +144,6 @@ macro_rules! impl_unsigned_int_ops {\n             impl_op! { impl BitAnd for $scalar }\n             impl_op! { impl BitOr  for $scalar }\n             impl_op! { impl BitXor for $scalar }\n-            impl_op! { impl Not for $scalar }\n \n             // Integers panic on divide by 0\n             impl_ref_ops! {\n@@ -344,67 +174,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Div<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn div(self, rhs: $scalar) -> Self::Output {\n-                        if rhs == 0 {\n-                            panic!(\"attempt to divide by zero\");\n-                        }\n-                        if <$scalar>::MIN != 0 &&\n-                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                            rhs == -1 as _ {\n-                                panic!(\"attempt to divide with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_div(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Div<Simd<$scalar, LANES>> for $scalar\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Simd<$scalar, LANES>;\n-\n-                    #[inline]\n-                    fn div(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                        Simd::splat(self) / rhs\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::DivAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn div_assign(&mut self, rhs: Self) {\n-                        *self = *self / rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::DivAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn div_assign(&mut self, rhs: $scalar) {\n-                        *self = *self / rhs;\n-                    }\n-                }\n-            }\n-\n             // remainder panics on zero divisor\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n@@ -434,67 +203,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Rem<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn rem(self, rhs: $scalar) -> Self::Output {\n-                        if rhs == 0 {\n-                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                        }\n-                        if <$scalar>::MIN != 0 &&\n-                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                            rhs == -1 as _ {\n-                                panic!(\"attempt to calculate the remainder with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_rem(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Rem<Simd<$scalar, LANES>> for $scalar\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Simd<$scalar, LANES>;\n-\n-                    #[inline]\n-                    fn rem(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                        Simd::splat(self) % rhs\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::RemAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn rem_assign(&mut self, rhs: Self) {\n-                        *self = *self % rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::RemAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn rem_assign(&mut self, rhs: $scalar) {\n-                        *self = *self % rhs;\n-                    }\n-                }\n-            }\n-\n             // shifts panic on overflow\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Shl<Self> for Simd<$scalar, LANES>\n@@ -518,49 +226,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Shl<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn shl(self, rhs: $scalar) -> Self::Output {\n-                        if invalid_shift_rhs(rhs) {\n-                            panic!(\"attempt to shift left with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_shl(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShlAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shl_assign(&mut self, rhs: Self) {\n-                        *self = *self << rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShlAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shl_assign(&mut self, rhs: $scalar) {\n-                        *self = *self << rhs;\n-                    }\n-                }\n-            }\n-\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Shr<Self> for Simd<$scalar, LANES>\n                 where\n@@ -582,49 +247,6 @@ macro_rules! impl_unsigned_int_ops {\n                     }\n                 }\n             }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Shr<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn shr(self, rhs: $scalar) -> Self::Output {\n-                        if invalid_shift_rhs(rhs) {\n-                            panic!(\"attempt to shift with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_shr(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShrAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shr_assign(&mut self, rhs: Self) {\n-                        *self = *self >> rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShrAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shr_assign(&mut self, rhs: $scalar) {\n-                        *self = *self >> rhs;\n-                    }\n-                }\n-            }\n         )*\n     };\n }\n@@ -633,9 +255,6 @@ macro_rules! impl_unsigned_int_ops {\n macro_rules! impl_signed_int_ops {\n     { $($scalar:ty),* } => {\n         impl_unsigned_int_ops! { $($scalar),* }\n-        $( // scalar\n-            impl_op! { impl Neg for $scalar }\n-        )*\n     };\n }\n "}, {"sha": "d2b48614fc96671296ac0a3380ec8232ee3dbb8f", "filename": "library/portable-simd/crates/core_simd/src/ops/assign.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -0,0 +1,124 @@\n+//! Assignment operators\n+use super::*;\n+use core::ops::{AddAssign, MulAssign}; // commutative binary op-assignment\n+use core::ops::{BitAndAssign, BitOrAssign, BitXorAssign}; // commutative bit binary op-assignment\n+use core::ops::{DivAssign, RemAssign, SubAssign}; // non-commutative binary op-assignment\n+use core::ops::{ShlAssign, ShrAssign}; // non-commutative bit binary op-assignment\n+\n+// Arithmetic\n+\n+macro_rules! assign_ops {\n+    ($(impl<T, U, const LANES: usize> $assignTrait:ident<U> for Simd<T, LANES>\n+        where\n+            Self: $trait:ident,\n+        {\n+            fn $assign_call:ident(rhs: U) {\n+                $call:ident\n+            }\n+        })*) => {\n+        $(impl<T, U, const LANES: usize> $assignTrait<U> for Simd<T, LANES>\n+        where\n+            Self: $trait<U, Output = Self>,\n+            T: SimdElement,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn $assign_call(&mut self, rhs: U) {\n+                *self = self.$call(rhs);\n+            }\n+        })*\n+    }\n+}\n+\n+assign_ops! {\n+    // Arithmetic\n+    impl<T, U, const LANES: usize> AddAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Add,\n+    {\n+        fn add_assign(rhs: U) {\n+            add\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> MulAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Mul,\n+    {\n+        fn mul_assign(rhs: U) {\n+            mul\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> SubAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Sub,\n+    {\n+        fn sub_assign(rhs: U) {\n+            sub\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> DivAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Div,\n+    {\n+        fn div_assign(rhs: U) {\n+            div\n+        }\n+    }\n+    impl<T, U, const LANES: usize> RemAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Rem,\n+    {\n+        fn rem_assign(rhs: U) {\n+            rem\n+        }\n+    }\n+\n+    // Bitops\n+    impl<T, U, const LANES: usize> BitAndAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitAnd,\n+    {\n+        fn bitand_assign(rhs: U) {\n+            bitand\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> BitOrAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitOr,\n+    {\n+        fn bitor_assign(rhs: U) {\n+            bitor\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> BitXorAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitXor,\n+    {\n+        fn bitxor_assign(rhs: U) {\n+            bitxor\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> ShlAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Shl,\n+    {\n+        fn shl_assign(rhs: U) {\n+            shl\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> ShrAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Shr,\n+    {\n+        fn shr_assign(rhs: U) {\n+            shr\n+        }\n+    }\n+}"}, {"sha": "9883a74c92d678cfff70473623468168772d6112", "filename": "library/portable-simd/crates/core_simd/src/ops/deref.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -0,0 +1,124 @@\n+//! This module hacks in \"implicit deref\" for Simd's operators.\n+//! Ideally, Rust would take care of this itself,\n+//! and method calls usually handle the LHS implicitly.\n+//! But this is not the case with arithmetic ops.\n+use super::*;\n+\n+macro_rules! deref_lhs {\n+    (impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        }) => {\n+        impl<T, const LANES: usize> $trait<$simd> for &$simd\n+        where\n+            T: SimdElement,\n+            $simd: $trait<$simd, Output = $simd>,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Simd<T, LANES>;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+            fn $call(self, rhs: $simd) -> Self::Output {\n+                (*self).$call(rhs)\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! deref_rhs {\n+    (impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        }) => {\n+        impl<T, const LANES: usize> $trait<&$simd> for $simd\n+        where\n+            T: SimdElement,\n+            $simd: $trait<$simd, Output = $simd>,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Simd<T, LANES>;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+            fn $call(self, rhs: &$simd) -> Self::Output {\n+                self.$call(*rhs)\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! deref_ops {\n+    ($(impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        })*) => {\n+        $(\n+            deref_rhs! {\n+                impl<T, const LANES: usize> $trait for $simd {\n+                    fn $call\n+                }\n+            }\n+            deref_lhs! {\n+                impl<T, const LANES: usize> $trait for $simd {\n+                    fn $call\n+                }\n+            }\n+            impl<'lhs, 'rhs, T, const LANES: usize> $trait<&'rhs $simd> for &'lhs $simd\n+            where\n+                T: SimdElement,\n+                $simd: $trait<$simd, Output = $simd>,\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                type Output = $simd;\n+\n+                #[inline]\n+                #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+                fn $call(self, rhs: &$simd) -> Self::Output {\n+                    (*self).$call(*rhs)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+deref_ops! {\n+    // Arithmetic\n+    impl<T, const LANES: usize> Add for Simd<T, LANES> {\n+        fn add\n+    }\n+\n+    impl<T, const LANES: usize> Mul for Simd<T, LANES> {\n+        fn mul\n+    }\n+\n+    impl<T, const LANES: usize> Sub for Simd<T, LANES> {\n+        fn sub\n+    }\n+\n+    impl<T, const LANES: usize> Div for Simd<T, LANES> {\n+        fn div\n+    }\n+\n+    impl<T, const LANES: usize> Rem for Simd<T, LANES> {\n+        fn rem\n+    }\n+\n+    // Bitops\n+    impl<T, const LANES: usize> BitAnd for Simd<T, LANES> {\n+        fn bitand\n+    }\n+\n+    impl<T, const LANES: usize> BitOr for Simd<T, LANES> {\n+        fn bitor\n+    }\n+\n+    impl<T, const LANES: usize> BitXor for Simd<T, LANES> {\n+        fn bitxor\n+    }\n+\n+    impl<T, const LANES: usize> Shl for Simd<T, LANES> {\n+        fn shl\n+    }\n+\n+    impl<T, const LANES: usize> Shr for Simd<T, LANES> {\n+        fn shr\n+    }\n+}"}, {"sha": "4ebea560fc65fa51e3d7f0594506e03a0c27adfa", "filename": "library/portable-simd/crates/core_simd/src/ops/unary.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -0,0 +1,77 @@\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::ops::{Neg, Not}; // unary ops\n+\n+macro_rules! neg {\n+    ($(impl<const LANES: usize> Neg for Simd<$scalar:ty, LANES>)*) => {\n+        $(impl<const LANES: usize> Neg for Simd<$scalar, LANES>\n+        where\n+            $scalar: SimdElement,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Self;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the input\"]\n+            fn neg(self) -> Self::Output {\n+                unsafe { intrinsics::simd_neg(self) }\n+            }\n+        })*\n+    }\n+}\n+\n+neg! {\n+    impl<const LANES: usize> Neg for Simd<f32, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<f64, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<i8, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<i16, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<i32, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<i64, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<isize, LANES>\n+}\n+\n+macro_rules! not {\n+    ($(impl<const LANES: usize> Not for Simd<$scalar:ty, LANES>)*) => {\n+        $(impl<const LANES: usize> Not for Simd<$scalar, LANES>\n+        where\n+            $scalar: SimdElement,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Self;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the input\"]\n+            fn not(self) -> Self::Output {\n+                self ^ (Simd::splat(!(0 as $scalar)))\n+            }\n+        })*\n+    }\n+}\n+\n+not! {\n+    impl<const LANES: usize> Not for Simd<i8, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<i16, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<i32, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<i64, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<isize, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<u8, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<u16, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<u32, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<u64, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<usize, LANES>\n+}"}, {"sha": "e79a185816bfbfcd3d9745003b66e50f0f6ad57b", "filename": "library/portable-simd/crates/core_simd/src/reduction.rs", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -2,7 +2,8 @@ use crate::simd::intrinsics::{\n     simd_reduce_add_ordered, simd_reduce_and, simd_reduce_max, simd_reduce_min,\n     simd_reduce_mul_ordered, simd_reduce_or, simd_reduce_xor,\n };\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::ops::{BitAnd, BitOr, BitXor};\n \n macro_rules! impl_integer_reductions {\n     { $scalar:ty } => {\n@@ -22,27 +23,6 @@ macro_rules! impl_integer_reductions {\n                 unsafe { simd_reduce_mul_ordered(self, 1) }\n             }\n \n-            /// Horizontal bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n-            /// the vector.\n-            #[inline]\n-            pub fn horizontal_and(self) -> $scalar {\n-                unsafe { simd_reduce_and(self) }\n-            }\n-\n-            /// Horizontal bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n-            /// the vector.\n-            #[inline]\n-            pub fn horizontal_or(self) -> $scalar {\n-                unsafe { simd_reduce_or(self) }\n-            }\n-\n-            /// Horizontal bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n-            /// the vector.\n-            #[inline]\n-            pub fn horizontal_xor(self) -> $scalar {\n-                unsafe { simd_reduce_xor(self) }\n-            }\n-\n             /// Horizontal maximum.  Returns the maximum lane in the vector.\n             #[inline]\n             pub fn horizontal_max(self) -> $scalar {\n@@ -121,3 +101,45 @@ macro_rules! impl_float_reductions {\n \n impl_float_reductions! { f32 }\n impl_float_reductions! { f64 }\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    Self: BitAnd<Self, Output = Self>,\n+    T: SimdElement + BitAnd<T, Output = T>,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Horizontal bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n+    /// the vector.\n+    #[inline]\n+    pub fn horizontal_and(self) -> T {\n+        unsafe { simd_reduce_and(self) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    Self: BitOr<Self, Output = Self>,\n+    T: SimdElement + BitOr<T, Output = T>,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Horizontal bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n+    /// the vector.\n+    #[inline]\n+    pub fn horizontal_or(self) -> T {\n+        unsafe { simd_reduce_or(self) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    Self: BitXor<Self, Output = Self>,\n+    T: SimdElement + BitXor<T, Output = T>,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Horizontal bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n+    /// the vector.\n+    #[inline]\n+    pub fn horizontal_xor(self) -> T {\n+        unsafe { simd_reduce_xor(self) }\n+    }\n+}"}, {"sha": "5d696ebf76ec299bccb57673f6a13c869f8ad09f", "filename": "library/portable-simd/crates/core_simd/src/select.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -17,6 +17,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     fn select(mask: Mask<T::Mask, LANES>, true_values: Self, false_values: Self) -> Self {\n         unsafe { intrinsics::simd_select(mask.to_int(), true_values, false_values) }\n     }\n@@ -35,6 +36,7 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     fn select(mask: Self, true_values: Self, false_values: Self) -> Self {\n         mask & true_values | !mask & false_values\n     }\n@@ -80,6 +82,7 @@ where\n     /// assert_eq!(c.to_array(), [true, false, true, false]);\n     /// ```\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn select<S: Select<Self>>(self, true_values: S, false_values: S) -> S {\n         S::select(self, true_values, false_values)\n     }"}, {"sha": "bdc489774a54a43e1293a31a754cfb9da72ecc3d", "filename": "library/portable-simd/crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -87,6 +87,8 @@ pub trait Swizzle<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n     /// Create a new vector from the lanes of `vector`.\n     ///\n     /// Lane `i` of the output is `vector[Self::INDEX[i]]`.\n+    #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     fn swizzle<T>(vector: Simd<T, INPUT_LANES>) -> Simd<T, OUTPUT_LANES>\n     where\n         T: SimdElement,\n@@ -106,6 +108,8 @@ pub trait Swizzle2<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n     ///\n     /// Lane `i` is `first[j]` when `Self::INDEX[i]` is `First(j)`, or `second[j]` when it is\n     /// `Second(j)`.\n+    #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     fn swizzle2<T>(\n         first: Simd<T, INPUT_LANES>,\n         second: Simd<T, INPUT_LANES>,\n@@ -182,6 +186,7 @@ where\n {\n     /// Reverse the order of the lanes in the vector.\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn reverse(self) -> Self {\n         const fn reverse_index<const LANES: usize>() -> [usize; LANES] {\n             let mut index = [0; LANES];\n@@ -206,6 +211,7 @@ where\n     /// while the last `LANES - OFFSET` elements move to the front. After calling `rotate_lanes_left`,\n     /// the element previously in lane `OFFSET` will become the first element in the slice.\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn rotate_lanes_left<const OFFSET: usize>(self) -> Self {\n         const fn rotate_index<const OFFSET: usize, const LANES: usize>() -> [usize; LANES] {\n             let offset = OFFSET % LANES;\n@@ -231,6 +237,7 @@ where\n     /// the end while the last `OFFSET` elements move to the front. After calling `rotate_lanes_right`,\n     /// the element previously at index `LANES - OFFSET` will become the first element in the slice.\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn rotate_lanes_right<const OFFSET: usize>(self) -> Self {\n         const fn rotate_index<const OFFSET: usize, const LANES: usize>() -> [usize; LANES] {\n             let offset = LANES - OFFSET % LANES;\n@@ -273,6 +280,7 @@ where\n     /// assert_eq!(y.to_array(), [2, 6, 3, 7]);\n     /// ```\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn interleave(self, other: Self) -> (Self, Self) {\n         const fn lo<const LANES: usize>() -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];\n@@ -336,6 +344,7 @@ where\n     /// assert_eq!(y.to_array(), [4, 5, 6, 7]);\n     /// ```\n     #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn deinterleave(self, other: Self) -> (Self, Self) {\n         const fn even<const LANES: usize>() -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];"}, {"sha": "4a4b23238c4ab3770d5357ffa962ae36d9afb999", "filename": "library/portable-simd/crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -15,6 +15,7 @@ macro_rules! impl_float_vector {\n             /// Raw transmutation to an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn to_bits(self) -> Simd<$bits_ty, LANES> {\n                 assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n                 unsafe { core::mem::transmute_copy(&self) }\n@@ -23,6 +24,7 @@ macro_rules! impl_float_vector {\n             /// Raw transmutation from an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n                 assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n                 unsafe { core::mem::transmute_copy(&bits) }\n@@ -31,6 +33,7 @@ macro_rules! impl_float_vector {\n             /// Produces a vector where every lane has the absolute value of the\n             /// equivalently-indexed lane in `self`.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn abs(self) -> Self {\n                 unsafe { intrinsics::simd_fabs(self) }\n             }\n@@ -44,79 +47,91 @@ macro_rules! impl_float_vector {\n             /// hardware in mind.\n             #[cfg(feature = \"std\")]\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn mul_add(self, a: Self, b: Self) -> Self {\n                 unsafe { intrinsics::simd_fma(self, a, b) }\n             }\n \n             /// Produces a vector where every lane has the square root value\n             /// of the equivalently-indexed lane in `self`\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             #[cfg(feature = \"std\")]\n             pub fn sqrt(self) -> Self {\n                 unsafe { intrinsics::simd_fsqrt(self) }\n             }\n \n             /// Takes the reciprocal (inverse) of each lane, `1/x`.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn recip(self) -> Self {\n                 Self::splat(1.0) / self\n             }\n \n             /// Converts each lane from radians to degrees.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn to_degrees(self) -> Self {\n                 // to_degrees uses a special constant for better precision, so extract that constant\n                 self * Self::splat(<$type>::to_degrees(1.))\n             }\n \n             /// Converts each lane from degrees to radians.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn to_radians(self) -> Self {\n                 self * Self::splat(<$type>::to_radians(1.))\n             }\n \n             /// Returns true for each lane if it has a positive sign, including\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_sign_positive(self) -> Mask<$mask_ty, LANES> {\n                 !self.is_sign_negative()\n             }\n \n             /// Returns true for each lane if it has a negative sign, including\n             /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n                 let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n                 sign_bits.lanes_gt(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is `NaN`.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n                 self.lanes_ne(self)\n             }\n \n             /// Returns true for each lane if its value is positive infinity or negative infinity.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is neither infinite nor `NaN`.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is subnormal.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is neither neither zero, infinite,\n             /// subnormal, or `NaN`.\n             #[inline]\n+            #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n                 !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n             }\n@@ -127,6 +142,7 @@ macro_rules! impl_float_vector {\n             /// * `-1.0` if the number is negative, `-0.0`, or `NEG_INFINITY`\n             /// * `NAN` if the number is `NAN`\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn signum(self) -> Self {\n                 self.is_nan().select(Self::splat(<$type>::NAN), Self::splat(1.0).copysign(self))\n             }\n@@ -135,6 +151,7 @@ macro_rules! impl_float_vector {\n             ///\n             /// If any lane is a `NAN`, then a `NAN` with the sign of `sign` is returned.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn copysign(self, sign: Self) -> Self {\n                 let sign_bit = sign.to_bits() & Self::splat(-0.).to_bits();\n                 let magnitude = self.to_bits() & !Self::splat(-0.).to_bits();\n@@ -145,6 +162,7 @@ macro_rules! impl_float_vector {\n             ///\n             /// If one of the values is `NAN`, then the other value is returned.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn min(self, other: Self) -> Self {\n                 // TODO consider using an intrinsic\n                 self.is_nan().select(\n@@ -157,6 +175,7 @@ macro_rules! impl_float_vector {\n             ///\n             /// If one of the values is `NAN`, then the other value is returned.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn max(self, other: Self) -> Self {\n                 // TODO consider using an intrinsic\n                 self.is_nan().select(\n@@ -171,6 +190,7 @@ macro_rules! impl_float_vector {\n             /// greater than `max`, and the corresponding lane in `min` if the lane is less\n             /// than `min`.  Otherwise returns the lane in `self`.\n             #[inline]\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn clamp(self, min: Self, max: Self) -> Self {\n                 assert!(\n                     min.lanes_le(max).all(),"}, {"sha": "c668d9a6eaee35785e7eb84b7bc5a01f7d317bc8", "filename": "library/portable-simd/crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -23,7 +23,7 @@ where\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n-            mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n+            mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n         }\n     }\n }\n@@ -49,7 +49,7 @@ where\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n-            mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n+            mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n         }\n     }\n }"}, {"sha": "0dd47015ed22f21b63331b1c273e9d1697784fd1", "filename": "library/portable-simd/crates/core_simd/src/vendor/x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -8,10 +8,10 @@ use core::arch::x86_64::*;\n \n from_transmute! { unsafe u8x16 => __m128i }\n from_transmute! { unsafe u8x32 => __m256i }\n-//from_transmute! { unsafe u8x64 => __m512i }\n+from_transmute! { unsafe u8x64 => __m512i }\n from_transmute! { unsafe i8x16 => __m128i }\n from_transmute! { unsafe i8x32 => __m256i }\n-//from_transmute! { unsafe i8x64 => __m512i }\n+from_transmute! { unsafe i8x64 => __m512i }\n \n from_transmute! { unsafe u16x8 => __m128i }\n from_transmute! { unsafe u16x16 => __m256i }"}, {"sha": "9359da16ee5c7c1a647666598d093697daceeb1f", "filename": "library/portable-simd/crates/core_simd/tests/autoderef.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -0,0 +1,22 @@\n+// Test that we handle all our \"auto-deref\" cases correctly.\n+#![feature(portable_simd)]\n+use core_simd::f32x4;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn deref() {\n+    let x = f32x4::splat(1.0);\n+    let y = f32x4::splat(2.0);\n+    let a = &x;\n+    let b = &y;\n+    assert_eq!(f32x4::splat(3.0), x + y);\n+    assert_eq!(f32x4::splat(3.0), x + b);\n+    assert_eq!(f32x4::splat(3.0), a + y);\n+    assert_eq!(f32x4::splat(3.0), a + b);\n+}"}, {"sha": "43ddde4c55e0162db189c5c4270a31695f69f021", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -38,37 +38,13 @@ macro_rules! impl_binary_op_test {\n                     );\n                 }\n \n-                fn scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n-\n-                fn scalar_lhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_lhs_elementwise(\n-                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n-\n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n                         &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|_, _| true,\n                     );\n                 }\n-\n-                fn assign_scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n             }\n         }\n     };\n@@ -99,37 +75,13 @@ macro_rules! impl_binary_checked_op_test {\n                     );\n                 }\n \n-                fn scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n-                        &$scalar_fn,\n-                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n-                    );\n-                }\n-\n-                fn scalar_lhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_lhs_elementwise(\n-                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n-                        &$scalar_fn,\n-                        &|x, y| y.iter().all(|y| $check_fn(x, *y)),\n-                    );\n-                }\n-\n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n                         &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n                     )\n                 }\n-\n-                fn assign_scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n-                        &$scalar_fn,\n-                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n-                    )\n-                }\n             }\n         }\n     };"}, {"sha": "7edd609638171da96b1d7b9c38d3740a6f3724e8", "filename": "library/portable-simd/crates/test_helpers/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=2ea27bf6ef77bdc5408d69e2fcccc58beb4bd306", "patch": "@@ -376,6 +376,12 @@ macro_rules! test_lanes {\n                 fn lanes_32() {\n                     implementation::<32>();\n                 }\n+\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                fn lanes_64() {\n+                    implementation::<64>();\n+                }\n             }\n         )*\n     }\n@@ -431,6 +437,12 @@ macro_rules! test_lanes_panic {\n                 fn lanes_32() {\n                     implementation::<32>();\n                 }\n+\n+                #[test]\n+                #[should_panic]\n+                fn lanes_64() {\n+                    implementation::<64>();\n+                }\n             }\n         )*\n     }"}]}