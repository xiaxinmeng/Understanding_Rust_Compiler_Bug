{"sha": "add6cccd4c923fbb5c83cc27b06aa84b2cbc9557", "node_id": "C_kwDOAAsO6NoAKGFkZDZjY2NkNGM5MjNmYmI1YzgzY2MyN2IwNmFhODRiMmNiYzk1NTc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-16T20:51:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-16T20:51:09Z"}, "message": "Merge #10781\n\n10781: internal: Do not use reference search in `runnables::related_tests` r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "d93f93b66c9c5cc6d19708615455cfa8f2b67e3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d93f93b66c9c5cc6d19708615455cfa8f2b67e3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhlBm9CRBK7hj4Ov3rIwAA/9wIAJlSz1f26oxUcN1fR0S7V/jn\nGyLOv4MdSN6mUB92dL8iWjq9MS93Akf7KnTQUHgWAKk7ItS5ehCGPr+MmgeB7YGA\nA/dzPv49SPVNZonA9+S1hL3XztlDH0zEi/f6AFD1MRwZF+skIS0LtTF9cOi58Naq\nxifRMXcGZ3DMaUC9vOj6EiECM3gXnFDxLJ16ZUDjRJl+nJHDUoKZPpzMrjm3JvBT\nTWXkFtL3A3Jw5tKhY86Z1OigD+4K4fgth3CjK8lATKEEb69SQkAmZIiauAhTQHwX\nUO6h+D9z1R89P13xg4ihNA52CAUlhRA+AkahWkvWw9E90zphhQVjnUmT9+EChyI=\n=KAR9\n-----END PGP SIGNATURE-----\n", "payload": "tree d93f93b66c9c5cc6d19708615455cfa8f2b67e3c\nparent 1c49667c5658e0f8f0fb496786071e2f9b6cd43c\nparent 366499c3be15a7bbf7914d6825e4d92fdfbddb1e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637095869 +0000\ncommitter GitHub <noreply@github.com> 1637095869 +0000\n\nMerge #10781\n\n10781: internal: Do not use reference search in `runnables::related_tests` r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557", "html_url": "https://github.com/rust-lang/rust/commit/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c49667c5658e0f8f0fb496786071e2f9b6cd43c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c49667c5658e0f8f0fb496786071e2f9b6cd43c", "html_url": "https://github.com/rust-lang/rust/commit/1c49667c5658e0f8f0fb496786071e2f9b6cd43c"}, {"sha": "366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "html_url": "https://github.com/rust-lang/rust/commit/366499c3be15a7bbf7914d6825e4d92fdfbddb1e"}], "stats": {"total": 274, "additions": 122, "deletions": 152}, "files": [{"sha": "281e6c65dc448b17c63b1eec17728cefc4253db3", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=add6cccd4c923fbb5c83cc27b06aa84b2cbc9557", "patch": "@@ -228,6 +228,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         token.parent().into_iter().flat_map(move |it| self.ancestors_with_macros(it))\n     }\n \n+    /// Iterates the ancestors of the given node, climbing up macro expansions while doing so.\n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n         self.imp.ancestors_with_macros(node)\n     }"}, {"sha": "7d4d52ff50ebf5527d4161b9af16ada6b1764935", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 17, "deletions": 52, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=add6cccd4c923fbb5c83cc27b06aa84b2cbc9557", "patch": "@@ -1,7 +1,7 @@\n use hir::Semantics;\n use ide_db::{\n-    base_db::FilePosition,\n-    defs::{Definition, NameClass, NameRefClass},\n+    base_db::{FileId, FilePosition},\n+    defs::Definition,\n     helpers::{for_each_break_expr, for_each_tail_expr, node_ext::walk_expr, pick_best_token},\n     search::{FileReference, ReferenceCategory, SearchScope},\n     RootDatabase,\n@@ -11,7 +11,7 @@ use syntax::{\n     ast::{self, HasLoopBody},\n     match_ast, AstNode,\n     SyntaxKind::IDENT,\n-    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n+    SyntaxNode, SyntaxToken, TextRange, T,\n };\n \n use crate::{display::TryToNav, references, NavigationTarget};\n@@ -45,12 +45,12 @@ pub struct HighlightRelatedConfig {\n pub(crate) fn highlight_related(\n     sema: &Semantics<RootDatabase>,\n     config: HighlightRelatedConfig,\n-    position: FilePosition,\n+    FilePosition { offset, file_id }: FilePosition,\n ) -> Option<Vec<HighlightedRange>> {\n     let _p = profile::span(\"highlight_related\");\n-    let syntax = sema.parse(position.file_id).syntax().clone();\n+    let syntax = sema.parse(file_id).syntax().clone();\n \n-    let token = pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n+    let token = pick_best_token(syntax.token_at_offset(offset), |kind| match kind {\n         T![?] => 4, // prefer `?` when the cursor is sandwiched like in `await$0?`\n         T![->] => 3,\n         kind if kind.is_keyword() => 2,\n@@ -68,17 +68,18 @@ pub(crate) fn highlight_related(\n             highlight_break_points(token)\n         }\n         T![break] | T![loop] | T![while] if config.break_points => highlight_break_points(token),\n-        _ if config.references => highlight_references(sema, &syntax, position),\n+        _ if config.references => highlight_references(sema, &syntax, token, file_id),\n         _ => None,\n     }\n }\n \n fn highlight_references(\n     sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    FilePosition { offset, file_id }: FilePosition,\n+    node: &SyntaxNode,\n+    token: SyntaxToken,\n+    file_id: FileId,\n ) -> Option<Vec<HighlightedRange>> {\n-    let defs = find_defs(sema, syntax, offset);\n+    let defs = find_defs(sema, token.clone());\n     let usages = defs\n         .iter()\n         .filter_map(|&d| {\n@@ -105,11 +106,8 @@ fn highlight_references(\n         .filter(|decl| decl.file_id == file_id)\n         .and_then(|decl| {\n             let range = decl.focus_range?;\n-            let category = if references::decl_mutability(&def, syntax, range) {\n-                Some(ReferenceCategory::Write)\n-            } else {\n-                None\n-            };\n+            let category =\n+                references::decl_mutability(&def, node, range).then(|| ReferenceCategory::Write);\n             Some(HighlightedRange { range, category })\n         })\n     });\n@@ -293,43 +291,10 @@ fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange\n     }\n }\n \n-fn find_defs(\n-    sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    offset: TextSize,\n-) -> FxHashSet<Definition> {\n-    sema.find_nodes_at_offset_with_descend(syntax, offset)\n-        .flat_map(|name_like| {\n-            Some(match name_like {\n-                ast::NameLike::NameRef(name_ref) => {\n-                    match NameRefClass::classify(sema, &name_ref)? {\n-                        NameRefClass::Definition(def) => vec![def],\n-                        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n-                            vec![Definition::Local(local_ref), Definition::Field(field_ref)]\n-                        }\n-                    }\n-                }\n-                ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n-                    NameClass::Definition(it) | NameClass::ConstReference(it) => vec![it],\n-                    NameClass::PatFieldShorthand { local_def, field_ref } => {\n-                        vec![Definition::Local(local_def), Definition::Field(field_ref)]\n-                    }\n-                },\n-                ast::NameLike::Lifetime(lifetime) => {\n-                    NameRefClass::classify_lifetime(sema, &lifetime)\n-                        .and_then(|class| match class {\n-                            NameRefClass::Definition(it) => Some(it),\n-                            _ => None,\n-                        })\n-                        .or_else(|| {\n-                            NameClass::classify_lifetime(sema, &lifetime)\n-                                .and_then(NameClass::defined)\n-                        })\n-                        .map(|it| vec![it])?\n-                }\n-            })\n-        })\n-        .flatten()\n+fn find_defs(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> FxHashSet<Definition> {\n+    sema.descend_into_macros(token)\n+        .into_iter()\n+        .flat_map(|token| Definition::from_token(sema, &token))\n         .collect()\n }\n "}, {"sha": "0e3b73d23543163fc0788cc667b130c8bbfc2b8c", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=add6cccd4c923fbb5c83cc27b06aa84b2cbc9557", "patch": "@@ -9,9 +9,6 @@\n //! at the index that the match starts at and its tree parent is\n //! resolved to the search element definition, we get a reference.\n \n-use std::iter;\n-\n-use either::Either;\n use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n@@ -58,69 +55,67 @@ pub(crate) fn find_all_refs(\n ) -> Option<Vec<ReferenceSearchResult>> {\n     let _p = profile::span(\"find_all_refs\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n+    let make_searcher = |literal_search: bool| {\n+        move |def: Definition| {\n+            let mut usages =\n+                def.usages(sema).set_scope(search_scope.clone()).include_self_refs().all();\n+            let declaration = match def {\n+                Definition::Module(module) => {\n+                    Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+                }\n+                def => def.try_to_nav(sema.db),\n+            }\n+            .map(|nav| {\n+                let decl_range = nav.focus_or_full_range();\n+                Declaration {\n+                    is_mut: decl_mutability(&def, sema.parse(nav.file_id).syntax(), decl_range),\n+                    nav,\n+                }\n+            });\n+            if literal_search {\n+                retain_adt_literal_usages(&mut usages, def, sema);\n+            }\n+\n+            let references = usages\n+                .into_iter()\n+                .map(|(file_id, refs)| {\n+                    (\n+                        file_id,\n+                        refs.into_iter()\n+                            .map(|file_ref| (file_ref.range, file_ref.category))\n+                            .collect(),\n+                    )\n+                })\n+                .collect();\n+\n+            ReferenceSearchResult { declaration, references }\n+        }\n+    };\n \n-    let mut is_literal_search = false;\n-    let defs = match name_for_constructor_search(&syntax, position) {\n+    match name_for_constructor_search(&syntax, position) {\n         Some(name) => {\n-            is_literal_search = true;\n             let def = match NameClass::classify(sema, &name)? {\n                 NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n                 NameClass::PatFieldShorthand { local_def: _, field_ref } => {\n                     Definition::Field(field_ref)\n                 }\n             };\n-            Either::Left(iter::once(def))\n+            Some(vec![make_searcher(true)(def)])\n         }\n-        None => Either::Right(find_defs(sema, &syntax, position.offset)),\n-    };\n-\n-    Some(\n-        defs.into_iter()\n-            .map(|def| {\n-                let mut usages =\n-                    def.usages(sema).set_scope(search_scope.clone()).include_self_refs().all();\n-                let declaration = match def {\n-                    Definition::Module(module) => {\n-                        Some(NavigationTarget::from_module_to_decl(sema.db, module))\n-                    }\n-                    def => def.try_to_nav(sema.db),\n-                }\n-                .map(|nav| {\n-                    let decl_range = nav.focus_or_full_range();\n-                    Declaration {\n-                        is_mut: decl_mutability(&def, sema.parse(nav.file_id).syntax(), decl_range),\n-                        nav,\n-                    }\n-                });\n-                if is_literal_search {\n-                    retain_adt_literal_usages(&mut usages, def, sema);\n-                }\n-\n-                let references = usages\n-                    .into_iter()\n-                    .map(|(file_id, refs)| {\n-                        (\n-                            file_id,\n-                            refs.into_iter()\n-                                .map(|file_ref| (file_ref.range, file_ref.category))\n-                                .collect(),\n-                        )\n-                    })\n-                    .collect();\n-\n-                ReferenceSearchResult { declaration, references }\n-            })\n-            .collect(),\n-    )\n+        None => {\n+            let search = make_searcher(false);\n+            Some(find_defs(sema, &syntax, position.offset).into_iter().map(search).collect())\n+        }\n+    }\n }\n \n pub(crate) fn find_defs<'a>(\n     sema: &'a Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     offset: TextSize,\n ) -> impl Iterator<Item = Definition> + 'a {\n-    sema.find_nodes_at_offset_with_descend(syntax, offset).filter_map(move |node| {\n-        Some(match node {\n+    sema.find_nodes_at_offset_with_descend(syntax, offset).filter_map(move |name_like| {\n+        let def = match name_like {\n             ast::NameLike::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n                 NameRefClass::Definition(def) => def,\n                 NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n@@ -141,7 +136,8 @@ pub(crate) fn find_defs<'a>(\n                 .or_else(|| {\n                     NameClass::classify_lifetime(sema, &lifetime).and_then(NameClass::defined)\n                 })?,\n-        })\n+        };\n+        Some(def)\n     })\n }\n "}, {"sha": "b2111bc4ee0a409ed197fb3385f305a48e443043", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 57, "deletions": 49, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add6cccd4c923fbb5c83cc27b06aa84b2cbc9557/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=add6cccd4c923fbb5c83cc27b06aa84b2cbc9557", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n \n use ast::HasName;\n use cfg::CfgExpr;\n-use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, InFile, Semantics};\n+use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics};\n use ide_assists::utils::test_related_attribute;\n use ide_db::{\n     base_db::{FilePosition, FileRange},\n@@ -14,7 +14,10 @@ use ide_db::{\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::{always, format_to};\n-use syntax::ast::{self, AstNode, HasAttrs as _};\n+use syntax::{\n+    ast::{self, AstNode, HasAttrs as _},\n+    SmolStr, SyntaxNode,\n+};\n \n use crate::{\n     display::{ToNav, TryToNav},\n@@ -31,7 +34,7 @@ pub struct Runnable {\n \n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n pub enum TestId {\n-    Name(String),\n+    Name(SmolStr),\n     Path(String),\n }\n \n@@ -206,68 +209,71 @@ pub(crate) fn related_tests(\n ) -> Vec<Runnable> {\n     let sema = Semantics::new(db);\n     let mut res: FxHashSet<Runnable> = FxHashSet::default();\n+    let syntax = sema.parse(position.file_id).syntax().clone();\n \n-    find_related_tests(&sema, position, search_scope, &mut res);\n+    find_related_tests(&sema, &syntax, position, search_scope, &mut res);\n \n-    res.into_iter().collect_vec()\n+    res.into_iter().collect()\n }\n \n fn find_related_tests(\n     sema: &Semantics<RootDatabase>,\n+    syntax: &SyntaxNode,\n     position: FilePosition,\n     search_scope: Option<SearchScope>,\n     tests: &mut FxHashSet<Runnable>,\n ) {\n-    if let Some(refs) = references::find_all_refs(sema, position, search_scope) {\n-        for (file_id, refs) in refs.into_iter().flat_map(|refs| refs.references) {\n-            let file = sema.parse(file_id);\n-            let file = file.syntax();\n-\n-            // create flattened vec of tokens\n-            let tokens = refs.iter().flat_map(|(range, _)| {\n-                match file.token_at_offset(range.start()).next() {\n-                    Some(token) => sema.descend_into_macros(token),\n-                    None => Default::default(),\n-                }\n-            });\n-\n-            // find first suitable ancestor\n-            let functions = tokens\n-                .filter_map(|token| token.ancestors().find_map(ast::Fn::cast))\n-                .map(|f| hir::InFile::new(sema.hir_file_for(f.syntax()), f));\n-\n-            for fn_def in functions {\n-                let InFile { value: fn_def, .. } = &fn_def;\n-                if let Some(runnable) = as_test_runnable(sema, fn_def) {\n+    let defs = references::find_defs(sema, syntax, position.offset);\n+    for def in defs {\n+        let defs = def\n+            .usages(sema)\n+            .set_scope(search_scope.clone())\n+            .all()\n+            .references\n+            .into_values()\n+            .flatten();\n+        for ref_ in defs {\n+            let name_ref = match ref_.name {\n+                ast::NameLike::NameRef(name_ref) => name_ref,\n+                _ => continue,\n+            };\n+            if let Some(fn_def) =\n+                sema.ancestors_with_macros(name_ref.syntax().clone()).find_map(ast::Fn::cast)\n+            {\n+                if let Some(runnable) = as_test_runnable(sema, &fn_def) {\n                     // direct test\n                     tests.insert(runnable);\n-                } else if let Some(module) = parent_test_module(sema, fn_def) {\n+                } else if let Some(module) = parent_test_module(sema, &fn_def) {\n                     // indirect test\n-                    find_related_tests_in_module(sema, fn_def, &module, tests);\n+                    find_related_tests_in_module(sema, syntax, &fn_def, &module, tests);\n                 }\n             }\n         }\n     }\n }\n+\n fn find_related_tests_in_module(\n     sema: &Semantics<RootDatabase>,\n+    syntax: &SyntaxNode,\n     fn_def: &ast::Fn,\n     parent_module: &hir::Module,\n     tests: &mut FxHashSet<Runnable>,\n ) {\n-    if let Some(fn_name) = fn_def.name() {\n-        let mod_source = parent_module.definition_source(sema.db);\n-        let range = match mod_source.value {\n-            hir::ModuleSource::Module(m) => m.syntax().text_range(),\n-            hir::ModuleSource::BlockExpr(b) => b.syntax().text_range(),\n-            hir::ModuleSource::SourceFile(f) => f.syntax().text_range(),\n-        };\n+    let fn_name = match fn_def.name() {\n+        Some(it) => it,\n+        _ => return,\n+    };\n+    let mod_source = parent_module.definition_source(sema.db);\n+    let range = match &mod_source.value {\n+        hir::ModuleSource::Module(m) => m.syntax().text_range(),\n+        hir::ModuleSource::BlockExpr(b) => b.syntax().text_range(),\n+        hir::ModuleSource::SourceFile(f) => f.syntax().text_range(),\n+    };\n \n-        let file_id = mod_source.file_id.original_file(sema.db);\n-        let mod_scope = SearchScope::file_range(FileRange { file_id, range });\n-        let fn_pos = FilePosition { file_id, offset: fn_name.syntax().text_range().start() };\n-        find_related_tests(sema, fn_pos, Some(mod_scope), tests)\n-    }\n+    let file_id = mod_source.file_id.original_file(sema.db);\n+    let mod_scope = SearchScope::file_range(FileRange { file_id, range });\n+    let fn_pos = FilePosition { file_id, offset: fn_name.syntax().text_range().start() };\n+    find_related_tests(sema, syntax, fn_pos, Some(mod_scope), tests)\n }\n \n fn as_test_runnable(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Option<Runnable> {\n@@ -294,24 +300,26 @@ fn parent_test_module(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Optio\n \n pub(crate) fn runnable_fn(sema: &Semantics<RootDatabase>, def: hir::Function) -> Option<Runnable> {\n     let func = def.source(sema.db)?;\n-    let name_string = def.name(sema.db).to_string();\n+    let name = def.name(sema.db).to_smol_str();\n \n     let root = def.module(sema.db).krate().root_module(sema.db);\n \n-    let kind = if name_string == \"main\" && def.module(sema.db) == root {\n+    let kind = if name == \"main\" && def.module(sema.db) == root {\n         RunnableKind::Bin\n     } else {\n-        let canonical_path = {\n-            let def: hir::ModuleDef = def.into();\n-            def.canonical_path(sema.db)\n+        let test_id = || {\n+            let canonical_path = {\n+                let def: hir::ModuleDef = def.into();\n+                def.canonical_path(sema.db)\n+            };\n+            canonical_path.map(TestId::Path).unwrap_or(TestId::Name(name))\n         };\n-        let test_id = canonical_path.map(TestId::Path).unwrap_or(TestId::Name(name_string));\n \n         if test_related_attribute(&func.value).is_some() {\n             let attr = TestAttr::from_fn(&func.value);\n-            RunnableKind::Test { test_id, attr }\n+            RunnableKind::Test { test_id: test_id(), attr }\n         } else if func.value.has_atom_attr(\"bench\") {\n-            RunnableKind::Bench { test_id }\n+            RunnableKind::Bench { test_id: test_id() }\n         } else {\n             return None;\n         }\n@@ -430,7 +438,7 @@ fn module_def_doctest(db: &RootDatabase, def: Definition) -> Option<Runnable> {\n         Some(path)\n     })();\n \n-    let test_id = path.map_or_else(|| TestId::Name(def_name.to_string()), TestId::Path);\n+    let test_id = path.map_or_else(|| TestId::Name(def_name.to_smol_str()), TestId::Path);\n \n     let mut nav = match def {\n         Definition::Module(def) => NavigationTarget::from_module_to_decl(db, def),"}]}