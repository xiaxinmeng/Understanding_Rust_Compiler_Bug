{"sha": "2ee97bd434f13b4be59e2d39ec0f7fc7f02c6ed0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZTk3YmQ0MzRmMTNiNGJlNTllMmQzOWVjMGY3ZmM3ZjAyYzZlZDA=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-04-08T09:49:17Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-04-08T13:32:22Z"}, "message": "Merge idents if they are part of a path", "tree": {"sha": "e6938edb5bffd403084cbe65d1cb3e0f4809054f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6938edb5bffd403084cbe65d1cb3e0f4809054f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ee97bd434f13b4be59e2d39ec0f7fc7f02c6ed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ee97bd434f13b4be59e2d39ec0f7fc7f02c6ed0", "html_url": "https://github.com/rust-lang/rust/commit/2ee97bd434f13b4be59e2d39ec0f7fc7f02c6ed0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ee97bd434f13b4be59e2d39ec0f7fc7f02c6ed0/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "html_url": "https://github.com/rust-lang/rust/commit/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1"}], "stats": {"total": 125, "additions": 107, "deletions": 18}, "files": [{"sha": "0030ef67c075d6cc0489dbe72510cfe76fbc2e07", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 107, "deletions": 18, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/2ee97bd434f13b4be59e2d39ec0f7fc7f02c6ed0/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee97bd434f13b4be59e2d39ec0f7fc7f02c6ed0/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=2ee97bd434f13b4be59e2d39ec0f7fc7f02c6ed0", "patch": "@@ -136,6 +136,16 @@ impl Iterator for TokenIter<'a> {\n     }\n }\n \n+fn get_real_ident_class(text: &str, edition: Edition) -> Class {\n+    match text {\n+        \"ref\" | \"mut\" => Class::RefKeyWord,\n+        \"self\" | \"Self\" => Class::Self_,\n+        \"false\" | \"true\" => Class::Bool,\n+        _ if Symbol::intern(text).is_reserved(|| edition) => Class::KeyWord,\n+        _ => Class::Ident,\n+    }\n+}\n+\n /// Processes program tokens, classifying strings of text by highlighting\n /// category (`Class`).\n struct Classifier<'a> {\n@@ -144,6 +154,8 @@ struct Classifier<'a> {\n     in_macro: bool,\n     in_macro_nonterminal: bool,\n     edition: Edition,\n+    byte_pos: u32,\n+    src: &'a str,\n }\n \n impl<'a> Classifier<'a> {\n@@ -155,6 +167,68 @@ impl<'a> Classifier<'a> {\n             in_macro: false,\n             in_macro_nonterminal: false,\n             edition,\n+            byte_pos: 0,\n+            src,\n+        }\n+    }\n+\n+    /// Concatenate colons and idents as one when possible.\n+    fn get_full_ident_path(&mut self) -> Vec<(TokenKind, usize, usize)> {\n+        let start = self.byte_pos as usize;\n+        let mut pos = start;\n+        let mut has_ident = false;\n+        let edition = self.edition;\n+\n+        loop {\n+            let mut nb = 0;\n+            while let Some((TokenKind::Colon, _)) = self.tokens.peek() {\n+                self.tokens.next();\n+                nb += 1;\n+            }\n+            // Ident path can start with \"::\" but if we already have content in the ident path,\n+            // the \"::\" is mandatory.\n+            if has_ident && nb == 0 {\n+                return vec![(TokenKind::Ident, start, pos)];\n+            } else if nb != 0 && nb != 2 {\n+                if has_ident {\n+                    return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];\n+                } else {\n+                    return vec![(TokenKind::Colon, pos, pos + nb)];\n+                }\n+            }\n+\n+            if let Some((Class::Ident, text)) = self.tokens.peek().map(|(token, text)| {\n+                if *token == TokenKind::Ident {\n+                    let class = get_real_ident_class(text, edition);\n+                    (class, text)\n+                } else {\n+                    // Doesn't matter which Class we put in here...\n+                    (Class::Comment, text)\n+                }\n+            }) {\n+                // We only \"add\" the colon if there is an ident behind.\n+                pos += text.len() + nb;\n+                has_ident = true;\n+                self.tokens.next();\n+            } else if nb > 0 && has_ident {\n+                return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];\n+            } else if nb > 0 {\n+                return vec![(TokenKind::Colon, pos, pos + nb)];\n+            } else if has_ident {\n+                return vec![(TokenKind::Ident, start, pos)];\n+            } else {\n+                return Vec::new();\n+            }\n+        }\n+    }\n+\n+    /// Wraps the tokens iteration to ensure that the byte_pos is always correct.\n+    fn next(&mut self) -> Option<(TokenKind, &'a str)> {\n+        if let Some((kind, text)) = self.tokens.next() {\n+            self.byte_pos += text.len() as u32;\n+            Some((kind, text))\n+        } else {\n+            None\n         }\n     }\n \n@@ -165,8 +239,25 @@ impl<'a> Classifier<'a> {\n     /// token is used.\n     fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'a>)) {\n         with_default_session_globals(|| {\n-            while let Some((token, text)) = self.tokens.next() {\n-                self.advance(token, text, sink);\n+            loop {\n+                if self\n+                    .tokens\n+                    .peek()\n+                    .map(|t| matches!(t.0, TokenKind::Colon | TokenKind::Ident))\n+                    .unwrap_or(false)\n+                {\n+                    let tokens = self.get_full_ident_path();\n+                    for (token, start, end) in tokens {\n+                        let text = &self.src[start..end];\n+                        self.advance(token, text, sink);\n+                        self.byte_pos += text.len() as u32;\n+                    }\n+                }\n+                if let Some((token, text)) = self.next() {\n+                    self.advance(token, text, sink);\n+                } else {\n+                    break;\n+                }\n             }\n         })\n     }\n@@ -203,12 +294,12 @@ impl<'a> Classifier<'a> {\n             },\n             TokenKind::And => match lookahead {\n                 Some(TokenKind::And) => {\n-                    let _and = self.tokens.next();\n+                    self.next();\n                     sink(Highlight::Token { text: \"&&\", class: Some(Class::Op) });\n                     return;\n                 }\n                 Some(TokenKind::Eq) => {\n-                    let _eq = self.tokens.next();\n+                    self.next();\n                     sink(Highlight::Token { text: \"&=\", class: Some(Class::Op) });\n                     return;\n                 }\n@@ -260,7 +351,7 @@ impl<'a> Classifier<'a> {\n                 match lookahead {\n                     // Case 1: #![inner_attribute]\n                     Some(TokenKind::Bang) => {\n-                        let _not = self.tokens.next().unwrap();\n+                        self.next();\n                         if let Some(TokenKind::OpenBracket) = self.peek() {\n                             self.in_attribute = true;\n                             sink(Highlight::EnterSpan { class: Class::Attribute });\n@@ -304,19 +395,17 @@ impl<'a> Classifier<'a> {\n                 sink(Highlight::Token { text, class: None });\n                 return;\n             }\n-            TokenKind::Ident => match text {\n-                \"ref\" | \"mut\" => Class::RefKeyWord,\n-                \"self\" | \"Self\" => Class::Self_,\n-                \"false\" | \"true\" => Class::Bool,\n-                \"Option\" | \"Result\" => Class::PreludeTy,\n-                \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n-                // Keywords are also included in the identifier set.\n-                _ if Symbol::intern(text).is_reserved(|| self.edition) => Class::KeyWord,\n-                _ if self.in_macro_nonterminal => {\n-                    self.in_macro_nonterminal = false;\n-                    Class::MacroNonTerminal\n-                }\n-                _ => Class::Ident,\n+            TokenKind::Ident => match get_real_ident_class(text, self.edition) {\n+                Class::Ident => match text {\n+                    \"Option\" | \"Result\" => Class::PreludeTy,\n+                    \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n+                    _ if self.in_macro_nonterminal => {\n+                        self.in_macro_nonterminal = false;\n+                        Class::MacroNonTerminal\n+                    }\n+                    _ => Class::Ident,\n+                },\n+                c => c,\n             },\n             TokenKind::RawIdent => Class::Ident,\n             TokenKind::Lifetime { .. } => Class::Lifetime,"}]}