{"sha": "eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZGIxY2M1NzY1YjA0M2YzMWNhNDMxNmM0MmYyYWM4ZDdkZjE5MTk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-07T11:41:33Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-07T12:03:09Z"}, "message": "rename ADTDef to AdtDef etc.", "tree": {"sha": "8d8d57104da8015eb928330cd5d26f57b34f25f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d8d57104da8015eb928330cd5d26f57b34f25f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "html_url": "https://github.com/rust-lang/rust/commit/eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/comments", "author": null, "committer": null, "parents": [{"sha": "62cd3cc46b533c3d1b6c94cc1d13a3be8a8c23ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/62cd3cc46b533c3d1b6c94cc1d13a3be8a8c23ab", "html_url": "https://github.com/rust-lang/rust/commit/62cd3cc46b533c3d1b6c94cc1d13a3be8a8c23ab"}], "stats": {"total": 309, "additions": 164, "deletions": 145}, "files": [{"sha": "217868f1b9c696d8206d108b54d4b6984813552c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -213,7 +213,7 @@ pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDe\n     decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n-pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> &'tcx ty::ADTDef_<'tcx, 'tcx> {\n+pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::AdtDefMaster<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_adt_def(&cstore.intr, &*cdata, def.node, tcx)"}, {"sha": "df5f798217f4b96e3dd7c061cacc18cc0e5d541d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -393,12 +393,12 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                          cdata: Cmd,\n                          item_id: ast::NodeId,\n-                         tcx: &ty::ctxt<'tcx>) -> &'tcx ty::ADTDef_<'tcx, 'tcx>\n+                         tcx: &ty::ctxt<'tcx>) -> ty::AdtDefMaster<'tcx>\n {\n     fn get_enum_variants<'tcx>(intr: &IdentInterner,\n                                cdata: Cmd,\n                                doc: rbml::Doc,\n-                               tcx: &ty::ctxt<'tcx>) -> Vec<ty::VariantDef_<'tcx, 'tcx>> {\n+                               tcx: &ty::ctxt<'tcx>) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n         let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n@@ -410,7 +410,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             let disr = disr_val;\n             disr_val = disr_val.wrapping_add(1);\n \n-            ty::VariantDef_ {\n+            ty::VariantDefData {\n                 did: did,\n                 name: item_name(intr, item),\n                 fields: get_variant_fields(intr, cdata, item, tcx),\n@@ -421,29 +421,29 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     fn get_variant_fields<'tcx>(intr: &IdentInterner,\n                                 cdata: Cmd,\n                                 doc: rbml::Doc,\n-                                tcx: &ty::ctxt<'tcx>) -> Vec<ty::FieldDef_<'tcx, 'tcx>> {\n+                                tcx: &ty::ctxt<'tcx>) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n         reader::tagged_docs(doc, tag_item_field).map(|f| {\n             let ff = item_family(f);\n             match ff {\n                 PublicField | InheritedField => {},\n                 _ => tcx.sess.bug(&format!(\"expected field, found {:?}\", ff))\n             };\n-            ty::FieldDef_::new(item_def_id(f, cdata),\n-                               item_name(intr, f),\n-                               struct_field_family_to_visibility(ff))\n+            ty::FieldDefData::new(item_def_id(f, cdata),\n+                                  item_name(intr, f),\n+                                  struct_field_family_to_visibility(ff))\n         }).chain(reader::tagged_docs(doc, tag_item_unnamed_field).map(|f| {\n             let ff = item_family(f);\n-            ty::FieldDef_::new(item_def_id(f, cdata),\n-                               special_idents::unnamed_field.name,\n-                               struct_field_family_to_visibility(ff))\n+            ty::FieldDefData::new(item_def_id(f, cdata),\n+                                  special_idents::unnamed_field.name,\n+                                  struct_field_family_to_visibility(ff))\n         })).collect()\n     }\n     fn get_struct_variant<'tcx>(intr: &IdentInterner,\n                                 cdata: Cmd,\n                                 doc: rbml::Doc,\n                                 did: ast::DefId,\n-                                tcx: &ty::ctxt<'tcx>) -> ty::VariantDef_<'tcx, 'tcx> {\n-        ty::VariantDef_ {\n+                                tcx: &ty::ctxt<'tcx>) -> ty::VariantDefData<'tcx, 'tcx> {\n+        ty::VariantDefData {\n             did: did,\n             name: item_name(intr, doc),\n             fields: get_variant_fields(intr, cdata, doc, tcx),\n@@ -454,9 +454,9 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     let doc = lookup_item(item_id, cdata.data());\n     let did = ast::DefId { krate: cdata.cnum, node: item_id };\n     let (kind, variants) = match item_family(doc) {\n-        Enum => (ty::ADTKind::Enum,\n+        Enum => (ty::AdtKind::Enum,\n                  get_enum_variants(intr, cdata, doc, tcx)),\n-        Struct => (ty::ADTKind::Struct,\n+        Struct => (ty::AdtKind::Struct,\n                    vec![get_struct_variant(intr, cdata, doc, did, tcx)]),\n         _ => tcx.sess.bug(\"get_adt_def called on a non-ADT\")\n     };\n@@ -467,7 +467,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     // to support recursive structures\n     for variant in &adt.variants {\n         if variant.kind() == ty::VariantKind::Tuple &&\n-            adt.adt_kind() == ty::ADTKind::Enum {\n+            adt.adt_kind() == ty::AdtKind::Enum {\n             // tuple-like enum variant fields aren't real items - get the types\n             // from the ctor.\n             debug!(\"evaluating the ctor-type of {:?}\","}, {"sha": "d5c189ff044d2ea3006479ac431d041253a9822e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -265,9 +265,9 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n-                        fields: &[ty::FieldDef],\n+                        variant: ty::VariantDef,\n                         origin: DefId) {\n-    for f in fields {\n+    for f in &variant.fields {\n         if f.name == special_idents::unnamed_field.name {\n             rbml_w.start_tag(tag_item_unnamed_field);\n         } else {\n@@ -315,14 +315,11 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n \n         if let ty::VariantKind::Dict = variant.kind() {\n-            let idx = encode_info_for_struct(ecx,\n-                                             rbml_w,\n-                                             &variant.fields,\n-                                             index);\n+            let idx = encode_info_for_struct(ecx, rbml_w, variant, index);\n             encode_index(rbml_w, idx, write_i64);\n         }\n \n-        encode_struct_fields(rbml_w, &variant.fields, vid);\n+        encode_struct_fields(rbml_w, variant, vid);\n \n         let specified_disr_val = variant.disr_val;\n         if specified_disr_val != disr_val {\n@@ -630,15 +627,15 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n /* Returns an index of items in this class */\n fn encode_info_for_struct<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n-                                    fields: &[ty::FieldDef<'tcx>],\n+                                    variant: ty::VariantDef<'tcx>,\n                                     global_index: &mut Vec<entry<i64>>)\n                                     -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let mut index = Vec::new();\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-    for field in fields {\n+    for field in &variant.fields {\n         let nm = field.name;\n         let id = field.did.node;\n \n@@ -1153,13 +1150,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n         let def = ecx.tcx.lookup_adt_def(def_id);\n-        let fields = &def.struct_variant().fields;\n+        let variant = def.struct_variant();\n \n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        let idx = encode_info_for_struct(ecx, rbml_w, &fields, index);\n+        let idx = encode_info_for_struct(ecx, rbml_w, variant, index);\n \n         /* Index the class*/\n         add_to_index(item, rbml_w, index);\n@@ -1181,7 +1178,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, &fields, def_id);\n+        encode_struct_fields(rbml_w, variant, def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n "}, {"sha": "b9d8e4b842d01a607c68d22372c4558fa9194f2d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -574,8 +574,10 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     })\n }\n \n-impl<'tcx> ADTDef<'tcx> {\n-    fn variant_of_ctor(&'tcx self, ctor: &Constructor) -> &'tcx VariantDef<'tcx> {\n+impl<'tcx, 'container> ty::AdtDefData<'tcx, 'container> {\n+    fn variant_of_ctor(&self,\n+                       ctor: &Constructor)\n+                       -> &VariantDefData<'tcx, 'container> {\n         match ctor {\n             &Variant(vid) => self.variant_with_id(vid),\n             _ => self.struct_variant()"}, {"sha": "3755b4c57c3ece41d91e456e0627e345bb7c9974", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -723,7 +723,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // are properly handled.\n         self.walk_expr(with_expr);\n \n-        fn contains_field_named(field: &ty::FieldDef,\n+        fn contains_field_named(field: ty::FieldDef,\n                                 fields: &Vec<ast::Field>)\n                                 -> bool\n         {"}, {"sha": "534a2fc054da7034c6ba0cd96fe710f27cc2d497", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -278,8 +278,8 @@ fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n-        ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.is_fundamental()\n-            ,\n+        ty::TyEnum(def, _) | ty::TyStruct(def, _) =>\n+            def.is_fundamental(),\n         ty::TyTrait(ref data) =>\n             tcx.has_attr(data.principal_def_id(), \"fundamental\"),\n         _ =>"}, {"sha": "2fe1f14d521ba3a7e881dbc36f8c9edfceba411d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 89, "deletions": 73, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -638,7 +638,7 @@ pub struct CtxtArenas<'tcx> {\n \n     // references\n     trait_defs: TypedArena<TraitDef<'tcx>>,\n-    adt_defs: TypedArena<ADTDef_<'tcx, 'tcx>>,\n+    adt_defs: TypedArena<AdtDefData<'tcx, 'tcx>>,\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -766,7 +766,7 @@ pub struct ctxt<'tcx> {\n \n     pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<&'tcx TraitDef<'tcx>>>,\n-    pub adt_defs: RefCell<DefIdMap<&'tcx ADTDef_<'tcx, 'tcx>>>,\n+    pub adt_defs: RefCell<DefIdMap<AdtDefMaster<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated predicates.\n@@ -937,10 +937,10 @@ impl<'tcx> ctxt<'tcx> {\n \n     pub fn intern_adt_def(&self,\n                           did: DefId,\n-                          kind: ADTKind,\n-                          variants: Vec<VariantDef_<'tcx, 'tcx>>)\n-                          -> &'tcx ADTDef_<'tcx, 'tcx> {\n-        let def = ADTDef_::new(self, did, kind, variants);\n+                          kind: AdtKind,\n+                          variants: Vec<VariantDefData<'tcx, 'tcx>>)\n+                          -> AdtDefMaster<'tcx> {\n+        let def = AdtDefData::new(self, did, kind, variants);\n         let interned = self.arenas.adt_defs.alloc(def);\n         // this will need a transmute when reverse-variance is removed\n         self.adt_defs.borrow_mut().insert(did, interned);\n@@ -1746,12 +1746,12 @@ pub enum TypeVariants<'tcx> {\n     /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n     /// well.\n-    TyEnum(&'tcx ADTDef<'tcx>, &'tcx Substs<'tcx>),\n+    TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// A structure type, defined with `struct`.\n     ///\n     /// See warning about substitutions for enumerated types.\n-    TyStruct(&'tcx ADTDef<'tcx>, &'tcx Substs<'tcx>),\n+    TyStruct(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n@@ -3177,7 +3177,7 @@ impl<'tcx> TraitDef<'tcx> {\n }\n \n bitflags! {\n-    flags ADTFlags: u32 {\n+    flags AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0,\n         const IS_ENUM             = 1 << 0,\n         const IS_DTORCK           = 1 << 1, // is this a dtorck type?\n@@ -3188,18 +3188,23 @@ bitflags! {\n     }\n }\n \n-pub type ADTDef<'tcx> = ADTDef_<'tcx, 'static>;\n-pub type VariantDef<'tcx> = VariantDef_<'tcx, 'static>;\n-pub type FieldDef<'tcx> = FieldDef_<'tcx, 'static>;\n+pub type AdtDef<'tcx> = &'tcx AdtDefData<'tcx, 'static>;\n+pub type VariantDef<'tcx> = &'tcx VariantDefData<'tcx, 'static>;\n+pub type FieldDef<'tcx> = &'tcx FieldDefData<'tcx, 'static>;\n \n-pub struct VariantDef_<'tcx, 'container: 'tcx> {\n+// See comment on AdtDefData for explanation\n+pub type AdtDefMaster<'tcx> = &'tcx AdtDefData<'tcx, 'tcx>;\n+pub type VariantDefMaster<'tcx> = &'tcx VariantDefData<'tcx, 'tcx>;\n+pub type FieldDefMaster<'tcx> = &'tcx FieldDefData<'tcx, 'tcx>;\n+\n+pub struct VariantDefData<'tcx, 'container: 'tcx> {\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n-    pub fields: Vec<FieldDef_<'tcx, 'container>>\n+    pub fields: Vec<FieldDefData<'tcx, 'container>>\n }\n \n-pub struct FieldDef_<'tcx, 'container: 'tcx> {\n+pub struct FieldDefData<'tcx, 'container: 'tcx> {\n     /// The field's DefId. NOTE: the fields of tuple-like enum variants\n     /// are not real items, and don't have entries in tcache etc.\n     pub did: DefId,\n@@ -3208,7 +3213,7 @@ pub struct FieldDef_<'tcx, 'container: 'tcx> {\n     pub name: Name,\n     pub vis: ast::Visibility,\n     /// TyIVar is used here to allow for variance (see the doc at\n-    /// ADTDef_).\n+    /// AdtDefData).\n     ty: TyIVar<'tcx, 'container>\n }\n \n@@ -3221,60 +3226,60 @@ pub struct FieldDef_<'tcx, 'container: 'tcx> {\n /// needs 2 lifetimes: the traditional variant lifetime ('tcx)\n /// bounding the lifetime of the inner types is of course necessary.\n /// However, it is not sufficient - types from a child tcx must\n-/// not be leaked into the master tcx by being stored in an ADTDef_.\n+/// not be leaked into the master tcx by being stored in an AdtDefData.\n ///\n /// The 'container lifetime ensures that by outliving the container\n /// tcx and preventing shorter-lived types from being inserted. When\n /// write access is not needed, the 'container lifetime can be\n-/// erased to 'static, which can be done by the ADTDef wrapper.\n-pub struct ADTDef_<'tcx, 'container: 'tcx> {\n+/// erased to 'static, which can be done by the AdtDef wrapper.\n+pub struct AdtDefData<'tcx, 'container: 'tcx> {\n     pub did: DefId,\n-    pub variants: Vec<VariantDef_<'tcx, 'container>>,\n-    flags: Cell<ADTFlags>,\n+    pub variants: Vec<VariantDefData<'tcx, 'container>>,\n+    flags: Cell<AdtFlags>,\n }\n \n-impl<'tcx, 'container> PartialEq for ADTDef_<'tcx, 'container> {\n-    // ADTDef are always interned and this is part of TyS equality\n+impl<'tcx, 'container> PartialEq for AdtDefData<'tcx, 'container> {\n+    // AdtDefData are always interned and this is part of TyS equality\n     #[inline]\n     fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n }\n \n-impl<'tcx, 'container> Eq for ADTDef_<'tcx, 'container> {}\n+impl<'tcx, 'container> Eq for AdtDefData<'tcx, 'container> {}\n \n-impl<'tcx, 'container> Hash for ADTDef_<'tcx, 'container> {\n+impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const ADTDef).hash(s)\n+        (self as *const AdtDefData).hash(s)\n     }\n }\n \n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum ADTKind { Struct, Enum }\n+pub enum AdtKind { Struct, Enum }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum VariantKind { Dict, Tuple, Unit }\n \n-impl<'tcx, 'container> ADTDef_<'tcx, 'container> {\n+impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     fn new(tcx: &ctxt<'tcx>,\n            did: DefId,\n-           kind: ADTKind,\n-           variants: Vec<VariantDef_<'tcx, 'container>>) -> Self {\n-        let mut flags = ADTFlags::NO_ADT_FLAGS;\n+           kind: AdtKind,\n+           variants: Vec<VariantDefData<'tcx, 'container>>) -> Self {\n+        let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attrs.iter().any(|item| item.check_name(\"fundamental\")) {\n-            flags = flags | ADTFlags::IS_FUNDAMENTAL;\n+            flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n         if attrs.iter().any(|item| item.check_name(\"simd\")) {\n-            flags = flags | ADTFlags::IS_SIMD;\n+            flags = flags | AdtFlags::IS_SIMD;\n         }\n         if Some(did) == tcx.lang_items.phantom_data() {\n-            flags = flags | ADTFlags::IS_PHANTOM_DATA;\n+            flags = flags | AdtFlags::IS_PHANTOM_DATA;\n         }\n-        if let ADTKind::Enum = kind {\n-            flags = flags | ADTFlags::IS_ENUM;\n+        if let AdtKind::Enum = kind {\n+            flags = flags | AdtFlags::IS_ENUM;\n         }\n-        ADTDef {\n+        AdtDefData {\n             did: did,\n             variants: variants,\n             flags: Cell::new(flags),\n@@ -3283,18 +3288,18 @@ impl<'tcx, 'container> ADTDef_<'tcx, 'container> {\n \n     fn calculate_dtorck(&'tcx self, tcx: &ctxt<'tcx>) {\n         if tcx.is_adt_dtorck(self) {\n-            self.flags.set(self.flags.get() | ADTFlags::IS_DTORCK);\n+            self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK);\n         }\n-        self.flags.set(self.flags.get() | ADTFlags::IS_DTORCK_VALID)\n+        self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n     /// Returns the kind of the ADT - Struct or Enum.\n     #[inline]\n-    pub fn adt_kind(&self) -> ADTKind {\n-        if self.flags.get().intersects(ADTFlags::IS_ENUM) {\n-            ADTKind::Enum\n+    pub fn adt_kind(&self) -> AdtKind {\n+        if self.flags.get().intersects(AdtFlags::IS_ENUM) {\n+            AdtKind::Enum\n         } else {\n-            ADTKind::Struct\n+            AdtKind::Struct\n         }\n     }\n \n@@ -3303,28 +3308,28 @@ impl<'tcx, 'container> ADTDef_<'tcx, 'container> {\n     /// alive; Otherwise, only the contents are required to be.\n     #[inline]\n     pub fn is_dtorck(&'tcx self, tcx: &ctxt<'tcx>) -> bool {\n-        if !self.flags.get().intersects(ADTFlags::IS_DTORCK_VALID) {\n+        if !self.flags.get().intersects(AdtFlags::IS_DTORCK_VALID) {\n             self.calculate_dtorck(tcx)\n         }\n-        self.flags.get().intersects(ADTFlags::IS_DTORCK)\n+        self.flags.get().intersects(AdtFlags::IS_DTORCK)\n     }\n \n     /// Returns whether this type is #[fundamental] for the purposes\n     /// of coherence checking.\n     #[inline]\n     pub fn is_fundamental(&self) -> bool {\n-        self.flags.get().intersects(ADTFlags::IS_FUNDAMENTAL)\n+        self.flags.get().intersects(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n     #[inline]\n     pub fn is_simd(&self) -> bool {\n-        self.flags.get().intersects(ADTFlags::IS_SIMD)\n+        self.flags.get().intersects(AdtFlags::IS_SIMD)\n     }\n \n     /// Returns true if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n-        self.flags.get().intersects(ADTFlags::IS_PHANTOM_DATA)\n+        self.flags.get().intersects(AdtFlags::IS_PHANTOM_DATA)\n     }\n \n     /// Returns whether this type has a destructor.\n@@ -3334,8 +3339,8 @@ impl<'tcx, 'container> ADTDef_<'tcx, 'container> {\n \n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n-    pub fn struct_variant(&self) -> &ty::VariantDef_<'tcx, 'container> {\n-        assert!(self.adt_kind() == ADTKind::Struct);\n+    pub fn struct_variant(&self) -> &VariantDefData<'tcx, 'container> {\n+        assert!(self.adt_kind() == AdtKind::Struct);\n         &self.variants[0]\n     }\n \n@@ -3354,12 +3359,12 @@ impl<'tcx, 'container> ADTDef_<'tcx, 'container> {\n     #[inline]\n     pub fn all_fields(&self) ->\n             iter::FlatMap<\n-                slice::Iter<VariantDef_<'tcx, 'container>>,\n-                slice::Iter<FieldDef_<'tcx, 'container>>,\n-                for<'s> fn(&'s VariantDef_<'tcx, 'container>)\n-                    -> slice::Iter<'s, FieldDef_<'tcx, 'container>>\n+                slice::Iter<VariantDefData<'tcx, 'container>>,\n+                slice::Iter<FieldDefData<'tcx, 'container>>,\n+                for<'s> fn(&'s VariantDefData<'tcx, 'container>)\n+                    -> slice::Iter<'s, FieldDefData<'tcx, 'container>>\n             > {\n-        self.variants.iter().flat_map(VariantDef_::fields_iter)\n+        self.variants.iter().flat_map(VariantDefData::fields_iter)\n     }\n \n     #[inline]\n@@ -3377,14 +3382,14 @@ impl<'tcx, 'container> ADTDef_<'tcx, 'container> {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef_<'tcx, 'container> {\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'tcx, 'container> {\n         self.variants\n             .iter()\n             .find(|v| v.did == vid)\n             .expect(\"variant_with_id: unknown variant\")\n     }\n \n-    pub fn variant_of_def(&self, def: def::Def) -> &VariantDef_<'tcx, 'container> {\n+    pub fn variant_of_def(&self, def: def::Def) -> &VariantDefData<'tcx, 'container> {\n         match def {\n             def::DefVariant(_, vid, _) => self.variant_with_id(vid),\n             def::DefStruct(..) | def::DefTy(..) => self.struct_variant(),\n@@ -3393,16 +3398,16 @@ impl<'tcx, 'container> ADTDef_<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx, 'container> VariantDef_<'tcx, 'container> {\n+impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n     #[inline]\n-    fn fields_iter(&self) -> slice::Iter<FieldDef_<'tcx, 'container>> {\n+    fn fields_iter(&self) -> slice::Iter<FieldDefData<'tcx, 'container>> {\n         self.fields.iter()\n     }\n \n     pub fn kind(&self) -> VariantKind {\n         match self.fields.get(0) {\n             None => VariantKind::Unit,\n-            Some(&FieldDef_ { name, .. }) if name == special_idents::unnamed_field.name => {\n+            Some(&FieldDefData { name, .. }) if name == special_idents::unnamed_field.name => {\n                 VariantKind::Tuple\n             }\n             Some(_) => VariantKind::Dict\n@@ -3414,21 +3419,23 @@ impl<'tcx, 'container> VariantDef_<'tcx, 'container> {\n     }\n \n     #[inline]\n-    pub fn find_field_named(&self, name: ast::Name) -> Option<&FieldDef_<'tcx, 'container>> {\n+    pub fn find_field_named(&self,\n+                            name: ast::Name)\n+                            -> Option<&FieldDefData<'tcx, 'container>> {\n         self.fields.iter().find(|f| f.name == name)\n     }\n \n     #[inline]\n-    pub fn field_named(&self, name: ast::Name) -> &FieldDef_<'tcx, 'container> {\n+    pub fn field_named(&self, name: ast::Name) -> &FieldDefData<'tcx, 'container> {\n         self.find_field_named(name).unwrap()\n     }\n }\n \n-impl<'tcx, 'container> FieldDef_<'tcx, 'container> {\n+impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n                vis: ast::Visibility) -> Self {\n-        FieldDef_ {\n+        FieldDefData {\n             did: did,\n             name: name,\n             vis: vis,\n@@ -3934,7 +3941,7 @@ impl<'tcx> ctxt<'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_enum(&self, def: &'tcx ADTDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_enum(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyEnum(def, substs))\n     }\n@@ -4036,7 +4043,7 @@ impl<'tcx> ctxt<'tcx> {\n         self.mk_ty(TyProjection(inner))\n     }\n \n-    pub fn mk_struct(&self, def: &'tcx ADTDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_struct(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyStruct(def, substs))\n     }\n@@ -4327,7 +4334,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn ty_adt_def(&self) -> Option<&'tcx ADTDef<'tcx>> {\n+    pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n         match self.sty {\n             TyStruct(adt, _) | TyEnum(adt, _) => Some(adt),\n             _ => None\n@@ -4677,7 +4684,7 @@ impl<'tcx> TyS<'tcx> {\n \n     // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n     pub fn is_instantiable(&'tcx self, cx: &ctxt<'tcx>) -> bool {\n-        fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<&'tcx ADTDef<'tcx>>,\n+        fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<AdtDef<'tcx>>,\n                                r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n             debug!(\"type_requires({:?}, {:?})?\",\n                    r_ty, ty);\n@@ -4689,7 +4696,7 @@ impl<'tcx> TyS<'tcx> {\n             return r;\n         }\n \n-        fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<&'tcx ADTDef<'tcx>>,\n+        fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<AdtDef<'tcx>>,\n                                   r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n             debug!(\"subtypes_require({:?}, {:?})?\",\n                    r_ty, ty);\n@@ -4826,7 +4833,7 @@ impl<'tcx> TyS<'tcx> {\n             }\n         }\n \n-        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ADTDef<'tcx>) -> bool {\n+        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: AdtDef<'tcx>) -> bool {\n             match ty.sty {\n                 TyStruct(ty_def, _) | TyEnum(ty_def, _) => {\n                      ty_def == def\n@@ -5969,14 +5976,23 @@ impl<'tcx> ctxt<'tcx> {\n         )\n     }\n \n-    /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_adt_def(&self, did: ast::DefId) -> &'tcx ADTDef_<'tcx, 'tcx> {\n+    /// Given the did of an ADT, return a master reference to its\n+    /// definition. Unless you are planning on fulfilling the ADT's fields,\n+    /// use lookup_adt_def instead.\n+    pub fn lookup_adt_def_master(&self, did: ast::DefId) -> AdtDefMaster<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n             || csearch::get_adt_def(self, did)\n         )\n     }\n \n+    /// Given the did of an ADT, return a reference to its definition.\n+    pub fn lookup_adt_def(&self, did: ast::DefId) -> AdtDef<'tcx> {\n+        // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n+        // woud be needed here.\n+        self.lookup_adt_def_master(did)\n+    }\n+\n     /// Given the did of an item, returns its full set of predicates.\n     pub fn lookup_predicates(&self, did: ast::DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n@@ -6610,7 +6626,7 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Returns true if this ADT is a dtorck type, i.e. whether it being\n     /// safe for destruction requires it to be alive\n-    fn is_adt_dtorck(&self, adt: &'tcx ADTDef<'tcx>) -> bool {\n+    fn is_adt_dtorck(&self, adt: AdtDef<'tcx>) -> bool {\n         let dtor_method = match self.destructor_for_type.borrow().get(&adt.did) {\n             Some(dtor) => *dtor,\n             None => return false"}, {"sha": "da20f730babab3bef80cae4c11de67fb4ab75ee5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -366,7 +366,7 @@ impl<'tcx> fmt::Debug for ty::TraitDef<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ADTDef<'tcx> {\n+impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| {\n             write!(f, \"{}\", tcx.item_path_str(self.did))"}, {"sha": "dabe1b984df2a57fad9550d67be17c411f5b63ce", "filename": "src/librustc_data_structures/ivar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_data_structures%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_data_structures%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fivar.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -20,6 +20,10 @@ use std::cell::Cell;\n /// if you attempt to read the value before it has been set. It is also\n /// not `Sync`, but may be extended in the future to be usable as a true\n /// concurrency type.\n+///\n+/// The `T: Copy` bound is not strictly needed, but it is required by\n+/// Cell (so removing it would require using UnsafeCell), and it\n+/// suffices for the current purposes.\n #[derive(PartialEq)]\n pub struct Ivar<T: Copy> {\n     data: Cell<Option<T>>"}, {"sha": "8f5519faf7a02a37b23ee738924bbf9bfb158d11", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -413,7 +413,7 @@ enum FfiResult {\n /// expanded to cover NonZero raw pointers and newtypes.\n /// FIXME: This duplicates code in trans.\n fn is_repr_nullable_ptr<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              def: &ty::ADTDef<'tcx>,\n+                              def: ty::AdtDef<'tcx>,\n                               substs: &Substs<'tcx>)\n                               -> bool {\n     if def.variants.len() == 2 {"}, {"sha": "d10dc2e05ffd04e0b93f9ba3d0a2d7d3feeffe36", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -687,8 +687,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a field is in scope.\n     fn check_field(&mut self,\n                    span: Span,\n-                   def: &'tcx ty::ADTDef<'tcx>,\n-                   v: &'tcx ty::VariantDef<'tcx>,\n+                   def: ty::AdtDef<'tcx>,\n+                   v: ty::VariantDef<'tcx>,\n                    name: FieldName) {\n         let field = match name {\n             NamedField(f_name) => {\n@@ -703,10 +703,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         }\n \n         let struct_desc = match def.adt_kind() {\n-            ty::ADTKind::Struct =>\n+            ty::AdtKind::Struct =>\n                 format!(\"struct `{}`\", self.tcx.item_path_str(def.did)),\n             // struct variant fields have inherited visibility\n-            ty::ADTKind::Enum => return\n+            ty::AdtKind::Enum => return\n         };\n         let msg = match name {\n             NamedField(name) => format!(\"field `{}` of {} is private\","}, {"sha": "707d4c4a844856bf925434cddf8fc87602b74cad", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -742,7 +742,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                           ex: &ast::Expr,\n                           path: &ast::Path,\n                           fields: &Vec<ast::Field>,\n-                          variant: &ty::VariantDef,\n+                          variant: ty::VariantDef,\n                           base: &Option<P<ast::Expr>>) {\n         if generated_code(path.span) {\n             return"}, {"sha": "5bbd8ce154904ad55b7d752aa172c154bc845c7d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -613,7 +613,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n-                              variant: &ty::VariantDef,\n+                              variant: ty::VariantDef,\n                               parent: NodeId)\n                               -> VariableRefData {\n         let f = variant.field_named(field_ref.ident.node.name);"}, {"sha": "326d1e2361e6d3ad631a626a5ba5a8fc598130e4", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -527,7 +527,7 @@ impl<'tcx> Case<'tcx> {\n }\n \n fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                   adt: &ty::ADTDef<'tcx>,\n+                   adt: ty::AdtDef<'tcx>,\n                    substs: &subst::Substs<'tcx>)\n                    -> Vec<Case<'tcx>> {\n     adt.variants.iter().map(|vi| {"}, {"sha": "5f73fc52446d165c9d09efb69975bfc1ef5f1843", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -386,7 +386,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n     fn iter_variant<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                    repr: &adt::Repr<'tcx>,\n                                    av: ValueRef,\n-                                   variant: &ty::VariantDef<'tcx>,\n+                                   variant: ty::VariantDef<'tcx>,\n                                    substs: &Substs<'tcx>,\n                                    f: &mut F)\n                                    -> Block<'blk, 'tcx> where"}, {"sha": "f57612789b53fc8ab6377baece70f92c44a65c03", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -1242,7 +1242,7 @@ pub fn langcall(bcx: Block,\n /// Return the VariantDef corresponding to an inlined variant node\n pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      inlined_vid: ast::NodeId)\n-                                     -> &'tcx ty::VariantDef<'tcx>\n+                                     -> ty::VariantDef<'tcx>\n {\n \n     let ctor_ty = ccx.tcx().node_id_to_type(inlined_vid);"}, {"sha": "0be155b7727382ad5050e10d84c5f85aa206a11b", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -1094,7 +1094,7 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n-    variant: &'tcx ty::VariantDef<'tcx>,\n+    variant: ty::VariantDef<'tcx>,\n     substs: &'tcx subst::Substs<'tcx>,\n     is_simd: bool,\n     span: Span,\n@@ -1489,7 +1489,7 @@ enum EnumDiscriminantInfo {\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n                                    struct_def: &adt::Struct<'tcx>,\n-                                   variant: &ty::VariantDef<'tcx>,\n+                                   variant: ty::VariantDef<'tcx>,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)"}, {"sha": "c2d1d19935a034208efeb4ba351ccecd9c69e838", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -291,7 +291,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n /// Returns the normalized type of a struct field\n pub fn field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       param_substs: &Substs<'tcx>,\n-                      f: &ty::FieldDef<'tcx>)\n+                      f: ty::FieldDef<'tcx>)\n                       -> Ty<'tcx>\n {\n     normalize_associated_type(tcx, &f.ty(tcx, param_substs))"}, {"sha": "883e3659720a6c80a222082d2f6c635b2667dcb3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -717,7 +717,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                          span: Span,\n                                          fields: &'tcx [Spanned<ast::FieldPat>],\n-                                         variant: &ty::VariantDef<'tcx>,\n+                                         variant: ty::VariantDef<'tcx>,\n                                          substs: &Substs<'tcx>,\n                                          etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;"}, {"sha": "39e67beab583d18c8d77e88dcd302efa02a1b23c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -289,10 +289,10 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                 TypeContext::ADT { def_id, variant, field, field_index } => {\n                     let adt = tcx.lookup_adt_def(def_id);\n                     let variant_name = match adt.adt_kind() {\n-                        ty::ADTKind::Enum => format!(\"enum {} variant {}\",\n+                        ty::AdtKind::Enum => format!(\"enum {} variant {}\",\n                                                      tcx.item_path_str(def_id),\n                                                      variant),\n-                        ty::ADTKind::Struct => format!(\"struct {}\",\n+                        ty::AdtKind::Struct => format!(\"struct {}\",\n                                                        tcx.item_path_str(def_id))\n                     };\n                     let field_name = if field == special_idents::unnamed_field.name {"}, {"sha": "6221134afd38a490b737f0deecbf0f95f9df6c7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -1677,7 +1677,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // FIXME(arielb1): use this instead of field.ty everywhere\n     pub fn field_ty(&self,\n                     span: Span,\n-                    field: &ty::FieldDef<'tcx>,\n+                    field: ty::FieldDef<'tcx>,\n                     substs: &Substs<'tcx>)\n                     -> Ty<'tcx>\n     {\n@@ -2913,7 +2913,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     // displays hints about the closest matches in field names\n-    fn suggest_field_names<'tcx>(variant: &ty::VariantDef<'tcx>,\n+    fn suggest_field_names<'tcx>(variant: ty::VariantDef<'tcx>,\n                                  field: &ast::SpannedIdent,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  skip : Vec<InternedString>) {\n@@ -3011,7 +3011,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     fn report_unknown_field<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       ty: Ty<'tcx>,\n-                                      variant: &ty::VariantDef<'tcx>,\n+                                      variant: ty::VariantDef<'tcx>,\n                                       field: &ast::Field,\n                                       skip_fields: &[ast::Field]) {\n         fcx.type_error_message(\n@@ -3095,7 +3095,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     fn check_struct_constructor<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                          id: ast::NodeId,\n                                          span: codemap::Span,\n-                                         struct_def: &'tcx ty::ADTDef<'tcx>,\n+                                         struct_def: ty::AdtDef<'tcx>,\n                                          fields: &'tcx [ast::Field],\n                                          base_expr: Option<&'tcx ast::Expr>) {\n         let tcx = fcx.ccx.tcx;"}, {"sha": "dabc09db68d8e80faa2bb9446f77d82aaf0efb5b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -620,7 +620,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            struct_generics: &ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n                            v: &ast::StructField,\n-                           ty_f: &'tcx ty::FieldDef_<'tcx, 'tcx>)\n+                           ty_f: ty::FieldDefMaster<'tcx>)\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &*v.node.ty);\n     ty_f.fulfill_ty(tt);\n@@ -748,7 +748,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n             convert_enum_variant_types(ccx,\n-                                       tcx.lookup_adt_def(local_def(it.id)),\n+                                       tcx.lookup_adt_def_master(local_def(it.id)),\n                                        scheme,\n                                        predicates,\n                                        &enum_definition.variants);\n@@ -996,7 +996,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n \n-            let variant = tcx.lookup_adt_def(local_def(it.id)).struct_variant();\n+            let variant = tcx.lookup_adt_def_master(local_def(it.id)).struct_variant();\n \n             for (f, ty_f) in struct_def.fields.iter().zip(variant.fields.iter()) {\n                 convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n@@ -1023,7 +1023,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   ctor_id: ast::NodeId,\n-                                  variant: &'tcx ty::VariantDef<'tcx>,\n+                                  variant: ty::VariantDef<'tcx>,\n                                   scheme: ty::TypeScheme<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let ctor_ty = match variant.kind() {\n@@ -1049,7 +1049,7 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                        def: &'tcx ty::ADTDef_<'tcx, 'tcx>,\n+                                        def: ty::AdtDefMaster<'tcx>,\n                                         scheme: ty::TypeScheme<'tcx>,\n                                         predicates: ty::GenericPredicates<'tcx>,\n                                         variants: &[P<ast::Variant>]) {\n@@ -1090,7 +1090,7 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 did: ast::DefId,\n                                 name: ast::Name,\n                                 disr_val: ty::Disr,\n-                                def: &ast::StructDef) -> ty::VariantDef_<'tcx, 'tcx> {\n+                                def: &ast::StructDef) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n     let fields = def.fields.iter().map(|f| {\n         let fid = local_def(f.node.id);\n@@ -1106,14 +1106,14 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     seen_fields.insert(ident.name, f.span);\n                 }\n \n-                ty::FieldDef_::new(fid, ident.name, vis)\n+                ty::FieldDefData::new(fid, ident.name, vis)\n             },\n             ast::UnnamedField(vis) => {\n-                ty::FieldDef_::new(fid, special_idents::unnamed_field.name, vis)\n+                ty::FieldDefData::new(fid, special_idents::unnamed_field.name, vis)\n             }\n         }\n     }).collect();\n-    ty::VariantDef_ {\n+    ty::VariantDefData {\n         did: did,\n         name: name,\n         disr_val: disr_val,\n@@ -1124,21 +1124,21 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             it: &ast::Item,\n                             def: &ast::StructDef)\n-                            -> &'tcx ty::ADTDef_<'tcx, 'tcx>\n+                            -> ty::AdtDefMaster<'tcx>\n {\n \n     let did = local_def(it.id);\n     tcx.intern_adt_def(\n         did,\n-        ty::ADTKind::Struct,\n+        ty::AdtKind::Struct,\n         vec![convert_struct_variant(tcx, did, it.ident.name, 0, def)]\n     )\n }\n \n fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           it: &ast::Item,\n                           def: &ast::EnumDef)\n-                          -> &'tcx ty::ADTDef_<'tcx, 'tcx>\n+                          -> ty::AdtDefMaster<'tcx>\n {\n     fn evaluate_disr_expr<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 repr_ty: Ty<'tcx>,\n@@ -1202,18 +1202,18 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n     fn convert_enum_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   v: &ast::Variant,\n                                   disr: ty::Disr)\n-                                  -> ty::VariantDef_<'tcx, 'tcx>\n+                                  -> ty::VariantDefData<'tcx, 'tcx>\n     {\n         let did = local_def(v.node.id);\n         let name = v.node.name.name;\n         match v.node.kind {\n             ast::TupleVariantKind(ref va) => {\n-                ty::VariantDef_ {\n+                ty::VariantDefData {\n                     did: did,\n                     name: name,\n                     disr_val: disr,\n                     fields: va.iter().map(|&ast::VariantArg { id, .. }| {\n-                        ty::FieldDef_::new(\n+                        ty::FieldDefData::new(\n                             local_def(id),\n                             special_idents::unnamed_field.name,\n                             ast::Visibility::Public\n@@ -1240,7 +1240,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n         prev_disr = Some(disr);\n         v\n     }).collect();\n-    tcx.intern_adt_def(local_def(it.id), ty::ADTKind::Enum, variants)\n+    tcx.intern_adt_def(local_def(it.id), ty::AdtKind::Enum, variants)\n }\n \n /// Ensures that the super-predicates of the trait with def-id"}, {"sha": "e9f9b8fb629cb4476306fffdf8c6363db73221e4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedb1cc5765b043f31ca4316c42f2ac8d7df1919/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "patch": "@@ -1730,7 +1730,7 @@ impl Clean<Item> for ast::StructField {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::FieldDef<'tcx> {\n+impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         use syntax::parse::token::special_idents::unnamed_field;\n         use rustc::metadata::csearch;\n@@ -1856,7 +1856,7 @@ impl Clean<Item> for doctree::Variant {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::VariantDef<'tcx> {\n+impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n         let kind = match self.kind() {"}]}