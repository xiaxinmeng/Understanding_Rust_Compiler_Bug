{"sha": "adef9da30f1ecbfeb81312d01ed94ac53f7161ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZWY5ZGEzMGYxZWNiZmViODEzMTJkMDFlZDk0YWM1M2Y3MTYxYmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-13T20:20:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-13T20:20:27Z"}, "message": "Auto merge of #75213 - dingxiangfei2009:yield-point-in-match-guard, r=tmandry\n\n[generator] Special cases for match guard when analyzing interior types in generators\n\nFix #72651\n\nThis proposes one of ways to fix the mentioned issue. One cause of #72651 is that the interior type analysis misses out types of match pattern locals. Those locals are manifested as temporary borrows in the scopes of match arm guards. If uses of these locals appear after yield points, the borrows from them were not considered live across the yield points. However, this is not the case since the borrowing always happens at the very beginning of the match guard.\n\nThis calls for special treatment to analysis of types appearing in the match guard. Those borrows are recorded as the HIR tree is walked by `InteriorVisitor` and their uses are recorded whenever a yield point is crossed.", "tree": {"sha": "8089557192478546df01fc2df840c28a18c0f9e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8089557192478546df01fc2df840c28a18c0f9e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adef9da30f1ecbfeb81312d01ed94ac53f7161ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adef9da30f1ecbfeb81312d01ed94ac53f7161ba", "html_url": "https://github.com/rust-lang/rust/commit/adef9da30f1ecbfeb81312d01ed94ac53f7161ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d65c08e9cc164b7b44de53503fae859a4fafd976", "url": "https://api.github.com/repos/rust-lang/rust/commits/d65c08e9cc164b7b44de53503fae859a4fafd976", "html_url": "https://github.com/rust-lang/rust/commit/d65c08e9cc164b7b44de53503fae859a4fafd976"}, {"sha": "50627a39c178b30a1bf2796201e442a61bdec369", "url": "https://api.github.com/repos/rust-lang/rust/commits/50627a39c178b30a1bf2796201e442a61bdec369", "html_url": "https://github.com/rust-lang/rust/commit/50627a39c178b30a1bf2796201e442a61bdec369"}], "stats": {"total": 134, "additions": 122, "deletions": 12}, "files": [{"sha": "38cb3c1701f928bf2124aa2e4a1a3ef5f9acb068", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=adef9da30f1ecbfeb81312d01ed94ac53f7161ba", "patch": "@@ -283,23 +283,27 @@ pub struct ScopeTree {\n     /// To see that this method works, consider:\n     ///\n     /// Let `D` be our binding/temporary and `U` be our other HIR node, with\n-    /// `HIR-postorder(U) < HIR-postorder(D)` (in our example, U would be\n-    /// the yield and D would be one of the calls). Let's show that\n-    /// `D` is storage-dead at `U`.\n+    /// `HIR-postorder(U) < HIR-postorder(D)`. Suppose, as in our example,\n+    /// U is the yield and D is one of the calls.\n+    /// Let's show that `D` is storage-dead at `U`.\n     ///\n     /// Remember that storage-live/storage-dead refers to the state of\n     /// the *storage*, and does not consider moves/drop flags.\n     ///\n     /// Then:\n+    ///\n     ///     1. From the ordering guarantee of HIR visitors (see\n     ///     `rustc_hir::intravisit`), `D` does not dominate `U`.\n+    ///\n     ///     2. Therefore, `D` is *potentially* storage-dead at `U` (because\n     ///     we might visit `U` without ever getting to `D`).\n+    ///\n     ///     3. However, we guarantee that at each HIR point, each\n     ///     binding/temporary is always either always storage-live\n     ///     or always storage-dead. This is what is being guaranteed\n     ///     by `terminating_scopes` including all blocks where the\n     ///     count of executions is not guaranteed.\n+    ///\n     ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n     ///     QED.\n     ///"}, {"sha": "e46274770be17532309bade4a4389d767ede36bb", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=adef9da30f1ecbfeb81312d01ed94ac53f7161ba", "patch": "@@ -28,8 +28,9 @@ use std::mem;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Simplify a candidate so that all match pairs require a test.\n     ///\n-    /// This method will also split a candidate where the only match-pair is an\n-    /// or-pattern into multiple candidates. This is so that\n+    /// This method will also split a candidate, in which the only\n+    /// match-pair is an or-pattern, into multiple candidates.\n+    /// This is so that\n     ///\n     /// match x {\n     ///     0 | 1 => { ... },"}, {"sha": "3fc5f02a4a47da009aecd94252cd311b019a9c6d", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 88, "deletions": 7, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=adef9da30f1ecbfeb81312d01ed94ac53f7161ba", "patch": "@@ -8,11 +8,13 @@ use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, ExprKind, Pat, PatKind};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n use rustc_middle::middle::region::{self, YieldData};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n+use smallvec::SmallVec;\n \n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -21,6 +23,13 @@ struct InteriorVisitor<'a, 'tcx> {\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n     prev_unresolved_span: Option<Span>,\n+    /// Match arm guards have temporary borrows from the pattern bindings.\n+    /// In case there is a yield point in a guard with a reference to such bindings,\n+    /// such borrows can span across this yield point.\n+    /// As such, we need to track these borrows and record them despite of the fact\n+    /// that they may succeed the said yield point in the post-order.\n+    guard_bindings: SmallVec<[SmallVec<[HirId; 4]>; 1]>,\n+    guard_bindings_set: HirIdSet,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -30,6 +39,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n         scope: Option<region::Scope>,\n         expr: Option<&'tcx Expr<'tcx>>,\n         source_span: Span,\n+        guard_borrowing_from_pattern: bool,\n     ) {\n         use rustc_span::DUMMY_SP;\n \n@@ -53,7 +63,12 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                         yield_data.expr_and_pat_count, self.expr_count, source_span\n                     );\n \n-                    if yield_data.expr_and_pat_count >= self.expr_count {\n+                    // If it is a borrowing happening in the guard,\n+                    // it needs to be recorded regardless because they\n+                    // do live across this yield point.\n+                    if guard_borrowing_from_pattern\n+                        || yield_data.expr_and_pat_count >= self.expr_count\n+                    {\n                         Some(yield_data)\n                     } else {\n                         None\n@@ -134,6 +149,8 @@ pub fn resolve_interior<'a, 'tcx>(\n         expr_count: 0,\n         kind,\n         prev_unresolved_span: None,\n+        guard_bindings: <_>::default(),\n+        guard_bindings_set: <_>::default(),\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n@@ -210,6 +227,38 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n+    fn visit_arm(&mut self, arm: &'tcx Arm<'tcx>) {\n+        let Arm { guard, pat, body, .. } = arm;\n+        self.visit_pat(pat);\n+        if let Some(ref g) = guard {\n+            self.guard_bindings.push(<_>::default());\n+            ArmPatCollector {\n+                guard_bindings_set: &mut self.guard_bindings_set,\n+                guard_bindings: self\n+                    .guard_bindings\n+                    .last_mut()\n+                    .expect(\"should have pushed at least one earlier\"),\n+            }\n+            .visit_pat(pat);\n+\n+            match g {\n+                Guard::If(ref e) => {\n+                    self.visit_expr(e);\n+                }\n+            }\n+\n+            let mut scope_var_ids =\n+                self.guard_bindings.pop().expect(\"should have pushed at least one earlier\");\n+            for var_id in scope_var_ids.drain(..) {\n+                assert!(\n+                    self.guard_bindings_set.remove(&var_id),\n+                    \"variable should be placed in scope earlier\"\n+                );\n+            }\n+        }\n+        self.visit_expr(body);\n+    }\n+\n     fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n         intravisit::walk_pat(self, pat);\n \n@@ -218,11 +267,12 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         if let PatKind::Binding(..) = pat.kind {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.typeck_results.borrow().pat_ty(pat);\n-            self.record(ty, Some(scope), None, pat.span);\n+            self.record(ty, Some(scope), None, pat.span, false);\n         }\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        let mut guard_borrowing_from_pattern = false;\n         match &expr.kind {\n             ExprKind::Call(callee, args) => match &callee.kind {\n                 ExprKind::Path(qpath) => {\n@@ -249,6 +299,16 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                 }\n                 _ => intravisit::walk_expr(self, expr),\n             },\n+            ExprKind::Path(qpath) => {\n+                intravisit::walk_expr(self, expr);\n+                let res = self.fcx.typeck_results.borrow().qpath_res(qpath, expr.hir_id);\n+                match res {\n+                    Res::Local(id) if self.guard_bindings_set.contains(&id) => {\n+                        guard_borrowing_from_pattern = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n             _ => intravisit::walk_expr(self, expr),\n         }\n \n@@ -259,18 +319,18 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // If there are adjustments, then record the final type --\n         // this is the actual value that is being produced.\n         if let Some(adjusted_ty) = self.fcx.typeck_results.borrow().expr_ty_adjusted_opt(expr) {\n-            self.record(adjusted_ty, scope, Some(expr), expr.span);\n+            self.record(adjusted_ty, scope, Some(expr), expr.span, guard_borrowing_from_pattern);\n         }\n \n         // Also record the unadjusted type (which is the only type if\n         // there are no adjustments). The reason for this is that the\n         // unadjusted value is sometimes a \"temporary\" that would wind\n         // up in a MIR temporary.\n         //\n-        // As an example, consider an expression like `vec![].push()`.\n+        // As an example, consider an expression like `vec![].push(x)`.\n         // Here, the `vec![]` would wind up MIR stored into a\n         // temporary variable `t` which we can borrow to invoke\n-        // `<Vec<_>>::push(&mut t)`.\n+        // `<Vec<_>>::push(&mut t, x)`.\n         //\n         // Note that an expression can have many adjustments, and we\n         // are just ignoring those intermediate types. This is because\n@@ -287,9 +347,30 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // The type table might not have information for this expression\n         // if it is in a malformed scope. (#66387)\n         if let Some(ty) = self.fcx.typeck_results.borrow().expr_ty_opt(expr) {\n-            self.record(ty, scope, Some(expr), expr.span);\n+            self.record(ty, scope, Some(expr), expr.span, guard_borrowing_from_pattern);\n         } else {\n             self.fcx.tcx.sess.delay_span_bug(expr.span, \"no type for node\");\n         }\n     }\n }\n+\n+struct ArmPatCollector<'a> {\n+    guard_bindings_set: &'a mut HirIdSet,\n+    guard_bindings: &'a mut SmallVec<[HirId; 4]>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ArmPatCollector<'a> {\n+    type Map = intravisit::ErasedMap<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n+        intravisit::walk_pat(self, pat);\n+        if let PatKind::Binding(_, id, ..) = pat.kind {\n+            self.guard_bindings.push(id);\n+            self.guard_bindings_set.insert(id);\n+        }\n+    }\n+}"}, {"sha": "d8aa354b1c604bb382622b1b8e09e9d423dd0937", "filename": "src/test/ui/generator/yielding-in-match-guards.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/src%2Ftest%2Fui%2Fgenerator%2Fyielding-in-match-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adef9da30f1ecbfeb81312d01ed94ac53f7161ba/src%2Ftest%2Fui%2Fgenerator%2Fyielding-in-match-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyielding-in-match-guards.rs?ref=adef9da30f1ecbfeb81312d01ed94ac53f7161ba", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+// edition:2018\n+\n+// This test is derived from\n+// https://github.com/rust-lang/rust/issues/72651#issuecomment-668720468\n+\n+// This test demonstrates that, in `async fn g()`,\n+// indeed a temporary borrow `y` from `x` is live\n+// while `f().await` is being evaluated.\n+// Thus, `&'_ u8` should be included in type signature\n+// of the underlying generator.\n+\n+async fn f() -> u8 { 1 }\n+\n+pub async fn g(x: u8) {\n+    match x {\n+        y if f().await == y => (),\n+        _ => (),\n+    }\n+}\n+\n+fn main() {\n+    let _ = g(10);\n+}"}]}