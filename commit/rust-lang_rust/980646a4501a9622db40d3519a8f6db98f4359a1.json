{"sha": "980646a4501a9622db40d3519a8f6db98f4359a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MDY0NmE0NTAxYTk2MjJkYjQwZDM1MTlhOGY2ZGI5OGY0MzU5YTE=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-17T21:41:50Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:12:05Z"}, "message": "Use Option .take() or .take_unwrap() instead of util::replace where possible", "tree": {"sha": "42e0481bb567d8fcf783b1ae7310abbddf3a9c19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42e0481bb567d8fcf783b1ae7310abbddf3a9c19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/980646a4501a9622db40d3519a8f6db98f4359a1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/980646a4501a9622db40d3519a8f6db98f4359a1", "html_url": "https://github.com/rust-lang/rust/commit/980646a4501a9622db40d3519a8f6db98f4359a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/980646a4501a9622db40d3519a8f6db98f4359a1/comments", "author": null, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "621bc79d0de970ecb5373d3dc8b58ef919dc6025", "url": "https://api.github.com/repos/rust-lang/rust/commits/621bc79d0de970ecb5373d3dc8b58ef919dc6025", "html_url": "https://github.com/rust-lang/rust/commit/621bc79d0de970ecb5373d3dc8b58ef919dc6025"}], "stats": {"total": 77, "additions": 32, "deletions": 45}, "files": [{"sha": "c42eba1ffa29cd1aab52b5b47188150007c02605", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -208,7 +208,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_front(&mut self) -> Option<T> {\n-        match util::replace(&mut self.list_head, None) {\n+        match self.list_head.take() {\n             None => None,\n             Some(old_head) => {\n                 self.length -= 1;"}, {"sha": "f46af664b189f630508677050fababf46915a9d5", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -14,7 +14,6 @@\n //! extra::container::Deque`.\n \n use std::num;\n-use std::util;\n use std::uint;\n use std::vec;\n use std::iterator::{FromIterator, InvertIterator};\n@@ -72,7 +71,7 @@ impl<T> Deque<T> for RingBuf<T> {\n \n     /// Remove and return the first element in the RingBuf, or None if it is empty\n     fn pop_front(&mut self) -> Option<T> {\n-        let result = util::replace(&mut self.elts[self.lo], None);\n+        let result = self.elts[self.lo].take();\n         if result.is_some() {\n             self.lo = (self.lo + 1u) % self.elts.len();\n             self.nelts -= 1u;\n@@ -85,7 +84,7 @@ impl<T> Deque<T> for RingBuf<T> {\n         if self.nelts > 0 {\n             self.nelts -= 1;\n             let hi = self.raw_index(self.nelts);\n-            util::replace(&mut self.elts[hi], None)\n+            self.elts[hi].take()\n         } else {\n             None\n         }"}, {"sha": "6ff219a4f8f7b2d61c2d96e059a4b888df905e35", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -118,7 +118,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n-        replace(&mut self.v[*key], None)\n+        self.v[*key].take()\n     }\n }\n "}, {"sha": "7e0cb76b5156157e0278416398ccbf5eb5751bb8", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -697,7 +697,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n         }\n       }\n     }\n-    return match replace(node, None) {\n+    return match node.take() {\n         Some(~TreeNode{value, _}) => Some(value), None => fail!()\n     };\n }"}, {"sha": "ea13f33199912183d7ea39a31ac2257a76c765d8", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -27,7 +27,6 @@ use std::result;\n use std::run;\n use std::task;\n use std::to_bytes;\n-use std::util::replace;\n \n /**\n *\n@@ -353,7 +352,7 @@ impl TPrep for Prep {\n \n             _ => {\n                 let (port, chan) = oneshot();\n-                let blk = replace(&mut bo, None).unwrap();\n+                let blk = bo.take_unwrap();\n                 let chan = Cell::new(chan);\n \n                 do task::spawn {\n@@ -385,7 +384,7 @@ fn unwrap<T:Send +\n             Decodable<json::Decoder>>( // FIXME(#5121)\n         w: Work<T>) -> T {\n     let mut ww = w;\n-    let s = replace(&mut ww.res, None);\n+    let s = ww.res.take();\n \n     match s {\n         None => fail!(),"}, {"sha": "695ed0749dde0216bb1e860e38644b402b5e7313", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -14,7 +14,6 @@\n \n use cast::transmute_mut;\n use prelude::*;\n-use util::replace;\n \n /*\n A dynamic, mutable location.\n@@ -48,7 +47,7 @@ impl<T> Cell<T> {\n             fail!(\"attempt to take an empty cell\");\n         }\n \n-        replace(&mut this.value, None).unwrap()\n+        this.value.take_unwrap()\n     }\n \n     /// Returns the value, failing if the cell is full."}, {"sha": "b9dacc142cebc24e7d7ee9c2d1feb752e923aa7e", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -242,8 +242,7 @@ impl<T: Send> GenericChan<T> for SharedChan<T> {\n                 unsafe {\n                     let mut xx = Some(x);\n                     do chan.with_imm |chan| {\n-                        let x = replace(&mut xx, None);\n-                        chan.send(x.unwrap())\n+                        chan.send(xx.take_unwrap())\n                     }\n                 }\n             }\n@@ -259,8 +258,7 @@ impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n                 unsafe {\n                     let mut xx = Some(x);\n                     do chan.with_imm |chan| {\n-                        let x = replace(&mut xx, None);\n-                        chan.try_send(x.unwrap())\n+                        chan.try_send(xx.take_unwrap())\n                     }\n                 }\n             }\n@@ -372,7 +370,6 @@ mod pipesy {\n     use pipes::{recv, try_recv, peek, PacketHeader};\n     use super::{GenericChan, GenericSmartChan, GenericPort, Peekable, Selectable};\n     use cast::transmute_mut;\n-    use util::replace;\n \n     /*proto! oneshot (\n         Oneshot:send<T:Send> {\n@@ -638,8 +635,7 @@ mod pipesy {\n         fn send(&self, x: T) {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n-                let endp = replace(self_endp, None);\n-                *self_endp = Some(streamp::client::data(endp.unwrap(), x))\n+                *self_endp = Some(streamp::client::data(self_endp.take_unwrap(), x))\n             }\n         }\n     }\n@@ -649,8 +645,7 @@ mod pipesy {\n         fn try_send(&self, x: T) -> bool {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n-                let endp = replace(self_endp, None);\n-                match streamp::client::try_data(endp.unwrap(), x) {\n+                match streamp::client::try_data(self_endp.take_unwrap(), x) {\n                     Some(next) => {\n                         *self_endp = Some(next);\n                         true\n@@ -666,7 +661,7 @@ mod pipesy {\n         fn recv(&self) -> T {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n-                let endp = replace(self_endp, None);\n+                let endp = self_endp.take();\n                 let streamp::data(x, endp) = recv(endp.unwrap());\n                 *self_endp = Some(endp);\n                 x\n@@ -677,7 +672,7 @@ mod pipesy {\n         fn try_recv(&self) -> Option<T> {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n-                let endp = replace(self_endp, None);\n+                let endp = self_endp.take();\n                 match try_recv(endp.unwrap()) {\n                     Some(streamp::data(x, endp)) => {\n                         *self_endp = Some(endp);\n@@ -694,7 +689,7 @@ mod pipesy {\n         fn peek(&self) -> bool {\n             unsafe {\n                 let self_endp = transmute_mut(&self.endp);\n-                let mut endp = replace(self_endp, None);\n+                let mut endp = self_endp.take();\n                 let peek = match endp {\n                     Some(ref mut endp) => peek(endp),\n                     None => fail!(\"peeking empty stream\")"}, {"sha": "182ee37202a658f48c56b8caf7f39f087bed33fc", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -253,7 +253,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         };\n \n         let len_buckets = self.buckets.len();\n-        let bucket = replace(&mut self.buckets[idx], None);\n+        let bucket = self.buckets[idx].take();\n \n         let value = match bucket {\n             None => None,\n@@ -267,7 +267,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         let size = self.size - 1;\n         idx = self.next_bucket(idx, len_buckets);\n         while self.buckets[idx].is_some() {\n-            let bucket = replace(&mut self.buckets[idx], None);\n+            let bucket = self.buckets[idx].take();\n             self.insert_opt_bucket(bucket);\n             idx = self.next_bucket(idx, len_buckets);\n         }"}, {"sha": "a861c3c5f0fd6d23169b21760e0ce5e891e58b98", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -431,7 +431,7 @@ fn try_recv_<T:Send>(p: &mut Packet<T>) -> Option<T> {\n     // optimistic path\n     match p.header.state {\n       Full => {\n-        let payload = replace(&mut p.payload, None);\n+        let payload = p.payload.take();\n         p.header.state = Empty;\n         return Some(payload.unwrap())\n       },\n@@ -482,7 +482,7 @@ fn try_recv_<T:Send>(p: &mut Packet<T>) -> Option<T> {\n             fail!(\"blocking on already blocked packet\")\n           },\n           Full => {\n-            let payload = replace(&mut p.payload, None);\n+            let payload = p.payload.take();\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 unsafe {\n@@ -676,8 +676,7 @@ impl<T:Send,Tbuffer:Send> Drop for SendPacketBuffered<T,Tbuffer> {\n         unsafe {\n             let this: &mut SendPacketBuffered<T,Tbuffer> = transmute(self);\n             if this.p != None {\n-                let p = replace(&mut this.p, None);\n-                sender_terminate(p.unwrap())\n+                sender_terminate(this.p.take_unwrap());\n             }\n         }\n     }\n@@ -695,7 +694,7 @@ pub fn SendPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n \n impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n     pub fn unwrap(&mut self) -> *mut Packet<T> {\n-        replace(&mut self.p, None).unwrap()\n+        self.p.take_unwrap()\n     }\n \n     pub fn header(&mut self) -> *mut PacketHeader {\n@@ -711,7 +710,7 @@ impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n \n     pub fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n         //error!(\"send reuse_buffer\");\n-        replace(&mut self.buffer, None).unwrap()\n+        self.buffer.take_unwrap()\n     }\n }\n \n@@ -734,20 +733,19 @@ impl<T:Send,Tbuffer:Send> Drop for RecvPacketBuffered<T,Tbuffer> {\n         unsafe {\n             let this: &mut RecvPacketBuffered<T,Tbuffer> = transmute(self);\n             if this.p != None {\n-                let p = replace(&mut this.p, None);\n-                receiver_terminate(p.unwrap())\n+                receiver_terminate(this.p.take_unwrap())\n             }\n         }\n     }\n }\n \n impl<T:Send,Tbuffer:Send> RecvPacketBuffered<T, Tbuffer> {\n     pub fn unwrap(&mut self) -> *mut Packet<T> {\n-        replace(&mut self.p, None).unwrap()\n+        self.p.take_unwrap()\n     }\n \n     pub fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n-        replace(&mut self.buffer, None).unwrap()\n+        self.buffer.take_unwrap()\n     }\n }\n "}, {"sha": "de6410aa82f91d70bfba72942968f4cc686a28cb", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -46,7 +46,6 @@ use rt::{context, OldTaskContext, TaskContext};\n use rt::local::Local;\n use task::rt::{task_id, sched_id};\n use unstable::finally::Finally;\n-use util::replace;\n use util;\n \n #[cfg(test)] use cast;\n@@ -224,8 +223,8 @@ impl TaskBuilder {\n             fail!(\"Cannot copy a task_builder\"); // Fake move mode on self\n         }\n         self.consumed = true;\n-        let gen_body = replace(&mut self.gen_body, None);\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        let gen_body = self.gen_body.take();\n+        let notify_chan = self.opts.notify_chan.take();\n         TaskBuilder {\n             opts: TaskOpts {\n                 linked: self.opts.linked,\n@@ -340,7 +339,7 @@ impl TaskBuilder {\n      * existing body generator to the new body generator.\n      */\n     pub fn add_wrapper(&mut self, wrapper: ~fn(v: ~fn()) -> ~fn()) {\n-        let prev_gen_body = replace(&mut self.gen_body, None);\n+        let prev_gen_body = self.gen_body.take();\n         let prev_gen_body = match prev_gen_body {\n             Some(gen) => gen,\n             None => {\n@@ -372,8 +371,8 @@ impl TaskBuilder {\n      * must be greater than zero.\n      */\n     pub fn spawn(&mut self, f: ~fn()) {\n-        let gen_body = replace(&mut self.gen_body, None);\n-        let notify_chan = replace(&mut self.opts.notify_chan, None);\n+        let gen_body = self.gen_body.take();\n+        let notify_chan = self.opts.notify_chan.take();\n         let x = self.consume();\n         let opts = TaskOpts {\n             linked: x.opts.linked,"}, {"sha": "03e94a902c1a1b495b4237ab7dd46e634a389a9c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/980646a4501a9622db40d3519a8f6db98f4359a1/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=980646a4501a9622db40d3519a8f6db98f4359a1", "patch": "@@ -1896,12 +1896,11 @@ pub mod raw {\n     use cast::transmute;\n     use clone::Clone;\n     use managed;\n-    use option::{None, Some};\n+    use option::Some;\n     use ptr;\n     use sys;\n     use unstable::intrinsics;\n     use vec::{UnboxedVecRepr, with_capacity, ImmutableVector, MutableVector};\n-    use util;\n     #[cfg(not(stage0))]\n     use unstable::intrinsics::contains_managed;\n \n@@ -2022,9 +2021,8 @@ pub mod raw {\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n         do v.as_mut_buf |p, _len| {\n-            let box2 = util::replace(&mut box, None);\n             intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n-                                      box2.unwrap());\n+                                      box.take_unwrap());\n         }\n     }\n "}]}