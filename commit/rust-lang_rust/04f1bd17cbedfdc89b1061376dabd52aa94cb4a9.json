{"sha": "04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZjFiZDE3Y2JlZGZkYzg5YjEwNjEzNzZkYWJkNTJhYTk0Y2I0YTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-15T11:53:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-15T11:53:55Z"}, "message": "Merge #2257\n\n2257: Flatten expr module r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ec1b28ac2a90ebbc42d88be3a79065f71ff55db9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec1b28ac2a90ebbc42d88be3a79065f71ff55db9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdzpHTCRBK7hj4Ov3rIwAAdHIIAIXphJDa36/nlJW4J4SvJ9lD\nGdrHPKScYsqkZl8+BSAs/HKVid959XrKNBRgl2q2khlhcB437yLRs3IRjC3Aa3wW\nA0pxrPQ//SH5NDZ8itLclUvxod7mGICEznWp9ChVemv+F44QSsM/FEBYZpQOtxHd\nzeJCdB+BG9Z5CGY7Vh6j+IsLOf9tp+MJJhH2uBtAUVllHlynQXOBSgbnsqLUbE67\nzoEBb9ipciohG/X6iOr94PvYWdmwYlKeqmEx6lrwJsghmYQQyoAJOoCkcun/LuIr\ndpSZ58PfWkRzWpPdIwIcAp/dNnx6s8/8L1j38dJ9545sP5Oqq8X09BirWGFcqw4=\n=4juM\n-----END PGP SIGNATURE-----\n", "payload": "tree ec1b28ac2a90ebbc42d88be3a79065f71ff55db9\nparent 3948de3143d06cc3056b6b8f0d18cb3e1468ae03\nparent c3f84960aa99529a3afc8f28c16e657fb071db5f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573818835 +0000\ncommitter GitHub <noreply@github.com> 1573818835 +0000\n\nMerge #2257\n\n2257: Flatten expr module r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "html_url": "https://github.com/rust-lang/rust/commit/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3948de3143d06cc3056b6b8f0d18cb3e1468ae03", "url": "https://api.github.com/repos/rust-lang/rust/commits/3948de3143d06cc3056b6b8f0d18cb3e1468ae03", "html_url": "https://github.com/rust-lang/rust/commit/3948de3143d06cc3056b6b8f0d18cb3e1468ae03"}, {"sha": "c3f84960aa99529a3afc8f28c16e657fb071db5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3f84960aa99529a3afc8f28c16e657fb071db5f", "html_url": "https://github.com/rust-lang/rust/commit/c3f84960aa99529a3afc8f28c16e657fb071db5f"}], "stats": {"total": 679, "additions": 345, "deletions": 334}, "files": [{"sha": "078bd86090e87547587d93bebc748206c7c27447", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "patch": "@@ -23,7 +23,7 @@ use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n use crate::{\n     adt::VariantDef,\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    expr::{validation::ExprValidator, BindingAnnotation, Body, BodySourceMap, Pat, PatId},\n+    expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     generics::{GenericDef, HasGenericParams},\n     ids::{\n         AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,"}, {"sha": "e3733779e9c106a1a375b50071e3257d11895516", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 108, "deletions": 171, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "patch": "@@ -1,12 +1,19 @@\n //! FIXME: write short doc here\n \n-pub(crate) mod validation;\n-\n use std::sync::Arc;\n \n+use hir_def::path::known;\n+use hir_expand::diagnostics::DiagnosticSink;\n+use ra_syntax::ast;\n use ra_syntax::AstPtr;\n+use rustc_hash::FxHashSet;\n \n-use crate::{db::HirDatabase, DefWithBody, HasBody, Resolver};\n+use crate::{\n+    db::HirDatabase,\n+    diagnostics::{MissingFields, MissingOkInTailExpr},\n+    ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n+    Adt, DefWithBody, Function, HasBody, Name, Path, Resolver,\n+};\n \n pub use hir_def::{\n     body::{\n@@ -43,191 +50,121 @@ pub(crate) fn resolver_for_scope(\n     r\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use hir_expand::Source;\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n-    use test_utils::{assert_eq_text, extract_offset};\n-\n-    use crate::{source_binder::SourceAnalyzer, test_db::TestDB};\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let (off, code) = extract_offset(code);\n-        let code = {\n-            let mut buf = String::new();\n-            let off = u32::from(off) as usize;\n-            buf.push_str(&code[..off]);\n-            buf.push_str(\"marker\");\n-            buf.push_str(&code[off..]);\n-            buf\n-        };\n+pub(crate) struct ExprValidator<'a, 'b: 'a> {\n+    func: Function,\n+    infer: Arc<InferenceResult>,\n+    sink: &'a mut DiagnosticSink<'b>,\n+}\n \n-        let (db, file_id) = TestDB::with_single_file(&code);\n-\n-        let file = db.parse(file_id).ok().unwrap();\n-        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n-\n-        let scopes = analyzer.scopes();\n-        let expr_id = analyzer\n-            .body_source_map()\n-            .node_expr(Source { file_id: file_id.into(), ast: &marker.into() })\n-            .unwrap();\n-        let scope = scopes.scope_for(expr_id);\n-\n-        let actual = scopes\n-            .scope_chain(scope)\n-            .flat_map(|scope| scopes.entries(scope))\n-            .map(|it| it.name().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n-        let expected = expected.join(\"\\n\");\n-        assert_eq_text!(&expected, &actual);\n+impl<'a, 'b> ExprValidator<'a, 'b> {\n+    pub(crate) fn new(\n+        func: Function,\n+        infer: Arc<InferenceResult>,\n+        sink: &'a mut DiagnosticSink<'b>,\n+    ) -> ExprValidator<'a, 'b> {\n+        ExprValidator { func, infer, sink }\n     }\n \n-    #[test]\n-    fn test_lambda_scope() {\n-        do_check(\n-            r\"\n-            fn quux(foo: i32) {\n-                let f = |bar, baz: i32| {\n-                    <|>\n-                };\n-            }\",\n-            &[\"bar\", \"baz\", \"foo\"],\n-        );\n-    }\n+    pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n+        let body = self.func.body(db);\n \n-    #[test]\n-    fn test_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n+        for e in body.exprs() {\n+            if let (id, Expr::RecordLit { path, fields, spread }) = e {\n+                self.validate_record_literal(id, path, fields, *spread, db);\n+            }\n+        }\n \n-    #[test]\n-    fn test_method_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                z.f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n+        let body_expr = &body[body.body_expr()];\n+        if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n+            self.validate_results_in_tail_expr(body.body_expr(), *t, db);\n+        }\n     }\n \n-    #[test]\n-    fn test_loop_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                loop {\n-                    let x = ();\n-                    <|>\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n+    fn validate_record_literal(\n+        &mut self,\n+        id: ExprId,\n+        _path: &Option<Path>,\n+        fields: &[RecordLitField],\n+        spread: Option<ExprId>,\n+        db: &impl HirDatabase,\n+    ) {\n+        if spread.is_some() {\n+            return;\n+        }\n+\n+        let struct_def = match self.infer[id].as_adt() {\n+            Some((Adt::Struct(s), _)) => s,\n+            _ => return,\n+        };\n \n-    #[test]\n-    fn test_match() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                match () {\n-                    Some(x) => {\n-                        <|>\n+        let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n+        let missed_fields: Vec<Name> = struct_def\n+            .fields(db)\n+            .iter()\n+            .filter_map(|f| {\n+                let name = f.name(db);\n+                if lit_fields.contains(&name) {\n+                    None\n+                } else {\n+                    Some(name)\n+                }\n+            })\n+            .collect();\n+        if missed_fields.is_empty() {\n+            return;\n+        }\n+        let source_map = self.func.body_source_map(db);\n+\n+        if let Some(source_ptr) = source_map.expr_syntax(id) {\n+            if let Some(expr) = source_ptr.ast.a() {\n+                let root = source_ptr.file_syntax(db);\n+                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n+                    if let Some(field_list) = record_lit.record_field_list() {\n+                        self.sink.push(MissingFields {\n+                            file: source_ptr.file_id,\n+                            field_list: AstPtr::new(&field_list),\n+                            missed_fields,\n+                        })\n                     }\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_shadow_variable() {\n-        do_check(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\",\n-            &[\"x\"],\n-        );\n+                }\n+            }\n+        }\n     }\n \n-    fn do_check_local_name(code: &str, expected_offset: u32) {\n-        let (off, code) = extract_offset(code);\n-\n-        let (db, file_id) = TestDB::with_single_file(&code);\n-        let file = db.parse(file_id).ok().unwrap();\n-        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n-            .expect(\"failed to find a name at the target offset\");\n-        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n+    fn validate_results_in_tail_expr(\n+        &mut self,\n+        body_id: ExprId,\n+        id: ExprId,\n+        db: &impl HirDatabase,\n+    ) {\n+        // the mismatch will be on the whole block currently\n+        let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n+            Some(m) => m,\n+            None => return,\n+        };\n \n-        let local_name_entry = analyzer.resolve_local_name(&name_ref).unwrap();\n-        let local_name =\n-            local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n-        assert_eq!(local_name.range(), expected_name.syntax().text_range());\n-    }\n+        let std_result_path = known::std_result_result();\n \n-    #[test]\n-    fn test_resolve_local_name() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: i32, y: u32) {\n-                {\n-                    let z = x * 2;\n-                }\n-                {\n-                    let t = x<|> * 3;\n-                }\n-            }\"#,\n-            21,\n-        );\n-    }\n+        let resolver = self.func.resolver(db);\n+        let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n+            Some(it) => it,\n+            _ => return,\n+        };\n \n-    #[test]\n-    fn test_resolve_local_name_declaration() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\"#,\n-            21,\n-        );\n-    }\n+        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum));\n+        let params = match &mismatch.expected {\n+            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n+            _ => return,\n+        };\n \n-    #[test]\n-    fn test_resolve_local_name_shadow() {\n-        do_check_local_name(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x;\n-                x<|>\n-            }\n-            \",\n-            53,\n-        );\n-    }\n+        if params.len() == 2 && &params[0] == &mismatch.actual {\n+            let source_map = self.func.body_source_map(db);\n \n-    #[test]\n-    fn ref_patterns_contribute_bindings() {\n-        do_check_local_name(\n-            r\"\n-            fn foo() {\n-                if let Some(&from) = bar() {\n-                    from<|>;\n+            if let Some(source_ptr) = source_map.expr_syntax(id) {\n+                if let Some(expr) = source_ptr.ast.a() {\n+                    self.sink.push(MissingOkInTailExpr { file: source_ptr.file_id, expr });\n                 }\n             }\n-            \",\n-            53,\n-        );\n+        }\n     }\n }"}, {"sha": "3054f1dcedf405270db5e98109734d55d5666e31", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/3948de3143d06cc3056b6b8f0d18cb3e1468ae03/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3948de3143d06cc3056b6b8f0d18cb3e1468ae03/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=3948de3143d06cc3056b6b8f0d18cb3e1468ae03", "patch": "@@ -1,137 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use std::sync::Arc;\n-\n-use hir_def::path::known;\n-use hir_expand::diagnostics::DiagnosticSink;\n-use ra_syntax::ast;\n-use rustc_hash::FxHashSet;\n-\n-use crate::{\n-    db::HirDatabase,\n-    diagnostics::{MissingFields, MissingOkInTailExpr},\n-    expr::AstPtr,\n-    ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n-    Adt, Function, Name, Path,\n-};\n-\n-use super::{Expr, ExprId, RecordLitField};\n-\n-pub(crate) struct ExprValidator<'a, 'b: 'a> {\n-    func: Function,\n-    infer: Arc<InferenceResult>,\n-    sink: &'a mut DiagnosticSink<'b>,\n-}\n-\n-impl<'a, 'b> ExprValidator<'a, 'b> {\n-    pub(crate) fn new(\n-        func: Function,\n-        infer: Arc<InferenceResult>,\n-        sink: &'a mut DiagnosticSink<'b>,\n-    ) -> ExprValidator<'a, 'b> {\n-        ExprValidator { func, infer, sink }\n-    }\n-\n-    pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n-        let body = self.func.body(db);\n-\n-        for e in body.exprs() {\n-            if let (id, Expr::RecordLit { path, fields, spread }) = e {\n-                self.validate_record_literal(id, path, fields, *spread, db);\n-            }\n-        }\n-\n-        let body_expr = &body[body.body_expr()];\n-        if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n-            self.validate_results_in_tail_expr(body.body_expr(), *t, db);\n-        }\n-    }\n-\n-    fn validate_record_literal(\n-        &mut self,\n-        id: ExprId,\n-        _path: &Option<Path>,\n-        fields: &[RecordLitField],\n-        spread: Option<ExprId>,\n-        db: &impl HirDatabase,\n-    ) {\n-        if spread.is_some() {\n-            return;\n-        }\n-\n-        let struct_def = match self.infer[id].as_adt() {\n-            Some((Adt::Struct(s), _)) => s,\n-            _ => return,\n-        };\n-\n-        let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n-        let missed_fields: Vec<Name> = struct_def\n-            .fields(db)\n-            .iter()\n-            .filter_map(|f| {\n-                let name = f.name(db);\n-                if lit_fields.contains(&name) {\n-                    None\n-                } else {\n-                    Some(name)\n-                }\n-            })\n-            .collect();\n-        if missed_fields.is_empty() {\n-            return;\n-        }\n-        let source_map = self.func.body_source_map(db);\n-\n-        if let Some(source_ptr) = source_map.expr_syntax(id) {\n-            if let Some(expr) = source_ptr.ast.a() {\n-                let root = source_ptr.file_syntax(db);\n-                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n-                    if let Some(field_list) = record_lit.record_field_list() {\n-                        self.sink.push(MissingFields {\n-                            file: source_ptr.file_id,\n-                            field_list: AstPtr::new(&field_list),\n-                            missed_fields,\n-                        })\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn validate_results_in_tail_expr(\n-        &mut self,\n-        body_id: ExprId,\n-        id: ExprId,\n-        db: &impl HirDatabase,\n-    ) {\n-        // the mismatch will be on the whole block currently\n-        let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n-            Some(m) => m,\n-            None => return,\n-        };\n-\n-        let std_result_path = known::std_result_result();\n-\n-        let resolver = self.func.resolver(db);\n-        let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {\n-            Some(it) => it,\n-            _ => return,\n-        };\n-\n-        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum));\n-        let params = match &mismatch.expected {\n-            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n-            _ => return,\n-        };\n-\n-        if params.len() == 2 && &params[0] == &mismatch.actual {\n-            let source_map = self.func.body_source_map(db);\n-\n-            if let Some(source_ptr) = source_map.expr_syntax(id) {\n-                if let Some(expr) = source_ptr.ast.a() {\n-                    self.sink.push(MissingOkInTailExpr { file: source_ptr.file_id, expr });\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "662d3f8808cb005169234e5d4f971fb9c16e8efa", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "patch": "@@ -19,7 +19,6 @@ use ra_syntax::{\n     SyntaxKind::*,\n     SyntaxNode, SyntaxNodePtr, TextRange, TextUnit,\n };\n-use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n@@ -285,33 +284,25 @@ impl SourceAnalyzer {\n         self.resolve_hir_path(db, &hir_path)\n     }\n \n-    pub fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n-        let mut shadowed = FxHashSet::default();\n+    fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n         let name = name_ref.as_name();\n         let source_map = self.body_source_map.as_ref()?;\n         let scopes = self.scopes.as_ref()?;\n-        let scope = scope_for(scopes, source_map, self.file_id.into(), name_ref.syntax());\n-        let ret = scopes\n-            .scope_chain(scope)\n-            .flat_map(|scope| scopes.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .filter(|entry| entry.name() == &name)\n-            .nth(0);\n-        ret.and_then(|entry| {\n-            Some(ScopeEntryWithSyntax {\n-                name: entry.name().clone(),\n-                ptr: source_map.pat_syntax(entry.pat())?.ast,\n-            })\n+        let scope = scope_for(scopes, source_map, self.file_id.into(), name_ref.syntax())?;\n+        let entry = scopes.resolve_name_in_scope(scope, &name)?;\n+        Some(ScopeEntryWithSyntax {\n+            name: entry.name().clone(),\n+            ptr: source_map.pat_syntax(entry.pat())?.ast,\n         })\n     }\n \n     pub fn process_all_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n         self.resolver.process_all_names(db, f)\n     }\n \n+    // FIXME: we only use this in `inline_local_variable` assist, ideally, we\n+    // should switch to general reference search infra there.\n     pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n-        // FIXME: at least, this should work with any DefWithBody, but ideally\n-        // this should be hir-based altogether\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n         let ptr = Either::A(AstPtr::new(&ast::Pat::from(pat.clone())));\n         fn_def\n@@ -413,11 +404,6 @@ impl SourceAnalyzer {\n     pub(crate) fn inference_result(&self) -> Arc<crate::ty::InferenceResult> {\n         self.infer.clone().unwrap()\n     }\n-\n-    #[cfg(test)]\n-    pub(crate) fn scopes(&self) -> Arc<ExprScopes> {\n-        self.scopes.clone().unwrap()\n-    }\n }\n \n fn scope_for("}, {"sha": "10cb87d37bdf1b9d73b63ab6b2bb74aa22c6dfa3", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "patch": "@@ -67,6 +67,11 @@ impl ExprScopes {\n         std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n     }\n \n+    pub fn resolve_name_in_scope(&self, scope: ScopeId, name: &Name) -> Option<&ScopeEntry> {\n+        self.scope_chain(Some(scope))\n+            .find_map(|scope| self.entries(scope).iter().find(|it| it.name == *name))\n+    }\n+\n     pub fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n         self.scope_by_expr.get(&expr).copied()\n     }\n@@ -163,3 +168,217 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n     };\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use hir_expand::{name::AsName, Source};\n+    use ra_db::{fixture::WithFixture, FileId, SourceDatabase};\n+    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n+    use test_utils::{assert_eq_text, extract_offset};\n+\n+    use crate::{db::DefDatabase2, test_db::TestDB, FunctionId, ModuleDefId};\n+\n+    fn find_function(db: &TestDB, file_id: FileId) -> FunctionId {\n+        let krate = db.test_crate();\n+        let crate_def_map = db.crate_def_map(krate);\n+\n+        let module = crate_def_map.modules_for_file(file_id).next().unwrap();\n+        let (_, res) = crate_def_map[module].scope.entries().next().unwrap();\n+        match res.def.take_values().unwrap() {\n+            ModuleDefId::FunctionId(it) => it,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    fn do_check(code: &str, expected: &[&str]) {\n+        let (off, code) = extract_offset(code);\n+        let code = {\n+            let mut buf = String::new();\n+            let off = u32::from(off) as usize;\n+            buf.push_str(&code[..off]);\n+            buf.push_str(\"marker\");\n+            buf.push_str(&code[off..]);\n+            buf\n+        };\n+\n+        let (db, file_id) = TestDB::with_single_file(&code);\n+\n+        let file_syntax = db.parse(file_id).syntax_node();\n+        let marker: ast::PathExpr = find_node_at_offset(&file_syntax, off).unwrap();\n+        let function = find_function(&db, file_id);\n+\n+        let scopes = db.expr_scopes(function.into());\n+        let (_body, source_map) = db.body_with_source_map(function.into());\n+\n+        let expr_id =\n+            source_map.node_expr(Source { file_id: file_id.into(), ast: &marker.into() }).unwrap();\n+        let scope = scopes.scope_for(expr_id);\n+\n+        let actual = scopes\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope))\n+            .map(|it| it.name().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let expected = expected.join(\"\\n\");\n+        assert_eq_text!(&expected, &actual);\n+    }\n+\n+    #[test]\n+    fn test_lambda_scope() {\n+        do_check(\n+            r\"\n+            fn quux(foo: i32) {\n+                let f = |bar, baz: i32| {\n+                    <|>\n+                };\n+            }\",\n+            &[\"bar\", \"baz\", \"foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_method_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                z.f(|x| <|> );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_loop_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                loop {\n+                    let x = ();\n+                    <|>\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_match() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                match () {\n+                    Some(x) => {\n+                        <|>\n+                    }\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_shadow_variable() {\n+        do_check(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    fn do_check_local_name(code: &str, expected_offset: u32) {\n+        let (off, code) = extract_offset(code);\n+\n+        let (db, file_id) = TestDB::with_single_file(&code);\n+\n+        let file = db.parse(file_id).ok().unwrap();\n+        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n+            .expect(\"failed to find a name at the target offset\");\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+\n+        let function = find_function(&db, file_id);\n+\n+        let scopes = db.expr_scopes(function.into());\n+        let (_body, source_map) = db.body_with_source_map(function.into());\n+\n+        let expr_scope = {\n+            let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();\n+            let expr_id =\n+                source_map.node_expr(Source { file_id: file_id.into(), ast: &expr_ast }).unwrap();\n+            scopes.scope_for(expr_id).unwrap()\n+        };\n+\n+        let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();\n+        let pat_src = source_map.pat_syntax(resolved.pat()).unwrap();\n+\n+        let local_name = pat_src.ast.either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n+        assert_eq!(local_name.range(), expected_name.syntax().text_range());\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: i32, y: u32) {\n+                {\n+                    let z = x * 2;\n+                }\n+                {\n+                    let t = x<|> * 3;\n+                }\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_declaration() {\n+        do_check_local_name(\n+            r#\"\n+            fn foo(x: String) {\n+                let x : &str = &x<|>;\n+            }\"#,\n+            21,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_shadow() {\n+        do_check_local_name(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x;\n+                x<|>\n+            }\n+            \",\n+            53,\n+        );\n+    }\n+\n+    #[test]\n+    fn ref_patterns_contribute_bindings() {\n+        do_check_local_name(\n+            r\"\n+            fn foo() {\n+                if let Some(&from) = bar() {\n+                    from<|>;\n+                }\n+            }\n+            \",\n+            53,\n+        );\n+    }\n+}"}, {"sha": "21d5f62e042f9ec16fe1971037b50ac7e4f81046", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "patch": "@@ -58,7 +58,7 @@ mod tests;\n \n use std::sync::Arc;\n \n-use hir_expand::{diagnostics::DiagnosticSink, name::Name, MacroDefId};\n+use hir_expand::{ast_id_map::FileAstId, diagnostics::DiagnosticSink, name::Name, MacroDefId};\n use once_cell::sync::Lazy;\n use ra_arena::Arena;\n use ra_db::{CrateId, Edition, FileId};\n@@ -73,7 +73,7 @@ use crate::{\n         diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs, raw::ImportId,\n     },\n     path::Path,\n-    AstId, CrateModuleId, ModuleDefId, ModuleId, TraitId,\n+    AstId, CrateModuleId, FunctionId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -124,6 +124,11 @@ pub struct ModuleData {\n     pub definition: Option<FileId>,\n }\n \n+#[derive(Default, Debug, PartialEq, Eq, Clone)]\n+pub(crate) struct Declarations {\n+    fns: FxHashMap<FileAstId<ast::FnDef>, FunctionId>,\n+}\n+\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     pub items: FxHashMap<Name, Resolution>,"}, {"sha": "5c899aff35c78010eeb3d156393888d5e5bc6bf0", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f1bd17cbedfdc89b1061376dabd52aa94cb4a9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=04f1bd17cbedfdc89b1061376dabd52aa94cb4a9", "patch": "@@ -664,7 +664,8 @@ where\n         let name = def.name.clone();\n         let def: PerNs = match def.kind {\n             raw::DefKind::Function(ast_id) => {\n-                PerNs::values(FunctionId::from_ast_id(ctx, ast_id).into())\n+                let f = FunctionId::from_ast_id(ctx, ast_id);\n+                PerNs::values(f.into())\n             }\n             raw::DefKind::Struct(ast_id) => {\n                 let id = StructOrUnionId::from_ast_id(ctx, ast_id).into();"}]}