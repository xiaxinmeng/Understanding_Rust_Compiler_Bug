{"sha": "f4c22f75d46e94985d2fe45c896bde65e991b13d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YzIyZjc1ZDQ2ZTk0OTg1ZDJmZTQ1Yzg5NmJkZTY1ZTk5MWIxM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-19T07:06:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-19T07:06:29Z"}, "message": "auto merge of #10561 : pcwalton/rust/procify, r=alexcrichton\n\nr? @alexcrichton", "tree": {"sha": "b811656373ff40c6840da947869871c80eeda43f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b811656373ff40c6840da947869871c80eeda43f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4c22f75d46e94985d2fe45c896bde65e991b13d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c22f75d46e94985d2fe45c896bde65e991b13d", "html_url": "https://github.com/rust-lang/rust/commit/f4c22f75d46e94985d2fe45c896bde65e991b13d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4c22f75d46e94985d2fe45c896bde65e991b13d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5f5d5aac762a554850d291165536ba752260303", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f5d5aac762a554850d291165536ba752260303", "html_url": "https://github.com/rust-lang/rust/commit/f5f5d5aac762a554850d291165536ba752260303"}, {"sha": "f977bedafd657b52fb618cc788cc31f35336270d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f977bedafd657b52fb618cc788cc31f35336270d", "html_url": "https://github.com/rust-lang/rust/commit/f977bedafd657b52fb618cc788cc31f35336270d"}], "stats": {"total": 451, "additions": 186, "deletions": 265}, "files": [{"sha": "2276d0052a643956d297b9d39653be2cb77e77ec", "filename": "doc/po/ja/tutorial-tasks.md.po", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -213,7 +213,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial-tasks.md:102\n msgid \"\"\n-\"The `spawn` function has a very simple type signature: `fn spawn(f: ~fn())`. \"\n+\"The `spawn` function has a very simple type signature: `fn spawn(f: proc())`. \"\n \"Because it accepts only owned closures, and owned closures contain only \"\n \"owned data, `spawn` can safely move the entire closure and all its \"\n \"associated state into an entirely different task for execution. Like any \""}, {"sha": "2b4e6e2c148cbd373c1e7cf38660834cf4c562d4", "filename": "doc/po/ja/tutorial.md.po", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial.md.po?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -3509,13 +3509,13 @@ msgstr \"## \u6240\u6709\u30af\u30ed\u30fc\u30b8\u30e3\"\n #. type: Plain text\n #: doc/tutorial.md:1510\n msgid \"\"\n-\"Owned closures, written `~fn` in analogy to the `~` pointer type, hold on to \"\n+\"Owned closures, written `proc`, hold on to \"\n \"things that can safely be sent between processes. They copy the values they \"\n \"close over, much like managed closures, but they also own them: that is, no \"\n \"other code can access them. Owned closures are used in concurrent code, \"\n \"particularly for spawning [tasks][tasks].\"\n msgstr \"\"\n-\"`~` \u30dd\u30a4\u30f3\u30bf\u578b\u3068\u540c\u69d8\u306b `~fn` \u578b  \u3067\u66f8\u304d\u8868\u3055\u308c\u308b\u6240\u6709\u30af\u30ed\u30fc\u30b8\u30e3\u306f\u5b89\u5168\u306b\u30d7\u30ed\u30bb\u30b9\"\n+\"`~` `proc` \u3067\u66f8\u304d\u8868\u3055\u308c\u308b\u6240\u6709\u30af\u30ed\u30fc\u30b8\u30e3\u306f\u5b89\u5168\u306b\u30d7\u30ed\u30bb\u30b9\"\n \"\u9593\u3067\u9001\u4fe1\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u6240\u6709\u30af\u30ed\u30fc\u3058\u3083\u306f\u30de\u30cd\u30fc\u30b8\u30c9\u30af\u30ed\u30fc\u30b8\u30e3\u3068\u5168\u304f\u540c\u3058\u3088\"\n \"\u3046\u306b\u9589\u3058\u8fbc\u3081\u308b\u5024\u3092\u30b3\u30d4\u30fc\u3057\u307e\u3059\u304c\u3001\u5024\u3092\u6240\u6709\u3057\u307e\u3059\u3002\u3064\u307e\u308a\u3001\u4ed6\u306e\u30b3\u30fc\u30c9\u306f\u9589\u3058\u8fbc\"\n \"\u3081\u3089\u308c\u305f\u5024\u306b\u30a2\u30af\u30bb\u30b9\u3067\u304d\u306a\u304f\u306a\u308a\u307e\u3059\u3002\u6240\u6709\u30af\u30ed\u30fc\u30b8\u30e3\u306f\u4e26\u5217\u30d7\u30ed\u30b0\u30e9\u30e0\u3001\u7279\u306b \"\n@@ -3666,11 +3666,11 @@ msgstr \"\"\n #: doc/tutorial.md:1582\n msgid \"\"\n \"`do` is a convenient way to create tasks with the `task::spawn` function.  \"\n-\"`spawn` has the signature `spawn(fn: ~fn())`. In other words, it is a \"\n+\"`spawn` has the signature `spawn(fn: proc())`. In other words, it is a \"\n \"function that takes an owned closure that takes no arguments.\"\n msgstr \"\"\n \"`task::spawn` \u95a2\u6570\u3092\u7528\u3044\u3066\u30bf\u30b9\u30af\u3092\u751f\u6210\u3059\u308b\u5834\u5408\u3001 `do` \u3092\u7528\u3044\u308b\u3068\u4fbf\u5229\u3067\u3059\u3002\"\n-\"`spawn` \u306f\u3001 `spawn(fn: ~fn())` \u3068\u3044\u3046\u65b9\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u8a00\u3044\u63db\u3048\u308b\u3068\u3001\"\n+\"`spawn` \u306f\u3001 `spawn(fn: proc())` \u3068\u3044\u3046\u65b9\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u8a00\u3044\u63db\u3048\u308b\u3068\u3001\"\n \"`spawn` \u306f\u300c\u5f15\u6570\u3092\u3068\u3089\u306a\u3044\u6240\u6709\u30af\u30ed\u30fc\u30b8\u30e3\u300d\u3092\u5f15\u6570\u3068\u3057\u3066\u3068\u308b\u95a2\u6570\u3068\u3044\u3046\u3053\u3068\u3067\"\n \"\u3059\u3002\"\n "}, {"sha": "7a15fe196923f7070e321ed0d88ecc88fe380b04", "filename": "doc/po/tutorial-tasks.md.pot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Fpo%2Ftutorial-tasks.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Fpo%2Ftutorial-tasks.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-tasks.md.pot?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -213,7 +213,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial-tasks.md:102\n msgid \"\"\n-\"The `spawn` function has a very simple type signature: `fn spawn(f: ~fn())`. \"\n+\"The `spawn` function has a very simple type signature: `fn spawn(f: proc())`. \"\n \"Because it accepts only owned closures, and owned closures contain only \"\n \"owned data, `spawn` can safely move the entire closure and all its \"\n \"associated state into an entirely different task for execution. Like any \""}, {"sha": "86937652da93b9de24feeb4fd3c83263c1210d21", "filename": "doc/po/tutorial.md.pot", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Fpo%2Ftutorial.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Fpo%2Ftutorial.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial.md.pot?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -2683,7 +2683,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial.md:1510\n msgid \"\"\n-\"Owned closures, written `~fn` in analogy to the `~` pointer type, hold on to \"\n+\"Owned closures, written `proc`, hold on to \"\n \"things that can safely be sent between processes. They copy the values they \"\n \"close over, much like managed closures, but they also own them: that is, no \"\n \"other code can access them. Owned closures are used in concurrent code, \"\n@@ -2808,7 +2808,7 @@ msgstr \"\"\n #: doc/tutorial.md:1582\n msgid \"\"\n \"`do` is a convenient way to create tasks with the `task::spawn` function.  \"\n-\"`spawn` has the signature `spawn(fn: ~fn())`. In other words, it is a \"\n+\"`spawn` has the signature `spawn(fn: proc())`. In other words, it is a \"\n \"function that takes an owned closure that takes no arguments.\"\n msgstr \"\"\n "}, {"sha": "d357e3b335ebe0ef6b1acfc1c60791f116282b0a", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -91,7 +91,7 @@ _owned types_. The language leaves the implementation details to the standard\n library.\n \n The `spawn` function has a very simple type signature: `fn spawn(f:\n-~fn())`. Because it accepts only owned closures, and owned closures\n+proc())`. Because it accepts only owned closures, and owned closures\n contain only owned data, `spawn` can safely move the entire closure\n and all its associated state into an entirely different task for\n execution. Like any closure, the function passed to `spawn` may capture"}, {"sha": "313d36e38bf7e983d21e23063a4b1899971948ec", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -1409,7 +1409,7 @@ pervasively in Rust code.\n \n ## Owned closures\n \n-Owned closures, written `~fn` in analogy to the `~` pointer type,\n+Owned closures, written `proc`,\n hold on to things that can safely be sent between\n processes. They copy the values they close over, much like managed\n closures, but they also own them: that is, no other code can access\n@@ -1484,7 +1484,7 @@ parentheses, where it looks more like a typical block of\n code.\n \n `do` is a convenient way to create tasks with the `task::spawn`\n-function.  `spawn` has the signature `spawn(fn: ~fn())`. In other\n+function.  `spawn` has the signature `spawn(fn: proc())`. In other\n words, it is a function that takes an owned closure that takes no\n arguments.\n "}, {"sha": "640ced24badd189ada93f5cdf9b499a9cccda1f8", "filename": "src/libextra/future.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -36,7 +36,7 @@ pub struct Future<A> {\n }\n \n enum FutureState<A> {\n-    Pending(~fn() -> A),\n+    Pending(proc() -> A),\n     Evaluating,\n     Forced(A)\n }\n@@ -92,7 +92,7 @@ impl<A> Future<A> {\n         Future {state: Forced(val)}\n     }\n \n-    pub fn from_fn(f: ~fn() -> A) -> Future<A> {\n+    pub fn from_fn(f: proc() -> A) -> Future<A> {\n         /*!\n          * Create a future from a function.\n          *\n@@ -120,7 +120,7 @@ impl<A:Send> Future<A> {\n         }\n     }\n \n-    pub fn spawn(blk: ~fn() -> A) -> Future<A> {\n+    pub fn spawn(blk: proc() -> A) -> Future<A> {\n         /*!\n          * Create a future from a unique closure.\n          *\n@@ -137,7 +137,7 @@ impl<A:Send> Future<A> {\n         Future::from_port(port)\n     }\n \n-    pub fn spawn_with<B: Send>(v: B, blk: ~fn(B) -> A) -> Future<A> {\n+    pub fn spawn_with<B: Send>(v: B, blk: proc(B) -> A) -> Future<A> {\n         /*!\n          * Create a future from a unique closure taking one argument.\n          *"}, {"sha": "64fb954764a83efed2d3b8c1dbef0987f8ae056e", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -23,7 +23,7 @@ use std::vec;\n #[cfg(test)] use std::task::SingleThreaded;\n \n enum Msg<T> {\n-    Execute(~fn(&T)),\n+    Execute(proc(&T)),\n     Quit\n }\n \n@@ -49,15 +49,15 @@ impl<T> TaskPool<T> {\n     /// local data to be kept around in that task.\n     pub fn new(n_tasks: uint,\n                opt_sched_mode: Option<SchedMode>,\n-               init_fn_factory: ~fn() -> ~fn(uint) -> T)\n+               init_fn_factory: &fn() -> proc(uint) -> T)\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n         let channels = do vec::from_fn(n_tasks) |i| {\n             let (port, chan) = comm::stream::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n-            let task_body: ~fn() = || {\n+            let task_body: proc() = || {\n                 let local_data = init_fn(i);\n                 loop {\n                     match port.recv() {\n@@ -88,7 +88,7 @@ impl<T> TaskPool<T> {\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n-    pub fn execute(&mut self, f: ~fn(&T)) {\n+    pub fn execute(&mut self, f: proc(&T)) {\n         self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n@@ -97,8 +97,8 @@ impl<T> TaskPool<T> {\n \n #[test]\n fn test_task_pool() {\n-    let f: ~fn() -> ~fn(uint) -> uint = || {\n-        let g: ~fn(uint) -> uint = |i| i;\n+    let f: &fn() -> proc(uint) -> uint = || {\n+        let g: proc(uint) -> uint = |i| i;\n         g\n     };\n     let mut pool = TaskPool::new(4, Some(SingleThreaded), f);"}, {"sha": "acb3d538c982a620f8c88e32dcd9fa38f648528b", "filename": "src/libextra/test.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -74,17 +74,22 @@ impl TestDesc {\n     }\n }\n \n+/// Represents a benchmark function.\n+pub trait TDynBenchFn {\n+    fn run(&self, harness: &mut BenchHarness);\n+}\n+\n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n pub enum TestFn {\n     StaticTestFn(extern fn()),\n     StaticBenchFn(extern fn(&mut BenchHarness)),\n-    StaticMetricFn(~fn(&mut MetricMap)),\n-    DynTestFn(~fn()),\n-    DynMetricFn(~fn(&mut MetricMap)),\n-    DynBenchFn(~fn(&mut BenchHarness))\n+    StaticMetricFn(proc(&mut MetricMap)),\n+    DynTestFn(proc()),\n+    DynMetricFn(proc(&mut MetricMap)),\n+    DynBenchFn(~TDynBenchFn)\n }\n \n impl TestFn {\n@@ -859,7 +864,7 @@ pub fn run_test(force_ignore: bool,\n \n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n-                      testfn: ~fn()) {\n+                      testfn: proc()) {\n         let testfn_cell = ::std::cell::Cell::new(testfn);\n         do task::spawn {\n             let mut task = task::task();\n@@ -878,8 +883,8 @@ pub fn run_test(force_ignore: bool,\n     }\n \n     match testfn {\n-        DynBenchFn(benchfn) => {\n-            let bs = ::test::bench::benchmark(benchfn);\n+        DynBenchFn(bencher) => {\n+            let bs = ::test::bench::benchmark(|harness| bencher.run(harness));\n             monitor_ch.send((desc, TrBench(bs)));\n             return;\n         }"}, {"sha": "7ea7b513f4bd141c2be826a832221e82a8f8de18", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -394,14 +394,14 @@ impl<'self> Prep<'self> {\n     pub fn exec<T:Send +\n         Encodable<json::Encoder> +\n         Decodable<json::Decoder>>(\n-            &'self self, blk: ~fn(&mut Exec) -> T) -> T {\n+            &'self self, blk: proc(&mut Exec) -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n     fn exec_work<T:Send +\n         Encodable<json::Encoder> +\n         Decodable<json::Decoder>>( // FIXME(#5121)\n-            &'self self, blk: ~fn(&mut Exec) -> T) -> Work<'self, T> {\n+            &'self self, blk: proc(&mut Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n \n         debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,"}, {"sha": "ec4363e7f05dcda13b97c016671c4e8287b45137", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -322,7 +322,7 @@ diagnostic emitter which records when we hit a fatal error. If the task\n fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n-pub fn monitor(f: ~fn(@diagnostic::Emitter)) {\n+pub fn monitor(f: proc(@diagnostic::Emitter)) {\n     use std::comm::*;\n \n     // XXX: This is a hack for newsched since it doesn't support split stacks."}, {"sha": "05f708355b0e75f8e7427811ae1a857d8bce9e20", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -1101,7 +1101,7 @@ mod test {\n             let handle2 = Cell::new(sched2.make_handle());\n             let tasksFriendHandle = Cell::new(sched2.make_handle());\n \n-            let on_exit: ~fn(UnwindResult) = |exit_status| {\n+            let on_exit: proc(UnwindResult) = |exit_status| {\n                 handle1.take().send(Shutdown);\n                 handle2.take().send(Shutdown);\n                 assert!(exit_status.is_success());\n@@ -1115,7 +1115,7 @@ mod test {\n                 }\n             }\n \n-            let test_function: ~fn() = || {\n+            let test_function: proc() = || {\n                 let io = unsafe { local_io() };\n                 let addr = next_test_ip4();\n                 let maybe_socket = io.udp_bind(addr);"}, {"sha": "438261ba8a0a3fc40951806dabe28a9bc242b9ec", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -157,7 +157,7 @@ mod tests {\n     use io::*;\n     use rt::comm::oneshot;\n \n-    fn smalltest(server: ~fn(UnixStream), client: ~fn(UnixStream)) {\n+    fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n         let server = Cell::new(server);\n         let client = Cell::new(client);\n         do run_in_mt_newsched_task {"}, {"sha": "9769739b966b15ce60a335d3930af517ff3e69a1", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -478,11 +478,11 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n-        self.align_to::<~fn()>();\n+        self.align_to::<proc()>();\n         if ! self.inner.visit_closure_ptr(ck) {\n             return false\n         }\n-        self.bump_past::<~fn()>();\n+        self.bump_past::<proc()>();\n         true\n     }\n }"}, {"sha": "e59704a643574ec6dcd34594314d9c2d98521b54", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -25,7 +25,7 @@ pub static RED_ZONE: uint = 20 * 1024;\n // then misalign the regs again.\n pub struct Context {\n     /// The context entry point, saved here for later destruction\n-    priv start: Option<~~fn()>,\n+    priv start: Option<~proc()>,\n     /// Hold the registers while the task or scheduler is suspended\n     priv regs: ~Registers,\n     /// Lower bound and upper bound for the stack\n@@ -41,18 +41,24 @@ impl Context {\n         }\n     }\n \n-    /// Create a new context that will resume execution by running ~fn()\n-    pub fn new(start: ~fn(), stack: &mut StackSegment) -> Context {\n+    /// Create a new context that will resume execution by running proc()\n+    pub fn new(start: proc(), stack: &mut StackSegment) -> Context {\n         // FIXME #7767: Putting main into a ~ so it's a thin pointer and can\n         // be passed to the spawn function.  Another unfortunate\n         // allocation\n         let start = ~start;\n \n         // The C-ABI function that is the task entry point\n-        extern fn task_start_wrapper(f: &~fn()) { (*f)() }\n+        extern fn task_start_wrapper(f: &proc()) {\n+            // XXX(pcwalton): This may be sketchy.\n+            unsafe {\n+                let f: &|| = transmute(f);\n+                (*f)()\n+            }\n+        }\n \n         let fp: *c_void = task_start_wrapper as *c_void;\n-        let argp: *c_void = unsafe { transmute::<&~fn(), *c_void>(&*start) };\n+        let argp: *c_void = unsafe { transmute::<&proc(), *c_void>(&*start) };\n         let sp: *uint = stack.end();\n         let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n         // Save and then immediately load the current context,"}, {"sha": "f7abc33ce142d5c650aba7083137c856f0e960f2", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -110,7 +110,7 @@ see a failure from the grandchild task. While we could achieve this by having\n each intermediate task block on its handle, this keeps around the other resources\n the task was using. To be more efficient, this is accomplished via \"tombstones\".\n \n-A tombstone is a closure, ~fn() -> bool, which will perform any waiting necessary\n+A tombstone is a closure, proc() -> bool, which will perform any waiting necessary\n to collect the exit code of descendant tasks. In its environment is captured\n the KillHandle of whichever task created the tombstone, and perhaps also any\n tombstones that that task itself had, and finally also another tombstone,\n@@ -205,7 +205,7 @@ struct KillHandleInner {\n     // Locklessly accessed; protected by the enclosing refcount's barriers.\n     any_child_failed: bool,\n     // A lazy list, consuming which may unwrap() many child tombstones.\n-    child_tombstones: Option<~fn() -> bool>,\n+    child_tombstones: Option<proc() -> bool>,\n     // Protects multiple children simultaneously creating tombstones.\n     graveyard_lock: LittleLock,\n }\n@@ -223,7 +223,7 @@ pub struct Death {\n     priv watching_parent: Option<KillHandle>,\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n-    on_exit:         Option<~fn(UnwindResult)>,\n+    on_exit:         Option<proc(UnwindResult)>,\n     // nesting level counter for task::unkillable calls (0 == killable).\n     priv unkillable:      int,\n     // nesting level counter for unstable::atomically calls (0 == can deschedule).\n@@ -525,7 +525,8 @@ impl KillHandle {\n         // NB: Takes a pthread mutex -- 'blk' not allowed to reschedule.\n         #[inline]\n         fn add_lazy_tombstone(parent: &mut KillHandle,\n-                              blk: &fn(Option<~fn() -> bool>) -> ~fn() -> bool) {\n+                              blk: &fn(Option<proc() -> bool>)\n+                              -> proc() -> bool) {\n \n             let inner: &mut KillHandleInner = unsafe { &mut *parent.get() };\n             unsafe {"}, {"sha": "72e1f6a6e8faca825aff3dbb84a580580216d0e5", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -207,7 +207,7 @@ pub mod borrowck;\n /// # Return value\n ///\n /// The return value is used as the process return code. 0 on success, 101 on error.\n-pub fn start(argc: int, argv: **u8, main: ~fn()) -> int {\n+pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n \n     init(argc, argv);\n     let exit_code = run(main);\n@@ -221,7 +221,7 @@ pub fn start(argc: int, argv: **u8, main: ~fn()) -> int {\n ///\n /// This is appropriate for running code that must execute on the main thread,\n /// such as the platform event loop and GUI.\n-pub fn start_on_main_thread(argc: int, argv: **u8, main: ~fn()) -> int {\n+pub fn start_on_main_thread(argc: int, argv: **u8, main: proc()) -> int {\n     init(argc, argv);\n     let exit_code = run_on_main_thread(main);\n     cleanup();\n@@ -254,15 +254,15 @@ pub fn cleanup() {\n /// Configures the runtime according to the environment, by default\n /// using a task scheduler with the same number of threads as cores.\n /// Returns a process exit code.\n-pub fn run(main: ~fn()) -> int {\n+pub fn run(main: proc()) -> int {\n     run_(main, false)\n }\n \n-pub fn run_on_main_thread(main: ~fn()) -> int {\n+pub fn run_on_main_thread(main: proc()) -> int {\n     run_(main, true)\n }\n \n-fn run_(main: ~fn(), use_main_sched: bool) -> int {\n+fn run_(main: proc(), use_main_sched: bool) -> int {\n     static DEFAULT_ERROR_CODE: int = 101;\n \n     let nscheds = util::default_sched_threads();\n@@ -341,7 +341,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     // When the main task exits, after all the tasks in the main\n     // task tree, shut down the schedulers and set the exit code.\n     let handles = Cell::new(handles);\n-    let on_exit: ~fn(UnwindResult) = |exit_success| {\n+    let on_exit: proc(UnwindResult) = |exit_success| {\n         unsafe {\n             assert!(!(*exited_already.get()).swap(true, SeqCst),\n                     \"the runtime already exited\");"}, {"sha": "00895289b6a9896d258e14c65ef1a15b982af2b8", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -990,7 +990,9 @@ mod test {\n                 assert!(Task::on_appropriate_sched());\n             };\n \n-            let on_exit: ~fn(UnwindResult) = |exit_status| rtassert!(exit_status.is_success());\n+            let on_exit: proc(UnwindResult) = |exit_status| {\n+                rtassert!(exit_status.is_success())\n+            };\n             task.death.on_exit = Some(on_exit);\n \n             sched.bootstrap(task);"}, {"sha": "6d3eec9a9213b0be3d96dece27f50ad8af963841", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -139,7 +139,10 @@ impl Task {\n \n     // A helper to build a new task using the dynamically found\n     // scheduler and task. Only works in GreenTask context.\n-    pub fn build_homed_child(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n+    pub fn build_homed_child(stack_size: Option<uint>,\n+                             f: proc(),\n+                             home: SchedHome)\n+                             -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n         do Local::borrow |running_task: &mut Task| {\n@@ -153,11 +156,14 @@ impl Task {\n         }\n     }\n \n-    pub fn build_child(stack_size: Option<uint>, f: ~fn()) -> ~Task {\n+    pub fn build_child(stack_size: Option<uint>, f: proc()) -> ~Task {\n         Task::build_homed_child(stack_size, f, AnySched)\n     }\n \n-    pub fn build_homed_root(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n+    pub fn build_homed_root(stack_size: Option<uint>,\n+                            f: proc(),\n+                            home: SchedHome)\n+                            -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n         do Local::borrow |running_task: &mut Task| {\n@@ -171,7 +177,7 @@ impl Task {\n         }\n     }\n \n-    pub fn build_root(stack_size: Option<uint>, f: ~fn()) -> ~Task {\n+    pub fn build_root(stack_size: Option<uint>, f: proc()) -> ~Task {\n         Task::build_homed_root(stack_size, f, AnySched)\n     }\n \n@@ -196,21 +202,21 @@ impl Task {\n \n     pub fn new_root(stack_pool: &mut StackPool,\n                     stack_size: Option<uint>,\n-                    start: ~fn()) -> Task {\n+                    start: proc()) -> Task {\n         Task::new_root_homed(stack_pool, stack_size, AnySched, start)\n     }\n \n     pub fn new_child(&mut self,\n                      stack_pool: &mut StackPool,\n                      stack_size: Option<uint>,\n-                     start: ~fn()) -> Task {\n+                     start: proc()) -> Task {\n         self.new_child_homed(stack_pool, stack_size, AnySched, start)\n     }\n \n     pub fn new_root_homed(stack_pool: &mut StackPool,\n                           stack_size: Option<uint>,\n                           home: SchedHome,\n-                          start: ~fn()) -> Task {\n+                          start: proc()) -> Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n@@ -233,7 +239,7 @@ impl Task {\n                            stack_pool: &mut StackPool,\n                            stack_size: Option<uint>,\n                            home: SchedHome,\n-                           start: ~fn()) -> Task {\n+                           start: proc()) -> Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n@@ -404,7 +410,10 @@ impl Drop for Task {\n \n impl Coroutine {\n \n-    pub fn new(stack_pool: &mut StackPool, stack_size: Option<uint>, start: ~fn()) -> Coroutine {\n+    pub fn new(stack_pool: &mut StackPool,\n+               stack_size: Option<uint>,\n+               start: proc())\n+               -> Coroutine {\n         let stack_size = match stack_size {\n             Some(size) => size,\n             None => env::min_stack()\n@@ -425,9 +434,9 @@ impl Coroutine {\n         }\n     }\n \n-    fn build_start_wrapper(start: ~fn()) -> ~fn() {\n+    fn build_start_wrapper(start: proc()) -> proc() {\n         let start_cell = Cell::new(start);\n-        let wrapper: ~fn() = || {\n+        let wrapper: proc() = || {\n             // First code after swap to this new context. Run our\n             // cleanup job.\n             unsafe {"}, {"sha": "d87eb56a6500e603cff303040605b33e5adcf299", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -64,28 +64,28 @@ pub fn new_test_sched() -> Scheduler {\n     return sched;\n }\n \n-pub fn run_in_uv_task(f: ~fn()) {\n+pub fn run_in_uv_task(f: proc()) {\n     let f = Cell::new(f);\n     do run_in_bare_thread {\n         run_in_uv_task_core(f.take());\n     }\n }\n \n-pub fn run_in_newsched_task(f: ~fn()) {\n+pub fn run_in_newsched_task(f: proc()) {\n     let f = Cell::new(f);\n     do run_in_bare_thread {\n         run_in_newsched_task_core(f.take());\n     }\n }\n \n-pub fn run_in_uv_task_core(f: ~fn()) {\n+pub fn run_in_uv_task_core(f: proc()) {\n \n     use rt::sched::Shutdown;\n \n     let mut sched = ~new_test_uv_sched();\n     let exit_handle = Cell::new(sched.make_handle());\n \n-    let on_exit: ~fn(UnwindResult) = |exit_status| {\n+    let on_exit: proc(UnwindResult) = |exit_status| {\n         exit_handle.take().send(Shutdown);\n         rtassert!(exit_status.is_success());\n     };\n@@ -95,13 +95,13 @@ pub fn run_in_uv_task_core(f: ~fn()) {\n     sched.bootstrap(task);\n }\n \n-pub fn run_in_newsched_task_core(f: ~fn()) {\n+pub fn run_in_newsched_task_core(f: proc()) {\n     use rt::sched::Shutdown;\n \n     let mut sched = ~new_test_sched();\n     let exit_handle = Cell::new(sched.make_handle());\n \n-    let on_exit: ~fn(UnwindResult) = |exit_status| {\n+    let on_exit: proc(UnwindResult) = |exit_status| {\n         exit_handle.take().send(Shutdown);\n         rtassert!(exit_status.is_success());\n     };\n@@ -195,7 +195,7 @@ pub fn prepare_for_lots_of_tests() {\n /// Create more than one scheduler and run a function in a task\n /// in one of the schedulers. The schedulers will stay alive\n /// until the function `f` returns.\n-pub fn run_in_mt_newsched_task(f: ~fn()) {\n+pub fn run_in_mt_newsched_task(f: proc()) {\n     use os;\n     use from_str::FromStr;\n     use rt::sched::Shutdown;\n@@ -245,7 +245,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         let handles = Cell::new(handles);\n-        let on_exit: ~fn(UnwindResult) = |exit_status| {\n+        let on_exit: proc(UnwindResult) = |exit_status| {\n             let mut handles = handles.take();\n             // Tell schedulers to exit\n             for handle in handles.mut_iter() {\n@@ -294,16 +294,16 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n }\n \n /// Test tasks will abort on failure instead of unwinding\n-pub fn spawntask(f: ~fn()) {\n+pub fn spawntask(f: proc()) {\n     Scheduler::run_task(Task::build_child(None, f));\n }\n \n /// Create a new task and run it right now. Aborts on failure\n-pub fn spawntask_later(f: ~fn()) {\n+pub fn spawntask_later(f: proc()) {\n     Scheduler::run_task_later(Task::build_child(None, f));\n }\n \n-pub fn spawntask_random(f: ~fn()) {\n+pub fn spawntask_random(f: proc()) {\n     use rand::{Rand, rng};\n \n     let mut rng = rng();\n@@ -316,11 +316,11 @@ pub fn spawntask_random(f: ~fn()) {\n     }\n }\n \n-pub fn spawntask_try(f: ~fn()) -> Result<(),()> {\n+pub fn spawntask_try(f: proc()) -> Result<(),()> {\n \n     let (port, chan) = oneshot();\n     let chan = Cell::new(chan);\n-    let on_exit: ~fn(UnwindResult) = |exit_status| chan.take().send(exit_status);\n+    let on_exit: proc(UnwindResult) = |exit_status| chan.take().send(exit_status);\n \n     let mut new_task = Task::build_root(None, f);\n     new_task.death.on_exit = Some(on_exit);\n@@ -333,7 +333,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(),()> {\n }\n \n /// Spawn a new task in a new scheduler and return a thread handle.\n-pub fn spawntask_thread(f: ~fn()) -> Thread {\n+pub fn spawntask_thread(f: proc()) -> Thread {\n \n     let f = Cell::new(f);\n \n@@ -345,7 +345,7 @@ pub fn spawntask_thread(f: ~fn()) -> Thread {\n }\n \n /// Get a ~Task for testing purposes other than actually scheduling it.\n-pub fn with_test_task(blk: ~fn(~Task) -> ~Task) {\n+pub fn with_test_task(blk: proc(~Task) -> ~Task) {\n     do run_in_bare_thread {\n         let mut sched = ~new_test_sched();\n         let task = blk(~Task::new_root(&mut sched.stack_pool, None, ||{}));"}, {"sha": "e364e5a6603f455361cee52833b92662a036ae41", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -35,7 +35,7 @@ static DEFAULT_STACK_SIZE: libc::size_t = 1024*1024;\n \n impl Thread {\n \n-    pub fn start(main: ~fn()) -> Thread {\n+    pub fn start(main: proc()) -> Thread {\n         // This is the starting point of rust os threads. The first thing we do\n         // is make sure that we don't trigger __morestack (also why this has a\n         // no_split_stack annotation), and then we extract the main function\n@@ -45,7 +45,7 @@ impl Thread {\n             use rt::context;\n             unsafe {\n                 context::record_stack_bounds(0, uint::max_value);\n-                let f: ~~fn() = cast::transmute(trampoline);\n+                let f: ~proc() = cast::transmute(trampoline);\n                 (*f)();\n             }\n             unsafe { cast::transmute(0) }\n@@ -67,7 +67,7 @@ impl Thread {\n \n #[cfg(windows)]\n fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                        tramp: ~~fn()) -> rust_thread {\n+                        tramp: ~proc()) -> rust_thread {\n     unsafe {\n         let ptr: *mut libc::c_void = cast::transmute(tramp);\n         CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start, ptr, 0, ptr::mut_null())\n@@ -82,7 +82,7 @@ fn native_thread_join(native: rust_thread) {\n \n #[cfg(unix)]\n fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                        tramp: ~~fn()) -> rust_thread {\n+                        tramp: ~proc()) -> rust_thread {\n     use unstable::intrinsics;\n     let mut native: libc::pthread_t = unsafe { intrinsics::uninit() };\n "}, {"sha": "5915dd45c08dc73f0615227e636c807de2a35bd4", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -195,7 +195,7 @@ pub struct TaskOpts {\n // FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n     opts: TaskOpts,\n-    priv gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n+    priv gen_body: Option<proc(v: proc()) -> proc()>,\n     priv can_not_copy: Option<util::NonCopyable>,\n     priv consumed: bool,\n }\n@@ -340,18 +340,18 @@ impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    pub fn add_wrapper(&mut self, wrapper: ~fn(v: ~fn()) -> ~fn()) {\n+    pub fn add_wrapper(&mut self, wrapper: proc(v: proc()) -> proc()) {\n         let prev_gen_body = self.gen_body.take();\n         let prev_gen_body = match prev_gen_body {\n             Some(gen) => gen,\n             None => {\n-                let f: ~fn(~fn()) -> ~fn() = |body| body;\n+                let f: proc(proc()) -> proc() = |body| body;\n                 f\n             }\n         };\n         let prev_gen_body = Cell::new(prev_gen_body);\n         let next_gen_body = {\n-            let f: ~fn(~fn()) -> ~fn() = |body| {\n+            let f: proc(proc()) -> proc() = |body| {\n                 let prev_gen_body = prev_gen_body.take();\n                 wrapper(prev_gen_body(body))\n             };\n@@ -372,7 +372,7 @@ impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    pub fn spawn(&mut self, f: ~fn()) {\n+    pub fn spawn(&mut self, f: proc()) {\n         let gen_body = self.gen_body.take();\n         let notify_chan = self.opts.notify_chan.take();\n         let name = self.opts.name.take();\n@@ -399,7 +399,7 @@ impl TaskBuilder {\n     }\n \n     /// Runs a task, while transferring ownership of one argument to the child.\n-    pub fn spawn_with<A:Send>(&mut self, arg: A, f: ~fn(v: A)) {\n+    pub fn spawn_with<A:Send>(&mut self, arg: A, f: proc(v: A)) {\n         let arg = Cell::new(arg);\n         do self.spawn {\n             f(arg.take());\n@@ -419,7 +419,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    pub fn try<T:Send>(&mut self, f: ~fn() -> T) -> Result<T, ~Any> {\n+    pub fn try<T:Send>(&mut self, f: proc() -> T) -> Result<T, ~Any> {\n         let (po, ch) = stream::<T>();\n \n         let result = self.future_result();\n@@ -468,20 +468,20 @@ pub fn default_task_opts() -> TaskOpts {\n /// the provided unique closure.\n ///\n /// This function is equivalent to `task().spawn(f)`.\n-pub fn spawn(f: ~fn()) {\n+pub fn spawn(f: proc()) {\n     let mut task = task();\n     task.spawn(f)\n }\n \n /// Creates a child task unlinked from the current one. If either this\n /// task or the child task fails, the other will not be killed.\n-pub fn spawn_unlinked(f: ~fn()) {\n+pub fn spawn_unlinked(f: proc()) {\n     let mut task = task();\n     task.unlinked();\n     task.spawn(f)\n }\n \n-pub fn spawn_supervised(f: ~fn()) {\n+pub fn spawn_supervised(f: proc()) {\n     /*!\n      * Creates a child task supervised by the current one. If the child\n      * task fails, the parent will not be killed, but if the parent fails,\n@@ -498,13 +498,13 @@ pub fn spawn_supervised(f: ~fn()) {\n /// (Note that this convenience wrapper still uses linked-failure, so the\n /// child's children will still be killable by the parent. For the fastest\n /// possible spawn mode, use task::task().unlinked().indestructible().spawn.)\n-pub fn spawn_indestructible(f: ~fn()) {\n+pub fn spawn_indestructible(f: proc()) {\n     let mut task = task();\n     task.indestructible();\n     task.spawn(f)\n }\n \n-pub fn spawn_with<A:Send>(arg: A, f: ~fn(v: A)) {\n+pub fn spawn_with<A:Send>(arg: A, f: proc(v: A)) {\n     /*!\n      * Runs a task, while transferring ownership of one argument to the\n      * child.\n@@ -519,7 +519,7 @@ pub fn spawn_with<A:Send>(arg: A, f: ~fn(v: A)) {\n     task.spawn_with(arg, f)\n }\n \n-pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n+pub fn spawn_sched(mode: SchedMode, f: proc()) {\n     /*!\n      * Creates a new task on a new or existing scheduler.\n      *\n@@ -537,7 +537,7 @@ pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n     task.spawn(f)\n }\n \n-pub fn try<T:Send>(f: ~fn() -> T) -> Result<T, ~Any> {\n+pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -1033,7 +1033,7 @@ fn test_add_wrapper() {\n     let ch = Cell::new(ch);\n     do b0.add_wrapper |body| {\n         let ch = Cell::new(ch.take());\n-        let result: ~fn() = || {\n+        let result: proc() = || {\n             let ch = ch.take();\n             body();\n             ch.send(());\n@@ -1201,7 +1201,7 @@ fn test_spawn_sched_blocking() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n+fn avoid_copying_the_body(spawnfn: &fn(v: proc())) {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n@@ -1327,7 +1327,7 @@ fn test_child_doesnt_ref_parent() {\n     // (well, it would if the constant were 8000+ - I lowered it to be more\n     // valgrind-friendly. try this at home, instead..!)\n     static generations: uint = 16;\n-    fn child_no(x: uint) -> ~fn() {\n+    fn child_no(x: uint) -> proc() {\n         return || {\n             if x < generations {\n                 let mut t = task();"}, {"sha": "d7d3e715ef9cab219cb67efdf198816a20afe94a", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -562,13 +562,13 @@ fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n     result\n }\n \n-pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n+pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n     assert!(in_green_task_context());\n \n     let child_data = Cell::new(gen_child_taskgroup(opts.linked, opts.supervised));\n     let indestructible = opts.indestructible;\n \n-    let child_wrapper: ~fn() = || {\n+    let child_wrapper: proc() = || {\n         // Child task runs this code.\n \n         // If child data is 'None', the enlist is vacuously successful.\n@@ -589,12 +589,14 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n                 }\n             }\n         };\n+\n         // Should be run after the local-borrowed task is returned.\n+        let f_cell = Cell::new(f);\n         if enlist_success {\n             if indestructible {\n-                do unkillable { f() }\n+                do unkillable { f_cell.take()() }\n             } else {\n-                f()\n+                f_cell.take()()\n             }\n         }\n     };\n@@ -683,7 +685,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n     if opts.notify_chan.is_some() {\n         let notify_chan = opts.notify_chan.take_unwrap();\n         let notify_chan = Cell::new(notify_chan);\n-        let on_exit: ~fn(UnwindResult) = |task_result| {\n+        let on_exit: proc(UnwindResult) = |task_result| {\n             notify_chan.take().send(task_result)\n         };\n         task.death.on_exit = Some(on_exit);"}, {"sha": "266a619c710371138d6df0a93ad9495d01328b97", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -54,7 +54,6 @@ impl<'self,T> Finally<T> for &'self fn() -> T {\n     }\n }\n \n-finally_fn!(~fn() -> T)\n finally_fn!(extern \"Rust\" fn() -> T)\n \n struct Finallyalizer<'self> {\n@@ -109,12 +108,3 @@ fn test_compact() {\n         but_always_run_this_function);\n }\n \n-#[test]\n-fn test_owned() {\n-    fn spawn_with_finalizer(f: ~fn()) {\n-        do spawn { do f.finally { } }\n-    }\n-    let owned: ~fn() = || { };\n-    spawn_with_finalizer(owned);\n-}\n-"}, {"sha": "63528036ffaecd1f958e3bb29ec8398422e476ad", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -36,7 +36,7 @@ for it to terminate.\n The executing thread has no access to a task pointer and will be using\n a normal large stack.\n */\n-pub fn run_in_bare_thread(f: ~fn()) {\n+pub fn run_in_bare_thread(f: proc()) {\n     use cell::Cell;\n     use rt::thread::Thread;\n "}, {"sha": "189cc8e827c83f3226fc2faf5e8036a499d17432", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -41,7 +41,8 @@ pub enum ObsoleteSyntax {\n     ObsoleteLoopAsContinue,\n     ObsoleteEnumWildcard,\n     ObsoleteStructWildcard,\n-    ObsoleteVecDotDotWildcard\n+    ObsoleteVecDotDotWildcard,\n+    ObsoleteBoxedClosure,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -128,6 +129,11 @@ impl ParserObsoleteMethods for Parser {\n                 \"vec slice wildcard\",\n                 \"use `..` instead of `.._` for matching slices\"\n             ),\n+            ObsoleteBoxedClosure => (\n+                \"managed or owned closure\",\n+                \"managed closures have been removed and owned closures are \\\n+                 now written `proc()`\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "2ea6878f4a3701219cc9a40d684e30ec6557ff34", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -1273,15 +1273,17 @@ impl Parser {\n     pub fn parse_box_or_uniq_pointee(&self,\n                                      sigil: ast::Sigil,\n                                      ctor: &fn(v: mt) -> ty_) -> ty_ {\n-        // ~'foo fn() or ~fn() are parsed directly as fn types:\n+        // ~'foo fn() or ~fn() are parsed directly as obsolete fn types:\n         match *self.token {\n             token::LIFETIME(*) => {\n                 let lifetime = self.parse_lifetime();\n+                self.obsolete(*self.last_span, ObsoleteBoxedClosure);\n                 return self.parse_ty_closure(Some(sigil), Some(lifetime));\n             }\n \n-            token::IDENT(*) => {\n+            token::IDENT(*) if sigil == ast::BorrowedSigil => {\n                 if self.token_is_old_style_closure_keyword() {\n+                    self.obsolete(*self.last_span, ObsoleteBoxedClosure);\n                     return self.parse_ty_closure(Some(sigil), None);\n                 }\n             }"}, {"sha": "73ecd33bc7ca92c6b71ca7a908cdc2e7dea74c4b", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -53,7 +53,7 @@ fn grandchild_group(num_tasks: uint) {\n     // Master grandchild task exits early.\n }\n \n-fn spawn_supervised_blocking(myname: &str, f: ~fn()) {\n+fn spawn_supervised_blocking(myname: &str, f: proc()) {\n     let mut builder = task::task();\n     let res = builder.future_result();\n     builder.supervised();"}, {"sha": "42dee384116c97cbf6dff28c8772de033b7eeb74", "filename": "src/test/compile-fail/borrowck-call-sendfn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -11,7 +11,7 @@\n // xfail-test #2978\n \n struct Foo {\n-    f: ~fn()\n+    f: proc()\n }\n \n fn call(x: @Foo) {"}, {"sha": "aa50f9ac3fee0df2d85c9e3c20eea2604e1508a5", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -1,13 +1,8 @@\n pub fn main() {\n-    let foo = ~3;\n-    let _pfoo = &foo;\n-    let _f: ~fn() -> int = || *foo + 5;\n-    //~^ ERROR cannot move `foo`\n-\n     // FIXME(#2202) - Due to the way that borrowck treats closures,\n     // you get two error reports here.\n     let bar = ~3;\n     let _g = || { //~ ERROR capture of moved value\n-        let _h: ~fn() -> int = || *bar; //~ ERROR capture of moved value\n+        let _h: proc() -> int = || *bar; //~ ERROR capture of moved value\n     };\n }"}, {"sha": "b6ad3ed95a4b4745eca0d9c1aa4d2b9ef0f8fc39", "filename": "src/test/compile-fail/borrowck-move-moved-value-into-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -1,4 +1,4 @@\n-fn call_f(f: ~fn:Send() -> int) -> int {\n+fn call_f(f: proc() -> int) -> int {\n     f()\n }\n "}, {"sha": "00eb31485b9d7af4bc367fd95a9e7e89187d2a13", "filename": "src/test/compile-fail/closure-bounds-cant-promote-superkind-in-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct X {\n-    field: ~fn:Send(),\n+    field: &'static fn:Send(),\n }\n \n-fn foo(blk: ~fn:()) -> X {\n+fn foo(blk: &'static fn:()) -> X {\n     return X { field: blk }; //~ ERROR expected bounds `Send` but found no bounds\n }\n "}, {"sha": "10d3e9ed3f10cbfffa8da6fdd4a0a9dddfa41096", "filename": "src/test/compile-fail/issue-8615.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Ftest%2Fcompile-fail%2Fissue-8615.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Ftest%2Fcompile-fail%2Fissue-8615.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8615.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let _: @'static whatever fn(); //~ ERROR expected `fn`, found `whatever`\n-    let _: @'static fn();\n-}"}, {"sha": "308eb637cd0b98f9de12cd30f0d46ed282ed5589", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -14,7 +14,7 @@ fn foo(_x: @uint) {}\n \n fn main() {\n     let x = @3u;\n-    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Send`\n-    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Send`\n-    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc() = || foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc() = || foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc() = || foo(x); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "bfef15ea1731c35e866258a0c62bed21e3e222e4", "filename": "src/test/compile-fail/kindck-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -47,7 +47,7 @@ fn test<'a,T,U:Send>(_: &'a int) {\n \n     // but closure and object types can have lifetime bounds which make\n     // them not ok (FIXME #5121)\n-    // assert_send::<~fn:'a()>(); // ERROR does not fulfill `Send`\n+    // assert_send::<proc:'a()>(); // ERROR does not fulfill `Send`\n     // assert_send::<~Dummy:'a>(); // ERROR does not fulfill `Send`\n \n     // unsafe ptrs are ok unless they point at unsendable things"}, {"sha": "57c1cb5ecc640ea2ace4ef731c1749d68d4617cf", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -1,4 +1,4 @@\n-type Noncopyable = ~fn();\n+type Noncopyable = proc();\n \n struct Foo {\n     copied: int,"}, {"sha": "81e140567e4f47fdfc77480f523bf704656fe69f", "filename": "src/test/compile-fail/once-cant-call-twice-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -16,7 +16,7 @@ extern mod extra;\n use extra::arc;\n use std::util;\n \n-fn foo(blk: ~once fn()) {\n+fn foo(blk: proc()) {\n     blk();\n     blk(); //~ ERROR use of moved value\n }"}, {"sha": "cc40fb6b8d88eea28edd8b844dde366cdb9bd7c0", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-heap.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Testing guarantees provided by once functions.\n-// This program would segfault if it were legal.\n-\n-extern mod extra;\n-use extra::arc;\n-use std::util;\n-\n-fn foo(blk: ~fn()) {\n-    blk();\n-    blk();\n-}\n-\n-fn main() {\n-    let x = arc::Arc::new(true);\n-    do foo {\n-        assert!(*x.get());\n-        util::ignore(x); //~ ERROR cannot move out of captured outer variable\n-    }\n-}"}, {"sha": "a743ff81b301a34c2008cae5fced5e88967b8810", "filename": "src/test/compile-fail/regions-infer-region-in-fn-but-not-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -11,7 +11,7 @@\n \n // check that the &int here does not cause us to think that `foo`\n // contains region pointers\n-struct foo(~fn(x: &int));\n+struct foo(proc(x: &int));\n \n fn take_foo(x: foo<'static>) {} //~ ERROR wrong number of lifetime parameters\n "}, {"sha": "da9220322dd74f2776c96fb594782acd1c2a781e", "filename": "src/test/debug-info/lexical-scope-in-unique-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unique-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unique-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unique-closure.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -51,7 +51,7 @@ fn main() {\n     zzz();\n     sentinel();\n \n-    let unique_closure: ~fn(int) = |x| {\n+    let unique_closure: proc(int) = |x| {\n         zzz();\n         sentinel();\n "}, {"sha": "664e377c9fbe99e4692c147f84ae53c7dfc80299", "filename": "src/test/debug-info/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -39,7 +39,7 @@ fn main() {\n \n     let owned = ~5;\n \n-    let closure: ~fn() = || {\n+    let closure: proc() = || {\n         zzz();\n         do_something(&constant, &a_struct.a, owned);\n     };"}, {"sha": "ffa6f03909b023a07eb3fabf491b41c96934b943", "filename": "src/test/pretty/fn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fpretty%2Ffn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Fpretty%2Ffn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffn-types.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -12,5 +12,5 @@\n \n fn from_foreign_fn(_x: fn()) { }\n fn from_stack_closure(_x: ||) { }\n-fn from_unique_closure(_x: ~fn()) { }\n+fn from_unique_closure(_x: proc()) { }\n fn main() { }"}, {"sha": "b28a2a6f1f0323eb822a9096f52b16823e63fc93", "filename": "src/test/run-fail/unwind-box-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-fn-unique.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -18,7 +18,7 @@ fn failfn() {\n \n fn main() {\n     let y = ~0;\n-    let x: @~fn() = @(|| {\n+    let x: @proc() = @(|| {\n         error!(\"{:?}\", y.clone());\n     });\n     failfn();"}, {"sha": "5aa28258792e682f963e1fdbbe1aedc415d105bf", "filename": "src/test/run-pass/block-arg-call-as.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -10,7 +10,7 @@\n \n extern mod extra;\n \n-fn asSendfn( f : ~fn()->uint ) -> uint {\n+fn asSendfn( f : proc()->uint ) -> uint {\n    return f();\n }\n "}, {"sha": "2f186cc3fba304503d00fd249f62e18c501bae4e", "filename": "src/test/run-pass/borrowck-move-by-capture-ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -1,5 +1,5 @@\n pub fn main() {\n     let bar = ~3;\n-    let h: ~fn() -> int = || *bar;\n+    let h: proc() -> int = || *bar;\n     assert_eq!(h(), 3);\n }"}, {"sha": "c6227fdcc5effe196ac79f056ff4b0b09e85d468", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -13,11 +13,11 @@ use std::ptr;\n pub fn main() {\n     let x = ~3;\n     let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n-    let snd_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let snd_move: proc() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert_eq!(snd_move(), y);\n \n     let x = ~4;\n     let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n-    let lam_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let lam_move: proc() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert_eq!(lam_move(), y);\n }"}, {"sha": "cceb0f353fb3a60cee3e9e23b075883929a3f2de", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -19,7 +19,7 @@ struct Pair {\n pub fn main() {\n     let z = ~Pair { a : 10, b : 12};\n \n-    let f: ~fn() = || {\n+    let f: proc() = || {\n         assert_eq!(z.a, 10);\n         assert_eq!(z.b, 12);\n     };"}, {"sha": "16c7eaf1037fddc28a7831047214f5bbf11cc59b", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -10,7 +10,7 @@\n \n use std::comm;\n \n-fn foo(blk: ~fn:Send()) {\n+fn foo(blk: proc()) {\n     blk();\n }\n "}, {"sha": "023381949a3577f1316a1e4ce9b3574f0b94b868", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -15,8 +15,8 @@ extern mod extra;\n  *\n  * The hash should concentrate entropy in the lower bits.\n  */\n-type HashFn<K> = ~fn(K) -> uint;\n-type EqFn<K> = ~fn(K, K) -> bool;\n+type HashFn<K> = proc(K) -> uint;\n+type EqFn<K> = proc(K, K) -> bool;\n \n struct LM { resize_at: uint, size: uint }\n "}, {"sha": "0aaaa58fdd257fd337d306e8519f314c879f067a", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -11,7 +11,7 @@\n // xfail-test\n static generations: uint = 1024+256+128+49;\n \n-fn child_no(x: uint) -> ~fn() {\n+fn child_no(x: uint) -> proc() {\n      || {\n         if x < generations {\n             task::spawn(child_no(x+1));"}, {"sha": "aeb4aad7d8315e266061618347198320de149313", "filename": "src/test/run-pass/issue-2190.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fissue-2190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fissue-2190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test\n type t = {\n-    f: ~fn()\n+    f: proc()\n };\n \n pub fn main() {"}, {"sha": "0b8fcdfbd84946ac675406176ba16e37c6cff70b", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -17,7 +17,7 @@ use std::path::{Path};\n use std::path;\n use std::result;\n \n-type rsrc_loader = ~fn(path: &Path) -> result::Result<~str, ~str>;\n+type rsrc_loader = proc(path: &Path) -> result::Result<~str, ~str>;\n \n fn tester()\n {"}, {"sha": "b283ba67d59bd13604d451493e2d5f96e40405e9", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -4,7 +4,7 @@ use std::comm::Chan;\n use std::task;\n \n type RingBuffer = ~[f64];\n-type SamplesFn = ~fn(samples: &RingBuffer);\n+type SamplesFn = proc(samples: &RingBuffer);\n \n enum Msg\n {"}, {"sha": "98d2ca5d9424e20874a4b0802af7065a8532fb58", "filename": "src/test/run-pass/issue-6141-leaking-owned-fn.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Ftest%2Frun-pass%2Fissue-6141-leaking-owned-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Ftest%2Frun-pass%2Fissue-6141-leaking-owned-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6141-leaking-owned-fn.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -1,8 +0,0 @@\n-fn run(f: &fn()) {\n-    f()\n-}\n-\n-pub fn main() {\n-    let f: ~fn() = || ();\n-    run(f);\n-}"}, {"sha": "e5844785a50f96c41729b988cec46ad227fa350f", "filename": "src/test/run-pass/newlambdas-ret-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -11,7 +11,7 @@\n // Test that the lambda kind is inferred correctly as a return\n // expression\n \n-fn unique() -> ~fn() { return || (); }\n+fn unique() -> proc() { return || (); }\n \n pub fn main() {\n }"}, {"sha": "ccf1997498be11e9ee9491d6ffd5806086bed5fe", "filename": "src/test/run-pass/newlambdas-ret-infer2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -11,7 +11,7 @@\n // Test that the lambda kind is inferred correctly as a return\n // expression\n \n-fn unique() -> ~fn() { || () }\n+fn unique() -> proc() { || () }\n \n pub fn main() {\n }"}, {"sha": "bf0af534597e759676aba9b71415f0efd39277be", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -17,7 +17,7 @@ extern mod extra;\n use extra::arc;\n use std::util;\n \n-fn foo(blk: ~once fn()) {\n+fn foo(blk: proc()) {\n     blk();\n }\n "}, {"sha": "5dd8ea96d3738a405a35221774aaad7ecff4c0e5", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -69,6 +69,6 @@ pub fn main() {\n     assert_eq!(q.y, !(p.y));\n \n     // Issue #1733\n-    let result: ~fn(int) = |_|();\n+    let result: proc(int) = |_|();\n     result(p[true]);\n }"}, {"sha": "d077db69c2a8c24ffe686e43e43e40343ea0d06e", "filename": "src/test/run-pass/sendfn-generic-fn.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -1,46 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-\n-use std::task;\n-\n-pub fn main() { test05(); }\n-\n-#[deriving(Clone)]\n-struct Pair<A,B> {\n-    a: A,\n-    b: B,\n-}\n-\n-fn make_generic_record<A,B>(a: A, b: B) -> Pair<A,B> {\n-    return Pair {a: a, b: b};\n-}\n-\n-fn test05_start(f: &~fn(v: f64, v: ~str) -> Pair<f64, ~str>) {\n-    let p = (*f)(22.22, ~\"Hi\");\n-    info!(\"{:?}\", p.clone());\n-    assert!(p.a == 22.22);\n-    assert!(p.b == ~\"Hi\");\n-\n-    let q = (*f)(44.44, ~\"Ho\");\n-    info!(\"{:?}\", q.clone());\n-    assert!(q.a == 44.44);\n-    assert!(q.b == ~\"Ho\");\n-}\n-\n-fn spawn<A,B>(f: extern fn(&~fn(A,B)->Pair<A,B>)) {\n-    let arg: ~fn(A, B) -> Pair<A,B> = |a, b| make_generic_record(a, b);\n-    task::spawn(|| f(&arg));\n-}\n-\n-fn test05() {\n-    spawn::<f64,~str>(test05_start);\n-}"}, {"sha": "91bc8345845d96a0f258626dd2d9072dadd22924", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -13,13 +13,13 @@ use std::task;\n \n pub fn main() { test05(); }\n \n-fn test05_start(f: ~fn(int)) {\n+fn test05_start(f: proc(int)) {\n     f(22);\n }\n \n fn test05() {\n     let three = ~3;\n-    let fn_to_send: ~fn(int) = |n| {\n+    let fn_to_send: proc(int) = |n| {\n         error!(\"{}\", *three + n); // will copy x into the closure\n         assert_eq!(*three, 3);\n     };"}, {"sha": "986a9a8c49c31b85b368e3d3d9d14808062ac005", "filename": "src/test/run-pass/swap-overlapping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -34,8 +34,8 @@ pub enum TestName {\n }\n \n pub enum TestFn {\n-    DynTestFn(~fn()),\n-    DynBenchFn(~fn(&mut int))\n+    DynTestFn(proc()),\n+    DynBenchFn(proc(&mut int))\n }\n \n pub struct TestDesc {"}, {"sha": "395d6b0b51ad2559da63f417a2d5899670216393", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -44,7 +44,7 @@ fn notify(ch: Chan<bool>, v: @mut bool) -> notify {\n     }\n }\n \n-fn joinable(f: ~fn()) -> Port<bool> {\n+fn joinable(f: proc()) -> Port<bool> {\n     fn wrapper(c: Chan<bool>, f: &fn()) {\n         let b = @mut false;\n         error!(\"wrapper: task=%? allocated v=%x\","}, {"sha": "a10753451400a6cc9e4c3509f468c9794d1b3a40", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -40,7 +40,7 @@ fn test_tempdir() {\n \n fn test_rm_tempdir() {\n     let (rd, wr) = stream();\n-    let f: ~fn() = || {\n+    let f: proc() = || {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         wr.send(tmp.path().clone());\n         fail!(\"fail to unwind past `tmp`\");\n@@ -52,7 +52,7 @@ fn test_rm_tempdir() {\n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n     let cell = Cell::new(tmp);\n-    let f: ~fn() = || {\n+    let f: proc() = || {\n         let _tmp = cell.take();\n         fail!(\"fail to unwind past `tmp`\");\n     };\n@@ -61,7 +61,7 @@ fn test_rm_tempdir() {\n \n     let path;\n     {\n-        let f: ~fn() -> TempDir = || {\n+        let f: proc() -> TempDir = || {\n             TempDir::new(\"test_rm_tempdir\").unwrap()\n         };\n         let tmp = task::try(f).expect(\"test_rm_tmdir\");"}, {"sha": "ada3607beaef577d5766b8488b4003355fc04541", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -19,11 +19,11 @@ enum maybe_pointy {\n \n struct Pointy {\n     a : maybe_pointy,\n-    d : ~fn() -> uint,\n+    d : proc() -> uint,\n }\n \n-fn make_uniq_closure<A:Send>(a: A) -> ~fn() -> uint {\n-    let result: ~fn() -> uint = || ptr::to_unsafe_ptr(&a) as uint;\n+fn make_uniq_closure<A:Send>(a: A) -> proc() -> uint {\n+    let result: proc() -> uint = || ptr::to_unsafe_ptr(&a) as uint;\n     result\n }\n "}, {"sha": "fc58374d46d6128cdb2e7ef47bacbac780c5f1ef", "filename": "src/test/run-pass/uniq-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c22f75d46e94985d2fe45c896bde65e991b13d/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc.rs?ref=f4c22f75d46e94985d2fe45c896bde65e991b13d", "patch": "@@ -18,7 +18,7 @@ enum maybe_pointy {\n struct Pointy {\n     a : maybe_pointy,\n     c : ~int,\n-    d : ~fn()->(),\n+    d : proc()->(),\n }\n \n fn empty_pointy() -> @mut Pointy {"}]}