{"sha": "540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MGZkM2FhNzE1YzhhZjdlZmI0YjA2YjdmOWFiNmRhMzk4ZGViNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-27T17:11:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-27T17:11:13Z"}, "message": "Auto merge of #26848 - oli-obk:const_fn_const_eval, r=pnkfelix\n\nthis has the funky side-effect of also allowing constant evaluation of function calls to functions that are not `const fn` as long as `check_const` didn't mark that function `NOT_CONST`\r\n\r\nIt's still not possible to call a normal function from a `const fn`, but let statements' initialization value can get const evaluated (this caused the fallout in the overflowing tests)\r\n\r\nwe can now do this:\r\n\r\n```rust\r\nconst fn add(x: usize, y: usize) -> usize { x + y }\r\nconst ARR: [i32; add(1, 2)] = [5, 6, 7];\r\n```\r\n\r\nalso added a test for destructuring in const fn args\r\n```rust\r\nconst fn i((a, b): (u32, u32)) -> u32 { a + b } //~ ERROR: E0022\r\n```\r\n\r\nThis is a **[breaking change]**, since it turns some runtime panics into compile-time errors. This statement is true for ANY improvement to the const evaluator.", "tree": {"sha": "0feb30ef01a22ace949e54c28244c4ed326a2f1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0feb30ef01a22ace949e54c28244c4ed326a2f1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "html_url": "https://github.com/rust-lang/rust/commit/540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "679b5a9faaed845bf4a4bd8fe27a2a98df78b7ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/679b5a9faaed845bf4a4bd8fe27a2a98df78b7ad", "html_url": "https://github.com/rust-lang/rust/commit/679b5a9faaed845bf4a4bd8fe27a2a98df78b7ad"}, {"sha": "2b000feba57a324534008356909e02394784cfcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b000feba57a324534008356909e02394784cfcc", "html_url": "https://github.com/rust-lang/rust/commit/2b000feba57a324534008356909e02394784cfcc"}], "stats": {"total": 216, "additions": 163, "deletions": 53}, "files": [{"sha": "263c9bd15774d7a91ab63876838ffe5b56b74a9f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     ty::TyUint(_) | ty::TyInt(_) if div_or_rem => {\n                         if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n                             match const_eval::eval_const_expr_partial(\n-                                    self.tcx, ex, ExprTypeChecked) {\n+                                    self.tcx, ex, ExprTypeChecked, None) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n                                     self.tcx.sess.add_lint(::lint::builtin::CONST_ERR, ex.id,"}, {"sha": "f8786c7daaa80adf5fd9d7837d3f17de9b2376f1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -272,7 +272,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     front_util::walk_pat(pat, |p| {\n         if let hir::PatLit(ref expr) = p.node {\n-            match eval_const_expr_partial(cx.tcx, &**expr, ExprTypeChecked) {\n+            match eval_const_expr_partial(cx.tcx, &**expr, ExprTypeChecked, None) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n                                \"unmatchable NaN in pattern, \\"}, {"sha": "1651e71c49a2aec1449b91a8de689298d6baf727", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 95, "deletions": 18, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -19,13 +19,14 @@ use front::map::blocks::FnLikeNode;\n use metadata::csearch;\n use metadata::inline::InlinedItem;\n use middle::{astencode, def, infer, subst, traits};\n-use middle::def_id::{DefId};\n+use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n+use util::nodemap::NodeMap;\n \n-use syntax::ast;\n+use syntax::{ast, abi};\n use rustc_front::hir::Expr;\n use rustc_front::hir;\n use rustc_front::visit::FnKind;\n@@ -253,14 +254,14 @@ pub enum ConstVal {\n     Bool(bool),\n     Struct(ast::NodeId),\n     Tuple(ast::NodeId),\n+    Function(DefId),\n }\n \n /// Note that equality for `ConstVal` means that the it is the same\n /// constant, not that the rust values are equal. In particular, `NaN\n /// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n /// are considering unequal).\n impl PartialEq for ConstVal {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq(&self, other: &ConstVal) -> bool {\n         match (self, other) {\n             (&Float(a), &Float(b)) => unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)},\n@@ -271,6 +272,7 @@ impl PartialEq for ConstVal {\n             (&Bool(a), &Bool(b)) => a == b,\n             (&Struct(a), &Struct(b)) => a == b,\n             (&Tuple(a), &Tuple(b)) => a == b,\n+            (&Function(a), &Function(b)) => a == b,\n             _ => false,\n         }\n     }\n@@ -288,6 +290,7 @@ impl ConstVal {\n             Bool(_) => \"boolean\",\n             Struct(_) => \"struct\",\n             Tuple(_) => \"tuple\",\n+            Function(_) => \"function definition\",\n         }\n     }\n }\n@@ -350,12 +353,13 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> ConstVal {\n-    match eval_const_expr_partial(tcx, e, ExprTypeChecked) {\n+    match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(s.span, &s.description())\n     }\n }\n \n+pub type FnArgMap<'a> = Option<&'a NodeMap<ConstVal>>;\n \n #[derive(Clone)]\n pub struct ConstEvalErr {\n@@ -739,7 +743,8 @@ pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n /// computing the length of an array. (See also the FIXME above EvalHint.)\n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n-                                     ty_hint: EvalHint<'tcx>) -> EvalResult {\n+                                     ty_hint: EvalHint<'tcx>,\n+                                     fn_args: FnArgMap) -> EvalResult {\n     fn fromb(b: bool) -> ConstVal { Int(b as i64) }\n \n     // Try to compute the type of the expression based on the EvalHint.\n@@ -776,7 +781,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint)) {\n+        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint, fn_args)) {\n           Float(f) => Float(-f),\n           Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n           Uint(i) => {\n@@ -786,7 +791,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint)) {\n+        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint, fn_args)) {\n           Int(i) => Int(!i),\n           Uint(i) => const_uint_not(i, expr_uint_type),\n           Bool(b) => Bool(!b),\n@@ -804,8 +809,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n             _ => ty_hint\n         };\n-        match (try!(eval_const_expr_partial(tcx, &**a, ty_hint)),\n-               try!(eval_const_expr_partial(tcx, &**b, b_ty))) {\n+        match (try!(eval_const_expr_partial(tcx, &**a, ty_hint, fn_args)),\n+               try!(eval_const_expr_partial(tcx, &**b, b_ty, fn_args))) {\n           (Float(a), Float(b)) => {\n             match op.node {\n               hir::BiAdd => Float(a + b),\n@@ -912,7 +917,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         };\n \n-        let val = try!(eval_const_expr_partial(tcx, &**base, base_hint));\n+        let val = try!(eval_const_expr_partial(tcx, &**base, base_hint, fn_args));\n         match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n@@ -990,6 +995,16 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               Some(def::DefStruct(_)) => {\n                   return Ok(ConstVal::Struct(e.id))\n               }\n+              Some(def::DefLocal(_, id)) => {\n+                  debug!(\"DefLocal({:?}): {:?}\", id, fn_args);\n+                  if let Some(val) = fn_args.and_then(|args| args.get(&id)) {\n+                      return Ok(val.clone());\n+                  } else {\n+                      (None, None)\n+                  }\n+              },\n+              Some(def::DefFn(id, _)) => return Ok(Function(id)),\n+              // FIXME: implement const methods?\n               _ => (None, None)\n           };\n           let const_expr = match const_expr {\n@@ -1007,14 +1022,76 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           } else {\n               ty_hint\n           };\n-          try!(eval_const_expr_partial(tcx, const_expr, item_hint))\n+          try!(eval_const_expr_partial(tcx, const_expr, item_hint, fn_args))\n       }\n+      hir::ExprCall(ref callee, ref args) => {\n+          let sub_ty_hint = if let ExprTypeChecked = ty_hint {\n+              ExprTypeChecked\n+          } else {\n+              UncheckedExprNoHint // we cannot reason about UncheckedExprHint here\n+          };\n+          let (\n+              decl,\n+              unsafety,\n+              abi,\n+              block,\n+              constness,\n+          ) = match try!(eval_const_expr_partial(tcx, callee, sub_ty_hint, fn_args)) {\n+              Function(did) => if did.is_local() {\n+                  match tcx.map.find(did.index.as_u32()) {\n+                      Some(ast_map::NodeItem(it)) => match it.node {\n+                          hir::ItemFn(\n+                              ref decl,\n+                              unsafety,\n+                              constness,\n+                              abi,\n+                              _, // ducktype generics? types are funky in const_eval\n+                              ref block,\n+                          ) => (decl, unsafety, abi, block, constness),\n+                          _ => signal!(e, NonConstPath),\n+                      },\n+                      _ => signal!(e, NonConstPath),\n+                  }\n+              } else {\n+                  signal!(e, NonConstPath)\n+              },\n+              _ => signal!(e, NonConstPath),\n+          };\n+          if let ExprTypeChecked = ty_hint {\n+              // no need to check for constness... either check_const\n+              // already forbids this or we const eval over whatever\n+              // we want\n+          } else {\n+              // we don't know much about the function, so we force it to be a const fn\n+              // so compilation will fail later in case the const fn's body is not const\n+              assert_eq!(constness, hir::Constness::Const)\n+          }\n+          assert_eq!(decl.inputs.len(), args.len());\n+          assert_eq!(unsafety, hir::Unsafety::Normal);\n+          assert_eq!(abi, abi::Abi::Rust);\n+\n+          let mut call_args = NodeMap();\n+          for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n+              let arg_val = try!(eval_const_expr_partial(\n+                  tcx,\n+                  arg_expr,\n+                  sub_ty_hint,\n+                  fn_args\n+              ));\n+              debug!(\"const call arg: {:?}\", arg);\n+              let old = call_args.insert(arg.pat.id, arg_val);\n+              assert!(old.is_none());\n+          }\n+          let result = block.expr.as_ref().unwrap();\n+          debug!(\"const call({:?})\", call_args);\n+          try!(eval_const_expr_partial(tcx, &**result, ty_hint, Some(&call_args)))\n+      },\n       hir::ExprLit(ref lit) => {\n           lit_to_const(&**lit, ety)\n       }\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint)),\n+            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint, fn_args)),\n             None => Int(0)\n         }\n       }\n@@ -1026,11 +1103,11 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         } else {\n             UncheckedExprNoHint\n         };\n-        if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint) {\n+        if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint, fn_args) {\n             if let Tuple(tup_id) = c {\n                 if let hir::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                     if index.node < fields.len() {\n-                        return eval_const_expr_partial(tcx, &fields[index.node], base_hint)\n+                        return eval_const_expr_partial(tcx, &fields[index.node], base_hint, fn_args)\n                     } else {\n                         signal!(e, TupleIndexOutOfBounds);\n                     }\n@@ -1051,14 +1128,14 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         } else {\n             UncheckedExprNoHint\n         };\n-        if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint) {\n+        if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint, fn_args) {\n             if let Struct(struct_id) = c {\n                 if let hir::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                     // Check that the given field exists and evaluate it\n                     // if the idents are compared run-pass/issue-19244 fails\n                     if let Some(f) = fields.iter().find(|f| f.name.node\n                                                          == field_name.node) {\n-                        return eval_const_expr_partial(tcx, &*f.expr, base_hint)\n+                        return eval_const_expr_partial(tcx, &*f.expr, base_hint, fn_args)\n                     } else {\n                         signal!(e, MissingStructField);\n                     }\n@@ -1237,14 +1314,14 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                a: &Expr,\n                                b: &Expr) -> Option<Ordering> {\n-    let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked) {\n+    let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n         Ok(a) => a,\n         Err(e) => {\n             tcx.sess.span_err(a.span, &e.description());\n             return None;\n         }\n     };\n-    let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked) {\n+    let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked, None) {\n         Ok(b) => b,\n         Err(e) => {\n             tcx.sess.span_err(b.span, &e.description());"}, {"sha": "2142755d4a59e87e6b3796f3eb6d607b56cad9f3", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -335,7 +335,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n     /// Returns the repeat count for a repeating vector expression.\n     pub fn eval_repeat_count(&self, count_expr: &hir::Expr) -> usize {\n         let hint = UncheckedExprHint(self.types.usize);\n-        match const_eval::eval_const_expr_partial(self, count_expr, hint) {\n+        match const_eval::eval_const_expr_partial(self, count_expr, hint, None) {\n             Ok(val) => {\n                 let found = match val {\n                     ConstVal::Uint(count) => return count as usize,"}, {"sha": "264228a7052a65af9fe34baae87f69fb712853a9", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -120,7 +120,7 @@ impl LateLintPass for TypeLimits {\n                             if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked) {\n+                            match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked, None) {\n                                 Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n                                 Ok(ConstVal::Uint(shift)) => { shift >= bits },\n                                 _ => { false }\n@@ -674,4 +674,3 @@ impl LateLintPass for ImproperCTypes {\n         }\n     }\n }\n-"}, {"sha": "e69f563edbac34e5d8b3f39243869ec19b057cc5", "filename": "src/librustc_mir/tcx/pattern.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -166,7 +166,8 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n                                 let opt_value =\n                                     const_eval::eval_const_expr_partial(\n                                         cx.tcx, const_expr,\n-                                        const_eval::EvalHint::ExprTypeChecked);\n+                                        const_eval::EvalHint::ExprTypeChecked,\n+                                        None);\n                                 let literal = if let Ok(value) = opt_value {\n                                     Literal::Value { value: value }\n                                 } else {"}, {"sha": "90faef51c2c6c6a3444d2afd3ae3dbf173ef4cb8", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -664,10 +664,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             adt::const_get_field(cx, &*brepr, bv, vinfo.discr, idx.node)\n         },\n-\n         hir::ExprIndex(ref base, ref index) => {\n             let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n-            let iv = match eval_const_expr_partial(cx.tcx(), &index, ExprTypeChecked) {\n+            let iv = match eval_const_expr_partial(cx.tcx(), &index, ExprTypeChecked, None) {\n                 Ok(ConstVal::Int(i)) => i as u64,\n                 Ok(ConstVal::Uint(u)) => u,\n                 _ => cx.sess().span_bug(index.span,"}, {"sha": "34378445c60877e54a13c160b872ff8ecf733ca2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -1673,7 +1673,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         hir::TyFixedLengthVec(ref ty, ref e) => {\n             let hint = UncheckedExprHint(tcx.types.usize);\n-            match const_eval::eval_const_expr_partial(tcx, &e, hint) {\n+            match const_eval::eval_const_expr_partial(tcx, &e, hint, None) {\n                 Ok(r) => {\n                     match r {\n                         ConstVal::Int(i) =>"}, {"sha": "2b46dbeecb841b9163c897366b0899237f02c1b3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -1148,7 +1148,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n         debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n \n         let hint = UncheckedExprHint(repr_ty);\n-        match const_eval::eval_const_expr_partial(tcx, e, hint) {\n+        match const_eval::eval_const_expr_partial(tcx, e, hint, None) {\n             Ok(ConstVal::Int(val)) => Some(val as ty::Disr),\n             Ok(ConstVal::Uint(val)) => Some(val as ty::Disr),\n             Ok(_) => {"}, {"sha": "3e75afcda6d71823f45538b7f9b921f7b4bdefc6", "filename": "src/test/compile-fail/const-eval-span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -14,7 +14,7 @@\n struct S(i32);\n \n const CONSTANT: S = S(0);\n-//~^ ERROR: constant evaluation error: unsupported constant expr\n+//~^ ERROR: constant evaluation error: non-constant path in constant expression [E0080]\n \n enum E {\n     V = CONSTANT,"}, {"sha": "1642c0410672333a5a3182643b81e6e2ca9cf5da", "filename": "src/test/compile-fail/const-fn-destructuring-arg.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fcompile-fail%2Fconst-fn-destructuring-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fcompile-fail%2Fconst-fn-destructuring-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-destructuring-arg.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// test that certain things are disallowed in const fn signatures\n+\n+#![feature(const_fn)]\n+\n+// no destructuring\n+const fn i((a, b): (u32, u32)) -> u32 { a + b } //~ ERROR: E0022\n+\n+fn main() {}"}, {"sha": "59e0db7b35508c8ca8cd6375604a99b51d3b9f94", "filename": "src/test/compile-fail/const-fn-stability-calls-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability-calls-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability-calls-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability-calls-2.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -17,5 +17,5 @@ extern crate const_fn_lib;\n use const_fn_lib::foo;\n \n fn main() {\n-    let x: [usize; foo()] = []; //~ ERROR unsupported constant expr\n+    let x: [usize; foo()] = []; //~ ERROR non-constant path in constant expr\n }"}, {"sha": "77c70fe7f63545567d61ac6e49b0eee0054447bf", "filename": "src/test/run-pass/const-fn-const-eval.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Frun-pass%2Fconst-fn-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Frun-pass%2Fconst-fn-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn-const-eval.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+const fn add(x: usize, y: usize) -> usize {\n+    x + y\n+}\n+\n+const ARR: [i32; add(1, 2)] = [5, 6, 7];\n+\n+pub fn main() {}"}, {"sha": "542e8de9e53ca8effb75cf5c841e4acf012596fc", "filename": "src/test/run-pass/shift-near-oflo.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Frun-pass%2Fshift-near-oflo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Frun-pass%2Fshift-near-oflo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshift-near-oflo.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -13,9 +13,6 @@\n // Check that we do *not* overflow on a number of edge cases.\n // (compare with test/run-fail/overflowing-{lsh,rsh}*.rs)\n \n-// (Work around constant-evaluation)\n-fn id<T>(x: T) -> T { x }\n-\n fn main() {\n     test_left_shift();\n     test_right_shift();\n@@ -26,34 +23,34 @@ fn test_left_shift() {\n \n     macro_rules! tests {\n         ($iN:ty, $uN:ty, $max_rhs:expr, $expect_i:expr, $expect_u:expr) => { {\n-            let x = (1 as $iN) << id(0);\n+            let x = (1 as $iN) << 0;\n             assert_eq!(x, 1);\n-            let x = (1 as $uN) << id(0);\n+            let x = (1 as $uN) << 0;\n             assert_eq!(x, 1);\n-            let x = (1 as $iN) << id($max_rhs);\n+            let x = (1 as $iN) << $max_rhs;\n             assert_eq!(x, $expect_i);\n-            let x = (1 as $uN) << id($max_rhs);\n+            let x = (1 as $uN) << $max_rhs;\n             assert_eq!(x, $expect_u);\n             // high-order bits on LHS are silently discarded without panic.\n-            let x = (3 as $iN) << id($max_rhs);\n+            let x = (3 as $iN) << $max_rhs;\n             assert_eq!(x, $expect_i);\n-            let x = (3 as $uN) << id($max_rhs);\n+            let x = (3 as $uN) << $max_rhs;\n             assert_eq!(x, $expect_u);\n         } }\n     }\n \n-    let x = 1_i8 << id(0);\n+    let x = 1_i8 << 0;\n     assert_eq!(x, 1);\n-    let x = 1_u8 << id(0);\n+    let x = 1_u8 << 0;\n     assert_eq!(x, 1);\n-    let x = 1_i8 << id(7);\n+    let x = 1_i8 << 7;\n     assert_eq!(x, std::i8::MIN);\n-    let x = 1_u8 << id(7);\n+    let x = 1_u8 << 7;\n     assert_eq!(x, 0x80);\n     // high-order bits on LHS are silently discarded without panic.\n-    let x = 3_i8 << id(7);\n+    let x = 3_i8 << 7;\n     assert_eq!(x, std::i8::MIN);\n-    let x = 3_u8 << id(7);\n+    let x = 3_u8 << 7;\n     assert_eq!(x, 0x80);\n \n     // above is (approximately) expanded from:\n@@ -71,23 +68,23 @@ fn test_right_shift() {\n         ($iN:ty, $uN:ty, $max_rhs:expr,\n          $signbit_i:expr, $highbit_i:expr, $highbit_u:expr) =>\n         { {\n-            let x = (1 as $iN) >> id(0);\n+            let x = (1 as $iN) >> 0;\n             assert_eq!(x, 1);\n-            let x = (1 as $uN) >> id(0);\n+            let x = (1 as $uN) >> 0;\n             assert_eq!(x, 1);\n-            let x = ($highbit_i) >> id($max_rhs-1);\n+            let x = ($highbit_i) >> $max_rhs-1;\n             assert_eq!(x, 1);\n-            let x = ($highbit_u) >> id($max_rhs);\n+            let x = ($highbit_u) >> $max_rhs;\n             assert_eq!(x, 1);\n             // sign-bit is carried by arithmetic right shift\n-            let x = ($signbit_i) >> id($max_rhs);\n+            let x = ($signbit_i) >> $max_rhs;\n             assert_eq!(x, -1);\n             // low-order bits on LHS are silently discarded without panic.\n-            let x = ($highbit_i + 1) >> id($max_rhs-1);\n+            let x = ($highbit_i + 1) >> $max_rhs-1;\n             assert_eq!(x, 1);\n-            let x = ($highbit_u + 1) >> id($max_rhs);\n+            let x = ($highbit_u + 1) >> $max_rhs;\n             assert_eq!(x, 1);\n-            let x = ($signbit_i + 1) >> id($max_rhs);\n+            let x = ($signbit_i + 1) >> $max_rhs;\n             assert_eq!(x, -1);\n         } }\n     }"}]}