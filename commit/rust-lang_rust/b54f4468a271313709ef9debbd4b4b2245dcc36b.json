{"sha": "b54f4468a271313709ef9debbd4b4b2245dcc36b", "node_id": "C_kwDOAAsO6NoAKGI1NGY0NDY4YTI3MTMxMzcwOWVmOWRlYmJkNGI0YjIyNDVkY2MzNmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-12T23:56:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-12T23:56:31Z"}, "message": "Auto merge of #8799 - Alexendoo:lintcheck-common, r=giraffate\n\nSome lintcheck cleanup\n\nA grab bag of smaller changes:\n\nPanics if a crate source isn't valid, and fixes the `ryu` crate entry so it's picked up. Took me a while to realise why I couldn't do `cargo lintcheck --only ryu` \ud83d\ude05\n\nParses messages with `cargo_metadata`, this catches a few more lints that were ignored because the message had an [expansion field](https://docs.rs/cargo_metadata/latest/cargo_metadata/diagnostic/struct.DiagnosticSpanMacroExpansion.html) that contained a path pointing into `.../.toolchains/...`. It also no longer emits some log lines with `null` as the column\n\nIt also merges the `run_clippy_lint` invocations and splits `LintcheckConfig` out into its own file\n\nchangelog: none", "tree": {"sha": "9356054cb114ae7f4fca6dcda59e8a57a9124cc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9356054cb114ae7f4fca6dcda59e8a57a9124cc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b54f4468a271313709ef9debbd4b4b2245dcc36b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b54f4468a271313709ef9debbd4b4b2245dcc36b", "html_url": "https://github.com/rust-lang/rust/commit/b54f4468a271313709ef9debbd4b4b2245dcc36b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b54f4468a271313709ef9debbd4b4b2245dcc36b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3d1f288491c703172b2debc88379c6469e26c75", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d1f288491c703172b2debc88379c6469e26c75", "html_url": "https://github.com/rust-lang/rust/commit/a3d1f288491c703172b2debc88379c6469e26c75"}, {"sha": "8708a261a1e297323060a8c71789e482b2d3725f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8708a261a1e297323060a8c71789e482b2d3725f", "html_url": "https://github.com/rust-lang/rust/commit/8708a261a1e297323060a8c71789e482b2d3725f"}], "stats": {"total": 615, "additions": 263, "deletions": 352}, "files": [{"sha": "e63f65ce2f75dfd142652d15fe90683b149090a1", "filename": "lintcheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b54f4468a271313709ef9debbd4b4b2245dcc36b/lintcheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b54f4468a271313709ef9debbd4b4b2245dcc36b/lintcheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FCargo.toml?ref=b54f4468a271313709ef9debbd4b4b2245dcc36b", "patch": "@@ -6,16 +6,15 @@ readme = \"README.md\"\n license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n categories = [\"development-tools\"]\n-edition = \"2018\"\n+edition = \"2021\"\n publish = false\n \n [dependencies]\n+cargo_metadata = \"0.14\"\n clap = \"2.33\"\n flate2 = \"1.0\"\n-fs_extra = \"1.2\"\n rayon = \"1.5.1\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n-serde_json = \"1.0\"\n tar = \"0.4\"\n toml = \"0.5\"\n ureq = \"2.2\""}, {"sha": "4fbae8614ca3daa060945a2862d65432bba921d5", "filename": "lintcheck/lintcheck_crates.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b54f4468a271313709ef9debbd4b4b2245dcc36b/lintcheck%2Flintcheck_crates.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b54f4468a271313709ef9debbd4b4b2245dcc36b/lintcheck%2Flintcheck_crates.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Flintcheck_crates.toml?ref=b54f4468a271313709ef9debbd4b4b2245dcc36b", "patch": "@@ -24,7 +24,7 @@ unicode-xid = {name = \"unicode-xid\", versions = ['0.2.1']}\n anyhow = {name = \"anyhow\", versions = ['1.0.38']}\n async-trait = {name = \"async-trait\", versions = ['0.1.42']}\n cxx = {name = \"cxx\", versions = ['1.0.32']}\n-ryu = {name = \"ryu\", version = ['1.0.5']}\n+ryu = {name = \"ryu\", versions = ['1.0.5']}\n serde_yaml = {name = \"serde_yaml\", versions = ['0.8.17']}\n thiserror = {name = \"thiserror\", versions = ['1.0.24']}\n # some embark crates, there are other interesting crates but"}, {"sha": "de32b48436019c5a2d774c1181cc554dda24ba99", "filename": "lintcheck/src/config.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b54f4468a271313709ef9debbd4b4b2245dcc36b/lintcheck%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b54f4468a271313709ef9debbd4b4b2245dcc36b/lintcheck%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fconfig.rs?ref=b54f4468a271313709ef9debbd4b4b2245dcc36b", "patch": "@@ -0,0 +1,140 @@\n+use clap::{App, Arg, ArgMatches};\n+use std::env;\n+use std::path::PathBuf;\n+\n+fn get_clap_config<'a>() -> ArgMatches<'a> {\n+    App::new(\"lintcheck\")\n+        .about(\"run clippy on a set of crates and check output\")\n+        .arg(\n+            Arg::with_name(\"only\")\n+                .takes_value(true)\n+                .value_name(\"CRATE\")\n+                .long(\"only\")\n+                .help(\"Only process a single crate of the list\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"crates-toml\")\n+                .takes_value(true)\n+                .value_name(\"CRATES-SOURCES-TOML-PATH\")\n+                .long(\"crates-toml\")\n+                .help(\"Set the path for a crates.toml where lintcheck should read the sources from\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"threads\")\n+                .takes_value(true)\n+                .value_name(\"N\")\n+                .short(\"j\")\n+                .long(\"jobs\")\n+                .help(\"Number of threads to use, 0 automatic choice\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"fix\")\n+                .long(\"--fix\")\n+                .help(\"Runs cargo clippy --fix and checks if all suggestions apply\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"filter\")\n+                .long(\"--filter\")\n+                .takes_value(true)\n+                .multiple(true)\n+                .value_name(\"clippy_lint_name\")\n+                .help(\"Apply a filter to only collect specified lints, this also overrides `allow` attributes\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"markdown\")\n+                .long(\"--markdown\")\n+                .help(\"Change the reports table to use markdown links\"),\n+        )\n+        .get_matches()\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct LintcheckConfig {\n+    /// max number of jobs to spawn (default 1)\n+    pub max_jobs: usize,\n+    /// we read the sources to check from here\n+    pub sources_toml_path: PathBuf,\n+    /// we save the clippy lint results here\n+    pub lintcheck_results_path: PathBuf,\n+    /// Check only a specified package\n+    pub only: Option<String>,\n+    /// whether to just run --fix and not collect all the warnings\n+    pub fix: bool,\n+    /// A list of lints that this lintcheck run should focus on\n+    pub lint_filter: Vec<String>,\n+    /// Indicate if the output should support markdown syntax\n+    pub markdown: bool,\n+}\n+\n+impl LintcheckConfig {\n+    pub fn new() -> Self {\n+        let clap_config = get_clap_config();\n+\n+        // first, check if we got anything passed via the LINTCHECK_TOML env var,\n+        // if not, ask clap if we got any value for --crates-toml  <foo>\n+        // if not, use the default \"lintcheck/lintcheck_crates.toml\"\n+        let sources_toml = env::var(\"LINTCHECK_TOML\").unwrap_or_else(|_| {\n+            clap_config\n+                .value_of(\"crates-toml\")\n+                .clone()\n+                .unwrap_or(\"lintcheck/lintcheck_crates.toml\")\n+                .to_string()\n+        });\n+\n+        let markdown = clap_config.is_present(\"markdown\");\n+        let sources_toml_path = PathBuf::from(sources_toml);\n+\n+        // for the path where we save the lint results, get the filename without extension (so for\n+        // wasd.toml, use \"wasd\"...)\n+        let filename: PathBuf = sources_toml_path.file_stem().unwrap().into();\n+        let lintcheck_results_path = PathBuf::from(format!(\n+            \"lintcheck-logs/{}_logs.{}\",\n+            filename.display(),\n+            if markdown { \"md\" } else { \"txt\" }\n+        ));\n+\n+        // look at the --threads arg, if 0 is passed, ask rayon rayon how many threads it would spawn and\n+        // use half of that for the physical core count\n+        // by default use a single thread\n+        let max_jobs = match clap_config.value_of(\"threads\") {\n+            Some(threads) => {\n+                let threads: usize = threads\n+                    .parse()\n+                    .unwrap_or_else(|_| panic!(\"Failed to parse '{}' to a digit\", threads));\n+                if threads == 0 {\n+                    // automatic choice\n+                    // Rayon seems to return thread count so half that for core count\n+                    (rayon::current_num_threads() / 2) as usize\n+                } else {\n+                    threads\n+                }\n+            },\n+            // no -j passed, use a single thread\n+            None => 1,\n+        };\n+\n+        let lint_filter: Vec<String> = clap_config\n+            .values_of(\"filter\")\n+            .map(|iter| {\n+                iter.map(|lint_name| {\n+                    let mut filter = lint_name.replace('_', \"-\");\n+                    if !filter.starts_with(\"clippy::\") {\n+                        filter.insert_str(0, \"clippy::\");\n+                    }\n+                    filter\n+                })\n+                .collect()\n+            })\n+            .unwrap_or_default();\n+\n+        LintcheckConfig {\n+            max_jobs,\n+            sources_toml_path,\n+            lintcheck_results_path,\n+            only: clap_config.value_of(\"only\").map(String::from),\n+            fix: clap_config.is_present(\"fix\"),\n+            lint_filter,\n+            markdown,\n+        }\n+    }\n+}"}, {"sha": "dff9d27db0a6c45f54f7fcab3e090fc644e24c31", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 120, "deletions": 348, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/b54f4468a271313709ef9debbd4b4b2245dcc36b/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b54f4468a271313709ef9debbd4b4b2245dcc36b/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=b54f4468a271313709ef9debbd4b4b2245dcc36b", "patch": "@@ -7,23 +7,25 @@\n \n #![allow(clippy::collapsible_else_if)]\n \n-use std::ffi::OsStr;\n+mod config;\n+\n+use config::LintcheckConfig;\n+\n+use std::collections::HashMap;\n+use std::env;\n use std::fmt::Write as _;\n+use std::fs::write;\n+use std::io::ErrorKind;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::sync::atomic::{AtomicUsize, Ordering};\n-use std::{collections::HashMap, io::ErrorKind};\n-use std::{\n-    env,\n-    fs::write,\n-    path::{Path, PathBuf},\n-    thread,\n-    time::Duration,\n-};\n-\n-use clap::{App, Arg, ArgMatches};\n+use std::thread;\n+use std::time::Duration;\n+\n+use cargo_metadata::diagnostic::DiagnosticLevel;\n+use cargo_metadata::Message;\n use rayon::prelude::*;\n use serde::{Deserialize, Serialize};\n-use serde_json::Value;\n use walkdir::{DirEntry, WalkDir};\n \n #[cfg(not(windows))]\n@@ -93,37 +95,67 @@ struct Crate {\n #[derive(Debug)]\n struct ClippyWarning {\n     crate_name: String,\n-    crate_version: String,\n     file: String,\n-    line: String,\n-    column: String,\n-    linttype: String,\n+    line: usize,\n+    column: usize,\n+    lint_type: String,\n     message: String,\n     is_ice: bool,\n }\n \n #[allow(unused)]\n impl ClippyWarning {\n+    fn new(cargo_message: Message, krate: &Crate) -> Option<Self> {\n+        let diag = match cargo_message {\n+            Message::CompilerMessage(message) => message.message,\n+            _ => return None,\n+        };\n+\n+        let lint_type = diag.code?.code;\n+        if !(lint_type.contains(\"clippy\") || diag.message.contains(\"clippy\"))\n+            || diag.message.contains(\"could not read cargo metadata\")\n+        {\n+            return None;\n+        }\n+\n+        let span = diag.spans.into_iter().find(|span| span.is_primary)?;\n+\n+        let file = match Path::new(&span.file_name).strip_prefix(env!(\"CARGO_HOME\")) {\n+            Ok(stripped) => format!(\"$CARGO_HOME/{}\", stripped.display()),\n+            Err(_) => format!(\n+                \"target/lintcheck/sources/{}-{}/{}\",\n+                krate.name, krate.version, span.file_name\n+            ),\n+        };\n+\n+        Some(Self {\n+            crate_name: krate.name.clone(),\n+            file,\n+            line: span.line_start,\n+            column: span.column_start,\n+            lint_type,\n+            message: diag.message,\n+            is_ice: diag.level == DiagnosticLevel::Ice,\n+        })\n+    }\n+\n     fn to_output(&self, markdown: bool) -> String {\n-        let file = format!(\"{}-{}/{}\", &self.crate_name, &self.crate_version, &self.file);\n-        let file_with_pos = format!(\"{}:{}:{}\", &file, &self.line, &self.column);\n+        let file_with_pos = format!(\"{}:{}:{}\", &self.file, &self.line, &self.column);\n         if markdown {\n-            let lint = format!(\"`{}`\", self.linttype);\n+            let lint = format!(\"`{}`\", self.lint_type);\n+\n+            let mut file = self.file.clone();\n+            if !file.starts_with('$') {\n+                file.insert_str(0, \"../\");\n+            }\n \n             let mut output = String::from(\"| \");\n-            let _ = write!(\n-                output,\n-                \"[`{}`](../target/lintcheck/sources/{}#L{})\",\n-                file_with_pos, file, self.line\n-            );\n+            let _ = write!(output, \"[`{}`]({}#L{})\", file_with_pos, file, self.line);\n             let _ = write!(output, r#\" | {:<50} | \"{}\" |\"#, lint, self.message);\n             output.push('\\n');\n             output\n         } else {\n-            format!(\n-                \"target/lintcheck/sources/{} {} \\\"{}\\\"\\n\",\n-                file_with_pos, self.linttype, self.message\n-            )\n+            format!(\"{} {} \\\"{}\\\"\\n\", file_with_pos, self.lint_type, self.message)\n         }\n     }\n }\n@@ -278,18 +310,17 @@ impl Crate {\n         &self,\n         cargo_clippy_path: &Path,\n         target_dir_index: &AtomicUsize,\n-        thread_limit: usize,\n         total_crates_to_lint: usize,\n-        fix: bool,\n+        config: &LintcheckConfig,\n         lint_filter: &Vec<String>,\n     ) -> Vec<ClippyWarning> {\n         // advance the atomic index by one\n         let index = target_dir_index.fetch_add(1, Ordering::SeqCst);\n         // \"loop\" the index within 0..thread_limit\n-        let thread_index = index % thread_limit;\n+        let thread_index = index % config.max_jobs;\n         let perc = (index * 100) / total_crates_to_lint;\n \n-        if thread_limit == 1 {\n+        if config.max_jobs == 1 {\n             println!(\n                 \"{}/{} {}% Linting {} {}\",\n                 index, total_crates_to_lint, perc, &self.name, &self.version\n@@ -305,7 +336,7 @@ impl Crate {\n \n         let shared_target_dir = clippy_project_root().join(\"target/lintcheck/shared_target_dir\");\n \n-        let mut args = if fix {\n+        let mut args = if config.fix {\n             vec![\"--fix\", \"--\"]\n         } else {\n             vec![\"--\", \"--message-format=json\", \"--\"]\n@@ -356,7 +387,7 @@ impl Crate {\n             );\n         }\n \n-        if fix {\n+        if config.fix {\n             if let Some(stderr) = stderr\n                 .lines()\n                 .find(|line| line.contains(\"failed to automatically apply fixes suggested by rustc to crate\"))\n@@ -371,127 +402,15 @@ impl Crate {\n             return Vec::new();\n         }\n \n-        let output_lines = stdout.lines();\n-        let warnings: Vec<ClippyWarning> = output_lines\n-            .into_iter()\n-            // get all clippy warnings and ICEs\n-            .filter(|line| filter_clippy_warnings(&line))\n-            .map(|json_msg| parse_json_message(json_msg, &self))\n+        // get all clippy warnings and ICEs\n+        let warnings: Vec<ClippyWarning> = Message::parse_stream(stdout.as_bytes())\n+            .filter_map(|msg| ClippyWarning::new(msg.unwrap(), &self))\n             .collect();\n \n         warnings\n     }\n }\n \n-#[derive(Debug)]\n-struct LintcheckConfig {\n-    /// max number of jobs to spawn (default 1)\n-    max_jobs: usize,\n-    /// we read the sources to check from here\n-    sources_toml_path: PathBuf,\n-    /// we save the clippy lint results here\n-    lintcheck_results_path: PathBuf,\n-    /// whether to just run --fix and not collect all the warnings\n-    fix: bool,\n-    /// A list of lints that this lintcheck run should focus on\n-    lint_filter: Vec<String>,\n-    /// Indicate if the output should support markdown syntax\n-    markdown: bool,\n-}\n-\n-impl LintcheckConfig {\n-    fn from_clap(clap_config: &ArgMatches) -> Self {\n-        // first, check if we got anything passed via the LINTCHECK_TOML env var,\n-        // if not, ask clap if we got any value for --crates-toml  <foo>\n-        // if not, use the default \"lintcheck/lintcheck_crates.toml\"\n-        let sources_toml = env::var(\"LINTCHECK_TOML\").unwrap_or_else(|_| {\n-            clap_config\n-                .value_of(\"crates-toml\")\n-                .clone()\n-                .unwrap_or(\"lintcheck/lintcheck_crates.toml\")\n-                .to_string()\n-        });\n-\n-        let markdown = clap_config.is_present(\"markdown\");\n-        let sources_toml_path = PathBuf::from(sources_toml);\n-\n-        // for the path where we save the lint results, get the filename without extension (so for\n-        // wasd.toml, use \"wasd\"...)\n-        let filename: PathBuf = sources_toml_path.file_stem().unwrap().into();\n-        let lintcheck_results_path = PathBuf::from(format!(\n-            \"lintcheck-logs/{}_logs.{}\",\n-            filename.display(),\n-            if markdown { \"md\" } else { \"txt\" }\n-        ));\n-\n-        // look at the --threads arg, if 0 is passed, ask rayon rayon how many threads it would spawn and\n-        // use half of that for the physical core count\n-        // by default use a single thread\n-        let max_jobs = match clap_config.value_of(\"threads\") {\n-            Some(threads) => {\n-                let threads: usize = threads\n-                    .parse()\n-                    .unwrap_or_else(|_| panic!(\"Failed to parse '{}' to a digit\", threads));\n-                if threads == 0 {\n-                    // automatic choice\n-                    // Rayon seems to return thread count so half that for core count\n-                    (rayon::current_num_threads() / 2) as usize\n-                } else {\n-                    threads\n-                }\n-            },\n-            // no -j passed, use a single thread\n-            None => 1,\n-        };\n-        let fix: bool = clap_config.is_present(\"fix\");\n-        let lint_filter: Vec<String> = clap_config\n-            .values_of(\"filter\")\n-            .map(|iter| {\n-                iter.map(|lint_name| {\n-                    let mut filter = lint_name.replace('_', \"-\");\n-                    if !filter.starts_with(\"clippy::\") {\n-                        filter.insert_str(0, \"clippy::\");\n-                    }\n-                    filter\n-                })\n-                .collect()\n-            })\n-            .unwrap_or_default();\n-\n-        LintcheckConfig {\n-            max_jobs,\n-            sources_toml_path,\n-            lintcheck_results_path,\n-            fix,\n-            lint_filter,\n-            markdown,\n-        }\n-    }\n-}\n-\n-/// takes a single json-formatted clippy warnings and returns true (we are interested in that line)\n-/// or false (we aren't)\n-fn filter_clippy_warnings(line: &str) -> bool {\n-    // we want to collect ICEs because clippy might have crashed.\n-    // these are summarized later\n-    if line.contains(\"internal compiler error: \") {\n-        return true;\n-    }\n-    // in general, we want all clippy warnings\n-    // however due to some kind of bug, sometimes there are absolute paths\n-    // to libcore files inside the message\n-    // or we end up with cargo-metadata output (https://github.com/rust-lang/rust-clippy/issues/6508)\n-\n-    // filter out these message to avoid unnecessary noise in the logs\n-    if line.contains(\"clippy::\")\n-        && !(line.contains(\"could not read cargo metadata\")\n-            || (line.contains(\".rustup\") && line.contains(\"toolchains\")))\n-    {\n-        return true;\n-    }\n-    false\n-}\n-\n /// Builds clippy inside the repo to make sure we have a clippy executable we can use.\n fn build_clippy() {\n     let status = Command::new(\"cargo\")\n@@ -527,27 +446,27 @@ fn read_crates(toml_path: &Path) -> Vec<CrateSource> {\n                 path: PathBuf::from(path),\n                 options: tk.options.clone(),\n             });\n-        }\n-\n-        // if we have multiple versions, save each one\n-        if let Some(ref versions) = tk.versions {\n+        } else if let Some(ref versions) = tk.versions {\n+            // if we have multiple versions, save each one\n             versions.iter().for_each(|ver| {\n                 crate_sources.push(CrateSource::CratesIo {\n                     name: tk.name.clone(),\n                     version: ver.to_string(),\n                     options: tk.options.clone(),\n                 });\n             })\n-        }\n-        // otherwise, we should have a git source\n-        if tk.git_url.is_some() && tk.git_hash.is_some() {\n+        } else if tk.git_url.is_some() && tk.git_hash.is_some() {\n+            // otherwise, we should have a git source\n             crate_sources.push(CrateSource::Git {\n                 name: tk.name.clone(),\n                 url: tk.git_url.clone().unwrap(),\n                 commit: tk.git_hash.clone().unwrap(),\n                 options: tk.options.clone(),\n             });\n+        } else {\n+            panic!(\"Invalid crate source: {tk:?}\");\n         }\n+\n         // if we have a version as well as a git data OR only one git data, something is funky\n         if tk.versions.is_some() && (tk.git_url.is_some() || tk.git_hash.is_some())\n             || tk.git_hash.is_some() != tk.git_url.is_some()\n@@ -568,57 +487,13 @@ fn read_crates(toml_path: &Path) -> Vec<CrateSource> {\n     crate_sources\n }\n \n-/// Parse the json output of clippy and return a `ClippyWarning`\n-fn parse_json_message(json_message: &str, krate: &Crate) -> ClippyWarning {\n-    let jmsg: Value = serde_json::from_str(&json_message).unwrap_or_else(|e| panic!(\"Failed to parse json:\\n{:?}\", e));\n-\n-    let file: String = jmsg[\"message\"][\"spans\"][0][\"file_name\"]\n-        .to_string()\n-        .trim_matches('\"')\n-        .into();\n-\n-    let file = if file.contains(\".cargo\") {\n-        // if we deal with macros, a filename may show the origin of a macro which can be inside a dep from\n-        // the registry.\n-        // don't show the full path in that case.\n-\n-        // /home/matthias/.cargo/registry/src/github.com-1ecc6299db9ec823/syn-1.0.63/src/custom_keyword.rs\n-        let path = PathBuf::from(file);\n-        let mut piter = path.iter();\n-        // consume all elements until we find \".cargo\", so that \"/home/matthias\" is skipped\n-        let _: Option<&OsStr> = piter.find(|x| x == &std::ffi::OsString::from(\".cargo\"));\n-        // collect the remaining segments\n-        let file = piter.collect::<PathBuf>();\n-        format!(\"{}\", file.display())\n-    } else {\n-        file\n-    };\n-\n-    ClippyWarning {\n-        crate_name: krate.name.to_string(),\n-        crate_version: krate.version.to_string(),\n-        file,\n-        line: jmsg[\"message\"][\"spans\"][0][\"line_start\"]\n-            .to_string()\n-            .trim_matches('\"')\n-            .into(),\n-        column: jmsg[\"message\"][\"spans\"][0][\"text\"][0][\"highlight_start\"]\n-            .to_string()\n-            .trim_matches('\"')\n-            .into(),\n-        linttype: jmsg[\"message\"][\"code\"][\"code\"].to_string().trim_matches('\"').into(),\n-        message: jmsg[\"message\"][\"message\"].to_string().trim_matches('\"').into(),\n-        is_ice: json_message.contains(\"internal compiler error: \"),\n-    }\n-}\n-\n /// Generate a short list of occurring lints-types and their count\n fn gather_stats(clippy_warnings: &[ClippyWarning]) -> (String, HashMap<&String, usize>) {\n     // count lint type occurrences\n     let mut counter: HashMap<&String, usize> = HashMap::new();\n     clippy_warnings\n         .iter()\n-        .for_each(|wrn| *counter.entry(&wrn.linttype).or_insert(0) += 1);\n+        .for_each(|wrn| *counter.entry(&wrn.lint_type).or_insert(0) += 1);\n \n     // collect into a tupled list for sorting\n     let mut stats: Vec<(&&String, &usize)> = counter.iter().map(|(lint, count)| (lint, count)).collect();\n@@ -667,22 +542,14 @@ fn lintcheck_needs_rerun(lintcheck_logs_path: &Path) -> bool {\n     logs_modified < clippy_modified\n }\n \n-/// lintchecks `main()` function\n-///\n-/// # Panics\n-///\n-/// This function panics if the clippy binaries don't exist\n-/// or if lintcheck is executed from the wrong directory (aka none-repo-root)\n-pub fn main() {\n+fn main() {\n     // assert that we launch lintcheck from the repo root (via cargo lintcheck)\n     if std::fs::metadata(\"lintcheck/Cargo.toml\").is_err() {\n         eprintln!(\"lintcheck needs to be run from clippys repo root!\\nUse `cargo lintcheck` alternatively.\");\n         std::process::exit(3);\n     }\n \n-    let clap_config = &get_clap_config();\n-\n-    let config = LintcheckConfig::from_clap(clap_config);\n+    let config = LintcheckConfig::new();\n \n     println!(\"Compiling clippy...\");\n     build_clippy();\n@@ -736,76 +603,46 @@ pub fn main() {\n         })\n         .collect();\n \n-    let clippy_warnings: Vec<ClippyWarning> = if let Some(only_one_crate) = clap_config.value_of(\"only\") {\n-        // if we don't have the specified crate in the .toml, throw an error\n-        if !crates.iter().any(|krate| {\n-            let name = match krate {\n-                CrateSource::CratesIo { name, .. } | CrateSource::Git { name, .. } | CrateSource::Path { name, .. } => {\n-                    name\n-                },\n-            };\n-            name == only_one_crate\n-        }) {\n-            eprintln!(\n-                \"ERROR: could not find crate '{}' in lintcheck/lintcheck_crates.toml\",\n-                only_one_crate\n-            );\n-            std::process::exit(1);\n-        }\n+    let crates: Vec<Crate> = crates\n+        .into_iter()\n+        .filter(|krate| {\n+            if let Some(only_one_crate) = &config.only {\n+                let name = match krate {\n+                    CrateSource::CratesIo { name, .. }\n+                    | CrateSource::Git { name, .. }\n+                    | CrateSource::Path { name, .. } => name,\n+                };\n \n-        // only check a single crate that was passed via cmdline\n-        crates\n-            .into_iter()\n-            .map(|krate| krate.download_and_extract())\n-            .filter(|krate| krate.name == only_one_crate)\n-            .flat_map(|krate| {\n-                krate.run_clippy_lints(&cargo_clippy_path, &AtomicUsize::new(0), 1, 1, config.fix, &lint_filter)\n-            })\n-            .collect()\n-    } else {\n-        if config.max_jobs > 1 {\n-            // run parallel with rayon\n-\n-            // Ask rayon for thread count. Assume that half of that is the number of physical cores\n-            // Use one target dir for each core so that we can run N clippys in parallel.\n-            // We need to use different target dirs because cargo would lock them for a single build otherwise,\n-            // killing the parallelism. However this also means that deps will only be reused half/a\n-            // quarter of the time which might result in a longer wall clock runtime\n-\n-            // This helps when we check many small crates with dep-trees that don't have a lot of branches in\n-            // order to achieve some kind of parallelism\n-\n-            // by default, use a single thread\n-            let num_cpus = config.max_jobs;\n-            let num_crates = crates.len();\n-\n-            // check all crates (default)\n-            crates\n-                .into_par_iter()\n-                .map(|krate| krate.download_and_extract())\n-                .flat_map(|krate| {\n-                    krate.run_clippy_lints(\n-                        &cargo_clippy_path,\n-                        &counter,\n-                        num_cpus,\n-                        num_crates,\n-                        config.fix,\n-                        &lint_filter,\n-                    )\n-                })\n-                .collect()\n-        } else {\n-            // run sequential\n-            let num_crates = crates.len();\n-            crates\n-                .into_iter()\n-                .map(|krate| krate.download_and_extract())\n-                .flat_map(|krate| {\n-                    krate.run_clippy_lints(&cargo_clippy_path, &counter, 1, num_crates, config.fix, &lint_filter)\n-                })\n-                .collect()\n-        }\n-    };\n+                name == only_one_crate\n+            } else {\n+                true\n+            }\n+        })\n+        .map(|krate| krate.download_and_extract())\n+        .collect();\n+\n+    if crates.is_empty() {\n+        eprintln!(\n+            \"ERROR: could not find crate '{}' in lintcheck/lintcheck_crates.toml\",\n+            config.only.unwrap(),\n+        );\n+        std::process::exit(1);\n+    }\n+\n+    // run parallel with rayon\n+\n+    // This helps when we check many small crates with dep-trees that don't have a lot of branches in\n+    // order to achieve some kind of parallelism\n+\n+    rayon::ThreadPoolBuilder::new()\n+        .num_threads(config.max_jobs)\n+        .build_global()\n+        .unwrap();\n+\n+    let clippy_warnings: Vec<ClippyWarning> = crates\n+        .par_iter()\n+        .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, crates.len(), &config, &lint_filter))\n+        .collect();\n \n     // if we are in --fix mode, don't change the log files, terminate here\n     if config.fix {\n@@ -837,7 +674,7 @@ pub fn main() {\n         text.push_str(\"| file | lint | message |\\n\");\n         text.push_str(\"| --- | --- | --- |\\n\");\n     }\n-    write!(text, \"{}\", all_msgs.join(\"\"));\n+    write!(text, \"{}\", all_msgs.join(\"\")).unwrap();\n     text.push_str(\"\\n\\n### ICEs:\\n\");\n     for (cratename, msg) in ices.iter() {\n         let _ = write!(text, \"{}: '{}'\", cratename, msg);\n@@ -949,75 +786,10 @@ fn create_dirs(krate_download_dir: &Path, extract_dir: &Path) {\n     });\n }\n \n-fn get_clap_config<'a>() -> ArgMatches<'a> {\n-    App::new(\"lintcheck\")\n-        .about(\"run clippy on a set of crates and check output\")\n-        .arg(\n-            Arg::with_name(\"only\")\n-                .takes_value(true)\n-                .value_name(\"CRATE\")\n-                .long(\"only\")\n-                .help(\"only process a single crate of the list\"),\n-        )\n-        .arg(\n-            Arg::with_name(\"crates-toml\")\n-                .takes_value(true)\n-                .value_name(\"CRATES-SOURCES-TOML-PATH\")\n-                .long(\"crates-toml\")\n-                .help(\"set the path for a crates.toml where lintcheck should read the sources from\"),\n-        )\n-        .arg(\n-            Arg::with_name(\"threads\")\n-                .takes_value(true)\n-                .value_name(\"N\")\n-                .short(\"j\")\n-                .long(\"jobs\")\n-                .help(\"number of threads to use, 0 automatic choice\"),\n-        )\n-        .arg(\n-            Arg::with_name(\"fix\")\n-                .long(\"--fix\")\n-                .help(\"runs cargo clippy --fix and checks if all suggestions apply\"),\n-        )\n-        .arg(\n-            Arg::with_name(\"filter\")\n-                .long(\"--filter\")\n-                .takes_value(true)\n-                .multiple(true)\n-                .value_name(\"clippy_lint_name\")\n-                .help(\"apply a filter to only collect specified lints, this also overrides `allow` attributes\"),\n-        )\n-        .arg(\n-            Arg::with_name(\"markdown\")\n-                .long(\"--markdown\")\n-                .help(\"change the reports table to use markdown links\"),\n-        )\n-        .get_matches()\n-}\n-\n /// Returns the path to the Clippy project directory\n-///\n-/// # Panics\n-///\n-/// Panics if the current directory could not be retrieved, there was an error reading any of the\n-/// Cargo.toml files or ancestor directory is the clippy root directory\n #[must_use]\n-pub fn clippy_project_root() -> PathBuf {\n-    let current_dir = std::env::current_dir().unwrap();\n-    for path in current_dir.ancestors() {\n-        let result = std::fs::read_to_string(path.join(\"Cargo.toml\"));\n-        if let Err(err) = &result {\n-            if err.kind() == std::io::ErrorKind::NotFound {\n-                continue;\n-            }\n-        }\n-\n-        let content = result.unwrap();\n-        if content.contains(\"[package]\\nname = \\\"clippy\\\"\") {\n-            return path.to_path_buf();\n-        }\n-    }\n-    panic!(\"error: Can't determine root of project. Please run inside a Clippy working dir.\");\n+fn clippy_project_root() -> &'static Path {\n+    Path::new(env!(\"CARGO_MANIFEST_DIR\")).parent().unwrap()\n }\n \n #[test]"}]}