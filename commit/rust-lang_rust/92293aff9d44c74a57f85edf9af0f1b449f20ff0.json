{"sha": "92293aff9d44c74a57f85edf9af0f1b449f20ff0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMjkzYWZmOWQ0NGM3NGE1N2Y4NWVkZjlhZjBmMWI0NDlmMjBmZjA=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-02-04T05:31:57Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-02-10T00:14:46Z"}, "message": "Add bitmask that supports up to 64 lanes. Simplify mask op API.", "tree": {"sha": "fe441803205ba20c5e06fea54e6084b90c8f014b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe441803205ba20c5e06fea54e6084b90c8f014b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92293aff9d44c74a57f85edf9af0f1b449f20ff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92293aff9d44c74a57f85edf9af0f1b449f20ff0", "html_url": "https://github.com/rust-lang/rust/commit/92293aff9d44c74a57f85edf9af0f1b449f20ff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92293aff9d44c74a57f85edf9af0f1b449f20ff0/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b0c23194829da3a75e641ff0424986cbeb5ff9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b0c23194829da3a75e641ff0424986cbeb5ff9e", "html_url": "https://github.com/rust-lang/rust/commit/1b0c23194829da3a75e641ff0424986cbeb5ff9e"}], "stats": {"total": 986, "additions": 645, "deletions": 341}, "files": [{"sha": "de9cb566022e2916d15e49654d0f752c60af4895", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92293aff9d44c74a57f85edf9af0f1b449f20ff0/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92293aff9d44c74a57f85edf9af0f1b449f20ff0/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=92293aff9d44c74a57f85edf9af0f1b449f20ff0", "patch": "@@ -1,12 +1,6 @@\n #![no_std]\n #![allow(incomplete_features)]\n-#![feature(\n-    repr_simd,\n-    platform_intrinsics,\n-    link_llvm_intrinsics,\n-    simd_ffi,\n-    const_generics\n-)]\n+#![feature(repr_simd, platform_intrinsics, simd_ffi, const_generics)]\n #![warn(missing_docs)]\n //! Portable SIMD module.\n "}, {"sha": "51ed8037043da993dc554891ab46edd2fba8dfe4", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/92293aff9d44c74a57f85edf9af0f1b449f20ff0/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92293aff9d44c74a57f85edf9af0f1b449f20ff0/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=92293aff9d44c74a57f85edf9af0f1b449f20ff0", "patch": "@@ -0,0 +1,220 @@\n+/// Implemented for bitmask sizes that are supported by the implementation.\n+pub trait LanesAtMost64 {}\n+impl LanesAtMost64 for BitMask<1> {}\n+impl LanesAtMost64 for BitMask<2> {}\n+impl LanesAtMost64 for BitMask<4> {}\n+impl LanesAtMost64 for BitMask<8> {}\n+impl LanesAtMost64 for BitMask<16> {}\n+impl LanesAtMost64 for BitMask<32> {}\n+impl LanesAtMost64 for BitMask<64> {}\n+\n+/// A mask where each lane is represented by a single bit.\n+#[derive(Copy, Clone, Debug)]\n+#[repr(transparent)]\n+pub struct BitMask<const LANES: usize>(u64)\n+where\n+    BitMask<LANES>: LanesAtMost64;\n+\n+impl<const LANES: usize> BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    /// Construct a mask by setting all lanes to the given value.\n+    pub fn splat(value: bool) -> Self {\n+        if value {\n+            Self(u64::MAX)\n+        } else {\n+            Self(u64::MIN)\n+        }\n+    }\n+\n+    /// Tests the value of the specified lane.\n+    ///\n+    /// # Panics\n+    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+    #[inline]\n+    pub fn test(&self, lane: usize) -> bool {\n+        assert!(lane < LANES, \"lane index out of range\");\n+        (self.0 >> lane) & 0x1 > 0\n+    }\n+\n+    /// Sets the value of the specified lane.\n+    ///\n+    /// # Panics\n+    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+    #[inline]\n+    pub fn set(&mut self, lane: usize, value: bool) {\n+        assert!(lane < LANES, \"lane index out of range\");\n+        self.0 ^= ((value ^ self.test(lane)) as u64) << lane\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: Self) -> Self {\n+        Self(self.0 & rhs.0)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAnd<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: bool) -> Self {\n+        self & Self::splat(rhs)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAnd<BitMask<LANES>> for bool\n+where\n+    BitMask<LANES>: LanesAtMost64,\n+{\n+    type Output = BitMask<LANES>;\n+    #[inline]\n+    fn bitand(self, rhs: BitMask<LANES>) -> BitMask<LANES> {\n+        BitMask::<LANES>::splat(self) & rhs\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: Self) -> Self {\n+        Self(self.0 | rhs.0)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOr<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: bool) -> Self {\n+        self | Self::splat(rhs)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOr<BitMask<LANES>> for bool\n+where\n+    BitMask<LANES>: LanesAtMost64,\n+{\n+    type Output = BitMask<LANES>;\n+    #[inline]\n+    fn bitor(self, rhs: BitMask<LANES>) -> BitMask<LANES> {\n+        BitMask::<LANES>::splat(self) | rhs\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: Self) -> Self::Output {\n+        Self(self.0 ^ rhs.0)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXor<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: bool) -> Self::Output {\n+        self ^ Self::splat(rhs)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXor<BitMask<LANES>> for bool\n+where\n+    BitMask<LANES>: LanesAtMost64,\n+{\n+    type Output = BitMask<LANES>;\n+    #[inline]\n+    fn bitxor(self, rhs: BitMask<LANES>) -> Self::Output {\n+        BitMask::<LANES>::splat(self) ^ rhs\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = BitMask<LANES>;\n+    #[inline]\n+    fn not(self) -> Self::Output {\n+        Self(!self.0)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAndAssign for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitand_assign(&mut self, rhs: Self) {\n+        self.0 &= rhs.0;\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAndAssign<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitand_assign(&mut self, rhs: bool) {\n+        *self &= Self::splat(rhs);\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOrAssign for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        self.0 |= rhs.0;\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOrAssign<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitor_assign(&mut self, rhs: bool) {\n+        *self |= Self::splat(rhs);\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXorAssign for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: Self) {\n+        self.0 ^= rhs.0;\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXorAssign<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: bool) {\n+        *self ^= Self::splat(rhs);\n+    }\n+}"}, {"sha": "d7c4af47727caa92b0c5faed174b5105687e3536", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/92293aff9d44c74a57f85edf9af0f1b449f20ff0/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92293aff9d44c74a57f85edf9af0f1b449f20ff0/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=92293aff9d44c74a57f85edf9af0f1b449f20ff0", "patch": "@@ -0,0 +1,301 @@\n+//! Masks that take up full SIMD vector registers.\n+\n+/// The error type returned when converting an integer to a mask fails.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct TryFromMaskError(());\n+\n+impl core::fmt::Display for TryFromMaskError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(\n+            f,\n+            \"mask vector must have all bits set or unset in each lane\"\n+        )\n+    }\n+}\n+\n+macro_rules! define_mask {\n+    { $(#[$attr:meta])* struct $name:ident<const $lanes:ident: usize>($type:ty); } => {\n+        $(#[$attr])*\n+        #[derive(Copy, Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n+        #[repr(transparent)]\n+        pub struct $name<const $lanes: usize>($type);\n+\n+        impl<const $lanes: usize> $name<$lanes> {\n+            /// Construct a mask by setting all lanes to the given value.\n+            pub fn splat(value: bool) -> Self {\n+                Self(<$type>::splat(\n+                    if value {\n+                        -1\n+                    } else {\n+                        0\n+                    }\n+                ))\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                assert!(lane < LANES, \"lane index out of range\");\n+                self.0[lane] == -1\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                assert!(lane < LANES, \"lane index out of range\");\n+                self.0[lane] = if value {\n+                    -1\n+                } else {\n+                    0\n+                }\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes> {\n+            fn from(value: bool) -> Self {\n+                Self::splat(value)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes> {\n+            type Error = TryFromMaskError;\n+            fn try_from(value: $type) -> Result<Self, Self::Error> {\n+                if value.as_slice().iter().all(|x| *x == 0 || *x == -1) {\n+                    Ok(Self(value))\n+                } else {\n+                    Err(TryFromMaskError(()))\n+                }\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type {\n+            fn from(value: $name<$lanes>) -> Self {\n+                value.0\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<crate::BitMask<$lanes>> for $name<$lanes>\n+        where\n+            crate::BitMask<$lanes>: crate::LanesAtMost64,\n+        {\n+            fn from(value: crate::BitMask<$lanes>) -> Self {\n+                // TODO use an intrinsic to do this efficiently (with LLVM's sext instruction)\n+                let mut mask = Self::splat(false);\n+                for lane in 0..LANES {\n+                    mask.set(lane, value.test(lane));\n+                }\n+                mask\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for crate::BitMask<$lanes>\n+        where\n+            crate::BitMask<$lanes>: crate::LanesAtMost64,\n+        {\n+            fn from(value: $name<$lanes>) -> Self {\n+                // TODO use an intrinsic to do this efficiently (with LLVM's trunc instruction)\n+                let mut mask = Self::splat(false);\n+                for lane in 0..LANES {\n+                    mask.set(lane, value.test(lane));\n+                }\n+                mask\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                f.debug_list()\n+                    .entries((0..LANES).map(|lane| self.test(lane)))\n+                    .finish()\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Binary for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Binary::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Octal for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Octal::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::LowerHex::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::UpperHex::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitand(self, rhs: Self) -> Self {\n+                Self(self.0 & rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitand(self, rhs: bool) -> Self {\n+                self & Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n+                $name::<LANES>::splat(self) & rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitor(self, rhs: Self) -> Self {\n+                Self(self.0 | rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitor(self, rhs: bool) -> Self {\n+                self | Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n+                $name::<LANES>::splat(self) | rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitxor(self, rhs: Self) -> Self::Output {\n+                Self(self.0 ^ rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitxor(self, rhs: bool) -> Self::Output {\n+                self ^ Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n+                $name::<LANES>::splat(self) ^ rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::Not for $name<LANES> {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn not(self) -> Self::Output {\n+                Self(!self.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES> {\n+            #[inline]\n+            fn bitand_assign(&mut self, rhs: Self) {\n+                self.0 &= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitand_assign(&mut self, rhs: bool) {\n+                *self &= Self::splat(rhs);\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES> {\n+            #[inline]\n+            fn bitor_assign(&mut self, rhs: Self) {\n+                self.0 |= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitor_assign(&mut self, rhs: bool) {\n+                *self |= Self::splat(rhs);\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES> {\n+            #[inline]\n+            fn bitxor_assign(&mut self, rhs: Self) {\n+                self.0 ^= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitxor_assign(&mut self, rhs: bool) {\n+                *self ^= Self::splat(rhs);\n+            }\n+        }\n+    }\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask8<const LANES: usize>(crate::SimdI8<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask16<const LANES: usize>(crate::SimdI16<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask32<const LANES: usize>(crate::SimdI32<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask64<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI128](crate::SimdI128), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask128<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMaskSize<const LANES: usize>(crate::SimdI64<LANES>);\n+}"}, {"sha": "eac5178512e52f894075ffed57011319e4599088", "filename": "crates/core_simd/src/masks/full_masks/mod.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c23194829da3a75e641ff0424986cbeb5ff9e/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c23194829da3a75e641ff0424986cbeb5ff9e/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs?ref=1b0c23194829da3a75e641ff0424986cbeb5ff9e", "patch": "@@ -1,205 +0,0 @@\n-//! Masks that take up full SIMD vector registers.\n-\n-/// The error type returned when converting an integer to a mask fails.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromMaskError(());\n-\n-impl core::fmt::Display for TryFromMaskError {\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        write!(f, \"mask vector must have all bits set or unset in each lane\")\n-    }\n-}\n-\n-macro_rules! define_mask {\n-    { $(#[$attr:meta])* struct $name:ident<const $lanes:ident: usize>($type:ty); } => {\n-        $(#[$attr])*\n-        #[derive(Copy, Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n-        #[repr(transparent)]\n-        pub struct $name<const $lanes: usize>($type);\n-\n-        delegate_ops_to_inner! { $name }\n-\n-        impl<const $lanes: usize> $name<$lanes> {\n-            /// Construct a mask by setting all lanes to the given value.\n-            pub fn splat(value: bool) -> Self {\n-                Self(<$type>::splat(\n-                    if value {\n-                        -1\n-                    } else {\n-                        0\n-                    }\n-                ))\n-            }\n-\n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                self.0[lane] == -1\n-            }\n-\n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                self.0[lane] = if value {\n-                    -1\n-                } else {\n-                    0\n-                }\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes> {\n-            fn from(value: bool) -> Self {\n-                Self::splat(value)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes> {\n-            type Error = TryFromMaskError;\n-            fn try_from(value: $type) -> Result<Self, Self::Error> {\n-                if value.as_slice().iter().all(|x| *x == 0 || *x == -1) {\n-                    Ok(Self(value))\n-                } else {\n-                    Err(TryFromMaskError(()))\n-                }\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type {\n-            fn from(value: $name<$lanes>) -> Self {\n-                value.0\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                f.debug_list()\n-                    .entries((0..LANES).map(|lane| self.test(lane)))\n-                    .finish()\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::Binary for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Binary::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::Octal for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Octal::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::LowerHex::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::UpperHex::fmt(&self.0, f)\n-            }\n-        }\n-    }\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI8Mask<const LANES: usize>(crate::SimdI8<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI16Mask<const LANES: usize>(crate::SimdI16<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI32Mask<const LANES: usize>(crate::SimdI32<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI64Mask<const LANES: usize>(crate::SimdI64<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI128](crate::SimdI128), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI128Mask<const LANES: usize>(crate::SimdI64<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdIsizeMask<const LANES: usize>(crate::SimdI64<LANES>);\n-}\n-\n-macro_rules! implement_mask_ext {\n-    { $($vector:ident => $mask:ident,)* } => {\n-        $(\n-            impl<const LANES: usize> crate::masks::MaskExt<$mask<LANES>> for crate::$vector<LANES> {\n-                #[inline]\n-                fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_eq(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_ne(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_lt(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_gt(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_le(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_ge(self, other) }\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-implement_mask_ext! {\n-    SimdI8 => SimdI8Mask,\n-    SimdI16 => SimdI16Mask,\n-    SimdI32 => SimdI32Mask,\n-    SimdI64 => SimdI64Mask,\n-    SimdI128 => SimdI128Mask,\n-    SimdIsize => SimdIsizeMask,\n-\n-    SimdU8 => SimdI8Mask,\n-    SimdU16 => SimdI16Mask,\n-    SimdU32 => SimdI32Mask,\n-    SimdU64 => SimdI64Mask,\n-    SimdU128 => SimdI128Mask,\n-    SimdUsize => SimdIsizeMask,\n-\n-    SimdF32 => SimdI32Mask,\n-    SimdF64 => SimdI64Mask,\n-}"}, {"sha": "61e1199095fbc266fe241bce8246a545d2320406", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 123, "deletions": 129, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/92293aff9d44c74a57f85edf9af0f1b449f20ff0/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92293aff9d44c74a57f85edf9af0f1b449f20ff0/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=92293aff9d44c74a57f85edf9af0f1b449f20ff0", "patch": "@@ -1,310 +1,304 @@\n //! Types and traits associated with masking lanes of vectors.\n #![allow(non_camel_case_types)]\n \n-/// Implements bitwise ops on mask types by delegating the operators to the inner type.\n-macro_rules! delegate_ops_to_inner {\n-    { $name:ident } => {\n-        impl<const LANES: usize> core::ops::BitAnd for $name<LANES> {\n+mod full_masks;\n+pub use full_masks::*;\n+\n+mod bitmask;\n+pub use bitmask::*;\n+\n+macro_rules! define_opaque_mask {\n+    {\n+        $(#[$attr:meta])*\n+        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n+    } => {\n+        $(#[$attr])*\n+        #[allow(non_camel_case_types)]\n+        pub struct $name<const $lanes: usize>($inner_ty) where BitMask<LANES>: LanesAtMost64;\n+\n+        impl<const $lanes: usize> $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            /// Construct a mask by setting all lanes to the given value.\n+            pub fn splat(value: bool) -> Self {\n+                Self(<$inner_ty>::splat(value))\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                self.0.test(lane)\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                self.0.set(lane, value);\n+            }\n+        }\n+\n+        impl<const $lanes: usize> From<BitMask<$lanes>> for $name<$lanes>\n+        where\n+            BitMask<$lanes>: LanesAtMost64,\n+        {\n+            fn from(value: BitMask<$lanes>) -> Self {\n+                Self(value.into())\n+            }\n+        }\n+\n+        impl<const $lanes: usize> From<$name<$lanes>> for crate::BitMask<$lanes>\n+        where\n+            BitMask<$lanes>: LanesAtMost64,\n+        {\n+            fn from(value: $name<$lanes>) -> Self {\n+                value.0.into()\n+            }\n+        }\n+\n+        impl<const $lanes: usize> Copy for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {}\n+\n+        impl<const $lanes: usize> Clone for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            #[inline]\n+            fn clone(&self) -> Self {\n+                *self\n+            }\n+        }\n+\n+        impl<const $lanes: usize> Default for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            #[inline]\n+            fn default() -> Self {\n+                Self::splat(false)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> PartialEq for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            #[inline]\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl<const $lanes: usize> PartialOrd for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            #[inline]\n+            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+                self.0.partial_cmp(&other.0)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Debug::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: Self) -> Self {\n                 Self(self.0 & rhs.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: bool) -> Self {\n                 self & Self::splat(rhs)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool {\n+        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool where BitMask<LANES>: LanesAtMost64 {\n             type Output = $name<LANES>;\n             #[inline]\n             fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n                 $name::<LANES>::splat(self) & rhs\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitOr for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: Self) -> Self {\n                 Self(self.0 | rhs.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: bool) -> Self {\n                 self | Self::splat(rhs)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool {\n+        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool where BitMask<LANES>: LanesAtMost64 {\n             type Output = $name<LANES>;\n             #[inline]\n             fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n                 $name::<LANES>::splat(self) | rhs\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitXor for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: Self) -> Self::Output {\n                 Self(self.0 ^ rhs.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: bool) -> Self::Output {\n                 self ^ Self::splat(rhs)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool {\n+        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool where BitMask<LANES>: LanesAtMost64 {\n             type Output = $name<LANES>;\n             #[inline]\n             fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n                 $name::<LANES>::splat(self) ^ rhs\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::Not for $name<LANES> {\n+        impl<const LANES: usize> core::ops::Not for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = $name<LANES>;\n             #[inline]\n             fn not(self) -> Self::Output {\n                 Self(!self.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n                 self.0 &= rhs.0;\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n                 *self &= Self::splat(rhs);\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n                 self.0 |= rhs.0;\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n                 *self |= Self::splat(rhs);\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n                 self.0 ^= rhs.0;\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n                 *self ^= Self::splat(rhs);\n             }\n         }\n-    }\n-}\n-\n-pub mod full_masks;\n-\n-macro_rules! define_opaque_mask {\n-    {\n-        $(#[$attr:meta])*\n-        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n-    } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        pub struct $name<const $lanes: usize>($inner_ty);\n-\n-        delegate_ops_to_inner! { $name }\n-\n-        impl<const $lanes: usize> $name<$lanes> {\n-            /// Construct a mask by setting all lanes to the given value.\n-            pub fn splat(value: bool) -> Self {\n-                Self(<$inner_ty>::splat(value))\n-            }\n-\n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                self.0.test(lane)\n-            }\n-\n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                self.0.set(lane, value);\n-            }\n-        }\n-\n-        impl<const $lanes: usize> Copy for $name<$lanes> {}\n-\n-        impl<const $lanes: usize> Clone for $name<$lanes> {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n-        impl<const $lanes: usize> Default for $name<$lanes> {\n-            #[inline]\n-            fn default() -> Self {\n-                Self::splat(false)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> PartialEq for $name<$lanes> {\n-            #[inline]\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl<const $lanes: usize> PartialOrd for $name<$lanes> {\n-            #[inline]\n-            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                self.0.partial_cmp(&other.0)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Debug::fmt(&self.0, f)\n-            }\n-        }\n     };\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 8-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask8<const LANES: usize>(full_masks::SimdI8Mask<LANES>);\n+    struct Mask8<const LANES: usize>(SimdMask8<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask16<const LANES: usize>(full_masks::SimdI16Mask<LANES>);\n+    struct Mask16<const LANES: usize>(SimdMask16<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask32<const LANES: usize>(full_masks::SimdI32Mask<LANES>);\n+    struct Mask32<const LANES: usize>(SimdMask32<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask64<const LANES: usize>(full_masks::SimdI64Mask<LANES>);\n+    struct Mask64<const LANES: usize>(SimdMask64<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 128-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask128<const LANES: usize>(full_masks::SimdI128Mask<LANES>);\n+    struct Mask128<const LANES: usize>(SimdMask128<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct MaskSize<const LANES: usize>(full_masks::SimdIsizeMask<LANES>);\n-}\n-\n-/// Mask-related operations using a particular mask layout.\n-pub trait MaskExt<Mask> {\n-    /// Test if each lane is equal to the corresponding lane in `other`.\n-    fn lanes_eq(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is not equal to the corresponding lane in `other`.\n-    fn lanes_ne(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is less than the corresponding lane in `other`.\n-    fn lanes_lt(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is greater than the corresponding lane in `other`.\n-    fn lanes_gt(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-    fn lanes_le(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-    fn lanes_ge(&self, other: &Self) -> Mask;\n+    struct MaskSize<const LANES: usize>(SimdMaskSize<LANES>);\n }\n \n macro_rules! implement_mask_ops {\n     { $($vector:ident => $mask:ident,)* } => {\n         $(\n-            impl<const LANES: usize> crate::$vector<LANES> {\n+            impl<const LANES: usize> crate::$vector<LANES> where BitMask<LANES>: LanesAtMost64 {\n                 /// Test if each lane is equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_eq(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_eq(self, other)) }\n                 }\n \n                 /// Test if each lane is not equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_ne(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_ne(self, other)) }\n                 }\n \n                 /// Test if each lane is less than the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_lt(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_lt(self, other)) }\n                 }\n \n                 /// Test if each lane is greater than the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_gt(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_gt(self, other)) }\n                 }\n \n                 /// Test if each lane is less than or equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_le(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_le(self, other)) }\n                 }\n \n                 /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_ge(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_ge(self, other)) }\n                 }\n             }\n         )*"}]}