{"sha": "1a43859a747a8916dbec98b8847a237e6caaf994", "node_id": "C_kwDOAAsO6NoAKDFhNDM4NTlhNzQ3YTg5MTZkYmVjOThiODg0N2EyMzdlNmNhYWY5OTQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-21T18:00:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-21T18:00:10Z"}, "message": "Rollup merge of #96391 - ChrisDenton:command-non-verbatim, r=joshtriplett\n\nWindows: make `Command` prefer non-verbatim paths\n\nWhen spawning Commands, the path we use can end up being queried using `env::current_exe` (or the equivalent in other languages). Not all applications handle these paths properly therefore we should have a stronger preference for non-verbatim paths when spawning processes.", "tree": {"sha": "4a5ab322c885bb5bdfc1101c306730fc04e4e7b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a5ab322c885bb5bdfc1101c306730fc04e4e7b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a43859a747a8916dbec98b8847a237e6caaf994", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkGfCqCRBK7hj4Ov3rIwAAvbEIAAMO54bUGMYllh6Dr7+rhBYv\nUu5N9Flvn1nFBsYBP2esjYXKUVmW27yaM9oJyQJvWMvE+ImOxlGxolg5f6gsyba5\nUxi22NW3MHU8i1eDENdaa5dRfNzexhX6bSOFNNbzhWK9kZqQQOVG31Izd3Ms3iaH\nT/RTofwZAaPQOwMQqDv8kIvc/l59mv7Flbvx1ltA20BXdNpZEMov4tt5t3TT4RrX\nj01VHNnd7jp16Axhr7PxDrj2/j6Zin7x83s69eqj4u+dzAzo8pQAr61DUmrhXS4n\nspA0AN83PHXhxeqt+ihJ5GRFoMVVKIGYKuTyakcTKAhoFEaR//ppzAMV/0znWa0=\n=vblC\n-----END PGP SIGNATURE-----\n", "payload": "tree 4a5ab322c885bb5bdfc1101c306730fc04e4e7b8\nparent 66676820eb801473f21006fa64315ce3c42402eb\nparent 920435f195b49029d0a83679c04d7dda66afb50a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679421610 +0100\ncommitter GitHub <noreply@github.com> 1679421610 +0100\n\nRollup merge of #96391 - ChrisDenton:command-non-verbatim, r=joshtriplett\n\nWindows: make `Command` prefer non-verbatim paths\n\nWhen spawning Commands, the path we use can end up being queried using `env::current_exe` (or the equivalent in other languages). Not all applications handle these paths properly therefore we should have a stronger preference for non-verbatim paths when spawning processes.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a43859a747a8916dbec98b8847a237e6caaf994", "html_url": "https://github.com/rust-lang/rust/commit/1a43859a747a8916dbec98b8847a237e6caaf994", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a43859a747a8916dbec98b8847a237e6caaf994/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66676820eb801473f21006fa64315ce3c42402eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/66676820eb801473f21006fa64315ce3c42402eb", "html_url": "https://github.com/rust-lang/rust/commit/66676820eb801473f21006fa64315ce3c42402eb"}, {"sha": "920435f195b49029d0a83679c04d7dda66afb50a", "url": "https://api.github.com/repos/rust-lang/rust/commits/920435f195b49029d0a83679c04d7dda66afb50a", "html_url": "https://github.com/rust-lang/rust/commit/920435f195b49029d0a83679c04d7dda66afb50a"}], "stats": {"total": 100, "additions": 62, "deletions": 38}, "files": [{"sha": "43c0cdb657ef1d71d9cbf8fbc409fd66835724f8", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1a43859a747a8916dbec98b8847a237e6caaf994/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a43859a747a8916dbec98b8847a237e6caaf994/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=1a43859a747a8916dbec98b8847a237e6caaf994", "patch": "@@ -11,10 +11,11 @@ use crate::fmt;\n use crate::io;\n use crate::num::NonZeroU16;\n use crate::os::windows::prelude::*;\n-use crate::path::PathBuf;\n-use crate::sys::c;\n+use crate::path::{Path, PathBuf};\n+use crate::sys::path::get_long_path;\n use crate::sys::process::ensure_no_nuls;\n use crate::sys::windows::os::current_exe;\n+use crate::sys::{c, to_u16s};\n use crate::sys_common::wstr::WStrUnits;\n use crate::vec;\n \n@@ -311,7 +312,7 @@ pub(crate) fn make_bat_command_line(\n /// Takes a path and tries to return a non-verbatim path.\n ///\n /// This is necessary because cmd.exe does not support verbatim paths.\n-pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n+pub(crate) fn to_user_path(path: &Path) -> io::Result<Vec<u16>> {\n     use crate::ptr;\n     use crate::sys::windows::fill_utf16_buf;\n \n@@ -324,6 +325,8 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n     const N: u16 = b'N' as _;\n     const C: u16 = b'C' as _;\n \n+    let mut path = to_u16s(path)?;\n+\n     // Early return if the path is too long to remove the verbatim prefix.\n     const LEGACY_MAX_PATH: usize = 260;\n     if path.len() > LEGACY_MAX_PATH {\n@@ -337,7 +340,13 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n             fill_utf16_buf(\n                 |buffer, size| c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()),\n                 |full_path: &[u16]| {\n-                    if full_path == &path[4..path.len() - 1] { full_path.into() } else { path }\n+                    if full_path == &path[4..path.len() - 1] {\n+                        let mut path: Vec<u16> = full_path.into();\n+                        path.push(0);\n+                        path\n+                    } else {\n+                        path\n+                    }\n                 },\n             )\n         },\n@@ -350,7 +359,9 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n                 |buffer, size| c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()),\n                 |full_path: &[u16]| {\n                     if full_path == &path[6..path.len() - 1] {\n-                        full_path.into()\n+                        let mut path: Vec<u16> = full_path.into();\n+                        path.push(0);\n+                        path\n                     } else {\n                         // Restore the 'C' in \"UNC\".\n                         path[6] = b'C' as u16;\n@@ -360,6 +371,6 @@ pub(crate) fn to_user_path(mut path: Vec<u16>) -> io::Result<Vec<u16>> {\n             )\n         },\n         // For everything else, leave the path unchanged.\n-        _ => Ok(path),\n+        _ => get_long_path(path, false),\n     }\n }"}, {"sha": "c3573d14c7f929cb87cc13faf81e1a8a40d615f3", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1a43859a747a8916dbec98b8847a237e6caaf994/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a43859a747a8916dbec98b8847a237e6caaf994/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=1a43859a747a8916dbec98b8847a237e6caaf994", "patch": "@@ -220,6 +220,19 @@ fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n ///\n /// This path may or may not have a verbatim prefix.\n pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n+    let path = to_u16s(path)?;\n+    get_long_path(path, true)\n+}\n+\n+/// Get a normalized absolute path that can bypass path length limits.\n+///\n+/// Setting prefer_verbatim to true suggests a stronger preference for verbatim\n+/// paths even when not strictly necessary. This allows the Windows API to avoid\n+/// repeating our work. However, if the path may be given back to users or\n+/// passed to other application then it's preferable to use non-verbatim paths\n+/// when possible. Non-verbatim paths are better understood by users and handled\n+/// by more software.\n+pub(crate) fn get_long_path(mut path: Vec<u16>, prefer_verbatim: bool) -> io::Result<Vec<u16>> {\n     // Normally the MAX_PATH is 260 UTF-16 code units (including the NULL).\n     // However, for APIs such as CreateDirectory[1], the limit is 248.\n     //\n@@ -243,7 +256,6 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n     // \\\\?\\UNC\\\n     const UNC_PREFIX: &[u16] = &[SEP, SEP, QUERY, SEP, U, N, C, SEP];\n \n-    let mut path = to_u16s(path)?;\n     if path.starts_with(VERBATIM_PREFIX) || path.starts_with(NT_PREFIX) || path == &[0] {\n         // Early return for paths that are already verbatim or empty.\n         return Ok(path);\n@@ -275,29 +287,34 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n         |mut absolute| {\n             path.clear();\n \n-            // Secondly, add the verbatim prefix. This is easier here because we know the\n-            // path is now absolute and fully normalized (e.g. `/` has been changed to `\\`).\n-            let prefix = match absolute {\n-                // C:\\ => \\\\?\\C:\\\n-                [_, COLON, SEP, ..] => VERBATIM_PREFIX,\n-                // \\\\.\\ => \\\\?\\\n-                [SEP, SEP, DOT, SEP, ..] => {\n-                    absolute = &absolute[4..];\n-                    VERBATIM_PREFIX\n-                }\n-                // Leave \\\\?\\ and \\??\\ as-is.\n-                [SEP, SEP, QUERY, SEP, ..] | [SEP, QUERY, QUERY, SEP, ..] => &[],\n-                // \\\\ => \\\\?\\UNC\\\n-                [SEP, SEP, ..] => {\n-                    absolute = &absolute[2..];\n-                    UNC_PREFIX\n-                }\n-                // Anything else we leave alone.\n-                _ => &[],\n-            };\n-\n-            path.reserve_exact(prefix.len() + absolute.len() + 1);\n-            path.extend_from_slice(prefix);\n+            // Only prepend the prefix if needed.\n+            if prefer_verbatim || absolute.len() + 1 >= LEGACY_MAX_PATH {\n+                // Secondly, add the verbatim prefix. This is easier here because we know the\n+                // path is now absolute and fully normalized (e.g. `/` has been changed to `\\`).\n+                let prefix = match absolute {\n+                    // C:\\ => \\\\?\\C:\\\n+                    [_, COLON, SEP, ..] => VERBATIM_PREFIX,\n+                    // \\\\.\\ => \\\\?\\\n+                    [SEP, SEP, DOT, SEP, ..] => {\n+                        absolute = &absolute[4..];\n+                        VERBATIM_PREFIX\n+                    }\n+                    // Leave \\\\?\\ and \\??\\ as-is.\n+                    [SEP, SEP, QUERY, SEP, ..] | [SEP, QUERY, QUERY, SEP, ..] => &[],\n+                    // \\\\ => \\\\?\\UNC\\\n+                    [SEP, SEP, ..] => {\n+                        absolute = &absolute[2..];\n+                        UNC_PREFIX\n+                    }\n+                    // Anything else we leave alone.\n+                    _ => &[],\n+                };\n+\n+                path.reserve_exact(prefix.len() + absolute.len() + 1);\n+                path.extend_from_slice(prefix);\n+            } else {\n+                path.reserve_exact(absolute.len() + 1);\n+            }\n             path.extend_from_slice(absolute);\n             path.push(0);\n         },"}, {"sha": "1c73b64e250ea76264536420eaec9f291d629ccf", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a43859a747a8916dbec98b8847a237e6caaf994/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a43859a747a8916dbec98b8847a237e6caaf994/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=1a43859a747a8916dbec98b8847a237e6caaf994", "patch": "@@ -266,11 +266,7 @@ impl Command {\n         let (program, mut cmd_str) = if is_batch_file {\n             (\n                 command_prompt()?,\n-                args::make_bat_command_line(\n-                    &args::to_user_path(program)?,\n-                    &self.args,\n-                    self.force_quotes_enabled,\n-                )?,\n+                args::make_bat_command_line(&program, &self.args, self.force_quotes_enabled)?,\n             )\n         } else {\n             let cmd_str = make_command_line(&self.program, &self.args, self.force_quotes_enabled)?;\n@@ -410,7 +406,7 @@ fn resolve_exe<'a>(\n         if has_exe_suffix {\n             // The application name is a path to a `.exe` file.\n             // Let `CreateProcessW` figure out if it exists or not.\n-            return path::maybe_verbatim(Path::new(exe_path));\n+            return args::to_user_path(Path::new(exe_path));\n         }\n         let mut path = PathBuf::from(exe_path);\n \n@@ -422,7 +418,7 @@ fn resolve_exe<'a>(\n             // It's ok to use `set_extension` here because the intent is to\n             // remove the extension that was just added.\n             path.set_extension(\"\");\n-            return path::maybe_verbatim(&path);\n+            return args::to_user_path(&path);\n         }\n     } else {\n         ensure_no_nuls(exe_path)?;\n@@ -510,7 +506,7 @@ where\n /// Check if a file exists without following symlinks.\n fn program_exists(path: &Path) -> Option<Vec<u16>> {\n     unsafe {\n-        let path = path::maybe_verbatim(path).ok()?;\n+        let path = args::to_user_path(path).ok()?;\n         // Getting attributes using `GetFileAttributesW` does not follow symlinks\n         // and it will almost always be successful if the link exists.\n         // There are some exceptions for special system files (e.g. the pagefile)"}]}