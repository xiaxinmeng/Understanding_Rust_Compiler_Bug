{"sha": "7ebae85bb8eac495bbc4a463319b23404fdc63a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYmFlODViYjhlYWM0OTViYmM0YTQ2MzMxOWIyMzQwNGZkYzYzYTY=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-08-02T17:18:44Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-08-02T18:09:35Z"}, "message": "StrSearcher: Implement the full two way algorithm in reverse for rfind\n\nFix quadratic behavior in StrSearcher in reverse search with periodic\nneedles.\n\nThis commit adds the missing pieces for the \"short period\" case in\nreverse search. The short case will show up when the needle is literally\nperiodic, for example \"abababab\".\n\nTwo way uses a \"critical factorization\" of the needle: x = u v.\n\nSearching matches v first, if mismatch at character k, skip k forward.\nMatching u, if mismatch, skip period(x) forward.\n\nTo avoid O(mn) behavior after mismatch in u, memorize the already\nmatched prefix.\n\nThe short period case requires that |u| < period(x).\n\nFor the reverse search we need to compute a different critical\nfactorization x = u' v' where |v'| < period(x), because we are searching\nfor the reversed needle. A short v' also benefits the algorithm in\ngeneral.\n\nThe reverse critical factorization is computed quickly by using the same\nmaximal suffix algorithm, but terminating as soon as we have a location\nwith local period equal to period(x).\n\nThis adds extra fields crit_pos_back and memory_back for the reverse\ncase. The new overhead for TwoWaySearcher::new is low, and additionally\nI think the \"short period\" case is uncommon in many applications of\nstring search.\n\nThe maximal_suffix methods were updated in documentation and the\nalgorithms updated to not use !0 and wrapping add, variable left is now\n1 larger, offset 1 smaller.\n\nUse periodicity when computing byteset: in the periodic case, just\niterate over one period instead of the whole needle.\n\nExample before (rfind) after (twoway_rfind) benchmark shows the removal\nof quadratic behavior.\n\nneedle: \"ab\" * 100, haystack: (\"bb\" + \"ab\" * 100) * 100\n\n```\ntest periodic::rfind           ... bench:   1,926,595 ns/iter (+/- 11,390) = 10 MB/s\ntest periodic::twoway_rfind    ... bench:      51,740 ns/iter (+/- 66) = 386 MB/s\n```", "tree": {"sha": "a18b49b4d0604cb25a8bae853f05e639da0fc41e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a18b49b4d0604cb25a8bae853f05e639da0fc41e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ebae85bb8eac495bbc4a463319b23404fdc63a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebae85bb8eac495bbc4a463319b23404fdc63a6", "html_url": "https://github.com/rust-lang/rust/commit/7ebae85bb8eac495bbc4a463319b23404fdc63a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ebae85bb8eac495bbc4a463319b23404fdc63a6/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5a1d8c3db171a4351712c04e6ba6a4e4636a332", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a1d8c3db171a4351712c04e6ba6a4e4636a332", "html_url": "https://github.com/rust-lang/rust/commit/c5a1d8c3db171a4351712c04e6ba6a4e4636a332"}], "stats": {"total": 207, "additions": 158, "deletions": 49}, "files": [{"sha": "8bc1ba207bdfb1ab13fa791abef0a971848f018e", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 158, "deletions": 49, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/7ebae85bb8eac495bbc4a463319b23404fdc63a6/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebae85bb8eac495bbc4a463319b23404fdc63a6/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=7ebae85bb8eac495bbc4a463319b23404fdc63a6", "patch": "@@ -676,8 +676,10 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n                 if searcher.end == 0 {\n                     return SearchStep::Done;\n                 }\n+                let is_long = searcher.memory == usize::MAX;\n                 match searcher.next_back::<RejectAndMatch>(self.haystack.as_bytes(),\n-                                                           self.needle.as_bytes())\n+                                                           self.needle.as_bytes(),\n+                                                           is_long)\n                 {\n                     SearchStep::Reject(mut a, b) => {\n                         // skip to next char boundary\n@@ -706,8 +708,16 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n                 }\n             }\n             StrSearcherImpl::TwoWay(ref mut searcher) => {\n-                searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n-                                                self.needle.as_bytes())\n+                let is_long = searcher.memory == usize::MAX;\n+                if is_long {\n+                    searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n+                                                    self.needle.as_bytes(),\n+                                                    true)\n+                } else {\n+                    searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n+                                                    self.needle.as_bytes(),\n+                                                    false)\n+                }\n             }\n         }\n     }\n@@ -718,14 +728,21 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n #[derive(Clone, Debug)]\n struct TwoWaySearcher {\n     // constants\n+    /// critical factorization index\n     crit_pos: usize,\n+    /// critical factorization index for reversed needle\n+    crit_pos_back: usize,\n     period: usize,\n+    /// `byteset` is an extension (not part of the two way algorithm);\n+    /// it's a 64-bit \"fingerprint\" where each set bit `j` corresponds\n+    /// to a (byte & 63) == j present in the needle.\n     byteset: u64,\n \n     // variables\n     position: usize,\n     end: usize,\n-    memory: usize\n+    memory: usize,\n+    memory_back: usize,\n }\n \n /*\n@@ -797,6 +814,9 @@ struct TwoWaySearcher {\n \n     The purpose of maximal_suffix is to find such a critical factorization.\n \n+    If the period is short, compute another factorization x = u' v' to use\n+    for reverse search, chosen instead so that |v'| < period(x).\n+\n */\n impl TwoWaySearcher {\n     fn new(needle: &[u8], end: usize) -> TwoWaySearcher {\n@@ -810,10 +830,6 @@ impl TwoWaySearcher {\n                 (crit_pos_true, period_true)\n             };\n \n-        // This isn't in the original algorithm, as far as I'm aware.\n-        let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n-\n         // A particularly readable explanation of what's going on here can be found\n         // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n         // see the code for \"Algorithm CP\" on p. 323.\n@@ -824,27 +840,51 @@ impl TwoWaySearcher {\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n         if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n-            // short period case\n+            // short period case -- the period is exact\n+            let byteset = needle[..period].iter()\n+                                .fold(0, |a, &b| (1 << (b & 0x3f)) | a);\n+\n+            // compute a separate critical factorization for the reversed needle\n+            // x = u' v' where |v'| < period(x).\n+            //\n+            // This is sped up by the period being known already.\n+            // Note that a case like x = \"acba\" may be factored exactly forwards\n+            // (crit_pos = 1, period = 3) while being factored with approximate\n+            // period in reverse (crit_pos = 2, period = 2). We use the given\n+            // reverse factorization but keep the exact period.\n+            let crit_pos_back = needle.len() - cmp::max(\n+                TwoWaySearcher::reverse_maximal_suffix(needle, period, false),\n+                TwoWaySearcher::reverse_maximal_suffix(needle, period, true));\n+\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n+                crit_pos_back: crit_pos_back,\n                 period: period,\n                 byteset: byteset,\n \n                 position: 0,\n                 end: end,\n-                memory: 0\n+                memory: 0,\n+                // memory_back after which we have already matched\n+                memory_back: needle.len(),\n             }\n         } else {\n-            // long period case\n-            // we have an approximation to the actual period, and don't use memory.\n+            // long period case -- we have an approximation to the actual period,\n+            // and don't use memorization.\n+\n+            let byteset = needle.iter()\n+                                .fold(0, |a, &b| (1 << (b & 0x3f)) | a);\n+\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n+                crit_pos_back: crit_pos,\n                 period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n                 byteset: byteset,\n \n                 position: 0,\n                 end: end,\n-                memory: usize::MAX // Dummy value to signify that the period is long\n+                memory: usize::MAX, // Dummy value to signify that the period is long\n+                memory_back: usize::MAX,\n             }\n         }\n     }\n@@ -926,19 +966,18 @@ impl TwoWaySearcher {\n \n     // Follows the ideas in `next()`.\n     //\n-    // All the definitions are completely symmetrical, with period(x) = period(reverse(x))\n+    // The definitions are symmetrical, with period(x) = period(reverse(x))\n     // and local_period(u, v) = local_period(reverse(v), reverse(u)), so if (u, v)\n-    // is a critical factorization, so is (reverse(v), reverse(u)). Similarly,\n-    // the \"period\" stored in self.period is the real period if long_period is\n-    // false, and so is still valid for a reversed needle, and if long_period is\n-    // true, all the algorithm requires is that self.period is less than or\n-    // equal to the real period, which must be true for the forward case anyway.\n+    // is a critical factorization, so is (reverse(v), reverse(u)).\n+    //\n+    // For the short period case, using memorization, we rely on |u| < period(x).\n+    // For this case we have computed a critical factorization x = u' v'\n+    // where |v'| < period(x) instead (field `crit_pos_back`).\n     //\n     // To search in reverse through the haystack, we search forward through\n-    // a reversed haystack with a reversed needle, and the above paragraph shows\n-    // that the precomputed parameters can be left alone.\n+    // a reversed haystack with a reversed needle, matching first u' and then v'.\n     #[inline]\n-    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8])\n+    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n         -> S::Output\n         where S: TwoWayStrategy\n     {\n@@ -959,21 +998,34 @@ impl TwoWaySearcher {\n             // Quickly skip by large portions unrelated to our substring\n             if !self.byteset_contains(haystack[self.end - needle.len()]) {\n                 self.end -= needle.len();\n+                if !long_period {\n+                    self.memory_back = needle.len();\n+                }\n                 continue 'search;\n             }\n \n             // See if the left part of the needle matches\n-            for i in (0..self.crit_pos).rev() {\n+            let crit = if long_period { self.crit_pos_back }\n+                        else { cmp::min(self.crit_pos_back, self.memory_back) };\n+            for i in (0..crit).rev() {\n                 if needle[i] != haystack[self.end - needle.len() + i] {\n-                    self.end -= self.crit_pos - i;\n+                    self.end -= self.crit_pos_back - i;\n+                    if !long_period {\n+                        self.memory_back = needle.len();\n+                    }\n                     continue 'search;\n                 }\n             }\n \n             // See if the right part of the needle matches\n-            for i in self.crit_pos..needle.len() {\n+            let needle_end = if long_period { needle.len() }\n+                        else { self.memory_back };\n+            for i in self.crit_pos_back..needle_end {\n                 if needle[i] != haystack[self.end - needle.len() + i] {\n                     self.end -= self.period;\n+                    if !long_period {\n+                        self.memory_back = self.period;\n+                    }\n                     continue 'search;\n                 }\n             }\n@@ -982,53 +1034,110 @@ impl TwoWaySearcher {\n             let match_pos = self.end - needle.len();\n             // Note: sub self.period instead of needle.len() to have overlapping matches\n             self.end -= needle.len();\n+            if !long_period {\n+                self.memory_back = needle.len();\n+            }\n \n             return S::matching(match_pos, match_pos + needle.len());\n         }\n     }\n \n-    // Computes a critical factorization (u, v) of `arr`.\n-    // Specifically, returns (i, p), where i is the starting index of v in some\n-    // critical factorization (u, v) and p = period(v)\n+    // Compute the maximal suffix of `arr`.\n+    //\n+    // The maximal suffix is a possible critical factorization (u, v) of `arr`.\n+    //\n+    // Returns (`i`, `p`) where `i` is the starting index of v and `p` is the\n+    // period of v.\n+    //\n+    // `order_greater` determines if lexical order is `<` or `>`. Both\n+    // orders must be computed -- the ordering with the largest `i` gives\n+    // a critical factorization.\n+    //\n+    // For long period cases, the resulting period is not exact (it is too short).\n     #[inline]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n-        let mut left: usize = !0; // Corresponds to i in the paper\n-        let mut right = 0; // Corresponds to j in the paper\n-        let mut offset = 1; // Corresponds to k in the paper\n+    fn maximal_suffix(arr: &[u8], order_greater: bool) -> (usize, usize) {\n+        let mut left = 0; // Corresponds to i in the paper\n+        let mut right = 1; // Corresponds to j in the paper\n+        let mut offset = 0; // Corresponds to k in the paper\n         let mut period = 1; // Corresponds to p in the paper\n \n-        while right + offset < arr.len() {\n-            let a;\n-            let b;\n-            if reversed {\n-                a = arr[left.wrapping_add(offset)];\n-                b = arr[right + offset];\n+        while let Some(&a) = arr.get(right + offset) {\n+            // `left` will be inbounds when `right` is.\n+            let b = arr[left + offset];\n+            if (a < b && !order_greater) || (a > b && order_greater) {\n+                // Suffix is smaller, period is entire prefix so far.\n+                right += offset + 1;\n+                offset = 0;\n+                period = right - left;\n+            } else if a == b {\n+                // Advance through repetition of the current period.\n+                if offset + 1 == period {\n+                    right += offset + 1;\n+                    offset = 0;\n+                } else {\n+                    offset += 1;\n+                }\n             } else {\n-                a = arr[right + offset];\n-                b = arr[left.wrapping_add(offset)];\n+                // Suffix is larger, start over from current location.\n+                left = right;\n+                right += 1;\n+                offset = 0;\n+                period = 1;\n             }\n-            if a < b {\n+        }\n+        (left, period)\n+    }\n+\n+    // Compute the maximal suffix of the reverse of `arr`.\n+    //\n+    // The maximal suffix is a possible critical factorization (u', v') of `arr`.\n+    //\n+    // Returns `i` where `i` is the starting index of v', from the back;\n+    // returns immedately when a period of `known_period` is reached.\n+    //\n+    // `order_greater` determines if lexical order is `<` or `>`. Both\n+    // orders must be computed -- the ordering with the largest `i` gives\n+    // a critical factorization.\n+    //\n+    // For long period cases, the resulting period is not exact (it is too short).\n+    fn reverse_maximal_suffix(arr: &[u8], known_period: usize,\n+                              order_greater: bool) -> usize\n+    {\n+        let mut left = 0; // Corresponds to i in the paper\n+        let mut right = 1; // Corresponds to j in the paper\n+        let mut offset = 0; // Corresponds to k in the paper\n+        let mut period = 1; // Corresponds to p in the paper\n+        let n = arr.len();\n+\n+        while right + offset < n {\n+            let a = arr[n - (1 + right + offset)];\n+            let b = arr[n - (1 + left + offset)];\n+            if (a < b && !order_greater) || (a > b && order_greater) {\n                 // Suffix is smaller, period is entire prefix so far.\n-                right += offset;\n-                offset = 1;\n-                period = right.wrapping_sub(left);\n+                right += offset + 1;\n+                offset = 0;\n+                period = right - left;\n             } else if a == b {\n                 // Advance through repetition of the current period.\n-                if offset == period {\n-                    right += offset;\n-                    offset = 1;\n+                if offset + 1 == period {\n+                    right += offset + 1;\n+                    offset = 0;\n                 } else {\n                     offset += 1;\n                 }\n             } else {\n                 // Suffix is larger, start over from current location.\n                 left = right;\n                 right += 1;\n-                offset = 1;\n+                offset = 0;\n                 period = 1;\n             }\n+            if period == known_period {\n+                break;\n+            }\n         }\n-        (left.wrapping_add(1), period)\n+        debug_assert!(period <= known_period);\n+        left\n     }\n }\n "}]}