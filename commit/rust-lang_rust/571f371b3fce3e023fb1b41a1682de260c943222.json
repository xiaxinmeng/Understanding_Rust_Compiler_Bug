{"sha": "571f371b3fce3e023fb1b41a1682de260c943222", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MWYzNzFiM2ZjZTNlMDIzZmIxYjQxYTE2ODJkZTI2MGM5NDMyMjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-14T20:03:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-14T20:03:39Z"}, "message": "Auto merge of #25403 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #25354, #25381, #25391, #25395, #25397, #25398, #25401\n- Failed merges:", "tree": {"sha": "6db38ec1db5609f61379667b1ba406bca992e826", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6db38ec1db5609f61379667b1ba406bca992e826"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/571f371b3fce3e023fb1b41a1682de260c943222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/571f371b3fce3e023fb1b41a1682de260c943222", "html_url": "https://github.com/rust-lang/rust/commit/571f371b3fce3e023fb1b41a1682de260c943222", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/571f371b3fce3e023fb1b41a1682de260c943222/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd4dad8c860363077a3d53af025a0c029a613320", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4dad8c860363077a3d53af025a0c029a613320", "html_url": "https://github.com/rust-lang/rust/commit/dd4dad8c860363077a3d53af025a0c029a613320"}, {"sha": "2df7ae6e647c1dff50c9bf21e8883827096f48c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2df7ae6e647c1dff50c9bf21e8883827096f48c1", "html_url": "https://github.com/rust-lang/rust/commit/2df7ae6e647c1dff50c9bf21e8883827096f48c1"}], "stats": {"total": 271, "additions": 229, "deletions": 42}, "files": [{"sha": "21e9be59ebbdf372c6b194a8bbf521de567f306b", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -3529,7 +3529,9 @@ The actual implementation for each vtable entry can vary on an object-by-object\n basis.\n \n Note that for a trait object to be instantiated, the trait must be\n-_object-safe_. Object safety rules are defined in [RFC 255][rfc255].\n+_object-safe_. Object safety rules are defined in [RFC 255].\n+\n+[RFC 255]: https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md\n \n Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T`\n implements trait `R`, casting `E` to the corresponding pointer type `&R` or"}, {"sha": "a93f622e9c529699e0ec03d6c6c0a9aeca5775f0", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -42,7 +42,7 @@ loop is just a handy way to write this `loop`/`match`/`break` construct.\n `for` loops aren't the only thing that uses iterators, however. Writing your\n own iterator involves implementing the `Iterator` trait. While doing that is\n outside of the scope of this guide, Rust provides a number of useful iterators\n-to accomplish various threads. Before we talk about those, we should talk about a\n+to accomplish various tasks. Before we talk about those, we should talk about a\n Rust anti-pattern. And that's using ranges like this.\n \n Yes, we just talked about how ranges are cool. But ranges are also very"}, {"sha": "9622a92303f1e05b78d579bb29aadf0fd8b96f67", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -80,15 +80,15 @@ This memory is kind of like a giant array: addresses start at zero and go\n up to the final number. So here\u2019s a diagram of our first stack frame:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 0       | x    | 42    |\n \n We\u2019ve got `x` located at address `0`, with the value `42`.\n \n When `foo()` is called, a new stack frame is allocated:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 2       | z    | 100   |\n | 1       | y    | 5     |\n | 0       | x    | 42    |\n@@ -107,7 +107,7 @@ value being stored.\n After `foo()` is over, its frame is deallocated:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 0       | x    | 42    |\n \n And then, after `main()`, even this last value goes away. Easy!\n@@ -142,13 +142,13 @@ fn main() {\n Okay, first, we call `main()`:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 0       | x    | 42    |\n \n Next up, `main()` calls `foo()`:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 3       | c    | 1     |\n | 2       | b    | 100   |\n | 1       | a    | 5     |\n@@ -157,7 +157,7 @@ Next up, `main()` calls `foo()`:\n And then `foo()` calls `bar()`:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 4       | i    | 6     |\n | 3       | c    | 1     |\n | 2       | b    | 100   |\n@@ -170,7 +170,7 @@ After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n `main()`:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 3       | c    | 1     |\n | 2       | b    | 100   |\n | 1       | a    | 5     |\n@@ -179,7 +179,7 @@ After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n And then `foo()` ends, leaving just `main()`\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 0       | x    | 42    |\n \n And then we\u2019re done. Getting the hang of it? It\u2019s like piling up dishes: you\n@@ -206,7 +206,7 @@ fn main() {\n Here\u2019s what happens in memory when `main()` is called:\n \n | Address | Name | Value  |\n-+---------+------+--------+\n+|---------|------|--------|\n | 1       | y    | 42     |\n | 0       | x    | ?????? |\n \n@@ -218,7 +218,7 @@ it allocates some memory for the heap, and puts `5` there. The memory now looks\n like this:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 5              |\n | ...             | ...  | ...            |\n | 1               | y    | 42             |\n@@ -243,7 +243,7 @@ layout of a program which has been running for a while now:\n \n \n | Address              | Name | Value                |\n-+----------------------+------+----------------------+\n+|----------------------|------|----------------------|\n | 2<sup>30</sup>       |      | 5                    |\n | (2<sup>30</sup>) - 1 |      |                      |\n | (2<sup>30</sup>) - 2 |      |                      |\n@@ -272,7 +272,7 @@ when it was created. Great! So when `x` goes away, it first frees the memory\n allocated on the heap:\n \n | Address | Name | Value  |\n-+---------+------+--------+\n+|---------|------|--------|\n | 1       | y    | 42     |\n | 0       | x    | ?????? |\n \n@@ -305,7 +305,7 @@ fn main() {\n When we enter `main()`, memory looks like this:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 1       | y    | 0     |\n | 0       | x    | 5     |\n \n@@ -315,7 +315,7 @@ memory location that `x` lives at, which in this case is `0`.\n What about when we call `foo()`, passing `y` as an argument?\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 3       | z    | 42    |\n | 2       | i    | 0     |\n | 1       | y    | 0     |\n@@ -367,7 +367,7 @@ fn main() {\n First, we call `main()`:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 20             |\n | ...             | ...  | ...            |\n | 2               | j    | 0              |\n@@ -380,7 +380,7 @@ value pointing there.\n Next, at the end of `main()`, `foo()` gets called:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 20             |\n | ...             | ...  | ...            |\n | 5               | z    | 4              |\n@@ -397,7 +397,7 @@ since `j` points at `h`.\n Next, `foo()` calls `baz()`, passing `z`:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 20             |\n | ...             | ...  | ...            |\n | 7               | g    | 100            |\n@@ -413,7 +413,7 @@ We\u2019ve allocated memory for `f` and `g`. `baz()` is very short, so when it\u2019s\n over, we get rid of its stack frame:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 20             |\n | ...             | ...  | ...            |\n | 5               | z    | 4              |\n@@ -426,7 +426,7 @@ over, we get rid of its stack frame:\n Next, `foo()` calls `bar()` with `x` and `z`:\n \n | Address              | Name | Value                |\n-+----------------------+------+----------------------+\n+|----------------------|------|----------------------|\n |  2<sup>30</sup>      |      | 20                   |\n | (2<sup>30</sup>) - 1 |      | 5                    |\n | ...                  | ...  | ...                  |\n@@ -449,7 +449,7 @@ case, we set up the variables as usual.\n At the end of `bar()`, it calls `baz()`:\n \n | Address              | Name | Value                |\n-+----------------------+------+----------------------+\n+|----------------------|------|----------------------|\n |  2<sup>30</sup>      |      | 20                   |\n | (2<sup>30</sup>) - 1 |      | 5                    |\n | ...                  | ...  | ...                  |\n@@ -473,7 +473,7 @@ far.\n After `baz()` is over, we get rid of `f` and `g`:\n \n | Address              | Name | Value                |\n-+----------------------+------+----------------------+\n+|----------------------|------|----------------------|\n |  2<sup>30</sup>      |      | 20                   |\n | (2<sup>30</sup>) - 1 |      | 5                    |\n | ...                  | ...  | ...                  |\n@@ -493,7 +493,7 @@ Next, we return from `bar()`. `d` in this case is a `Box<T>`, so it also frees\n what it points to: (2<sup>30</sup>) - 1.\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n |  2<sup>30</sup> |      | 20             |\n | ...             | ...  | ...            |\n | 5               | z    | 4              |\n@@ -506,7 +506,7 @@ what it points to: (2<sup>30</sup>) - 1.\n And after that, `foo()` returns:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n |  2<sup>30</sup> |      | 20             |\n | ...             | ...  | ...            |\n | 2               | j    | 0              |"}, {"sha": "15ddcbc80749cb38dd430dd2f50aa6833f45d522", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 84, "deletions": 6, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -49,6 +49,88 @@ about what constitutes an Item declaration and what does not:\n http://doc.rust-lang.org/reference.html#statements\n \"##,\n \n+E0251: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0252: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::baz; // error, do `use bar::baz as quux` instead\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0255: r##\"\n+You can't import a value whose name is the same as another value defined in the\n+module.\n+\n+An example of this error:\n+\n+```\n+use bar::foo; // error, do `use bar::foo as baz` instead\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n+E0256: r##\"\n+You can't import a type or module when the name of the item being imported is\n+the same as another type or submodule defined in the module.\n+\n+An example of this error:\n+\n+```\n+use foo::Bar; // error\n+\n+type Bar = u32;\n+\n+mod foo {\n+    pub mod Bar { }\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n E0259: r##\"\n The name chosen for an external crate conflicts with another external crate that\n has been imported into the current module.\n@@ -122,14 +204,10 @@ http://doc.rust-lang.org/reference.html#types\n register_diagnostics! {\n     E0157,\n     E0153,\n-    E0251, // a named type or value has already been imported in this module\n-    E0252, // a named type or value has already been imported in this module\n     E0253, // not directly importable\n     E0254, // import conflicts with imported crate in this module\n-    E0255, // import conflicts with value in this module\n-    E0256, // import conflicts with type in this module\n-    E0257, // inherent implementations are only allowed on types defined in the current module\n-    E0258, // import conflicts with existing submodule\n+    E0257,\n+    E0258,\n     E0364, // item is private\n     E0365  // item is private\n }"}, {"sha": "3cdbaec15284b7e488e423ae208e1aa8b2191781", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -3082,8 +3082,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let mut checked = false;\n           opt_place.as_ref().map(|place| match place.node {\n               ast::ExprPath(None, ref path) => {\n-                  // FIXME(pcwalton): For now we hardcode the two permissible\n-                  // places: the exchange heap and the managed heap.\n+                  // FIXME(pcwalton): For now we hardcode the only permissible\n+                  // place: the exchange heap.\n                   let definition = lookup_full_def(tcx, path.span, place.id);\n                   let def_id = definition.def_id();\n                   let referent_ty = fcx.expr_ty(&**subexpr);\n@@ -3097,7 +3097,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           if !checked {\n               span_err!(tcx.sess, expr.span, E0066,\n-                  \"only the managed heap and exchange heap are currently supported\");\n+                  \"only the exchange heap is currently supported\");\n               fcx.write_ty(id, tcx.types.err);\n           }\n       }\n@@ -3317,7 +3317,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n                                                     result_type, ty::mk_nil(fcx.tcx())) {\n                             span_err!(tcx.sess, expr.span, E0069,\n-                                \"`return;` in function returning non-nil\");\n+                                \"`return;` in a function whose return type is \\\n+                                 not `()`\");\n                         },\n                     Some(ref e) => {\n                         check_expr_coercable_to_type(fcx, &**e, result_type);"}, {"sha": "2e5b389c2850eb179cc4a50fc7080d01dc80cad5", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 104, "deletions": 4, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -64,6 +64,43 @@ impl Foo for Bar {\n ```\n \"##,\n \n+E0053: r##\"\n+For any given method of a trait, the mutabilities of the parameters must match\n+between the trait definition and the implementation.\n+\n+Here's an example where the mutability of the `self` parameter is wrong:\n+\n+```\n+trait Foo { fn foo(&self); }\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, the signature should be `fn foo(&self)` instead\n+    fn foo(&mut self) { }\n+}\n+\n+fn main() {}\n+```\n+\n+Here's another example, this time for a non-`self` parameter:\n+\n+```\n+trait Foo { fn foo(x: &mut bool) -> bool; }\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, the type of `x` should be `&mut bool` instead\n+    fn foo(x: &bool) -> bool { *x }\n+}\n+\n+fn main() {}\n+```\n+\n+\n+\"##,\n+\n E0054: r##\"\n It is not allowed to cast to a bool. If you are trying to cast a numeric type\n to a bool, you can compare it with zero instead:\n@@ -91,6 +128,16 @@ enum variant, one of the fields was not provided. Each field should be specified\n exactly once.\n \"##,\n \n+E0066: r##\"\n+Box placement expressions (like C++'s \"placement new\") do not yet support any\n+place expression except the exchange heap (i.e. `std::boxed::HEAP`).\n+Furthermore, the syntax is changing to use `in` instead of `box`. See [RFC 470]\n+and [RFC 809] for more details.\n+\n+[RFC 470]: https://github.com/rust-lang/rfcs/pull/470\n+[RFC 809]: https://github.com/rust-lang/rfcs/pull/809\n+\"##,\n+\n E0067: r##\"\n The left-hand side of an assignment operator must be an lvalue expression. An\n lvalue expression represents a memory location and includes item paths (ie,\n@@ -108,6 +155,21 @@ LinkedList::new() += 1;\n ```\n \"##,\n \n+E0069: r##\"\n+The compiler found a function whose body contains a `return;` statement but\n+whose return type is not `()`. An example of this is:\n+\n+```\n+// error\n+fn foo() -> u8 {\n+    return;\n+}\n+```\n+\n+Since `return;` is just like `return ();`, there is a mismatch between the\n+function's return type and the value being returned.\n+\"##,\n+\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -458,6 +520,48 @@ The `Sized` trait is a special trait built-in to the compiler for types with a\n constant size known at compile-time. This trait is automatically implemented\n for types as needed by the compiler, and it is currently disallowed to\n explicitly implement it for a type.\n+\"##,\n+\n+E0368: r##\"\n+This error indicates that a binary assignment operator like `+=` or `^=` was\n+applied to the wrong types.\n+\n+A couple examples of this are as follows:\n+\n+```\n+let mut x: u16 = 5;\n+x ^= true; // error, `^=` cannot be applied to types `u16` and `bool`\n+x += ();   // error, `+=` cannot be applied to types `u16` and `()`\n+```\n+\n+Another problem you might be facing is this: suppose you've overloaded the `+`\n+operator for some type `Foo` by implementing the `std::ops::Add` trait for\n+`Foo`, but you find that using `+=` does not work, as in this example:\n+\n+```\n+use std::ops::Add;\n+\n+struct Foo(u32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, rhs: Foo) -> Foo {\n+        Foo(self.0 + rhs.0)\n+    }\n+}\n+\n+fn main() {\n+    let mut x: Foo = Foo(5);\n+    x += Foo(7); // error, `+= cannot be applied to types `Foo` and `Foo`\n+}\n+```\n+\n+This is because the binary assignment operators currently do not work off of\n+traits, so it is not possible to overload them. See [RFC 953] for a proposal\n+to change this.\n+\n+[RFC 953]: https://github.com/rust-lang/rfcs/pull/953\n \"##\n \n }\n@@ -478,15 +582,12 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n-    E0053,\n     E0055, // method has an incompatible type for trait\n     E0057, // method has an incompatible type for trait\n     E0059,\n     E0060,\n     E0061,\n-    E0066,\n     E0068,\n-    E0069,\n     E0070,\n     E0071,\n     E0072,\n@@ -606,7 +707,6 @@ register_diagnostics! {\n     E0328, // cannot implement Unsize explicitly\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n-    E0368, // binary operation `<op>=` cannot be applied to types\n     E0369, // binary operation `<op>` cannot be applied to types\n     E0371, // impl Trait for Trait is illegal\n     E0372, // impl Trait for Trait where Trait is not object safe"}, {"sha": "220a0ba5755f0c0e5584ab0c744ae6c2c045b099", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -28,7 +28,7 @@\n //!\n //! The standard library is minimal, a set of battle-tested\n //! core types and shared abstractions for the [broader Rust\n-//! ecosystem][https://crates.io] to build on.\n+//! ecosystem](https://crates.io) to build on.\n //!\n //! The [primitive types](#primitives), though not defined in the\n //! standard library, are documented here, as are the predefined"}, {"sha": "47bdc9335c4019819de309ac70da326c1c528162", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -183,6 +183,12 @@ impl Subcommand for Build {\n             tgt = PathBuf::from(&env::args().nth(3).unwrap());\n         }\n \n+        // `_book` directory may already exist from previous runs. Check and\n+        // delete it if it exists.\n+        for entry in try!(fs::read_dir(&cwd)) {\n+            let path = try!(entry).path();\n+            if path == tgt { try!(fs::remove_dir_all(&tgt)) }\n+        }\n         try!(fs::create_dir(&tgt));\n \n         try!(File::create(&tgt.join(\"rust-book.css\")).and_then(|mut f| {"}, {"sha": "003c6644f7f0229061662a995ecc8ab5eff03ba1", "filename": "src/test/compile-fail/issue-14084.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     box ( () ) 0;\n-    //~^ ERROR: only the managed heap and exchange heap are currently supported\n+    //~^ ERROR: only the exchange heap is currently supported\n }"}, {"sha": "6be98fbd82773ffad6e708af3bddb0559de87276", "filename": "src/test/compile-fail/ret-non-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/571f371b3fce3e023fb1b41a1682de260c943222/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571f371b3fce3e023fb1b41a1682de260c943222/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs?ref=571f371b3fce3e023fb1b41a1682de260c943222", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: `return;` in function returning non-nil\n+// error-pattern: `return;` in a function whose return type is not `()`\n \n fn f() { return; }\n "}]}