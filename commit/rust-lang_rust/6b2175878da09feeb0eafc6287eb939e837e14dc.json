{"sha": "6b2175878da09feeb0eafc6287eb939e837e14dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMjE3NTg3OGRhMDlmZWViMGVhZmM2Mjg3ZWI5MzllODM3ZTE0ZGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-16T11:48:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-16T11:48:36Z"}, "message": "Merge #4891\n\n4891: New VFS API r=matklad a=matklad\n\ncc @flodiebold , @jonas-schievink \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c8a2de2f545cfa7337f298812d5e4f8fae6b01ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8a2de2f545cfa7337f298812d5e4f8fae6b01ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b2175878da09feeb0eafc6287eb939e837e14dc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe6LGUCRBK7hj4Ov3rIwAAdHIIAFPKg7EL6z0pktYDjM/yTb5K\n6tyIGLTIXJtCjpP13xABp+DWROTO4DLFxiT1jjN7rj3XTyH2jdK8rhePHGomr2u/\nue1+RjL1ZvJTdDBo9xrinqUkAgnZPTrgEYxODDtPzpxPDgClGhNDqLXVcMuIV0KU\nyykn+qWUQlH2IVrInu9riMTN6cYPdbqokziikCKDZ1P5vzrMujppHX9OzqTimxa8\nJTnvP+f9wmAf691e9P7otgFf/FdMLIxLzaCOtCk6enTIUhP/3kdy7m7oSfOTebDe\ntiwtb3WOTnr8KJ7RbePiR741Dku4epmRr2BGQtA5NC9TZnIUKyMOIkEqi9rAGbY=\n=e6Sb\n-----END PGP SIGNATURE-----\n", "payload": "tree c8a2de2f545cfa7337f298812d5e4f8fae6b01ae\nparent 4342b717158eeb9aff20d1958229ffcbca17f1c7\nparent c002322bde06a73c8cfa02cd1cbe33cf225da47b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592308116 +0000\ncommitter GitHub <noreply@github.com> 1592308116 +0000\n\nMerge #4891\n\n4891: New VFS API r=matklad a=matklad\n\ncc @flodiebold , @jonas-schievink \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b2175878da09feeb0eafc6287eb939e837e14dc", "html_url": "https://github.com/rust-lang/rust/commit/6b2175878da09feeb0eafc6287eb939e837e14dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b2175878da09feeb0eafc6287eb939e837e14dc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4342b717158eeb9aff20d1958229ffcbca17f1c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4342b717158eeb9aff20d1958229ffcbca17f1c7", "html_url": "https://github.com/rust-lang/rust/commit/4342b717158eeb9aff20d1958229ffcbca17f1c7"}, {"sha": "c002322bde06a73c8cfa02cd1cbe33cf225da47b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c002322bde06a73c8cfa02cd1cbe33cf225da47b", "html_url": "https://github.com/rust-lang/rust/commit/c002322bde06a73c8cfa02cd1cbe33cf225da47b"}], "stats": {"total": 520, "additions": 520, "deletions": 0}, "files": [{"sha": "6d83c927614475274313fe43c82e1e8615b58866", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b2175878da09feeb0eafc6287eb939e837e14dc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6b2175878da09feeb0eafc6287eb939e837e14dc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6b2175878da09feeb0eafc6287eb939e837e14dc", "patch": "@@ -1729,6 +1729,18 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"vfs\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"crossbeam-channel\",\n+ \"globset\",\n+ \"jod-thread\",\n+ \"paths\",\n+ \"rustc-hash\",\n+ \"walkdir\",\n+]\n+\n [[package]]\n name = \"walkdir\"\n version = \"2.3.1\""}, {"sha": "c03e6363b8e3e9d9fdd653f97bf8718a0a41dd12", "filename": "crates/vfs/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2FCargo.toml?ref=6b2175878da09feeb0eafc6287eb939e837e14dc", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"vfs\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+rustc-hash = \"1.0\"\n+jod-thread = \"0.1.0\"\n+walkdir = \"2.3.1\"\n+globset = \"0.4.5\"\n+crossbeam-channel = \"0.4.0\"\n+\n+paths = { path = \"../paths\" }"}, {"sha": "7dc721f7e4e750539755bcb07d0e4970533b8146", "filename": "crates/vfs/src/file_set.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=6b2175878da09feeb0eafc6287eb939e837e14dc", "patch": "@@ -0,0 +1,99 @@\n+//! Partitions a list of files into disjoint subsets.\n+//!\n+//! Files which do not belong to any explicitly configured `FileSet` belong to\n+//! the default `FileSet`.\n+use std::{cmp, fmt, iter};\n+\n+use paths::AbsPathBuf;\n+use rustc_hash::FxHashMap;\n+\n+use crate::{FileId, Vfs, VfsPath};\n+\n+#[derive(Default, Clone, Eq, PartialEq)]\n+pub struct FileSet {\n+    files: FxHashMap<VfsPath, FileId>,\n+    paths: FxHashMap<FileId, VfsPath>,\n+}\n+\n+impl FileSet {\n+    pub fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n+        let mut base = self.paths[&anchor].clone();\n+        base.pop();\n+        let path = base.join(path);\n+        let res = self.files.get(&path).copied();\n+        res\n+    }\n+    pub fn insert(&mut self, file_id: FileId, path: VfsPath) {\n+        self.files.insert(path.clone(), file_id);\n+        self.paths.insert(file_id, path);\n+    }\n+    pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n+        self.paths.keys().copied()\n+    }\n+}\n+\n+impl fmt::Debug for FileSet {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FileSet\").field(\"n_files\", &self.files.len()).finish()\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct FileSetConfig {\n+    n_file_sets: usize,\n+    roots: Vec<(AbsPathBuf, usize)>,\n+}\n+\n+impl FileSetConfig {\n+    pub fn builder() -> FileSetConfigBuilder {\n+        FileSetConfigBuilder::default()\n+    }\n+    pub fn partition(&self, vfs: &Vfs) -> Vec<FileSet> {\n+        let mut res = vec![FileSet::default(); self.len()];\n+        for (file_id, path) in vfs.iter() {\n+            let root = self.classify(&path);\n+            res[root].insert(file_id, path)\n+        }\n+        res\n+    }\n+    fn len(&self) -> usize {\n+        self.n_file_sets\n+    }\n+    fn classify(&self, path: &VfsPath) -> usize {\n+        for (root, idx) in self.roots.iter() {\n+            if let Some(path) = path.as_path() {\n+                if path.starts_with(root) {\n+                    return *idx;\n+                }\n+            }\n+        }\n+        self.len() - 1\n+    }\n+}\n+\n+pub struct FileSetConfigBuilder {\n+    roots: Vec<Vec<AbsPathBuf>>,\n+}\n+\n+impl Default for FileSetConfigBuilder {\n+    fn default() -> Self {\n+        FileSetConfigBuilder { roots: Vec::new() }\n+    }\n+}\n+\n+impl FileSetConfigBuilder {\n+    pub fn add_file_set(&mut self, roots: Vec<AbsPathBuf>) {\n+        self.roots.push(roots)\n+    }\n+    pub fn build(self) -> FileSetConfig {\n+        let n_file_sets = self.roots.len() + 1;\n+        let mut roots: Vec<(AbsPathBuf, usize)> = self\n+            .roots\n+            .into_iter()\n+            .enumerate()\n+            .flat_map(|(i, paths)| paths.into_iter().zip(iter::repeat(i)))\n+            .collect();\n+        roots.sort_by_key(|(path, _)| cmp::Reverse(path.to_string_lossy().len()));\n+        FileSetConfig { n_file_sets, roots }\n+    }\n+}"}, {"sha": "75ce61cf9dfa337285a94122d6af4daaacce882c", "filename": "crates/vfs/src/lib.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Flib.rs?ref=6b2175878da09feeb0eafc6287eb939e837e14dc", "patch": "@@ -0,0 +1,138 @@\n+//! # Virtual File System\n+//!\n+//! VFS stores all files read by rust-analyzer. Reading file contents from VFS\n+//! always returns the same contents, unless VFS was explicitly modified with\n+//! `set_file_contents`. All changes to VFS are logged, and can be retrieved via\n+//! `take_changes` method. The pack of changes is then pushed to `salsa` and\n+//! triggers incremental recomputation.\n+//!\n+//! Files in VFS are identified with `FileId`s -- interned paths. The notion of\n+//! the path, `VfsPath` is somewhat abstract: at the moment, it is represented\n+//! as an `std::path::PathBuf` internally, but this is an implementation detail.\n+//!\n+//! VFS doesn't do IO or file watching itself. For that, see the `loader`\n+//! module. `loader::Handle` is an object-safe trait which abstracts both file\n+//! loading and file watching. `Handle` is dynamically configured with a set of\n+//! directory entries which should be scanned and watched. `Handle` then\n+//! asynchronously pushes file changes. Directory entries are configured in\n+//! free-form via list of globs, it's up to the `Handle` to interpret the globs\n+//! in any specific way.\n+//!\n+//! A simple `WalkdirLoaderHandle` is provided, which doesn't implement watching\n+//! and just scans the directory using walkdir.\n+//!\n+//! VFS stores a flat list of files. `FileSet` can partition this list of files\n+//! into disjoint sets of files. Traversal-like operations (including getting\n+//! the neighbor file by the relative path) are handled by the `FileSet`.\n+//! `FileSet`s are also pushed to salsa and cause it to re-check `mod foo;`\n+//! declarations when files are created or deleted.\n+//!\n+//! `file_set::FileSet` and `loader::Entry` play similar, but different roles.\n+//! Both specify the \"set of paths/files\", one is geared towards file watching,\n+//! the other towards salsa changes. In particular, single `file_set::FileSet`\n+//! may correspond to several `loader::Entry`. For example, a crate from\n+//! crates.io which uses code generation would have two `Entries` -- for sources\n+//! in `~/.cargo`, and for generated code in `./target/debug/build`. It will\n+//! have a single `FileSet` which unions the two sources.\n+mod vfs_path;\n+mod path_interner;\n+pub mod file_set;\n+pub mod loader;\n+pub mod walkdir_loader;\n+\n+use std::{fmt, mem};\n+\n+use crate::path_interner::PathInterner;\n+\n+pub use crate::vfs_path::VfsPath;\n+pub use paths::{AbsPath, AbsPathBuf};\n+\n+#[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\n+pub struct FileId(pub u32);\n+\n+#[derive(Default)]\n+pub struct Vfs {\n+    interner: PathInterner,\n+    data: Vec<Option<Vec<u8>>>,\n+    changes: Vec<ChangedFile>,\n+}\n+\n+pub struct ChangedFile {\n+    pub file_id: FileId,\n+    pub change_kind: ChangeKind,\n+}\n+\n+impl ChangedFile {\n+    pub fn exists(&self) -> bool {\n+        self.change_kind != ChangeKind::Delete\n+    }\n+    pub fn is_created_or_deleted(&self) -> bool {\n+        matches!(self.change_kind, ChangeKind::Create | ChangeKind::Delete)\n+    }\n+}\n+\n+#[derive(Eq, PartialEq)]\n+pub enum ChangeKind {\n+    Create,\n+    Modify,\n+    Delete,\n+}\n+\n+impl Vfs {\n+    pub fn file_id(&self, path: &VfsPath) -> Option<FileId> {\n+        self.interner.get(path).filter(|&it| self.get(it).is_some())\n+    }\n+    pub fn file_path(&self, file_id: FileId) -> VfsPath {\n+        self.interner.lookup(file_id).clone()\n+    }\n+    pub fn file_contents(&self, file_id: FileId) -> &[u8] {\n+        self.get(file_id).as_deref().unwrap()\n+    }\n+    pub fn iter(&self) -> impl Iterator<Item = (FileId, VfsPath)> + '_ {\n+        (0..self.data.len())\n+            .map(|it| FileId(it as u32))\n+            .filter(move |&file_id| self.get(file_id).is_some())\n+            .map(move |file_id| {\n+                let path = self.interner.lookup(file_id).clone();\n+                (file_id, path)\n+            })\n+    }\n+    pub fn set_file_contents(&mut self, path: VfsPath, contents: Option<Vec<u8>>) {\n+        let file_id = self.alloc_file_id(path);\n+        let change_kind = match (&self.get(file_id), &contents) {\n+            (None, None) => return,\n+            (None, Some(_)) => ChangeKind::Create,\n+            (Some(_), None) => ChangeKind::Delete,\n+            (Some(old), Some(new)) if old == new => return,\n+            (Some(_), Some(_)) => ChangeKind::Modify,\n+        };\n+\n+        *self.get_mut(file_id) = contents;\n+        self.changes.push(ChangedFile { file_id, change_kind })\n+    }\n+    pub fn has_changes(&self) -> bool {\n+        !self.changes.is_empty()\n+    }\n+    pub fn take_changes(&mut self) -> Vec<ChangedFile> {\n+        mem::take(&mut self.changes)\n+    }\n+    fn alloc_file_id(&mut self, path: VfsPath) -> FileId {\n+        let file_id = self.interner.intern(path);\n+        let idx = file_id.0 as usize;\n+        let len = self.data.len().max(idx + 1);\n+        self.data.resize_with(len, || None);\n+        file_id\n+    }\n+    fn get(&self, file_id: FileId) -> &Option<Vec<u8>> {\n+        &self.data[file_id.0 as usize]\n+    }\n+    fn get_mut(&mut self, file_id: FileId) -> &mut Option<Vec<u8>> {\n+        &mut self.data[file_id.0 as usize]\n+    }\n+}\n+\n+impl fmt::Debug for Vfs {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Vfs\").field(\"n_files\", &self.data.len()).finish()\n+    }\n+}"}, {"sha": "5a0ca68f385711a71660ded17b2ddf786c702e1c", "filename": "crates/vfs/src/loader.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Floader.rs?ref=6b2175878da09feeb0eafc6287eb939e837e14dc", "patch": "@@ -0,0 +1,69 @@\n+//! Object safe interface for file watching and reading.\n+use std::fmt;\n+\n+use paths::AbsPathBuf;\n+\n+pub enum Entry {\n+    Files(Vec<AbsPathBuf>),\n+    Directory { path: AbsPathBuf, globs: Vec<String> },\n+}\n+\n+pub struct Config {\n+    pub load: Vec<Entry>,\n+    pub watch: Vec<usize>,\n+}\n+\n+pub enum Message {\n+    DidSwitchConfig { n_entries: usize },\n+    DidLoadAllEntries,\n+    Loaded { files: Vec<(AbsPathBuf, Option<Vec<u8>>)> },\n+}\n+\n+pub type Sender = Box<dyn Fn(Message) + Send>;\n+\n+pub trait Handle: fmt::Debug {\n+    fn spawn(sender: Sender) -> Self\n+    where\n+        Self: Sized;\n+    fn set_config(&mut self, config: Config);\n+    fn invalidate(&mut self, path: AbsPathBuf);\n+    fn load_sync(&mut self, path: &AbsPathBuf) -> Option<Vec<u8>>;\n+}\n+\n+impl Entry {\n+    pub fn rs_files_recursively(base: AbsPathBuf) -> Entry {\n+        Entry::Directory { path: base, globs: globs(&[\"*.rs\"]) }\n+    }\n+    pub fn local_cargo_package(base: AbsPathBuf) -> Entry {\n+        Entry::Directory { path: base, globs: globs(&[\"*.rs\", \"!/target/\"]) }\n+    }\n+    pub fn cargo_package_dependency(base: AbsPathBuf) -> Entry {\n+        Entry::Directory {\n+            path: base,\n+            globs: globs(&[\"*.rs\", \"!/tests/\", \"!/examples/\", \"!/benches/\"]),\n+        }\n+    }\n+}\n+\n+fn globs(globs: &[&str]) -> Vec<String> {\n+    globs.iter().map(|it| it.to_string()).collect()\n+}\n+\n+impl fmt::Debug for Message {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Message::Loaded { files } => {\n+                f.debug_struct(\"Loaded\").field(\"n_files\", &files.len()).finish()\n+            }\n+            Message::DidSwitchConfig { n_entries } => {\n+                f.debug_struct(\"DidSwitchConfig\").field(\"n_entries\", n_entries).finish()\n+            }\n+            Message::DidLoadAllEntries => f.debug_struct(\"DidLoadAllEntries\").finish(),\n+        }\n+    }\n+}\n+\n+#[test]\n+fn handle_is_object_safe() {\n+    fn _assert(_: &dyn Handle) {}\n+}"}, {"sha": "4f70d61e806b9a0dc5d72cba594ae6e2c81d560e", "filename": "crates/vfs/src/path_interner.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Fpath_interner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Fpath_interner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fpath_interner.rs?ref=6b2175878da09feeb0eafc6287eb939e837e14dc", "patch": "@@ -0,0 +1,31 @@\n+//! Maps paths to compact integer ids. We don't care about clearings paths which\n+//! no longer exist -- the assumption is total size of paths we ever look at is\n+//! not too big.\n+use rustc_hash::FxHashMap;\n+\n+use crate::{FileId, VfsPath};\n+\n+#[derive(Default)]\n+pub(crate) struct PathInterner {\n+    map: FxHashMap<VfsPath, FileId>,\n+    vec: Vec<VfsPath>,\n+}\n+\n+impl PathInterner {\n+    pub(crate) fn get(&self, path: &VfsPath) -> Option<FileId> {\n+        self.map.get(path).copied()\n+    }\n+    pub(crate) fn intern(&mut self, path: VfsPath) -> FileId {\n+        if let Some(id) = self.get(&path) {\n+            return id;\n+        }\n+        let id = FileId(self.vec.len() as u32);\n+        self.map.insert(path.clone(), id);\n+        self.vec.push(path);\n+        id\n+    }\n+\n+    pub(crate) fn lookup(&self, id: FileId) -> &VfsPath {\n+        &self.vec[id.0 as usize]\n+    }\n+}"}, {"sha": "de5dc0bf34808717403ca9be5a33b9683c733b64", "filename": "crates/vfs/src/vfs_path.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=6b2175878da09feeb0eafc6287eb939e837e14dc", "patch": "@@ -0,0 +1,49 @@\n+//! Abstract-ish representation of paths for VFS.\n+use std::fmt;\n+\n+use paths::{AbsPath, AbsPathBuf};\n+\n+/// Long-term, we want to support files which do not reside in the file-system,\n+/// so we treat VfsPaths as opaque identifiers.\n+#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n+pub struct VfsPath(VfsPathRepr);\n+\n+impl VfsPath {\n+    pub fn as_path(&self) -> Option<&AbsPath> {\n+        match &self.0 {\n+            VfsPathRepr::PathBuf(it) => Some(it.as_path()),\n+        }\n+    }\n+    pub fn join(&self, path: &str) -> VfsPath {\n+        match &self.0 {\n+            VfsPathRepr::PathBuf(it) => {\n+                let res = it.join(path).normalize();\n+                VfsPath(VfsPathRepr::PathBuf(res))\n+            }\n+        }\n+    }\n+    pub fn pop(&mut self) -> bool {\n+        match &mut self.0 {\n+            VfsPathRepr::PathBuf(it) => it.pop(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n+enum VfsPathRepr {\n+    PathBuf(AbsPathBuf),\n+}\n+\n+impl From<AbsPathBuf> for VfsPath {\n+    fn from(v: AbsPathBuf) -> Self {\n+        VfsPath(VfsPathRepr::PathBuf(v))\n+    }\n+}\n+\n+impl fmt::Display for VfsPath {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match &self.0 {\n+            VfsPathRepr::PathBuf(it) => fmt::Display::fmt(&it.display(), f),\n+        }\n+    }\n+}"}, {"sha": "13e59e3f3435252001a7386f26da8f40ba332110", "filename": "crates/vfs/src/walkdir_loader.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Fwalkdir_loader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2175878da09feeb0eafc6287eb939e837e14dc/crates%2Fvfs%2Fsrc%2Fwalkdir_loader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fwalkdir_loader.rs?ref=6b2175878da09feeb0eafc6287eb939e837e14dc", "patch": "@@ -0,0 +1,108 @@\n+//! A walkdir-based implementation of `loader::Handle`, which doesn't try to\n+//! watch files.\n+use std::convert::TryFrom;\n+\n+use globset::{Glob, GlobSetBuilder};\n+use paths::{AbsPath, AbsPathBuf};\n+use walkdir::WalkDir;\n+\n+use crate::loader;\n+\n+#[derive(Debug)]\n+pub struct WalkdirLoaderHandle {\n+    // Relative order of fields below is significant.\n+    sender: crossbeam_channel::Sender<Message>,\n+    _thread: jod_thread::JoinHandle,\n+}\n+\n+enum Message {\n+    Config(loader::Config),\n+    Invalidate(AbsPathBuf),\n+}\n+\n+impl loader::Handle for WalkdirLoaderHandle {\n+    fn spawn(sender: loader::Sender) -> WalkdirLoaderHandle {\n+        let actor = WalkdirLoaderActor { sender };\n+        let (sender, receiver) = crossbeam_channel::unbounded::<Message>();\n+        let thread = jod_thread::spawn(move || actor.run(receiver));\n+        WalkdirLoaderHandle { sender, _thread: thread }\n+    }\n+    fn set_config(&mut self, config: loader::Config) {\n+        self.sender.send(Message::Config(config)).unwrap()\n+    }\n+    fn invalidate(&mut self, path: AbsPathBuf) {\n+        self.sender.send(Message::Invalidate(path)).unwrap();\n+    }\n+    fn load_sync(&mut self, path: &AbsPathBuf) -> Option<Vec<u8>> {\n+        read(path)\n+    }\n+}\n+\n+struct WalkdirLoaderActor {\n+    sender: loader::Sender,\n+}\n+\n+impl WalkdirLoaderActor {\n+    fn run(mut self, receiver: crossbeam_channel::Receiver<Message>) {\n+        for msg in receiver {\n+            match msg {\n+                Message::Config(config) => {\n+                    self.send(loader::Message::DidSwitchConfig { n_entries: config.load.len() });\n+                    for entry in config.load.into_iter() {\n+                        let files = self.load_entry(entry);\n+                        self.send(loader::Message::Loaded { files });\n+                    }\n+                    drop(config.watch);\n+                    self.send(loader::Message::DidLoadAllEntries);\n+                }\n+                Message::Invalidate(path) => {\n+                    let contents = read(path.as_path());\n+                    let files = vec![(path, contents)];\n+                    self.send(loader::Message::Loaded { files });\n+                }\n+            }\n+        }\n+    }\n+    fn load_entry(&mut self, entry: loader::Entry) -> Vec<(AbsPathBuf, Option<Vec<u8>>)> {\n+        match entry {\n+            loader::Entry::Files(files) => files\n+                .into_iter()\n+                .map(|file| {\n+                    let contents = read(file.as_path());\n+                    (file, contents)\n+                })\n+                .collect::<Vec<_>>(),\n+            loader::Entry::Directory { path, globs } => {\n+                let globset = {\n+                    let mut builder = GlobSetBuilder::new();\n+                    for glob in &globs {\n+                        builder.add(Glob::new(glob).unwrap());\n+                    }\n+                    builder.build().unwrap()\n+                };\n+\n+                let files = WalkDir::new(path)\n+                    .into_iter()\n+                    .filter_map(|it| it.ok())\n+                    .filter(|it| it.file_type().is_file())\n+                    .map(|it| it.into_path())\n+                    .map(|it| AbsPathBuf::try_from(it).unwrap())\n+                    .filter(|it| globset.is_match(&it));\n+\n+                files\n+                    .map(|file| {\n+                        let contents = read(file.as_path());\n+                        (file, contents)\n+                    })\n+                    .collect()\n+            }\n+        }\n+    }\n+    fn send(&mut self, msg: loader::Message) {\n+        (self.sender)(msg)\n+    }\n+}\n+\n+fn read(path: &AbsPath) -> Option<Vec<u8>> {\n+    std::fs::read(path).ok()\n+}"}]}