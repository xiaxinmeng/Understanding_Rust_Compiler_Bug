{"sha": "b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7", "node_id": "C_kwDOAAsO6NoAKGI3OWFkNTdhZDdkYWU4MWUyN2ZiMzdiOGM3MDNkYzRlNGFjZGI3YTc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-15T10:15:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-15T10:15:32Z"}, "message": "Rollup merge of #102998 - nathanwhit:let-chains-drop-order, r=eholk\n\nDrop temporaries created in a condition, even if it's a let chain\n\nFixes #100513.\n\nDuring the lowering from AST to HIR we wrap expressions acting as conditions in a `DropTemps` expression so that any temporaries created in the condition are dropped after the condition is executed. Effectively this means we transform\n\n```rust\nif Some(1).is_some() { .. }\n```\n\ninto (roughly)\n\n```rust\nif { let _t = Some(1).is_some(); _t } { .. }\n```\n\nso that if we create any temporaries, they're lifted into the new scope surrounding the condition, so for example something along the lines of\n\n```rust\nif { let temp = Some(1); let _t = temp.is_some(); _t }.\n```\n\nBefore this PR, if the condition contained any let expressions we would not introduce that new scope, instead leaving the condition alone. This meant that in a let-chain like\n\n```rust\nif get_drop(\"first\").is_some() && let None = get_drop(\"last\") {\n        println!(\"second\");\n} else { .. }\n```\n\nthe temporary created for `get_drop(\"first\")` would be lifted into the _surrounding block_, which caused it to be dropped after the execution of the entire `if` expression.\n\nAfter this PR, we wrap everything but the `let` expression in terminating scopes. The upside to this solution is that it's minimally invasive, but the downside is that in the worst case, an expression with `let` exprs interspersed like\n\n```rust\nif get_drop(\"first\").is_some()\n    && let Some(_a) = get_drop(\"fifth\")\n    && get_drop(\"second\").is_some()\n    && let Some(_b) = get_drop(\"fourth\") { .. }\n```\n\ngets _multiple_ new scopes, roughly\n\n```rust\nif { let _t = get_drop(\"first\").is_some(); _t }\n    && let Some(_a) = get_drop(\"fifth\")\n    && { let _t = get_drop(\"second\").is_some(); _t }\n    && let Some(_b) = get_drop(\"fourth\") { .. }\n```\n\nso instead of all of the temporaries being dropped at the end of the entire condition, they will be dropped right after they're evaluated (before the subsequent `let` expr). So while I'd say the drop behavior around let-chains is _less_ surprising after this PR, it still might not exactly match what people might expect.\n\nFor tests, I've just extended the drop order tests added in #100526. I'm not sure if that's the best way to go about it, though, so suggestions are welcome.", "tree": {"sha": "4fa9d32dfad33dd1b35e15ce4dc96a28b3aa67c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fa9d32dfad33dd1b35e15ce4dc96a28b3aa67c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjSohECRBK7hj4Ov3rIwAAX/0IAAR/4puWiT/DMkvR2bFiPied\nQCJsVlvjzVFvVElM49ebIGTRXh0aF90kcFbKc/u8jUyl8EJ2lVAZ2+rXbJQLGaKK\n44GJAnQT6NszsjMsS+rP1LlAcOXgW2yyWHtM17mto+N02x+NvQEcYW7u8AL7sevJ\nxvVox37tQ96s90WjfWk/TTViRZMGBspbSxRgrPAGvweAEsJGULo5Sc4tRdn3N+J8\nB/YORJL32PQy8lGtAXx5/EqQmRPlhkEP/bQ9cHmKHvzmBP1B02iNyKgBqYCgZL0u\nRIU9p8TvGpZDP+dhidVtSTdEjj7rFjnUCVpHbVuk++GsifvOfuRTINm+35MKVIU=\n=0pil\n-----END PGP SIGNATURE-----\n", "payload": "tree 4fa9d32dfad33dd1b35e15ce4dc96a28b3aa67c1\nparent 59e0af68ab42c2c0b98b7e943ecfe01a36d90a94\nparent 4e1c09dcd64507c03ded02844c1e5022031b9e38\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1665828932 +0530\ncommitter GitHub <noreply@github.com> 1665828932 +0530\n\nRollup merge of #102998 - nathanwhit:let-chains-drop-order, r=eholk\n\nDrop temporaries created in a condition, even if it's a let chain\n\nFixes #100513.\n\nDuring the lowering from AST to HIR we wrap expressions acting as conditions in a `DropTemps` expression so that any temporaries created in the condition are dropped after the condition is executed. Effectively this means we transform\n\n```rust\nif Some(1).is_some() { .. }\n```\n\ninto (roughly)\n\n```rust\nif { let _t = Some(1).is_some(); _t } { .. }\n```\n\nso that if we create any temporaries, they're lifted into the new scope surrounding the condition, so for example something along the lines of\n\n```rust\nif { let temp = Some(1); let _t = temp.is_some(); _t }.\n```\n\nBefore this PR, if the condition contained any let expressions we would not introduce that new scope, instead leaving the condition alone. This meant that in a let-chain like\n\n```rust\nif get_drop(\"first\").is_some() && let None = get_drop(\"last\") {\n        println!(\"second\");\n} else { .. }\n```\n\nthe temporary created for `get_drop(\"first\")` would be lifted into the _surrounding block_, which caused it to be dropped after the execution of the entire `if` expression.\n\nAfter this PR, we wrap everything but the `let` expression in terminating scopes. The upside to this solution is that it's minimally invasive, but the downside is that in the worst case, an expression with `let` exprs interspersed like\n\n```rust\nif get_drop(\"first\").is_some()\n    && let Some(_a) = get_drop(\"fifth\")\n    && get_drop(\"second\").is_some()\n    && let Some(_b) = get_drop(\"fourth\") { .. }\n```\n\ngets _multiple_ new scopes, roughly\n\n```rust\nif { let _t = get_drop(\"first\").is_some(); _t }\n    && let Some(_a) = get_drop(\"fifth\")\n    && { let _t = get_drop(\"second\").is_some(); _t }\n    && let Some(_b) = get_drop(\"fourth\") { .. }\n```\n\nso instead of all of the temporaries being dropped at the end of the entire condition, they will be dropped right after they're evaluated (before the subsequent `let` expr). So while I'd say the drop behavior around let-chains is _less_ surprising after this PR, it still might not exactly match what people might expect.\n\nFor tests, I've just extended the drop order tests added in #100526. I'm not sure if that's the best way to go about it, though, so suggestions are welcome.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7", "html_url": "https://github.com/rust-lang/rust/commit/b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59e0af68ab42c2c0b98b7e943ecfe01a36d90a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/59e0af68ab42c2c0b98b7e943ecfe01a36d90a94", "html_url": "https://github.com/rust-lang/rust/commit/59e0af68ab42c2c0b98b7e943ecfe01a36d90a94"}, {"sha": "4e1c09dcd64507c03ded02844c1e5022031b9e38", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e1c09dcd64507c03ded02844c1e5022031b9e38", "html_url": "https://github.com/rust-lang/rust/commit/4e1c09dcd64507c03ded02844c1e5022031b9e38"}], "stats": {"total": 129, "additions": 109, "deletions": 20}, "files": [{"sha": "ec9c3935020566aee76eeef1bf82fc9092125762", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7", "patch": "@@ -387,32 +387,58 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         then: &Block,\n         else_opt: Option<&Expr>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.lower_expr(cond);\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let lowered_cond = self.lower_cond(cond);\n         let then_expr = self.lower_block_expr(then);\n         if let Some(rslt) = else_opt {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), Some(self.lower_expr(rslt)))\n+            hir::ExprKind::If(\n+                lowered_cond,\n+                self.arena.alloc(then_expr),\n+                Some(self.lower_expr(rslt)),\n+            )\n         } else {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), None)\n+            hir::ExprKind::If(lowered_cond, self.arena.alloc(then_expr), None)\n         }\n     }\n \n-    // If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`\n-    // in a temporary block.\n-    fn manage_let_cond(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n-        fn has_let_expr<'hir>(expr: &'hir hir::Expr<'hir>) -> bool {\n-            match expr.kind {\n-                hir::ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n-                hir::ExprKind::Let(..) => true,\n+    // Lowers a condition (i.e. `cond` in `if cond` or `while cond`), wrapping it in a terminating scope\n+    // so that temporaries created in the condition don't live beyond it.\n+    fn lower_cond(&mut self, cond: &Expr) -> &'hir hir::Expr<'hir> {\n+        fn has_let_expr(expr: &Expr) -> bool {\n+            match &expr.kind {\n+                ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                ExprKind::Let(..) => true,\n                 _ => false,\n             }\n         }\n-        if has_let_expr(cond) {\n-            cond\n-        } else {\n-            let reason = DesugaringKind::CondTemporary;\n-            let span_block = self.mark_span_with_reason(reason, cond.span, None);\n-            self.expr_drop_temps(span_block, cond, AttrVec::new())\n+\n+        // We have to take special care for `let` exprs in the condition, e.g. in\n+        // `if let pat = val` or `if foo && let pat = val`, as we _do_ want `val` to live beyond the\n+        // condition in this case.\n+        //\n+        // In order to mantain the drop behavior for the non `let` parts of the condition,\n+        // we still wrap them in terminating scopes, e.g. `if foo && let pat = val` essentially\n+        // gets transformed into `if { let _t = foo; _t } && let pat = val`\n+        match &cond.kind {\n+            ExprKind::Binary(op @ Spanned { node: ast::BinOpKind::And, .. }, lhs, rhs)\n+                if has_let_expr(cond) =>\n+            {\n+                let op = self.lower_binop(*op);\n+                let lhs = self.lower_cond(lhs);\n+                let rhs = self.lower_cond(rhs);\n+\n+                self.arena.alloc(self.expr(\n+                    cond.span,\n+                    hir::ExprKind::Binary(op, lhs, rhs),\n+                    AttrVec::new(),\n+                ))\n+            }\n+            ExprKind::Let(..) => self.lower_expr(cond),\n+            _ => {\n+                let cond = self.lower_expr(cond);\n+                let reason = DesugaringKind::CondTemporary;\n+                let span_block = self.mark_span_with_reason(reason, cond.span, None);\n+                self.expr_drop_temps(span_block, cond, AttrVec::new())\n+            }\n         }\n     }\n \n@@ -439,14 +465,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_cond(cond));\n         let then = self.lower_block_expr(body);\n         let expr_break = self.expr_break(span, AttrVec::new());\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n         let else_expr = self.arena.alloc(self.expr_block(else_blk, AttrVec::new()));\n-        let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));\n+        let if_kind = hir::ExprKind::If(lowered_cond, self.arena.alloc(then), Some(else_expr));\n         let if_expr = self.expr(span, if_kind, AttrVec::new());\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));"}, {"sha": "ba1ac53aa7ce8a1c33138307ba83e617b57c9199", "filename": "src/test/ui/drop/drop_order.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs?ref=b79ad57ad7dae81e27fb37b8c703dc4e4acdb7a7", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+// compile-flags: -Z validate-mir\n+#![feature(let_chains)]\n \n use std::cell::RefCell;\n use std::convert::TryInto;\n@@ -116,6 +118,58 @@ impl DropOrderCollector {\n         }\n     }\n \n+    fn let_chain(&self) {\n+        // take the \"then\" branch\n+        if self.option_loud_drop(2).is_some() // 2\n+            && self.option_loud_drop(1).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(4) { // 4\n+            self.print(3); // 3\n+        }\n+\n+        // take the \"else\" branch\n+        if self.option_loud_drop(6).is_some() // 2\n+            && self.option_loud_drop(5).is_some() // 1\n+            && let None = self.option_loud_drop(7) { // 3\n+            unreachable!();\n+        } else {\n+            self.print(8); // 4\n+        }\n+\n+        // let exprs interspersed\n+        if self.option_loud_drop(9).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(13) // 5\n+            && self.option_loud_drop(10).is_some() // 2\n+            && let Some(_e) = self.option_loud_drop(12) { // 4\n+            self.print(11); // 3\n+        }\n+\n+        // let exprs first\n+        if let Some(_d) = self.option_loud_drop(18) // 5\n+            && let Some(_e) = self.option_loud_drop(17) // 4\n+            && self.option_loud_drop(14).is_some() // 1\n+            && self.option_loud_drop(15).is_some() { // 2\n+                self.print(16); // 3\n+            }\n+\n+        // let exprs last\n+        if self.option_loud_drop(20).is_some() // 2\n+            && self.option_loud_drop(19).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(23) // 5\n+            && let Some(_e) = self.option_loud_drop(22) { // 4\n+                self.print(21); // 3\n+        }\n+    }\n+\n+    fn while_(&self) {\n+        let mut v = self.option_loud_drop(4);\n+        while let Some(_d) = v\n+            && self.option_loud_drop(1).is_some()\n+            && self.option_loud_drop(2).is_some() {\n+            self.print(3);\n+            v = None;\n+        }\n+    }\n+\n     fn assert_sorted(self) {\n         assert!(\n             self.0\n@@ -142,4 +196,14 @@ fn main() {\n     let collector = DropOrderCollector::default();\n     collector.match_();\n     collector.assert_sorted();\n+\n+    println!(\"-- let chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.let_chain();\n+    collector.assert_sorted();\n+\n+    println!(\"-- while --\");\n+    let collector = DropOrderCollector::default();\n+    collector.while_();\n+    collector.assert_sorted();\n }"}]}