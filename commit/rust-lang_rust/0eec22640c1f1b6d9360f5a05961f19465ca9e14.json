{"sha": "0eec22640c1f1b6d9360f5a05961f19465ca9e14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZWMyMjY0MGMxZjFiNmQ5MzYwZjVhMDU5NjFmMTk0NjVjYTllMTQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-02-04T16:42:32Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-02-06T20:24:06Z"}, "message": "debuginfo: Implement direct debuginfo source location application for ICmp, FCmp, and CallWithConv.", "tree": {"sha": "ec23bb6c3bc9361a5d0b7ab393b63d80bc9d9bac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec23bb6c3bc9361a5d0b7ab393b63d80bc9d9bac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eec22640c1f1b6d9360f5a05961f19465ca9e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eec22640c1f1b6d9360f5a05961f19465ca9e14", "html_url": "https://github.com/rust-lang/rust/commit/0eec22640c1f1b6d9360f5a05961f19465ca9e14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eec22640c1f1b6d9360f5a05961f19465ca9e14/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d98d50832c8520e7e0284c4d199b305ec0066de2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d98d50832c8520e7e0284c4d199b305ec0066de2", "html_url": "https://github.com/rust-lang/rust/commit/d98d50832c8520e7e0284c4d199b305ec0066de2"}], "stats": {"total": 157, "additions": 112, "deletions": 45}, "files": [{"sha": "feea8282f3995a5a36273de71330eff1b7214c5c", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -819,7 +819,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n-        let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq);\n+        let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq, debug_loc);\n         return Result::new(rs.bcx, rs.val);\n     }\n \n@@ -1149,17 +1149,28 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             RangeResult(Result { val: vbegin, .. },\n                                         Result { bcx, val: vend }) => {\n                                 let Result { bcx, val: llge } =\n-                                    compare_scalar_types(\n-                                    bcx, test_val,\n-                                    vbegin, t, ast::BiGe);\n+                                    compare_scalar_types(bcx,\n+                                                         test_val,\n+                                                         vbegin,\n+                                                         t,\n+                                                         ast::BiGe,\n+                                                         debug_loc);\n                                 let Result { bcx, val: llle } =\n-                                    compare_scalar_types(\n-                                    bcx, test_val, vend,\n-                                    t, ast::BiLe);\n+                                    compare_scalar_types(bcx,\n+                                                         test_val,\n+                                                         vend,\n+                                                         t,\n+                                                         ast::BiLe,\n+                                                         debug_loc);\n                                 Result::new(bcx, And(bcx, llge, llle, debug_loc))\n                             }\n                             LowerBound(Result { bcx, val }) => {\n-                                compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n+                                compare_scalar_types(bcx,\n+                                                     test_val,\n+                                                     val,\n+                                                     t,\n+                                                     ast::BiGe,\n+                                                     debug_loc)\n                             }\n                         }\n                     };"}, {"sha": "8bb60eca8b14a12e1af6f3b8a7d6709c755d0649", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -751,7 +751,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         RawNullablePointer { nndiscr, nnty, .. } =>  {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n-            val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty));\n+            val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty), DebugLoc::None);\n             signed = false;\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n@@ -770,7 +770,7 @@ fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &Disc\n     let llptrptr = GEPi(bcx, scrutinee, &discrfield[]);\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-    ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n+    ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)), DebugLoc::None)\n }\n \n /// Helper for cases where the discriminant is simply loaded."}, {"sha": "0aef00e69e355f89cc3930e07a4278917d82159c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -66,7 +66,7 @@ use trans::consts;\n use trans::context::SharedCrateContext;\n use trans::controlflow;\n use trans::datum;\n-use trans::debuginfo::{self, DebugLoc};\n+use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::foreign;\n use trans::glue;\n@@ -540,9 +540,10 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n                                         t: Ty<'tcx>,\n-                                        op: ast::BinOp_)\n+                                        op: ast::BinOp_,\n+                                        debug_loc: DebugLoc)\n                                         -> Result<'blk, 'tcx> {\n-    let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n+    let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op, debug_loc));\n \n     match t.sty {\n         ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n@@ -561,7 +562,8 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                          lhs: ValueRef,\n                                          rhs: ValueRef,\n                                          nt: scalar_type,\n-                                         op: ast::BinOp_)\n+                                         op: ast::BinOp_,\n+                                         debug_loc: DebugLoc)\n                                          -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: Block) -> ! {\n@@ -588,7 +590,7 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n           ast::BiGe => llvm::RealOGE,\n           _ => die(cx)\n         };\n-        return FCmp(cx, cmp, lhs, rhs);\n+        return FCmp(cx, cmp, lhs, rhs, debug_loc);\n       }\n       signed_int => {\n         let cmp = match op {\n@@ -600,7 +602,7 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n           ast::BiGe => llvm::IntSGE,\n           _ => die(cx)\n         };\n-        return ICmp(cx, cmp, lhs, rhs);\n+        return ICmp(cx, cmp, lhs, rhs, debug_loc);\n       }\n       unsigned_int => {\n         let cmp = match op {\n@@ -612,7 +614,7 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n           ast::BiGe => llvm::IntUGE,\n           _ => die(cx)\n         };\n-        return ICmp(cx, cmp, lhs, rhs);\n+        return ICmp(cx, cmp, lhs, rhs, debug_loc);\n       }\n     }\n }\n@@ -623,7 +625,8 @@ pub fn compare_simd_types<'blk, 'tcx>(\n                     rhs: ValueRef,\n                     t: Ty<'tcx>,\n                     size: uint,\n-                    op: ast::BinOp)\n+                    op: ast::BinOp_,\n+                    debug_loc: DebugLoc)\n                     -> ValueRef {\n     let cmp = match t.sty {\n         ty::ty_float(_) => {\n@@ -634,7 +637,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n             cx.sess().bug(\"compare_simd_types: comparison operators \\\n                            not supported for floating point SIMD types\")\n         },\n-        ty::ty_uint(_) => match op.node {\n+        ty::ty_uint(_) => match op {\n             ast::BiEq => llvm::IntEQ,\n             ast::BiNe => llvm::IntNE,\n             ast::BiLt => llvm::IntULT,\n@@ -643,7 +646,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n             ast::BiGe => llvm::IntUGE,\n             _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n         },\n-        ty::ty_int(_) => match op.node {\n+        ty::ty_int(_) => match op {\n             ast::BiEq => llvm::IntEQ,\n             ast::BiNe => llvm::IntNE,\n             ast::BiLt => llvm::IntSLT,\n@@ -659,7 +662,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n     // by the target architecture.\n-    SExt(cx, ICmp(cx, cmp, lhs, rhs), return_ty)\n+    SExt(cx, ICmp(cx, cmp, lhs, rhs, debug_loc), return_ty)\n }\n \n // Iterates through the elements of a structural type.\n@@ -866,14 +869,16 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         (\"attempted remainder with a divisor of zero\",\n          \"attempted remainder with overflow\")\n     };\n+    let debug_loc = call_info.debug_loc();\n+\n     let (is_zero, is_signed) = match rhs_t.sty {\n         ty::ty_int(t) => {\n             let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n-            (ICmp(cx, llvm::IntEQ, rhs, zero), true)\n+            (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), true)\n         }\n         ty::ty_uint(t) => {\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, false);\n-            (ICmp(cx, llvm::IntEQ, rhs, zero), false)\n+            (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n         }\n         _ => {\n             cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n@@ -910,10 +915,10 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             _ => unreachable!(),\n         };\n         let minus_one = ICmp(bcx, llvm::IntEQ, rhs,\n-                             C_integral(llty, -1, false));\n+                             C_integral(llty, -1, false), debug_loc);\n         with_cond(bcx, minus_one, |bcx| {\n             let is_min = ICmp(bcx, llvm::IntEQ, lhs,\n-                              C_integral(llty, min, true));\n+                              C_integral(llty, min, true), debug_loc);\n             with_cond(bcx, is_min, |bcx| {\n                 controlflow::trans_fail(bcx,\n                                         call_info,"}, {"sha": "2fcfc5e43931d2770391bde8b4c03e92b6505954", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -856,22 +856,32 @@ pub fn FPCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n \n \n /* Comparisons */\n-pub fn ICmp(cx: Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n-     -> ValueRef {\n+pub fn ICmp(cx: Block,\n+            op: IntPredicate,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).icmp(op, lhs, rhs)\n     }\n }\n \n-pub fn FCmp(cx: Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n-     -> ValueRef {\n+pub fn FCmp(cx: Block,\n+            op: RealPredicate,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).fcmp(op, lhs, rhs)\n     }\n }\n@@ -941,9 +951,17 @@ pub fn Call(cx: Block,\n     B(cx).call(fn_, args, attributes)\n }\n \n-pub fn CallWithConv(cx: Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n-                    attributes: Option<AttrBuilder>) -> ValueRef {\n-    if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n+pub fn CallWithConv(cx: Block,\n+                    fn_: ValueRef,\n+                    args: &[ValueRef],\n+                    conv: CallConv,\n+                    attributes: Option<AttrBuilder>,\n+                    debug_loc: DebugLoc)\n+                    -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _UndefReturn(cx, fn_);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).call_with_conv(fn_, args, conv, attributes)\n }\n "}, {"sha": "e45918ce5a7455998131deae030462b578f89512", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -827,9 +827,13 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                          abi);\n         fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n-        bcx = foreign::trans_native_call(bcx, callee_ty,\n-                                         llfn, opt_llretslot.unwrap(),\n-                                         &llargs[], arg_tys);\n+        bcx = foreign::trans_native_call(bcx,\n+                                         callee_ty,\n+                                         llfn,\n+                                         opt_llretslot.unwrap(),\n+                                         &llargs[],\n+                                         arg_tys,\n+                                         debug_loc);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);"}, {"sha": "9ea7a276d97c657453dcd8b0e9a19107c26db480", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -696,6 +696,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n \n+    let index_expr_debug_loc = index_expr.debug_loc();\n+\n     // Check for overloaded index.\n     let method_ty = ccx.tcx()\n                        .method_map\n@@ -778,13 +780,17 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debug!(\"trans_index: base {}\", bcx.val_to_string(base));\n             debug!(\"trans_index: len {}\", bcx.val_to_string(len));\n \n-            let bounds_check = ICmp(bcx, llvm::IntUGE, ix_val, len);\n+            let bounds_check = ICmp(bcx,\n+                                    llvm::IntUGE,\n+                                    ix_val,\n+                                    len,\n+                                    index_expr_debug_loc);\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n             let expected = Call(bcx,\n                                 expect,\n                                 &[bounds_check, C_bool(ccx, false)],\n                                 None,\n-                                index_expr.debug_loc());\n+                                index_expr_debug_loc);\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n                                                      expr_info(index_expr),\n@@ -1744,9 +1750,21 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_scalar(rhs_t) {\n-            unpack_result!(bcx, base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op.node))\n+            unpack_result!(bcx,\n+                           base::compare_scalar_types(bcx,\n+                                                      lhs,\n+                                                      rhs,\n+                                                      rhs_t,\n+                                                      op.node,\n+                                                      binop_debug_loc))\n         } else if is_simd {\n-            base::compare_simd_types(bcx, lhs, rhs, intype, ty::simd_size(tcx, lhs_t), op)\n+            base::compare_simd_types(bcx,\n+                                     lhs,\n+                                     rhs,\n+                                     intype,\n+                                     ty::simd_size(tcx, lhs_t),\n+                                     op.node,\n+                                     binop_debug_loc)\n         } else {\n             bcx.tcx().sess.span_bug(binop_expr.span, \"comparison operator unsupported for type\")\n         }"}, {"sha": "7844594a24d13b9f5a9bffa65e696b35159da49b", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -18,6 +18,7 @@ use trans::base;\n use trans::build::*;\n use trans::cabi;\n use trans::common::*;\n+use trans::debuginfo::DebugLoc;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -218,7 +219,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      llfn: ValueRef,\n                                      llretptr: ValueRef,\n                                      llargs_rust: &[ValueRef],\n-                                     passed_arg_tys: Vec<Ty<'tcx>>)\n+                                     passed_arg_tys: Vec<Ty<'tcx>>,\n+                                     call_debug_loc: DebugLoc)\n                                      -> Block<'blk, 'tcx>\n {\n     let ccx = bcx.ccx();\n@@ -370,7 +372,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         llfn,\n                                         &llargs_foreign[],\n                                         cc,\n-                                        Some(attrs));\n+                                        Some(attrs),\n+                                        call_debug_loc);\n \n     // If the function we just called does not use an outpointer,\n     // store the result into the rust outpointer. Cast the outpointer"}, {"sha": "8cf9a51b3bfd9ec6f74c7303fd2c3700e681ad9c", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -342,7 +342,11 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             // Return the sum of sizes and max of aligns.\n             let size = Add(bcx, sized_size, unsized_size, DebugLoc::None);\n             let align = Select(bcx,\n-                               ICmp(bcx, llvm::IntULT, sized_align, unsized_align),\n+                               ICmp(bcx,\n+                                    llvm::IntULT,\n+                                    sized_align,\n+                                    unsized_align,\n+                                    DebugLoc::None),\n                                sized_align,\n                                unsized_align);\n             (size, align)"}, {"sha": "441a5e899ff62ddca57a6ef1056dc8783234e198", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eec22640c1f1b6d9360f5a05961f19465ca9e14/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=0eec22640c1f1b6d9360f5a05961f19465ca9e14", "patch": "@@ -73,7 +73,11 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let unit_size = llsize_of_alloc(ccx, llty);\n             if unit_size != 0 {\n                 let len = get_len(bcx, vptr);\n-                let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0us));\n+                let not_empty = ICmp(bcx,\n+                                     llvm::IntNE,\n+                                     len,\n+                                     C_uint(ccx, 0us),\n+                                     DebugLoc::None);\n                 with_cond(bcx, not_empty, |bcx| {\n                     let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n                     let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n@@ -443,7 +447,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     { // i < count\n         let lhs = Load(cond_bcx, loop_counter);\n         let rhs = count;\n-        let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs);\n+        let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs, DebugLoc::None);\n \n         CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n     }\n@@ -497,7 +501,7 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let data_ptr =\n             Phi(header_bcx, val_ty(data_ptr), &[data_ptr], &[bcx.llbb]);\n         let not_yet_at_end =\n-            ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr);\n+            ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr, DebugLoc::None);\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);"}]}