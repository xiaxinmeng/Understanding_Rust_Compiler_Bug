{"sha": "aa38867e4e7da648a85985251f542bee12a64095", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMzg4NjdlNGU3ZGE2NDhhODU5ODUyNTFmNTQyYmVlMTJhNjQwOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-27T20:09:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-27T20:09:35Z"}, "message": "auto merge of #6071 : bjz/rust/numeric-traits, r=graydon\n\nAs part of the numeric trait reform (see issue #4819), I have added the following traits to `core::num` and implemented them for Rust's primitive numeric types:\r\n\r\n~~~rust\r\npub trait Bitwise: Not<Self>\r\n                 + BitAnd<Self,Self>\r\n                 + BitOr<Self,Self>\r\n                 + BitXor<Self,Self>\r\n                 + Shl<Self,Self>\r\n                 + Shr<Self,Self> {}\r\n\r\npub trait BitCount {\r\n    fn population_count(&self) -> Self;\r\n    fn leading_zeros(&self) -> Self;\r\n    fn trailing_zeros(&self) -> Self;\r\n}\r\n\r\npub trait Bounded {\r\n    fn min_value() -> Self;\r\n    fn max_value() -> Self;\r\n}\r\n\r\npub trait Primitive: Num\r\n                   + NumCast\r\n                   + Bounded\r\n                   + Neg<Self>\r\n                   + Add<Self,Self>\r\n                   + Sub<Self,Self>\r\n                   + Mul<Self,Self>\r\n                   + Quot<Self,Self>\r\n                   + Rem<Self,Self> {\r\n    fn bits() -> uint;\r\n    fn bytes() -> uint;\r\n}\r\n\r\npub trait Int: Integer\r\n             + Primitive\r\n             + Bitwise\r\n             + BitCount {}\r\n\r\npub trait Float: Real\r\n               + Signed\r\n               + Primitive {\r\n    fn NaN() -> Self;\r\n    fn infinity() -> Self;\r\n    fn neg_infinity() -> Self;\r\n    fn neg_zero() -> Self;\r\n\r\n    fn is_NaN(&self) -> bool;\r\n    fn is_infinite(&self) -> bool;\r\n    fn is_finite(&self) -> bool;\r\n\r\n    fn mantissa_digits() -> uint;\r\n    fn digits() -> uint;\r\n    fn epsilon() -> Self;\r\n    fn min_exp() -> int;\r\n    fn max_exp() -> int;\r\n    fn min_10_exp() -> int;\r\n    fn max_10_exp() -> int;\r\n\r\n    fn mul_add(&self, a: Self, b: Self) -> Self;\r\n    fn next_after(&self, other: Self) -> Self;\r\n}\r\n~~~\r\nNote: I'm not sure my implementation for `BitCount::trailing_zeros` and `BitCount::leading_zeros` is correct for uints. I also need some assistance creating appropriate unit tests for them.\r\n\r\nMore work needs to be done in implementing specialized primitive floating-point and integer methods, but I'm beginning to reach the limits of my knowledge. Please leave your suggestions/critiques/ideas on #4819 if you have them \u2013 I'd very much appreciate hearing them.\r\n\r\nI have also added an `Orderable` trait:\r\n\r\n~~~rust\r\npub trait Orderable: Ord {\r\n    fn min(&self, other: &Self) -> Self;\r\n    fn max(&self, other: &Self) -> Self;\r\n    fn clamp(&self, mn: &Self, mx: &Self) -> Self;\r\n}\r\n~~~\r\n\r\nThis is a temporary trait until we have default methods. We don't want to encumber all implementors of Ord by requiring them to implement these functions, but at the same time we want to be able to take advantage of the speed of the specific numeric functions (like the `fmin` and `fmax` intrinsics).", "tree": {"sha": "a63425d6739dc5cad3d1a09c9e63404a40545ff3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a63425d6739dc5cad3d1a09c9e63404a40545ff3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa38867e4e7da648a85985251f542bee12a64095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa38867e4e7da648a85985251f542bee12a64095", "html_url": "https://github.com/rust-lang/rust/commit/aa38867e4e7da648a85985251f542bee12a64095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa38867e4e7da648a85985251f542bee12a64095/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5de74f3e754628fa98c0cdf0b95b39f39db50e19", "url": "https://api.github.com/repos/rust-lang/rust/commits/5de74f3e754628fa98c0cdf0b95b39f39db50e19", "html_url": "https://github.com/rust-lang/rust/commit/5de74f3e754628fa98c0cdf0b95b39f39db50e19"}, {"sha": "9cdf402c80536c7e138d04433ee3f0a0855f08ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cdf402c80536c7e138d04433ee3f0a0855f08ce", "html_url": "https://github.com/rust-lang/rust/commit/9cdf402c80536c7e138d04433ee3f0a0855f08ce"}], "stats": {"total": 2570, "additions": 1722, "deletions": 848}, "files": [{"sha": "158da9a12fca1e4b5da715b5b6fe9e16840aaeeb", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -104,8 +104,11 @@ pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use iter::{ExtendedMutableIter};\n \n pub use num::{Num, NumCast};\n-pub use num::{Signed, Unsigned, Integer};\n+pub use num::{Orderable, Signed, Unsigned, Integer};\n pub use num::{Round, Fractional, Real, RealExt};\n+pub use num::{Bitwise, BitCount, Bounded};\n+pub use num::{Primitive, Int, Float};\n+\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "30b0c54dc2dc212124199b385619820f06545c73", "filename": "src/libcore/num/cmath.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fcmath.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -47,7 +47,8 @@ pub mod c_double_utils {\n         unsafe fn fmax(a: c_double, b: c_double) -> c_double;\n         #[link_name=\"fmin\"]\n         unsafe fn fmin(a: c_double, b: c_double) -> c_double;\n-        unsafe fn nextafter(x: c_double, y: c_double) -> c_double;\n+        #[link_name=\"nextafter\"]\n+        unsafe fn next_after(x: c_double, y: c_double) -> c_double;\n         unsafe fn frexp(n: c_double, value: &mut c_int) -> c_double;\n         unsafe fn hypot(x: c_double, y: c_double) -> c_double;\n         unsafe fn ldexp(x: c_double, n: c_int) -> c_double;\n@@ -131,7 +132,7 @@ pub mod c_float_utils {\n         #[link_name=\"fminf\"]\n         unsafe fn fmin(a: c_float, b: c_float) -> c_float;\n         #[link_name=\"nextafterf\"]\n-        unsafe fn nextafter(x: c_float, y: c_float) -> c_float;\n+        unsafe fn next_after(x: c_float, y: c_float) -> c_float;\n         #[link_name=\"hypotf\"]\n         unsafe fn hypot(x: c_float, y: c_float) -> c_float;\n         #[link_name=\"ldexpf\"]"}, {"sha": "ada47fb597e5debffe7b6dd7960ec6625d657ac0", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 283, "deletions": 166, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -12,7 +12,7 @@\n \n use from_str;\n use libc::c_int;\n-use num::strconv;\n+use num::{Zero, One, strconv};\n use prelude::*;\n \n pub use cmath::c_float_targ_consts::*;\n@@ -88,7 +88,7 @@ delegate!(\n     fn abs_sub(a: c_float, b: c_float) -> c_float = c_float_utils::abs_sub,\n     fn fmax(a: c_float, b: c_float) -> c_float = c_float_utils::fmax,\n     fn fmin(a: c_float, b: c_float) -> c_float = c_float_utils::fmin,\n-    fn nextafter(x: c_float, y: c_float) -> c_float = c_float_utils::nextafter,\n+    fn next_after(x: c_float, y: c_float) -> c_float = c_float_utils::next_after,\n     fn frexp(n: c_float, value: &mut c_int) -> c_float = c_float_utils::frexp,\n     fn hypot(x: c_float, y: c_float) -> c_float = c_float_utils::hypot,\n     fn ldexp(x: c_float, n: c_int) -> c_float = c_float_utils::ldexp,\n@@ -114,9 +114,6 @@ pub static infinity: f32 = 1.0_f32/0.0_f32;\n \n pub static neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n-#[inline(always)]\n-pub fn is_NaN(f: f32) -> bool { f != f }\n-\n #[inline(always)]\n pub fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n@@ -154,24 +151,6 @@ pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n-/// Returns true if `x` is a zero number (positive or negative zero)\n-#[inline(always)]\n-pub fn is_zero(x: f32) -> bool {\n-    return x == 0.0f32 || x == -0.0f32;\n-}\n-\n-/// Returns true if `x`is an infinite number\n-#[inline(always)]\n-pub fn is_infinite(x: f32) -> bool {\n-    return x == infinity || x == neg_infinity;\n-}\n-\n-/// Returns true if `x`is a finite number\n-#[inline(always)]\n-pub fn is_finite(x: f32) -> bool {\n-    return !(is_NaN(x) || is_infinite(x));\n-}\n-\n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify.\n \n /* Module: consts */\n@@ -245,12 +224,40 @@ impl Ord for f32 {\n     fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n }\n \n-impl num::Zero for f32 {\n+impl Orderable for f32 {\n+    /// Returns `NaN` if either of the numbers are `NaN`.\n+    #[inline(always)]\n+    fn min(&self, other: &f32) -> f32 {\n+        if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmin(*self, *other) }\n+    }\n+\n+    /// Returns `NaN` if either of the numbers are `NaN`.\n+    #[inline(always)]\n+    fn max(&self, other: &f32) -> f32 {\n+        if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n+    }\n+\n+    /// Returns the number constrained within the range `mn <= self <= mx`.\n+    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    #[inline(always)]\n+    fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n+        if self.is_NaN() { *self }\n+        else if !(*self <= *mx) { *mx }\n+        else if !(*self >= *mn) { *mn }\n+        else { *self }\n+    }\n+}\n+\n+impl Zero for f32 {\n     #[inline(always)]\n     fn zero() -> f32 { 0.0 }\n+\n+    /// Returns true if the number is equal to either `0.0` or `-0.0`\n+    #[inline(always)]\n+    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n-impl num::One for f32 {\n+impl One for f32 {\n     #[inline(always)]\n     fn one() -> f32 { 1.0 }\n }\n@@ -306,16 +313,16 @@ impl Signed for f32 {\n     #[inline(always)]\n     fn abs(&self) -> f32 { abs(*self) }\n \n-    /**\n-     * # Returns\n-     *\n-     * - `1.0` if the number is positive, `+0.0` or `infinity`\n-     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-     * - `NaN` if the number is `NaN`\n-     */\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n+    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+    /// - `NaN` if the number is NaN\n+    ///\n     #[inline(always)]\n     fn signum(&self) -> f32 {\n-        if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n+        if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -511,52 +518,134 @@ impl Real for f32 {\n     fn tanh(&self) -> f32 { tanh(*self) }\n }\n \n-/**\n- * Section: String Conversions\n- */\n+impl Bounded for f32 {\n+    #[inline(always)]\n+    fn min_value() -> f32 { 1.17549435e-38 }\n+\n+    #[inline(always)]\n+    fn max_value() -> f32 { 3.40282347e+38 }\n+}\n+\n+impl Primitive for f32 {\n+    #[inline(always)]\n+    fn bits() -> uint { 32 }\n+\n+    #[inline(always)]\n+    fn bytes() -> uint { Primitive::bits::<f32>() / 8 }\n+}\n+\n+impl Float for f32 {\n+    #[inline(always)]\n+    fn NaN() -> f32 { 0.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn infinity() -> f32 { 1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_infinity() -> f32 { -1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_zero() -> f32 { -0.0 }\n+\n+    #[inline(always)]\n+    fn is_NaN(&self) -> bool { *self != *self }\n \n-/**\n- * Converts a float to a string\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+    #[inline(always)]\n+    fn mantissa_digits() -> uint { 24 }\n+\n+    #[inline(always)]\n+    fn digits() -> uint { 6 }\n+\n+    #[inline(always)]\n+    fn epsilon() -> f32 { 1.19209290e-07 }\n+\n+    #[inline(always)]\n+    fn min_exp() -> int { -125 }\n+\n+    #[inline(always)]\n+    fn max_exp() -> int { 128 }\n+\n+    #[inline(always)]\n+    fn min_10_exp() -> int { -37 }\n+\n+    #[inline(always)]\n+    fn max_10_exp() -> int { 38 }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline(always)]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is finite\n+    #[inline(always)]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_NaN() || self.is_infinite())\n+    }\n+\n+    ///\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n+    /// produces a more accurate result with better performance than a separate multiplication\n+    /// operation followed by an add.\n+    ///\n+    #[inline(always)]\n+    fn mul_add(&self, a: f32, b: f32) -> f32 {\n+        mul_add(*self, a, b)\n+    }\n+\n+    /// Returns the next representable floating-point value in the direction of `other`\n+    #[inline(always)]\n+    fn next_after(&self, other: f32) -> f32 {\n+        next_after(*self, other)\n+    }\n+}\n+\n+//\n+// Section: String Conversions\n+//\n+\n+///\n+/// Converts a float to a string\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in hexadecimal format\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string in hexadecimal format\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- *\n- * # Failure\n- *\n- * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n- * possible misinterpretation of the result at higher bases. If those values\n- * are expected, use `to_str_radix_special()` instead.\n- */\n+///\n+/// Converts a float to a string in a given radix\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n+/// # Failure\n+///\n+/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+/// possible misinterpretation of the result at higher bases. If those values\n+/// are expected, use `to_str_radix_special()` instead.\n+///\n #[inline(always)]\n pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n@@ -566,46 +655,46 @@ pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix, and a flag indicating\n- * whether it's a special value\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- */\n+///\n+/// Converts a float to a string in a given radix, and a flag indicating\n+/// whether it's a special value\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n #[inline(always)]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n-/**\n- * Converts a float to a string with exactly the number of\n- * provided significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with exactly the number of\n+/// provided significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n-/**\n- * Converts a float to a string with a maximum number of\n- * significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with a maximum number of\n+/// significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n@@ -625,91 +714,91 @@ impl num::ToStrRadix for f32 {\n     }\n }\n \n-/**\n- * Convert a string in base 10 to a float.\n- * Accepts a optional decimal exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * '3.14'\n- * * '+3.14', equivalent to '3.14'\n- * * '-3.14'\n- * * '2.5E10', or equivalently, '2.5e10'\n- * * '2.5E-10'\n- * * '.' (understood as 0)\n- * * '5.'\n- * * '.5', or, equivalently,  '0.5'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in base 10 to a float.\n+/// Accepts a optional decimal exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * '3.14'\n+/// * '+3.14', equivalent to '3.14'\n+/// * '-3.14'\n+/// * '2.5E10', or equivalently, '2.5e10'\n+/// * '2.5E-10'\n+/// * '.' (understood as 0)\n+/// * '5.'\n+/// * '.5', or, equivalently,  '0.5'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n }\n \n-/**\n- * Convert a string in base 16 to a float.\n- * Accepts a optional binary exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * 'a4.fe'\n- * * '+a4.fe', equivalent to 'a4.fe'\n- * * '-a4.fe'\n- * * '2b.aP128', or equivalently, '2b.ap128'\n- * * '2b.aP-128'\n- * * '.' (understood as 0)\n- * * 'c.'\n- * * '.c', or, equivalently,  '0.c'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n- */\n+///\n+/// Convert a string in base 16 to a float.\n+/// Accepts a optional binary exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * 'a4.fe'\n+/// * '+a4.fe', equivalent to 'a4.fe'\n+/// * '-a4.fe'\n+/// * '2b.aP128', or equivalently, '2b.ap128'\n+/// * '2b.aP-128'\n+/// * '.' (understood as 0)\n+/// * 'c.'\n+/// * '.c', or, equivalently,  '0.c'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+///\n #[inline(always)]\n pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n-/**\n- * Convert a string in an given base to a float.\n- *\n- * Due to possible conflicts, this function does **not** accept\n- * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n- * does it recognize exponents of any kind.\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- * * radix - The base to use. Must lie in the range [2 .. 36]\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number. Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in an given base to a float.\n+///\n+/// Due to possible conflicts, this function does **not** accept\n+/// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+/// does it recognize exponents of any kind.\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+/// * radix - The base to use. Must lie in the range [2 .. 36]\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number. Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n     strconv::from_str_common(num, rdx, true, true, false,\n@@ -748,6 +837,28 @@ mod tests {\n         num::test_num(10f32, 2f32);\n     }\n \n+    #[test]\n+    fn test_min() {\n+        assert_eq!(1f32.min(&2f32), 1f32);\n+        assert_eq!(2f32.min(&1f32), 1f32);\n+    }\n+\n+    #[test]\n+    fn test_max() {\n+        assert_eq!(1f32.max(&2f32), 2f32);\n+        assert_eq!(2f32.max(&1f32), 2f32);\n+    }\n+\n+    #[test]\n+    fn test_clamp() {\n+        assert_eq!(1f32.clamp(&2f32, &4f32), 2f32);\n+        assert_eq!(8f32.clamp(&2f32, &4f32), 4f32);\n+        assert_eq!(3f32.clamp(&2f32, &4f32), 3f32);\n+        assert!(3f32.clamp(&Float::NaN::<f32>(), &4f32).is_NaN());\n+        assert!(3f32.clamp(&2f32, &Float::NaN::<f32>()).is_NaN());\n+        assert!(Float::NaN::<f32>().clamp(&2f32, &4f32).is_NaN());\n+    }\n+\n     #[test]\n     fn test_floor() {\n         assert_fuzzy_eq!(1.0f32.floor(), 1.0f32);\n@@ -846,7 +957,7 @@ mod tests {\n         assert_eq!((-1f32).abs(), 1f32);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f32/neg_infinity).abs(), 0f32);\n-        assert!(is_NaN(NaN.abs()));\n+        assert!(NaN.abs().is_NaN());\n \n         assert_eq!(infinity.signum(), 1f32);\n         assert_eq!(1f32.signum(), 1f32);\n@@ -855,7 +966,7 @@ mod tests {\n         assert_eq!((-1f32).signum(), -1f32);\n         assert_eq!(neg_infinity.signum(), -1f32);\n         assert_eq!((1f32/neg_infinity).signum(), -1f32);\n-        assert!(is_NaN(NaN.signum()));\n+        assert!(NaN.signum().is_NaN());\n \n         assert!(infinity.is_positive());\n         assert!(1f32.is_positive());\n@@ -875,6 +986,12 @@ mod tests {\n         assert!((1f32/neg_infinity).is_negative());\n         assert!(!NaN.is_negative());\n     }\n+\n+    #[test]\n+    fn test_primitive() {\n+        assert_eq!(Primitive::bits::<f32>(), sys::size_of::<f32>() * 8);\n+        assert_eq!(Primitive::bytes::<f32>(), sys::size_of::<f32>());\n+    }\n }\n \n //"}, {"sha": "07a29652e94aaa9d0cd8f4bfa785e9597018a464", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 287, "deletions": 166, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -12,7 +12,7 @@\n \n use from_str;\n use libc::c_int;\n-use num::strconv;\n+use num::{Zero, One, strconv};\n use prelude::*;\n \n pub use cmath::c_double_targ_consts::*;\n@@ -89,7 +89,7 @@ delegate!(\n     fn abs_sub(a: c_double, b: c_double) -> c_double = c_double_utils::abs_sub,\n     fn fmax(a: c_double, b: c_double) -> c_double = c_double_utils::fmax,\n     fn fmin(a: c_double, b: c_double) -> c_double = c_double_utils::fmin,\n-    fn nextafter(x: c_double, y: c_double) -> c_double = c_double_utils::nextafter,\n+    fn next_after(x: c_double, y: c_double) -> c_double = c_double_utils::next_after,\n     fn frexp(n: c_double, value: &mut c_int) -> c_double = c_double_utils::frexp,\n     fn hypot(x: c_double, y: c_double) -> c_double = c_double_utils::hypot,\n     fn ldexp(x: c_double, n: c_int) -> c_double = c_double_utils::ldexp,\n@@ -138,9 +138,6 @@ pub static infinity: f64 = 1.0_f64/0.0_f64;\n \n pub static neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n-#[inline(always)]\n-pub fn is_NaN(f: f64) -> bool { f != f }\n-\n #[inline(always)]\n pub fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n@@ -174,24 +171,6 @@ pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n #[inline(always)]\n pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-/// Returns true if `x` is a zero number (positive or negative zero)\n-#[inline(always)]\n-pub fn is_zero(x: f64) -> bool {\n-    return x == 0.0f64 || x == -0.0f64;\n-}\n-\n-/// Returns true if `x`is an infinite number\n-#[inline(always)]\n-pub fn is_infinite(x: f64) -> bool {\n-    return x == infinity || x == neg_infinity;\n-}\n-\n-/// Returns true if `x` is a finite number\n-#[inline(always)]\n-pub fn is_finite(x: f64) -> bool {\n-    return !(is_NaN(x) || is_infinite(x));\n-}\n-\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n@@ -266,12 +245,40 @@ impl Ord for f64 {\n     fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n-impl num::Zero for f64 {\n+impl Orderable for f64 {\n+    /// Returns `NaN` if either of the numbers are `NaN`.\n+    #[inline(always)]\n+    fn min(&self, other: &f64) -> f64 {\n+        if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmin(*self, *other) }\n+    }\n+\n+    /// Returns `NaN` if either of the numbers are `NaN`.\n+    #[inline(always)]\n+    fn max(&self, other: &f64) -> f64 {\n+        if self.is_NaN() || other.is_NaN() { Float::NaN() } else { fmax(*self, *other) }\n+    }\n+\n+    /// Returns the number constrained within the range `mn <= self <= mx`.\n+    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    #[inline(always)]\n+    fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n+        if self.is_NaN() { *self }\n+        else if !(*self <= *mx) { *mx }\n+        else if !(*self >= *mn) { *mn }\n+        else { *self }\n+    }\n+}\n+\n+impl Zero for f64 {\n     #[inline(always)]\n     fn zero() -> f64 { 0.0 }\n+\n+    /// Returns true if the number is equal to either `0.0` or `-0.0`\n+    #[inline(always)]\n+    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n-impl num::One for f64 {\n+impl One for f64 {\n     #[inline(always)]\n     fn one() -> f64 { 1.0 }\n }\n@@ -316,16 +323,16 @@ impl Signed for f64 {\n     #[inline(always)]\n     fn abs(&self) -> f64 { abs(*self) }\n \n-    /**\n-     * # Returns\n-     *\n-     * - `1.0` if the number is positive, `+0.0` or `infinity`\n-     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-     * - `NaN` if the number is `NaN`\n-     */\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n+    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+    /// - `NaN` if the number is NaN\n+    ///\n     #[inline(always)]\n     fn signum(&self) -> f64 {\n-        if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n+        if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -551,52 +558,134 @@ impl RealExt for f64 {\n     fn yn(&self, n: int) -> f64 { yn(n as c_int, *self) }\n }\n \n-/**\n- * Section: String Conversions\n- */\n+impl Bounded for f64 {\n+    #[inline(always)]\n+    fn min_value() -> f64 { 2.2250738585072014e-308 }\n+\n+    #[inline(always)]\n+    fn max_value() -> f64 { 1.7976931348623157e+308 }\n+}\n+\n+impl Primitive for f64 {\n+    #[inline(always)]\n+    fn bits() -> uint { 64 }\n+\n+    #[inline(always)]\n+    fn bytes() -> uint { Primitive::bits::<f64>() / 8 }\n+}\n+\n+impl Float for f64 {\n+    #[inline(always)]\n+    fn NaN() -> f64 { 0.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn infinity() -> f64 { 1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_infinity() -> f64 { -1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_zero() -> f64 { -0.0 }\n+\n+    #[inline(always)]\n+    fn is_NaN(&self) -> bool { *self != *self }\n \n-/**\n- * Converts a float to a string\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+    /// Returns `true` if the number is infinite\n+    #[inline(always)]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is finite\n+    #[inline(always)]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_NaN() || self.is_infinite())\n+    }\n+\n+    #[inline(always)]\n+    fn mantissa_digits() -> uint { 53 }\n+\n+    #[inline(always)]\n+    fn digits() -> uint { 15 }\n+\n+    #[inline(always)]\n+    fn epsilon() -> f64 { 2.2204460492503131e-16 }\n+\n+    #[inline(always)]\n+    fn min_exp() -> int { -1021 }\n+\n+    #[inline(always)]\n+    fn max_exp() -> int { 1024 }\n+\n+    #[inline(always)]\n+    fn min_10_exp() -> int { -307 }\n+\n+    #[inline(always)]\n+    fn max_10_exp() -> int { 308 }\n+\n+    ///\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n+    /// produces a more accurate result with better performance than a separate multiplication\n+    /// operation followed by an add.\n+    ///\n+    #[inline(always)]\n+    fn mul_add(&self, a: f64, b: f64) -> f64 {\n+        mul_add(*self, a, b)\n+    }\n+\n+    /// Returns the next representable floating-point value in the direction of `other`\n+    #[inline(always)]\n+    fn next_after(&self, other: f64) -> f64 {\n+        next_after(*self, other)\n+    }\n+}\n+\n+//\n+// Section: String Conversions\n+//\n+\n+///\n+/// Converts a float to a string\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in hexadecimal format\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string in hexadecimal format\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- *\n- * # Failure\n- *\n- * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n- * possible misinterpretation of the result at higher bases. If those values\n- * are expected, use `to_str_radix_special()` instead.\n- */\n+///\n+/// Converts a float to a string in a given radix\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n+/// # Failure\n+///\n+/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+/// possible misinterpretation of the result at higher bases. If those values\n+/// are expected, use `to_str_radix_special()` instead.\n+///\n #[inline(always)]\n pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n@@ -606,46 +695,46 @@ pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix, and a flag indicating\n- * whether it's a special value\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- */\n+///\n+/// Converts a float to a string in a given radix, and a flag indicating\n+/// whether it's a special value\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n #[inline(always)]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n-/**\n- * Converts a float to a string with exactly the number of\n- * provided significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with exactly the number of\n+/// provided significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n     r\n }\n \n-/**\n- * Converts a float to a string with a maximum number of\n- * significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with a maximum number of\n+/// significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n@@ -665,91 +754,91 @@ impl num::ToStrRadix for f64 {\n     }\n }\n \n-/**\n- * Convert a string in base 10 to a float.\n- * Accepts a optional decimal exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * '3.14'\n- * * '+3.14', equivalent to '3.14'\n- * * '-3.14'\n- * * '2.5E10', or equivalently, '2.5e10'\n- * * '2.5E-10'\n- * * '.' (understood as 0)\n- * * '5.'\n- * * '.5', or, equivalently,  '0.5'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in base 10 to a float.\n+/// Accepts a optional decimal exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * '3.14'\n+/// * '+3.14', equivalent to '3.14'\n+/// * '-3.14'\n+/// * '2.5E10', or equivalently, '2.5e10'\n+/// * '2.5E-10'\n+/// * '.' (understood as 0)\n+/// * '5.'\n+/// * '.5', or, equivalently,  '0.5'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n }\n \n-/**\n- * Convert a string in base 16 to a float.\n- * Accepts a optional binary exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * 'a4.fe'\n- * * '+a4.fe', equivalent to 'a4.fe'\n- * * '-a4.fe'\n- * * '2b.aP128', or equivalently, '2b.ap128'\n- * * '2b.aP-128'\n- * * '.' (understood as 0)\n- * * 'c.'\n- * * '.c', or, equivalently,  '0.c'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n- */\n+///\n+/// Convert a string in base 16 to a float.\n+/// Accepts a optional binary exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * 'a4.fe'\n+/// * '+a4.fe', equivalent to 'a4.fe'\n+/// * '-a4.fe'\n+/// * '2b.aP128', or equivalently, '2b.ap128'\n+/// * '2b.aP-128'\n+/// * '.' (understood as 0)\n+/// * 'c.'\n+/// * '.c', or, equivalently,  '0.c'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+///\n #[inline(always)]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n-/**\n- * Convert a string in an given base to a float.\n- *\n- * Due to possible conflicts, this function does **not** accept\n- * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n- * does it recognize exponents of any kind.\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- * * radix - The base to use. Must lie in the range [2 .. 36]\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number. Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in an given base to a float.\n+///\n+/// Due to possible conflicts, this function does **not** accept\n+/// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+/// does it recognize exponents of any kind.\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+/// * radix - The base to use. Must lie in the range [2 .. 36]\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number. Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n     strconv::from_str_common(num, rdx, true, true, false,\n@@ -789,6 +878,32 @@ mod tests {\n         num::test_num(10f64, 2f64);\n     }\n \n+    #[test]\n+    fn test_min() {\n+        assert_eq!(1f64.min(&2f64), 1f64);\n+        assert_eq!(2f64.min(&1f64), 1f64);\n+        assert!(1f64.min(&Float::NaN::<f64>()).is_NaN());\n+        assert!(Float::NaN::<f64>().min(&1f64).is_NaN());\n+    }\n+\n+    #[test]\n+    fn test_max() {\n+        assert_eq!(1f64.max(&2f64), 2f64);\n+        assert_eq!(2f64.max(&1f64), 2f64);\n+        assert!(1f64.max(&Float::NaN::<f64>()).is_NaN());\n+        assert!(Float::NaN::<f64>().max(&1f64).is_NaN());\n+    }\n+\n+    #[test]\n+    fn test_clamp() {\n+        assert_eq!(1f64.clamp(&2f64, &4f64), 2f64);\n+        assert_eq!(8f64.clamp(&2f64, &4f64), 4f64);\n+        assert_eq!(3f64.clamp(&2f64, &4f64), 3f64);\n+        assert!(3f64.clamp(&Float::NaN::<f64>(), &4f64).is_NaN());\n+        assert!(3f64.clamp(&2f64, &Float::NaN::<f64>()).is_NaN());\n+        assert!(Float::NaN::<f64>().clamp(&2f64, &4f64).is_NaN());\n+    }\n+\n     #[test]\n     fn test_floor() {\n         assert_fuzzy_eq!(1.0f64.floor(), 1.0f64);\n@@ -887,7 +1002,7 @@ mod tests {\n         assert_eq!((-1f64).abs(), 1f64);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f64/neg_infinity).abs(), 0f64);\n-        assert!(is_NaN(NaN.abs()));\n+        assert!(NaN.abs().is_NaN());\n \n         assert_eq!(infinity.signum(), 1f64);\n         assert_eq!(1f64.signum(), 1f64);\n@@ -896,7 +1011,7 @@ mod tests {\n         assert_eq!((-1f64).signum(), -1f64);\n         assert_eq!(neg_infinity.signum(), -1f64);\n         assert_eq!((1f64/neg_infinity).signum(), -1f64);\n-        assert!(is_NaN(NaN.signum()));\n+        assert!(NaN.signum().is_NaN());\n \n         assert!(infinity.is_positive());\n         assert!(1f64.is_positive());\n@@ -916,6 +1031,12 @@ mod tests {\n         assert!((1f64/neg_infinity).is_negative());\n         assert!(!NaN.is_negative());\n     }\n+\n+    #[test]\n+    fn test_primitive() {\n+        assert_eq!(Primitive::bits::<f64>(), sys::size_of::<f64>() * 8);\n+        assert_eq!(Primitive::bytes::<f64>(), sys::size_of::<f64>());\n+    }\n }\n \n //"}, {"sha": "ef0adee884b7c2482e53ee4b72ad003defd33e70", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 302, "deletions": 176, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -22,14 +22,14 @@\n \n use from_str;\n use libc::c_int;\n-use num::strconv;\n+use num::{Zero, One, strconv};\n use prelude::*;\n \n pub use f64::{add, sub, mul, quot, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n pub use f64::{acos, asin, atan2, cbrt, ceil, copysign, cosh, floor};\n pub use f64::{erf, erfc, exp, expm1, exp2, abs_sub};\n-pub use f64::{mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp};\n+pub use f64::{mul_add, fmax, fmin, next_after, frexp, hypot, ldexp};\n pub use f64::{lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix};\n pub use f64::{modf, pow, powi, round, sinh, tanh, tgamma, trunc};\n pub use f64::{j0, j1, jn, y0, y1, yn};\n@@ -84,52 +84,52 @@ pub mod consts {\n     pub static ln_10: float = 2.30258509299404568401799145468436421;\n }\n \n-/*\n- * Section: String Conversions\n- */\n+//\n+// Section: String Conversions\n+//\n \n-/**\n- * Converts a float to a string\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in hexadecimal format\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- */\n+///\n+/// Converts a float to a string in hexadecimal format\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+///\n #[inline(always)]\n pub fn to_str_hex(num: float) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 16u, true, strconv::SignNeg, strconv::DigAll);\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- *\n- * # Failure\n- *\n- * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n- * possible misinterpretation of the result at higher bases. If those values\n- * are expected, use `to_str_radix_special()` instead.\n- */\n+///\n+/// Converts a float to a string in a given radix\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n+/// # Failure\n+///\n+/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+/// possible misinterpretation of the result at higher bases. If those values\n+/// are expected, use `to_str_radix_special()` instead.\n+///\n #[inline(always)]\n pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n@@ -139,46 +139,46 @@ pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     r\n }\n \n-/**\n- * Converts a float to a string in a given radix, and a flag indicating\n- * whether it's a special value\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * radix - The base to use\n- */\n+///\n+/// Converts a float to a string in a given radix, and a flag indicating\n+/// whether it's a special value\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * radix - The base to use\n+///\n #[inline(always)]\n pub fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n     strconv::to_str_common(&num, radix, true,\n                            strconv::SignNeg, strconv::DigAll)\n }\n \n-/**\n- * Converts a float to a string with exactly the number of\n- * provided significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with exactly the number of\n+/// provided significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n         &num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));\n     r\n }\n \n-/**\n- * Converts a float to a string with a maximum number of\n- * significant digits\n- *\n- * # Arguments\n- *\n- * * num - The float value\n- * * digits - The number of significant digits\n- */\n+///\n+/// Converts a float to a string with a maximum number of\n+/// significant digits\n+///\n+/// # Arguments\n+///\n+/// * num - The float value\n+/// * digits - The number of significant digits\n+///\n #[inline(always)]\n pub fn to_str_digits(num: float, digits: uint) -> ~str {\n     let (r, _) = strconv::to_str_common(\n@@ -198,91 +198,91 @@ impl num::ToStrRadix for float {\n     }\n }\n \n-/**\n- * Convert a string in base 10 to a float.\n- * Accepts a optional decimal exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * '3.14'\n- * * '+3.14', equivalent to '3.14'\n- * * '-3.14'\n- * * '2.5E10', or equivalently, '2.5e10'\n- * * '2.5E-10'\n- * * '.' (understood as 0)\n- * * '5.'\n- * * '.5', or, equivalently,  '0.5'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in base 10 to a float.\n+/// Accepts a optional decimal exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * '3.14'\n+/// * '+3.14', equivalent to '3.14'\n+/// * '-3.14'\n+/// * '2.5E10', or equivalently, '2.5e10'\n+/// * '2.5E-10'\n+/// * '.' (understood as 0)\n+/// * '5.'\n+/// * '.5', or, equivalently,  '0.5'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 10u, true, true, true,\n                              strconv::ExpDec, false, false)\n }\n \n-/**\n- * Convert a string in base 16 to a float.\n- * Accepts a optional binary exponent.\n- *\n- * This function accepts strings such as\n- *\n- * * 'a4.fe'\n- * * '+a4.fe', equivalent to 'a4.fe'\n- * * '-a4.fe'\n- * * '2b.aP128', or equivalently, '2b.ap128'\n- * * '2b.aP-128'\n- * * '.' (understood as 0)\n- * * 'c.'\n- * * '.c', or, equivalently,  '0.c'\n- * * '+inf', 'inf', '-inf', 'NaN'\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n- */\n+///\n+/// Convert a string in base 16 to a float.\n+/// Accepts a optional binary exponent.\n+///\n+/// This function accepts strings such as\n+///\n+/// * 'a4.fe'\n+/// * '+a4.fe', equivalent to 'a4.fe'\n+/// * '-a4.fe'\n+/// * '2b.aP128', or equivalently, '2b.ap128'\n+/// * '2b.aP-128'\n+/// * '.' (understood as 0)\n+/// * 'c.'\n+/// * '.c', or, equivalently,  '0.c'\n+/// * '+inf', 'inf', '-inf', 'NaN'\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+///\n #[inline(always)]\n pub fn from_str_hex(num: &str) -> Option<float> {\n     strconv::from_str_common(num, 16u, true, true, true,\n                              strconv::ExpBin, false, false)\n }\n \n-/**\n- * Convert a string in an given base to a float.\n- *\n- * Due to possible conflicts, this function does **not** accept\n- * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n- * does it recognize exponents of any kind.\n- *\n- * Leading and trailing whitespace represent an error.\n- *\n- * # Arguments\n- *\n- * * num - A string\n- * * radix - The base to use. Must lie in the range [2 .. 36]\n- *\n- * # Return value\n- *\n- * `none` if the string did not represent a valid number. Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `num`.\n- */\n+///\n+/// Convert a string in an given base to a float.\n+///\n+/// Due to possible conflicts, this function does **not** accept\n+/// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+/// does it recognize exponents of any kind.\n+///\n+/// Leading and trailing whitespace represent an error.\n+///\n+/// # Arguments\n+///\n+/// * num - A string\n+/// * radix - The base to use. Must lie in the range [2 .. 36]\n+///\n+/// # Return value\n+///\n+/// `none` if the string did not represent a valid number. Otherwise,\n+/// `Some(n)` where `n` is the floating-point number represented by `num`.\n+///\n #[inline(always)]\n pub fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n     strconv::from_str_common(num, radix, true, true, false,\n@@ -301,22 +301,22 @@ impl num::FromStrRadix for float {\n     }\n }\n \n-/**\n- * Section: Arithmetics\n- */\n+//\n+// Section: Arithmetics\n+//\n \n-/**\n- * Compute the exponentiation of an integer by another integer as a float\n- *\n- * # Arguments\n- *\n- * * x - The base\n- * * pow - The exponent\n- *\n- * # Return value\n- *\n- * `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n- */\n+///\n+/// Compute the exponentiation of an integer by another integer as a float\n+///\n+/// # Arguments\n+///\n+/// * x - The base\n+/// * pow - The exponent\n+///\n+/// # Return value\n+///\n+/// `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n+///\n pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {\n@@ -337,15 +337,6 @@ pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-#[inline(always)]\n-pub fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n-#[inline(always)]\n-pub fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n-#[inline(always)]\n-pub fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n-#[inline(always)]\n-pub fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n-\n #[inline(always)]\n pub fn abs(x: float) -> float {\n     f64::abs(x as f64) as float\n@@ -393,12 +384,37 @@ impl Ord for float {\n     fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n \n-impl num::Zero for float {\n+impl Orderable for float {\n+    /// Returns `NaN` if either of the numbers are `NaN`.\n+    #[inline(always)]\n+    fn min(&self, other: &float) -> float {\n+        (*self as f64).min(&(*other as f64)) as float\n+    }\n+\n+    /// Returns `NaN` if either of the numbers are `NaN`.\n+    #[inline(always)]\n+    fn max(&self, other: &float) -> float {\n+        (*self as f64).max(&(*other as f64)) as float\n+    }\n+\n+    /// Returns the number constrained within the range `mn <= self <= mx`.\n+    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    #[inline(always)]\n+    fn clamp(&self, mn: &float, mx: &float) -> float {\n+        (*self as f64).clamp(&(*mn as f64), &(*mx as f64)) as float\n+    }\n+}\n+\n+impl Zero for float {\n     #[inline(always)]\n     fn zero() -> float { 0.0 }\n+\n+    /// Returns true if the number is equal to either `0.0` or `-0.0`\n+    #[inline(always)]\n+    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n }\n \n-impl num::One for float {\n+impl One for float {\n     #[inline(always)]\n     fn one() -> float { 1.0 }\n }\n@@ -666,16 +682,16 @@ impl Signed for float {\n     #[inline(always)]\n     fn abs(&self) -> float { abs(*self) }\n \n-    /**\n-     * # Returns\n-     *\n-     * - `1.0` if the number is positive, `+0.0` or `infinity`\n-     * - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-     * - `NaN` if the number is NaN\n-     */\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n+    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n+    /// - `NaN` if the number is NaN\n+    ///\n     #[inline(always)]\n     fn signum(&self) -> float {\n-        if is_NaN(*self) { NaN } else { f64::copysign(1.0, *self as f64) as float }\n+        if self.is_NaN() { NaN } else { f64::copysign(1.0, *self as f64) as float }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -687,6 +703,88 @@ impl Signed for float {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n+impl Bounded for float {\n+    #[inline(always)]\n+    fn min_value() -> float { Bounded::min_value::<f64>() as float }\n+\n+    #[inline(always)]\n+    fn max_value() -> float { Bounded::max_value::<f64>() as float }\n+}\n+\n+impl Primitive for float {\n+    #[inline(always)]\n+    fn bits() -> uint { Primitive::bits::<f64>() }\n+\n+    #[inline(always)]\n+    fn bytes() -> uint { Primitive::bytes::<f64>() }\n+}\n+\n+impl Float for float {\n+    #[inline(always)]\n+    fn NaN() -> float { 0.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn infinity() -> float { 1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_infinity() -> float { -1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_zero() -> float { -0.0 }\n+\n+    #[inline(always)]\n+    fn is_NaN(&self) -> bool { *self != *self }\n+\n+    #[inline(always)]\n+    fn mantissa_digits() -> uint { Float::mantissa_digits::<f64>() }\n+\n+    #[inline(always)]\n+    fn digits() -> uint { Float::digits::<f64>() }\n+\n+    #[inline(always)]\n+    fn epsilon() -> float { Float::epsilon::<f64>() as float }\n+\n+    #[inline(always)]\n+    fn min_exp() -> int { Float::min_exp::<f64>() }\n+\n+    #[inline(always)]\n+    fn max_exp() -> int { Float::max_exp::<f64>() }\n+\n+    #[inline(always)]\n+    fn min_10_exp() -> int { Float::min_10_exp::<f64>() }\n+\n+    #[inline(always)]\n+    fn max_10_exp() -> int { Float::max_10_exp::<f64>() }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline(always)]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is finite\n+    #[inline(always)]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_NaN() || self.is_infinite())\n+    }\n+\n+    ///\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n+    /// produces a more accurate result with better performance than a separate multiplication\n+    /// operation followed by an add.\n+    ///\n+    #[inline(always)]\n+    fn mul_add(&self, a: float, b: float) -> float {\n+        mul_add(*self as f64, a as f64, b as f64) as float\n+    }\n+\n+    /// Returns the next representable floating-point value in the direction of `other`\n+    #[inline(always)]\n+    fn next_after(&self, other: float) -> float {\n+        next_after(*self as f64, other as f64) as float\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -706,6 +804,28 @@ mod tests {\n         num::test_num(10f, 2f);\n     }\n \n+    #[test]\n+    fn test_min() {\n+        assert_eq!(1f.min(&2f), 1f);\n+        assert_eq!(2f.min(&1f), 1f);\n+    }\n+\n+    #[test]\n+    fn test_max() {\n+        assert_eq!(1f.max(&2f), 2f);\n+        assert_eq!(2f.max(&1f), 2f);\n+    }\n+\n+    #[test]\n+    fn test_clamp() {\n+        assert_eq!(1f.clamp(&2f, &4f), 2f);\n+        assert_eq!(8f.clamp(&2f, &4f), 4f);\n+        assert_eq!(3f.clamp(&2f, &4f), 3f);\n+        assert!(3f.clamp(&Float::NaN::<float>(), &4f).is_NaN());\n+        assert!(3f.clamp(&2f, &Float::NaN::<float>()).is_NaN());\n+        assert!(Float::NaN::<float>().clamp(&2f, &4f).is_NaN());\n+    }\n+\n     #[test]\n     fn test_floor() {\n         assert_fuzzy_eq!(1.0f.floor(), 1.0f);\n@@ -796,15 +916,15 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_signed() {\n+    fn test_signed() {\n         assert_eq!(infinity.abs(), infinity);\n         assert_eq!(1f.abs(), 1f);\n         assert_eq!(0f.abs(), 0f);\n         assert_eq!((-0f).abs(), 0f);\n         assert_eq!((-1f).abs(), 1f);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f/neg_infinity).abs(), 0f);\n-        assert!(is_NaN(NaN.abs()));\n+        assert!(NaN.abs().is_NaN());\n \n         assert_eq!(infinity.signum(), 1f);\n         assert_eq!(1f.signum(), 1f);\n@@ -813,7 +933,7 @@ mod tests {\n         assert_eq!((-1f).signum(), -1f);\n         assert_eq!(neg_infinity.signum(), -1f);\n         assert_eq!((1f/neg_infinity).signum(), -1f);\n-        assert!(is_NaN(NaN.signum()));\n+        assert!(NaN.signum().is_NaN());\n \n         assert!(infinity.is_positive());\n         assert!(1f.is_positive());\n@@ -834,6 +954,12 @@ mod tests {\n         assert!(!NaN.is_negative());\n     }\n \n+    #[test]\n+    fn test_primitive() {\n+        assert_eq!(Primitive::bits::<float>(), sys::size_of::<float>() * 8);\n+        assert_eq!(Primitive::bytes::<float>(), sys::size_of::<float>());\n+    }\n+\n     #[test]\n     pub fn test_to_str_exact_do_decimal() {\n         let s = to_str_exact(5.0, 4u);\n@@ -862,16 +988,16 @@ mod tests {\n         assert_eq!(from_str(~\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str(~\"NaN\") {\n-            Some(f) => assert!(is_NaN(f)),\n+            Some(f) => assert!(f.is_NaN()),\n             None => fail!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str(~\"-0\") {\n-            Some(v) if is_zero(v) => assert!(v.is_negative()),\n+            Some(v) if v.is_zero() => assert!(v.is_negative()),\n             _ => fail!()\n         }\n         match from_str(~\"0\") {\n-            Some(v) if is_zero(v) => assert!(v.is_positive()),\n+            Some(v) if v.is_zero() => assert!(v.is_positive()),\n             _ => fail!()\n         }\n \n@@ -909,16 +1035,16 @@ mod tests {\n         assert_eq!(from_str_hex(~\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str_hex(~\"NaN\") {\n-            Some(f) => assert!(is_NaN(f)),\n+            Some(f) => assert!(f.is_NaN()),\n             None => fail!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str_hex(~\"-0\") {\n-            Some(v) if is_zero(v) => assert!(v.is_negative()),\n+            Some(v) if v.is_zero() => assert!(v.is_negative()),\n             _ => fail!()\n         }\n         match from_str_hex(~\"0\") {\n-            Some(v) if is_zero(v) => assert!(v.is_positive()),\n+            Some(v) if v.is_zero() => assert!(v.is_positive()),\n             _ => fail!()\n         }\n         assert_eq!(from_str_hex(~\"e\"), Some(14.));"}, {"sha": "08df820a73db82f7658e26cbb1d420af93acf536", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 196, "deletions": 144, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -12,7 +12,7 @@ use T = self::inst::T;\n \n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n-use num::strconv;\n+use num::{Zero, One, strconv};\n use prelude::*;\n \n pub use cmp::{min, max};\n@@ -32,26 +32,26 @@ pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n pub fn quot(x: T, y: T) -> T { x / y }\n \n-/**\n- * Returns the remainder of y / x.\n- *\n- * # Examples\n- * ~~~\n- * assert!(int::rem(5 / 2) == 1);\n- * ~~~\n- *\n- * When faced with negative numbers, the result copies the sign of the\n- * dividend.\n- *\n- * ~~~\n- * assert!(int::rem(2 / -3) ==  2);\n- * ~~~\n- *\n- * ~~~\n- * assert!(int::rem(-2 / 3) ==  -2);\n- * ~~~\n- *\n- */\n+///\n+/// Returns the remainder of y / x.\n+///\n+/// # Examples\n+/// ~~~\n+/// assert!(int::rem(5 / 2) == 1);\n+/// ~~~\n+///\n+/// When faced with negative numbers, the result copies the sign of the\n+/// dividend.\n+///\n+/// ~~~\n+/// assert!(int::rem(2 / -3) ==  2);\n+/// ~~~\n+///\n+/// ~~~\n+/// assert!(int::rem(-2 / 3) ==  -2);\n+/// ~~~\n+///\n+///\n #[inline(always)]\n pub fn rem(x: T, y: T) -> T { x % y }\n \n@@ -68,23 +68,23 @@ pub fn ge(x: T, y: T) -> bool { x >= y }\n #[inline(always)]\n pub fn gt(x: T, y: T) -> bool { x > y }\n \n-/**\n- * Iterate over the range [`lo`..`hi`)\n- *\n- * # Arguments\n- *\n- * * `lo` - lower bound, inclusive\n- * * `hi` - higher bound, exclusive\n- *\n- * # Examples\n- * ~~~\n- * let mut sum = 0;\n- * for int::range(1, 5) |i| {\n- *     sum += i;\n- * }\n- * assert!(sum == 10);\n- * ~~~\n- */\n+///\n+/// Iterate over the range [`lo`..`hi`)\n+///\n+/// # Arguments\n+///\n+/// * `lo` - lower bound, inclusive\n+/// * `hi` - higher bound, exclusive\n+///\n+/// # Examples\n+/// ~~~\n+/// let mut sum = 0;\n+/// for int::range(1, 5) |i| {\n+///     sum += i;\n+/// }\n+/// assert!(sum == 10);\n+/// ~~~\n+///\n #[inline(always)]\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n@@ -152,12 +152,33 @@ impl Eq for T {\n     fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n-impl num::Zero for T {\n+impl Orderable for T {\n+    #[inline(always)]\n+    fn min(&self, other: &T) -> T {\n+        if *self < *other { *self } else { *other }\n+    }\n+\n+    #[inline(always)]\n+    fn max(&self, other: &T) -> T {\n+        if *self > *other { *self } else { *other }\n+    }\n+\n+    #[inline(always)]\n+    fn clamp(&self, mn: &T, mx: &T) -> T {\n+        if *self > *mx { *mx } else\n+        if *self < *mn { *mn } else { *self }\n+    }\n+}\n+\n+impl Zero for T {\n     #[inline(always)]\n     fn zero() -> T { 0 }\n+\n+    #[inline(always)]\n+    fn is_zero(&self) -> bool { *self == 0 }\n }\n \n-impl num::One for T {\n+impl One for T {\n     #[inline(always)]\n     fn one() -> T { 1 }\n }\n@@ -187,24 +208,24 @@ impl Div<T,T> for T {\n }\n #[cfg(not(stage0),notest)]\n impl Quot<T,T> for T {\n-    /**\n-     * Returns the integer quotient, truncated towards 0. As this behaviour reflects\n-     * the underlying machine implementation it is more efficient than `Natural::div`.\n-     *\n-     * # Examples\n-     *\n-     * ~~~\n-     * assert!( 8 /  3 ==  2);\n-     * assert!( 8 / -3 == -2);\n-     * assert!(-8 /  3 == -2);\n-     * assert!(-8 / -3 ==  2);\n-\n-     * assert!( 1 /  2 ==  0);\n-     * assert!( 1 / -2 ==  0);\n-     * assert!(-1 /  2 ==  0);\n-     * assert!(-1 / -2 ==  0);\n-     * ~~~\n-     */\n+    ///\n+    /// Returns the integer quotient, truncated towards 0. As this behaviour reflects\n+    /// the underlying machine implementation it is more efficient than `Natural::div`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!( 8 /  3 ==  2);\n+    /// assert!( 8 / -3 == -2);\n+    /// assert!(-8 /  3 == -2);\n+    /// assert!(-8 / -3 ==  2);\n+\n+    /// assert!( 1 /  2 ==  0);\n+    /// assert!( 1 / -2 ==  0);\n+    /// assert!(-1 /  2 ==  0);\n+    /// assert!(-1 / -2 ==  0);\n+    /// ~~~\n+    ///\n     #[inline(always)]\n     fn quot(&self, other: &T) -> T { *self / *other }\n }\n@@ -216,27 +237,27 @@ impl Modulo<T,T> for T {\n }\n #[cfg(not(stage0),notest)]\n impl Rem<T,T> for T {\n-    /**\n-     * Returns the integer remainder after division, satisfying:\n-     *\n-     * ~~~\n-     * assert!((n / d) * d + (n % d) == n)\n-     * ~~~\n-     *\n-     * # Examples\n-     *\n-     * ~~~\n-     * assert!( 8 %  3 ==  2);\n-     * assert!( 8 % -3 ==  2);\n-     * assert!(-8 %  3 == -2);\n-     * assert!(-8 % -3 == -2);\n-\n-     * assert!( 1 %  2 ==  1);\n-     * assert!( 1 % -2 ==  1);\n-     * assert!(-1 %  2 == -1);\n-     * assert!(-1 % -2 == -1);\n-     * ~~~\n-     */\n+    ///\n+    /// Returns the integer remainder after division, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!((n / d) * d + (n % d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!( 8 %  3 ==  2);\n+    /// assert!( 8 % -3 ==  2);\n+    /// assert!(-8 %  3 == -2);\n+    /// assert!(-8 % -3 == -2);\n+\n+    /// assert!( 1 %  2 ==  1);\n+    /// assert!( 1 % -2 ==  1);\n+    /// assert!(-1 %  2 == -1);\n+    /// assert!(-1 % -2 == -1);\n+    /// ~~~\n+    ///\n     #[inline(always)]\n     fn rem(&self, other: &T) -> T { *self % *other }\n }\n@@ -254,13 +275,13 @@ impl Signed for T {\n         if self.is_negative() { -*self } else { *self }\n     }\n \n-    /**\n-     * # Returns\n-     *\n-     * - `0` if the number is zero\n-     * - `1` if the number is positive\n-     * - `-1` if the number is negative\n-     */\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `0` if the number is zero\n+    /// - `1` if the number is positive\n+    /// - `-1` if the number is negative\n+    ///\n     #[inline(always)]\n     fn signum(&self) -> T {\n         match *self {\n@@ -280,23 +301,23 @@ impl Signed for T {\n }\n \n impl Integer for T {\n-    /**\n-     * Floored integer division\n-     *\n-     * # Examples\n-     *\n-     * ~~~\n-     * assert!(( 8).div( 3) ==  2);\n-     * assert!(( 8).div(-3) == -3);\n-     * assert!((-8).div( 3) == -3);\n-     * assert!((-8).div(-3) ==  2);\n-     *\n-     * assert!(( 1).div( 2) ==  0);\n-     * assert!(( 1).div(-2) == -1);\n-     * assert!((-1).div( 2) == -1);\n-     * assert!((-1).div(-2) ==  0);\n-     * ~~~\n-     */\n+    ///\n+    /// Floored integer division\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!(( 8).div( 3) ==  2);\n+    /// assert!(( 8).div(-3) == -3);\n+    /// assert!((-8).div( 3) == -3);\n+    /// assert!((-8).div(-3) ==  2);\n+    ///\n+    /// assert!(( 1).div( 2) ==  0);\n+    /// assert!(( 1).div(-2) == -1);\n+    /// assert!((-1).div( 2) == -1);\n+    /// assert!((-1).div(-2) ==  0);\n+    /// ~~~\n+    ///\n     #[inline(always)]\n     fn div(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n@@ -308,27 +329,27 @@ impl Integer for T {\n         }\n     }\n \n-    /**\n-     * Integer modulo, satisfying:\n-     *\n-     * ~~~\n-     * assert!(n.div(d) * d + n.modulo(d) == n)\n-     * ~~~\n-     *\n-     * # Examples\n-     *\n-     * ~~~\n-     * assert!(( 8).modulo( 3) ==  2);\n-     * assert!(( 8).modulo(-3) == -1);\n-     * assert!((-8).modulo( 3) ==  1);\n-     * assert!((-8).modulo(-3) == -2);\n-     *\n-     * assert!(( 1).modulo( 2) ==  1);\n-     * assert!(( 1).modulo(-2) == -1);\n-     * assert!((-1).modulo( 2) ==  1);\n-     * assert!((-1).modulo(-2) == -1);\n-     * ~~~\n-     */\n+    ///\n+    /// Integer modulo, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!(n.div(d) * d + n.modulo(d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!(( 8).modulo( 3) ==  2);\n+    /// assert!(( 8).modulo(-3) == -1);\n+    /// assert!((-8).modulo( 3) ==  1);\n+    /// assert!((-8).modulo(-3) == -2);\n+    ///\n+    /// assert!(( 1).modulo( 2) ==  1);\n+    /// assert!(( 1).modulo(-2) == -1);\n+    /// assert!((-1).modulo( 2) ==  1);\n+    /// assert!((-1).modulo(-2) == -1);\n+    /// ~~~\n+    ///\n     #[inline(always)]\n     fn modulo(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n@@ -358,11 +379,11 @@ impl Integer for T {\n         (*self / *other, *self % *other)\n     }\n \n-    /**\n-     * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-     *\n-     * The result is always positive\n-     */\n+    ///\n+    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+    ///\n+    /// The result is always positive\n+    ///\n     #[inline(always)]\n     fn gcd(&self, other: &T) -> T {\n         // Use Euclid's algorithm\n@@ -375,9 +396,9 @@ impl Integer for T {\n         n.abs()\n     }\n \n-    /**\n-     * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n-     */\n+    ///\n+    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+    ///\n     #[inline(always)]\n     fn lcm(&self, other: &T) -> T {\n         ((*self * *other) / self.gcd(other)).abs() // should not have to recaluculate abs\n@@ -396,6 +417,8 @@ impl Integer for T {\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n+impl Bitwise for T {}\n+\n #[cfg(notest)]\n impl BitOr<T,T> for T {\n     #[inline(always)]\n@@ -432,6 +455,16 @@ impl Not<T> for T {\n     fn not(&self) -> T { !*self }\n }\n \n+impl Bounded for T {\n+    #[inline(always)]\n+    fn min_value() -> T { min_value }\n+\n+    #[inline(always)]\n+    fn max_value() -> T { max_value }\n+}\n+\n+impl Int for T {}\n+\n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n@@ -520,6 +553,17 @@ mod tests {\n         num::test_num(10 as T, 2 as T);\n     }\n \n+    #[test]\n+    fn test_orderable() {\n+        assert_eq!((1 as T).min(&(2 as T)), 1 as T);\n+        assert_eq!((2 as T).min(&(1 as T)), 1 as T);\n+        assert_eq!((1 as T).max(&(2 as T)), 2 as T);\n+        assert_eq!((2 as T).max(&(1 as T)), 2 as T);\n+        assert_eq!((1 as T).clamp(&(2 as T), &(4 as T)), 2 as T);\n+        assert_eq!((8 as T).clamp(&(2 as T), &(4 as T)), 4 as T);\n+        assert_eq!((3 as T).clamp(&(2 as T), &(4 as T)), 3 as T);\n+    }\n+\n     #[test]\n     pub fn test_signed() {\n         assert_eq!((1 as T).abs(), 1 as T);\n@@ -542,18 +586,15 @@ mod tests {\n         assert!((-1 as T).is_negative());\n     }\n \n-    /**\n-     * Checks that the division rule holds for:\n-     *\n-     * - `n`: numerator (dividend)\n-     * - `d`: denominator (divisor)\n-     * - `qr`: quotient and remainder\n-     */\n+    ///\n+    /// Checks that the division rule holds for:\n+    ///\n+    /// - `n`: numerator (dividend)\n+    /// - `d`: denominator (divisor)\n+    /// - `qr`: quotient and remainder\n+    ///\n     #[cfg(test)]\n-    fn test_division_rule(nd: (T,T), qr: (T,T)) {\n-        let (n,d) = nd,\n-            (q,r) = qr;\n-\n+    fn test_division_rule((n,d): (T,T), (q,r): (T,T)) {\n         assert_eq!(d * q + r, n);\n     }\n \n@@ -632,7 +673,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitwise_ops() {\n+    fn test_bitwise() {\n         assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));\n         assert_eq!(0b1000 as T, (0b1100 as T).bitand(&(0b1010 as T)));\n         assert_eq!(0b0110 as T, (0b1100 as T).bitxor(&(0b1010 as T)));\n@@ -641,6 +682,17 @@ mod tests {\n         assert_eq!(-(0b11 as T) - (1 as T), (0b11 as T).not());\n     }\n \n+    #[test]\n+    fn test_bitcount() {\n+        assert_eq!((0b010101 as T).population_count(), 3);\n+    }\n+\n+    #[test]\n+    fn test_primitive() {\n+        assert_eq!(Primitive::bits::<T>(), sys::size_of::<T>() * 8);\n+        assert_eq!(Primitive::bytes::<T>(), sys::size_of::<T>());\n+    }\n+\n     #[test]\n     fn test_from_str() {\n         assert_eq!(from_str(~\"0\"), Some(0 as T));"}, {"sha": "282633785553bf26e6362e8e46b266043f935887", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -11,6 +11,31 @@\n //! Operations and constants for `i16`\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+    use unstable::intrinsics;\n+\n     pub type T = i16;\n     pub static bits: uint = ::u16::bits;\n+\n+    impl Primitive for i16 {\n+        #[inline(always)]\n+        fn bits() -> uint { 16 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<i16>() / 8 }\n+    }\n+\n+    impl BitCount for i16 {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> i16 { unsafe { intrinsics::ctpop16(*self) } }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self) } }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self) } }\n+    }\n }"}, {"sha": "959cf8f7d77cac26cb66f9993c2444e77f94cb26", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -11,6 +11,31 @@\n //! Operations and constants for `i32`\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+    use unstable::intrinsics;\n+\n     pub type T = i32;\n     pub static bits: uint = ::u32::bits;\n+\n+    impl Primitive for i32 {\n+        #[inline(always)]\n+        fn bits() -> uint { 32 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<i32>() / 8 }\n+    }\n+\n+    impl BitCount for i32 {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> i32 { unsafe { intrinsics::ctpop32(*self) } }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self) } }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self) } }\n+    }\n }"}, {"sha": "3b51c70be12e52bc2f684b7e85fb198a9de160ca", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -11,6 +11,31 @@\n //! Operations and constants for `i64`\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+    use unstable::intrinsics;\n+\n     pub type T = i64;\n     pub static bits: uint = ::u64::bits;\n+\n+    impl Primitive for i64 {\n+        #[inline(always)]\n+        fn bits() -> uint { 64 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<i64>() / 8 }\n+    }\n+\n+    impl BitCount for i64 {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> i64 { unsafe { intrinsics::ctpop64(*self) } }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self) } }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self) } }\n+    }\n }"}, {"sha": "896fb4dbf50f822bafd99e9207e66db73c3b10fb", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -11,6 +11,31 @@\n //! Operations and constants for `i8`\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+    use unstable::intrinsics;\n+\n     pub type T = i8;\n     pub static bits: uint = ::u8::bits;\n+\n+    impl Primitive for i8 {\n+        #[inline(always)]\n+        fn bits() -> uint { 8 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<i8>() / 8 }\n+    }\n+\n+    impl BitCount for i8 {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> i8 { unsafe { intrinsics::ctpop8(*self) } }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self) } }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self) } }\n+    }\n }"}, {"sha": "7a44bfdf16038ab7b087850a63668042c2caf86c", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -13,9 +13,56 @@\n pub use self::inst::pow;\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+\n     pub type T = int;\n     pub static bits: uint = ::uint::bits;\n \n+    impl Primitive for int {\n+        #[cfg(target_word_size = \"32\")]\n+        #[inline(always)]\n+        fn bits() -> uint { 32 }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        #[inline(always)]\n+        fn bits() -> uint { 64 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<int>() / 8 }\n+    }\n+\n+    #[cfg(target_word_size = \"32\")]\n+    #[inline(always)]\n+    impl BitCount for int {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> int { (*self as i32).population_count() as int }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n+    #[inline(always)]\n+    impl BitCount for int {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> int { (*self as i64).population_count() as int }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n+    }\n+\n     /// Returns `base` raised to the power of `exponent`\n     pub fn pow(base: int, exponent: uint) -> int {\n         if exponent == 0u {"}, {"sha": "0e2669a26b6b3c5e720ba56def648d2e665233a7", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 127, "deletions": 34, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -18,11 +18,15 @@ use Quot = ops::Div;\n use Rem = ops::Modulo;\n #[cfg(not(stage0))]\n use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n use kinds::Copy;\n \n pub mod strconv;\n \n+///\n+/// The base trait for numeric types\n+///\n pub trait Num: Eq + Zero + One\n              + Neg<Self>\n              + Add<Self,Self>\n@@ -36,14 +40,23 @@ pub trait IntConvertible {\n     fn from_int(n: int) -> Self;\n }\n \n+pub trait Orderable: Ord {\n+    // These should be methods on `Ord`, with overridable default implementations. We don't want\n+    // to encumber all implementors of Ord by requiring them to implement these functions, but at\n+    // the same time we want to be able to take advantage of the speed of the specific numeric\n+    // functions (like the `fmin` and `fmax` intrinsics).\n+    fn min(&self, other: &Self) -> Self;\n+    fn max(&self, other: &Self) -> Self;\n+    fn clamp(&self, mn: &Self, mx: &Self) -> Self;\n+}\n+\n pub trait Zero {\n-    // FIXME (#5527): These should be associated constants\n-    fn zero() -> Self;\n+    fn zero() -> Self;      // FIXME (#5527): This should be an associated constant\n+    fn is_zero(&self) -> bool;\n }\n \n pub trait One {\n-    // FIXME (#5527): These should be associated constants\n-    fn one() -> Self;\n+    fn one() -> Self;       // FIXME (#5527): This should be an associated constant\n }\n \n pub trait Signed: Num\n@@ -62,7 +75,7 @@ pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n }\n \n pub trait Integer: Num\n-                 + Ord\n+                 + Orderable\n                  + Quot<Self,Self>\n                  + Rem<Self,Self> {\n     fn div(&self, other: &Self) -> Self;\n@@ -86,12 +99,15 @@ pub trait Round {\n }\n \n pub trait Fractional: Num\n-                    + Ord\n+                    + Orderable\n                     + Round\n                     + Quot<Self,Self> {\n     fn recip(&self) -> Self;\n }\n \n+///\n+/// Defines constants and methods common to real numbers\n+///\n pub trait Real: Signed\n               + Fractional {\n     // FIXME (#5527): usages of `int` should be replaced with an associated\n@@ -154,7 +170,9 @@ pub trait Real: Signed\n     fn tanh(&self) -> Self;\n }\n \n+///\n /// Methods that are harder to implement and not commonly used.\n+///\n pub trait RealExt: Real {\n     // FIXME (#5527): usages of `int` should be replaced with an associated\n     // integer type once these are implemented\n@@ -172,24 +190,101 @@ pub trait RealExt: Real {\n     fn yn(&self, n: int) -> Self;\n }\n \n-/**\n- * Cast from one machine scalar to another\n- *\n- * # Example\n- *\n- * ~~~\n- * let twenty: f32 = num::cast(0x14);\n- * assert_eq!(twenty, 20f32);\n- * ~~~\n- */\n+///\n+/// Collects the bitwise operators under one trait.\n+///\n+pub trait Bitwise: Not<Self>\n+                 + BitAnd<Self,Self>\n+                 + BitOr<Self,Self>\n+                 + BitXor<Self,Self>\n+                 + Shl<Self,Self>\n+                 + Shr<Self,Self> {}\n+\n+pub trait BitCount {\n+    fn population_count(&self) -> Self;\n+    fn leading_zeros(&self) -> Self;\n+    fn trailing_zeros(&self) -> Self;\n+}\n+\n+pub trait Bounded {\n+    // FIXME (#5527): These should be associated constants\n+    fn min_value() -> Self;\n+    fn max_value() -> Self;\n+}\n+\n+///\n+/// Specifies the available operations common to all of Rust's core numeric primitives.\n+/// These may not always make sense from a purely mathematical point of view, but\n+/// may be useful for systems programming.\n+///\n+pub trait Primitive: Num\n+                   + NumCast\n+                   + Bounded\n+                   + Neg<Self>\n+                   + Add<Self,Self>\n+                   + Sub<Self,Self>\n+                   + Mul<Self,Self>\n+                   + Quot<Self,Self>\n+                   + Rem<Self,Self> {\n+    // FIXME (#5527): These should be associated constants\n+    fn bits() -> uint;\n+    fn bytes() -> uint;\n+}\n+\n+///\n+/// A collection of traits relevant to primitive signed and unsigned integers\n+///\n+pub trait Int: Integer\n+             + Primitive\n+             + Bitwise\n+             + BitCount {}\n+\n+///\n+/// Primitive floating point numbers\n+///\n+pub trait Float: Real\n+               + Signed\n+               + Primitive {\n+    // FIXME (#5527): These should be associated constants\n+    fn NaN() -> Self;\n+    fn infinity() -> Self;\n+    fn neg_infinity() -> Self;\n+    fn neg_zero() -> Self;\n+\n+    fn is_NaN(&self) -> bool;\n+    fn is_infinite(&self) -> bool;\n+    fn is_finite(&self) -> bool;\n+\n+    fn mantissa_digits() -> uint;\n+    fn digits() -> uint;\n+    fn epsilon() -> Self;\n+    fn min_exp() -> int;\n+    fn max_exp() -> int;\n+    fn min_10_exp() -> int;\n+    fn max_10_exp() -> int;\n+\n+    fn mul_add(&self, a: Self, b: Self) -> Self;\n+    fn next_after(&self, other: Self) -> Self;\n+}\n+\n+///\n+/// Cast from one machine scalar to another\n+///\n+/// # Example\n+///\n+/// ~~~\n+/// let twenty: f32 = num::cast(0x14);\n+/// assert_eq!(twenty, 20f32);\n+/// ~~~\n+///\n #[inline(always)]\n pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n     NumCast::from(n)\n }\n \n-/**\n- * An interface for casting between machine scalars\n- */\n+///\n+/// An interface for casting between machine scalars\n+///\n pub trait NumCast {\n     fn from<T:NumCast>(n: T) -> Self;\n \n@@ -261,21 +356,19 @@ pub trait FromStrRadix {\n     pub fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n-// Generic math functions:\n-\n-/**\n- * Calculates a power to a given radix, optimized for uint `pow` and `radix`.\n- *\n- * Returns `radix^pow` as `T`.\n- *\n- * Note:\n- * Also returns `1` for `0^0`, despite that technically being an\n- * undefined number. The reason for this is twofold:\n- * - If code written to use this function cares about that special case, it's\n- *   probably going to catch it before making the call.\n- * - If code written to use this function doesn't care about it, it's\n- *   probably assuming that `x^0` always equals `1`.\n- */\n+///\n+/// Calculates a power to a given radix, optimized for uint `pow` and `radix`.\n+///\n+/// Returns `radix^pow` as `T`.\n+///\n+/// Note:\n+/// Also returns `1` for `0^0`, despite that technically being an\n+/// undefined number. The reason for this is twofold:\n+/// - If code written to use this function cares about that special case, it's\n+///   probably going to catch it before making the call.\n+/// - If code written to use this function doesn't care about it, it's\n+///   probably assuming that `x^0` always equals `1`.\n+///\n pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Quot<T,T>+Mul<T,T>>(\n     radix: uint, pow: uint) -> T {\n     let _0: T = Zero::zero();"}, {"sha": "af64660ad0c5cd73085482300043f8e2107b10fe", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -13,7 +13,7 @@ use T_SIGNED = self::inst::T_SIGNED;\n \n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n-use num::strconv;\n+use num::{Zero, One, strconv};\n use prelude::*;\n \n pub use cmp::{min, max};\n@@ -49,10 +49,9 @@ pub fn ge(x: T, y: T) -> bool { x >= y }\n pub fn gt(x: T, y: T) -> bool { x > y }\n \n #[inline(always)]\n-/**\n- * Iterate over the range [`start`,`start`+`step`..`stop`)\n- *\n- */\n+///\n+/// Iterate over the range [`start`,`start`+`step`..`stop`)\n+///\n pub fn range_step(start: T,\n                        stop: T,\n                        step: T_SIGNED,\n@@ -118,12 +117,33 @@ impl Eq for T {\n     fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n-impl num::Zero for T {\n+impl Orderable for T {\n+    #[inline(always)]\n+    fn min(&self, other: &T) -> T {\n+        if *self < *other { *self } else { *other }\n+    }\n+\n+    #[inline(always)]\n+    fn max(&self, other: &T) -> T {\n+        if *self > *other { *self } else { *other }\n+    }\n+\n+    #[inline(always)]\n+    fn clamp(&self, mn: &T, mx: &T) -> T {\n+        if *self > *mx { *mx } else\n+        if *self < *mn { *mn } else { *self }\n+    }\n+}\n+\n+impl Zero for T {\n     #[inline(always)]\n     fn zero() -> T { 0 }\n+\n+    #[inline(always)]\n+    fn is_zero(&self) -> bool { *self == 0 }\n }\n \n-impl num::One for T {\n+impl One for T {\n     #[inline(always)]\n     fn one() -> T { 1 }\n }\n@@ -229,6 +249,8 @@ impl Integer for T {\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n+impl Bitwise for T {}\n+\n #[cfg(notest)]\n impl BitOr<T,T> for T {\n     #[inline(always)]\n@@ -265,6 +287,16 @@ impl Not<T> for T {\n     fn not(&self) -> T { !*self }\n }\n \n+impl Bounded for T {\n+    #[inline(always)]\n+    fn min_value() -> T { min_value }\n+\n+    #[inline(always)]\n+    fn max_value() -> T { max_value }\n+}\n+\n+impl Int for T {}\n+\n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10.\n@@ -353,6 +385,17 @@ mod tests {\n         num::test_num(10 as T, 2 as T);\n     }\n \n+    #[test]\n+    fn test_orderable() {\n+        assert_eq!((1 as T).min(&(2 as T)), 1 as T);\n+        assert_eq!((2 as T).min(&(1 as T)), 1 as T);\n+        assert_eq!((1 as T).max(&(2 as T)), 2 as T);\n+        assert_eq!((2 as T).max(&(1 as T)), 2 as T);\n+        assert_eq!((1 as T).clamp(&(2 as T), &(4 as T)), 2 as T);\n+        assert_eq!((8 as T).clamp(&(2 as T), &(4 as T)), 4 as T);\n+        assert_eq!((3 as T).clamp(&(2 as T), &(4 as T)), 3 as T);\n+    }\n+\n     #[test]\n     fn test_gcd() {\n         assert_eq!((10 as T).gcd(&2), 2 as T);\n@@ -373,7 +416,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitwise_ops() {\n+    fn test_bitwise() {\n         assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));\n         assert_eq!(0b1000 as T, (0b1100 as T).bitand(&(0b1010 as T)));\n         assert_eq!(0b0110 as T, (0b1100 as T).bitxor(&(0b1010 as T)));\n@@ -382,6 +425,17 @@ mod tests {\n         assert_eq!(max_value - (0b1011 as T), (0b1011 as T).not());\n     }\n \n+    #[test]\n+    fn test_bitcount() {\n+        assert_eq!((0b010101 as T).population_count(), 3);\n+    }\n+\n+    #[test]\n+    fn test_primitive() {\n+        assert_eq!(Primitive::bits::<T>(), sys::size_of::<T>() * 8);\n+        assert_eq!(Primitive::bytes::<T>(), sys::size_of::<T>());\n+    }\n+\n     #[test]\n     pub fn test_to_str() {\n         assert_eq!(to_str_radix(0 as T, 10u), ~\"0\");"}, {"sha": "cc262f6b4dee7100385e9b7784383173265c8d5e", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -11,8 +11,33 @@\n //! Operations and constants for `u16`\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+    use unstable::intrinsics;\n+\n     pub type T = u16;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i16;\n     pub static bits: uint = 16;\n+\n+    impl Primitive for u16 {\n+        #[inline(always)]\n+        fn bits() -> uint { 16 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<u16>() / 8 }\n+    }\n+\n+    impl BitCount for u16 {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> u16 { unsafe { intrinsics::ctpop16(*self as i16) as u16 } }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> u16 { unsafe { intrinsics::ctlz16(*self as i16) as u16 } }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> u16 { unsafe { intrinsics::cttz16(*self as i16) as u16 } }\n+    }\n }"}, {"sha": "7d7c8e3be302e3589b6d72f5e3fbd5f77296647a", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -11,8 +11,33 @@\n //! Operations and constants for `u32`\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+    use unstable::intrinsics;\n+\n     pub type T = u32;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i32;\n     pub static bits: uint = 32;\n+\n+    impl Primitive for u32 {\n+        #[inline(always)]\n+        fn bits() -> uint { 32 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<u32>() / 8 }\n+    }\n+\n+    impl BitCount for u32 {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> u32 { unsafe { intrinsics::ctpop32(*self as i32) as u32 } }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlp` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> u32 { unsafe { intrinsics::ctlz32(*self as i32) as u32 } }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttp` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> u32 { unsafe { intrinsics::cttz32(*self as i32) as u32 } }\n+    }\n }"}, {"sha": "756c29950c35b062b2fdf4dd902c6924e5e88a9f", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -11,8 +11,33 @@\n //! Operations and constants for `u64`\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+    use unstable::intrinsics;\n+\n     pub type T = u64;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i64;\n     pub static bits: uint = 64;\n+\n+    impl Primitive for u64 {\n+        #[inline(always)]\n+        fn bits() -> uint { 64 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<u64>() / 8 }\n+    }\n+\n+    impl BitCount for u64 {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> u64 { unsafe { intrinsics::ctpop64(*self as i64) as u64 } }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> u64 { unsafe { intrinsics::ctlz64(*self as i64) as u64 } }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> u64 { unsafe { intrinsics::cttz64(*self as i64) as u64 } }\n+    }\n }"}, {"sha": "5ac860c0359c547fd7217162a1245b169e6f49c8", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -11,8 +11,33 @@\n //! Operations and constants for `u8`\n \n mod inst {\n+    use num::{Primitive, BitCount};\n+    use unstable::intrinsics;\n+\n     pub type T = u8;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i8;\n     pub static bits: uint = 8;\n+\n+    impl Primitive for u8 {\n+        #[inline(always)]\n+        fn bits() -> uint { 8 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<u8>() / 8 }\n+    }\n+\n+    impl BitCount for u8 {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> u8 { unsafe { intrinsics::ctpop8(*self as i8) as u8 } }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> u8 { unsafe { intrinsics::ctlz8(*self as i8) as u8 } }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> u8 { unsafe { intrinsics::cttz8(*self as i8) as u8 } }\n+    }\n }"}, {"sha": "6a8567451e6e0ee45c1d5deb63b408f1dd12d3d8", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 110, "deletions": 64, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -18,6 +18,7 @@ pub use self::inst::{\n pub mod inst {\n     use sys;\n     use iter;\n+    use num::{Primitive, BitCount};\n \n     pub type T = uint;\n     #[allow(non_camel_case_types)]\n@@ -31,74 +32,119 @@ pub mod inst {\n     #[cfg(target_arch = \"x86_64\")]\n     pub static bits: uint = 64;\n \n-    /**\n-    * Divide two numbers, return the result, rounded up.\n-    *\n-    * # Arguments\n-    *\n-    * * x - an integer\n-    * * y - an integer distinct from 0u\n-    *\n-    * # Return value\n-    *\n-    * The smallest integer `q` such that `x/y <= q`.\n-    */\n+    impl Primitive for uint {\n+        #[cfg(target_word_size = \"32\")]\n+        #[inline(always)]\n+        fn bits() -> uint { 32 }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        #[inline(always)]\n+        fn bits() -> uint { 64 }\n+\n+        #[inline(always)]\n+        fn bytes() -> uint { Primitive::bits::<uint>() / 8 }\n+    }\n+\n+    #[cfg(target_word_size = \"32\")]\n+    #[inline(always)]\n+    impl BitCount for uint {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> uint { (*self as i32).population_count() as uint }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> uint { (*self as i32).leading_zeros() as uint }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> uint { (*self as i32).trailing_zeros() as uint }\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n+    #[inline(always)]\n+    impl BitCount for uint {\n+        /// Counts the number of bits set. Wraps LLVM's `ctpop` intrinsic.\n+        #[inline(always)]\n+        fn population_count(&self) -> uint { (*self as i64).population_count() as uint }\n+\n+        /// Counts the number of leading zeros. Wraps LLVM's `ctlz` intrinsic.\n+        #[inline(always)]\n+        fn leading_zeros(&self) -> uint { (*self as i64).leading_zeros() as uint }\n+\n+        /// Counts the number of trailing zeros. Wraps LLVM's `cttz` intrinsic.\n+        #[inline(always)]\n+        fn trailing_zeros(&self) -> uint { (*self as i64).trailing_zeros() as uint }\n+    }\n+\n+    ///\n+    /// Divide two numbers, return the result, rounded up.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * x - an integer\n+    /// * y - an integer distinct from 0u\n+    ///\n+    /// # Return value\n+    ///\n+    /// The smallest integer `q` such that `x/y <= q`.\n+    ///\n     pub fn div_ceil(x: uint, y: uint) -> uint {\n         let div = x / y;\n         if x % y == 0u { div }\n         else { div + 1u }\n     }\n \n-    /**\n-    * Divide two numbers, return the result, rounded to the closest integer.\n-    *\n-    * # Arguments\n-    *\n-    * * x - an integer\n-    * * y - an integer distinct from 0u\n-    *\n-    * # Return value\n-    *\n-    * The integer `q` closest to `x/y`.\n-    */\n+    ///\n+    /// Divide two numbers, return the result, rounded to the closest integer.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * x - an integer\n+    /// * y - an integer distinct from 0u\n+    ///\n+    /// # Return value\n+    ///\n+    /// The integer `q` closest to `x/y`.\n+    ///\n     pub fn div_round(x: uint, y: uint) -> uint {\n         let div = x / y;\n         if x % y * 2u  < y { div }\n         else { div + 1u }\n     }\n \n-    /**\n-    * Divide two numbers, return the result, rounded down.\n-    *\n-    * Note: This is the same function as `div`.\n-    *\n-    * # Arguments\n-    *\n-    * * x - an integer\n-    * * y - an integer distinct from 0u\n-    *\n-    * # Return value\n-    *\n-    * The smallest integer `q` such that `x/y <= q`. This\n-    * is either `x/y` or `x/y + 1`.\n-    */\n+    ///\n+    /// Divide two numbers, return the result, rounded down.\n+    ///\n+    /// Note: This is the same function as `div`.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * x - an integer\n+    /// * y - an integer distinct from 0u\n+    ///\n+    /// # Return value\n+    ///\n+    /// The smallest integer `q` such that `x/y <= q`. This\n+    /// is either `x/y` or `x/y + 1`.\n+    ///\n     pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n-    /**\n-    * Iterate over the range [`lo`..`hi`), or stop when requested\n-    *\n-    * # Arguments\n-    *\n-    * * lo - The integer at which to start the loop (included)\n-    * * hi - The integer at which to stop the loop (excluded)\n-    * * it - A block to execute with each consecutive integer of the range.\n-    *        Return `true` to continue, `false` to stop.\n-    *\n-    * # Return value\n-    *\n-    * `true` If execution proceeded correctly, `false` if it was interrupted,\n-    * that is if `it` returned `false` at any point.\n-    */\n+    ///\n+    /// Iterate over the range [`lo`..`hi`), or stop when requested\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * lo - The integer at which to start the loop (included)\n+    /// * hi - The integer at which to stop the loop (excluded)\n+    /// * it - A block to execute with each consecutive integer of the range.\n+    ///        Return `true` to continue, `false` to stop.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `true` If execution proceeded correctly, `false` if it was interrupted,\n+    /// that is if `it` returned `false` at any point.\n+    ///\n     pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n         let mut i = lo;\n         while i < hi {\n@@ -110,16 +156,16 @@ pub mod inst {\n \n     impl iter::Times for uint {\n         #[inline(always)]\n-        /**\n-        * A convenience form for basic iteration. Given a uint `x`,\n-        * `for x.times { ... }` executes the given block x times.\n-        *\n-        * Equivalent to `for uint::range(0, x) |_| { ... }`.\n-        *\n-        * Not defined on all integer types to permit unambiguous\n-        * use with integer literals of inferred integer-type as\n-        * the self-value (eg. `for 100.times { ... }`).\n-        */\n+        ///\n+        /// A convenience form for basic iteration. Given a uint `x`,\n+        /// `for x.times { ... }` executes the given block x times.\n+        ///\n+        /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n+        ///\n+        /// Not defined on all integer types to permit unambiguous\n+        /// use with integer literals of inferred integer-type as\n+        /// the self-value (eg. `for 100.times { ... }`).\n+        ///\n         fn times(&self, it: &fn() -> bool) {\n             let mut i = *self;\n             while i > 0 {"}, {"sha": "7e41f1b5b34e29c665f86f2a7215b74544b21908", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -38,8 +38,10 @@ pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::{Times, ExtendedMutableIter};\n pub use num::{Num, NumCast};\n-pub use num::{Signed, Unsigned, Integer};\n+pub use num::{Orderable, Signed, Unsigned, Integer};\n pub use num::{Round, Fractional, Real, RealExt};\n+pub use num::{Bitwise, BitCount, Bounded};\n+pub use num::{Primitive, Int, Float};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "214bb0be0ed2876d5170710f9ae238bedf687e50", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -148,10 +148,12 @@ impl Shr<uint, BigUint> for BigUint {\n \n impl Zero for BigUint {\n     fn zero() -> BigUint { BigUint::new(~[]) }\n+\n+    fn is_zero(&self) -> bool { self.data.is_empty() }\n }\n \n impl One for BigUint {\n-    pub fn one() -> BigUint { BigUint::new(~[1]) }\n+    fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Unsigned for BigUint {}\n@@ -310,7 +312,7 @@ impl ToStrRadix for BigUint {\n                 result += [m0.to_uint() as BigDigit];\n                 m = d;\n             }\n-            if m.is_not_zero() {\n+            if !m.is_zero() {\n                 result += [m.to_uint() as BigDigit];\n             }\n             return result;\n@@ -470,10 +472,6 @@ pub impl BigUint {\n         self.div_mod(other)\n     }\n \n-    fn is_zero(&self) -> bool { self.data.is_empty() }\n-\n-    fn is_not_zero(&self) -> bool { !self.data.is_empty() }\n-\n     fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n@@ -684,6 +682,8 @@ impl Zero for BigInt {\n     pub fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n+\n+    fn is_zero(&self) -> bool { self.sign == Zero }\n }\n \n impl One for BigInt {\n@@ -909,8 +909,6 @@ pub impl BigInt {\n \n     fn is_zero(&self) -> bool { self.sign == Zero }\n \n-    fn is_not_zero(&self) -> bool { self.sign != Zero }\n-\n     fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n@@ -1212,10 +1210,10 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            if a.is_not_zero() {\n+            if !a.is_zero() {\n                 assert!(c.quot_rem(&a) == (b, Zero::zero()));\n             }\n-            if b.is_not_zero() {\n+            if !b.is_zero() {\n                 assert!(c.quot_rem(&b) == (a, Zero::zero()));\n             }\n         }\n@@ -1227,7 +1225,7 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            if b.is_not_zero() { assert!(a.quot_rem(&b) == (c, d)); }\n+            if !b.is_zero() { assert!(a.quot_rem(&b) == (c, d)); }\n         }\n     }\n \n@@ -1577,7 +1575,7 @@ mod bigint_tests {\n     fn test_div_mod() {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n             let (d, m) = a.div_mod(b);\n-            if m.is_not_zero() {\n+            if !m.is_zero() {\n                 assert!(m.sign == b.sign);\n             }\n             assert!(m.abs() <= b.abs());\n@@ -1606,8 +1604,8 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            if a.is_not_zero() { check(&c, &a, &b, &Zero::zero()); }\n-            if b.is_not_zero() { check(&c, &b, &a, &Zero::zero()); }\n+            if !a.is_zero() { check(&c, &a, &b, &Zero::zero()); }\n+            if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n         for quot_rem_quadruples.each |elm| {\n@@ -1617,7 +1615,7 @@ mod bigint_tests {\n             let c = BigInt::from_slice(Plus, cVec);\n             let d = BigInt::from_slice(Plus, dVec);\n \n-            if b.is_not_zero() {\n+            if !b.is_zero() {\n                 check(&a, &b, &c, &d);\n             }\n         }\n@@ -1628,7 +1626,7 @@ mod bigint_tests {\n     fn test_quot_rem() {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n             let (q, r) = a.quot_rem(b);\n-            if r.is_not_zero() {\n+            if !r.is_zero() {\n                 assert!(r.sign == a.sign);\n             }\n             assert!(r.abs() <= b.abs());\n@@ -1649,8 +1647,8 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            if a.is_not_zero() { check(&c, &a, &b, &Zero::zero()); }\n-            if b.is_not_zero() { check(&c, &b, &a, &Zero::zero()); }\n+            if !a.is_zero() { check(&c, &a, &b, &Zero::zero()); }\n+            if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n         for quot_rem_quadruples.each |elm| {\n@@ -1660,7 +1658,7 @@ mod bigint_tests {\n             let c = BigInt::from_slice(Plus, cVec);\n             let d = BigInt::from_slice(Plus, dVec);\n \n-            if b.is_not_zero() {\n+            if !b.is_zero() {\n                 check(&a, &b, &c, &d);\n             }\n         }"}, {"sha": "fc17cbc678ea7e3296eda1f17d1130c0c104af07", "filename": "src/libstd/num/complex.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibstd%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibstd%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcomplex.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -125,6 +125,11 @@ impl<T: Copy + Num> Zero for Cmplx<T> {\n     fn zero() -> Cmplx<T> {\n         Cmplx::new(Zero::zero(), Zero::zero())\n     }\n+\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        *self == Zero::zero()\n+    }\n }\n \n impl<T: Copy + Num> One for Cmplx<T> {"}, {"sha": "93b63593a5eb0c33b76afdd9e2467da54c8aea42", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -191,6 +191,11 @@ impl<T: Copy + Num + Ord>\n     fn zero() -> Ratio<T> {\n         Ratio::new_raw(Zero::zero(), One::one())\n     }\n+\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        *self == Zero::zero()\n+    }\n }\n \n impl<T: Copy + Num + Ord>"}, {"sha": "08523de3ccd814df1f57277786db946ec77afd1d", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 71, "deletions": 67, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/aa38867e4e7da648a85985251f542bee12a64095/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa38867e4e7da648a85985251f542bee12a64095/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=aa38867e4e7da648a85985251f542bee12a64095", "patch": "@@ -10,82 +10,86 @@\n \n extern mod std;\n \n+use core::num::Float::{\n+  NaN, infinity, neg_infinity\n+};\n+\n pub fn main() {\n-  let nan = float::NaN;\n-  assert!((float::is_NaN(nan)));\n+  let nan = NaN::<float>();\n+  assert!((nan).is_NaN());\n \n-  let inf = float::infinity;\n-  assert!((-inf == float::neg_infinity));\n+  let inf = infinity::<float>();\n+  assert!(-inf == neg_infinity::<float>());\n \n-  assert!(( nan !=  nan));\n-  assert!(( nan != -nan));\n-  assert!((-nan != -nan));\n-  assert!((-nan !=  nan));\n+  assert!( nan !=  nan);\n+  assert!( nan != -nan);\n+  assert!(-nan != -nan);\n+  assert!(-nan !=  nan);\n \n-  assert!(( nan !=   1.));\n-  assert!(( nan !=   0.));\n-  assert!(( nan !=  inf));\n-  assert!(( nan != -inf));\n+  assert!( nan !=   1.);\n+  assert!( nan !=   0.);\n+  assert!( nan !=  inf);\n+  assert!( nan != -inf);\n \n-  assert!((  1. !=  nan));\n-  assert!((  0. !=  nan));\n-  assert!(( inf !=  nan));\n-  assert!((-inf !=  nan));\n+  assert!(  1. !=  nan);\n+  assert!(  0. !=  nan);\n+  assert!( inf !=  nan);\n+  assert!(-inf !=  nan);\n \n-  assert!((!( nan ==  nan)));\n-  assert!((!( nan == -nan)));\n-  assert!((!( nan ==   1.)));\n-  assert!((!( nan ==   0.)));\n-  assert!((!( nan ==  inf)));\n-  assert!((!( nan == -inf)));\n-  assert!((!(  1. ==  nan)));\n-  assert!((!(  0. ==  nan)));\n-  assert!((!( inf ==  nan)));\n-  assert!((!(-inf ==  nan)));\n-  assert!((!(-nan ==  nan)));\n-  assert!((!(-nan == -nan)));\n+  assert!(!( nan ==  nan));\n+  assert!(!( nan == -nan));\n+  assert!(!( nan ==   1.));\n+  assert!(!( nan ==   0.));\n+  assert!(!( nan ==  inf));\n+  assert!(!( nan == -inf));\n+  assert!(!(  1. ==  nan));\n+  assert!(!(  0. ==  nan));\n+  assert!(!( inf ==  nan));\n+  assert!(!(-inf ==  nan));\n+  assert!(!(-nan ==  nan));\n+  assert!(!(-nan == -nan));\n \n-  assert!((!( nan >  nan)));\n-  assert!((!( nan > -nan)));\n-  assert!((!( nan >   0.)));\n-  assert!((!( nan >  inf)));\n-  assert!((!( nan > -inf)));\n-  assert!((!(  0. >  nan)));\n-  assert!((!( inf >  nan)));\n-  assert!((!(-inf >  nan)));\n-  assert!((!(-nan >  nan)));\n+  assert!(!( nan >  nan));\n+  assert!(!( nan > -nan));\n+  assert!(!( nan >   0.));\n+  assert!(!( nan >  inf));\n+  assert!(!( nan > -inf));\n+  assert!(!(  0. >  nan));\n+  assert!(!( inf >  nan));\n+  assert!(!(-inf >  nan));\n+  assert!(!(-nan >  nan));\n \n-  assert!((!(nan <   0.)));\n-  assert!((!(nan <   1.)));\n-  assert!((!(nan <  -1.)));\n-  assert!((!(nan <  inf)));\n-  assert!((!(nan < -inf)));\n-  assert!((!(nan <  nan)));\n-  assert!((!(nan < -nan)));\n+  assert!(!(nan <   0.));\n+  assert!(!(nan <   1.));\n+  assert!(!(nan <  -1.));\n+  assert!(!(nan <  inf));\n+  assert!(!(nan < -inf));\n+  assert!(!(nan <  nan));\n+  assert!(!(nan < -nan));\n \n-  assert!((!(  0. < nan)));\n-  assert!((!(  1. < nan)));\n-  assert!((!( -1. < nan)));\n-  assert!((!( inf < nan)));\n-  assert!((!(-inf < nan)));\n-  assert!((!(-nan < nan)));\n+  assert!(!(  0. < nan));\n+  assert!(!(  1. < nan));\n+  assert!(!( -1. < nan));\n+  assert!(!( inf < nan));\n+  assert!(!(-inf < nan));\n+  assert!(!(-nan < nan));\n \n-  assert!((float::is_NaN(nan + inf)));\n-  assert!((float::is_NaN(nan + -inf)));\n-  assert!((float::is_NaN(nan + 0.)));\n-  assert!((float::is_NaN(nan + 1.)));\n-  assert!((float::is_NaN(nan * 1.)));\n-  assert!((float::is_NaN(nan / 1.)));\n-  assert!((float::is_NaN(nan / 0.)));\n-  assert!((float::is_NaN(0. / 0.)));\n-  assert!((float::is_NaN(-inf + inf)));\n-  assert!((float::is_NaN(inf - inf)));\n+  assert!((nan + inf).is_NaN());\n+  assert!((nan + -inf).is_NaN());\n+  assert!((nan + 0.).is_NaN());\n+  assert!((nan + 1.).is_NaN());\n+  assert!((nan * 1.).is_NaN());\n+  assert!((nan / 1.).is_NaN());\n+  assert!((nan / 0.).is_NaN());\n+  assert!((0f/0f).is_NaN());\n+  assert!((-inf + inf).is_NaN());\n+  assert!((inf - inf).is_NaN());\n \n-  assert!((!float::is_NaN(-1.)));\n-  assert!((!float::is_NaN(0.)));\n-  assert!((!float::is_NaN(0.1)));\n-  assert!((!float::is_NaN(1.)));\n-  assert!((!float::is_NaN(inf)));\n-  assert!((!float::is_NaN(-inf)));\n-  assert!((!float::is_NaN(1./-inf)));\n+  assert!(!(-1f).is_NaN());\n+  assert!(!(0f).is_NaN());\n+  assert!(!(0.1f).is_NaN());\n+  assert!(!(1f).is_NaN());\n+  assert!(!(inf).is_NaN());\n+  assert!(!(-inf).is_NaN());\n+  assert!(!(1./-inf).is_NaN());\n }"}]}