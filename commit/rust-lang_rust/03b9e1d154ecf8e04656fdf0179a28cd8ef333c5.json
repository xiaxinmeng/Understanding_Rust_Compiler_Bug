{"sha": "03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "node_id": "C_kwDOAAsO6NoAKDAzYjllMWQxNTRlY2Y4ZTA0NjU2ZmRmMDE3OWEyOGNkOGVmMzMzYzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-05T03:59:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-05T03:59:31Z"}, "message": "Auto merge of #105409 - compiler-errors:closure-infer-cycle, r=jackh726\n\nDon't deduce a signature that makes a closure cyclic\n\nSometimes when elaborating supertrait bounds for closure signature inference, we end up deducing a closure signature that is cyclical because either a parameter or the return type references a projection mentioning `Self` that also has escaping bound vars, which means that it's not eagerly replaced with an inference variable.\n\nInterestingly, this is not *just* related to my PR that elaborates supertrait bounds for closure signature deduction. The committed test `supertrait-hint-cycle-3.rs` shows **stable** code that is fixed by this PR:\n\n```rust\ntrait Foo<'a> {\n    type Input;\n}\n\nimpl<F: Fn(u32)> Foo<'_> for F {\n    type Input = u32;\n}\n\nfn needs_super<F: for<'a> Fn(<F as Foo<'a>>::Input) + for<'a> Foo<'a>>(_: F) {}\n\nfn main() {\n    needs_super(|_: u32| {});\n}\n```\n\nFixes #105401\nFixes #105396\n\nr? types", "tree": {"sha": "8c1b70fb5f8b03c7d47813924f1f0ca8c09438f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c1b70fb5f8b03c7d47813924f1f0ca8c09438f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "html_url": "https://github.com/rust-lang/rust/commit/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d26242d35faf50aa9c873fa3c7c15e5564384baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26242d35faf50aa9c873fa3c7c15e5564384baa", "html_url": "https://github.com/rust-lang/rust/commit/d26242d35faf50aa9c873fa3c7c15e5564384baa"}, {"sha": "fa2f31b97178c3a66d6e5f91fa597711f585fd3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa2f31b97178c3a66d6e5f91fa597711f585fd3b", "html_url": "https://github.com/rust-lang/rust/commit/fa2f31b97178c3a66d6e5f91fa597711f585fd3b"}], "stats": {"total": 172, "additions": 162, "deletions": 10}, "files": [{"sha": "3453da500b984f8f55f706d150d6d138efb0c575", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "patch": "@@ -13,14 +13,15 @@ use rustc_infer::infer::{InferOk, InferResult};\n use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TypeSuperVisitable, TypeVisitor};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use std::cmp;\n use std::iter;\n+use std::ops::ControlFlow;\n \n /// What signature do we *expect* the closure to have from context?\n #[derive(Debug, Clone, TypeFoldable, TypeVisitable)]\n@@ -54,7 +55,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // closure sooner rather than later, so first examine the expected\n         // type, and see if can glean a closure kind from there.\n         let (expected_sig, expected_kind) = match expected.to_option(self) {\n-            Some(ty) => self.deduce_expectations_from_expected_type(ty),\n+            Some(ty) => self.deduce_closure_signature(ty),\n             None => (None, None),\n         };\n         let body = self.tcx.hir().body(closure.body);\n@@ -162,13 +163,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Given the expected type, figures out what it can about this closure we\n     /// are about to type check:\n     #[instrument(skip(self), level = \"debug\")]\n-    fn deduce_expectations_from_expected_type(\n+    fn deduce_closure_signature(\n         &self,\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => self\n-                .deduce_signature_from_predicates(\n+                .deduce_closure_signature_from_predicates(\n+                    expected_ty,\n                     self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n                 ),\n             ty::Dynamic(ref object_type, ..) => {\n@@ -181,7 +183,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .and_then(|did| self.tcx.fn_trait_kind_from_def_id(did));\n                 (sig, kind)\n             }\n-            ty::Infer(ty::TyVar(vid)) => self.deduce_signature_from_predicates(\n+            ty::Infer(ty::TyVar(vid)) => self.deduce_closure_signature_from_predicates(\n+                self.tcx.mk_ty_var(self.root_var(vid)),\n                 self.obligations_for_self_ty(vid).map(|obl| (obl.predicate, obl.cause.span)),\n             ),\n             ty::FnPtr(sig) => {\n@@ -192,8 +195,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn deduce_signature_from_predicates(\n+    fn deduce_closure_signature_from_predicates(\n         &self,\n+        expected_ty: Ty<'tcx>,\n         predicates: impl DoubleEndedIterator<Item = (ty::Predicate<'tcx>, Span)>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let mut expected_sig = None;\n@@ -214,13 +218,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if expected_sig.is_none()\n                 && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n-                expected_sig = self.normalize(\n+                let inferred_sig = self.normalize(\n                     obligation.cause.span,\n                     self.deduce_sig_from_projection(\n                     Some(obligation.cause.span),\n                         bound_predicate.rebind(proj_predicate),\n                     ),\n                 );\n+                // Make sure that we didn't infer a signature that mentions itself.\n+                // This can happen when we elaborate certain supertrait bounds that\n+                // mention projections containing the `Self` type. See #105401.\n+                struct MentionsTy<'tcx> {\n+                    expected_ty: Ty<'tcx>,\n+                }\n+                impl<'tcx> TypeVisitor<'tcx> for MentionsTy<'tcx> {\n+                    type BreakTy = ();\n+\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                        if t == self.expected_ty {\n+                            ControlFlow::BREAK\n+                        } else {\n+                            t.super_visit_with(self)\n+                        }\n+                    }\n+                }\n+                if inferred_sig.visit_with(&mut MentionsTy { expected_ty }).is_continue() {\n+                    expected_sig = inferred_sig;\n+                }\n             }\n \n             // Even if we can't infer the full signature, we may be able to"}, {"sha": "4eeff2bdc7388f1e7db24cbc995787d5e2506f66", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "patch": "@@ -33,7 +33,7 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n-use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n@@ -1215,6 +1215,25 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n \n+            OutputTypeParameterMismatch(\n+                found_trait_ref,\n+                expected_trait_ref,\n+                terr @ TypeError::CyclicTy(_),\n+            ) => {\n+                let self_ty = found_trait_ref.self_ty().skip_binder();\n+                let (cause, terr) = if let ty::Closure(def_id, _) = self_ty.kind() {\n+                    (\n+                        ObligationCause::dummy_with_span(tcx.def_span(def_id)),\n+                        TypeError::CyclicTy(self_ty),\n+                    )\n+                } else {\n+                    (obligation.cause.clone(), terr)\n+                };\n+                self.report_and_explain_type_error(\n+                    TypeTrace::poly_trait_refs(&cause, true, expected_trait_ref, found_trait_ref),\n+                    terr,\n+                )\n+            }\n             OutputTypeParameterMismatch(found_trait_ref, expected_trait_ref, _) => {\n                 let found_trait_ref = self.resolve_vars_if_possible(found_trait_ref);\n                 let expected_trait_ref = self.resolve_vars_if_possible(expected_trait_ref);"}, {"sha": "fda81b18d1e9417750ff0d17e1369aa1b805c7fe", "filename": "src/test/ui/closures/supertrait-hint-cycle-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle-2.rs?ref=03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+trait Foo<'a> {\n+    type Input;\n+}\n+\n+impl<F: Fn(u32)> Foo<'_> for F {\n+    type Input = u32;\n+}\n+\n+trait SuperFn: for<'a> Foo<'a> + for<'a> Fn(<Self as Foo<'a>>::Input) {}\n+impl<T> SuperFn for T where T: for<'a> Fn(<Self as Foo<'a>>::Input) + for<'a> Foo<'a> {}\n+\n+fn needs_super(_: impl SuperFn) {}\n+\n+fn main() {\n+    needs_super(|_: u32| {});\n+}"}, {"sha": "8149474df196eb55ce09d1042ff30d8540b9829e", "filename": "src/test/ui/closures/supertrait-hint-cycle-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle-3.rs?ref=03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+\n+trait Foo<'a> {\n+    type Input;\n+}\n+\n+impl<F: Fn(u32)> Foo<'_> for F {\n+    type Input = u32;\n+}\n+\n+fn needs_super<F: for<'a> Fn(<F as Foo<'a>>::Input) + for<'a> Foo<'a>>(_: F) {}\n+\n+fn main() {\n+    needs_super(|_: u32| {});\n+}"}, {"sha": "dbb06b2ef7a7a345861b9f040faa759a517f5f45", "filename": "src/test/ui/closures/supertrait-hint-cycle.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fsupertrait-hint-cycle.rs?ref=03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "patch": "@@ -0,0 +1,65 @@\n+// edition:2021\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+#![feature(closure_lifetime_binder)]\n+\n+use std::future::Future;\n+\n+trait AsyncFn<I, R>: FnMut(I) -> Self::Fut {\n+    type Fut: Future<Output = R>;\n+}\n+\n+impl<F, I, R, Fut> AsyncFn<I, R> for F\n+where\n+    Fut: Future<Output = R>,\n+    F: FnMut(I) -> Fut,\n+{\n+    type Fut = Fut;\n+}\n+\n+async fn call<C, R, F>(mut ctx: C, mut f: F) -> Result<R, ()>\n+where\n+    F: for<'a> AsyncFn<&'a mut C, Result<R, ()>>,\n+{\n+    loop {\n+        match f(&mut ctx).await {\n+            Ok(val) => return Ok(val),\n+            Err(_) => continue,\n+        }\n+    }\n+}\n+\n+trait Cap<'a> {}\n+impl<T> Cap<'_> for T {}\n+\n+fn works(ctx: &mut usize) {\n+    let mut inner = 0;\n+\n+    type Ret<'a, 'b: 'a> = impl Future<Output = Result<usize, ()>> + 'a + Cap<'b>;\n+\n+    let callback = for<'a, 'b> |c: &'a mut &'b mut usize| -> Ret<'a, 'b> {\n+        inner += 1;\n+        async move {\n+            let _c = c;\n+            Ok(1usize)\n+        }\n+    };\n+    call(ctx, callback);\n+}\n+\n+fn doesnt_work_but_should(ctx: &mut usize) {\n+    let mut inner = 0;\n+\n+    type Ret<'a, 'b: 'a> = impl Future<Output = Result<usize, ()>> + 'a + Cap<'b>;\n+\n+    call(ctx, for<'a, 'b> |c: &'a mut &'b mut usize| -> Ret<'a, 'b> {\n+        inner += 1;\n+        async move {\n+            let _c = c;\n+            Ok(1usize)\n+        }\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "dadae23fdf39989a69f63b5546e882ef92ab0a88", "filename": "src/test/ui/issues/issue-25439.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Fissues%2Fissue-25439.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Fissues%2Fissue-25439.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25439.stderr?ref=03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "patch": "@@ -2,12 +2,17 @@ error[E0644]: closure/generator type that references itself\n   --> $DIR/issue-25439.rs:8:9\n    |\n LL |     fix(|_, x| x);\n-   |         ^^^^^^^^ cyclic type of infinite size\n+   |         ^^^^^^ cyclic type of infinite size\n    |\n    = note: closures cannot capture themselves or take themselves as argument;\n            this error may be the result of a recent compiler bug-fix,\n            see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\n            for more information\n+note: required by a bound in `fix`\n+  --> $DIR/issue-25439.rs:3:33\n+   |\n+LL | fn fix<F>(f: F) -> i32 where F: Fn(Helper<F>, i32) -> i32 {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `fix`\n \n error: aborting due to previous error\n "}, {"sha": "6d5dbca0558580a0e2dc934c7c112f946c83e4ed", "filename": "src/test/ui/unboxed-closures/unboxed-closure-no-cyclic-sig.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-no-cyclic-sig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03b9e1d154ecf8e04656fdf0179a28cd8ef333c5/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-no-cyclic-sig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-no-cyclic-sig.stderr?ref=03b9e1d154ecf8e04656fdf0179a28cd8ef333c5", "patch": "@@ -2,12 +2,17 @@ error[E0644]: closure/generator type that references itself\n   --> $DIR/unboxed-closure-no-cyclic-sig.rs:8:7\n    |\n LL |     g(|_| {  });\n-   |       ^^^^^^^^ cyclic type of infinite size\n+   |       ^^^ cyclic type of infinite size\n    |\n    = note: closures cannot capture themselves or take themselves as argument;\n            this error may be the result of a recent compiler bug-fix,\n            see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\n            for more information\n+note: required by a bound in `g`\n+  --> $DIR/unboxed-closure-no-cyclic-sig.rs:5:24\n+   |\n+LL | fn g<F>(_: F) where F: FnOnce(Option<F>) {}\n+   |                        ^^^^^^^^^^^^^^^^^ required by this bound in `g`\n \n error: aborting due to previous error\n "}]}