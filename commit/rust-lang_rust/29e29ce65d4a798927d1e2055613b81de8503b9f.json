{"sha": "29e29ce65d4a798927d1e2055613b81de8503b9f", "node_id": "C_kwDOAAsO6NoAKDI5ZTI5Y2U2NWQ0YTc5ODkyN2QxZTIwNTU2MTNiODFkZTg1MDNiOWY", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-03-23T19:57:49Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-03-23T19:57:49Z"}, "message": "fix some links, clarify documentation based on review feedback", "tree": {"sha": "574dd956733b5003053add8a3bfcb2a3b3118f3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/574dd956733b5003053add8a3bfcb2a3b3118f3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29e29ce65d4a798927d1e2055613b81de8503b9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29e29ce65d4a798927d1e2055613b81de8503b9f", "html_url": "https://github.com/rust-lang/rust/commit/29e29ce65d4a798927d1e2055613b81de8503b9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29e29ce65d4a798927d1e2055613b81de8503b9f/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7549cfa599004715a57fa17f8a988c216e0f6f4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7549cfa599004715a57fa17f8a988c216e0f6f4e", "html_url": "https://github.com/rust-lang/rust/commit/7549cfa599004715a57fa17f8a988c216e0f6f4e"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "282af8cc33fddbfa9c54751501ae8a91a027fd26", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/29e29ce65d4a798927d1e2055613b81de8503b9f/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e29ce65d4a798927d1e2055613b81de8503b9f/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=29e29ce65d4a798927d1e2055613b81de8503b9f", "patch": "@@ -1,18 +1,21 @@\n //! Inplace iterate-and-collect specialization for `Vec`\n //!\n+//! Note: This documents Vec internals, some of the following sections explain implementation\n+//! details and are best read together with the source of this module.\n+//!\n //! The specialization in this module applies to iterators in the shape of\n //! `source.adapter().adapter().adapter().collect::<Vec<U>>()`\n-//! where `source` is an owning iterator obtained from [`Vec<T>`], [`Box<[T]>`] (by conversion to `Vec`)\n+//! where `source` is an owning iterator obtained from [`Vec<T>`], [`Box<[T]>`][box] (by conversion to `Vec`)\n //! or [`BinaryHeap<T>`], the adapters each consume one or more items per step\n //! (represented by [`InPlaceIterable`]), provide transitive access to `source` (via [`SourceIter`])\n //! and thus the underlying allocation. And finally the layouts of `T` and `U` must\n-//! have the same size and alignment, this is currently ensured via const eval instead of trait\n-//! bounds.\n+//! have the same size and alignment, this is currently ensured via const eval instead of trait bounds\n+//! in the specialized [`SpecFromIter`] implementation.\n //!\n //! [`BinaryHeap<T>`]: crate::collections::BinaryHeap\n-//! [`Box<[T]>`]: crate::boxed::Box\n+//! [box]: crate::boxed::Box\n //!\n-//! By extension some other collections which use `collect::Vec<_>()` internally in their\n+//! By extension some other collections which use `collect::<Vec<_>>()` internally in their\n //! `FromIterator` implementation benefit from this too.\n //!\n //! Access to the underlying source goes through a further layer of indirection via the private\n@@ -27,10 +30,10 @@\n //! # Reading from and writing to the same allocation\n //!\n //! By its nature collecting in place means that the reader and writer side of the iterator\n-//! use the same allocation. Since `fold()` and co. take a reference to the iterator for the\n-//! duration of the iteration that means we can't interleave the step of reading a value\n-//! and getting a reference to write to. Instead raw pointers must be used on the reader\n-//! and writer side.\n+//! use the same allocation. Since `try_fold()` (used in [`SpecInPlaceCollect`]) takes a\n+//! reference to the iterator for the duration of the iteration that means we can't interleave\n+//! the step of reading a value and getting a reference to write to. Instead raw pointers must be\n+//! used on the reader and writer side.\n //!\n //! That writes never clobber a yet-to-be-read item is ensured by the [`InPlaceIterable`] requirements.\n //!\n@@ -49,25 +52,29 @@\n //! All those drops in turn can panic which then must either leak the allocation or abort to avoid\n //! double-drops.\n //!\n-//! These tasks are handled by [`InPlaceDrop`] and [`vec::IntoIter::forget_allocation_drop_remaining()`]\n+//! This is handled by the [`InPlaceDrop`] guard for sink items (`U`) and by\n+//! [`vec::IntoIter::forget_allocation_drop_remaining()`] for remaining source items (`T`).\n //!\n //! [`vec::IntoIter::forget_allocation_drop_remaining()`]: super::IntoIter::forget_allocation_drop_remaining()\n //!\n //! # O(1) collect\n //!\n //! The main iteration itself is further specialized when the iterator implements\n //! [`TrustedRandomAccessNoCoerce`] to let the optimizer see that it is a counted loop with a single\n-//! induction variable. This can turn some iterators into a noop, i.e. it reduces them from O(n) to\n+//! [induction variable]. This can turn some iterators into a noop, i.e. it reduces them from O(n) to\n //! O(1). This particular optimization is quite fickle and doesn't always work, see [#79308]\n //!\n //! [#79308]: https://github.com/rust-lang/rust/issues/79308\n+//! [induction variable]: https://en.wikipedia.org/wiki/Induction_variable\n //!\n //! Since unchecked accesses through that trait do not advance the read pointer of `IntoIter`\n //! this would interact unsoundly with the requirements about dropping the tail described above.\n //! But since the normal `Drop` implementation of `IntoIter` would suffer from the same problem it\n //! is only correct for `TrustedRandomAccessNoCoerce` to be implemented when the items don't\n //! have a destructor. Thus that implicit requirement also makes the specialization safe to use for\n //! in-place collection.\n+//! Note that this safety concern is about the correctness of `impl Drop for IntoIter`,\n+//! not the guarantees of `InPlaceIterable`.\n //!\n //! # Adapter implementations\n //!\n@@ -76,7 +83,7 @@\n //! For example `InPlaceIterable` would be valid to implement for [`Peekable`], except\n //! that it is stateful, cloneable and `IntoIter`'s clone implementation shortens the underlying\n //! allocation which means if the iterator has been peeked and then gets cloned there no longer is\n-//! enough room, thus breaking an invariant (#85322).\n+//! enough room, thus breaking an invariant ([#85322]).\n //!\n //! [#85322]: https://github.com/rust-lang/rust/issues/85322\n //! [`Peekable`]: core::iter::Peekable"}]}