{"sha": "d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzOWM2NmJmNGZmMmI0OTk1N2VkYWRmMTBhZmNjNDA1MGMzZmM2MGI=", "commit": {"author": {"name": "moxian", "email": "moxian@google.com", "date": "2018-05-08T06:19:55Z"}, "committer": {"name": "moxian", "email": "moxian@google.com", "date": "2018-06-28T21:56:42Z"}, "message": "Add a fallback for stacktrace printing for older Windows versions.\n\nPR #47252 switched stack inspection functions of dbghelp.dll\nto their newer alternatives that also capture inlined context.\nUnfortunately, said new alternatives are not present in older\ndbghelp.dll versions.\nIn particular Windows 7 at the time of writing has dbghelp.dll\nversion 6.1.7601 from 2010, that lacks StackWalkEx and friends.\n\nFixes #50138", "tree": {"sha": "c75ab891a3b5de6946c513d2b6203bf66367d2bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c75ab891a3b5de6946c513d2b6203bf66367d2bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "html_url": "https://github.com/rust-lang/rust/commit/d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d39c66bf4ff2b49957edadf10afcc4050c3fc60b/comments", "author": {"login": "moxian", "id": 7831163, "node_id": "MDQ6VXNlcjc4MzExNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7831163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/moxian", "html_url": "https://github.com/moxian", "followers_url": "https://api.github.com/users/moxian/followers", "following_url": "https://api.github.com/users/moxian/following{/other_user}", "gists_url": "https://api.github.com/users/moxian/gists{/gist_id}", "starred_url": "https://api.github.com/users/moxian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/moxian/subscriptions", "organizations_url": "https://api.github.com/users/moxian/orgs", "repos_url": "https://api.github.com/users/moxian/repos", "events_url": "https://api.github.com/users/moxian/events{/privacy}", "received_events_url": "https://api.github.com/users/moxian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "moxian", "id": 7831163, "node_id": "MDQ6VXNlcjc4MzExNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7831163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/moxian", "html_url": "https://github.com/moxian", "followers_url": "https://api.github.com/users/moxian/followers", "following_url": "https://api.github.com/users/moxian/following{/other_user}", "gists_url": "https://api.github.com/users/moxian/gists{/gist_id}", "starred_url": "https://api.github.com/users/moxian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/moxian/subscriptions", "organizations_url": "https://api.github.com/users/moxian/orgs", "repos_url": "https://api.github.com/users/moxian/repos", "events_url": "https://api.github.com/users/moxian/events{/privacy}", "received_events_url": "https://api.github.com/users/moxian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3bf634e060bc2f8665878288bcea02008ca346e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3bf634e060bc2f8665878288bcea02008ca346e", "html_url": "https://github.com/rust-lang/rust/commit/e3bf634e060bc2f8665878288bcea02008ca346e"}], "stats": {"total": 439, "additions": 331, "deletions": 108}, "files": [{"sha": "8e879e0f49e863a7b4c8f59c592813b06ade80f3", "filename": "src/libstd/sys/windows/backtrace/mod.rs", "status": "modified", "additions": 128, "deletions": 42, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d39c66bf4ff2b49957edadf10afcc4050c3fc60b/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39c66bf4ff2b49957edadf10afcc4050c3fc60b/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs?ref=d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "patch": "@@ -48,24 +48,21 @@ pub mod gnu;\n \n pub use self::printing::{resolve_symname, foreach_symbol_fileline};\n \n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n+pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n     let dbghelp = DynamicLibrary::open(\"dbghelp.dll\")?;\n \n     // Fetch the symbols necessary from dbghelp.dll\n     let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn)?;\n     let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn)?;\n-    let StackWalkEx = sym!(dbghelp, \"StackWalkEx\", StackWalkExFn)?;\n+    // StackWalkEx might not be present and we'll fall back to StackWalk64\n+    let ResStackWalkEx = sym!(dbghelp, \"StackWalkEx\", StackWalkExFn);\n+    let ResStackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn);\n \n     // Allocate necessary structures for doing the stack walk\n     let process = unsafe { c::GetCurrentProcess() };\n     let thread = unsafe { c::GetCurrentThread() };\n     let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n     unsafe { c::RtlCaptureContext(&mut context) };\n-    let mut frame: c::STACKFRAME_EX = unsafe { mem::zeroed() };\n-    frame.StackFrameSize = mem::size_of_val(&frame) as c::DWORD;\n-    let image = init_frame(&mut frame, &context);\n \n     let backtrace_context = BacktraceContext {\n         handle: process,\n@@ -76,49 +73,139 @@ pub fn unwind_backtrace(frames: &mut [Frame])\n     // Initialize this process's symbols\n     let ret = unsafe { SymInitialize(process, ptr::null_mut(), c::TRUE) };\n     if ret != c::TRUE {\n-        return Ok((0, backtrace_context))\n+        return Ok((0, backtrace_context));\n     }\n \n     // And now that we're done with all the setup, do the stack walking!\n-    let mut i = 0;\n-    unsafe {\n-        while i < frames.len() &&\n-              StackWalkEx(image, process, thread, &mut frame, &mut context,\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          0) == c::TRUE\n-        {\n-            let addr = (frame.AddrPC.Offset - 1) as *const u8;\n-\n-            frames[i] = Frame {\n-                symbol_addr: addr,\n-                exact_position: addr,\n-                inline_context: frame.InlineFrameContext,\n-            };\n-            i += 1;\n+    match (ResStackWalkEx, ResStackWalk64) {\n+        (Ok(StackWalkEx), _) => {\n+            let mut frame: c::STACKFRAME_EX = unsafe { mem::zeroed() };\n+            frame.StackFrameSize = mem::size_of_val(&frame) as c::DWORD;\n+            let image = init_frame_ex(&mut frame, &context);\n+\n+            let mut i = 0;\n+            unsafe {\n+                while i < frames.len()\n+                    && StackWalkEx(\n+                        image,\n+                        process,\n+                        thread,\n+                        &mut frame,\n+                        &mut context,\n+                        ptr::null_mut(),\n+                        ptr::null_mut(),\n+                        ptr::null_mut(),\n+                        ptr::null_mut(),\n+                        0,\n+                    ) == c::TRUE\n+                {\n+                    let addr = (frame.AddrPC.Offset - 1) as *const u8;\n+\n+                    frames[i] = Frame {\n+                        symbol_addr: addr,\n+                        exact_position: addr,\n+                        inline_context: frame.InlineFrameContext,\n+                    };\n+                    i += 1;\n+                }\n+            }\n+\n+            Ok((i, backtrace_context))\n         }\n+        (_, Ok(StackWalk64)) => {\n+            let mut frame: c::STACKFRAME64 = unsafe { mem::zeroed() };\n+            let image = init_frame_64(&mut frame, &context);\n+\n+            // Start from -1 to avoid printing this stack frame, which will\n+            // always be exactly the same.\n+            let mut i = 0;\n+            unsafe {\n+                while i < frames.len()\n+                    && StackWalk64(\n+                        image,\n+                        process,\n+                        thread,\n+                        &mut frame,\n+                        &mut context,\n+                        ptr::null_mut(),\n+                        ptr::null_mut(),\n+                        ptr::null_mut(),\n+                        ptr::null_mut(),\n+                    ) == c::TRUE\n+                {\n+                    let addr = frame.AddrPC.Offset;\n+                    if addr == frame.AddrReturn.Offset || addr == 0 || frame.AddrReturn.Offset == 0\n+                    {\n+                        break;\n+                    }\n+\n+                    frames[i] = Frame {\n+                        symbol_addr: (addr - 1) as *const u8,\n+                        exact_position: (addr - 1) as *const u8,\n+                        inline_context: 0,\n+                    };\n+                    i += 1;\n+                }\n+            }\n+\n+            Ok((i, backtrace_context))\n+        }\n+        (Err(e), _) => Err(e),\n     }\n-\n-    Ok((i, backtrace_context))\n }\n \n-type SymInitializeFn =\n-    unsafe extern \"system\" fn(c::HANDLE, *mut c_void,\n-                              c::BOOL) -> c::BOOL;\n-type SymCleanupFn =\n-    unsafe extern \"system\" fn(c::HANDLE) -> c::BOOL;\n+type SymInitializeFn = unsafe extern \"system\" fn(c::HANDLE, *mut c_void, c::BOOL) -> c::BOOL;\n+type SymCleanupFn = unsafe extern \"system\" fn(c::HANDLE) -> c::BOOL;\n+\n+type StackWalkExFn = unsafe extern \"system\" fn(\n+    c::DWORD,\n+    c::HANDLE,\n+    c::HANDLE,\n+    *mut c::STACKFRAME_EX,\n+    *mut c::CONTEXT,\n+    *mut c_void,\n+    *mut c_void,\n+    *mut c_void,\n+    *mut c_void,\n+    c::DWORD,\n+) -> c::BOOL;\n+\n+type StackWalk64Fn = unsafe extern \"system\" fn(\n+    c::DWORD,\n+    c::HANDLE,\n+    c::HANDLE,\n+    *mut c::STACKFRAME64,\n+    *mut c::CONTEXT,\n+    *mut c_void,\n+    *mut c_void,\n+    *mut c_void,\n+    *mut c_void,\n+) -> c::BOOL;\n \n-type StackWalkExFn =\n-    unsafe extern \"system\" fn(c::DWORD, c::HANDLE, c::HANDLE,\n-                              *mut c::STACKFRAME_EX, *mut c::CONTEXT,\n-                              *mut c_void, *mut c_void,\n-                              *mut c_void, *mut c_void, c::DWORD) -> c::BOOL;\n+#[cfg(target_arch = \"x86\")]\n+fn init_frame_ex(frame: &mut c::STACKFRAME_EX, ctx: &c::CONTEXT) -> c::DWORD {\n+    frame.AddrPC.Offset = ctx.Eip as u64;\n+    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    frame.AddrStack.Offset = ctx.Esp as u64;\n+    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    frame.AddrFrame.Offset = ctx.Ebp as u64;\n+    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    c::IMAGE_FILE_MACHINE_I386\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+fn init_frame_ex(frame: &mut c::STACKFRAME_EX, ctx: &c::CONTEXT) -> c::DWORD {\n+    frame.AddrPC.Offset = ctx.Rip as u64;\n+    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    frame.AddrStack.Offset = ctx.Rsp as u64;\n+    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    frame.AddrFrame.Offset = ctx.Rbp as u64;\n+    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+    c::IMAGE_FILE_MACHINE_AMD64\n+}\n \n #[cfg(target_arch = \"x86\")]\n-fn init_frame(frame: &mut c::STACKFRAME_EX,\n-              ctx: &c::CONTEXT) -> c::DWORD {\n+fn init_frame_64(frame: &mut c::STACKFRAME64, ctx: &c::CONTEXT) -> c::DWORD {\n     frame.AddrPC.Offset = ctx.Eip as u64;\n     frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n     frame.AddrStack.Offset = ctx.Esp as u64;\n@@ -129,8 +216,7 @@ fn init_frame(frame: &mut c::STACKFRAME_EX,\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-fn init_frame(frame: &mut c::STACKFRAME_EX,\n-              ctx: &c::CONTEXT) -> c::DWORD {\n+fn init_frame_64(frame: &mut c::STACKFRAME64, ctx: &c::CONTEXT) -> c::DWORD {\n     frame.AddrPC.Offset = ctx.Rip as u64;\n     frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n     frame.AddrStack.Offset = ctx.Rsp as u64;"}, {"sha": "e26d95a4f9d0a0a4545f4f9260676ebbb3be7b92", "filename": "src/libstd/sys/windows/backtrace/printing/msvc.rs", "status": "modified", "additions": 187, "deletions": 66, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/d39c66bf4ff2b49957edadf10afcc4050c3fc60b/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39c66bf4ff2b49957edadf10afcc4050c3fc60b/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs?ref=d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "patch": "@@ -10,88 +10,209 @@\n \n use ffi::CStr;\n use io;\n-use libc::{c_ulong, c_char};\n+use libc::{c_char, c_ulong};\n use mem;\n-use sys::c;\n use sys::backtrace::BacktraceContext;\n+use sys::c;\n use sys_common::backtrace::Frame;\n \n type SymFromInlineContextFn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG,\n-                              *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n-type SymGetLineFromInlineContextFn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG,\n-                              u64, *mut c::DWORD, *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n+    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n+type SymFromInlineContextFn =\n+    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n+type SymGetLineFromInlineContextFn = unsafe extern \"system\" fn(\n+    c::HANDLE,\n+    u64,\n+    c::ULONG,\n+    u64,\n+    *mut c::DWORD,\n+    *mut c::IMAGEHLP_LINE64,\n+) -> c::BOOL;\n+\n+type SymFromAddrFn =\n+    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n+type SymGetLineFromAddr64Fn =\n+    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u32, *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n \n /// Converts a pointer to symbol to its string value.\n-pub fn resolve_symname<F>(frame: Frame,\n-                          callback: F,\n-                          context: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n+pub fn resolve_symname<F>(frame: Frame, callback: F, context: &BacktraceContext) -> io::Result<()>\n+where\n+    F: FnOnce(Option<&str>) -> io::Result<()>,\n {\n-    let SymFromInlineContext = sym!(&context.dbghelp,\n-                                    \"SymFromInlineContext\",\n-                                    SymFromInlineContextFn)?;\n+    match (\n+        sym!(\n+            &context.dbghelp,\n+            \"SymFromInlineContext\",\n+            SymFromInlineContextFn\n+        ),\n+        sym!(&context.dbghelp, \"SymFromAddr\", SymFromAddrFn),\n+    ) {\n+        (Ok(SymFromInlineContext), _) => unsafe {\n+            let mut info: c::SYMBOL_INFO = mem::zeroed();\n+            info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n+            // the struct size in C.  the value is different to\n+            // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+            // due to struct alignment.\n+            info.SizeOfStruct = 88;\n \n-    unsafe {\n-        let mut info: c::SYMBOL_INFO = mem::zeroed();\n-        info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n-        // the struct size in C.  the value is different to\n-        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-        // due to struct alignment.\n-        info.SizeOfStruct = 88;\n+            let mut displacement = 0u64;\n+            let ret = SymFromInlineContext(\n+                context.handle,\n+                frame.symbol_addr as u64,\n+                frame.inline_context,\n+                &mut displacement,\n+                &mut info,\n+            );\n+            let valid_range =\n+                if ret == c::TRUE && frame.symbol_addr as usize >= info.Address as usize {\n+                    if info.Size != 0 {\n+                        (frame.symbol_addr as usize) < info.Address as usize + info.Size as usize\n+                    } else {\n+                        true\n+                    }\n+                } else {\n+                    false\n+                };\n+            let symname = if valid_range {\n+                let ptr = info.Name.as_ptr() as *const c_char;\n+                CStr::from_ptr(ptr).to_str().ok()\n+            } else {\n+                None\n+            };\n+            callback(symname)\n+{\n+    match (\n+        sym!(\n+            &context.dbghelp,\n+            \"SymFromInlineContext\",\n+            SymFromInlineContextFn\n+        ),\n+        sym!(&context.dbghelp, \"SymFromAddr\", SymFromAddrFn),\n+    ) {\n+        (Ok(SymFromInlineContext), _) => unsafe {\n+            let mut info: c::SYMBOL_INFO = mem::zeroed();\n+            info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n+            // the struct size in C.  the value is different to\n+            // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+            // due to struct alignment.\n+            info.SizeOfStruct = 88;\n \n-        let mut displacement = 0u64;\n-        let ret = SymFromInlineContext(context.handle,\n-                                       frame.symbol_addr as u64,\n-                                       frame.inline_context,\n-                                       &mut displacement,\n-                                       &mut info);\n-        let valid_range = if ret == c::TRUE &&\n-                             frame.symbol_addr as usize >= info.Address as usize {\n-            if info.Size != 0 {\n-                (frame.symbol_addr as usize) < info.Address as usize + info.Size as usize\n+            let mut displacement = 0u64;\n+            let ret = SymFromInlineContext(\n+                context.handle,\n+                frame.symbol_addr as u64,\n+                frame.inline_context,\n+                &mut displacement,\n+                &mut info,\n+            );\n+            let valid_range =\n+                if ret == c::TRUE && frame.symbol_addr as usize >= info.Address as usize {\n+                    if info.Size != 0 {\n+                        (frame.symbol_addr as usize) < info.Address as usize + info.Size as usize\n+                    } else {\n+                        true\n+                    }\n+                } else {\n+                    false\n+                };\n+            let symname = if valid_range {\n+                let ptr = info.Name.as_ptr() as *const c_char;\n+                CStr::from_ptr(ptr).to_str().ok()\n             } else {\n-                true\n-            }\n-        } else {\n-            false\n-        };\n-        let symname = if valid_range {\n-            let ptr = info.Name.as_ptr() as *const c_char;\n-            CStr::from_ptr(ptr).to_str().ok()\n-        } else {\n-            None\n-        };\n-        callback(symname)\n+                None\n+            };\n+            callback(symname)\n+        },\n+        (_, Ok(SymFromAddr)) => unsafe {\n+            } else {\n+                None\n+            };\n+            callback(symname)\n+        },\n+        (_, Ok(SymFromAddr)) => unsafe {\n+            let mut info: c::SYMBOL_INFO = mem::zeroed();\n+            info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n+            // the struct size in C.  the value is different to\n+            // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+            // due to struct alignment.\n+            info.SizeOfStruct = 88;\n+\n+            let mut displacement = 0u64;\n+            let ret = SymFromAddr(\n+                context.handle,\n+                frame.symbol_addr as u64,\n+                &mut displacement,\n+                &mut info,\n+            );\n+\n+            let symname = if ret == c::TRUE {\n+                let ptr = info.Name.as_ptr() as *const c_char;\n+                CStr::from_ptr(ptr).to_str().ok()\n+            } else {\n+                None\n+            };\n+            callback(symname)\n+        },\n+        (Err(e), _) => Err(e),\n     }\n }\n \n-pub fn foreach_symbol_fileline<F>(frame: Frame,\n-                                  mut f: F,\n-                                  context: &BacktraceContext)\n-    -> io::Result<bool>\n-    where F: FnMut(&[u8], u32) -> io::Result<()>\n+pub fn foreach_symbol_fileline<F>(\n+    frame: Frame,\n+    mut f: F,\n+    context: &BacktraceContext,\n+) -> io::Result<bool>\n+where\n+    F: FnMut(&[u8], u32) -> io::Result<()>,\n {\n-    let SymGetLineFromInlineContext = sym!(&context.dbghelp,\n-                                    \"SymGetLineFromInlineContext\",\n-                                    SymGetLineFromInlineContextFn)?;\n+    match (\n+        sym!(\n+            &context.dbghelp,\n+            \"SymGetLineFromInlineContext\",\n+            SymGetLineFromInlineContextFn\n+        ),\n+        sym!(\n+            &context.dbghelp,\n+            \"SymGetLineFromAddr64\",\n+            SymGetLineFromAddr64Fn\n+        ),\n+    ) {\n+        (Ok(SymGetLineFromInlineContext), _) => unsafe {\n+            let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n+            line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n \n-    unsafe {\n-        let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n-        line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n+            let mut displacement = 0u32;\n+            let ret = SymGetLineFromInlineContext(\n+                context.handle,\n+                frame.exact_position as u64,\n+                frame.inline_context,\n+                0,\n+                &mut displacement,\n+                &mut line,\n+            );\n+            if ret == c::TRUE {\n+                let name = CStr::from_ptr(line.Filename).to_bytes();\n+                f(name, line.LineNumber as u32)?;\n+            }\n+            Ok(false)\n+        },\n+        (_, Ok(SymGetLineFromAddr64)) => unsafe {\n+            let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n+            line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n \n-        let mut displacement = 0u32;\n-        let ret = SymGetLineFromInlineContext(context.handle,\n-                                              frame.exact_position as u64,\n-                                              frame.inline_context,\n-                                              0,\n-                                              &mut displacement,\n-                                              &mut line);\n-        if ret == c::TRUE {\n-            let name = CStr::from_ptr(line.Filename).to_bytes();\n-            f(name, line.LineNumber as u32)?;\n-        }\n-        Ok(false)\n+            let mut displacement = 0u32;\n+            let ret = SymGetLineFromAddr64(\n+                context.handle,\n+                frame.exact_position as u64,\n+                &mut displacement,\n+                &mut line,\n+            );\n+            if ret == c::TRUE {\n+                let name = CStr::from_ptr(line.Filename).to_bytes();\n+                f(name, line.LineNumber as u32)?;\n+            }\n+            Ok(false)\n+        },\n+        (Err(e), _) => Err(e),\n     }\n }"}, {"sha": "30aba2f400f2f8059fd6680105833d5f0d77d827", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d39c66bf4ff2b49957edadf10afcc4050c3fc60b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39c66bf4ff2b49957edadf10afcc4050c3fc60b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "patch": "@@ -635,6 +635,22 @@ pub struct STACKFRAME_EX {\n     pub InlineFrameContext: DWORD,\n }\n \n+#[repr(C)]\n+#[cfg(feature = \"backtrace\")]\n+pub struct STACKFRAME64 {\n+    pub AddrPC: ADDRESS64,\n+    pub AddrReturn: ADDRESS64,\n+    pub AddrFrame: ADDRESS64,\n+    pub AddrStack: ADDRESS64,\n+    pub AddrBStore: ADDRESS64,\n+    pub FuncTableEntry: *mut c_void,\n+    pub Params: [u64; 4],\n+    pub Far: BOOL,\n+    pub Virtual: BOOL,\n+    pub Reserved: [u64; 3],\n+    pub KdHelp: KDHELP64,\n+}\n+\n #[repr(C)]\n #[cfg(feature = \"backtrace\")]\n pub struct KDHELP64 {"}]}