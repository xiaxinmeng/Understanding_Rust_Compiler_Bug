{"sha": "bd4d375a64e6ab58896ddcccb81e06dd5b4051d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNGQzNzVhNjRlNmFiNTg4OTZkZGNjY2I4MWUwNmRkNWI0MDUxZDM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-11-17T12:35:25Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-11-17T14:25:58Z"}, "message": "Make code more readable", "tree": {"sha": "6812356d036e320b88ea7509b6abd844fd1e0359", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6812356d036e320b88ea7509b6abd844fd1e0359"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd4d375a64e6ab58896ddcccb81e06dd5b4051d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4d375a64e6ab58896ddcccb81e06dd5b4051d3", "html_url": "https://github.com/rust-lang/rust/commit/bd4d375a64e6ab58896ddcccb81e06dd5b4051d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd4d375a64e6ab58896ddcccb81e06dd5b4051d3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0c4dbc399ee11cc8c34e5ef33d7c3cba8a03d47", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c4dbc399ee11cc8c34e5ef33d7c3cba8a03d47", "html_url": "https://github.com/rust-lang/rust/commit/a0c4dbc399ee11cc8c34e5ef33d7c3cba8a03d47"}], "stats": {"total": 393, "additions": 207, "deletions": 186}, "files": [{"sha": "3ea6ba47e0d91068b855be6df651ff44aa4cce1d", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 207, "deletions": 186, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/bd4d375a64e6ab58896ddcccb81e06dd5b4051d3/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4d375a64e6ab58896ddcccb81e06dd5b4051d3/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=bd4d375a64e6ab58896ddcccb81e06dd5b4051d3", "patch": "@@ -197,215 +197,236 @@ impl ProjectWorkspace {\n         proc_macro_client: &ProcMacroClient,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     ) -> CrateGraph {\n-        let mut crate_graph = CrateGraph::default();\n-        match self {\n+        let mut crate_graph = match self {\n             ProjectWorkspace::Json { project, sysroot } => {\n-                let sysroot_deps = sysroot\n-                    .as_ref()\n-                    .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n-\n-                let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n-                let crates: FxHashMap<CrateId, CrateId> = project\n-                    .crates()\n-                    .filter_map(|(crate_id, krate)| {\n-                        let file_path = &krate.root_module;\n-                        let file_id = load(&file_path)?;\n-                        Some((crate_id, krate, file_id))\n-                    })\n-                    .map(|(crate_id, krate, file_id)| {\n-                        let env = krate.env.clone().into_iter().collect();\n-                        let proc_macro = krate\n-                            .proc_macro_dylib_path\n-                            .clone()\n-                            .map(|it| proc_macro_client.by_dylib_path(&it));\n-\n-                        let target = krate.target.as_deref().or(target);\n-                        let target_cfgs = cfg_cache\n-                            .entry(target)\n-                            .or_insert_with(|| get_rustc_cfg_options(target));\n-\n-                        let mut cfg_options = CfgOptions::default();\n-                        cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n-                        (\n-                            crate_id,\n-                            crate_graph.add_crate_root(\n-                                file_id,\n-                                krate.edition,\n-                                krate.display_name.clone(),\n-                                cfg_options,\n-                                env,\n-                                proc_macro.unwrap_or_default(),\n-                            ),\n-                        )\n-                    })\n-                    .collect();\n-\n-                for (from, krate) in project.crates() {\n-                    if let Some(&from) = crates.get(&from) {\n-                        if let Some((public_deps, _proc_macro)) = &sysroot_deps {\n-                            for (name, to) in public_deps.iter() {\n-                                add_dep(&mut crate_graph, from, name.clone(), *to)\n-                            }\n-                        }\n-\n-                        for dep in &krate.deps {\n-                            if let Some(&to) = crates.get(&dep.crate_id) {\n-                                add_dep(&mut crate_graph, from, dep.name.clone(), to)\n-                            }\n-                        }\n-                    }\n-                }\n+                project_json_to_crate_graph(target, proc_macro_client, load, project, sysroot)\n             }\n             ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                let (public_deps, libproc_macro) =\n-                    sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n+                cargo_to_crate_graph(target, proc_macro_client, load, cargo, sysroot, rustc)\n+            }\n+        };\n+        if crate_graph.patch_cfg_if() {\n+            log::debug!(\"Patched std to depend on cfg-if\")\n+        } else {\n+            log::debug!(\"Did not patch std to depend on cfg-if\")\n+        }\n+        crate_graph\n+    }\n+}\n \n-                let mut cfg_options = CfgOptions::default();\n-                cfg_options.extend(get_rustc_cfg_options(target));\n+fn project_json_to_crate_graph(\n+    target: Option<&str>,\n+    proc_macro_client: &ProcMacroClient,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    project: &ProjectJson,\n+    sysroot: &Option<Sysroot>,\n+) -> CrateGraph {\n+    let mut crate_graph = CrateGraph::default();\n+    let sysroot_deps = sysroot\n+        .as_ref()\n+        .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n+\n+    let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n+    let crates: FxHashMap<CrateId, CrateId> = project\n+        .crates()\n+        .filter_map(|(crate_id, krate)| {\n+            let file_path = &krate.root_module;\n+            let file_id = load(&file_path)?;\n+            Some((crate_id, krate, file_id))\n+        })\n+        .map(|(crate_id, krate, file_id)| {\n+            let env = krate.env.clone().into_iter().collect();\n+            let proc_macro =\n+                krate.proc_macro_dylib_path.clone().map(|it| proc_macro_client.by_dylib_path(&it));\n+\n+            let target = krate.target.as_deref().or(target);\n+            let target_cfgs =\n+                cfg_cache.entry(target).or_insert_with(|| get_rustc_cfg_options(target));\n+\n+            let mut cfg_options = CfgOptions::default();\n+            cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n+            (\n+                crate_id,\n+                crate_graph.add_crate_root(\n+                    file_id,\n+                    krate.edition,\n+                    krate.display_name.clone(),\n+                    cfg_options,\n+                    env,\n+                    proc_macro.unwrap_or_default(),\n+                ),\n+            )\n+        })\n+        .collect();\n \n-                let mut pkg_to_lib_crate = FxHashMap::default();\n+    for (from, krate) in project.crates() {\n+        if let Some(&from) = crates.get(&from) {\n+            if let Some((public_deps, _proc_macro)) = &sysroot_deps {\n+                for (name, to) in public_deps.iter() {\n+                    add_dep(&mut crate_graph, from, name.clone(), *to)\n+                }\n+            }\n \n-                // Add test cfg for non-sysroot crates\n-                cfg_options.insert_atom(\"test\".into());\n-                cfg_options.insert_atom(\"debug_assertions\".into());\n+            for dep in &krate.deps {\n+                if let Some(&to) = crates.get(&dep.crate_id) {\n+                    add_dep(&mut crate_graph, from, dep.name.clone(), to)\n+                }\n+            }\n+        }\n+    }\n+    crate_graph\n+}\n \n-                let mut pkg_crates = FxHashMap::default();\n+fn cargo_to_crate_graph(\n+    target: Option<&str>,\n+    proc_macro_client: &ProcMacroClient,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    cargo: &CargoWorkspace,\n+    sysroot: &Sysroot,\n+    rustc: &Option<CargoWorkspace>,\n+) -> CrateGraph {\n+    let mut crate_graph = CrateGraph::default();\n+    let (public_deps, libproc_macro) =\n+        sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n \n-                // Next, create crates for each package, target pair\n-                for pkg in cargo.packages() {\n-                    let mut lib_tgt = None;\n-                    for &tgt in cargo[pkg].targets.iter() {\n-                        if let Some(crate_id) = add_target_crate_root(\n+    let mut cfg_options = CfgOptions::default();\n+    cfg_options.extend(get_rustc_cfg_options(target));\n+\n+    let mut pkg_to_lib_crate = FxHashMap::default();\n+\n+    // Add test cfg for non-sysroot crates\n+    cfg_options.insert_atom(\"test\".into());\n+    cfg_options.insert_atom(\"debug_assertions\".into());\n+\n+    let mut pkg_crates = FxHashMap::default();\n+\n+    // Next, create crates for each package, target pair\n+    for pkg in cargo.packages() {\n+        let mut lib_tgt = None;\n+        for &tgt in cargo[pkg].targets.iter() {\n+            if let Some(crate_id) = add_target_crate_root(\n+                &mut crate_graph,\n+                &cargo[pkg],\n+                &cargo[tgt],\n+                &cfg_options,\n+                proc_macro_client,\n+                load,\n+            ) {\n+                if cargo[tgt].kind == TargetKind::Lib {\n+                    lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n+                    pkg_to_lib_crate.insert(pkg, crate_id);\n+                }\n+                if cargo[tgt].is_proc_macro {\n+                    if let Some(proc_macro) = libproc_macro {\n+                        add_dep(\n                             &mut crate_graph,\n-                            &cargo[pkg],\n-                            &cargo[tgt],\n-                            &cfg_options,\n-                            proc_macro_client,\n-                            load,\n-                        ) {\n-                            if cargo[tgt].kind == TargetKind::Lib {\n-                                lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                            }\n-                            if cargo[tgt].is_proc_macro {\n-                                if let Some(proc_macro) = libproc_macro {\n-                                    add_dep(\n-                                        &mut crate_graph,\n-                                        crate_id,\n-                                        CrateName::new(\"proc_macro\").unwrap(),\n-                                        proc_macro,\n-                                    );\n-                                }\n-                            }\n-\n-                            pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                        }\n+                            crate_id,\n+                            CrateName::new(\"proc_macro\").unwrap(),\n+                            proc_macro,\n+                        );\n                     }\n+                }\n \n-                    // Set deps to the core, std and to the lib target of the current package\n-                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                        if let Some((to, name)) = lib_tgt.clone() {\n-                            if to != from {\n-                                // For root projects with dashes in their name,\n-                                // cargo metadata does not do any normalization,\n-                                // so we do it ourselves currently\n-                                let name = CrateName::normalize_dashes(&name);\n-                                add_dep(&mut crate_graph, from, name, to);\n-                            }\n-                        }\n-                        for (name, krate) in public_deps.iter() {\n-                            add_dep(&mut crate_graph, from, name.clone(), *krate);\n-                        }\n-                    }\n+                pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+            }\n+        }\n+\n+        // Set deps to the core, std and to the lib target of the current package\n+        for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+            if let Some((to, name)) = lib_tgt.clone() {\n+                if to != from {\n+                    // For root projects with dashes in their name,\n+                    // cargo metadata does not do any normalization,\n+                    // so we do it ourselves currently\n+                    let name = CrateName::normalize_dashes(&name);\n+                    add_dep(&mut crate_graph, from, name, to);\n                 }\n+            }\n+            for (name, krate) in public_deps.iter() {\n+                add_dep(&mut crate_graph, from, name.clone(), *krate);\n+            }\n+        }\n+    }\n \n-                // Now add a dep edge from all targets of upstream to the lib\n-                // target of downstream.\n-                for pkg in cargo.packages() {\n-                    for dep in cargo[pkg].dependencies.iter() {\n-                        let name = CrateName::new(&dep.name).unwrap();\n-                        if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                add_dep(&mut crate_graph, from, name.clone(), to)\n-                            }\n-                        }\n-                    }\n+    // Now add a dep edge from all targets of upstream to the lib\n+    // target of downstream.\n+    for pkg in cargo.packages() {\n+        for dep in cargo[pkg].dependencies.iter() {\n+            let name = CrateName::new(&dep.name).unwrap();\n+            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                    add_dep(&mut crate_graph, from, name.clone(), to)\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut rustc_pkg_crates = FxHashMap::default();\n+\n+    // If the user provided a path to rustc sources, we add all the rustc_private crates\n+    // and create dependencies on them for the crates in the current workspace\n+    if let Some(rustc_workspace) = rustc {\n+        for pkg in rustc_workspace.packages() {\n+            for &tgt in rustc_workspace[pkg].targets.iter() {\n+                if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                    continue;\n+                }\n+                // Exclude alloc / core / std\n+                if rustc_workspace[tgt]\n+                    .root\n+                    .components()\n+                    .any(|c| c == Component::Normal(\"library\".as_ref()))\n+                {\n+                    continue;\n                 }\n \n-                let mut rustc_pkg_crates = FxHashMap::default();\n-\n-                // If the user provided a path to rustc sources, we add all the rustc_private crates\n-                // and create dependencies on them for the crates in the current workspace\n-                if let Some(rustc_workspace) = rustc {\n-                    for pkg in rustc_workspace.packages() {\n-                        for &tgt in rustc_workspace[pkg].targets.iter() {\n-                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n-                                continue;\n-                            }\n-                            // Exclude alloc / core / std\n-                            if rustc_workspace[tgt]\n-                                .root\n-                                .components()\n-                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n-                            {\n-                                continue;\n-                            }\n-\n-                            if let Some(crate_id) = add_target_crate_root(\n-                                &mut crate_graph,\n-                                &rustc_workspace[pkg],\n-                                &rustc_workspace[tgt],\n-                                &cfg_options,\n-                                proc_macro_client,\n-                                load,\n-                            ) {\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                                // Add dependencies on the core / std / alloc for rustc\n-                                for (name, krate) in public_deps.iter() {\n-                                    add_dep(&mut crate_graph, crate_id, name.clone(), *krate);\n-                                }\n-                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                            }\n-                        }\n+                if let Some(crate_id) = add_target_crate_root(\n+                    &mut crate_graph,\n+                    &rustc_workspace[pkg],\n+                    &rustc_workspace[tgt],\n+                    &cfg_options,\n+                    proc_macro_client,\n+                    load,\n+                ) {\n+                    pkg_to_lib_crate.insert(pkg, crate_id);\n+                    // Add dependencies on the core / std / alloc for rustc\n+                    for (name, krate) in public_deps.iter() {\n+                        add_dep(&mut crate_graph, crate_id, name.clone(), *krate);\n                     }\n-                    // Now add a dep edge from all targets of upstream to the lib\n-                    // target of downstream.\n-                    for pkg in rustc_workspace.packages() {\n-                        for dep in rustc_workspace[pkg].dependencies.iter() {\n-                            let name = CrateName::new(&dep.name).unwrap();\n-                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    add_dep(&mut crate_graph, from, name.clone(), to);\n-                                }\n-                            }\n-                        }\n+                    rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                }\n+            }\n+        }\n+        // Now add a dep edge from all targets of upstream to the lib\n+        // target of downstream.\n+        for pkg in rustc_workspace.packages() {\n+            for dep in rustc_workspace[pkg].dependencies.iter() {\n+                let name = CrateName::new(&dep.name).unwrap();\n+                if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                    for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                        add_dep(&mut crate_graph, from, name.clone(), to);\n                     }\n+                }\n+            }\n+        }\n+\n+        // Add dependencies for all the crates of the current workspace to rustc_private libraries\n+        for dep in rustc_workspace.packages() {\n+            let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n \n-                    // Add dependencies for all the crates of the current workspace to rustc_private libraries\n-                    for dep in rustc_workspace.packages() {\n-                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n-\n-                        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n-                            for pkg in cargo.packages() {\n-                                if !cargo[pkg].is_member {\n-                                    continue;\n-                                }\n-                                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    add_dep(&mut crate_graph, from, name.clone(), to);\n-                                }\n-                            }\n-                        }\n+            if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+                for pkg in cargo.packages() {\n+                    if !cargo[pkg].is_member {\n+                        continue;\n+                    }\n+                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                        add_dep(&mut crate_graph, from, name.clone(), to);\n                     }\n                 }\n             }\n         }\n-        if crate_graph.patch_cfg_if() {\n-            log::debug!(\"Patched std to depend on cfg-if\")\n-        } else {\n-            log::debug!(\"Did not patch std to depend on cfg-if\")\n-        }\n-        crate_graph\n     }\n+    crate_graph\n }\n \n fn add_target_crate_root("}]}