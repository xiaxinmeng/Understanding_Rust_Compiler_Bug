{"sha": "98fda878d8d109c7b3337593d5396a3b893aa966", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZmRhODc4ZDhkMTA5YzdiMzMzNzU5M2Q1Mzk2YTNiODkzYWE5NjY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-03T22:28:38Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-05T22:22:12Z"}, "message": "conv_did: convert to \"unboxed\" closure", "tree": {"sha": "90f92ae6a972f05a9f9d26cd21c78be2fd8bd2b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90f92ae6a972f05a9f9d26cd21c78be2fd8bd2b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98fda878d8d109c7b3337593d5396a3b893aa966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98fda878d8d109c7b3337593d5396a3b893aa966", "html_url": "https://github.com/rust-lang/rust/commit/98fda878d8d109c7b3337593d5396a3b893aa966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98fda878d8d109c7b3337593d5396a3b893aa966/comments", "author": null, "committer": null, "parents": [{"sha": "07a8e7cfb5128a2b1697713a0ec84329e4e44f1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a8e7cfb5128a2b1697713a0ec84329e4e44f1a", "html_url": "https://github.com/rust-lang/rust/commit/07a8e7cfb5128a2b1697713a0ec84329e4e44f1a"}], "stats": {"total": 381, "additions": 254, "deletions": 127}, "files": [{"sha": "825daa7ddb94cc1582fa15414d6101447725a008", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 254, "deletions": 127, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/98fda878d8d109c7b3337593d5396a3b893aa966/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98fda878d8d109c7b3337593d5396a3b893aa966/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=98fda878d8d109c7b3337593d5396a3b893aa966", "patch": "@@ -61,8 +61,7 @@ pub enum DefIdSource {\n     UnboxedClosureSource\n }\n \n-pub type conv_did<'a> =\n-    |source: DefIdSource, ast::DefId|: 'a -> ast::DefId;\n+// type conv_did = impl FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n \n pub struct PState<'a, 'tcx: 'a> {\n     data: &'a [u8],\n@@ -145,70 +144,88 @@ fn data_log_string(data: &[u8], pos: uint) -> String {\n     buf\n }\n \n-pub fn parse_ty_closure_data<'tcx>(data: &[u8],\n-                                   crate_num: ast::CrateNum,\n-                                   pos: uint,\n-                                   tcx: &ty::ctxt<'tcx>,\n-                                   conv: conv_did)\n-                                   -> ty::ClosureTy<'tcx> {\n+pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n+                                      crate_num: ast::CrateNum,\n+                                      pos: uint,\n+                                      tcx: &ty::ctxt<'tcx>,\n+                                      conv: F)\n+                                      -> ty::ClosureTy<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_closure_ty(&mut st, conv)\n }\n \n-pub fn parse_ty_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n-                           tcx: &ty::ctxt<'tcx>, conv: conv_did) -> Ty<'tcx> {\n+pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                              tcx: &ty::ctxt<'tcx>, conv: F) -> Ty<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(&mut st, conv)\n }\n \n-pub fn parse_region_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                         conv: conv_did) -> ty::Region {\n+pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n+                            conv: F) -> ty::Region where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     debug!(\"parse_region_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_region(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n-                                   tcx: &ty::ctxt<'tcx>, conv: conv_did)\n-                                   -> ty::BareFnTy<'tcx> {\n+pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                                      tcx: &ty::ctxt<'tcx>, conv: F)\n+                                      -> ty::BareFnTy<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     debug!(\"parse_bare_fn_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n-                                  tcx: &ty::ctxt<'tcx>, conv: conv_did)\n-                                  -> Rc<ty::TraitRef<'tcx>> {\n+pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                                     tcx: &ty::ctxt<'tcx>, conv: F)\n+                                     -> Rc<ty::TraitRef<'tcx>> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_trait_ref(&mut st, conv)\n }\n \n-pub fn parse_substs_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n-                               tcx: &ty::ctxt<'tcx>, conv: conv_did) -> subst::Substs<'tcx> {\n+pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                                  tcx: &ty::ctxt<'tcx>, conv: F) -> subst::Substs<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     debug!(\"parse_substs_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_substs(&mut st, conv)\n }\n \n-pub fn parse_bounds_data<'tcx>(data: &[u8], crate_num: ast::CrateNum,\n-                               pos: uint, tcx: &ty::ctxt<'tcx>, conv: conv_did)\n-                               -> ty::ParamBounds<'tcx> {\n+pub fn parse_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n+                                  pos: uint, tcx: &ty::ctxt<'tcx>, conv: F)\n+                                  -> ty::ParamBounds<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bounds(&mut st, conv)\n }\n \n-pub fn parse_existential_bounds_data<'tcx>(data: &[u8], crate_num: ast::CrateNum,\n-                                           pos: uint, tcx: &ty::ctxt<'tcx>, conv: conv_did)\n-                                           -> ty::ExistentialBounds<'tcx> {\n+pub fn parse_existential_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n+                                              pos: uint, tcx: &ty::ctxt<'tcx>, conv: F)\n+                                              -> ty::ExistentialBounds<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_existential_bounds(&mut st, conv)\n }\n \n-pub fn parse_builtin_bounds_data(data: &[u8], crate_num: ast::CrateNum,\n-                                 pos: uint, tcx: &ty::ctxt, conv: conv_did)\n-                                 -> ty::BuiltinBounds {\n+pub fn parse_builtin_bounds_data<F>(data: &[u8], crate_num: ast::CrateNum,\n+                                    pos: uint, tcx: &ty::ctxt, conv: F)\n+                                    -> ty::BuiltinBounds where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_builtin_bounds(&mut st, conv)\n }\n@@ -226,10 +243,12 @@ fn parse_size(st: &mut PState) -> Option<uint> {\n     }\n }\n \n-fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n+fn parse_trait_store_<F>(st: &mut PState, conv: &mut F) -> ty::TraitStore where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n-        '&' => ty::RegionTraitStore(parse_region(st, conv), parse_mutability(st)),\n+        '&' => ty::RegionTraitStore(parse_region_(st, conv), parse_mutability(st)),\n         c => {\n             st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\",\n                                     c)[])\n@@ -253,39 +272,52 @@ fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n     r\n }\n \n-fn parse_substs<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n-                          conv: conv_did) -> subst::Substs<'tcx> {\n+fn parse_substs<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n+                             mut conv: F) -> subst::Substs<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_substs_(st, &mut conv)\n+}\n+\n+fn parse_substs_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n+                              conv: &mut F) -> subst::Substs<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let regions =\n-        parse_region_substs(st, |x,y| conv(x,y));\n+        parse_region_substs_(st, conv);\n \n     let types =\n-        parse_vec_per_param_space(st, |st| parse_ty(st, |x,y| conv(x,y)));\n+        parse_vec_per_param_space(st, |st| parse_ty_(st, conv));\n \n     subst::Substs { types: types,\n                     regions: regions }\n }\n \n-fn parse_region_substs(st: &mut PState, conv: conv_did) -> subst::RegionSubsts {\n+fn parse_region_substs_<F>(st: &mut PState, conv: &mut F) -> subst::RegionSubsts where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     match next(st) {\n         'e' => subst::ErasedRegions,\n         'n' => {\n             subst::NonerasedRegions(\n                 parse_vec_per_param_space(\n-                    st, |st| parse_region(st, |x,y| conv(x,y))))\n+                    st, |st| parse_region_(st, conv)))\n         }\n         _ => panic!(\"parse_bound_region: bad input\")\n     }\n }\n \n-fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n+fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     match next(st) {\n         'a' => {\n             let id = parse_u32(st);\n             assert_eq!(next(st), '|');\n             ty::BrAnon(id)\n         }\n         '[' => {\n-            let def = parse_def(st, RegionParameter, |x,y| conv(x,y));\n+            let def = parse_def_(st, RegionParameter, conv);\n             let ident = token::str_to_ident(parse_str(st, ']')[]);\n             ty::BrNamed(def, ident.name)\n         }\n@@ -299,13 +331,21 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n     }\n }\n \n-fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n+fn parse_region<F>(st: &mut PState, mut conv: F) -> ty::Region where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_region_(st, &mut conv)\n+}\n+\n+fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     match next(st) {\n       'b' => {\n         assert_eq!(next(st), '[');\n         let id = ty::DebruijnIndex::new(parse_u32(st));\n         assert_eq!(next(st), '|');\n-        let br = parse_bound_region(st, |x,y| conv(x,y));\n+        let br = parse_bound_region_(st, conv);\n         assert_eq!(next(st), ']');\n         ty::ReLateBound(id, br)\n       }\n@@ -324,7 +364,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '[');\n         let scope = parse_scope(st);\n         assert_eq!(next(st), '|');\n-        let br = parse_bound_region(st, |x,y| conv(x,y));\n+        let br = parse_bound_region_(st, conv);\n         assert_eq!(next(st), ']');\n         ty::ReFree(ty::FreeRegion { scope: scope,\n                                     bound_region: br})\n@@ -375,14 +415,31 @@ fn parse_str(st: &mut PState, term: char) -> String {\n     result\n }\n \n-fn parse_trait_ref<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n-                             -> Rc<ty::TraitRef<'tcx>> {\n-    let def = parse_def(st, NominalType, |x,y| conv(x,y));\n-    let substs = st.tcx.mk_substs(parse_substs(st, |x,y| conv(x,y)));\n+fn parse_trait_ref<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n+                                -> Rc<ty::TraitRef<'tcx>> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_trait_ref_(st, &mut conv)\n+}\n+\n+fn parse_trait_ref_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n+                              -> Rc<ty::TraitRef<'tcx>> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    let def = parse_def_(st, NominalType, conv);\n+    let substs = st.tcx.mk_substs(parse_substs_(st, conv));\n     Rc::new(ty::TraitRef {def_id: def, substs: substs})\n }\n \n-fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n+fn parse_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F) -> Ty<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_ty_(st, &mut conv)\n+}\n+\n+fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let tcx = st.tcx;\n     match next(st) {\n       'b' => return tcx.types.bool,\n@@ -406,15 +463,15 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       'c' => return tcx.types.char,\n       't' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def(st, NominalType, |x,y| conv(x,y));\n-        let substs = parse_substs(st, |x,y| conv(x,y));\n+        let def = parse_def_(st, NominalType, conv);\n+        let substs = parse_substs_(st, conv);\n         assert_eq!(next(st), ']');\n         return ty::mk_enum(tcx, def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let trait_ref = ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)));\n-        let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n+        let trait_ref = ty::Binder(parse_trait_ref_(st, conv));\n+        let bounds = parse_existential_bounds_(st, conv);\n         assert_eq!(next(st), ']');\n         return ty::mk_trait(tcx, trait_ref, bounds);\n       }\n@@ -427,15 +484,15 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n         let name = token::intern(parse_str(st, ']')[]);\n         return ty::mk_param(tcx, space, index, name);\n       }\n-      '~' => return ty::mk_uniq(tcx, parse_ty(st, |x,y| conv(x,y))),\n-      '*' => return ty::mk_ptr(tcx, parse_mt(st, |x,y| conv(x,y))),\n+      '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),\n+      '*' => return ty::mk_ptr(tcx, parse_mt_(st, conv)),\n       '&' => {\n-        let r = parse_region(st, |x,y| conv(x,y));\n-        let mt = parse_mt(st, |x,y| conv(x,y));\n+        let r = parse_region_(st, conv);\n+        let mt = parse_mt_(st, conv);\n         return ty::mk_rptr(tcx, tcx.mk_region(r), mt);\n       }\n       'V' => {\n-        let t = parse_ty(st, |x,y| conv(x,y));\n+        let t = parse_ty_(st, conv);\n         let sz = parse_size(st);\n         return ty::mk_vec(tcx, t, sz);\n       }\n@@ -445,21 +502,21 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = Vec::new();\n-        while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n+        while peek(st) != ']' { params.push(parse_ty_(st, conv)); }\n         st.pos = st.pos + 1u;\n         return ty::mk_tup(tcx, params);\n       }\n       'f' => {\n-        return ty::mk_closure(tcx, parse_closure_ty(st, |x,y| conv(x,y)));\n+        return ty::mk_closure(tcx, parse_closure_ty_(st, conv));\n       }\n       'F' => {\n-          let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n+          let def_id = parse_def_(st, NominalType, conv);\n           return ty::mk_bare_fn(tcx, Some(def_id),\n-                                tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n+                                tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n       }\n       'G' => {\n           return ty::mk_bare_fn(tcx, None,\n-                                tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n+                                tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n       }\n       '#' => {\n         let pos = parse_hex(st);\n@@ -478,34 +535,34 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n             pos: pos,\n             .. *st\n         };\n-        let tt = parse_ty(&mut ps, |x,y| conv(x,y));\n+        let tt = parse_ty_(&mut ps, conv);\n         tcx.rcache.borrow_mut().insert(key, tt);\n         return tt;\n       }\n       '\\\"' => {\n-        let _ = parse_def(st, TypeWithId, |x,y| conv(x,y));\n-        let inner = parse_ty(st, |x,y| conv(x,y));\n+        let _ = parse_def_(st, TypeWithId, conv);\n+        let inner = parse_ty_(st, conv);\n         inner\n       }\n       'a' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def(st, NominalType, |x,y| conv(x,y));\n-          let substs = parse_substs(st, |x,y| conv(x,y));\n+          let did = parse_def_(st, NominalType, conv);\n+          let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, st.tcx.mk_substs(substs));\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def(st, UnboxedClosureSource, |x,y| conv(x,y));\n-          let region = parse_region(st, |x,y| conv(x,y));\n-          let substs = parse_substs(st, |x,y| conv(x,y));\n+          let did = parse_def_(st, UnboxedClosureSource, conv);\n+          let region = parse_region_(st, conv);\n+          let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n           return ty::mk_unboxed_closure(st.tcx, did,\n                   st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n       }\n       'P' => {\n           assert_eq!(next(st), '[');\n-          let trait_ref = parse_trait_ref(st, |x,y| conv(x,y));\n+          let trait_ref = parse_trait_ref_(st, conv);\n           let name = token::intern(parse_str(st, ']').as_slice());\n           return ty::mk_projection(tcx, trait_ref, name);\n       }\n@@ -523,14 +580,17 @@ fn parse_mutability(st: &mut PState) -> ast::Mutability {\n     }\n }\n \n-fn parse_mt<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::mt<'tcx> {\n+fn parse_mt_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::mt<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let m = parse_mutability(st);\n-    ty::mt { ty: parse_ty(st, |x,y| conv(x,y)), mutbl: m }\n+    ty::mt { ty: parse_ty_(st, conv), mutbl: m }\n }\n \n-fn parse_def(st: &mut PState, source: DefIdSource,\n-             conv: conv_did) -> ast::DefId {\n-    return conv(source, scan(st, |c| { c == '|' }, parse_def_id));\n+fn parse_def_<F>(st: &mut PState, source: DefIdSource, conv: &mut F) -> ast::DefId where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    return (*conv)(source, scan(st, |c| { c == '|' }, parse_def_id));\n }\n \n fn parse_uint(st: &mut PState) -> uint {\n@@ -592,13 +652,22 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     }\n }\n \n-fn parse_closure_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n-                              conv: conv_did) -> ty::ClosureTy<'tcx> {\n+fn parse_closure_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n+                                 mut conv: F) -> ty::ClosureTy<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_closure_ty_(st, &mut conv)\n+}\n+\n+fn parse_closure_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n+                                 conv: &mut F) -> ty::ClosureTy<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let unsafety = parse_unsafety(next(st));\n     let onceness = parse_onceness(next(st));\n-    let store = parse_trait_store(st, |x,y| conv(x,y));\n-    let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n-    let sig = parse_sig(st, |x,y| conv(x,y));\n+    let store = parse_trait_store_(st, conv);\n+    let bounds = parse_existential_bounds_(st, conv);\n+    let sig = parse_sig_(st, conv);\n     let abi = parse_abi_set(st);\n     ty::ClosureTy {\n         unsafety: unsafety,\n@@ -610,23 +679,34 @@ fn parse_closure_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n     }\n }\n \n-fn parse_bare_fn_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n-                              conv: conv_did) -> ty::BareFnTy<'tcx> {\n+fn parse_bare_fn_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n+                                 mut conv: F) -> ty::BareFnTy<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_bare_fn_ty_(st, &mut conv)\n+}\n+\n+fn parse_bare_fn_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n+                                 conv: &mut F) -> ty::BareFnTy<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let unsafety = parse_unsafety(next(st));\n     let abi = parse_abi_set(st);\n-    let sig = parse_sig(st, |x,y| conv(x,y));\n+    let sig = parse_sig_(st, conv);\n     ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n         sig: sig\n     }\n }\n \n-fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::PolyFnSig<'tcx> {\n+fn parse_sig_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::PolyFnSig<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     assert_eq!(next(st), '[');\n     let mut inputs = Vec::new();\n     while peek(st) != ']' {\n-        inputs.push(parse_ty(st, |x,y| conv(x,y)));\n+        inputs.push(parse_ty_(st, conv));\n     }\n     st.pos += 1u; // eat the ']'\n     let variadic = match next(st) {\n@@ -639,7 +719,7 @@ fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::PolyFnS\n           st.pos += 1u;\n           ty::FnDiverging\n         }\n-        _ => ty::FnConverging(parse_ty(st, |x,y| conv(x,y)))\n+        _ => ty::FnConverging(parse_ty_(st, conv))\n     };\n     ty::Binder(ty::FnSig {inputs: inputs,\n                         output: output,\n@@ -672,66 +752,87 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     ast::DefId { krate: crate_num, node: def_num }\n }\n \n-pub fn parse_predicate_data<'tcx>(data: &[u8],\n-                                  start: uint,\n-                                  crate_num: ast::CrateNum,\n-                                  tcx: &ty::ctxt<'tcx>,\n-                                  conv: conv_did)\n-                                  -> ty::Predicate<'tcx>\n+pub fn parse_predicate_data<'tcx, F>(data: &[u8],\n+                                     start: uint,\n+                                     crate_num: ast::CrateNum,\n+                                     tcx: &ty::ctxt<'tcx>,\n+                                     conv: F)\n+                                     -> ty::Predicate<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let mut st = parse_state_from_data(data, crate_num, start, tcx);\n     parse_predicate(&mut st, conv)\n }\n \n-pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n-                                conv: conv_did)\n-                                -> ty::Predicate<'tcx>\n+pub fn parse_predicate<'a,'tcx, F>(st: &mut PState<'a, 'tcx>,\n+                                   mut conv: F)\n+                                   -> ty::Predicate<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_predicate_(st, &mut conv)\n+}\n+\n+fn parse_predicate_<'a,'tcx, F>(st: &mut PState<'a, 'tcx>,\n+                                conv: &mut F)\n+                                -> ty::Predicate<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     match next(st) {\n-        't' => ty::Binder(parse_trait_ref(st, conv)).as_predicate(),\n-        'e' => ty::Binder(ty::EquatePredicate(parse_ty(st, |x,y| conv(x,y)),\n-                                              parse_ty(st, |x,y| conv(x,y)))).as_predicate(),\n-        'r' => ty::Binder(ty::OutlivesPredicate(parse_region(st, |x,y| conv(x,y)),\n-                                                parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n-        'o' => ty::Binder(ty::OutlivesPredicate(parse_ty(st, |x,y| conv(x,y)),\n-                                                parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n-        'p' => ty::Binder(parse_projection_predicate(st, conv)).as_predicate(),\n+        't' => ty::Binder(parse_trait_ref_(st, conv)).as_predicate(),\n+        'e' => ty::Binder(ty::EquatePredicate(parse_ty_(st, conv),\n+                                              parse_ty_(st, conv))).as_predicate(),\n+        'r' => ty::Binder(ty::OutlivesPredicate(parse_region_(st, conv),\n+                                                parse_region_(st, conv))).as_predicate(),\n+        'o' => ty::Binder(ty::OutlivesPredicate(parse_ty_(st, conv),\n+                                                parse_region_(st, conv))).as_predicate(),\n+        'p' => ty::Binder(parse_projection_predicate_(st, conv)).as_predicate(),\n         c => panic!(\"Encountered invalid character in metadata: {}\", c)\n     }\n }\n \n-fn parse_projection_predicate<'a,'tcx>(\n+fn parse_projection_predicate_<'a,'tcx, F>(\n     st: &mut PState<'a, 'tcx>,\n-    conv: conv_did)\n-     -> ty::ProjectionPredicate<'tcx>\n+    conv: &mut F,\n+) -> ty::ProjectionPredicate<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     ty::ProjectionPredicate {\n         projection_ty: ty::ProjectionTy {\n-            trait_ref: parse_trait_ref(st, |x,y| conv(x,y)),\n+            trait_ref: parse_trait_ref_(st, conv),\n             item_name: token::str_to_ident(parse_str(st, '|').as_slice()).name,\n         },\n-        ty: parse_ty(st, |x,y| conv(x,y)),\n+        ty: parse_ty_(st, conv),\n     }\n }\n \n-pub fn parse_type_param_def_data<'tcx>(data: &[u8], start: uint,\n-                                       crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n-                                       conv: conv_did) -> ty::TypeParameterDef<'tcx>\n+pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: uint,\n+                                          crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n+                                          conv: F) -> ty::TypeParameterDef<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let mut st = parse_state_from_data(data, crate_num, start, tcx);\n     parse_type_param_def(&mut st, conv)\n }\n \n-fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n-                                  -> ty::TypeParameterDef<'tcx> {\n+fn parse_type_param_def<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n+                                     -> ty::TypeParameterDef<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_type_param_def_(st, &mut conv)\n+}\n+\n+fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n+                                      -> ty::TypeParameterDef<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let name = parse_name(st, ':');\n-    let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n+    let def_id = parse_def_(st, NominalType, conv);\n     let space = parse_param_space(st);\n     assert_eq!(next(st), '|');\n     let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n-    let bounds = parse_bounds(st, |x,y| conv(x,y));\n-    let default = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)));\n+    let bounds = parse_bounds_(st, conv);\n+    let default = parse_opt(st, |st| parse_ty_(st, conv));\n \n     ty::TypeParameterDef {\n         name: name,\n@@ -743,12 +844,21 @@ fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     }\n }\n \n-fn parse_existential_bounds<'a,'tcx>(st: &mut PState<'a,'tcx>,\n-                                     conv: conv_did)\n-                                     -> ty::ExistentialBounds<'tcx>\n+fn parse_existential_bounds<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n+                                        mut conv: F)\n+                                        -> ty::ExistentialBounds<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_existential_bounds_(st, &mut conv)\n+}\n+\n+fn parse_existential_bounds_<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n+                                        conv: &mut F)\n+                                        -> ty::ExistentialBounds<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let ty::ParamBounds { trait_bounds, mut region_bounds, builtin_bounds, projection_bounds } =\n-         parse_bounds(st, conv);\n+         parse_bounds_(st, conv);\n     assert_eq!(region_bounds.len(), 1);\n     assert_eq!(trait_bounds.len(), 0);\n     let region_bound = region_bounds.pop().unwrap();\n@@ -757,7 +867,15 @@ fn parse_existential_bounds<'a,'tcx>(st: &mut PState<'a,'tcx>,\n                                    projection_bounds: projection_bounds };\n }\n \n-fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n+fn parse_builtin_bounds<F>(st: &mut PState, mut _conv: F) -> ty::BuiltinBounds where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_builtin_bounds_(st, &mut _conv)\n+}\n+\n+fn parse_builtin_bounds_<F>(st: &mut PState, _conv: &mut F) -> ty::BuiltinBounds where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n     let mut builtin_bounds = ty::empty_builtin_bounds();\n \n     loop {\n@@ -784,9 +902,18 @@ fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n     }\n }\n \n-fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n-                          -> ty::ParamBounds<'tcx> {\n-    let builtin_bounds = parse_builtin_bounds(st, |x,y| conv(x,y));\n+fn parse_bounds<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n+                             -> ty::ParamBounds<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    parse_bounds_(st, &mut conv)\n+}\n+\n+fn parse_bounds_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n+                              -> ty::ParamBounds<'tcx> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    let builtin_bounds = parse_builtin_bounds_(st, conv);\n \n     let mut param_bounds = ty::ParamBounds {\n         region_bounds: Vec::new(),\n@@ -798,15 +925,15 @@ fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n         match next(st) {\n             'R' => {\n                 param_bounds.region_bounds.push(\n-                    parse_region(st, |x, y| conv (x, y)));\n+                    parse_region_(st, conv));\n             }\n             'I' => {\n                 param_bounds.trait_bounds.push(\n-                    ty::Binder(parse_trait_ref(st, |x,y| conv(x,y))));\n+                    ty::Binder(parse_trait_ref_(st, conv)));\n             }\n             'P' => {\n                 param_bounds.projection_bounds.push(\n-                    ty::Binder(parse_projection_predicate(st, |x,y| conv(x,y))));\n+                    ty::Binder(parse_projection_predicate_(st, conv)));\n             }\n             '.' => {\n                 return param_bounds;"}]}