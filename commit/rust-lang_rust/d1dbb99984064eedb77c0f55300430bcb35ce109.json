{"sha": "d1dbb99984064eedb77c0f55300430bcb35ce109", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZGJiOTk5ODQwNjRlZWRiNzdjMGY1NTMwMDQzMGJjYjM1Y2UxMDk=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-29T18:00:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-30T01:54:59Z"}, "message": "Removing proxies and message queues.", "tree": {"sha": "9e45ab1c525f0c59ac892117d0dd5424d29a7f51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e45ab1c525f0c59ac892117d0dd5424d29a7f51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1dbb99984064eedb77c0f55300430bcb35ce109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1dbb99984064eedb77c0f55300430bcb35ce109", "html_url": "https://github.com/rust-lang/rust/commit/d1dbb99984064eedb77c0f55300430bcb35ce109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1dbb99984064eedb77c0f55300430bcb35ce109/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc4e9afe2547fa88b55ffc31fef041dffe864b2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4e9afe2547fa88b55ffc31fef041dffe864b2b", "html_url": "https://github.com/rust-lang/rust/commit/bc4e9afe2547fa88b55ffc31fef041dffe864b2b"}], "stats": {"total": 754, "additions": 64, "deletions": 690}, "files": [{"sha": "3c0d9f86ce78435af2e033c07ad6ea3bffcd9e0e", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -18,7 +18,6 @@ RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/rust_port.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_log.cpp \\\n-              rt/rust_message.cpp \\\n               rt/rust_timer.cpp \\\n               rt/circular_buffer.cpp \\\n               rt/isaac/randport.cpp \\\n@@ -44,9 +43,7 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/rust_scheduler.h \\\n                rt/rust_task.h \\\n                rt/rust_task_list.h \\\n-               rt/rust_proxy.h \\\n                rt/rust_log.h \\\n-               rt/rust_message.h \\\n                rt/circular_buffer.h \\\n                rt/util/array_list.h \\\n                rt/util/indexed_list.h \\"}, {"sha": "42deca7b2cd58fabc38c1a1b027508f4f2628ffa", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -93,7 +93,6 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n     rust_srv *srv = new rust_srv(env);\n     rust_kernel *kernel = new rust_kernel(srv, env->num_sched_threads);\n-    kernel->start();\n     rust_task *root_task = kernel->create_task(NULL, \"main\");\n     rust_scheduler *sched = root_task->sched;\n     command_line_args *args"}, {"sha": "3ade237c25a8576c05334390aa3232e3268a89d7", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 39, "deletions": 68, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -4,7 +4,7 @@\n /**\n  * Create a new rust channel and associate it with the specified port.\n  */\n-rust_chan::rust_chan(rust_kernel *kernel, maybe_proxy<rust_port> *port,\n+rust_chan::rust_chan(rust_kernel *kernel, rust_port *port,\n                      size_t unit_sz)\n     : ref_count(1),\n       kernel(kernel),\n@@ -29,18 +29,16 @@ rust_chan::~rust_chan() {\n /**\n  * Link this channel with the specified port.\n  */\n-void rust_chan::associate(maybe_proxy<rust_port> *port) {\n+void rust_chan::associate(rust_port *port) {\n     this->port = port;\n-    if (port->is_proxy() == false) {\n-        scoped_lock with(port->referent()->lock);\n-        KLOG(kernel, task,\n-            \"associating chan: 0x%\" PRIxPTR \" with port: 0x%\" PRIxPTR,\n-            this, port);\n-        ++this->ref_count;\n-        this->task = port->referent()->task;\n-        this->task->ref();\n-        this->port->referent()->chans.push(this);\n-    }\n+    scoped_lock with(port->lock);\n+    KLOG(kernel, task,\n+         \"associating chan: 0x%\" PRIxPTR \" with port: 0x%\" PRIxPTR,\n+         this, port);\n+    ++this->ref_count;\n+    this->task = port->task;\n+    this->task->ref();\n+    this->port->chans.push(this);\n }\n \n bool rust_chan::is_associated() {\n@@ -52,19 +50,17 @@ bool rust_chan::is_associated() {\n  */\n void rust_chan::disassociate() {\n     A(kernel,\n-      port->referent()->lock.lock_held_by_current_thread(),\n+      port->lock.lock_held_by_current_thread(),\n       \"Port referent lock must be held to call rust_chan::disassociate\");\n     A(kernel, is_associated(),\n       \"Channel must be associated with a port.\");\n-    if (port->is_proxy() == false) {\n-        KLOG(kernel, task,\n-             \"disassociating chan: 0x%\" PRIxPTR \" from port: 0x%\" PRIxPTR,\n-             this, port->referent());\n-        --this->ref_count;\n-        task->deref();\n-        this->task = NULL;\n-        port->referent()->chans.swap_delete(this);\n-    }\n+    KLOG(kernel, task,\n+         \"disassociating chan: 0x%\" PRIxPTR \" from port: 0x%\" PRIxPTR,\n+         this, port);\n+    --this->ref_count;\n+    task->deref();\n+    this->task = NULL;\n+    port->chans.swap_delete(this);\n \n     // Delete reference to the port.\n     port = NULL;\n@@ -74,12 +70,7 @@ void rust_chan::disassociate() {\n  * Attempt to send data to the associated port.\n  */\n void rust_chan::send(void *sptr) {\n-    I(kernel, !port->is_proxy());\n-\n-    rust_port *target_port = port->referent();\n-    // TODO: We can probably avoid this lock by using atomic operations in\n-    // circular_buffer.\n-    scoped_lock with(target_port->lock);\n+    scoped_lock with(port->lock);\n \n     buffer.enqueue(sptr);\n \n@@ -92,28 +83,17 @@ void rust_chan::send(void *sptr) {\n     A(kernel, !buffer.is_empty(),\n       \"rust_chan::transmit with nothing to send.\");\n \n-    if (port->is_proxy()) {\n-        data_message::send(buffer.peek(), buffer.unit_sz, \"send data\",\n-                           task->get_handle(), port->as_proxy()->handle());\n-        buffer.dequeue(NULL);\n-    } else {\n-        if (target_port->task->blocked_on(target_port)) {\n-            KLOG(kernel, comm, \"dequeued in rendezvous_ptr\");\n-            buffer.dequeue(target_port->task->rendezvous_ptr);\n-            target_port->task->rendezvous_ptr = 0;\n-            target_port->task->wakeup(target_port);\n-            return;\n-        }\n+    if (port->task->blocked_on(port)) {\n+        KLOG(kernel, comm, \"dequeued in rendezvous_ptr\");\n+        buffer.dequeue(port->task->rendezvous_ptr);\n+        port->task->rendezvous_ptr = 0;\n+        port->task->wakeup(port);\n     }\n-\n-    return;\n }\n \n rust_chan *rust_chan::clone(rust_task *target) {\n-    size_t unit_sz = buffer.unit_sz;\n-    maybe_proxy<rust_port> *port = this->port;\n     return new (target->kernel, \"cloned chan\")\n-        rust_chan(kernel, port, unit_sz);\n+        rust_chan(kernel, port, buffer.unit_sz);\n }\n \n /**\n@@ -125,30 +105,21 @@ void rust_chan::destroy() {\n       \"Channel's ref count should be zero.\");\n \n     if (is_associated()) {\n-        if (port->is_proxy()) {\n-            // Here is a good place to delete the port proxy we allocated\n-            // in upcall_clone_chan.\n-            rust_proxy<rust_port> *proxy = port->as_proxy();\n-            scoped_lock with(port->referent()->lock);\n-            disassociate();\n-            delete proxy;\n-        } else {\n-            // We're trying to delete a channel that another task may be\n-            // reading from. We have two options:\n-            //\n-            // 1. We can flush the channel by blocking in upcall_flush_chan()\n-            //    and resuming only when the channel is flushed. The problem\n-            //    here is that we can get ourselves in a deadlock if the\n-            //    parent task tries to join us.\n-            //\n-            // 2. We can leave the channel in a \"dormnat\" state by not freeing\n-            //    it and letting the receiver task delete it for us instead.\n-            if (buffer.is_empty() == false) {\n-                return;\n-            }\n-            scoped_lock with(port->referent()->lock);\n-            disassociate();\n+        // We're trying to delete a channel that another task may be\n+        // reading from. We have two options:\n+        //\n+        // 1. We can flush the channel by blocking in upcall_flush_chan()\n+        //    and resuming only when the channel is flushed. The problem\n+        //    here is that we can get ourselves in a deadlock if the\n+        //    parent task tries to join us.\n+        //\n+        // 2. We can leave the channel in a \"dormnat\" state by not freeing\n+        //    it and letting the receiver task delete it for us instead.\n+        if (buffer.is_empty() == false) {\n+            return;\n         }\n+        scoped_lock with(port->lock);\n+        disassociate();\n     }\n     delete this;\n }"}, {"sha": "9b30b8acbb15ad5ba08648000724feef27fde6a3", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -5,18 +5,18 @@ class rust_chan : public kernel_owned<rust_chan>,\n                   public rust_cond {\n public:\n     RUST_REFCOUNTED_WITH_DTOR(rust_chan, destroy())\n-    rust_chan(rust_kernel *kernel, maybe_proxy<rust_port> *port,\n+    rust_chan(rust_kernel *kernel, rust_port *port,\n               size_t unit_sz);\n \n     ~rust_chan();\n \n     rust_kernel *kernel;\n     rust_task *task;\n-    maybe_proxy<rust_port> *port;\n+    rust_port *port;\n     size_t idx;\n     circular_buffer buffer;\n \n-    void associate(maybe_proxy<rust_port> *port);\n+    void associate(rust_port *port);\n     void disassociate();\n     bool is_associated();\n "}, {"sha": "0b983bb880634a4b68d78fb608d6f215f1295ddd", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -219,9 +219,7 @@ template <typename T> class ptr_vec : public task_owned<ptr_vec<T> > {\n #include \"memory_region.h\"\n #include \"rust_srv.h\"\n #include \"rust_log.h\"\n-#include \"rust_proxy.h\"\n #include \"rust_kernel.h\"\n-#include \"rust_message.h\"\n #include \"rust_scheduler.h\"\n \n struct rust_timer {"}, {"sha": "1eeb9b2c018867d47adfe0e1cd04d54804ce56e7", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 3, "deletions": 136, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -1,15 +1,14 @@\n #include \"rust_internal.h\"\n \n-#define KLOG_(...) \\\n+#define KLOG_(...)                              \\\n     KLOG(this, kern, __VA_ARGS__)\n-#define KLOG_ERR_(field, ...)                    \\\n+#define KLOG_ERR_(field, ...)                   \\\n     KLOG_LVL(this, field, log_err, __VA_ARGS__)\n \n rust_kernel::rust_kernel(rust_srv *srv, size_t num_threads) :\n     _region(srv, true),\n     _log(srv, NULL),\n     srv(srv),\n-    _interrupt_kernel_loop(FALSE),\n     num_threads(num_threads),\n     rval(0),\n     live_tasks(0),\n@@ -22,15 +21,9 @@ rust_kernel::rust_kernel(rust_srv *srv, size_t num_threads) :\n rust_scheduler *\n rust_kernel::create_scheduler(int id) {\n     _kernel_lock.lock();\n-    rust_message_queue *message_queue =\n-        new (this, \"rust_message_queue\") rust_message_queue(srv, this);\n     rust_srv *srv = this->srv->clone();\n     rust_scheduler *sched =\n-        new (this, \"rust_scheduler\")\n-        rust_scheduler(this, message_queue, srv, id);\n-    rust_handle<rust_scheduler> *handle = internal_get_sched_handle(sched);\n-    message_queue->associate(handle);\n-    message_queues.append(message_queue);\n+        new (this, \"rust_scheduler\") rust_scheduler(this, srv, id);\n     KLOG_(\"created scheduler: \" PTR \", id: %d, index: %d\",\n           sched, id, sched->list_index);\n     _kernel_lock.signal_all();\n@@ -43,7 +36,6 @@ rust_kernel::destroy_scheduler(rust_scheduler *sched) {\n     _kernel_lock.lock();\n     KLOG_(\"deleting scheduler: \" PTR \", name: %s, index: %d\",\n         sched, sched->name, sched->list_index);\n-    sched->message_queue->disassociate();\n     rust_srv *srv = sched->srv;\n     delete sched;\n     delete srv;\n@@ -65,46 +57,6 @@ void rust_kernel::destroy_schedulers() {\n     }\n }\n \n-rust_handle<rust_scheduler> *\n-rust_kernel::internal_get_sched_handle(rust_scheduler *sched) {\n-    rust_handle<rust_scheduler> *handle = NULL;\n-    if (_sched_handles.get(sched, &handle) == false) {\n-        handle = new (this, \"rust_handle<rust_scheduler\")\n-            rust_handle<rust_scheduler>(this, sched->message_queue, sched);\n-        _sched_handles.put(sched, handle);\n-    }\n-    return handle;\n-}\n-\n-rust_handle<rust_task> *\n-rust_kernel::get_task_handle(rust_task *task) {\n-    _kernel_lock.lock();\n-    rust_handle<rust_task> *handle = NULL;\n-    if (_task_handles.get(task, &handle) == false) {\n-        handle =\n-            new (this, \"rust_handle<rust_task>\")\n-            rust_handle<rust_task>(this, task->sched->message_queue, task);\n-        _task_handles.put(task, handle);\n-    }\n-    _kernel_lock.unlock();\n-    return handle;\n-}\n-\n-rust_handle<rust_port> *\n-rust_kernel::get_port_handle(rust_port *port) {\n-    _kernel_lock.lock();\n-    rust_handle<rust_port> *handle = NULL;\n-    if (_port_handles.get(port, &handle) == false) {\n-        handle = new (this, \"rust_handle<rust_port>\")\n-            rust_handle<rust_port>(this,\n-                                   port->task->sched->message_queue,\n-                                   port);\n-        _port_handles.put(port, handle);\n-    }\n-    _kernel_lock.unlock();\n-    return handle;\n-}\n-\n void\n rust_kernel::log_all_scheduler_state() {\n     for(size_t i = 0; i < num_threads; ++i) {\n@@ -141,73 +93,8 @@ rust_kernel::fatal(char const *fmt, ...) {\n     va_end(args);\n }\n \n-void\n-rust_kernel::pump_message_queues() {\n-    for (size_t i = 0; i < message_queues.length(); i++) {\n-        rust_message_queue *queue = message_queues[i];\n-        if (queue->is_associated() == false) {\n-            rust_message *message = NULL;\n-            while (queue->dequeue(&message)) {\n-                message->kernel_process();\n-                delete message;\n-            }\n-        }\n-    }\n-}\n-\n-void\n-rust_kernel::start_kernel_loop() {\n-    _kernel_lock.lock();\n-    while (_interrupt_kernel_loop == false) {\n-        _kernel_lock.wait();\n-        pump_message_queues();\n-    }\n-    _kernel_lock.unlock();\n-}\n-\n-void\n-rust_kernel::run() {\n-    KLOG_(\"started kernel loop\");\n-    start_kernel_loop();\n-    KLOG_(\"finished kernel loop\");\n-}\n-\n-void\n-rust_kernel::terminate_kernel_loop() {\n-    KLOG_(\"terminating kernel loop\");\n-    _interrupt_kernel_loop = true;\n-    signal_kernel_lock();\n-    join();\n-}\n-\n rust_kernel::~rust_kernel() {\n     destroy_schedulers();\n-\n-    terminate_kernel_loop();\n-\n-    // It's possible that the message pump misses some messages because\n-    // of races, so pump any remaining messages here. By now all domain\n-    // threads should have been joined, so we shouldn't miss any more\n-    // messages.\n-    pump_message_queues();\n-\n-    KLOG_(\"freeing handles\");\n-\n-    free_handles(_task_handles);\n-    KLOG_(\"..task handles freed\");\n-    free_handles(_port_handles);\n-    KLOG_(\"..port handles freed\");\n-    free_handles(_sched_handles);\n-    KLOG_(\"..sched handles freed\");\n-\n-    KLOG_(\"freeing queues\");\n-\n-    rust_message_queue *queue = NULL;\n-    while (message_queues.pop(&queue)) {\n-        K(srv, queue->is_empty(), \"Kernel message queue should be empty \"\n-          \"before killing the kernel.\");\n-        delete queue;\n-    }\n }\n \n void *\n@@ -224,26 +111,6 @@ void rust_kernel::free(void *mem) {\n     _region.free(mem);\n }\n \n-template<class T> void\n-rust_kernel::free_handles(hash_map<T*, rust_handle<T>* > &map) {\n-    T* key;\n-    rust_handle<T> *value;\n-    while (map.pop(&key, &value)) {\n-        KLOG_(\"...freeing \" PTR, value);\n-        delete value;\n-    }\n-}\n-\n-void\n-rust_kernel::notify_message_enqueued(rust_message_queue *queue,\n-                                     rust_message *message) {\n-    // The message pump needs to handle this message if the queue is not\n-    // associated with a domain, therefore signal the message pump.\n-    if (queue->is_associated() == false) {\n-        signal_kernel_lock();\n-    }\n-}\n-\n void\n rust_kernel::signal_kernel_lock() {\n     _kernel_lock.lock();"}, {"sha": "66196e196849ac091b8c0ff5c59c01f1259e894f", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 1, "deletions": 76, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -2,77 +2,22 @@\n #ifndef RUST_KERNEL_H\n #define RUST_KERNEL_H\n \n-/**\n- * A handle object for Rust tasks. We need a reference to the message queue\n- * of the referent's domain which we can safely hang on to since it's a\n- * kernel object. We use the referent reference as a label we stash in\n- * messages sent via this proxy.\n- */\n-\n-class rust_kernel;\n-class rust_message;\n-\n-template <typename T> class\n-rust_handle :\n-    public rust_cond,\n-    public rc_base<rust_handle<T> >,\n-    public kernel_owned<rust_handle<T> > {\n-public:\n-    rust_kernel *kernel;\n-    rust_message_queue *message_queue;\n-    T *_referent;\n-    T * referent() {\n-        return _referent;\n-    }\n-    rust_handle(rust_kernel *kernel,\n-                rust_message_queue *message_queue,\n-                T *referent) :\n-                kernel(kernel),\n-                message_queue(message_queue),\n-                _referent(referent) {\n-        // Nop.\n-    }\n-};\n-\n-class rust_task_thread;\n-\n-\n /**\n  * A global object shared by all thread domains. Most of the data structures\n  * in this class are synchronized since they are accessed from multiple\n  * threads.\n  */\n-class rust_kernel : public rust_thread {\n+class rust_kernel {\n     memory_region _region;\n     rust_log _log;\n \n public:\n     rust_srv *srv;\n private:\n-\n-    /**\n-     * Task proxy objects are kernel owned handles to Rust objects.\n-     */\n-    hash_map<rust_task *, rust_handle<rust_task> *> _task_handles;\n-    hash_map<rust_port *, rust_handle<rust_port> *> _port_handles;\n-    hash_map<rust_scheduler *, rust_handle<rust_scheduler> *> _sched_handles;\n-\n-    template<class T> void free_handles(hash_map<T*, rust_handle<T>* > &map);\n-\n-    void run();\n-    void start_kernel_loop();\n-    bool _interrupt_kernel_loop;\n-\n     lock_and_signal _kernel_lock;\n \n     const size_t num_threads;\n \n-    void terminate_kernel_loop();\n-    void pump_message_queues();\n-\n-    rust_handle<rust_scheduler> *\n-    internal_get_sched_handle(rust_scheduler *sched);\n-\n     array_list<rust_scheduler *> threads;\n \n     randctx rctx;\n@@ -89,35 +34,15 @@ class rust_kernel : public rust_thread {\n \n     volatile int live_tasks;\n \n-    /**\n-     * Message queues are kernel objects and are associated with domains.\n-     * Their lifetime is not bound to the lifetime of a domain and in fact\n-     * live on after their associated domain has died. This way we can safely\n-     * communicate with domains that may have died.\n-     *\n-     */\n-    indexed_list<rust_message_queue> message_queues;\n-\n     struct rust_env *env;\n \n-    rust_handle<rust_task> *get_task_handle(rust_task *task);\n-    rust_handle<rust_port> *get_port_handle(rust_port *port);\n-\n     rust_kernel(rust_srv *srv, size_t num_threads);\n \n     bool is_deadlocked();\n \n     void signal_kernel_lock();\n     void wakeup_schedulers();\n \n-    /**\n-     * Notifies the kernel whenever a message has been enqueued . This gives\n-     * the kernel the opportunity to wake up the message pump thread if the\n-     * message queue is not associated.\n-     */\n-    void\n-    notify_message_enqueued(rust_message_queue *queue, rust_message *message);\n-\n     void log_all_scheduler_state();\n     void log(uint32_t level, char const *fmt, ...);\n     void fatal(char const *fmt, ...);"}, {"sha": "f8001a17193b1d4f8377fba554a725c0971f74c2", "filename": "src/rt/rust_message.cpp", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bc4e9afe2547fa88b55ffc31fef041dffe864b2b/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bc4e9afe2547fa88b55ffc31fef041dffe864b2b/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=bc4e9afe2547fa88b55ffc31fef041dffe864b2b", "patch": "@@ -1,125 +0,0 @@\n-#include \"rust_internal.h\"\n-#include \"rust_message.h\"\n-\n-rust_message::\n-rust_message(memory_region *region, const char* label,\n-             rust_handle<rust_task> *source, rust_handle<rust_task> *target) :\n-             label(label), region(region), _source(source), _target(target) {\n-}\n-\n-rust_message::~rust_message() {\n-}\n-\n-void rust_message::process() {\n-}\n-\n-void rust_message::kernel_process() {\n-}\n-\n-notify_message::\n-notify_message(memory_region *region, notification_type type,\n-    const char* label, rust_handle<rust_task> *source,\n-    rust_handle<rust_task> *target) :\n-    rust_message(region, label, source, target), type(type) {\n-}\n-\n-data_message::\n-data_message(memory_region *region, uint8_t *buffer, size_t buffer_sz,\n-             const char* label, rust_handle<rust_task> *source,\n-             rust_handle<rust_port> *port) :\n-             rust_message(region, label, source, NULL),\n-             _buffer_sz(buffer_sz), _port(port) {\n-    _buffer = (uint8_t *)malloc(buffer_sz);\n-    memcpy(_buffer, buffer, buffer_sz);\n-}\n-\n-data_message::~data_message() {\n-    free (_buffer);\n-}\n-\n-/**\n- * Sends a message to the target task via a proxy. The message is allocated\n- * in the target task domain along with a proxy which points back to the\n- * source task.\n- */\n-void notify_message::\n-send(notification_type type, const char* label,\n-     rust_handle<rust_task> *source, rust_handle<rust_task> *target) {\n-    memory_region *region = &target->message_queue->region;\n-    notify_message *message =\n-        new (region, \"notify_message\")\n-        notify_message(region, type, label, source, target);\n-    target->message_queue->enqueue(message);\n-}\n-\n-void notify_message::process() {\n-    rust_task *task = _target->referent();\n-    switch (type) {\n-    case KILL:\n-        // task->ref_count--;\n-        task->kill();\n-        break;\n-    case JOIN: {\n-        if (task->dead() == false) {\n-            // FIXME: this should be dead code.\n-            assert(false);\n-        } else {\n-            send(WAKEUP, \"wakeup\", _target, _source);\n-        }\n-        break;\n-    }\n-    case WAKEUP:\n-        task->wakeup(_source);\n-        break;\n-    }\n-}\n-\n-void notify_message::kernel_process() {\n-    switch(type) {\n-    case WAKEUP:\n-    case KILL:\n-        // Ignore.\n-        break;\n-    case JOIN:\n-        send(WAKEUP, \"wakeup\", _target, _source);\n-        break;\n-    }\n-}\n-\n-void data_message::\n-send(uint8_t *buffer, size_t buffer_sz, const char* label,\n-     rust_handle<rust_task> *source, rust_handle<rust_port> *port) {\n-\n-    memory_region *region = &port->message_queue->region;\n-    data_message *message =\n-        new (region, \"data_message\")\n-        data_message(region, buffer, buffer_sz, label, source, port);\n-    LOG(source->referent(), comm, \"==> sending \\\"%s\\\"\" PTR \" in queue \" PTR,\n-        label, message, &port->message_queue);\n-    port->message_queue->enqueue(message);\n-}\n-\n-void data_message::process() {\n-    _port->referent()->remote_channel->send(_buffer);\n-}\n-\n-void data_message::kernel_process() {\n-\n-}\n-\n-rust_message_queue::rust_message_queue(rust_srv *srv, rust_kernel *kernel)\n-    : region(srv, true),\n-      kernel(kernel),\n-      sched_handle(NULL) {\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "88c34119e199548cf5bb0a6871bf3afc1e13df71", "filename": "src/rt/rust_message.h", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/bc4e9afe2547fa88b55ffc31fef041dffe864b2b/src%2Frt%2Frust_message.h", "raw_url": "https://github.com/rust-lang/rust/raw/bc4e9afe2547fa88b55ffc31fef041dffe864b2b/src%2Frt%2Frust_message.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.h?ref=bc4e9afe2547fa88b55ffc31fef041dffe864b2b", "patch": "@@ -1,135 +0,0 @@\n-#ifndef RUST_MESSAGE_H\n-#define RUST_MESSAGE_H\n-\n-/**\n- * Rust messages are used for inter-thread communication. They are enqueued\n- * and allocated in the target domain.\n- */\n-\n-/**\n- * Abstract base class for all message types.\n- */\n-class rust_message : public region_owned<rust_message> {\n-public:\n-    const char* label;\n-    memory_region *region;\n-private:\n-protected:\n-    rust_handle<rust_task> *_source;\n-    rust_handle<rust_task> *_target;\n-public:\n-    rust_message(memory_region *region,\n-                 const char* label,\n-                 rust_handle<rust_task> *source,\n-                 rust_handle<rust_task> *target);\n-\n-    virtual ~rust_message();\n-\n-    /**\n-     * Processes the message in the target domain.\n-     */\n-    virtual void process();\n-\n-    /**\n-     * Processes the message in the kernel.\n-     */\n-    virtual void kernel_process();\n-};\n-\n-/**\n- * Notify messages are simple argument-less messages.\n- */\n-class notify_message : public rust_message {\n-public:\n-    enum notification_type {\n-        KILL, JOIN, WAKEUP\n-    };\n-\n-    const notification_type type;\n-\n-    notify_message(memory_region *region, notification_type type,\n-                   const char* label, rust_handle<rust_task> *source,\n-                   rust_handle<rust_task> *target);\n-\n-    void process();\n-    void kernel_process();\n-\n-    /**\n-     * This code executes in the sending domain's thread.\n-     */\n-    static void\n-    send(notification_type type, const char* label,\n-         rust_handle<rust_task> *source, rust_handle<rust_task> *target);\n-};\n-\n-/**\n- * Data messages carry a buffer.\n- */\n-class data_message : public rust_message {\n-private:\n-    uint8_t *_buffer;\n-    size_t _buffer_sz;\n-    rust_handle<rust_port> *_port;\n-\n-public:\n-    data_message(memory_region *region, uint8_t *buffer, size_t buffer_sz,\n-                 const char* label, rust_handle<rust_task> *source,\n-                 rust_handle<rust_port> *port);\n-\n-    virtual ~data_message();\n-    void process();\n-    void kernel_process();\n-\n-    /**\n-     * This code executes in the sending domain's thread.\n-     */\n-    static void\n-    send(uint8_t *buffer, size_t buffer_sz, const char* label,\n-         rust_handle<rust_task> *source, rust_handle<rust_port> *port);\n-};\n-\n-class rust_message_queue : public lock_free_queue<rust_message*>,\n-                           public kernel_owned<rust_message_queue> {\n-public:\n-    memory_region region;\n-    rust_kernel *kernel;\n-    rust_handle<rust_scheduler> *sched_handle;\n-    int32_t list_index;\n-    rust_message_queue(rust_srv *srv, rust_kernel *kernel);\n-\n-    void associate(rust_handle<rust_scheduler> *sched_handle) {\n-        this->sched_handle = sched_handle;\n-    }\n-\n-    /**\n-     * The Rust domain relinquishes control to the Rust kernel.\n-     */\n-    void disassociate() {\n-        this->sched_handle = NULL;\n-    }\n-\n-    /**\n-     * Checks if a Rust domain is responsible for draining the message queue.\n-     */\n-    bool is_associated() {\n-        return this->sched_handle != NULL;\n-    }\n-\n-    void enqueue(rust_message* message) {\n-        lock_free_queue<rust_message*>::enqueue(message);\n-        kernel->notify_message_enqueued(this, message);\n-    }\n-};\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//\n-\n-#endif /* RUST_MESSAGE_H */"}, {"sha": "bd4cff4f2357ada2d7c829fb8d246f1a8c569fe6", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -2,7 +2,7 @@\n #include \"rust_port.h\"\n \n rust_port::rust_port(rust_task *task, size_t unit_sz)\n-    : maybe_proxy<rust_port>(this), kernel(task->kernel), task(task),\n+    : ref_count(1), kernel(task->kernel), task(task),\n       unit_sz(unit_sz), writers(task), chans(task) {\n \n     LOG(task, comm,\n@@ -17,11 +17,9 @@ rust_port::rust_port(rust_task *task, size_t unit_sz)\n rust_port::~rust_port() {\n     LOG(task, comm, \"~rust_port 0x%\" PRIxPTR, (uintptr_t) this);\n \n-    //    log_state();\n-\n     // Disassociate channels from this port.\n     while (chans.is_empty() == false) {\n-        scoped_lock with(referent()->lock);\n+        scoped_lock with(lock);\n         rust_chan *chan = chans.peek();\n         chan->disassociate();\n "}, {"sha": "5a3da51ac94f0dfe18440134f7547fc31f82db16", "filename": "src/rt/rust_port.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_port.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_port.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.h?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -1,10 +1,11 @@\n #ifndef RUST_PORT_H\n #define RUST_PORT_H\n \n-class rust_port : public maybe_proxy<rust_port>,\n-                  public kernel_owned<rust_port> {\n+class rust_port : public kernel_owned<rust_port>, public rust_cond {\n \n public:\n+    RUST_REFCOUNTED(rust_port);\n+\n     rust_kernel *kernel;\n     rust_task *task;\n     size_t unit_sz;"}, {"sha": "2ab080be45eba4d359b66f0b9da3b34a21fe36fe", "filename": "src/rt/rust_proxy.h", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bc4e9afe2547fa88b55ffc31fef041dffe864b2b/src%2Frt%2Frust_proxy.h", "raw_url": "https://github.com/rust-lang/rust/raw/bc4e9afe2547fa88b55ffc31fef041dffe864b2b/src%2Frt%2Frust_proxy.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_proxy.h?ref=bc4e9afe2547fa88b55ffc31fef041dffe864b2b", "patch": "@@ -1,77 +0,0 @@\n-#ifndef RUST_PROXY_H\n-#define RUST_PROXY_H\n-\n-/**\n- * A proxy object is a wrapper for remote objects. Proxy objects are domain\n- * owned and provide a way distinguish between local and remote objects.\n- */\n-\n-template <typename T> struct rust_proxy;\n-\n-/**\n- * The base class of all objects that may delegate.\n- */\n-template <typename T> struct\n-maybe_proxy : public rc_base<T>, public rust_cond {\n-protected:\n-    T *_referent;\n-public:\n-    maybe_proxy(T *referent) : _referent(referent) {\n-    }\n-\n-    T *referent() {\n-        return (T *)_referent;\n-    }\n-\n-    bool is_proxy() {\n-        return _referent != this;\n-    }\n-\n-    rust_proxy<T> *as_proxy() {\n-        return (rust_proxy<T> *) this;\n-    }\n-\n-    T *as_referent() {\n-        return (T *) this;\n-    }\n-};\n-\n-template <typename T> class rust_handle;\n-\n-/**\n- * A proxy object that delegates to another.\n- */\n-template <typename T> struct\n-rust_proxy : public maybe_proxy<T> {\n-private:\n-    bool _strong;\n-    rust_handle<T> *_handle;\n-public:\n-    rust_proxy(rust_handle<T> *handle) :\n-        maybe_proxy<T> (NULL), _strong(FALSE), _handle(handle) {\n-    }\n-\n-    rust_proxy(T *referent) :\n-        maybe_proxy<T> (referent), _strong(FALSE), _handle(NULL) {\n-    }\n-\n-    rust_handle<T> *handle() {\n-        return _handle;\n-    }\n-};\n-\n-class rust_message_queue;\n-struct rust_task;\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//\n-\n-#endif /* RUST_PROXY_H */"}, {"sha": "6f91d17f9b8271059c44f6ea5052b549b95367c4", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -4,7 +4,6 @@\n #include \"globals.h\"\n \n rust_scheduler::rust_scheduler(rust_kernel *kernel,\n-                               rust_message_queue *message_queue,\n                                rust_srv *srv,\n                                int id) :\n     interrupt_flag(0),\n@@ -19,7 +18,6 @@ rust_scheduler::rust_scheduler(rust_kernel *kernel,\n     dead_tasks(this, \"dead\"),\n     cache(this),\n     kernel(kernel),\n-    message_queue(message_queue),\n     id(id),\n     min_stack_size(kernel->env->min_stack_size),\n     env(kernel->env)\n@@ -108,21 +106,6 @@ rust_scheduler::reap_dead_tasks(int id) {\n     }\n }\n \n-/**\n- * Drains and processes incoming pending messages.\n- */\n-void rust_scheduler::drain_incoming_message_queue(bool process) {\n-    rust_message *message;\n-    while (message_queue->dequeue(&message)) {\n-        DLOG(this, comm, \"<== receiving \\\"%s\\\" \" PTR,\n-            message->label, message);\n-        if (process) {\n-            message->process();\n-        }\n-        delete message;\n-    }\n-}\n-\n /**\n  * Schedules a running task for execution. Only running tasks can be\n  * activated.  Blocked tasks have to be unblocked before they can be\n@@ -207,8 +190,6 @@ rust_scheduler::start_main_loop() {\n         DLOG(this, dom, \"worker %d, number_of_live_tasks = %d, total = %d\",\n              id, number_of_live_tasks(), kernel->live_tasks);\n \n-        drain_incoming_message_queue(true);\n-\n         rust_task *scheduled_task = schedule_task(id);\n \n         if (scheduled_task == NULL) {\n@@ -259,18 +240,14 @@ rust_scheduler::start_main_loop() {\n          \"terminated scheduler loop, reaping dead tasks ...\");\n \n     while (dead_tasks.length() > 0) {\n-        if (message_queue->is_empty()) {\n-            DLOG(this, dom,\n-                \"waiting for %d dead tasks to become dereferenced, \"\n-                \"scheduler yielding ...\",\n-                dead_tasks.length());\n-            log_state();\n-            lock.unlock();\n-            sync::yield();\n-            lock.lock();\n-        } else {\n-            drain_incoming_message_queue(true);\n-        }\n+        DLOG(this, dom,\n+             \"waiting for %d dead tasks to become dereferenced, \"\n+             \"scheduler yielding ...\",\n+             dead_tasks.length());\n+        log_state();\n+        lock.unlock();\n+        sync::yield();\n+        lock.lock();\n         reap_dead_tasks(id);\n     }\n "}, {"sha": "87ee1f1b20671d1e223d2d672cb3a008b861c4fb", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -51,11 +51,8 @@ struct rust_scheduler : public kernel_owned<rust_scheduler>,\n     rust_kernel *kernel;\n     int32_t list_index;\n \n-    hash_map<rust_task *, rust_proxy<rust_task> *> _task_proxies;\n-    hash_map<rust_port *, rust_proxy<rust_port> *> _port_proxies;\n-\n-    // Incoming messages from other domains.\n-    rust_message_queue *message_queue;\n+    hash_map<rust_task *, rust_task *> _task_proxies;\n+    hash_map<rust_port *, rust_port *> _port_proxies;\n \n     const int id;\n \n@@ -70,17 +67,13 @@ struct rust_scheduler : public kernel_owned<rust_scheduler>,\n \n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n-    rust_scheduler(rust_kernel *kernel,\n-                   rust_message_queue *message_queue, rust_srv *srv,\n-                   int id);\n+    rust_scheduler(rust_kernel *kernel, rust_srv *srv, int id);\n     ~rust_scheduler();\n     void activate(rust_task *task);\n     void log(rust_task *task, uint32_t level, char const *fmt, ...);\n     rust_log & get_log();\n     void fail();\n \n-    void drain_incoming_message_queue(bool process);\n-\n     rust_crate_cache *get_cache();\n     size_t number_of_live_tasks();\n "}, {"sha": "37a5e64172ed1ea58265b1d611f53661651876a2", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -76,7 +76,6 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n     supervisor(spawner),\n     list_index(-1),\n     rendezvous_ptr(0),\n-    handle(NULL),\n     running_on(-1),\n     pinned_on(-1),\n     local_region(&sched->srv->local_region),\n@@ -464,14 +463,6 @@ rust_task::backtrace() {\n #endif\n }\n \n-rust_handle<rust_task> *\n-rust_task::get_handle() {\n-    if (handle == NULL) {\n-        handle = sched->kernel->get_task_handle(this);\n-    }\n-    return handle;\n-}\n-\n bool rust_task::can_schedule(int id)\n {\n     return yield_timer.has_timed_out() &&"}, {"sha": "133c10a95e5f649b05e3773b955240b8ab82f6a6", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -80,8 +80,6 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     // List of tasks waiting for this task to finish.\n     array_list<rust_task *> tasks_waiting_to_join;\n \n-    rust_handle<rust_task> *handle;\n-\n     context ctx;\n \n     // This flag indicates that a worker is either currently running the task\n@@ -157,8 +155,6 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     // Notify tasks waiting for us that we are about to die.\n     void notify_tasks_waiting_to_join();\n \n-    rust_handle<rust_task> * get_handle();\n-\n     frame_glue_fns *get_frame_glue_fns(uintptr_t fp);\n     rust_crate_cache * get_crate_cache();\n "}, {"sha": "048be072e12e0f554f7b5aeeb1079da13908c02d", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1dbb99984064eedb77c0f55300430bcb35ce109/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=d1dbb99984064eedb77c0f55300430bcb35ce109", "patch": "@@ -169,9 +169,7 @@ upcall_clone_chan(rust_task *task, rust_task *target,\n extern \"C\" CDECL rust_task *\n upcall_chan_target_task(rust_task *task, rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n-    I(task->sched, !chan->port->is_proxy());\n-\n-    return chan->port->referent()->task;\n+    return chan->port->task;\n }\n \n extern \"C\" CDECL void\n@@ -204,9 +202,9 @@ upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n \n extern \"C\" CDECL void\n upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n+    LOG_UPCALL_ENTRY(task);\n     {\n         scoped_lock with(port->lock);\n-        LOG_UPCALL_ENTRY(task);\n \n         LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n             \", size: 0x%\" PRIxPTR \", chan_no: %d\","}]}