{"sha": "ed7a2068432b62880bca89cd69546682a2e192cd", "node_id": "C_kwDOAAsO6NoAKGVkN2EyMDY4NDMyYjYyODgwYmNhODljZDY5NTQ2NjgyYTJlMTkyY2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-20T00:40:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-20T00:40:58Z"}, "message": "Auto merge of #91844 - nnethercote:rm-ObligationCauseData-2, r=Mark-Simulacrum\n\nEliminate `ObligationCauseData`\n\nThis makes `Obligation` two words bigger, but avoids allocating a lot of the time.\n\nI previously tried this in #73983 and it didn't help much, but local timings look more promising now.\n\nr? `@ghost`", "tree": {"sha": "5e21f44877699c429281fcbd9269cca9b7c50495", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e21f44877699c429281fcbd9269cca9b7c50495"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed7a2068432b62880bca89cd69546682a2e192cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed7a2068432b62880bca89cd69546682a2e192cd", "html_url": "https://github.com/rust-lang/rust/commit/ed7a2068432b62880bca89cd69546682a2e192cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed7a2068432b62880bca89cd69546682a2e192cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e95e084a14870a718c712936ab5a8f8cd0159485", "url": "https://api.github.com/repos/rust-lang/rust/commits/e95e084a14870a718c712936ab5a8f8cd0159485", "html_url": "https://github.com/rust-lang/rust/commit/e95e084a14870a718c712936ab5a8f8cd0159485"}, {"sha": "f09b1facd04250135d9ad0434c73378a6c08f415", "url": "https://api.github.com/repos/rust-lang/rust/commits/f09b1facd04250135d9ad0434c73378a6c08f415", "html_url": "https://github.com/rust-lang/rust/commit/f09b1facd04250135d9ad0434c73378a6c08f415"}], "stats": {"total": 274, "additions": 135, "deletions": 139}, "files": [{"sha": "9a76c05e4f6202bd23a49f7e87ee55501883c59e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -604,7 +604,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n         terr: &TypeError<'tcx>,\n     ) {\n-        match cause.code {\n+        match *cause.code() {\n             ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n                 let ty = self.resolve_vars_if_possible(root_ty);\n                 if ty.is_suggestable() {\n@@ -781,7 +781,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             _ => {\n                 if let ObligationCauseCode::BindingObligation(_, binding_span) =\n-                    cause.code.peel_derives()\n+                    cause.code().peel_derives()\n                 {\n                     if matches!(terr, TypeError::RegionsPlaceholderMismatch) {\n                         err.span_note(*binding_span, \"the lifetime requirement is introduced here\");\n@@ -1729,10 +1729,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             _ => exp_found,\n         };\n-        debug!(\"exp_found {:?} terr {:?} cause.code {:?}\", exp_found, terr, cause.code);\n+        debug!(\"exp_found {:?} terr {:?} cause.code {:?}\", exp_found, terr, cause.code());\n         if let Some(exp_found) = exp_found {\n             let should_suggest_fixes = if let ObligationCauseCode::Pattern { root_ty, .. } =\n-                &cause.code\n+                cause.code()\n             {\n                 // Skip if the root_ty of the pattern is not the same as the expected_ty.\n                 // If these types aren't equal then we've probably peeled off a layer of arrays.\n@@ -1827,15 +1827,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             exp_span, exp_found.expected, exp_found.found,\n         );\n \n-        if let ObligationCauseCode::CompareImplMethodObligation { .. } = &cause.code {\n+        if let ObligationCauseCode::CompareImplMethodObligation { .. } = cause.code() {\n             return;\n         }\n \n         match (\n             self.get_impl_future_output_ty(exp_found.expected),\n             self.get_impl_future_output_ty(exp_found.found),\n         ) {\n-            (Some(exp), Some(found)) if same_type_modulo_infer(exp, found) => match &cause.code {\n+            (Some(exp), Some(found)) if same_type_modulo_infer(exp, found) => match cause.code() {\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n                     diag.multipart_suggestion(\n                         \"consider `await`ing on both `Future`s\",\n@@ -1875,7 +1875,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            (Some(ty), _) if same_type_modulo_infer(ty, exp_found.found) => match cause.code {\n+            (Some(ty), _) if same_type_modulo_infer(ty, exp_found.found) => match cause.code() {\n                 ObligationCauseCode::Pattern { span: Some(span), .. }\n                 | ObligationCauseCode::IfExpression(box IfExpressionCause { then: span, .. }) => {\n                     diag.span_suggestion_verbose(\n@@ -1927,7 +1927,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .map(|field| (field.ident.name, field.ty(self.tcx, expected_substs)))\n                 .find(|(_, ty)| same_type_modulo_infer(ty, exp_found.found))\n             {\n-                if let ObligationCauseCode::Pattern { span: Some(span), .. } = cause.code {\n+                if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestion = if expected_def.is_struct() {\n                             format!(\"{}.{}\", snippet, name)\n@@ -2064,7 +2064,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 if let MatchExpressionArm(box MatchExpressionArmCause { source, .. }) =\n-                    trace.cause.code\n+                    *trace.cause.code()\n                 {\n                     if let hir::MatchSource::TryDesugar = source {\n                         if let Some((expected_ty, found_ty)) = self.values_str(trace.values) {\n@@ -2659,7 +2659,7 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     fn as_failure_code(&self, terr: &TypeError<'tcx>) -> FailureCode {\n         use self::FailureCode::*;\n         use crate::traits::ObligationCauseCode::*;\n-        match self.code {\n+        match self.code() {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n             CompareImplTypeObligation { .. } => Error0308(\"type not compatible with trait\"),\n             MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => {\n@@ -2694,7 +2694,7 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n \n     fn as_requirement_str(&self) -> &'static str {\n         use crate::traits::ObligationCauseCode::*;\n-        match self.code {\n+        match self.code() {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             CompareImplTypeObligation { .. } => \"associated type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\","}, {"sha": "d3b47e396ec2ba278e1d2adc3578c82e38327699", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -31,15 +31,15 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n         // If we added a \"points at argument expression\" obligation, we remove it here, we care\n         // about the original obligation only.\n-        let code = match &cause.code {\n+        let code = match cause.code() {\n             ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } => &*parent_code,\n-            _ => &cause.code,\n+            _ => cause.code(),\n         };\n         let (parent, impl_def_id) = match code {\n             ObligationCauseCode::MatchImpl(parent, impl_def_id) => (parent, impl_def_id),\n             _ => return None,\n         };\n-        let binding_span = match parent.code {\n+        let binding_span = match *parent.code() {\n             ObligationCauseCode::BindingObligation(_def_id, binding_span) => binding_span,\n             _ => return None,\n         };"}, {"sha": "7178bfa525bcb6dd7c8663a88fa5eaf26189be5b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -208,7 +208,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         );\n         let mut err = self.tcx().sess.struct_span_err(span, &msg);\n \n-        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id) = cause.code {\n+        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id) = *cause.code() {\n             err.span_label(span, \"doesn't satisfy where-clause\");\n             err.span_label(\n                 self.tcx().def_span(def_id),"}, {"sha": "b6dff2e53e9cd0e5eac97c50d8bbb4035685acf5", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 sup_r,\n             ) if **sub_r == RegionKind::ReStatic => {\n                 // This is for an implicit `'static` requirement coming from `impl dyn Trait {}`.\n-                if let ObligationCauseCode::UnifyReceiver(ctxt) = &cause.code {\n+                if let ObligationCauseCode::UnifyReceiver(ctxt) = cause.code() {\n                     // This may have a closure and it would cause ICE\n                     // through `find_param_with_region` (#78262).\n                     let anon_reg_sup = tcx.is_suitable_region(sup_r)?;\n@@ -184,7 +184,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = sub_origin {\n             if let ObligationCauseCode::ReturnValue(hir_id)\n-            | ObligationCauseCode::BlockTailExpression(hir_id) = &cause.code\n+            | ObligationCauseCode::BlockTailExpression(hir_id) = cause.code()\n             {\n                 let parent_id = tcx.hir().get_parent_item(*hir_id);\n                 if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id) {\n@@ -226,7 +226,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         let mut override_error_code = None;\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sup_origin {\n-            if let ObligationCauseCode::UnifyReceiver(ctxt) = &cause.code {\n+            if let ObligationCauseCode::UnifyReceiver(ctxt) = cause.code() {\n                 // Handle case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a\n                 // `'static` lifetime when called as a method on a binding: `bar.qux()`.\n                 if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n@@ -235,9 +235,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sub_origin {\n-            let code = match &cause.code {\n-                ObligationCauseCode::MatchImpl(parent, ..) => &parent.code,\n-                _ => &cause.code,\n+            let code = match cause.code() {\n+                ObligationCauseCode::MatchImpl(parent, ..) => parent.code(),\n+                _ => cause.code(),\n             };\n             if let (ObligationCauseCode::ItemObligation(item_def_id), None) =\n                 (code, override_error_code)"}, {"sha": "f5fb82dbf31d2c9bb95b85d4f8e73280097731a7", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     ValuePairs::Types(sub_expected_found),\n                     ValuePairs::Types(sup_expected_found),\n                     CompareImplMethodObligation { trait_item_def_id, .. },\n-                ) = (&sub_trace.values, &sup_trace.values, &sub_trace.cause.code)\n+                ) = (&sub_trace.values, &sup_trace.values, sub_trace.cause.code())\n                 {\n                     if sup_expected_found == sub_expected_found {\n                         self.emit_err("}, {"sha": "82bd8890dda21c74dad4edca1f98778ea6052468", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -359,13 +359,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         match placeholder_origin {\n             infer::Subtype(box ref trace)\n                 if matches!(\n-                    &trace.cause.code.peel_derives(),\n+                    &trace.cause.code().peel_derives(),\n                     ObligationCauseCode::BindingObligation(..)\n                 ) =>\n             {\n                 // Hack to get around the borrow checker because trace.cause has an `Rc`.\n                 if let ObligationCauseCode::BindingObligation(_, span) =\n-                    &trace.cause.code.peel_derives()\n+                    &trace.cause.code().peel_derives()\n                 {\n                     let span = *span;\n                     let mut err = self.report_concrete_failure(placeholder_origin, sub, sup);"}, {"sha": "04e04e297cdd260407ff75d0b73fae7b6a076adc", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -1824,7 +1824,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n     where\n         F: FnOnce() -> Self,\n     {\n-        match cause.code {\n+        match *cause.code() {\n             traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) => {\n                 SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)\n             }"}, {"sha": "74eb263a6339021bb7ab7315232f948b7836c7c6", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -102,7 +102,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             infer::RelateParamBound(\n                 cause.span,\n                 sup_type,\n-                match cause.code.peel_derives() {\n+                match cause.code().peel_derives() {\n                     ObligationCauseCode::BindingObligation(_, span) => Some(*span),\n                     _ => None,\n                 },"}, {"sha": "e1f3b548e97fe7c8ffcbdda70345e5a53827574b", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -81,7 +81,7 @@ impl TraitObligation<'_> {\n \n // `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(PredicateObligation<'_>, 32);\n+static_assert_size!(PredicateObligation<'_>, 48);\n \n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n "}, {"sha": "de5beffb5c54180f34413836f32769a64523360d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -23,9 +23,7 @@ use rustc_span::{Span, DUMMY_SP};\n use smallvec::SmallVec;\n \n use std::borrow::Cow;\n-use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::ops::Deref;\n \n pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n \n@@ -80,38 +78,14 @@ pub enum Reveal {\n \n /// The reason why we incurred this obligation; used for error reporting.\n ///\n-/// As the happy path does not care about this struct, storing this on the heap\n-/// ends up increasing performance.\n+/// Non-misc `ObligationCauseCode`s are stored on the heap. This gives the\n+/// best trade-off between keeping the type small (which makes copies cheaper)\n+/// while not doing too many heap allocations.\n ///\n /// We do not want to intern this as there are a lot of obligation causes which\n /// only live for a short period of time.\n-#[derive(Clone, PartialEq, Eq, Hash, Lift)]\n-pub struct ObligationCause<'tcx> {\n-    /// `None` for `ObligationCause::dummy`, `Some` otherwise.\n-    data: Option<Lrc<ObligationCauseData<'tcx>>>,\n-}\n-\n-const DUMMY_OBLIGATION_CAUSE_DATA: ObligationCauseData<'static> =\n-    ObligationCauseData { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation };\n-\n-// Correctly format `ObligationCause::dummy`.\n-impl<'tcx> fmt::Debug for ObligationCause<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ObligationCauseData::fmt(self, f)\n-    }\n-}\n-\n-impl<'tcx> Deref for ObligationCause<'tcx> {\n-    type Target = ObligationCauseData<'tcx>;\n-\n-    #[inline(always)]\n-    fn deref(&self) -> &Self::Target {\n-        self.data.as_deref().unwrap_or(&DUMMY_OBLIGATION_CAUSE_DATA)\n-    }\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq, Lift)]\n-pub struct ObligationCauseData<'tcx> {\n+pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n     /// The ID of the fn body that triggered this obligation. This is\n@@ -122,46 +96,58 @@ pub struct ObligationCauseData<'tcx> {\n     /// information.\n     pub body_id: hir::HirId,\n \n-    pub code: ObligationCauseCode<'tcx>,\n+    /// `None` for `MISC_OBLIGATION_CAUSE_CODE` (a common case, occurs ~60% of\n+    /// the time). `Some` otherwise.\n+    code: Option<Lrc<ObligationCauseCode<'tcx>>>,\n }\n \n-impl Hash for ObligationCauseData<'_> {\n+// This custom hash function speeds up hashing for `Obligation` deduplication\n+// greatly by skipping the `code` field, which can be large and complex. That\n+// shouldn't affect hash quality much since there are several other fields in\n+// `Obligation` which should be unique enough, especially the predicate itself\n+// which is hashed as an interned pointer. See #90996.\n+impl Hash for ObligationCause<'_> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.body_id.hash(state);\n         self.span.hash(state);\n-        std::mem::discriminant(&self.code).hash(state);\n     }\n }\n \n+const MISC_OBLIGATION_CAUSE_CODE: ObligationCauseCode<'static> = MiscObligation;\n+\n impl<'tcx> ObligationCause<'tcx> {\n     #[inline]\n     pub fn new(\n         span: Span,\n         body_id: hir::HirId,\n         code: ObligationCauseCode<'tcx>,\n     ) -> ObligationCause<'tcx> {\n-        ObligationCause { data: Some(Lrc::new(ObligationCauseData { span, body_id, code })) }\n+        ObligationCause {\n+            span,\n+            body_id,\n+            code: if code == MISC_OBLIGATION_CAUSE_CODE { None } else { Some(Lrc::new(code)) },\n+        }\n     }\n \n     pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n         ObligationCause::new(span, body_id, MiscObligation)\n     }\n \n-    pub fn dummy_with_span(span: Span) -> ObligationCause<'tcx> {\n-        ObligationCause::new(span, hir::CRATE_HIR_ID, MiscObligation)\n-    }\n-\n     #[inline(always)]\n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { data: None }\n+        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: None }\n+    }\n+\n+    pub fn dummy_with_span(span: Span) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id: hir::CRATE_HIR_ID, code: None }\n     }\n \n-    pub fn make_mut(&mut self) -> &mut ObligationCauseData<'tcx> {\n-        Lrc::make_mut(self.data.get_or_insert_with(|| Lrc::new(DUMMY_OBLIGATION_CAUSE_DATA)))\n+    pub fn make_mut_code(&mut self) -> &mut ObligationCauseCode<'tcx> {\n+        Lrc::make_mut(self.code.get_or_insert_with(|| Lrc::new(MISC_OBLIGATION_CAUSE_CODE)))\n     }\n \n     pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n-        match self.code {\n+        match *self.code() {\n             ObligationCauseCode::CompareImplMethodObligation { .. }\n             | ObligationCauseCode::MainFunctionType\n             | ObligationCauseCode::StartFunctionType => {\n@@ -174,6 +160,18 @@ impl<'tcx> ObligationCause<'tcx> {\n             _ => self.span,\n         }\n     }\n+\n+    #[inline]\n+    pub fn code(&self) -> &ObligationCauseCode<'tcx> {\n+        self.code.as_deref().unwrap_or(&MISC_OBLIGATION_CAUSE_CODE)\n+    }\n+\n+    pub fn clone_code(&self) -> Lrc<ObligationCauseCode<'tcx>> {\n+        match &self.code {\n+            Some(code) => code.clone(),\n+            None => Lrc::new(MISC_OBLIGATION_CAUSE_CODE),\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]"}, {"sha": "df6e739dc201180229ad422fb232152a57448d75", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -519,7 +519,7 @@ impl<T> Trait<T> for X {\n                             proj_ty,\n                             values,\n                             body_owner_def_id,\n-                            &cause.code,\n+                            cause.code(),\n                         );\n                     }\n                     (_, ty::Projection(proj_ty)) => {"}, {"sha": "b5c5724f56edcb0e25d477c77316b6b14d146765", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self.note_obligation_cause_code(\n             &mut err,\n             &obligation.predicate,\n-            &obligation.cause.code,\n+            obligation.cause.code(),\n             &mut vec![],\n             &mut Default::default(),\n         );\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // If this obligation was generated as a result of well-formedness checking, see if we\n                 // can get a better error message by performing HIR-based well-formedness checking.\n                 if let ObligationCauseCode::WellFormed(Some(wf_loc)) =\n-                    root_obligation.cause.code.peel_derives()\n+                    root_obligation.cause.code().peel_derives()\n                 {\n                     if let Some(cause) = self\n                         .tcx\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 | ObligationCauseCode::CompareImplTypeObligation {\n                     impl_item_def_id,\n                     trait_item_def_id,\n-                } = obligation.cause.code\n+                } = *obligation.cause.code()\n                 {\n                     self.report_extra_impl_obligation(\n                         span,\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                         let trait_ref = trait_predicate.to_poly_trait_ref();\n                         let (post_message, pre_message, type_def) = self\n-                            .get_parent_trait_ref(&obligation.cause.code)\n+                            .get_parent_trait_ref(obligation.cause.code())\n                             .map(|(t, s)| {\n                                 (\n                                     format!(\" in `{}`\", t),\n@@ -376,17 +376,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             }\n                         }\n \n-                        let explanation =\n-                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n-                                \"consider using `()`, or a `Result`\".to_owned()\n-                            } else {\n-                                format!(\n-                                    \"{}the trait `{}` is not implemented for `{}`\",\n-                                    pre_message,\n-                                    trait_ref.print_only_trait_path(),\n-                                    trait_ref.skip_binder().self_ty(),\n-                                )\n-                            };\n+                        let explanation = if let ObligationCauseCode::MainFunctionType =\n+                            obligation.cause.code()\n+                        {\n+                            \"consider using `()`, or a `Result`\".to_owned()\n+                        } else {\n+                            format!(\n+                                \"{}the trait `{}` is not implemented for `{}`\",\n+                                pre_message,\n+                                trait_ref.print_only_trait_path(),\n+                                trait_ref.skip_binder().self_ty(),\n+                            )\n+                        };\n \n                         if self.suggest_add_reference_to_arg(\n                             &obligation,\n@@ -1305,7 +1306,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n \n                 let is_normalized_ty_expected = !matches!(\n-                    obligation.cause.code.peel_derives(),\n+                    obligation.cause.code().peel_derives(),\n                     ObligationCauseCode::ItemObligation(_)\n                         | ObligationCauseCode::BindingObligation(_, _)\n                         | ObligationCauseCode::ObjectCastObligation(_)\n@@ -1620,9 +1621,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         let predicate = self.resolve_vars_if_possible(obligation.predicate);\n         let span = obligation.cause.span;\n \n-        debug!(\n-            ?predicate, ?obligation.cause.code,\n-        );\n+        debug!(?predicate, obligation.cause.code = tracing::field::debug(&obligation.cause.code()));\n \n         // Ambiguity errors are often caused as fallout from earlier errors.\n         // We ignore them if this `infcx` is tainted in some cases below.\n@@ -1717,13 +1716,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n+                if let ObligationCauseCode::ItemObligation(def_id) = *obligation.cause.code() {\n                     self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n                 } else if let (\n                     Ok(ref snippet),\n                     ObligationCauseCode::BindingObligation(ref def_id, _),\n                 ) =\n-                    (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n+                    (self.tcx.sess.source_map().span_to_snippet(span), obligation.cause.code())\n                 {\n                     let generics = self.tcx.generics_of(*def_id);\n                     if generics.params.iter().any(|p| p.name != kw::SelfUpper)\n@@ -2006,7 +2005,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             self.note_obligation_cause_code(\n                 err,\n                 &obligation.predicate,\n-                &obligation.cause.code,\n+                obligation.cause.code(),\n                 &mut vec![],\n                 &mut Default::default(),\n             );\n@@ -2019,15 +2018,16 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n-        let (pred, item_def_id, span) =\n-            match (obligation.predicate.kind().skip_binder(), obligation.cause.code.peel_derives())\n-            {\n-                (\n-                    ty::PredicateKind::Trait(pred),\n-                    &ObligationCauseCode::BindingObligation(item_def_id, span),\n-                ) => (pred, item_def_id, span),\n-                _ => return,\n-            };\n+        let (pred, item_def_id, span) = match (\n+            obligation.predicate.kind().skip_binder(),\n+            obligation.cause.code().peel_derives(),\n+        ) {\n+            (\n+                ty::PredicateKind::Trait(pred),\n+                &ObligationCauseCode::BindingObligation(item_def_id, span),\n+            ) => (pred, item_def_id, span),\n+            _ => return,\n+        };\n         debug!(\n             \"suggest_unsized_bound_if_applicable: pred={:?} item_def_id={:?} span={:?}\",\n             pred, item_def_id, span"}, {"sha": "1540725246b514cd887589da70f86c6588704d2c", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             self.describe_enclosure(obligation.cause.body_id).map(|s| s.to_owned()),\n         )];\n \n-        match obligation.cause.code {\n+        match obligation.cause.code() {\n             ObligationCauseCode::BuiltinDerivedObligation(..)\n             | ObligationCauseCode::ImplDerivedObligation(..)\n             | ObligationCauseCode::DerivedObligation(..) => {}\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         if let ObligationCauseCode::ItemObligation(item)\n-        | ObligationCauseCode::BindingObligation(item, _) = obligation.cause.code\n+        | ObligationCauseCode::BindingObligation(item, _) = *obligation.cause.code()\n         {\n             // FIXME: maybe also have some way of handling methods\n             // from other traits? That would require name resolution,"}, {"sha": "0f276718c16e774c217d17539aff9c8019db206f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -9,7 +9,6 @@ use crate::traits::normalize_projection_type;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::{\n     error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n };\n@@ -497,7 +496,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) {\n         // It only make sense when suggesting dereferences for arguments\n         let code = if let ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } =\n-            &obligation.cause.code\n+            obligation.cause.code()\n         {\n             parent_code.clone()\n         } else {\n@@ -662,7 +661,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             _ => return,\n         };\n-        if matches!(obligation.cause.code, ObligationCauseCode::FunctionArgumentObligation { .. }) {\n+        if matches!(obligation.cause.code(), ObligationCauseCode::FunctionArgumentObligation { .. })\n+        {\n             // When the obligation error has been ensured to have been caused by\n             // an argument, the `obligation.cause.span` points at the expression\n             // of the argument, so we can provide a suggestion. Otherwise, we give\n@@ -688,13 +688,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let span = obligation.cause.span;\n \n         let code = if let ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } =\n-            &obligation.cause.code\n+            obligation.cause.code()\n         {\n-            parent_code.clone()\n+            &parent_code\n         } else if let ExpnKind::Desugaring(DesugaringKind::ForLoop) =\n             span.ctxt().outer_expn_data().kind\n         {\n-            Lrc::new(obligation.cause.code.clone())\n+            obligation.cause.code()\n         } else {\n             return false;\n         };\n@@ -805,10 +805,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return false;\n         };\n \n-        if let ObligationCauseCode::ImplDerivedObligation(obligation) = &*code {\n+        if let ObligationCauseCode::ImplDerivedObligation(obligation) = code {\n             try_borrowing(obligation.parent_trait_ref, &[])\n         } else if let ObligationCauseCode::BindingObligation(_, _)\n-        | ObligationCauseCode::ItemObligation(_) = &*code\n+        | ObligationCauseCode::ItemObligation(_) = code\n         {\n             try_borrowing(*poly_trait_ref, &never_suggest_borrow)\n         } else {\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) {\n         let span = obligation.cause.span;\n \n-        if let ObligationCauseCode::AwaitableExpr(hir_id) = obligation.cause.code.peel_derives() {\n+        if let ObligationCauseCode::AwaitableExpr(hir_id) = obligation.cause.code().peel_derives() {\n             let hir = self.tcx.hir();\n             if let Some(node) = hir_id.and_then(|hir_id| hir.find(hir_id)) {\n                 if let hir::Node::Expr(expr) = node {\n@@ -945,7 +945,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     ) {\n         let points_at_arg = matches!(\n-            obligation.cause.code,\n+            obligation.cause.code(),\n             ObligationCauseCode::FunctionArgumentObligation { .. },\n         );\n \n@@ -1072,7 +1072,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     ) -> bool {\n-        match obligation.cause.code.peel_derives() {\n+        match obligation.cause.code().peel_derives() {\n             // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n             ObligationCauseCode::SizedReturnType => {}\n             _ => return false,\n@@ -1267,7 +1267,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n-        match obligation.cause.code.peel_derives() {\n+        match obligation.cause.code().peel_derives() {\n             ObligationCauseCode::SizedReturnType => {}\n             _ => return,\n         }\n@@ -1461,7 +1461,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         let mut generator = None;\n         let mut outer_generator = None;\n-        let mut next_code = Some(&obligation.cause.code);\n+        let mut next_code = Some(obligation.cause.code());\n \n         let mut seen_upvar_tys_infer_tuple = false;\n "}, {"sha": "42e3f0db15e538204b701ff96e72ae2b95933aeb", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -96,7 +96,7 @@ pub struct PendingPredicateObligation<'tcx> {\n \n // `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(PendingPredicateObligation<'_>, 56);\n+static_assert_size!(PendingPredicateObligation<'_>, 72);\n \n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context."}, {"sha": "85016a701f3b160ed65d2a976962959d3129dcda", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -29,7 +29,6 @@ use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -2384,7 +2383,7 @@ impl<'tcx> TraitObligationExt<'tcx> for TraitObligation<'tcx> {\n         // by using -Z verbose or just a CLI argument.\n         let derived_cause = DerivedObligationCause {\n             parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n-            parent_code: Lrc::new(obligation.cause.code.clone()),\n+            parent_code: obligation.cause.clone_code(),\n         };\n         let derived_code = variant(derived_cause);\n         ObligationCause::new(obligation.cause.span, obligation.cause.body_id, derived_code)"}, {"sha": "b6e653c0eea4600e50afe4242f643d5d689d68d8", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -232,7 +232,7 @@ pub fn predicates_for_generics<'tcx>(\n     debug!(\"predicates_for_generics(generic_bounds={:?})\", generic_bounds);\n \n     iter::zip(generic_bounds.predicates, generic_bounds.spans).map(move |(predicate, span)| {\n-        let cause = match cause.code {\n+        let cause = match *cause.code() {\n             traits::ItemObligation(def_id) if !span.is_dummy() => traits::ObligationCause::new(\n                 cause.span,\n                 cause.body_id,"}, {"sha": "4bd73ef68aa7a58fa707562739a6bec2068df0b0", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -1,7 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::opaque_types::required_region_bounds;\n use crate::traits;\n-use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -227,7 +226,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                 if let Some(impl_item_span) =\n                     items.iter().find(|item| item.ident == trait_assoc_item.ident).map(fix_span)\n                 {\n-                    cause.make_mut().span = impl_item_span;\n+                    cause.span = impl_item_span;\n                 }\n             }\n         }\n@@ -242,7 +241,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                         items.iter().find(|i| i.ident == trait_assoc_item.ident).map(fix_span)\n                     })\n                 {\n-                    cause.make_mut().span = impl_item_span;\n+                    cause.span = impl_item_span;\n                 }\n             }\n         }\n@@ -302,9 +301,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 let derived_cause = traits::DerivedObligationCause {\n                     // FIXME(fee1-dead): when improving error messages, change this to PolyTraitPredicate\n                     parent_trait_ref: parent_trait_ref.map_bound(|t| t.trait_ref),\n-                    parent_code: Lrc::new(obligation.cause.code.clone()),\n+                    parent_code: obligation.cause.clone_code(),\n                 };\n-                cause.make_mut().code =\n+                *cause.make_mut_code() =\n                     traits::ObligationCauseCode::DerivedObligation(derived_cause);\n             }\n             extend_cause_with_original_assoc_item_obligation(\n@@ -343,7 +342,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         if let Some(hir::ItemKind::Impl(hir::Impl { self_ty, .. })) =\n                             item.map(|i| &i.kind)\n                         {\n-                            new_cause.make_mut().span = self_ty.span;\n+                            new_cause.span = self_ty.span;\n                         }\n                     }\n                     traits::Obligation::with_depth("}, {"sha": "6192c77d6c648e42da1c2e4cfc121f1a96f6b5dd", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -1444,7 +1444,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n                 let mut err;\n                 let mut unsized_return = false;\n-                match cause.code {\n+                match *cause.code() {\n                     ObligationCauseCode::ReturnNoExpression => {\n                         err = struct_span_err!(\n                             fcx.tcx.sess,"}, {"sha": "c942bafcf034bcc67fb411f533607b770d8047aa", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -232,7 +232,7 @@ fn compare_predicate_entailment<'tcx>(\n \n             inh.register_predicates(obligations);\n             let mut cause = cause.clone();\n-            cause.make_mut().span = span;\n+            cause.span = span;\n             inh.register_predicate(traits::Obligation::new(cause, param_env, predicate));\n         }\n \n@@ -293,7 +293,7 @@ fn compare_predicate_entailment<'tcx>(\n             let (impl_err_span, trait_err_span) =\n                 extract_spans_for_error_reporting(&infcx, &terr, &cause, impl_m, trait_m);\n \n-            cause.make_mut().span = impl_err_span;\n+            cause.span = impl_err_span;\n \n             let mut diag = struct_span_err!(\n                 tcx.sess,\n@@ -1043,7 +1043,7 @@ crate fn compare_const_impl<'tcx>(\n \n             // Locate the Span containing just the type of the offending impl\n             match tcx.hir().expect_impl_item(impl_c.def_id.expect_local()).kind {\n-                ImplItemKind::Const(ref ty, _) => cause.make_mut().span = ty.span,\n+                ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n                 _ => bug!(\"{:?} is not a impl const\", impl_c),\n             }\n "}, {"sha": "11b63a99043b705451d9439948c07a90a956ec92", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -997,7 +997,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 result_code\n             }\n-            let self_: ty::subst::GenericArg<'_> = match &*unpeel_to_top(Lrc::new(error.obligation.cause.code.clone())) {\n+            let self_: ty::subst::GenericArg<'_> = match &*unpeel_to_top(error.obligation.cause.clone_code()) {\n                 ObligationCauseCode::BuiltinDerivedObligation(code) |\n                 ObligationCauseCode::ImplDerivedObligation(code) |\n                 ObligationCauseCode::DerivedObligation(code) => {\n@@ -1040,18 +1040,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 // We make sure that only *one* argument matches the obligation failure\n                 // and we assign the obligation's span to its expression's.\n-                error.obligation.cause.make_mut().span = args[ref_in].span;\n-                let code = error.obligation.cause.code.clone();\n-                error.obligation.cause.make_mut().code =\n+                error.obligation.cause.span = args[ref_in].span;\n+                let parent_code = error.obligation.cause.clone_code();\n+                *error.obligation.cause.make_mut_code() =\n                     ObligationCauseCode::FunctionArgumentObligation {\n                         arg_hir_id: args[ref_in].hir_id,\n                         call_hir_id: expr.hir_id,\n-                        parent_code: Lrc::new(code),\n+                        parent_code,\n                     };\n-            } else if error.obligation.cause.make_mut().span == call_sp {\n+            } else if error.obligation.cause.span == call_sp {\n                 // Make function calls point at the callee, not the whole thing.\n                 if let hir::ExprKind::Call(callee, _) = expr.kind {\n-                    error.obligation.cause.make_mut().span = callee.span;\n+                    error.obligation.cause.span = callee.span;\n                 }\n             }\n         }\n@@ -1092,7 +1092,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, hir_ty);\n                                     let ty = self.resolve_vars_if_possible(ty);\n                                     if ty == predicate.self_ty() {\n-                                        error.obligation.cause.make_mut().span = hir_ty.span;\n+                                        error.obligation.cause.span = hir_ty.span;\n                                     }\n                                 }\n                             }"}, {"sha": "1dcc20c29a32c1a6a3d11ab2edf3950b9e7aba93", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed7a2068432b62880bca89cd69546682a2e192cd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ed7a2068432b62880bca89cd69546682a2e192cd", "patch": "@@ -832,7 +832,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     for (data, p, parent_p) in unsatisfied_predicates\n                         .iter()\n                         .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n-                        .filter_map(|(p, parent, c)| match c.code {\n+                        .filter_map(|(p, parent, c)| match c.code() {\n                             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n                                 Some((data, p, parent))\n                             }"}]}