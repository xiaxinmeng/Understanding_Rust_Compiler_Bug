{"sha": "add04307f9b627992914b31dca82530f7886ef9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZDA0MzA3ZjliNjI3OTkyOTE0YjMxZGNhODI1MzBmNzg4NmVmOWE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-09-02T23:46:41Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-09-04T16:14:13Z"}, "message": "Support non-return value references in platform intrinsic generator.", "tree": {"sha": "d271de03257e734d384d636fcf4439f93029176b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d271de03257e734d384d636fcf4439f93029176b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/add04307f9b627992914b31dca82530f7886ef9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/add04307f9b627992914b31dca82530f7886ef9a", "html_url": "https://github.com/rust-lang/rust/commit/add04307f9b627992914b31dca82530f7886ef9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/add04307f9b627992914b31dca82530f7886ef9a/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d12135a70de99e1cf86e3147379f4eb0678cd97c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d12135a70de99e1cf86e3147379f4eb0678cd97c", "html_url": "https://github.com/rust-lang/rust/commit/d12135a70de99e1cf86e3147379f4eb0678cd97c"}], "stats": {"total": 153, "additions": 79, "deletions": 74}, "files": [{"sha": "2102bd9c488ba3fe8b69d0eed8a4f6212a043026", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 79, "deletions": 74, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/add04307f9b627992914b31dca82530f7886ef9a/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/add04307f9b627992914b31dca82530f7886ef9a/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=add04307f9b627992914b31dca82530f7886ef9a", "patch": "@@ -14,6 +14,7 @@\n import sys\n import re\n import textwrap\n+import itertools\n \n SPEC = re.compile(\n     r'^(?:(?P<id>[iusfIUSF])(?:\\((?P<start>\\d+)-(?P<end>\\d+)\\)|'\n@@ -258,7 +259,7 @@ def type_info(self, platform_info):\n                   'u': [Unsigned],\n                   'f': [Float]}\n \n-def ptrify(match, elem, width):\n+def ptrify(match, elem, width, previous):\n     ptr = match.group('pointer')\n     if ptr is None:\n         return elem\n@@ -268,7 +269,7 @@ def ptrify(match, elem, width):\n             llvm_elem = None\n         else:\n             assert llvm_ptr.startswith('/')\n-            options = list(TypeSpec(llvm_ptr[1:]).enumerate(width))\n+            options = list(TypeSpec(llvm_ptr[1:]).enumerate(width, previous))\n             assert len(options) == 1\n             llvm_elem = options[0]\n         assert ptr in ('Pc', 'Pm')\n@@ -281,77 +282,70 @@ def __init__(self, spec):\n \n         self.spec = spec\n \n-    def enumerate(self, width):\n+    def enumerate(self, width, previous):\n         for spec in self.spec:\n             match = SPEC.match(spec)\n-            assert match is not None\n-            if True:\n+            if match is not None:\n                 id = match.group('id')\n-                assert id is not None\n-                is_vector = id.islower()\n-                type_ctors = TYPE_ID_LOOKUP[id.lower()]\n-\n-                start = match.group('start')\n-                if start is not None:\n-                    end = match.group('end')\n-                    llvm_width = None\n+                reference = match.group('reference')\n+\n+                if id is not None:\n+                    is_vector = id.islower()\n+                    type_ctors = TYPE_ID_LOOKUP[id.lower()]\n+\n+                    start = match.group('start')\n+                    if start is not None:\n+                        end = match.group('end')\n+                        llvm_width = None\n+                    else:\n+                        start = end = match.group('width')\n+                        llvm_width = match.group('llvm_width')\n+                    start = int(start)\n+                    end = int(end)\n+\n+                    bitwidth = start\n+                    while bitwidth <= end:\n+                        for ctor in type_ctors:\n+                            if llvm_width is not None:\n+                                assert not is_vector\n+                                llvm_width = int(llvm_width)\n+                                assert llvm_width < bitwidth\n+                                scalar = ctor(bitwidth, llvm_width)\n+                            else:\n+                                scalar = ctor(bitwidth)\n+\n+                            if is_vector:\n+                                elem = Vector(scalar, width // bitwidth)\n+                            else:\n+                                elem = scalar\n+                            yield ptrify(match, elem, width, previous)\n+                        bitwidth *= 2\n+                elif reference is not None:\n+                    reference = int(reference)\n+                    assert reference < len(previous), \\\n+                        'referring to argument {}, but only {} are known'.format(reference,\n+                                                                                 len(previous))\n+                    ret = previous[reference]\n+                    for x in match.group('modifiers') or []:\n+                        ret = ret.modify(x, width)\n+                    force = match.group('force_width')\n+                    if force is not None:\n+                        ret = ret.modify(force, width)\n+                    yield ptrify(match, ret, width, previous)\n                 else:\n-                    start = end = match.group('width')\n-                    llvm_width = match.group('llvm_width')\n-                start = int(start)\n-                end = int(end)\n-\n-                bitwidth = start\n-                while bitwidth <= end:\n-                    for ctor in type_ctors:\n-                        if llvm_width is not None:\n-                            assert not is_vector\n-                            llvm_width = int(llvm_width)\n-                            assert llvm_width < bitwidth\n-                            scalar = ctor(bitwidth, llvm_width)\n-                        else:\n-                            scalar = ctor(bitwidth)\n-\n-                        if is_vector:\n-                            elem = Vector(scalar, width // bitwidth)\n-                        else:\n-                            elem = scalar\n-                        yield ptrify(match, elem, width)\n-                    bitwidth *= 2\n+                    assert False, 'matched `{}`, but didn\\'t understand it?'.format(spec)\n+            elif spec.startswith('('):\n+                if spec.endswith(')'):\n+                    raise NotImplementedError()\n+                elif spec.endswith(')f'):\n+                    true_spec = spec[1:-2]\n+                    flatten = True\n+\n+                for elems in itertools.product(*(TypeSpec(subspec).enumerate(width, previous)\n+                                                 for subspec in true_spec.split(','))):\n+                    yield Aggregate(flatten, elems)\n             else:\n-                pass\n-                #print('Failed to parse: `{}`'.format(spec), file=sys.stderr)\n-\n-    def resolve(self, width, zero):\n-        assert len(self.spec) == 1\n-        spec = self.spec[0]\n-        match = SPEC.match(spec)\n-        if match:\n-            id = match.group('id')\n-            if id is not None:\n-                options = list(self.enumerate(width))\n-                assert len(options) == 1\n-                return options[0]\n-            reference = match.group('reference')\n-            if reference != '0':\n-                raise NotImplementedError('only argument 0 (return value) references are supported')\n-            ret = zero\n-            for x in match.group('modifiers') or []:\n-                ret = ret.modify(x, width)\n-            force = match.group('force_width')\n-            if force is not None:\n-                ret = ret.modify(force, width)\n-            return ptrify(match, ret, width)\n-        elif spec.startswith('('):\n-            if spec.endswith(')'):\n-                raise NotImplementedError()\n-            elif spec.endswith(')f'):\n-                true_spec = spec[1:-2]\n-                flatten = True\n-            elems = [TypeSpec(subspec).resolve(width, zero) for subspec in true_spec.split(',')]\n-            return Aggregate(flatten, elems)\n-        else:\n-            assert False, 'Failed to resolve: {}'.format(spec)\n+                assert False, 'Failed to parse `{}`'.format(spec)\n \n class GenericIntrinsic(object):\n     def __init__(self, platform, intrinsic, widths, llvm_name, ret, args):\n@@ -366,10 +360,22 @@ def monomorphise(self):\n         for width in self.widths:\n             # must be a power of two\n             assert width & (width - 1) == 0\n-            for ret in self.ret.enumerate(width):\n-                args = [arg.resolve(width, ret) for arg in self.args]\n-                yield MonomorphicIntrinsic(self._platform, self.intrinsic, width, self.llvm_name,\n-                                           ret, args)\n+            def recur(processed, untouched):\n+                if untouched == []:\n+                    ret = processed[0]\n+                    args = processed[1:]\n+                    yield MonomorphicIntrinsic(self._platform, self.intrinsic, width,\n+                                               self.llvm_name,\n+                                               ret, args)\n+                else:\n+                    raw_arg = untouched[0]\n+                    rest = untouched[1:]\n+                    for arg in raw_arg.enumerate(width, processed):\n+                        for intr in recur(processed + [arg], rest):\n+                            yield intr\n+\n+            for x in recur([], [self.ret] + self.args):\n+                yield x\n \n class MonomorphicIntrinsic(object):\n     def __init__(self, platform, intrinsic, width, llvm_name, ret, args):\n@@ -517,8 +523,7 @@ def parse_args():\n         A reference uses the type of another argument, with possible\n         modifications. The number refers to the type to use, starting\n         with 0 == return value, 1 == first argument, 2 == second\n-        argument, etc. (Currently only referencing 0, the return\n-        value, is supported.)\n+        argument, etc.\n \n         ### Modifiers\n "}]}