{"sha": "59a05ad118a5d85dd8998babbe5bcd3163303a43", "node_id": "C_kwDOAAsO6NoAKDU5YTA1YWQxMThhNWQ4NWRkODk5OGJhYmJlNWJjZDMxNjMzMDNhNDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-12T17:45:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-12T17:45:33Z"}, "message": "Auto merge of #110239 - matthiaskrgr:rollup-o90hx4s, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #109959 (Fix transmute intrinsic mir validation ICE)\n - #110176 (Renumbering cleanups)\n - #110182 (Use `itertools::Either` instead of own impl)\n - #110188 (Remove orphaned remove_dir_all implementation from rust-installer)\n - #110190 (Custom MIR: Support `BinOp::Offset`)\n - #110209 (Add regression test for #59003)\n - #110210 (`DescriptionCtx` cleanups)\n - #110217 (doc: loongarch: Fix typos)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9b46c3b5c4586ea89186514fbf82e5f798ec7975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b46c3b5c4586ea89186514fbf82e5f798ec7975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59a05ad118a5d85dd8998babbe5bcd3163303a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59a05ad118a5d85dd8998babbe5bcd3163303a43", "html_url": "https://github.com/rust-lang/rust/commit/59a05ad118a5d85dd8998babbe5bcd3163303a43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59a05ad118a5d85dd8998babbe5bcd3163303a43/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "661b33f5247debc4e0cd948caa388997e18e9cb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/661b33f5247debc4e0cd948caa388997e18e9cb8", "html_url": "https://github.com/rust-lang/rust/commit/661b33f5247debc4e0cd948caa388997e18e9cb8"}, {"sha": "a9545844127849e765f228351a60e3c2e5d9ebbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9545844127849e765f228351a60e3c2e5d9ebbb", "html_url": "https://github.com/rust-lang/rust/commit/a9545844127849e765f228351a60e3c2e5d9ebbb"}], "stats": {"total": 1336, "additions": 208, "deletions": 1128}, "files": [{"sha": "f9e8ea7a7140d820ffd978016b8d2fed721356ff", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -2769,13 +2769,11 @@ dependencies = [\n  \"anyhow\",\n  \"clap 3.2.20\",\n  \"flate2\",\n- \"lazy_static\",\n  \"num_cpus\",\n  \"rayon\",\n  \"remove_dir_all\",\n  \"tar\",\n  \"walkdir\",\n- \"winapi\",\n  \"xz2\",\n ]\n \n@@ -4576,6 +4574,7 @@ dependencies = [\n  \"elsa\",\n  \"ena\",\n  \"indexmap\",\n+ \"itertools\",\n  \"jobserver\",\n  \"libc\",\n  \"measureme\","}, {"sha": "2c1d74ef9ca85e61f1694ab76b4dd9997d5500d6", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -20,31 +20,13 @@ pub fn renumber_mir<'tcx>(\n ) {\n     debug!(?body.arg_count);\n \n-    let mut visitor = NllVisitor { infcx };\n+    let mut renumberer = RegionRenumberer { infcx };\n \n     for body in promoted.iter_mut() {\n-        visitor.visit_body(body);\n+        renumberer.visit_body(body);\n     }\n \n-    visitor.visit_body(body);\n-}\n-\n-/// Replaces all regions appearing in `value` with fresh inference\n-/// variables.\n-#[instrument(skip(infcx, get_ctxt_fn), level = \"debug\")]\n-pub(crate) fn renumber_regions<'tcx, T, F>(\n-    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n-    value: T,\n-    get_ctxt_fn: F,\n-) -> T\n-where\n-    T: TypeFoldable<TyCtxt<'tcx>>,\n-    F: Fn() -> RegionCtxt,\n-{\n-    infcx.tcx.fold_regions(value, |_region, _depth| {\n-        let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n-        infcx.next_nll_region_var(origin, || get_ctxt_fn())\n-    })\n+    renumberer.visit_body(body);\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n@@ -82,21 +64,26 @@ impl RegionCtxt {\n     }\n }\n \n-struct NllVisitor<'a, 'tcx> {\n+struct RegionRenumberer<'a, 'tcx> {\n     infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> RegionRenumberer<'a, 'tcx> {\n+    /// Replaces all regions appearing in `value` with fresh inference\n+    /// variables.\n     fn renumber_regions<T, F>(&mut self, value: T, region_ctxt_fn: F) -> T\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n         F: Fn() -> RegionCtxt,\n     {\n-        renumber_regions(self.infcx, value, region_ctxt_fn)\n+        let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n+        self.infcx.tcx.fold_regions(value, |_region, _depth| {\n+            self.infcx.next_nll_region_var(origin, || region_ctxt_fn())\n+        })\n     }\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> MutVisitor<'tcx> for RegionRenumberer<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -124,9 +111,9 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _location: Location) {\n+    fn visit_constant(&mut self, constant: &mut Constant<'tcx>, location: Location) {\n         let literal = constant.literal;\n-        constant.literal = self.renumber_regions(literal, || RegionCtxt::Location(_location));\n+        constant.literal = self.renumber_regions(literal, || RegionCtxt::Location(location));\n         debug!(\"constant: {:#?}\", constant);\n     }\n }"}, {"sha": "d4bed97380ba18f703ff4212502acd8246b0ce3c", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -679,13 +679,21 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             // Unlike `mem::transmute`, a MIR `Transmute` is well-formed\n                             // for any two `Sized` types, just potentially UB to run.\n \n-                            if !op_ty.is_sized(self.tcx, self.param_env) {\n+                            if !self\n+                                .tcx\n+                                .normalize_erasing_regions(self.param_env, op_ty)\n+                                .is_sized(self.tcx, self.param_env)\n+                            {\n                                 self.fail(\n                                     location,\n                                     format!(\"Cannot transmute from non-`Sized` type {op_ty:?}\"),\n                                 );\n                             }\n-                            if !target_type.is_sized(self.tcx, self.param_env) {\n+                            if !self\n+                                .tcx\n+                                .normalize_erasing_regions(self.param_env, *target_type)\n+                                .is_sized(self.tcx, self.param_env)\n+                            {\n                                 self.fail(\n                                     location,\n                                     format!(\"Cannot transmute to non-`Sized` type {target_type:?}\"),"}, {"sha": "2102f09c56a03f5b168930bbf5d099f6133909dd", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -33,6 +33,7 @@ tempfile = \"3.2\"\n thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n elsa = \"=1.7.1\"\n+itertools = \"0.10.1\"\n \n [dependencies.parking_lot]\n version = \"0.11\""}, {"sha": "bca6c0955b905f8732fb72b598fc75e62d924152", "filename": "compiler/rustc_data_structures/src/sso/either_iter.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/661b33f5247debc4e0cd948caa388997e18e9cb8/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661b33f5247debc4e0cd948caa388997e18e9cb8/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs?ref=661b33f5247debc4e0cd948caa388997e18e9cb8", "patch": "@@ -1,73 +0,0 @@\n-use std::fmt;\n-use std::iter::FusedIterator;\n-\n-/// Iterator which may contain instance of\n-/// one of two specific implementations.\n-///\n-/// Note: For most methods providing custom\n-///       implementation may marginally\n-///       improve performance by avoiding\n-///       doing Left/Right match on every step\n-///       and doing it only once instead.\n-#[derive(Clone)]\n-pub enum EitherIter<L, R> {\n-    Left(L),\n-    Right(R),\n-}\n-\n-impl<L, R> Iterator for EitherIter<L, R>\n-where\n-    L: Iterator,\n-    R: Iterator<Item = L::Item>,\n-{\n-    type Item = L::Item;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self {\n-            EitherIter::Left(l) => l.next(),\n-            EitherIter::Right(r) => r.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self {\n-            EitherIter::Left(l) => l.size_hint(),\n-            EitherIter::Right(r) => r.size_hint(),\n-        }\n-    }\n-}\n-\n-impl<L, R> ExactSizeIterator for EitherIter<L, R>\n-where\n-    L: ExactSizeIterator,\n-    R: ExactSizeIterator,\n-    EitherIter<L, R>: Iterator,\n-{\n-    fn len(&self) -> usize {\n-        match self {\n-            EitherIter::Left(l) => l.len(),\n-            EitherIter::Right(r) => r.len(),\n-        }\n-    }\n-}\n-\n-impl<L, R> FusedIterator for EitherIter<L, R>\n-where\n-    L: FusedIterator,\n-    R: FusedIterator,\n-    EitherIter<L, R>: Iterator,\n-{\n-}\n-\n-impl<L, R> fmt::Debug for EitherIter<L, R>\n-where\n-    L: fmt::Debug,\n-    R: fmt::Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            EitherIter::Left(l) => l.fmt(f),\n-            EitherIter::Right(r) => r.fmt(f),\n-        }\n-    }\n-}"}, {"sha": "89b8c852649691261b3e8080f926bd171c77eae9", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -1,24 +1,24 @@\n-use super::either_iter::EitherIter;\n use crate::fx::FxHashMap;\n use arrayvec::ArrayVec;\n+use itertools::Either;\n use std::fmt;\n use std::hash::Hash;\n use std::ops::Index;\n \n-// For pointer-sized arguments arrays\n-// are faster than set/map for up to 64\n-// arguments.\n-//\n-// On the other hand such a big array\n-// hurts cache performance, makes passing\n-// sso structures around very expensive.\n-//\n-// Biggest performance benefit is gained\n-// for reasonably small arrays that stay\n-// small in vast majority of cases.\n-//\n-// '8' is chosen as a sane default, to be\n-// reevaluated later.\n+/// For pointer-sized arguments arrays\n+/// are faster than set/map for up to 64\n+/// arguments.\n+///\n+/// On the other hand such a big array\n+/// hurts cache performance, makes passing\n+/// sso structures around very expensive.\n+///\n+/// Biggest performance benefit is gained\n+/// for reasonably small arrays that stay\n+/// small in vast majority of cases.\n+///\n+/// '8' is chosen as a sane default, to be\n+/// reevaluated later.\n const SSO_ARRAY_SIZE: usize = 8;\n \n /// Small-storage-optimized implementation of a map.\n@@ -138,35 +138,35 @@ impl<K, V> SsoHashMap<K, V> {\n     /// The iterator element type is `&'a K`.\n     pub fn keys(&self) -> impl Iterator<Item = &'_ K> {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(k, _v)| k)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.keys()),\n+            SsoHashMap::Array(array) => Either::Left(array.iter().map(|(k, _v)| k)),\n+            SsoHashMap::Map(map) => Either::Right(map.keys()),\n         }\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n     /// The iterator element type is `&'a V`.\n     pub fn values(&self) -> impl Iterator<Item = &'_ V> {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(_k, v)| v)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.values()),\n+            SsoHashMap::Array(array) => Either::Left(array.iter().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => Either::Right(map.values()),\n         }\n     }\n \n     /// An iterator visiting all values mutably in arbitrary order.\n     /// The iterator element type is `&'a mut V`.\n     pub fn values_mut(&mut self) -> impl Iterator<Item = &'_ mut V> {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.iter_mut().map(|(_k, v)| v)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.values_mut()),\n+            SsoHashMap::Array(array) => Either::Left(array.iter_mut().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => Either::Right(map.values_mut()),\n         }\n     }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n     /// allocated memory for reuse.\n     pub fn drain(&mut self) -> impl Iterator<Item = (K, V)> + '_ {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.drain(..)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.drain()),\n+            SsoHashMap::Array(array) => Either::Left(array.drain(..)),\n+            SsoHashMap::Map(map) => Either::Right(map.drain()),\n         }\n     }\n }\n@@ -406,16 +406,16 @@ where\n }\n \n impl<K, V> IntoIterator for SsoHashMap<K, V> {\n-    type IntoIter = EitherIter<\n-        <ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n+    type IntoIter = Either<\n+        <ArrayVec<(K, V), SSO_ARRAY_SIZE> as IntoIterator>::IntoIter,\n         <FxHashMap<K, V> as IntoIterator>::IntoIter,\n     >;\n     type Item = <Self::IntoIter as Iterator>::Item;\n \n     fn into_iter(self) -> Self::IntoIter {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter()),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+            SsoHashMap::Array(array) => Either::Left(array.into_iter()),\n+            SsoHashMap::Map(map) => Either::Right(map.into_iter()),\n         }\n     }\n }\n@@ -435,9 +435,9 @@ fn adapt_array_mut_it<K, V>(pair: &mut (K, V)) -> (&K, &mut V) {\n }\n \n impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n-    type IntoIter = EitherIter<\n+    type IntoIter = Either<\n         std::iter::Map<\n-            <&'a ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n+            <&'a ArrayVec<(K, V), SSO_ARRAY_SIZE> as IntoIterator>::IntoIter,\n             fn(&'a (K, V)) -> (&'a K, &'a V),\n         >,\n         <&'a FxHashMap<K, V> as IntoIterator>::IntoIter,\n@@ -446,16 +446,16 @@ impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n \n     fn into_iter(self) -> Self::IntoIter {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_ref_it)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.iter()),\n+            SsoHashMap::Array(array) => Either::Left(array.into_iter().map(adapt_array_ref_it)),\n+            SsoHashMap::Map(map) => Either::Right(map.iter()),\n         }\n     }\n }\n \n impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n-    type IntoIter = EitherIter<\n+    type IntoIter = Either<\n         std::iter::Map<\n-            <&'a mut ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n+            <&'a mut ArrayVec<(K, V), SSO_ARRAY_SIZE> as IntoIterator>::IntoIter,\n             fn(&'a mut (K, V)) -> (&'a K, &'a mut V),\n         >,\n         <&'a mut FxHashMap<K, V> as IntoIterator>::IntoIter,\n@@ -464,8 +464,8 @@ impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n \n     fn into_iter(self) -> Self::IntoIter {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_mut_it)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.iter_mut()),\n+            SsoHashMap::Array(array) => Either::Left(array.into_iter().map(adapt_array_mut_it)),\n+            SsoHashMap::Map(map) => Either::Right(map.iter_mut()),\n         }\n     }\n }"}, {"sha": "ef634b9adcec3fa25150eea8a8a844a6d243ec07", "filename": "compiler/rustc_data_structures/src/sso/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -1,4 +1,3 @@\n-mod either_iter;\n mod map;\n mod set;\n "}, {"sha": "1ae53182046f31fc2bf2224260c652498148cd13", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -163,7 +163,6 @@ infer_region_explanation = {$pref_kind ->\n     [as_defined] the lifetime `{$desc_arg}` as defined here\n     [as_defined_anon] the anonymous lifetime as defined here\n     [defined_here] the anonymous lifetime defined here\n-    [anon_num_here] the anonymous lifetime #{$desc_num_arg} defined here\n     [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n }{$suff_kind ->\n     *[should_not_happen] [{$suff_kind}]"}, {"sha": "7328241dfbcaf3a48cdd2f05dd637cee16537c50", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 47, "deletions": 76, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -4,12 +4,10 @@ use rustc_errors::{self, AddToDiagnostic, Diagnostic, IntoDiagnosticArg, Subdiag\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{symbol::kw, Span};\n \n-#[derive(Default)]\n struct DescriptionCtx<'a> {\n     span: Option<Span>,\n     kind: &'a str,\n     arg: String,\n-    num_arg: u32,\n }\n \n impl<'a> DescriptionCtx<'a> {\n@@ -18,102 +16,74 @@ impl<'a> DescriptionCtx<'a> {\n         region: ty::Region<'tcx>,\n         alt_span: Option<Span>,\n     ) -> Option<Self> {\n-        let mut me = DescriptionCtx::default();\n-        me.span = alt_span;\n-        match *region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                return Self::from_early_bound_and_free_regions(tcx, region);\n-            }\n-            ty::ReStatic => {\n-                me.kind = \"restatic\";\n-            }\n-\n-            ty::RePlaceholder(_) => return None,\n-\n-            ty::ReError(_) => return None,\n-\n-            // FIXME(#13998) RePlaceholder should probably print like\n-            // ReFree rather than dumping Debug output on the user.\n-            //\n-            // We shouldn't really be having unification failures with ReVar\n-            // and ReLateBound though.\n-            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n-                me.kind = \"revar\";\n-                me.arg = format!(\"{:?}\", region);\n-            }\n-        };\n-        Some(me)\n-    }\n-\n-    fn from_early_bound_and_free_regions<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) -> Option<Self> {\n-        let mut me = DescriptionCtx::default();\n-        let scope = region.free_region_binding_scope(tcx).expect_local();\n-        match *region {\n+        let (span, kind, arg) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = tcx.def_span(scope);\n-                if let Some(param) =\n+                let scope = region.free_region_binding_scope(tcx).expect_local();\n+                let span = if let Some(param) =\n                     tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n                 {\n-                    sp = param.span;\n-                }\n-                if br.has_name() {\n-                    me.kind = \"as_defined\";\n-                    me.arg = br.name.to_string();\n+                    param.span\n                 } else {\n-                    me.kind = \"as_defined_anon\";\n+                    tcx.def_span(scope)\n                 };\n-                me.span = Some(sp)\n+                if br.has_name() {\n+                    (Some(span), \"as_defined\", br.name.to_string())\n+                } else {\n+                    (Some(span), \"as_defined_anon\", String::new())\n+                }\n             }\n             ty::ReFree(ref fr) => {\n                 if !fr.bound_region.is_named()\n                     && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n                 {\n-                    me.kind = \"defined_here\";\n-                    me.span = Some(ty.span);\n+                    (Some(ty.span), \"defined_here\", String::new())\n                 } else {\n+                    let scope = region.free_region_binding_scope(tcx).expect_local();\n                     match fr.bound_region {\n                         ty::BoundRegionKind::BrNamed(_, name) => {\n-                            let mut sp = tcx.def_span(scope);\n-                            if let Some(param) =\n-                                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                            let span = if let Some(param) = tcx\n+                                .hir()\n+                                .get_generics(scope)\n+                                .and_then(|generics| generics.get_named(name))\n                             {\n-                                sp = param.span;\n-                            }\n-                            if name == kw::UnderscoreLifetime {\n-                                me.kind = \"as_defined_anon\";\n+                                param.span\n                             } else {\n-                                me.kind = \"as_defined\";\n-                                me.arg = name.to_string();\n+                                tcx.def_span(scope)\n                             };\n-                            me.span = Some(sp);\n+                            if name == kw::UnderscoreLifetime {\n+                                (Some(span), \"as_defined_anon\", String::new())\n+                            } else {\n+                                (Some(span), \"as_defined\", name.to_string())\n+                            }\n                         }\n                         ty::BrAnon(span) => {\n-                            me.kind = \"defined_here\";\n-                            me.span = match span {\n+                            let span = match span {\n                                 Some(_) => span,\n                                 None => Some(tcx.def_span(scope)),\n-                            }\n-                        },\n+                            };\n+                            (span, \"defined_here\", String::new())\n+                        }\n                         _ => {\n-                            me.kind = \"defined_here_reg\";\n-                            me.arg = region.to_string();\n-                            me.span = Some(tcx.def_span(scope));\n-                        },\n+                            (Some(tcx.def_span(scope)), \"defined_here_reg\", region.to_string())\n+                        }\n                     }\n                 }\n             }\n-            _ => bug!(),\n-        }\n-        Some(me)\n-    }\n \n-    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n-        diag.set_arg(\"desc_kind\", self.kind);\n-        diag.set_arg(\"desc_arg\", self.arg);\n-        diag.set_arg(\"desc_num_arg\", self.num_arg);\n+            ty::ReStatic => (alt_span, \"restatic\", String::new()),\n+\n+            ty::RePlaceholder(_) | ty::ReError(_) => return None,\n+\n+            // FIXME(#13998) RePlaceholder should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+                (alt_span, \"revar\", format!(\"{:?}\", region))\n+            }\n+        };\n+        Some(DescriptionCtx { span, kind, arg })\n     }\n }\n \n@@ -198,10 +168,11 @@ impl AddToDiagnostic for RegionExplanation<'_> {\n     {\n         diag.set_arg(\"pref_kind\", self.prefix);\n         diag.set_arg(\"suff_kind\", self.suffix);\n-        let desc_span = self.desc.span;\n-        self.desc.add_to(diag);\n+        diag.set_arg(\"desc_kind\", self.desc.kind);\n+        diag.set_arg(\"desc_arg\", self.desc.arg);\n+\n         let msg = f(diag, fluent::infer_region_explanation.into());\n-        if let Some(span) = desc_span {\n+        if let Some(span) = self.desc.span {\n             diag.span_note(span, msg);\n         } else {\n             diag.note(msg);"}, {"sha": "b68ffaed69dab8f7325a85ae2e725bd372773f1f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 32, "deletions": 42, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -184,84 +184,74 @@ fn msg_span_from_named_region<'tcx>(\n     region: ty::Region<'tcx>,\n     alt_span: Option<Span>,\n ) -> (String, Option<Span>) {\n-    match *region {\n-        ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-            let (msg, span) = msg_span_from_early_bound_and_free_regions(tcx, region);\n-            (msg, Some(span))\n-        }\n-        ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrNamed(def_id, name), .. },\n-            ..\n-        }) => (format!(\"the lifetime `{name}` as defined here\"), Some(tcx.def_span(def_id))),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(Some(span)), .. },\n-            ..\n-        }) => (format!(\"the anonymous lifetime defined here\"), Some(span)),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(None), .. },\n-            ..\n-        }) => (format!(\"an anonymous lifetime\"), None),\n-        _ => bug!(\"{:?}\", region),\n-    }\n-}\n-\n-fn msg_span_from_early_bound_and_free_regions<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region: ty::Region<'tcx>,\n-) -> (String, Span) {\n-    let scope = region.free_region_binding_scope(tcx).expect_local();\n     match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = tcx.def_span(scope);\n-            if let Some(param) =\n+            let scope = region.free_region_binding_scope(tcx).expect_local();\n+            let span = if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n-                sp = param.span;\n-            }\n+                param.span\n+            } else {\n+                tcx.def_span(scope)\n+            };\n             let text = if br.has_name() {\n                 format!(\"the lifetime `{}` as defined here\", br.name)\n             } else {\n                 \"the anonymous lifetime as defined here\".to_string()\n             };\n-            (text, sp)\n+            (text, Some(span))\n         }\n         ty::ReFree(ref fr) => {\n             if !fr.bound_region.is_named()\n                 && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n             {\n-                (\"the anonymous lifetime defined here\".to_string(), ty.span)\n+                (\"the anonymous lifetime defined here\".to_string(), Some(ty.span))\n             } else {\n+                let scope = region.free_region_binding_scope(tcx).expect_local();\n                 match fr.bound_region {\n                     ty::BoundRegionKind::BrNamed(_, name) => {\n-                        let mut sp = tcx.def_span(scope);\n-                        if let Some(param) =\n+                        let span = if let Some(param) =\n                             tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n                         {\n-                            sp = param.span;\n-                        }\n+                            param.span\n+                        } else {\n+                            tcx.def_span(scope)\n+                        };\n                         let text = if name == kw::UnderscoreLifetime {\n                             \"the anonymous lifetime as defined here\".to_string()\n                         } else {\n                             format!(\"the lifetime `{}` as defined here\", name)\n                         };\n-                        (text, sp)\n+                        (text, Some(span))\n                     }\n                     ty::BrAnon(span) => (\n                         \"the anonymous lifetime as defined here\".to_string(),\n-                        match span {\n+                        Some(match span {\n                             Some(span) => span,\n                             None => tcx.def_span(scope)\n-                        }\n+                        })\n                     ),\n                     _ => (\n                         format!(\"the lifetime `{}` as defined here\", region),\n-                        tcx.def_span(scope),\n+                        Some(tcx.def_span(scope)),\n                     ),\n                 }\n             }\n         }\n-        _ => bug!(),\n+        ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrNamed(def_id, name), .. },\n+            ..\n+        }) => (format!(\"the lifetime `{name}` as defined here\"), Some(tcx.def_span(def_id))),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(Some(span)), .. },\n+            ..\n+        }) => (format!(\"the anonymous lifetime defined here\"), Some(span)),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(None), .. },\n+            ..\n+        }) => (format!(\"an anonymous lifetime\"), None),\n+        _ => bug!(\"{:?}\", region),\n     }\n }\n "}, {"sha": "931fe1b2433a0cb56efc6bebe1609cbde205117e", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -148,6 +148,11 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                     )),\n                 )\n             },\n+            @call(\"mir_offset\", args) => {\n+                let ptr = self.parse_operand(args[0])?;\n+                let offset = self.parse_operand(args[1])?;\n+                Ok(Rvalue::BinaryOp(BinOp::Offset, Box::new((ptr, offset))))\n+            },\n             @call(\"mir_len\", args) => Ok(Rvalue::Len(self.parse_place(args[0])?)),\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)"}, {"sha": "d9d62eb759e69ca984a384a4c10ee3d4f5a42f27", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -232,6 +232,7 @@\n //!  - `&`, `&mut`, `addr_of!`, and `addr_of_mut!` all work to create their associated rvalue.\n //!  - [`Discriminant`] and [`Len`] have associated functions.\n //!  - Unary and binary operations use their normal Rust syntax - `a * b`, `!c`, etc.\n+//!  - The binary operation `Offset` can be created via [`Offset`].\n //!  - Checked binary operations are represented by wrapping the associated binop in [`Checked`].\n //!  - Array repetition syntax (`[foo; 10]`) creates the associated rvalue.\n //!\n@@ -289,6 +290,7 @@ define!(\n     fn Discriminant<T>(place: T) -> <T as ::core::marker::DiscriminantKind>::Discriminant\n );\n define!(\"mir_set_discriminant\", fn SetDiscriminant<T>(place: T, index: u32));\n+define!(\"mir_offset\", fn Offset<T, U>(ptr: T, count: U) -> T);\n define!(\n     \"mir_field\",\n     /// Access the field with the given index of some place."}, {"sha": "d7d31d8724c6da3641fa231a21486f6cad6ec0cd", "filename": "src/doc/rustc/src/platform-support/loongarch-linux.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -6,12 +6,12 @@\n \n [LoongArch]: https://loongson.github.io/LoongArch-Documentation/README-EN.html\n \n-The target name follow this format: `<machine>-<vendor>-<os><fabi_suffix>, where `<machine>` specifies the CPU family/model, `<vendor>` specifies the vendor and `<os>` the operating system name.\n+The target name follow this format: `<machine>-<vendor>-<os><fabi_suffix>`, where `<machine>` specifies the CPU family/model, `<vendor>` specifies the vendor and `<os>` the operating system name.\n While the integer base ABI is\u00a0implied by the\u2002machine\u2002field, the floating point base ABI type is encoded into the os field of the specifier using the string suffix `<fabi-suffix>`.\n \n |    `<fabi-suffix>`     |                           `Description`                            |\n |------------------------|--------------------------------------------------------------------|\n-|          f64           | The base ABI use 64-bits FPRs for parameter passing.(lp64d)|\n+|          f64           | The base ABI use 64-bits FPRs for parameter passing. (lp64d)|\n |          f32           | The base ABI uses 32-bit FPRs for parameter passing. (lp64f)|\n |          sf            | The base ABI uses no FPR for parameter passing. (lp64s)     |\n \n@@ -26,9 +26,9 @@ While the integer base ABI is\u00a0implied by the\u2002machine\u2002field, the floating po\n \n ## Target maintainers\n \n-- [ZHAI xiaojuan](https://github.com/zhaixiaojuan) `zhaixiaojuan@loongson.cn`\n-- [WANG rui](https://github.com/heiher) `wangrui@loongson.cn`\n-- [ZHAI xiang](https://github.com/xiangzhai) `zhaixiang@loongson.cn`\n+- [ZHAI Xiaojuan](https://github.com/zhaixiaojuan) `zhaixiaojuan@loongson.cn`\n+- [WANG Rui](https://github.com/heiher) `wangrui@loongson.cn`\n+- [ZHAI Xiang](https://github.com/xiangzhai) `zhaixiang@loongson.cn`\n - [WANG Xuerui](https://github.com/xen0n) `git@xen0n.name`\n \n ## Requirements"}, {"sha": "97734f048ab33174492d2303bcebfc8d679032c6", "filename": "src/tools/rust-installer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/src%2Ftools%2Frust-installer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/src%2Ftools%2Frust-installer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2FCargo.toml?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -22,7 +22,3 @@ remove_dir_all = \"0.5\"\n [dependencies.clap]\n features = [\"derive\"]\n version = \"3.1\"\n-\n-[target.\"cfg(windows)\".dependencies]\n-lazy_static = \"1\"\n-winapi = { version = \"0.3\", features = [\"errhandlingapi\", \"handleapi\", \"ioapiset\", \"winerror\", \"winioctl\", \"winnt\"] }"}, {"sha": "11097652865c4221bbddffce70c35744c29fee0a", "filename": "src/tools/rust-installer/src/remove_dir_all.rs", "status": "removed", "additions": 0, "deletions": 860, "changes": 860, "blob_url": "https://github.com/rust-lang/rust/blob/661b33f5247debc4e0cd948caa388997e18e9cb8/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661b33f5247debc4e0cd948caa388997e18e9cb8/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs?ref=661b33f5247debc4e0cd948caa388997e18e9cb8", "patch": "@@ -1,860 +0,0 @@\n-#![allow(non_snake_case)]\n-\n-use std::io;\n-use std::path::Path;\n-\n-#[cfg(not(windows))]\n-pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    ::std::fs::remove_dir_all(path)\n-}\n-\n-#[cfg(windows)]\n-pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    win::remove_dir_all(path)\n-}\n-\n-#[cfg(windows)]\n-mod win {\n-    use winapi::ctypes::{c_uint, c_ushort};\n-    use winapi::shared::minwindef::{BOOL, DWORD, FALSE, FILETIME, LPVOID};\n-    use winapi::shared::winerror::{\n-        ERROR_CALL_NOT_IMPLEMENTED, ERROR_INSUFFICIENT_BUFFER, ERROR_NO_MORE_FILES,\n-    };\n-    use winapi::um::errhandlingapi::{GetLastError, SetLastError};\n-    use winapi::um::fileapi::{\n-        CreateFileW, FindFirstFileW, FindNextFileW, GetFileInformationByHandle,\n-    };\n-    use winapi::um::fileapi::{BY_HANDLE_FILE_INFORMATION, CREATE_ALWAYS, CREATE_NEW};\n-    use winapi::um::fileapi::{FILE_BASIC_INFO, FILE_RENAME_INFO, TRUNCATE_EXISTING};\n-    use winapi::um::fileapi::{OPEN_ALWAYS, OPEN_EXISTING};\n-    use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};\n-    use winapi::um::ioapiset::DeviceIoControl;\n-    use winapi::um::libloaderapi::{GetModuleHandleW, GetProcAddress};\n-    use winapi::um::minwinbase::{\n-        FileBasicInfo, FileRenameInfo, FILE_INFO_BY_HANDLE_CLASS, WIN32_FIND_DATAW,\n-    };\n-    use winapi::um::winbase::SECURITY_SQOS_PRESENT;\n-    use winapi::um::winbase::{\n-        FILE_FLAG_BACKUP_SEMANTICS, FILE_FLAG_DELETE_ON_CLOSE, FILE_FLAG_OPEN_REPARSE_POINT,\n-    };\n-    use winapi::um::winioctl::FSCTL_GET_REPARSE_POINT;\n-    use winapi::um::winnt::{DELETE, FILE_ATTRIBUTE_DIRECTORY, HANDLE, LPCWSTR};\n-    use winapi::um::winnt::{FILE_ATTRIBUTE_READONLY, FILE_ATTRIBUTE_REPARSE_POINT};\n-    use winapi::um::winnt::{FILE_GENERIC_WRITE, FILE_WRITE_DATA, GENERIC_READ, GENERIC_WRITE};\n-    use winapi::um::winnt::{FILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES};\n-    use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n-    use winapi::um::winnt::{IO_REPARSE_TAG_MOUNT_POINT, IO_REPARSE_TAG_SYMLINK, LARGE_INTEGER};\n-\n-    use std::ffi::{OsStr, OsString};\n-    use std::io;\n-    use std::mem;\n-    use std::os::windows::ffi::{OsStrExt, OsStringExt};\n-    use std::path::{Path, PathBuf};\n-    use std::ptr;\n-    use std::sync::Arc;\n-\n-    pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-        // On Windows it is not enough to just recursively remove the contents of a\n-        // directory and then the directory itself. Deleting does not happen\n-        // instantaneously, but is scheduled.\n-        // To work around this, we move the file or directory to some `base_dir`\n-        // right before deletion to avoid races.\n-        //\n-        // As `base_dir` we choose the parent dir of the directory we want to\n-        // remove. We very probably have permission to create files here, as we\n-        // already need write permission in this dir to delete the directory. And it\n-        // should be on the same volume.\n-        //\n-        // To handle files with names like `CON` and `morse .. .`, and when a\n-        // directory structure is so deep it needs long path names the path is first\n-        // converted to a `//?/`-path with `get_path()`.\n-        //\n-        // To make sure we don't leave a moved file laying around if the process\n-        // crashes before we can delete the file, we do all operations on an file\n-        // handle. By opening a file with `FILE_FLAG_DELETE_ON_CLOSE` Windows will\n-        // always delete the file when the handle closes.\n-        //\n-        // All files are renamed to be in the `base_dir`, and have their name\n-        // changed to \"rm-<counter>\". After every rename the counter is increased.\n-        // Rename should not overwrite possibly existing files in the base dir. So\n-        // if it fails with `AlreadyExists`, we just increase the counter and try\n-        // again.\n-        //\n-        // For read-only files and directories we first have to remove the read-only\n-        // attribute before we can move or delete them. This also removes the\n-        // attribute from possible hardlinks to the file, so just before closing we\n-        // restore the read-only attribute.\n-        //\n-        // If 'path' points to a directory symlink or junction we should not\n-        // recursively remove the target of the link, but only the link itself.\n-        //\n-        // Moving and deleting is guaranteed to succeed if we are able to open the\n-        // file with `DELETE` permission. If others have the file open we only have\n-        // `DELETE` permission if they have specified `FILE_SHARE_DELETE`. We can\n-        // also delete the file now, but it will not disappear until all others have\n-        // closed the file. But no-one can open the file after we have flagged it\n-        // for deletion.\n-\n-        // Open the path once to get the canonical path, file type and attributes.\n-        let (path, metadata) = {\n-            let mut opts = OpenOptions::new();\n-            opts.access_mode(FILE_READ_ATTRIBUTES);\n-            opts.custom_flags(FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT);\n-            let file = File::open(path, &opts)?;\n-            (get_path(&file)?, file.file_attr()?)\n-        };\n-\n-        let mut ctx = RmdirContext {\n-            base_dir: match path.parent() {\n-                Some(dir) => dir,\n-                None => {\n-                    return Err(io::Error::new(\n-                        io::ErrorKind::PermissionDenied,\n-                        \"can't delete root directory\",\n-                    ))\n-                }\n-            },\n-            readonly: metadata.perm().readonly(),\n-            counter: 0,\n-        };\n-\n-        let filetype = metadata.file_type();\n-        if filetype.is_dir() {\n-            remove_dir_all_recursive(path.as_ref(), &mut ctx)\n-        } else if filetype.is_symlink_dir() {\n-            remove_item(path.as_ref(), &mut ctx)\n-        } else {\n-            Err(io::Error::new(\n-                io::ErrorKind::PermissionDenied,\n-                \"Not a directory\",\n-            ))\n-        }\n-    }\n-\n-    fn readdir(p: &Path) -> io::Result<ReadDir> {\n-        let root = p.to_path_buf();\n-        let star = p.join(\"*\");\n-        let path = to_u16s(&star)?;\n-\n-        unsafe {\n-            let mut wfd = mem::zeroed();\n-            let find_handle = FindFirstFileW(path.as_ptr(), &mut wfd);\n-            if find_handle != INVALID_HANDLE_VALUE {\n-                Ok(ReadDir {\n-                    handle: FindNextFileHandle(find_handle),\n-                    root: Arc::new(root),\n-                    first: Some(wfd),\n-                })\n-            } else {\n-                Err(io::Error::last_os_error())\n-            }\n-        }\n-    }\n-\n-    struct RmdirContext<'a> {\n-        base_dir: &'a Path,\n-        readonly: bool,\n-        counter: u64,\n-    }\n-\n-    fn remove_dir_all_recursive(path: &Path, ctx: &mut RmdirContext) -> io::Result<()> {\n-        let dir_readonly = ctx.readonly;\n-        for child in readdir(path)? {\n-            let child = child?;\n-            let child_type = child.file_type()?;\n-            ctx.readonly = child.metadata()?.perm().readonly();\n-            if child_type.is_dir() {\n-                remove_dir_all_recursive(&child.path(), ctx)?;\n-            } else {\n-                remove_item(&child.path().as_ref(), ctx)?;\n-            }\n-        }\n-        ctx.readonly = dir_readonly;\n-        remove_item(path, ctx)\n-    }\n-\n-    fn remove_item(path: &Path, ctx: &mut RmdirContext) -> io::Result<()> {\n-        if !ctx.readonly {\n-            let mut opts = OpenOptions::new();\n-            opts.access_mode(DELETE);\n-            opts.custom_flags(\n-                FILE_FLAG_BACKUP_SEMANTICS | // delete directory\n-                              FILE_FLAG_OPEN_REPARSE_POINT | // delete symlink\n-                              FILE_FLAG_DELETE_ON_CLOSE,\n-            );\n-            let file = File::open(path, &opts)?;\n-            move_item(&file, ctx)\n-        } else {\n-            // remove read-only permision\n-            set_perm(&path, FilePermissions::new())?;\n-            // move and delete file, similar to !readonly.\n-            // only the access mode is different.\n-            let mut opts = OpenOptions::new();\n-            opts.access_mode(DELETE | FILE_WRITE_ATTRIBUTES);\n-            opts.custom_flags(\n-                FILE_FLAG_BACKUP_SEMANTICS\n-                    | FILE_FLAG_OPEN_REPARSE_POINT\n-                    | FILE_FLAG_DELETE_ON_CLOSE,\n-            );\n-            let file = File::open(path, &opts)?;\n-            move_item(&file, ctx)?;\n-            // restore read-only flag just in case there are other hard links\n-            let mut perm = FilePermissions::new();\n-            perm.set_readonly(true);\n-            let _ = file.set_perm(perm); // ignore if this fails\n-            Ok(())\n-        }\n-    }\n-\n-    macro_rules! compat_fn {\n-        ($module:ident: $(\n-            fn $symbol:ident($($argname:ident: $argtype:ty),*)\n-                             -> $rettype:ty {\n-                $($body:expr);*\n-            }\n-        )*) => ($(\n-            #[allow(unused_variables)]\n-            unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                use std::sync::atomic::{AtomicUsize, Ordering};\n-                use std::mem;\n-                use std::ffi::CString;\n-                type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n-\n-                lazy_static! { static ref PTR: AtomicUsize = AtomicUsize::new(0);}\n-\n-                fn lookup(module: &str, symbol: &str) -> Option<usize> {\n-                    let mut module: Vec<u16> = module.encode_utf16().collect();\n-                    module.push(0);\n-                    let symbol = CString::new(symbol).unwrap();\n-                    unsafe {\n-                        let handle = GetModuleHandleW(module.as_ptr());\n-                        match GetProcAddress(handle, symbol.as_ptr()) as usize {\n-                            0 => None,\n-                            n => Some(n),\n-                        }\n-                    }\n-                }\n-\n-                fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n-                              fallback: usize) -> usize {\n-                    let value = lookup(module, symbol).unwrap_or(fallback);\n-                    ptr.store(value, Ordering::SeqCst);\n-                    value\n-                }\n-\n-                fn load() -> usize {\n-                    store_func(&PTR, stringify!($module), stringify!($symbol), fallback as usize)\n-                }\n-                unsafe extern \"system\" fn fallback($($argname: $argtype),*)\n-                                                   -> $rettype {\n-                    $($body);*\n-                }\n-\n-                let addr = match PTR.load(Ordering::SeqCst) {\n-                    0 => load(),\n-                    n => n,\n-                };\n-                mem::transmute::<usize, F>(addr)($($argname),*)\n-            }\n-        )*)\n-    }\n-\n-    compat_fn! {\n-        kernel32:\n-        fn GetFinalPathNameByHandleW(_hFile: HANDLE,\n-                                     _lpszFilePath: LPCWSTR,\n-                                     _cchFilePath: DWORD,\n-                                     _dwFlags: DWORD) -> DWORD {\n-            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-        }\n-        fn SetFileInformationByHandle(_hFile: HANDLE,\n-                                      _FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n-                                      _lpFileInformation: LPVOID,\n-                                      _dwBufferSize: DWORD) -> BOOL {\n-            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-        }\n-    }\n-\n-    fn cvt(i: i32) -> io::Result<i32> {\n-        if i == 0 {\n-            Err(io::Error::last_os_error())\n-        } else {\n-            Ok(i)\n-        }\n-    }\n-\n-    fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n-        fn inner(s: &OsStr) -> io::Result<Vec<u16>> {\n-            let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n-            if maybe_result.iter().any(|&u| u == 0) {\n-                return Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"strings passed to WinAPI cannot contain NULs\",\n-                ));\n-            }\n-            maybe_result.push(0);\n-            Ok(maybe_result)\n-        }\n-        inner(s.as_ref())\n-    }\n-\n-    fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n-        match v.iter().position(|c| *c == 0) {\n-            // don't include the 0\n-            Some(i) => &v[..i],\n-            None => v,\n-        }\n-    }\n-\n-    fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n-    where\n-        F1: FnMut(*mut u16, DWORD) -> DWORD,\n-        F2: FnOnce(&[u16]) -> T,\n-    {\n-        // Start off with a stack buf but then spill over to the heap if we end up\n-        // needing more space.\n-        let mut stack_buf = [0u16; 512];\n-        let mut heap_buf = Vec::new();\n-        unsafe {\n-            let mut n = stack_buf.len();\n-            loop {\n-                let buf = if n <= stack_buf.len() {\n-                    &mut stack_buf[..]\n-                } else {\n-                    let extra = n - heap_buf.len();\n-                    heap_buf.reserve(extra);\n-                    heap_buf.set_len(n);\n-                    &mut heap_buf[..]\n-                };\n-\n-                // This function is typically called on windows API functions which\n-                // will return the correct length of the string, but these functions\n-                // also return the `0` on error. In some cases, however, the\n-                // returned \"correct length\" may actually be 0!\n-                //\n-                // To handle this case we call `SetLastError` to reset it to 0 and\n-                // then check it again if we get the \"0 error value\". If the \"last\n-                // error\" is still 0 then we interpret it as a 0 length buffer and\n-                // not an actual error.\n-                SetLastError(0);\n-                let k = match f1(buf.as_mut_ptr(), n as DWORD) {\n-                    0 if GetLastError() == 0 => 0,\n-                    0 => return Err(io::Error::last_os_error()),\n-                    n => n,\n-                } as usize;\n-                if k == n && GetLastError() == ERROR_INSUFFICIENT_BUFFER {\n-                    n *= 2;\n-                } else if k >= n {\n-                    n = k;\n-                } else {\n-                    return Ok(f2(&buf[..k]));\n-                }\n-            }\n-        }\n-    }\n-\n-    #[derive(Clone, PartialEq, Eq, Debug, Default)]\n-    struct FilePermissions {\n-        readonly: bool,\n-    }\n-\n-    impl FilePermissions {\n-        fn new() -> FilePermissions {\n-            Default::default()\n-        }\n-        fn readonly(&self) -> bool {\n-            self.readonly\n-        }\n-        fn set_readonly(&mut self, readonly: bool) {\n-            self.readonly = readonly\n-        }\n-    }\n-\n-    #[derive(Clone)]\n-    struct OpenOptions {\n-        // generic\n-        read: bool,\n-        write: bool,\n-        append: bool,\n-        truncate: bool,\n-        create: bool,\n-        create_new: bool,\n-        // system-specific\n-        custom_flags: u32,\n-        access_mode: Option<DWORD>,\n-        attributes: DWORD,\n-        share_mode: DWORD,\n-        security_qos_flags: DWORD,\n-        security_attributes: usize, // FIXME: should be a reference\n-    }\n-\n-    impl OpenOptions {\n-        fn new() -> OpenOptions {\n-            OpenOptions {\n-                // generic\n-                read: false,\n-                write: false,\n-                append: false,\n-                truncate: false,\n-                create: false,\n-                create_new: false,\n-                // system-specific\n-                custom_flags: 0,\n-                access_mode: None,\n-                share_mode: FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                attributes: 0,\n-                security_qos_flags: 0,\n-                security_attributes: 0,\n-            }\n-        }\n-        fn custom_flags(&mut self, flags: u32) {\n-            self.custom_flags = flags;\n-        }\n-        fn access_mode(&mut self, access_mode: u32) {\n-            self.access_mode = Some(access_mode);\n-        }\n-\n-        fn get_access_mode(&self) -> io::Result<DWORD> {\n-            const ERROR_INVALID_PARAMETER: i32 = 87;\n-\n-            match (self.read, self.write, self.append, self.access_mode) {\n-                (_, _, _, Some(mode)) => Ok(mode),\n-                (true, false, false, None) => Ok(GENERIC_READ),\n-                (false, true, false, None) => Ok(GENERIC_WRITE),\n-                (true, true, false, None) => Ok(GENERIC_READ | GENERIC_WRITE),\n-                (false, _, true, None) => Ok(FILE_GENERIC_WRITE & !FILE_WRITE_DATA),\n-                (true, _, true, None) => Ok(GENERIC_READ | (FILE_GENERIC_WRITE & !FILE_WRITE_DATA)),\n-                (false, false, false, None) => {\n-                    Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER))\n-                }\n-            }\n-        }\n-\n-        fn get_creation_mode(&self) -> io::Result<DWORD> {\n-            const ERROR_INVALID_PARAMETER: i32 = 87;\n-\n-            match (self.write, self.append) {\n-                (true, false) => {}\n-                (false, false) => {\n-                    if self.truncate || self.create || self.create_new {\n-                        return Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n-                    }\n-                }\n-                (_, true) => {\n-                    if self.truncate && !self.create_new {\n-                        return Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n-                    }\n-                }\n-            }\n-\n-            Ok(match (self.create, self.truncate, self.create_new) {\n-                (false, false, false) => OPEN_EXISTING,\n-                (true, false, false) => OPEN_ALWAYS,\n-                (false, true, false) => TRUNCATE_EXISTING,\n-                (true, true, false) => CREATE_ALWAYS,\n-                (_, _, true) => CREATE_NEW,\n-            })\n-        }\n-\n-        fn get_flags_and_attributes(&self) -> DWORD {\n-            self.custom_flags\n-                | self.attributes\n-                | self.security_qos_flags\n-                | if self.security_qos_flags != 0 {\n-                    SECURITY_SQOS_PRESENT\n-                } else {\n-                    0\n-                }\n-                | if self.create_new {\n-                    FILE_FLAG_OPEN_REPARSE_POINT\n-                } else {\n-                    0\n-                }\n-        }\n-    }\n-\n-    struct File {\n-        handle: Handle,\n-    }\n-\n-    impl File {\n-        fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-            let path = to_u16s(path)?;\n-            let handle = unsafe {\n-                CreateFileW(\n-                    path.as_ptr(),\n-                    opts.get_access_mode()?,\n-                    opts.share_mode,\n-                    opts.security_attributes as *mut _,\n-                    opts.get_creation_mode()?,\n-                    opts.get_flags_and_attributes(),\n-                    ptr::null_mut(),\n-                )\n-            };\n-            if handle == INVALID_HANDLE_VALUE {\n-                Err(io::Error::last_os_error())\n-            } else {\n-                Ok(File {\n-                    handle: Handle::new(handle),\n-                })\n-            }\n-        }\n-\n-        fn file_attr(&self) -> io::Result<FileAttr> {\n-            unsafe {\n-                let mut info: BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n-                cvt(GetFileInformationByHandle(self.handle.raw(), &mut info))?;\n-                let mut attr = FileAttr {\n-                    attributes: info.dwFileAttributes,\n-                    creation_time: info.ftCreationTime,\n-                    last_access_time: info.ftLastAccessTime,\n-                    last_write_time: info.ftLastWriteTime,\n-                    file_size: ((info.nFileSizeHigh as u64) << 32) | (info.nFileSizeLow as u64),\n-                    reparse_tag: 0,\n-                };\n-                if attr.is_reparse_point() {\n-                    let mut b = [0; MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-                    if let Ok((_, buf)) = self.reparse_point(&mut b) {\n-                        attr.reparse_tag = buf.ReparseTag;\n-                    }\n-                }\n-                Ok(attr)\n-            }\n-        }\n-\n-        fn set_attributes(&self, attr: DWORD) -> io::Result<()> {\n-            let zero: LARGE_INTEGER = unsafe { mem::zeroed() };\n-\n-            let mut info = FILE_BASIC_INFO {\n-                CreationTime: zero,   // do not change\n-                LastAccessTime: zero, // do not change\n-                LastWriteTime: zero,  // do not change\n-                ChangeTime: zero,     // do not change\n-                FileAttributes: attr,\n-            };\n-            let size = mem::size_of_val(&info);\n-            cvt(unsafe {\n-                SetFileInformationByHandle(\n-                    self.handle.raw(),\n-                    FileBasicInfo,\n-                    &mut info as *mut _ as *mut _,\n-                    size as DWORD,\n-                )\n-            })?;\n-            Ok(())\n-        }\n-\n-        fn rename(&self, new: &Path, replace: bool) -> io::Result<()> {\n-            // &self must be opened with DELETE permission\n-            use std::iter;\n-            #[cfg(target_arch = \"x86\")]\n-            const STRUCT_SIZE: usize = 12;\n-            #[cfg(target_arch = \"x86_64\")]\n-            const STRUCT_SIZE: usize = 20;\n-\n-            // FIXME: check for internal NULs in 'new'\n-            let mut data: Vec<u16> = iter::repeat(0u16)\n-                .take(STRUCT_SIZE / 2)\n-                .chain(new.as_os_str().encode_wide())\n-                .collect();\n-            data.push(0);\n-            let size = data.len() * 2;\n-\n-            unsafe {\n-                // Thanks to alignment guarantees on Windows this works\n-                // (8 for 32-bit and 16 for 64-bit)\n-                let info = data.as_mut_ptr() as *mut FILE_RENAME_INFO;\n-                // The type of ReplaceIfExists is BOOL, but it actually expects a\n-                // BOOLEAN. This means true is -1, not c::TRUE.\n-                (*info).ReplaceIfExists = if replace { -1 } else { FALSE };\n-                (*info).RootDirectory = ptr::null_mut();\n-                (*info).FileNameLength = (size - STRUCT_SIZE) as DWORD;\n-                cvt(SetFileInformationByHandle(\n-                    self.handle().raw(),\n-                    FileRenameInfo,\n-                    data.as_mut_ptr() as *mut _ as *mut _,\n-                    size as DWORD,\n-                ))?;\n-                Ok(())\n-            }\n-        }\n-        fn set_perm(&self, perm: FilePermissions) -> io::Result<()> {\n-            let attr = self.file_attr()?.attributes;\n-            if perm.readonly == (attr & FILE_ATTRIBUTE_READONLY != 0) {\n-                Ok(())\n-            } else if perm.readonly {\n-                self.set_attributes(attr | FILE_ATTRIBUTE_READONLY)\n-            } else {\n-                self.set_attributes(attr & !FILE_ATTRIBUTE_READONLY)\n-            }\n-        }\n-\n-        fn handle(&self) -> &Handle {\n-            &self.handle\n-        }\n-\n-        fn reparse_point<'a>(\n-            &self,\n-            space: &'a mut [u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n-        ) -> io::Result<(DWORD, &'a REPARSE_DATA_BUFFER)> {\n-            unsafe {\n-                let mut bytes = 0;\n-                cvt({\n-                    DeviceIoControl(\n-                        self.handle.raw(),\n-                        FSCTL_GET_REPARSE_POINT,\n-                        ptr::null_mut(),\n-                        0,\n-                        space.as_mut_ptr() as *mut _,\n-                        space.len() as DWORD,\n-                        &mut bytes,\n-                        ptr::null_mut(),\n-                    )\n-                })?;\n-                Ok((bytes, &*(space.as_ptr() as *const REPARSE_DATA_BUFFER)))\n-            }\n-        }\n-    }\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-    enum FileType {\n-        Dir,\n-        File,\n-        SymlinkFile,\n-        SymlinkDir,\n-        ReparsePoint,\n-        MountPoint,\n-    }\n-\n-    impl FileType {\n-        fn new(attrs: DWORD, reparse_tag: DWORD) -> FileType {\n-            match (\n-                attrs & FILE_ATTRIBUTE_DIRECTORY != 0,\n-                attrs & FILE_ATTRIBUTE_REPARSE_POINT != 0,\n-                reparse_tag,\n-            ) {\n-                (false, false, _) => FileType::File,\n-                (true, false, _) => FileType::Dir,\n-                (false, true, IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkFile,\n-                (true, true, IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkDir,\n-                (true, true, IO_REPARSE_TAG_MOUNT_POINT) => FileType::MountPoint,\n-                (_, true, _) => FileType::ReparsePoint,\n-                // Note: if a _file_ has a reparse tag of the type IO_REPARSE_TAG_MOUNT_POINT it is\n-                // invalid, as junctions always have to be dirs. We set the filetype to ReparsePoint\n-                // to indicate it is something symlink-like, but not something you can follow.\n-            }\n-        }\n-\n-        fn is_dir(&self) -> bool {\n-            *self == FileType::Dir\n-        }\n-        fn is_symlink_dir(&self) -> bool {\n-            *self == FileType::SymlinkDir || *self == FileType::MountPoint\n-        }\n-    }\n-\n-    impl DirEntry {\n-        fn new(root: &Arc<PathBuf>, wfd: &WIN32_FIND_DATAW) -> Option<DirEntry> {\n-            let first_bytes = &wfd.cFileName[0..3];\n-            if first_bytes.starts_with(&[46, 0]) || first_bytes.starts_with(&[46, 46, 0]) {\n-                None\n-            } else {\n-                Some(DirEntry {\n-                    root: root.clone(),\n-                    data: *wfd,\n-                })\n-            }\n-        }\n-\n-        fn path(&self) -> PathBuf {\n-            self.root.join(&self.file_name())\n-        }\n-\n-        fn file_name(&self) -> OsString {\n-            let filename = truncate_utf16_at_nul(&self.data.cFileName);\n-            OsString::from_wide(filename)\n-        }\n-\n-        fn file_type(&self) -> io::Result<FileType> {\n-            Ok(FileType::new(\n-                self.data.dwFileAttributes,\n-                /* reparse_tag = */ self.data.dwReserved0,\n-            ))\n-        }\n-\n-        fn metadata(&self) -> io::Result<FileAttr> {\n-            Ok(FileAttr {\n-                attributes: self.data.dwFileAttributes,\n-                creation_time: self.data.ftCreationTime,\n-                last_access_time: self.data.ftLastAccessTime,\n-                last_write_time: self.data.ftLastWriteTime,\n-                file_size: ((self.data.nFileSizeHigh as u64) << 32)\n-                    | (self.data.nFileSizeLow as u64),\n-                reparse_tag: if self.data.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                    // reserved unless this is a reparse point\n-                    self.data.dwReserved0\n-                } else {\n-                    0\n-                },\n-            })\n-        }\n-    }\n-\n-    struct DirEntry {\n-        root: Arc<PathBuf>,\n-        data: WIN32_FIND_DATAW,\n-    }\n-\n-    struct ReadDir {\n-        handle: FindNextFileHandle,\n-        root: Arc<PathBuf>,\n-        first: Option<WIN32_FIND_DATAW>,\n-    }\n-\n-    impl Iterator for ReadDir {\n-        type Item = io::Result<DirEntry>;\n-        fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-            if let Some(first) = self.first.take() {\n-                if let Some(e) = DirEntry::new(&self.root, &first) {\n-                    return Some(Ok(e));\n-                }\n-            }\n-            unsafe {\n-                let mut wfd = mem::zeroed();\n-                loop {\n-                    if FindNextFileW(self.handle.0, &mut wfd) == 0 {\n-                        if GetLastError() == ERROR_NO_MORE_FILES {\n-                            return None;\n-                        } else {\n-                            return Some(Err(io::Error::last_os_error()));\n-                        }\n-                    }\n-                    if let Some(e) = DirEntry::new(&self.root, &wfd) {\n-                        return Some(Ok(e));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[derive(Clone)]\n-    struct FileAttr {\n-        attributes: DWORD,\n-        creation_time: FILETIME,\n-        last_access_time: FILETIME,\n-        last_write_time: FILETIME,\n-        file_size: u64,\n-        reparse_tag: DWORD,\n-    }\n-\n-    impl FileAttr {\n-        fn perm(&self) -> FilePermissions {\n-            FilePermissions {\n-                readonly: self.attributes & FILE_ATTRIBUTE_READONLY != 0,\n-            }\n-        }\n-\n-        fn file_type(&self) -> FileType {\n-            FileType::new(self.attributes, self.reparse_tag)\n-        }\n-\n-        fn is_reparse_point(&self) -> bool {\n-            self.attributes & FILE_ATTRIBUTE_REPARSE_POINT != 0\n-        }\n-    }\n-\n-    #[repr(C)]\n-    struct REPARSE_DATA_BUFFER {\n-        ReparseTag: c_uint,\n-        ReparseDataLength: c_ushort,\n-        Reserved: c_ushort,\n-        rest: (),\n-    }\n-\n-    const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n-\n-    /// An owned container for `HANDLE` object, closing them on Drop.\n-    ///\n-    /// All methods are inherited through a `Deref` impl to `RawHandle`\n-    struct Handle(RawHandle);\n-\n-    use std::ops::Deref;\n-\n-    /// A wrapper type for `HANDLE` objects to give them proper Send/Sync inference\n-    /// as well as Rust-y methods.\n-    ///\n-    /// This does **not** drop the handle when it goes out of scope, use `Handle`\n-    /// instead for that.\n-    #[derive(Copy, Clone)]\n-    struct RawHandle(HANDLE);\n-\n-    unsafe impl Send for RawHandle {}\n-    unsafe impl Sync for RawHandle {}\n-\n-    impl Handle {\n-        fn new(handle: HANDLE) -> Handle {\n-            Handle(RawHandle::new(handle))\n-        }\n-    }\n-\n-    impl Deref for Handle {\n-        type Target = RawHandle;\n-        fn deref(&self) -> &RawHandle {\n-            &self.0\n-        }\n-    }\n-\n-    impl Drop for Handle {\n-        fn drop(&mut self) {\n-            unsafe {\n-                let _ = CloseHandle(self.raw());\n-            }\n-        }\n-    }\n-\n-    impl RawHandle {\n-        fn new(handle: HANDLE) -> RawHandle {\n-            RawHandle(handle)\n-        }\n-\n-        fn raw(&self) -> HANDLE {\n-            self.0\n-        }\n-    }\n-\n-    struct FindNextFileHandle(HANDLE);\n-\n-    fn get_path(f: &File) -> io::Result<PathBuf> {\n-        fill_utf16_buf(\n-            |buf, sz| unsafe {\n-                GetFinalPathNameByHandleW(f.handle.raw(), buf, sz, VOLUME_NAME_DOS)\n-            },\n-            |buf| PathBuf::from(OsString::from_wide(buf)),\n-        )\n-    }\n-\n-    fn move_item(file: &File, ctx: &mut RmdirContext) -> io::Result<()> {\n-        let mut tmpname = ctx.base_dir.join(format! {\"rm-{}\", ctx.counter});\n-        ctx.counter += 1;\n-        // Try to rename the file. If it already exists, just retry with an other\n-        // filename.\n-        while let Err(err) = file.rename(tmpname.as_ref(), false) {\n-            if err.kind() != io::ErrorKind::AlreadyExists {\n-                return Err(err);\n-            };\n-            tmpname = ctx.base_dir.join(format!(\"rm-{}\", ctx.counter));\n-            ctx.counter += 1;\n-        }\n-        Ok(())\n-    }\n-\n-    fn set_perm(path: &Path, perm: FilePermissions) -> io::Result<()> {\n-        let mut opts = OpenOptions::new();\n-        opts.access_mode(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES);\n-        opts.custom_flags(FILE_FLAG_BACKUP_SEMANTICS);\n-        let file = File::open(path, &opts)?;\n-        file.set_perm(perm)\n-    }\n-\n-    const VOLUME_NAME_DOS: DWORD = 0x0;\n-}"}, {"sha": "f614aef4029d0127d091b66a6a2027929007339a", "filename": "tests/mir-opt/building/custom/references.raw_pointer_offset.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.raw_pointer_offset.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.raw_pointer_offset.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.raw_pointer_offset.built.after.mir?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `raw_pointer_offset` after built\n+\n+fn raw_pointer_offset(_1: *const i32) -> *const i32 {\n+    let mut _0: *const i32;              // return place in scope 0 at $DIR/references.rs:+0:45: +0:55\n+\n+    bb0: {\n+        _0 = Offset(_1, const 1_isize);  // scope 0 at $DIR/references.rs:+2:9: +2:33\n+        return;                          // scope 0 at $DIR/references.rs:+3:9: +3:17\n+    }\n+}"}, {"sha": "f87f6664c7a5c55b86fa488c7f6092de604b84f3", "filename": "tests/mir-opt/building/custom/references.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -45,11 +45,22 @@ pub fn raw_pointer(x: *const i32) -> *const i32 {\n     })\n }\n \n+// EMIT_MIR references.raw_pointer_offset.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+pub fn raw_pointer_offset(x: *const i32) -> *const i32 {\n+    mir!({\n+        RET = Offset(x, 1_isize);\n+        Return()\n+    })\n+}\n+\n fn main() {\n     let mut x = 5;\n+    let arr = [1, 2];\n     assert_eq!(*mut_ref(&mut x), 5);\n     assert_eq!(*immut_ref(&x), 5);\n     unsafe {\n         assert_eq!(*raw_pointer(addr_of!(x)), 5);\n+        assert_eq!(*raw_pointer_offset(addr_of!(arr[0])), 2);\n     }\n }"}, {"sha": "966d6412870b682b3a2416930aeea0e0f8e7ce2d", "filename": "tests/ui/lint/dead-code/issue-59003.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/tests%2Fui%2Flint%2Fdead-code%2Fissue-59003.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/tests%2Fui%2Flint%2Fdead-code%2Fissue-59003.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Fissue-59003.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+// Make sure we don't have any false positives about the \"struct is never constructed\" lint.\n+\n+#![deny(dead_code)]\n+\n+struct Foo {\n+    #[allow(dead_code)]\n+    inner: u32,\n+}\n+\n+impl From<u32> for Foo {\n+    fn from(inner: u32) -> Self {\n+        Self { inner }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "eaaf7eb3ecd09bd5b2c48c616587e46efe738807", "filename": "tests/ui/mir/validate/transmute_cast_sized.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59a05ad118a5d85dd8998babbe5bcd3163303a43/tests%2Fui%2Fmir%2Fvalidate%2Ftransmute_cast_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a05ad118a5d85dd8998babbe5bcd3163303a43/tests%2Fui%2Fmir%2Fvalidate%2Ftransmute_cast_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fvalidate%2Ftransmute_cast_sized.rs?ref=59a05ad118a5d85dd8998babbe5bcd3163303a43", "patch": "@@ -0,0 +1,17 @@\n+// build-pass\n+// compile-flags: -Zvalidate-mir\n+// edition: 2021\n+\n+#![crate_type = \"lib\"]\n+\n+// Use `PhantomData` to get target-independent size\n+async fn get(_r: std::marker::PhantomData<&i32>) {\n+    loop {}\n+}\n+\n+pub fn check() {\n+    let mut v = get(loop {});\n+    let _ = || unsafe {\n+        v = std::mem::transmute([0_u8; 1]);\n+    };\n+}"}]}