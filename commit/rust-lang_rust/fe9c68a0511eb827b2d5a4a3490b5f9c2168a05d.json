{"sha": "fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOWM2OGEwNTExZWI4MjdiMmQ1YTRhMzQ5MGI1ZjljMjE2OGEwNWQ=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-08-05T22:39:43Z"}, "committer": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-08-17T09:36:32Z"}, "message": "Adding E0623 for structs", "tree": {"sha": "4e75eeea06e514e3fc01264e3f7dba345b4db860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e75eeea06e514e3fc01264e3f7dba345b4db860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "html_url": "https://github.com/rust-lang/rust/commit/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3245948445b77c25cd9f3b29cbad3187aee3eb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3245948445b77c25cd9f3b29cbad3187aee3eb7", "html_url": "https://github.com/rust-lang/rust/commit/e3245948445b77c25cd9f3b29cbad3187aee3eb7"}], "stats": {"total": 798, "additions": 621, "deletions": 177}, "files": [{"sha": "3821bf766b960e3339287b9a178d969309cf3182", "filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs", "status": "modified", "additions": 168, "deletions": 54, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -27,65 +27,83 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     //    { x.push(y); }.\n     // The example gives\n     // fn foo(x: &mut Vec<&u8>, y: &u8) {\n-    //                    ---      --- these references must have the same lifetime\n+    //                    ---      --- these references are declared with different lifetimes...\n     //            x.push(y);\n-    //            ^ data from `y` flows into `x` here\n-    // It will later be extended to trait objects and structs.\n+    //            ^ ...but data from `y` flows into `x` here\n+    // It has been extended for the case of structs too.\n+    // Consider the example\n+    // struct Ref<'a> { x: &'a u32 }\n+    // fn foo(mut x: Vec<Ref>, y: Ref) {\n+    //                   ---      --- these structs are declared with different lifetimes...\n+    //               x.push(y);\n+    //               ^ ...but data from `y` flows into `x` here\n+    // }\n+    // It will later be extended to trait objects.\n     pub fn try_report_anon_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-\n         let (span, sub, sup) = match *error {\n             ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n             _ => return false, // inapplicable\n         };\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let (ty1, ty2) = if self.is_suitable_anonymous_region(sup).is_some() &&\n-                            self.is_suitable_anonymous_region(sub).is_some() {\n-            if let (Some(anon_reg1), Some(anon_reg2)) =\n-                (self.is_suitable_anonymous_region(sup), self.is_suitable_anonymous_region(sub)) {\n-                let ((_, br1), (_, br2)) = (anon_reg1, anon_reg2);\n-                if self.find_anon_type(sup, &br1).is_some() &&\n-                   self.find_anon_type(sub, &br2).is_some() {\n-                    (self.find_anon_type(sup, &br1).unwrap(),\n-                     self.find_anon_type(sub, &br2).unwrap())\n+        let (ty_sup, ty_sub, scope_def_id_sup, scope_def_id_sub, bregion_sup, bregion_sub) =\n+            if let (Some(anon_reg_sup), Some(anon_reg_sub)) =\n+                (self.is_suitable_anonymous_region(sup, true),\n+                 self.is_suitable_anonymous_region(sub, true)) {\n+                let ((def_id_sup, br_sup), (def_id_sub, br_sub)) = (anon_reg_sup, anon_reg_sub);\n+                if let (Some(anonarg_sup), Some(anonarg_sub)) =\n+                    (self.find_anon_type(sup, &br_sup), self.find_anon_type(sub, &br_sub)) {\n+                    (anonarg_sup, anonarg_sub, def_id_sup, def_id_sub, br_sup, br_sub)\n                 } else {\n                     return false;\n                 }\n             } else {\n                 return false;\n-            }\n-        } else {\n-            return false; // inapplicable\n-        };\n+            };\n \n-        if let (Some(sup_arg), Some(sub_arg)) =\n+        let (label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n             (self.find_arg_with_anonymous_region(sup, sup),\n              self.find_arg_with_anonymous_region(sub, sub)) {\n-            let ((anon_arg1, _, _, _), (anon_arg2, _, _, _)) = (sup_arg, sub_arg);\n \n-            let span_label_var1 = if let Some(simple_name) = anon_arg1.pat.simple_name() {\n-                format!(\" from `{}` \", simple_name)\n-            } else {\n-                format!(\" \")\n-            };\n+            let ((anon_arg_sup, _, _, is_first_sup), (anon_arg_sub, _, _, is_first_sub)) =\n+                (sup_arg, sub_arg);\n+            if self.is_self_anon(is_first_sup, scope_def_id_sup) ||\n+               self.is_self_anon(is_first_sub, scope_def_id_sub) {\n+                return false;\n+            }\n+\n+            if self.is_return_type_anon(scope_def_id_sup, bregion_sup) ||\n+               self.is_return_type_anon(scope_def_id_sub, bregion_sub) {\n+                return false;\n+            }\n \n-            let span_label_var2 = if let Some(simple_name) = anon_arg2.pat.simple_name() {\n-                format!(\" into `{}` \", simple_name)\n+            if anon_arg_sup == anon_arg_sub {\n+                (format!(\" with one lifetime\"), format!(\" into the other\"))\n             } else {\n-                format!(\" \")\n-            };\n+                let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n+                    format!(\" from `{}`\", simple_name)\n+                } else {\n+                    format!(\"\")\n+                };\n+\n+                let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n+                    format!(\" into `{}`\", simple_name)\n+                } else {\n+                    format!(\"\")\n+                };\n \n-            struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-                .span_label(ty1.span,\n-                            format!(\"these references are not declared with the same lifetime...\"))\n-                .span_label(ty2.span, format!(\"\"))\n-                .span_label(span,\n-                            format!(\"...but data{}flows{}here\", span_label_var1, span_label_var2))\n-                .emit();\n+                (span_label_var1, span_label_var2)\n+            }\n         } else {\n             return false;\n-        }\n+        };\n \n+        struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n+            .span_label(ty_sup.span,\n+                        format!(\"these two types are declared with different lifetimes...\"))\n+            .span_label(ty_sub.span, format!(\"\"))\n+            .span_label(span, format!(\"...but data{} flows{} here\", label1, label2))\n+            .emit();\n         return true;\n     }\n \n@@ -94,7 +112,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// contains the anonymous type.\n     ///\n     /// # Arguments\n-    ///\n     /// region - the anonymous region corresponding to the anon_anon conflict\n     /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n     ///\n@@ -105,8 +122,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n-    fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n-        if let Some(anon_reg) = self.is_suitable_anonymous_region(region) {\n+    pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n+        if let Some(anon_reg) = self.is_suitable_anonymous_region(region, true) {\n             let (def_id, _) = anon_reg;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let ret_ty = self.tcx.type_of(def_id);\n@@ -117,19 +134,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        .inputs\n                                        .iter()\n                                        .filter_map(|arg| {\n-                                let mut nested_visitor = FindNestedTypeVisitor {\n-                                    infcx: &self,\n-                                    hir_map: &self.tcx.hir,\n-                                    bound_region: *br,\n-                                    found_type: None,\n-                                };\n-                                nested_visitor.visit_ty(&**arg);\n-                                if nested_visitor.found_type.is_some() {\n-                                    nested_visitor.found_type\n-                                } else {\n-                                    None\n-                                }\n-                            })\n+                                                       self.find_component_for_bound_region(&**arg,\n+                                                                                            br)\n+                                                   })\n+                                       .next();\n+                        }\n+                    } else if let hir_map::NodeTraitItem(it) = self.tcx.hir.get(node_id) {\n+                        if let hir::TraitItemKind::Method(ref fndecl, _) = it.node {\n+                            return fndecl\n+                                       .decl\n+                                       .inputs\n+                                       .iter()\n+                                       .filter_map(|arg| {\n+                                                       self.find_component_for_bound_region(&**arg,\n+                                                                                            br)\n+                                                   })\n+                                       .next();\n+                        }\n+                    } else if let hir_map::NodeImplItem(it) = self.tcx.hir.get(node_id) {\n+                        if let hir::ImplItemKind::Method(ref fndecl, _) = it.node {\n+                            return fndecl\n+                                       .decl\n+                                       .inputs\n+                                       .iter()\n+                                       .filter_map(|arg| {\n+                                                       self.find_component_for_bound_region(&**arg,\n+                                                                                            br)\n+                                                   })\n                                        .next();\n                         }\n                     }\n@@ -138,6 +169,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n         None\n     }\n+\n+    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n+    // to the anonymous region.\n+    fn find_component_for_bound_region(&self,\n+                                       arg: &'gcx hir::Ty,\n+                                       br: &ty::BoundRegion)\n+                                       -> Option<(&'gcx hir::Ty)> {\n+        let mut nested_visitor = FindNestedTypeVisitor {\n+            infcx: &self,\n+            hir_map: &self.tcx.hir,\n+            bound_region: *br,\n+            found_type: None,\n+        };\n+        nested_visitor.visit_ty(arg);\n+        nested_visitor.found_type\n+    }\n }\n \n // The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the\n@@ -176,8 +223,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n             hir::TyRptr(ref lifetime, _) => {\n                 match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n                     // the lifetime of the TyRptr\n-                    Some(&rl::Region::LateBoundAnon(debuijn_index, anon_index)) => {\n-                        if debuijn_index.depth == 1 && anon_index == br_index {\n+                    Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+                        if debruijn_index.depth == 1 && anon_index == br_index {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n                         }\n@@ -191,10 +238,77 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n+            hir::TyPath(_) => {\n+                let subvisitor = &mut TyPathVisitor {\n+                                          infcx: self.infcx,\n+                                          found_it: false,\n+                                          bound_region: self.bound_region,\n+                                          hir_map: self.hir_map,\n+                                      };\n+                intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n+                // this will visit only outermost type\n+                if subvisitor.found_it {\n+                    self.found_type = Some(arg);\n+                }\n+            }\n             _ => {}\n         }\n         // walk the embedded contents: e.g., if we are visiting `Vec<&Foo>`,\n         // go on to visit `&Foo`\n         intravisit::walk_ty(self, arg);\n     }\n }\n+\n+// The visitor captures the corresponding `hir::Ty` of the anonymous region\n+// in the case of structs ie. `hir::TyPath`.\n+// This visitor would be invoked for each lifetime corresponding to a struct,\n+// and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n+// where that lifetime appears. This allows us to highlight the\n+// specific part of the type in the error message.\n+struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    hir_map: &'a hir::map::Map<'gcx>,\n+    found_it: bool,\n+    bound_region: ty::BoundRegion,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n+        let br_index = match self.bound_region {\n+            ty::BrAnon(index) => index,\n+            _ => return,\n+        };\n+\n+        match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n+            // the lifetime of the TyPath!\n+            Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+                if debruijn_index.depth == 1 && anon_index == br_index {\n+                    self.found_it = true;\n+                }\n+            }\n+            Some(&rl::Region::Static) |\n+            Some(&rl::Region::EarlyBound(_, _)) |\n+            Some(&rl::Region::LateBound(_, _)) |\n+            Some(&rl::Region::Free(_, _)) |\n+            None => {\n+                debug!(\"no arg found\");\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+        // ignore nested types\n+        //\n+        // If you have a type like `Foo<'a, &Ty>` we\n+        // are only interested in the immediate lifetimes ('a).\n+        //\n+        // Making `visit_ty` empty will ignore the `&Ty` embedded\n+        // inside, it will get reached by the outer visitor.\n+        debug!(\"`Ty` corresponding to a struct is {:?}\", arg);\n+    }\n+}"}, {"sha": "f46855502ea41849c5930bdfbfe296b9ec2704b9", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 31, "deletions": 53, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -11,7 +11,6 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n use infer::InferCtxt;\n-use ty;\n use infer::region_inference::RegionResolutionError::*;\n use infer::region_inference::RegionResolutionError;\n \n@@ -31,63 +30,42 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.\n-        let (named, (arg, new_ty, br, is_first), (scope_def_id, _)) =\n-            if sub.is_named_region() && self.is_suitable_anonymous_region(sup).is_some() {\n-                (sub,\n-                 self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n-                 self.is_suitable_anonymous_region(sup).unwrap())\n-            } else if sup.is_named_region() && self.is_suitable_anonymous_region(sub).is_some() {\n-                (sup,\n-                 self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n-                 self.is_suitable_anonymous_region(sub).unwrap())\n-            } else {\n-                return false; // inapplicable\n-            };\n-\n-        // Here, we check for the case where the anonymous region\n-        // is in the return type.\n-        // FIXME(#42703) - Need to handle certain cases here.\n-        let ret_ty = self.tcx.type_of(scope_def_id);\n-        match ret_ty.sty {\n-            ty::TyFnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(self.tcx);\n-                let late_bound_regions = self.tcx\n-                    .collect_referenced_late_bound_regions(&sig.output());\n-                if late_bound_regions.iter().any(|r| *r == br) {\n-                    return false;\n-                }\n-            }\n-            _ => {}\n-        }\n+        let (named, (arg, new_ty, br, is_first), (scope_def_id, _)) = if\n+            sub.is_named_region() && self.is_suitable_anonymous_region(sup, false).is_some() {\n+            (sub,\n+             self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n+             self.is_suitable_anonymous_region(sup, false).unwrap())\n+        } else if\n+            sup.is_named_region() && self.is_suitable_anonymous_region(sub, false).is_some() {\n+            (sup,\n+             self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n+             self.is_suitable_anonymous_region(sub, false).unwrap())\n+        } else {\n+            return false; // inapplicable\n+        };\n \n-        // Here we check for the case where anonymous region\n-        // corresponds to self and if yes, we display E0312.\n-        // FIXME(#42700) - Need to format self properly to\n-        // enable E0621 for it.\n-        if is_first &&\n-           self.tcx\n-               .opt_associated_item(scope_def_id)\n-               .map(|i| i.method_has_self_argument)\n-               .unwrap_or(false) {\n+        if self.is_return_type_anon(scope_def_id, br) || self.is_self_anon(is_first, scope_def_id) {\n             return false;\n-        }\n-\n-        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n-            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n         } else {\n-            (\"parameter type\".to_owned(), \"type\".to_owned())\n-        };\n \n-        struct_span_err!(self.tcx.sess,\n-                         span,\n-                         E0621,\n-                         \"explicit lifetime required in {}\",\n-                         error_var)\n-                .span_label(arg.pat.span,\n-                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n-                .span_label(span, format!(\"lifetime `{}` required\", named))\n-                .emit();\n+            let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+                (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n+            } else {\n+                (\"parameter type\".to_owned(), \"type\".to_owned())\n+            };\n \n+            struct_span_err!(self.tcx.sess,\n+                             span,\n+                             E0621,\n+                             \"explicit lifetime required in {}\",\n+                             error_var)\n+                    .span_label(arg.pat.span,\n+                                format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n+                    .span_label(span, format!(\"lifetime `{}` required\", named))\n+                    .emit();\n+\n+\n+        }\n         return true;\n     }\n }"}, {"sha": "21a6e8e050a13ea624934e2633b794859af7ae7e", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 56, "deletions": 17, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -79,22 +79,26 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     // This method returns whether the given Region is Anonymous\n     // and returns the DefId and the BoundRegion corresponding to the given region.\n+    // The is_anon_anon is set true when we are dealing with cases where\n+    // both the regions are anonymous i.e. E0623.\n     pub fn is_suitable_anonymous_region(&self,\n-                                        region: Region<'tcx>)\n+                                        region: Region<'tcx>,\n+                                        is_anon_anon: bool)\n                                         -> Option<(DefId, ty::BoundRegion)> {\n         if let ty::ReFree(ref free_region) = *region {\n-            if let ty::BrAnon(..) = free_region.bound_region{\n-                    let anonymous_region_binding_scope = free_region.scope;\n-                    let node_id = self.tcx\n-                        .hir\n-                        .as_local_node_id(anonymous_region_binding_scope)\n-                        .unwrap();\n-                    match self.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeItem(..)) |\n-                        Some(hir_map::NodeTraitItem(..)) => {\n-                            // Success -- proceed to return Some below\n-                        }\n-                        Some(hir_map::NodeImplItem(..)) => {\n+            if let ty::BrAnon(..) = free_region.bound_region {\n+                let anonymous_region_binding_scope = free_region.scope;\n+                let node_id = self.tcx\n+                    .hir\n+                    .as_local_node_id(anonymous_region_binding_scope)\n+                    .unwrap();\n+                match self.tcx.hir.find(node_id) {\n+                    Some(hir_map::NodeItem(..)) |\n+                    Some(hir_map::NodeTraitItem(..)) => {\n+                        // Success -- proceed to return Some below\n+                    }\n+                    Some(hir_map::NodeImplItem(..)) => {\n+                        if !is_anon_anon {\n                             let container_id = self.tcx\n                                 .associated_item(anonymous_region_binding_scope)\n                                 .container\n@@ -108,13 +112,48 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 // FIXME(#42706) -- in some cases, we could do better here.\n                                 return None;\n                             }\n+                        } else {\n                         }\n-                        _ => return None, // inapplicable\n-                        // we target only top-level functions\n                     }\n-                    return Some((anonymous_region_binding_scope, free_region.bound_region));\n+                    _ => return None, // inapplicable\n+                    // we target only top-level functions\n                 }\n+                return Some((anonymous_region_binding_scope, free_region.bound_region));\n             }\n-            None\n         }\n+        None\n+    }\n+\n+    // Here, we check for the case where the anonymous region\n+    // is in the return type.\n+    // FIXME(#42703) - Need to handle certain cases here.\n+    pub fn is_return_type_anon(&self, scope_def_id: DefId, br: ty::BoundRegion) -> bool {\n+        let ret_ty = self.tcx.type_of(scope_def_id);\n+        match ret_ty.sty {\n+            ty::TyFnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(self.tcx);\n+                let late_bound_regions = self.tcx\n+                    .collect_referenced_late_bound_regions(&sig.output());\n+                if late_bound_regions.iter().any(|r| *r == br) {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+    // Here we check for the case where anonymous region\n+    // corresponds to self and if yes, we display E0312.\n+    // FIXME(#42700) - Need to format self properly to\n+    // enable E0621 for it.\n+    pub fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n+        if is_first &&\n+           self.tcx\n+               .opt_associated_item(scope_def_id)\n+               .map(|i| i.method_has_self_argument)\n+               .unwrap_or(false) {\n+            return true;\n+        }\n+        false\n+    }\n }"}, {"sha": "1ee0099799760d392a7bc037b3cd74c447678d36", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -1,25 +1,10 @@\n-error[E0308]: mismatched types\n+error[E0623]: lifetime mismatch\n   --> $DIR/ex2b-push-no-existing-names.rs:16:12\n    |\n+15 | fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+   |                    --------      -------- these two types are declared with different lifetimes...\n 16 |     x.push(y);\n-   |            ^ lifetime mismatch\n-   |\n-   = note: expected type `Ref<'_, _>`\n-              found type `Ref<'_, _>`\n-note: the anonymous lifetime #3 defined on the function body at 15:1...\n-  --> $DIR/ex2b-push-no-existing-names.rs:15:1\n-   |\n-15 | / fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-16 | |     x.push(y);\n-17 | | }\n-   | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 15:1\n-  --> $DIR/ex2b-push-no-existing-names.rs:15:1\n-   |\n-15 | / fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-16 | |     x.push(y);\n-17 | | }\n-   | |_^\n+   |            ^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "74a40c87c2fb1841b7a64acaa36cf7cb2c95b746", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -2,7 +2,7 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-2.rs:12:9\n    |\n 11 | fn foo((v, w): (&u8, &u8), x: &u8) {\n-   |                 ---           --- these references are not declared with the same lifetime...\n+   |                 ---           --- these two types are declared with different lifetimes...\n 12 |     v = x;\n    |         ^ ...but data from `x` flows here\n "}, {"sha": "51271243bdfdcc2399ca1d0f6b251cb7c0f1e540", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-3.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo((v, w): (&u8, &u8), (x, y): (&u8, &u8)) {\n-    v = x;\n+fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n+    z.push((x,y));\n }\n \n fn main() { }\n+"}, {"sha": "898866c75f2140fccba2edc7a040a13816eec910", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-3.stderr", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -1,10 +1,18 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-3.rs:12:9\n+  --> $DIR/ex3-both-anon-regions-3.rs:12:13\n    |\n-11 | fn foo((v, w): (&u8, &u8), (x, y): (&u8, &u8)) {\n-   |                 ---                 --- these references are not declared with the same lifetime...\n-12 |     v = x;\n-   |         ^ ...but data flows here\n+11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n+   |                     ---                 --- these two types are declared with different lifetimes...\n+12 |     z.push((x,y));\n+   |             ^ ...but data flows into `z` here\n \n-error: aborting due to previous error\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-3.rs:12:15\n+   |\n+11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n+   |                         ---                  --- these two types are declared with different lifetimes...\n+12 |     z.push((x,y));\n+   |               ^ ...but data flows into `z` here\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "9c2630fc811439ea0a07cea2933b54703bd5de0a", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-4.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e3245948445b77c25cd9f3b29cbad3187aee3eb7/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3245948445b77c25cd9f3b29cbad3187aee3eb7/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr?ref=e3245948445b77c25cd9f3b29cbad3187aee3eb7", "patch": "@@ -1,20 +0,0 @@\n-error[E0601]: main function not found\n-\n-error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-4.rs:12:13\n-   |\n-11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                     ---                 --- these references are not declared with the same lifetime...\n-12 |     z.push((x,y));\n-   |             ^ ...but data flows into `z` here\n-\n-error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-4.rs:12:15\n-   |\n-11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                         ---                  --- these references are not declared with the same lifetime...\n-12 |     z.push((x,y));\n-   |               ^ ...but data flows into `z` here\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "2fbf31aead5edea147c45a99fbcfc85ed250e521", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+struct Ref<'a, 'b> {\n+    a: &'a u32,\n+    b: &'b u32,\n+}\n+\n+fn foo(mut x: Ref, y: Ref) {\n+    x.b = y.b;\n+}\n+\n+fn main() {}"}, {"sha": "26f31defc9eb1ff8eeabccd3553357509b870c69", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-both-are-structs-2.rs:16:11\n+   |\n+15 | fn foo(mut x: Ref, y: Ref) {\n+   |               ---     --- these two types are declared with different lifetimes...\n+16 |     x.b = y.b;\n+   |           ^^^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "120a7ca74aeeed81d5c28af32933d5d562e52935", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+struct Ref<'a, 'b> {\n+    a: &'a u32,\n+    b: &'b u32,\n+}\n+\n+fn foo(mut x: Ref) {\n+    x.a = x.b;\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "5ec4511372a6f21813ad93667c1820f6cae9bc38", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-3.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,12 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-both-are-structs-3.rs:16:11\n+   |\n+15 | fn foo(mut x: Ref) {\n+   |               ---\n+   |               |\n+   |               these two types are declared with different lifetimes...\n+16 |     x.a = x.b;\n+   |           ^^^ ...but data with one lifetime flows into the other here\n+\n+error: aborting due to previous error\n+"}, {"sha": "606e611865fc772746230d09cd4104c9dfef6913", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-4.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+struct Ref<'a, 'b> {\n+    a: &'a u32,\n+    b: &'b u32,\n+}\n+\n+fn foo(mut x: Ref) {\n+    x.a = x.b;\n+}\n+\n+fn main() {}"}, {"sha": "2ef1cd507f1477c9d5e3493aa36703b4eb62a5d2", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-4.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,12 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-both-are-structs-4.rs:16:11\n+   |\n+15 | fn foo(mut x: Ref) {\n+   |               ---\n+   |               |\n+   |               these two types are declared with different lifetimes...\n+16 |     x.a = x.b;\n+   |           ^^^ ...but data with one lifetime flows into the other here\n+\n+error: aborting due to previous error\n+"}, {"sha": "67ba8ee532ad0fc75148102766eaa157c40f7012", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs.rs", "status": "renamed", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,7 +7,12 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+struct Ref<'a> {\n+    x: &'a u32,\n+}\n \n-fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-    z.push((x,y));\n+fn foo(mut x: Vec<Ref>, y: Ref) {\n+    x.push(y);\n }\n+\n+fn main() {}", "previous_filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-4.rs"}, {"sha": "6ad795400b334e040cb0d5c5e4e22e6959170ca2", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-both-are-structs.rs:15:12\n+   |\n+14 | fn foo(mut x: Vec<Ref>, y: Ref) {\n+   |                   ---      --- these two types are declared with different lifetimes...\n+15 |     x.push(y);\n+   |            ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "a8b1f53fc98d67f7469c6d722bdbe2ca45bc92a0", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, 'b> { a: &'a u32, b: &'b u32 }\n+\n+fn foo(mut x: Ref, y: &u32) {\n+    y = x.b;\n+}\n+\n+fn main() { }"}, {"sha": "31c7ebf6504cc0bd9ebf76960aa3c11ec62421e4", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-2.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,12 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-one-is-struct-2.rs:14:9\n+   |\n+13 | fn foo(mut x: Ref, y: &u32) {\n+   |               ---     ----\n+   |               |\n+   |               these two types are declared with different lifetimes...\n+14 |     y = x.b;\n+   |         ^^^ ...but data from `x` flows into `y` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "026b4e90c4e0c4f85fff8f90aad5975926a7d945", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-3.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, 'b> { a: &'a u32, b: &'b u32 }\n+\n+fn foo(mut y: Ref, x: &u32) {\n+    x = y.b;\n+}\n+\n+fn main() { }"}, {"sha": "8f1cff9c4a8ab1321e81edd7fbaf47f84d83b5bc", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-3.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,12 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-one-is-struct-3.rs:14:9\n+   |\n+13 | fn foo(mut y: Ref, x: &u32) {\n+   |               ---     ----\n+   |               |\n+   |               these two types are declared with different lifetimes...\n+14 |     x = y.b;\n+   |         ^^^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "4933dbb7e7a7a2c3ec95ffb312fa34dcd9875ee4", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-4.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, 'b> { a: &'a u32, b: &'b u32 }\n+\n+fn foo(mut y: Ref, x: &u32) {\n+    y.b = x;\n+}\n+\n+fn main() { }"}, {"sha": "40f026bcb1b588e67d3aebf5e1b3be560b787e54", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-4.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-one-is-struct-4.rs:14:11\n+   |\n+13 | fn foo(mut y: Ref, x: &u32) {\n+   |               ---     ---- these two types are declared with different lifetimes...\n+14 |     y.b = x;\n+   |           ^ ...but data from `x` flows into `y` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "e1594b1a277cdea01b4f1899eb8a4abe5455fda0", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, 'b> {\n+    a: &'a u32,\n+    b: &'b u32,\n+}\n+\n+fn foo(mut x: Ref, y: &u32) {\n+    x.b = y;\n+}\n+\n+fn main() {}"}, {"sha": "bb7b9ea68436c6f75168fb1c9edecbd846ea0af2", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-one-is-struct.rs:17:11\n+   |\n+16 | fn foo(mut x: Ref, y: &u32) {\n+   |               ---     ---- these two types are declared with different lifetimes...\n+17 |     x.b = y;\n+   |           ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "0dc257ac0921ef8b12fa5d557fbd4708a04d4ca3", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-return-type-is-anon.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+  field: i32\n+}\n+\n+impl Foo {\n+  fn foo<'a>(&self, x: &i32) -> &i32 {\n+    x\n+  }\n+}\n+\n+fn main() { }\n+"}, {"sha": "890f9b311e7d20c9f428217e2e13f18199ebe38f", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-return-type-is-anon.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,23 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:17:5\n+   |\n+17 |     x\n+   |     ^\n+   |\n+note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:3...\n+  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:16:3\n+   |\n+16 | /   fn foo<'a>(&self, x: &i32) -> &i32 {\n+17 | |     x\n+18 | |   }\n+   | |___^\n+note: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the method body at 16:3\n+  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:16:3\n+   |\n+16 | /   fn foo<'a>(&self, x: &i32) -> &i32 {\n+17 | |     x\n+18 | |   }\n+   | |___^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0940ce15d1e7679d13fcc9c71c031e2b1f4c4c48", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-self-is-anon.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    field: i32,\n+}\n+\n+impl Foo {\n+    fn foo<'a>(&self, x: &Foo) -> &Foo {\n+        if true { x } else { self }\n+    }\n+}\n+\n+fn main() {}\n+"}, {"sha": "43f00c32c62856bed949c846ba8a3b21d34ba19a", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-self-is-anon.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,23 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:17:19\n+   |\n+17 |         if true { x } else { self }\n+   |                   ^\n+   |\n+note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:5...\n+  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:16:5\n+   |\n+16 | /     fn foo<'a>(&self, x: &Foo) -> &Foo {\n+17 | |         if true { x } else { self }\n+18 | |     }\n+   | |_____^\n+note: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the method body at 16:5\n+  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:16:5\n+   |\n+16 | /     fn foo<'a>(&self, x: &Foo) -> &Foo {\n+17 | |         if true { x } else { self }\n+18 | |     }\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}, {"sha": "3a7ba415c0ded363e73827879d3bc36882fa34cb", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-impl-items.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+trait Foo {\n+    fn foo<'a>(x: &mut Vec<&u8>, y: &u8);\n+}\n+impl Foo for () {\n+    fn foo(x: &mut Vec<&u8>, y: &u8) {\n+        x.push(y);\n+    }\n+}\n+fn main() {}"}, {"sha": "9591df8e8aad249277330641674ee3891653b147", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-impl-items.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -0,0 +1,10 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ex3-both-anon-regions-using-impl-items.rs:15:16\n+   |\n+14 |     fn foo(x: &mut Vec<&u8>, y: &u8) {\n+   |                        ---      --- these two types are declared with different lifetimes...\n+15 |         x.push(y);\n+   |                ^ ...but data from `y` flows into `x` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "be48d07b94e06098e811eb97395cef030c37f159", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.rs?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}, {"sha": "d3291063859cac81ee35beaa3f6048d878864ac7", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr?ref=fe9c68a0511eb827b2d5a4a3490b5f9c2168a05d", "patch": "@@ -2,7 +2,7 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions.rs:12:12\n    |\n 11 | fn foo(x: &mut Vec<&u8>, y: &u8) {\n-   |                    ---      --- these references are not declared with the same lifetime...\n+   |                    ---      --- these two types are declared with different lifetimes...\n 12 |     x.push(y);\n    |            ^ ...but data from `y` flows into `x` here\n "}]}