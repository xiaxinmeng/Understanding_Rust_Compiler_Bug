{"sha": "c21644ad162c69da7c883812be3e473c4e64c257", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMTY0NGFkMTYyYzY5ZGE3Yzg4MzgxMmJlM2U0NzNjNGU2NGMyNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-13T12:33:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-13T12:33:28Z"}, "message": "Auto merge of #31916 - nagisa:mir-passmgr-2, r=arielb1\n\nAdd Pass manager for MIR\n\nA new PR, since rebasing the original one (https://github.com/rust-lang/rust/pull/31448) properly was a pain. Since then there has been several changes most notable of which:\n\n1. Removed the pretty-printing with `#[rustc_mir(graphviz/pretty)]`, mostly because we now have `--unpretty=mir`, IMHO that\u2019s the direction we should expand this functionality into;\n2. Reverted the infercx change done for typeck, because typeck can make an infercx for itself by being a `MirMapPass`\n\nr? @nikomatsakis", "tree": {"sha": "633d8df31d9d3b1d3983de913ba35a20ad160570", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/633d8df31d9d3b1d3983de913ba35a20ad160570"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c21644ad162c69da7c883812be3e473c4e64c257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c21644ad162c69da7c883812be3e473c4e64c257", "html_url": "https://github.com/rust-lang/rust/commit/c21644ad162c69da7c883812be3e473c4e64c257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c21644ad162c69da7c883812be3e473c4e64c257/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db6dd8e4fecd365157ecf51fc492c366359d4064", "url": "https://api.github.com/repos/rust-lang/rust/commits/db6dd8e4fecd365157ecf51fc492c366359d4064", "html_url": "https://github.com/rust-lang/rust/commit/db6dd8e4fecd365157ecf51fc492c366359d4064"}, {"sha": "bdc176ef6b3909270c187235af657a89e4f2aeec", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdc176ef6b3909270c187235af657a89e4f2aeec", "html_url": "https://github.com/rust-lang/rust/commit/bdc176ef6b3909270c187235af657a89e4f2aeec"}], "stats": {"total": 511, "additions": 246, "deletions": 265}, "files": [{"sha": "821217d75821c079d3f9103d1fac2a810afa5c53", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -10,6 +10,7 @@\n \n use self::thread::{DepGraphThreadData, DepMessage};\n use middle::def_id::DefId;\n+use syntax::ast::NodeId;\n use middle::ty::TyCtxt;\n use rustc_front::hir;\n use rustc_front::intravisit::Visitor;\n@@ -71,6 +72,7 @@ pub enum DepNode {\n     IntrinsicCheck(DefId),\n     MatchCheck(DefId),\n     MirMapConstruction(DefId),\n+    MirTypeck(NodeId),\n     BorrowCheck(DefId),\n     RvalueCheck(DefId),\n     Reachability,"}, {"sha": "1a34699aff491754aea088576fdefa5c47f00106", "filename": "src/librustc/mir/mir_map.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fmir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fmir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmir_map.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -8,31 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepNode;\n use util::nodemap::NodeMap;\n use mir::repr::Mir;\n-use mir::transform::MirPass;\n-use middle::ty::{self, TyCtxt};\n-use middle::infer;\n \n pub struct MirMap<'tcx> {\n     pub map: NodeMap<Mir<'tcx>>,\n }\n-\n-impl<'tcx> MirMap<'tcx> {\n-    pub fn run_passes(&mut self, passes: &mut [Box<MirPass>], tcx: &TyCtxt<'tcx>) {\n-        if passes.is_empty() { return; }\n-\n-        for (&id, mir) in &mut self.map {\n-            let did = tcx.map.local_def_id(id);\n-            let _task = tcx.dep_graph.in_task(DepNode::MirMapConstruction(did));\n-\n-            let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n-\n-            for pass in &mut *passes {\n-                pass.run_on_mir(mir, &infcx)\n-            }\n-        }\n-    }\n-}"}, {"sha": "127cc96859a808f97766e6cd46160901d97602a8", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -207,7 +207,7 @@ impl Debug for BasicBlock {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// BasicBlock and Terminator\n+// BasicBlockData and Terminator\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct BasicBlockData<'tcx> {"}, {"sha": "afcb5b956319d29dbefeeb72c1b9afe76b5eef1e", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -8,9 +8,68 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use mir::mir_map::MirMap;\n use mir::repr::Mir;\n-use middle::infer::InferCtxt;\n+use middle::ty::TyCtxt;\n+use syntax::ast::NodeId;\n \n-pub trait MirPass {\n-    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, infcx: &InferCtxt<'a, 'tcx>);\n+/// Various information about pass.\n+pub trait Pass {\n+    // fn name() for printouts of various sorts?\n+    // fn should_run(Session) to check if pass should run?\n+}\n+\n+/// A pass which inspects the whole MirMap.\n+pub trait MirMapPass<'tcx>: Pass {\n+    fn run_pass(&mut self, cx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>);\n+}\n+\n+/// A pass which inspects Mir of functions in isolation.\n+pub trait MirPass<'tcx>: Pass {\n+    fn run_pass(&mut self, cx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>);\n+}\n+\n+impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+        for (&id, mir) in &mut map.map {\n+            MirPass::run_pass(self, tcx, id, mir);\n+        }\n+    }\n+}\n+\n+/// A manager for MIR passes.\n+pub struct Passes {\n+    passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>,\n+    plugin_passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>\n+}\n+\n+impl Passes {\n+    pub fn new() -> Passes {\n+        let passes = Passes {\n+            passes: Vec::new(),\n+            plugin_passes: Vec::new()\n+        };\n+        passes\n+    }\n+\n+    pub fn run_passes<'tcx>(&mut self, pcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+        for pass in &mut self.plugin_passes {\n+            pass.run_pass(pcx, map);\n+        }\n+        for pass in &mut self.passes {\n+            pass.run_pass(pcx, map);\n+        }\n+    }\n+\n+    /// Pushes a built-in pass.\n+    pub fn push_pass(&mut self, pass: Box<for<'a> MirMapPass<'a>>) {\n+        self.passes.push(pass);\n+    }\n+}\n+\n+/// Copies the plugin passes.\n+impl ::std::iter::Extend<Box<for<'a> MirMapPass<'a>>> for Passes {\n+    fn extend<I: IntoIterator<Item=Box<for <'a> MirMapPass<'a>>>>(&mut self, it: I) {\n+        self.plugin_passes.extend(it);\n+    }\n }"}, {"sha": "b198eda181208f2e3a8c7fc52464d017d6200ec4", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -13,7 +13,7 @@ use middle::cstore::CrateStore;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeMap, FnvHashMap};\n-use mir::transform::MirPass;\n+use mir::transform as mir_pass;\n \n use syntax::ast::{NodeId, NodeIdAssigner, Name};\n use syntax::codemap::{Span, MultiSpan};\n@@ -60,7 +60,7 @@ pub struct Session {\n     pub lint_store: RefCell<lint::LintStore>,\n     pub lints: RefCell<NodeMap<Vec<(lint::LintId, Span, String)>>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n-    pub plugin_mir_passes: RefCell<Vec<Box<MirPass>>>,\n+    pub mir_passes: RefCell<mir_pass::Passes>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n@@ -477,7 +477,7 @@ pub fn build_session_(sopts: config::Options,\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n-        plugin_mir_passes: RefCell::new(Vec::new()),\n+        mir_passes: RefCell::new(mir_pass::Passes::new()),\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FnvHashMap()),"}, {"sha": "46e06d21c7c249c47e66f54eed0c7eb54ebac699", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -568,7 +568,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         }\n \n         *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n-        *sess.plugin_mir_passes.borrow_mut() = mir_passes;\n+        sess.mir_passes.borrow_mut().extend(mir_passes);\n         *sess.plugin_attributes.borrow_mut() = attributes.clone();\n     }));\n \n@@ -865,9 +865,19 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                  \"MIR dump\",\n                  || mir::mir_map::build_mir_for_crate(tcx));\n \n-        time(time_passes,\n-             \"MIR passes\",\n-             || mir_map.run_passes(&mut sess.plugin_mir_passes.borrow_mut(), tcx));\n+        time(time_passes, \"MIR passes\", || {\n+            let mut passes = sess.mir_passes.borrow_mut();\n+            // Push all the built-in passes.\n+            passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+            passes.push_pass(box mir::transform::type_check::TypeckMir);\n+            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n+            // Late passes\n+            passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n+            passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+            passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n+            // And run everything.\n+            passes.run_passes(tcx, &mut mir_map);\n+        });\n \n         time(time_passes,\n              \"borrow checking\",\n@@ -916,9 +926,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n-/// be discarded.\n pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                       mut mir_map: MirMap<'tcx>,\n+                                       mir_map: MirMap<'tcx>,\n                                        analysis: ty::CrateAnalysis)\n                                        -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n@@ -927,10 +936,6 @@ pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n-    time(time_passes,\n-         \"erasing regions from MIR\",\n-         || mir::transform::erase_regions::erase_regions(tcx, &mut mir_map));\n-\n     // Option dance to work around the lack of stack once closures.\n     time(time_passes,\n          \"translation\","}, {"sha": "4792fa72831b83ce8a1dd124abfbd5306d7b67a0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -31,6 +31,7 @@ use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n \n use rustc_mir::pretty::write_mir_pretty;\n+use rustc_mir::graphviz::write_mir_graphviz;\n \n use syntax::ast::{self, BlockCheckMode};\n use syntax::codemap;\n@@ -44,6 +45,7 @@ use graphviz as dot;\n \n use std::fs::File;\n use std::io::{self, Write};\n+use std::iter;\n use std::option;\n use std::path::PathBuf;\n use std::str::FromStr;\n@@ -80,6 +82,7 @@ pub enum PpMode {\n     PpmHir(PpSourceMode),\n     PpmFlowGraph(PpFlowGraphMode),\n     PpmMir,\n+    PpmMirCFG,\n }\n \n pub fn parse_pretty(sess: &Session,\n@@ -100,6 +103,7 @@ pub fn parse_pretty(sess: &Session,\n         (\"hir,identified\", true) => PpmHir(PpmIdentified),\n         (\"hir,typed\", true) => PpmHir(PpmTyped),\n         (\"mir\", true) => PpmMir,\n+        (\"mir-cfg\", true) => PpmMirCFG,\n         (\"flowgraph\", true) => PpmFlowGraph(PpFlowGraphMode::Default),\n         (\"flowgraph,unlabelled\", true) => PpmFlowGraph(PpFlowGraphMode::UnlabelledEdges),\n         _ => {\n@@ -574,6 +578,7 @@ fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n         PpmSource(PpmExpandedHygiene) |\n         PpmHir(_) |\n         PpmMir |\n+        PpmMirCFG |\n         PpmFlowGraph(_) => true,\n         PpmSource(PpmTyped) => panic!(\"invalid state\"),\n     }\n@@ -590,6 +595,7 @@ fn needs_expansion(ppm: &PpMode) -> bool {\n         PpmSource(PpmExpandedHygiene) |\n         PpmHir(_) |\n         PpmMir |\n+        PpmMirCFG |\n         PpmFlowGraph(_) => true,\n         PpmSource(PpmTyped) => panic!(\"invalid state\"),\n     }\n@@ -807,9 +813,15 @@ pub fn pretty_print_input(sess: Session,\n             })\n         }\n \n-        (PpmMir, None) => {\n-            debug!(\"pretty printing MIR for whole crate\");\n-            let ast_map = ast_map.expect(\"--unpretty mir missing ast_map\");\n+        (pp_type@PpmMir, uii) | (pp_type@PpmMirCFG, uii) => {\n+            let ast_map = ast_map.expect(\"--unpretty missing ast_map\");\n+            let nodeid = if let Some(uii) = uii {\n+                debug!(\"pretty printing MIR for {:?}\", uii);\n+                Some(uii.to_one_node_id(\"--unpretty\", &sess, &ast_map))\n+            } else {\n+                debug!(\"pretty printing MIR for whole crate\");\n+                None\n+            };\n             abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n                                                              &cstore,\n                                                              ast_map,\n@@ -818,38 +830,25 @@ pub fn pretty_print_input(sess: Session,\n                                                              resolve::MakeGlobMap::No,\n                                                              |tcx, mir_map, _, _| {\n                 if let Some(mir_map) = mir_map {\n-                    for (nodeid, mir) in &mir_map.map {\n-                        try!(writeln!(out, \"MIR for {}\", tcx.map.node_to_string(*nodeid)));\n-                        try!(write_mir_pretty(mir, &mut out));\n+                    if let Some(nodeid) = nodeid {\n+                        let mir = mir_map.map.get(&nodeid).unwrap_or_else(|| {\n+                            sess.fatal(&format!(\"no MIR map entry for node {}\", nodeid))\n+                        });\n+                        try!(match pp_type {\n+                            PpmMir => write_mir_pretty(tcx, iter::once((&nodeid, mir)), &mut out),\n+                            _ => write_mir_graphviz(tcx, iter::once((&nodeid, mir)), &mut out)\n+                        });\n+                    } else {\n+                        try!(match pp_type {\n+                            PpmMir => write_mir_pretty(tcx, mir_map.map.iter(), &mut out),\n+                            _ => write_mir_graphviz(tcx, mir_map.map.iter(), &mut out)\n+                        });\n                     }\n                 }\n                 Ok(())\n             }), &sess)\n         }\n \n-        (PpmMir, Some(uii)) => {\n-            debug!(\"pretty printing MIR for {:?}\", uii);\n-            let ast_map = ast_map.expect(\"--unpretty mir missing ast_map\");\n-            let nodeid = uii.to_one_node_id(\"--unpretty\", &sess, &ast_map);\n-\n-            abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                             &cstore,\n-                                                             ast_map,\n-                                                             &arenas,\n-                                                             &id,\n-                                                             resolve::MakeGlobMap::No,\n-                                                             |tcx, mir_map, _, _| {\n-                if let Some(mir_map) = mir_map {\n-                    try!(writeln!(out, \"MIR for {}\", tcx.map.node_to_string(nodeid)));\n-                    let mir = mir_map.map.get(&nodeid).unwrap_or_else(|| {\n-                        sess.fatal(&format!(\"no MIR map entry for node {}\", nodeid))\n-                    });\n-                    try!(write_mir_pretty(mir, &mut out));\n-                }\n-                Ok(())\n-            }), &sess)\n-        }\n-\n         (PpmFlowGraph(mode), opt_uii) => {\n             debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {"}, {"sha": "f705c0591b5596a3258d5a9564f1189ade2ba946", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -13,30 +13,34 @@ use rustc::mir::repr::*;\n use rustc::middle::ty;\n use std::fmt::Debug;\n use std::io::{self, Write};\n+use syntax::ast::NodeId;\n \n-/// Write a graphviz DOT graph for the given MIR.\n-pub fn write_mir_graphviz<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n-    try!(writeln!(w, \"digraph Mir {{\"));\n+/// Write a graphviz DOT graph of a list of MIRs.\n+pub fn write_mir_graphviz<'a, 't, W, I>(tcx: &ty::TyCtxt<'t>, iter: I, w: &mut W) -> io::Result<()>\n+where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n+    for (&nodeid, mir) in iter {\n+        try!(writeln!(w, \"digraph Mir_{} {{\", nodeid));\n \n-    // Global graph properties\n-    try!(writeln!(w, r#\"    graph [fontname=\"monospace\"];\"#));\n-    try!(writeln!(w, r#\"    node [fontname=\"monospace\"];\"#));\n-    try!(writeln!(w, r#\"    edge [fontname=\"monospace\"];\"#));\n+        // Global graph properties\n+        try!(writeln!(w, r#\"    graph [fontname=\"monospace\"];\"#));\n+        try!(writeln!(w, r#\"    node [fontname=\"monospace\"];\"#));\n+        try!(writeln!(w, r#\"    edge [fontname=\"monospace\"];\"#));\n \n-    // Graph label\n-    try!(write_graph_label(mir, w));\n+        // Graph label\n+        try!(write_graph_label(tcx, nodeid, mir, w));\n \n-    // Nodes\n-    for block in mir.all_basic_blocks() {\n-        try!(write_node(block, mir, w));\n-    }\n+        // Nodes\n+        for block in mir.all_basic_blocks() {\n+            try!(write_node(block, mir, w));\n+        }\n \n-    // Edges\n-    for source in mir.all_basic_blocks() {\n-        try!(write_edges(source, mir, w));\n+        // Edges\n+        for source in mir.all_basic_blocks() {\n+            try!(write_edges(source, mir, w));\n+        }\n+        try!(writeln!(w, \"}}\"))\n     }\n-\n-    writeln!(w, \"}}\")\n+    Ok(())\n }\n \n /// Write a graphviz DOT node for the given basic block.\n@@ -84,8 +88,9 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n-    try!(write!(w, \"    label=<fn(\"));\n+fn write_graph_label<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n+-> io::Result<()> {\n+    try!(write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.map.path_to_string(nid))));\n \n     // fn argument types.\n     for (i, arg) in mir.arg_decls.iter().enumerate() {"}, {"sha": "2e13e7b42bd6c0dad193b89037f27b6bbe58c1eb", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 5, "deletions": 56, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -20,16 +20,10 @@ extern crate syntax;\n extern crate rustc_front;\n \n use build;\n-use graphviz;\n-use pretty;\n-use transform::{clear_dead_blocks, simplify_cfg, type_check};\n-use transform::{no_landing_pads};\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;\n-use std::fs::File;\n \n-use rustc::mir::transform::MirPass;\n use rustc::mir::mir_map::MirMap;\n use rustc::middle::infer;\n use rustc::middle::region::CodeExtentData;\n@@ -136,61 +130,16 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n                 body: &'tcx hir::Block,\n                 span: Span,\n                 id: ast::NodeId) {\n-        let (prefix, implicit_arg_tys) = match fk {\n-            intravisit::FnKind::Closure =>\n-                (format!(\"{}-\", id), vec![closure_self_ty(&self.tcx, id, body.id)]),\n-            _ =>\n-                (format!(\"\"), vec![]),\n+        let implicit_arg_tys = if let intravisit::FnKind::Closure = fk {\n+            vec![closure_self_ty(&self.tcx, id, body.id)]\n+        } else {\n+            vec![]\n         };\n \n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-\n         let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n-\n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n-            Ok(mut mir) => {\n-                clear_dead_blocks::ClearDeadBlocks::new().run_on_mir(&mut mir, &infcx);\n-                type_check::TypeckMir::new().run_on_mir(&mut mir, &infcx);\n-                no_landing_pads::NoLandingPads.run_on_mir(&mut mir, &infcx);\n-                if self.tcx.sess.opts.mir_opt_level > 0 {\n-                    simplify_cfg::SimplifyCfg::new().run_on_mir(&mut mir, &infcx);\n-                }\n-                let meta_item_list = self.attr\n-                                         .iter()\n-                                         .flat_map(|a| a.meta_item_list())\n-                                         .flat_map(|l| l.iter());\n-                for item in meta_item_list {\n-                    if item.check_name(\"graphviz\") || item.check_name(\"pretty\") {\n-                        match item.value_str() {\n-                            Some(s) => {\n-                                let filename = format!(\"{}{}\", prefix, s);\n-                                let result = File::create(&filename).and_then(|ref mut output| {\n-                                    if item.check_name(\"graphviz\") {\n-                                        graphviz::write_mir_graphviz(&mir, output)\n-                                    } else {\n-                                        pretty::write_mir_pretty(&mir, output)\n-                                    }\n-                                });\n-\n-                                if let Err(e) = result {\n-                                    self.tcx.sess.span_fatal(\n-                                        item.span,\n-                                        &format!(\"Error writing MIR {} results to `{}`: {}\",\n-                                                 item.name(), filename, e));\n-                                }\n-                            }\n-                            None => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    &format!(\"{} attribute requires a path\", item.name()));\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                let previous = self.map.map.insert(id, mir);\n-                assert!(previous.is_none());\n-            }\n+            Ok(mir) => assert!(self.map.map.insert(id, mir).is_none()),\n             Err(ErrorReported) => {}\n         }\n "}, {"sha": "c3fe4df40b5f6ba4d27640f8000021b025f3d3ec", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -11,19 +11,22 @@\n use rustc::mir::repr::*;\n use rustc::middle::ty;\n use std::io::{self, Write};\n+use syntax::ast::NodeId;\n \n const INDENT: &'static str = \"    \";\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n-    try!(write_mir_intro(mir, w));\n-\n-    // Nodes\n-    for block in mir.all_basic_blocks() {\n-        try!(write_basic_block(block, mir, w));\n+pub fn write_mir_pretty<'a, 't, W, I>(tcx: &ty::TyCtxt<'t>, iter: I, w: &mut W) -> io::Result<()>\n+where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n+    for (&nodeid, mir) in iter {\n+        try!(write_mir_intro(tcx, nodeid, mir, w));\n+        // Nodes\n+        for block in mir.all_basic_blocks() {\n+            try!(write_basic_block(block, mir, w));\n+        }\n+        try!(writeln!(w, \"}}\"))\n     }\n-\n-    writeln!(w, \"}}\")\n+    Ok(())\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n@@ -46,8 +49,10 @@ fn write_basic_block<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::R\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n-    try!(write!(w, \"fn(\"));\n+fn write_mir_intro<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n+-> io::Result<()> {\n+\n+    try!(write!(w, \"fn {}(\", tcx.map.path_to_string(nid)));\n \n     // fn argument types.\n     for (i, arg) in mir.arg_decls.iter().enumerate() {"}, {"sha": "1920bd552ec3e5a3dc6821f97b4f221d29cdf3a8", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -15,13 +15,8 @@\n use rustc::middle::ty::{self, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::mir_map::MirMap;\n-\n-pub fn erase_regions<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &mut MirMap<'tcx>) {\n-    for (_, mir) in &mut mir_map.map {\n-        EraseRegionsVisitor::new(tcx).visit_mir(mir);\n-    }\n-}\n+use rustc::mir::transform::{MirPass, Pass};\n+use syntax::ast::NodeId;\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n@@ -123,3 +118,13 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n         self.super_constant(constant);\n     }\n }\n+\n+pub struct EraseRegions;\n+\n+impl Pass for EraseRegions {}\n+\n+impl<'tcx> MirPass<'tcx> for EraseRegions {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+        EraseRegionsVisitor::new(tcx).visit_mir(mir);\n+    }\n+}"}, {"sha": "57690caeccb37a4832ec35a2908a3f87b8bb0bea", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub mod clear_dead_blocks;\n+pub mod remove_dead_blocks;\n pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;"}, {"sha": "9caee36e44a7de9bf515629c2712b499eba67537", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -11,10 +11,11 @@\n //! This pass removes the unwind branch of all the terminators when the no-landing-pads option is\n //! specified.\n \n-use rustc::middle::infer;\n+use rustc::middle::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::MirPass;\n+use rustc::mir::transform::{Pass, MirPass};\n+use syntax::ast::NodeId;\n \n pub struct NoLandingPads;\n \n@@ -40,11 +41,12 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n     }\n }\n \n-impl MirPass for NoLandingPads {\n-    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>,\n-                            infcx: &infer::InferCtxt<'a, 'tcx>) {\n-        if infcx.tcx.sess.no_landing_pads() {\n+impl<'tcx> MirPass<'tcx> for NoLandingPads {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+        if tcx.sess.no_landing_pads() {\n             self.visit_mir(mir);\n         }\n     }\n }\n+\n+impl Pass for NoLandingPads {}"}, {"sha": "4513aeef86d91c0d7003e99a25eb2ea2b667b932", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "renamed", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -32,50 +32,56 @@\n //! this pass just replaces the blocks with empty \"return\" blocks\n //! and does not renumber anything.\n \n-use rustc::middle::infer;\n+use rustc_data_structures::bitvec::BitVector;\n+use rustc::middle::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::MirPass;\n+use rustc::mir::transform::{Pass, MirPass};\n+use syntax::ast::NodeId;\n \n-pub struct ClearDeadBlocks;\n-\n-impl ClearDeadBlocks {\n-    pub fn new() -> ClearDeadBlocks {\n-        ClearDeadBlocks\n-    }\n-\n-    fn clear_dead_blocks(&self, mir: &mut Mir) {\n-        let mut seen = vec![false; mir.basic_blocks.len()];\n+pub struct RemoveDeadBlocks;\n \n+impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n+    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+        let mut seen = BitVector::new(mir.basic_blocks.len());\n         // These blocks are always required.\n-        seen[START_BLOCK.index()] = true;\n-        seen[END_BLOCK.index()] = true;\n+        seen.insert(START_BLOCK.index());\n+        seen.insert(END_BLOCK.index());\n \n-        let mut worklist = vec![START_BLOCK];\n+        let mut worklist = Vec::with_capacity(4);\n+        worklist.push(START_BLOCK);\n         while let Some(bb) = worklist.pop() {\n             for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n-                if !seen[succ.index()] {\n-                    seen[succ.index()] = true;\n+                if seen.insert(succ.index()) {\n                     worklist.push(*succ);\n                 }\n             }\n         }\n+        retain_basic_blocks(mir, &seen);\n+    }\n+}\n \n-        for (n, (block, seen)) in mir.basic_blocks.iter_mut().zip(seen).enumerate() {\n-            if !seen {\n-                info!(\"clearing block #{}: {:?}\", n, block);\n-                *block = BasicBlockData {\n-                    statements: vec![],\n-                    terminator: Some(Terminator::Return),\n-                    is_cleanup: false\n-                };\n-            }\n+impl Pass for RemoveDeadBlocks {}\n+\n+/// Mass removal of basic blocks to keep the ID-remapping cheap.\n+fn retain_basic_blocks(mir: &mut Mir, keep: &BitVector) {\n+    let num_blocks = mir.basic_blocks.len();\n+\n+    let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n+    let mut used_blocks = 0;\n+    for alive_index in keep.iter() {\n+        replacements[alive_index] = BasicBlock::new(used_blocks);\n+        if alive_index != used_blocks {\n+            // Swap the next alive block data with the current available slot. Since alive_index is\n+            // non-decreasing this is a valid operation.\n+            mir.basic_blocks.swap(alive_index, used_blocks);\n         }\n+        used_blocks += 1;\n     }\n-}\n+    mir.basic_blocks.truncate(used_blocks);\n \n-impl MirPass for ClearDeadBlocks {\n-    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &infer::InferCtxt<'a, 'tcx>)\n-    {\n-        self.clear_dead_blocks(mir);\n+    for bb in mir.all_basic_blocks() {\n+        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n+            *target = replacements[target.index()];\n+        }\n     }\n }", "previous_filename": "src/librustc_mir/transform/clear_dead_blocks.rs"}, {"sha": "84410bdc57c0abb714212705ee5013055b42d2f8", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 9, "deletions": 48, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_eval::ConstVal;\n-use rustc::middle::infer;\n+use rustc::middle::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::MirPass;\n+use rustc::mir::transform::{MirPass, Pass};\n+use syntax::ast::NodeId;\n+\n+use super::remove_dead_blocks::RemoveDeadBlocks;\n \n pub struct SimplifyCfg;\n \n@@ -21,26 +23,7 @@ impl SimplifyCfg {\n         SimplifyCfg\n     }\n \n-    fn remove_dead_blocks(&self, mir: &mut Mir) {\n-        let mut seen = BitVector::new(mir.basic_blocks.len());\n-        // These blocks are always required.\n-        seen.insert(START_BLOCK.index());\n-        seen.insert(END_BLOCK.index());\n-\n-        let mut worklist = Vec::with_capacity(4);\n-        worklist.push(START_BLOCK);\n-        while let Some(bb) = worklist.pop() {\n-            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n-                if seen.insert(succ.index()) {\n-                    worklist.push(*succ);\n-                }\n-            }\n-        }\n-        retain_basic_blocks(mir, &seen);\n-    }\n-\n     fn remove_goto_chains(&self, mir: &mut Mir) -> bool {\n-\n         // Find the target at the end of the jump chain, return None if there is a loop\n         fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> {\n             // Keep track of already seen blocks to detect loops\n@@ -118,39 +101,17 @@ impl SimplifyCfg {\n     }\n }\n \n-impl MirPass for SimplifyCfg {\n-    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &infer::InferCtxt<'a, 'tcx>) {\n+impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>) {\n         let mut changed = true;\n         while changed {\n             changed = self.simplify_branches(mir);\n             changed |= self.remove_goto_chains(mir);\n-            self.remove_dead_blocks(mir);\n+            RemoveDeadBlocks.run_pass(tcx, id, mir);\n         }\n         // FIXME: Should probably be moved into some kind of pass manager\n         mir.basic_blocks.shrink_to_fit();\n     }\n }\n \n-/// Mass removal of basic blocks to keep the ID-remapping cheap.\n-fn retain_basic_blocks(mir: &mut Mir, keep: &BitVector) {\n-    let num_blocks = mir.basic_blocks.len();\n-\n-    let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n-    let mut used_blocks = 0;\n-    for alive_index in keep.iter() {\n-        replacements[alive_index] = BasicBlock::new(used_blocks);\n-        if alive_index != used_blocks {\n-            // Swap the next alive block data with the current available slot. Since alive_index is\n-            // non-decreasing this is a valid operation.\n-            mir.basic_blocks.swap(alive_index, used_blocks);\n-        }\n-        used_blocks += 1;\n-    }\n-    mir.basic_blocks.truncate(used_blocks);\n-\n-    for bb in mir.all_basic_blocks() {\n-        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n-            *target = replacements[target.index()];\n-        }\n-    }\n-}\n+impl Pass for SimplifyCfg {}"}, {"sha": "45393d57101e577c1b0779a4350d53910b36c5b5", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -11,17 +11,18 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use rustc::dep_graph::DepNode;\n use rustc::middle::infer::{self, InferCtxt};\n use rustc::middle::traits;\n-use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::middle::ty::fold::TypeFoldable;\n+use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::mir::transform::MirPass;\n+use rustc::mir::transform::{MirPass, Pass};\n use rustc::mir::visit::{self, Visitor};\n-\n-use syntax::codemap::{Span, DUMMY_SP};\n use std::fmt;\n+use syntax::ast::NodeId;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n@@ -572,17 +573,17 @@ impl TypeckMir {\n     }\n }\n \n-impl MirPass for TypeckMir {\n-    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, infcx: &InferCtxt<'a, 'tcx>)\n-    {\n-        if infcx.tcx.sess.err_count() > 0 {\n+impl<'tcx> MirPass<'tcx> for TypeckMir {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>) {\n+        if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-\n-        let mut checker = TypeChecker::new(infcx);\n-\n+        let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(id));\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+        let mut checker = TypeChecker::new(&infcx);\n         {\n             let mut verifier = TypeVerifier::new(&mut checker, mir);\n             verifier.visit_mir(mir);\n@@ -591,8 +592,9 @@ impl MirPass for TypeckMir {\n                 return;\n             }\n         }\n-\n         checker.typeck_mir(mir);\n         checker.verify_obligations(mir);\n     }\n }\n+\n+impl Pass for TypeckMir {}"}, {"sha": "3cfd6a76dda63005649773a72f86d92d936d66ca", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -13,7 +13,7 @@\n use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n use rustc::session::Session;\n \n-use rustc::mir::transform::MirPass;\n+use rustc::mir::transform::MirMapPass;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n use syntax::ext::base::{IdentTT, MultiModifier, MultiDecorator};\n@@ -56,7 +56,7 @@ pub struct Registry<'a> {\n     pub late_lint_passes: Vec<LateLintPassObject>,\n \n     #[doc(hidden)]\n-    pub mir_passes: Vec<Box<MirPass>>,\n+    pub mir_passes: Vec<Box<for<'pcx> MirMapPass<'pcx>>>,\n \n     #[doc(hidden)]\n     pub lint_groups: HashMap<&'static str, Vec<LintId>>,\n@@ -141,7 +141,7 @@ impl<'a> Registry<'a> {\n     }\n \n     /// Register a MIR pass\n-    pub fn register_mir_pass(&mut self, pass: Box<MirPass>) {\n+    pub fn register_mir_pass(&mut self, pass: Box<for<'pcx> MirMapPass<'pcx>>) {\n         self.mir_passes.push(pass);\n     }\n "}, {"sha": "89101fe709d97d0c1770ccbaa69b90c46dc45f88", "filename": "src/test/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c21644ad162c69da7c883812be3e473c4e64c257/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21644ad162c69da7c883812be3e473c4e64c257/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs?ref=c21644ad162c69da7c883812be3e473c4e64c257", "patch": "@@ -18,17 +18,20 @@ extern crate rustc_front;\n extern crate rustc_plugin;\n extern crate syntax;\n \n-use rustc::mir::transform::MirPass;\n+use rustc::mir::transform::{self, MirPass};\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n-use rustc::middle::infer::InferCtxt;\n+use rustc::middle::ty;\n use rustc::middle::const_eval::ConstVal;\n use rustc_plugin::Registry;\n \n+use syntax::ast::NodeId;\n+\n struct Pass;\n \n-impl MirPass for Pass {\n-    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &InferCtxt<'a, 'tcx>) {\n+impl transform::Pass for Pass {}\n+impl<'tcx> MirPass<'tcx> for Pass {\n+    fn run_pass(&mut self, _: &ty::TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n         Visitor.visit_mir(mir)\n     }\n }"}]}