{"sha": "9075025c7b48ffc028b3bddbb983ceac98ce9636", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNzUwMjVjN2I0OGZmYzAyOGIzYmRkYmI5ODNjZWFjOThjZTk2MzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-14T20:32:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-14T20:32:11Z"}, "message": "auto merge of #11485 : eddyb/rust/sweep-old-rust, r=nikomatsakis", "tree": {"sha": "e3e7c8832f1d8ecf7700665f91b2938e8bcb01b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3e7c8832f1d8ecf7700665f91b2938e8bcb01b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9075025c7b48ffc028b3bddbb983ceac98ce9636", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9075025c7b48ffc028b3bddbb983ceac98ce9636", "html_url": "https://github.com/rust-lang/rust/commit/9075025c7b48ffc028b3bddbb983ceac98ce9636", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9075025c7b48ffc028b3bddbb983ceac98ce9636/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b77a7e76a18f0d2237813428425c80bf78faf772", "url": "https://api.github.com/repos/rust-lang/rust/commits/b77a7e76a18f0d2237813428425c80bf78faf772", "html_url": "https://github.com/rust-lang/rust/commit/b77a7e76a18f0d2237813428425c80bf78faf772"}, {"sha": "509fc92a9bb6f9a251308476ebf4e76795df60bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/509fc92a9bb6f9a251308476ebf4e76795df60bf", "html_url": "https://github.com/rust-lang/rust/commit/509fc92a9bb6f9a251308476ebf4e76795df60bf"}], "stats": {"total": 449, "additions": 189, "deletions": 260}, "files": [{"sha": "77c8ddae3de835aefd5c87f70c74f57277a9afc2", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -782,7 +782,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     match explicit_self_kind as char {\n         's' => ast::SelfStatic,\n         'v' => ast::SelfValue(get_mutability(string[1])),\n-        '@' => ast::SelfBox(get_mutability(string[1])),\n+        '@' => ast::SelfBox,\n         '~' => ast::SelfUniq(get_mutability(string[1])),\n         // FIXME(#4846) expl. region\n         '&' => ast::SelfRegion(None, get_mutability(string[1])),"}, {"sha": "465a52221d9b9f1693d9f5009c8ae2bd2af4df0e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -687,9 +687,8 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n             ebml_w.writer.write(&[ '&' as u8 ]);\n             encode_mutability(ebml_w, m);\n         }\n-        SelfBox(m) => {\n+        SelfBox => {\n             ebml_w.writer.write(&[ '@' as u8 ]);\n-            encode_mutability(ebml_w, m);\n         }\n         SelfUniq(m) => {\n             ebml_w.writer.write(&[ '~' as u8 ]);"}, {"sha": "1f33ef2f41be6790ee63b3ea9f3783e68512a3a4", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -343,7 +343,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_self(st.tcx, did);\n       }\n       '@' => return ty::mk_box(st.tcx, parse_ty(st, |x,y| conv(x,y))),\n-      '~' => return ty::mk_uniq(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n+      '~' => return ty::mk_uniq(st.tcx, parse_ty(st, |x,y| conv(x,y))),\n       '*' => return ty::mk_ptr(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n       '&' => {\n         let r = parse_region(st, |x,y| conv(x,y));"}, {"sha": "3b2fbffe6d4a26e1bc993347f7950c079eae17b9", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -292,7 +292,7 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             mywrite!(w, \"]\");\n         }\n         ty::ty_box(typ) => { mywrite!(w, \"@\"); enc_ty(w, cx, typ); }\n-        ty::ty_uniq(mt) => { mywrite!(w, \"~\"); enc_mt(w, cx, mt); }\n+        ty::ty_uniq(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n         ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n         ty::ty_rptr(r, mt) => {\n             mywrite!(w, \"&\");"}, {"sha": "286365f8c13fa45bfd4c9feb0fabffdbf90abcd1", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 7, "deletions": 44, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -248,7 +248,7 @@ data as mutable).\n 2. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n the lifetime of the value being borrowed. This pass is also\n responsible for inserting root annotations to keep managed values\n-alive and for dynamically freezing `@mut` boxes.\n+alive.\n \n 3. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n restrictions to maintain memory safety. These are the restrictions\n@@ -308,22 +308,17 @@ be borrowed if MQ is immutable or const:\n \n ### Checking mutability of mutable pointer types\n \n-`&mut T` and `@mut T` can be frozen, so it is acceptable to borrow\n-them as either imm or mut:\n+`&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n     MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n       TYPE(LV) = &mut Ty\n \n-    MUTABILITY(*LV, MQ)                 // M-Deref-Managed-Mut\n-      TYPE(LV) = @mut Ty\n-\n ## Checking lifetime\n \n-These rules aim to ensure that no data is borrowed for a scope that\n-exceeds its lifetime. In addition, these rules manage the rooting and\n-dynamic freezing of `@` and `@mut` values. These two computations wind\n-up being intimately related. Formally, we define a predicate\n-`LIFETIME(LV, LT, MQ)`, which states that \"the lvalue `LV` can be\n+These rules aim to ensure that no data is borrowed for a scope that exceeds\n+its lifetime. In addition, these rules manage the rooting of `@` values.\n+These two computations wind up being intimately related. Formally, we define\n+a predicate `LIFETIME(LV, LT, MQ)`, which states that \"the lvalue `LV` can be\n safely borrowed for the lifetime `LT` with mutability `MQ`\". The Rust\n code corresponding to this predicate is the module\n `middle::borrowck::gather_loans::lifetime`.\n@@ -352,7 +347,7 @@ The scope of a managed referent is also the scope of the pointer.  This\n is a conservative approximation, since there may be other aliases fo\n that same managed box that would cause it to live longer:\n \n-      SCOPE(*LV) = SCOPE(LV) if LV has type @T or @mut T\n+      SCOPE(*LV) = SCOPE(LV) if LV has type @T\n \n The scope of a borrowed referent is the scope associated with the\n pointer.  This is a conservative approximation, since the data that\n@@ -441,29 +436,6 @@ makes a note in a side-table that the box `LV` must be rooted into the\n stack when `*LV` is evaluated, and that this root can be released when\n the scope `LT` exits.\n \n-### Checking lifetime for derefs of managed, mutable pointers\n-\n-Loans of the contents of mutable managed pointers are simpler in some\n-ways that loans of immutable managed pointers, because we can never\n-rely on the user to root them (since the contents are, after all,\n-mutable). This means that the burden always falls to the compiler, so\n-there is only one rule:\n-\n-    LIFETIME(*LV, LT, MQ)              // L-Deref-Managed-Mut-Compiler-Root\n-      TYPE(LV) = @mut Ty\n-      LT <= innermost enclosing loop/func\n-      ROOT LV at *LV for LT\n-      LOCK LV at *LV as MQ for LT\n-\n-Note that there is an additional clause this time `LOCK LV at *LV as\n-MQ for LT`.  This clause states that in addition to rooting `LV`, the\n-compiler should also \"lock\" the box dynamically, meaning that we\n-register that the box has been borrowed as mutable or immutable,\n-depending on `MQ`. This lock will fail if the box has already been\n-borrowed and either the old loan or the new loan is a mutable loan\n-(multiple immutable loans are okay). The lock is released as we exit\n-the scope `LT`.\n-\n ## Computing the restrictions\n \n The final rules govern the computation of *restrictions*, meaning that\n@@ -835,15 +807,6 @@ prohibited from both freezes and claims. This would avoid the need to\n prevent `const` borrows of the base pointer when the referent is\n borrowed.\n \n-### Restrictions for loans of mutable managed referents\n-\n-With `@mut` referents, we don't make any static guarantees.  But as a\n-convenience, we still register a restriction against `*LV`, because\n-that way if we *can* find a simple static error, we will:\n-\n-    RESTRICTIONS(*LV, LT, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n-      TYPE(LV) = @mut Ty\n-\n # Moves and initialization\n \n The borrow checker is also in charge of ensuring that:"}, {"sha": "16a7f4c3e7eea39a7c54622f0ab4a940b946f158", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -137,7 +137,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 //\n                 // As a second example, consider *this* scenario:\n                 //\n-                //    let x = @mut @Some(3);\n+                //    let x = @@Some(3);\n                 //    match x { @@Some(y) {...} @@None {...} }\n                 //\n                 // Here again, `x` need only be rooted in the `some` arm.\n@@ -156,7 +156,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 // with a second basic block.  However, the naive approach\n                 // also yielded suboptimal results for patterns like:\n                 //\n-                //    let x = @mut @...;\n+                //    let x = @@...;\n                 //    match x { @@some_variant(y) | @@some_other_variant(y) =>\n                 //\n                 // The reason is that we would root the value once for"}, {"sha": "a65e903e4b9bdaa60ca70de702a58230da3591b9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -409,7 +409,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n     match *fk {\n         visit::FkMethod(_, _, method) => {\n             match method.explicit_self.node {\n-                SelfValue(_) | SelfRegion(..) | SelfBox(_) | SelfUniq(_) => {\n+                SelfValue(_) | SelfRegion(..) | SelfBox | SelfUniq(_) => {\n                     fn_maps.add_variable(Arg(method.self_id,\n                                              special_idents::self_));\n                 }"}, {"sha": "5e189bb2ab23113a217fd4b22270024a12690d2f", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -357,20 +357,18 @@ pub fn malloc_raw_dyn<'a>(\n         rslt(r.bcx, PointerCast(r.bcx, r.val, llty_value.ptr_to()))\n     } else {\n         // we treat ~fn, @fn and @[] as @ here, which isn't ideal\n-        let (mk_fn, langcall) = match heap {\n+        let langcall = match heap {\n             heap_managed | heap_managed_unique => {\n-                (ty::mk_imm_box,\n-                 require_alloc_fn(bcx, t, MallocFnLangItem))\n+                require_alloc_fn(bcx, t, MallocFnLangItem)\n             }\n             heap_exchange_closure => {\n-                (ty::mk_imm_box,\n-                 require_alloc_fn(bcx, t, ClosureExchangeMallocFnLangItem))\n+                require_alloc_fn(bcx, t, ClosureExchangeMallocFnLangItem)\n             }\n             _ => fail!(\"heap_exchange already handled\")\n         };\n \n         // Grab the TypeRef type of box_ptr_ty.\n-        let box_ptr_ty = mk_fn(bcx.tcx(), t);\n+        let box_ptr_ty = ty::mk_box(bcx.tcx(), t);\n         let llty = type_of(ccx, box_ptr_ty);\n \n         // Get the tydesc for the body:"}, {"sha": "d371637e1a76c2e10e07c34c665b56348223d1cd", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -131,11 +131,6 @@ impl EnvValue {\n     }\n }\n \n-pub fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n-    let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    return ty::mk_imm_uniq(tcx, cbox_ty);\n-}\n-\n // Given a closure ty, emits a corresponding tuple ty\n pub fn mk_closure_tys(tcx: ty::ctxt,\n                       bound_values: &[EnvValue])"}, {"sha": "35414162a27ac48396fd83c2615dc8b93ae2bbf2", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -569,7 +569,7 @@ impl Datum {\n \n         let (content_ty, header) = match ty::get(self.ty).sty {\n             ty::ty_box(typ) => (typ, true),\n-            ty::ty_uniq(mt) => (mt.ty, false),\n+            ty::ty_uniq(typ) => (typ, false),\n             ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n                 let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);\n                 let unboxed_vec_ty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);"}, {"sha": "97bcf92fcc9ffa678913c2eb2c77798b58139a8e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -2164,12 +2164,15 @@ fn type_metadata(cx: &CrateContext,\n                 }\n             }\n         },\n-        ty::ty_uniq(ref mt) if ty::type_contents(cx.tcx, mt.ty).owns_managed() => {\n-            create_pointer_to_box_metadata(cx, t, mt.ty)\n-        },\n-        ty::ty_uniq(ref mt)    |\n-        ty::ty_ptr(ref mt)     |\n-        ty::ty_rptr(_, ref mt) => {\n+        ty::ty_uniq(typ) => {\n+            if ty::type_contents(cx.tcx, typ).owns_managed() {\n+                create_pointer_to_box_metadata(cx, t, typ)\n+            } else {\n+                let pointee = type_metadata(cx, typ, usage_site_span);\n+                pointer_type_metadata(cx, t, pointee)\n+            }\n+        }\n+        ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n             let pointee = type_metadata(cx, mt.ty, usage_site_span);\n             pointer_type_metadata(cx, t, pointee)\n         },\n@@ -2193,7 +2196,7 @@ fn type_metadata(cx: &CrateContext,\n \n     let mut created_types = debug_context(cx).created_types.borrow_mut();\n     created_types.get().insert(cache_id, type_metadata);\n-    return type_metadata;\n+    type_metadata\n }\n \n #[deriving(Eq)]"}, {"sha": "4b09da4ddde1ad8987bf16212be30a6a826edf69", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -108,22 +108,26 @@ fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     }\n \n     if field == abi::tydesc_field_take_glue && ty::type_is_boxed(t) {\n-        return ty::mk_imm_box(tcx, ty::mk_nil());\n+        return ty::mk_box(tcx, ty::mk_nil());\n     }\n \n     if field == abi::tydesc_field_drop_glue {\n         match ty::get(t).sty {\n             ty::ty_box(typ)\n                 if !ty::type_needs_drop(tcx, typ) =>\n-            return ty::mk_imm_box(tcx, ty::mk_nil()),\n+            return ty::mk_box(tcx, ty::mk_nil()),\n \n             ty::ty_vec(mt, ty::vstore_box)\n                 if !ty::type_needs_drop(tcx, mt.ty) =>\n-            return ty::mk_imm_box(tcx, ty::mk_nil()),\n+            return ty::mk_box(tcx, ty::mk_nil()),\n \n-            ty::ty_uniq(mt) | ty::ty_vec(mt, ty::vstore_uniq)\n+            ty::ty_uniq(typ)\n+                if !ty::type_needs_drop(tcx, typ) =>\n+            return ty::mk_uniq(tcx, ty::mk_nil()),\n+\n+            ty::ty_vec(mt, ty::vstore_uniq)\n                 if !ty::type_needs_drop(tcx, mt.ty) =>\n-            return ty::mk_imm_uniq(tcx, ty::mk_nil()),\n+            return ty::mk_uniq(tcx, ty::mk_nil()),\n \n             _ => {}\n         }"}, {"sha": "e8d9015e860f985dc4f133a1364e919eddbb084b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -176,6 +176,7 @@ impl<'a> Reflector<'a> {\n               self.visit(\"vec\", values)\n           }\n \n+          // Should rename to str_*/vec_*.\n           ty::ty_str(vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               self.visit(~\"estr_\" + name, extra)\n@@ -189,15 +190,19 @@ impl<'a> Reflector<'a> {\n                   self.visit(~\"evec_\" + name, extra)\n               }\n           }\n+          // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n               let extra = self.c_mt(&ty::mt {\n                   ty: typ,\n                   mutbl: ast::MutImmutable,\n               });\n               self.visit(\"box\", extra)\n           }\n-          ty::ty_uniq(ref mt) => {\n-              let extra = self.c_mt(mt);\n+          ty::ty_uniq(typ) => {\n+              let extra = self.c_mt(&ty::mt {\n+                  ty: typ,\n+                  mutbl: ast::MutImmutable,\n+              });\n               if ty::type_contents(bcx.tcx(), t).owns_managed() {\n                   self.visit(\"uniq_managed\", extra)\n               } else {"}, {"sha": "9819f34c6f14b0e6b5b8060459c3ccb43afb551f", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -39,14 +39,14 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unit_ty = ty::sequence_element_type(tcx, t);\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n-      ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) => {\n-        ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n-      }\n-      ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n-        ty::mk_imm_box(tcx, unboxed_vec_ty)\n-      }\n-      _ => tcx.sess.bug(\"non boxed-vec type \\\n-                         in tvec::expand_boxed_vec_ty\")\n+        ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) => {\n+            ty::mk_uniq(tcx, unboxed_vec_ty)\n+        }\n+        ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n+            ty::mk_box(tcx, unboxed_vec_ty)\n+        }\n+        _ => tcx.sess.bug(\"non boxed-vec type \\\n+                           in tvec::expand_boxed_vec_ty\")\n     }\n }\n "}, {"sha": "2fc35f379ba0b0124a385cbee2c2d386c32bb734", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -244,9 +244,9 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let ty = type_of(cx, typ);\n           Type::smart_ptr(cx, &ty).ptr_to()\n       }\n-      ty::ty_uniq(ref mt) => {\n-          let ty = type_of(cx, mt.ty);\n-          if ty::type_contents(cx.tcx, mt.ty).owns_managed() {\n+      ty::ty_uniq(typ) => {\n+          let ty = type_of(cx, typ);\n+          if ty::type_contents(cx.tcx, typ).owns_managed() {\n               Type::unique(cx, &ty).ptr_to()\n           } else {\n               ty.ptr_to()"}, {"sha": "0b6a18dd7e1697de2ff6c78f7cd88e8a1cfe7c73", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Logic relating to rooting and write guards for managed values\n-//! (`@` and `@mut`). This code is primarily for use by datum;\n+//! Logic relating to rooting and write guards for managed values.\n+//! This code is primarily for use by datum;\n //! it exists in its own module both to keep datum.rs bite-sized\n //! and for each in debugging (e.g., so you can use\n //! `RUST_LOG=rustc::middle::trans::write_guard`)."}, {"sha": "fd3bf0deae799d59fc0d7fa31dd20f49b8ab4dad", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -629,7 +629,7 @@ pub enum sty {\n     ty_str(vstore),\n     ty_enum(DefId, substs),\n     ty_box(t),\n-    ty_uniq(mt),\n+    ty_uniq(t),\n     ty_vec(mt, vstore),\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n@@ -1091,8 +1091,10 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n               _ => {}\n           }\n       }\n-      &ty_box(ref tt) => flags |= get(*tt).flags,\n-      &ty_uniq(ref m) | &ty_vec(ref m, _) | &ty_ptr(ref m) |\n+      &ty_box(tt) | &ty_uniq(tt) => {\n+        flags |= get(tt).flags\n+      }\n+      &ty_vec(ref m, _) | &ty_ptr(ref m) |\n       &ty_unboxed_vec(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n@@ -1234,15 +1236,7 @@ pub fn mk_enum(cx: ctxt, did: ast::DefId, substs: substs) -> t {\n \n pub fn mk_box(cx: ctxt, ty: t) -> t { mk_t(cx, ty_box(ty)) }\n \n-pub fn mk_imm_box(cx: ctxt, ty: t) -> t {\n-    mk_box(cx, ty)\n-}\n-\n-pub fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n-\n-pub fn mk_imm_uniq(cx: ctxt, ty: t) -> t {\n-    mk_uniq(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n-}\n+pub fn mk_uniq(cx: ctxt, ty: t) -> t { mk_t(cx, ty_uniq(ty)) }\n \n pub fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n@@ -1355,9 +1349,9 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n       ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str(_) | ty_type | ty_self(_) |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {}\n-      ty_box(ref ty) => maybe_walk_ty(*ty, f),\n+      ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n       ty_vec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n-      ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n+      ty_rptr(_, ref tm) => {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n@@ -2026,6 +2020,10 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 tc_ty(cx, typ, cache).managed_pointer()\n             }\n \n+            ty_uniq(typ) => {\n+                tc_ty(cx, typ, cache).owned_pointer()\n+            }\n+\n             ty_trait(_, _, store, mutbl, bounds) => {\n                 object_contents(cx, store, mutbl, bounds)\n             }\n@@ -2039,10 +2037,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                     borrowed_contents(r, mt.mutbl))\n             }\n \n-            ty_uniq(mt) => {\n-                tc_mt(cx, mt, cache).owned_pointer()\n-            }\n-\n             ty_vec(mt, vstore_uniq) => {\n                 tc_mt(cx, mt, cache).owned_pointer()\n             }\n@@ -2318,10 +2312,9 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_unboxed_vec(_) => {\n                 false\n             }\n-            ty_box(typ) => {\n+            ty_box(typ) | ty_uniq(typ) => {\n                 type_requires(cx, seen, r_ty, typ)\n             }\n-            ty_uniq(ref mt) |\n             ty_rptr(_, ref mt) => {\n                 type_requires(cx, seen, r_ty, mt.ty)\n             }\n@@ -2596,22 +2589,22 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n \n pub fn deref_sty(sty: &sty, explicit: bool) -> Option<mt> {\n     match *sty {\n-      ty_box(typ) => {\n-        Some(mt {\n-          ty: typ,\n-          mutbl: ast::MutImmutable,\n-        })\n-      }\n+        ty_box(typ) | ty_uniq(typ) => {\n+            Some(mt {\n+                ty: typ,\n+                mutbl: ast::MutImmutable,\n+            })\n+        }\n \n-      ty_rptr(_, mt) | ty_uniq(mt) => {\n-        Some(mt)\n-      }\n+        ty_rptr(_, mt) => {\n+            Some(mt)\n+        }\n \n-      ty_ptr(mt) if explicit => {\n-        Some(mt)\n-      }\n+        ty_ptr(mt) if explicit => {\n+            Some(mt)\n+        }\n \n-      _ => None\n+        _ => None\n     }\n }\n \n@@ -4861,9 +4854,8 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n             ty_box(_) => {\n                 hash.input([9]);\n             }\n-            ty_uniq(m) => {\n+            ty_uniq(_) => {\n                 hash.input([10]);\n-                mt(&mut hash, m);\n             }\n             ty_vec(m, v) => {\n                 hash.input([11]);"}, {"sha": "28ba566c0a4ab5063594303b8a2a03ea3d69e8e3", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -143,8 +143,8 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_box(typ) => {\n             ty::ty_box(this.fold_ty(typ))\n         }\n-        ty::ty_uniq(ref tm) => {\n-            ty::ty_uniq(this.fold_mt(tm))\n+        ty::ty_uniq(typ) => {\n+            ty::ty_uniq(this.fold_ty(typ))\n         }\n         ty::ty_ptr(ref tm) => {\n             ty::ty_ptr(this.fold_mt(tm))"}, {"sha": "3b787581e158d4ad1099bd603907dcec43d37585", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -410,7 +410,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n       ast::TyUniq(ty) => {\n         let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n         mk_pointer(this, rscope, &mt, ty::vstore_uniq,\n-                   |tmt| ty::mk_uniq(tcx, tmt))\n+                   |tmt| ty::mk_uniq(tcx, tmt.ty))\n       }\n       ast::TyVec(ty) => {\n         tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n@@ -691,13 +691,11 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n-            ast::SelfBox(_) => {\n+            ast::SelfBox => {\n                 Some(ty::mk_box(this.tcx(), self_info.untransformed_self_ty))\n             }\n             ast::SelfUniq(_) => {\n-                Some(ty::mk_uniq(this.tcx(),\n-                                 ty::mt {ty: self_info.untransformed_self_ty,\n-                                         mutbl: ast::MutImmutable}))\n+                Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty))\n             }\n         }\n     }"}, {"sha": "9303bf80208a7843b8941c276c6dda5f920a94c3", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -670,7 +670,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n     };\n     match *structure_of(fcx, span, expected) {\n         ty::ty_uniq(e_inner) if pointer_kind == Send => {\n-            check_inner(e_inner.ty);\n+            check_inner(e_inner);\n         }\n         ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed => {\n             check_inner(e_inner.ty);"}, {"sha": "3c0849f04b8e79ea52aaed1d1a1ab533590eb792", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -623,9 +623,9 @@ impl<'a> LookupContext<'a> {\n          * consuming the original pointer.\n          *\n          * You might think that this would be a natural byproduct of\n-         * the auto-deref/auto-ref process.  This is true for `@mut T`\n-         * but not for an `&mut T` receiver.  With `@mut T`, we would\n-         * begin by testing for methods with a self type `@mut T`,\n+         * the auto-deref/auto-ref process.  This is true for `~T`\n+         * but not for an `&mut T` receiver.  With `~T`, we would\n+         * begin by testing for methods with a self type `~T`,\n          * then autoderef to `T`, then autoref to `&mut T`.  But with\n          * an `&mut T` receiver the process begins with `&mut T`, only\n          * without any autoadjustments.\n@@ -1057,15 +1057,15 @@ impl<'a> LookupContext<'a> {\n          *\n          *     trait Foo {\n          *         fn r_method<'a>(&'a self);\n-         *         fn m_method(@mut self);\n+         *         fn u_method(~self);\n          *     }\n          *\n          * Now, assuming that `r_method` is being called, we want the\n-         * result to be `&'a Foo`. Assuming that `m_method` is being\n-         * called, we want the result to be `@mut Foo`. Of course,\n+         * result to be `&'a Foo`. Assuming that `u_method` is being\n+         * called, we want the result to be `~Foo`. Of course,\n          * this transformation has already been done as part of\n-         * `method_ty.transformed_self_ty`, but there the\n-         * type is expressed in terms of `Self` (i.e., `&'a Self`, `@mut Self`).\n+         * `method_ty.transformed_self_ty`, but there the type\n+         * is expressed in terms of `Self` (i.e., `&'a Self`, `~Self`).\n          * Because objects are not standalone types, we can't just substitute\n          * `s/Self/Foo/`, so we must instead perform this kind of hokey\n          * match below.\n@@ -1081,7 +1081,7 @@ impl<'a> LookupContext<'a> {\n             ast::SelfValue(_) => {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n             }\n-            ast::SelfRegion(..) | ast::SelfBox(..) | ast::SelfUniq(..) => {\n+            ast::SelfRegion(..) | ast::SelfBox | ast::SelfUniq(..) => {\n                 let transformed_self_ty =\n                     method_ty.transformed_self_ty.clone().unwrap();\n                 match ty::get(transformed_self_ty).sty {\n@@ -1095,9 +1095,9 @@ impl<'a> LookupContext<'a> {\n                                      substs, BoxTraitStore, ast::MutImmutable,\n                                      ty::EmptyBuiltinBounds())\n                     }\n-                    ty::ty_uniq(mt) => { // must be SelfUniq\n+                    ty::ty_uniq(_) => { // must be SelfUniq\n                         ty::mk_trait(self.tcx(), trait_def_id,\n-                                     substs, UniqTraitStore, mt.mutbl,\n+                                     substs, UniqTraitStore, ast::MutImmutable,\n                                      ty::EmptyBuiltinBounds())\n                     }\n                     _ => {\n@@ -1144,7 +1144,7 @@ impl<'a> LookupContext<'a> {\n                      through an object\");\n             }\n \n-            ast::SelfRegion(..) | ast::SelfBox(..) | ast::SelfUniq(..) => {}\n+            ast::SelfRegion(..) | ast::SelfBox | ast::SelfUniq(..) => {}\n         }\n \n         if ty::type_has_self(method_fty) { // reason (a) above\n@@ -1219,15 +1219,14 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfBox(m) => {\n+            SelfBox => {\n                 debug!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(typ) => {\n                         rcvr_matches_ty(self.fcx, typ, candidate)\n                     }\n \n-                    ty::ty_trait(self_did, _, BoxTraitStore, self_m, _) => {\n-                        mutability_matches(self_m, m) &&\n+                    ty::ty_trait(self_did, _, BoxTraitStore, ast::MutImmutable, _) => {\n                         rcvr_matches_object(self_did, candidate)\n                     }\n \n@@ -1238,8 +1237,8 @@ impl<'a> LookupContext<'a> {\n             SelfUniq(_) => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n-                    ty::ty_uniq(mt) => {\n-                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    ty::ty_uniq(typ) => {\n+                        rcvr_matches_ty(self.fcx, typ, candidate)\n                     }\n \n                     ty::ty_trait(self_did, _, UniqTraitStore, _, _) => {"}, {"sha": "1f643cfc80cc392e09cf0765f6227b6ade8fff90", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -1334,7 +1334,7 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n \n         // Some extra checks to detect weird cycles and so forth:\n         match *sty {\n-            ty::ty_box(inner) => {\n+            ty::ty_box(inner) | ty::ty_uniq(inner) => {\n                 match ty::get(t1).sty {\n                     ty::ty_infer(ty::TyVar(v1)) => {\n                         ty::occurs_check(fcx.ccx.tcx, sp, v1,\n@@ -1343,7 +1343,7 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n                     _ => ()\n                 }\n             }\n-            ty::ty_uniq(inner) | ty::ty_rptr(_, inner) => {\n+            ty::ty_rptr(_, inner) => {\n                 match ty::get(t1).sty {\n                     ty::ty_infer(ty::TyVar(v1)) => {\n                         ty::occurs_check(fcx.ccx.tcx, sp, v1,\n@@ -2697,10 +2697,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                   let def_id = ast_util::def_id_of_def(definition);\n                   match tcx.lang_items.items[ExchangeHeapLangItem as uint] {\n                       Some(item_def_id) if def_id == item_def_id => {\n-                          fcx.write_ty(id, ty::mk_uniq(tcx, ty::mt {\n-                              ty: fcx.expr_ty(subexpr),\n-                              mutbl: ast::MutImmutable,\n-                          }));\n+                          fcx.write_ty(id, ty::mk_uniq(tcx,\n+                                                       fcx.expr_ty(subexpr)));\n                           checked = true\n                       }\n                       Some(_) | None => {}\n@@ -2806,13 +2804,12 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n       ast::ExprUnary(callee_id, unop, oprnd) => {\n         let exp_inner = unpack_expected(fcx, expected, |sty| {\n             match unop {\n-              ast::UnBox | ast::UnUniq => match *sty {\n-                ty::ty_box(ty) => Some(ty),\n-                ty::ty_uniq(ref mt) => Some(mt.ty),\n-                _ => None\n-              },\n-              ast::UnNot | ast::UnNeg => expected,\n-              ast::UnDeref => None\n+                ast::UnBox | ast::UnUniq => match *sty {\n+                    ty::ty_box(ty) | ty::ty_uniq(ty) => Some(ty),\n+                    _ => None\n+                },\n+                ast::UnNot | ast::UnNeg => expected,\n+                ast::UnDeref => None\n             }\n         });\n         check_expr_with_opt_hint(fcx, oprnd, exp_inner);\n@@ -2824,9 +2821,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                     oprnd_t = ty::mk_box(tcx, oprnd_t)\n                 }\n                 ast::UnUniq => {\n-                    oprnd_t = ty::mk_uniq(tcx,\n-                                          ty::mt {ty: oprnd_t,\n-                                                  mutbl: ast::MutImmutable});\n+                    oprnd_t = ty::mk_uniq(tcx, oprnd_t);\n                 }\n                 ast::UnDeref => {\n                     let sty = structure_of(fcx, expr.span, oprnd_t);"}, {"sha": "5dbcae7418bc6f2296e0358d5e75a4cc4f32a23a", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -582,14 +582,14 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n               let ty = structurally_resolved_type(fcx, ex.span,\n                                                   fcx.expr_ty(src));\n               match (&ty::get(ty).sty, store) {\n-                  (&ty::ty_box(..), ty::BoxTraitStore)\n+                  (&ty::ty_box(..), ty::BoxTraitStore) |\n+                  (&ty::ty_uniq(..), ty::UniqTraitStore)\n                     if !mutability_allowed(ast::MutImmutable,\n                                            target_mutbl) => {\n                       fcx.tcx().sess.span_err(ex.span,\n                                               format!(\"types differ in mutability\"));\n                   }\n \n-                  (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n                   (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..))\n                     if !mutability_allowed(mt.mutbl, target_mutbl) => {\n                       fcx.tcx().sess.span_err(ex.span,\n@@ -600,8 +600,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n                   (&ty::ty_uniq(..), ty::UniqTraitStore) |\n                   (&ty::ty_rptr(..), ty::RegionTraitStore(..)) => {\n                     let typ = match (&ty::get(ty).sty) {\n-                        &ty::ty_box(typ) => typ,\n-                        &ty::ty_uniq(mt) | &ty::ty_rptr(_, mt) => mt.ty,\n+                        &ty::ty_box(typ) | &ty::ty_uniq(typ) => typ,\n+                        &ty::ty_rptr(_, mt) => mt.ty,\n                         _ => fail!(\"shouldn't get here\"),\n                     };\n "}, {"sha": "5008dd8a0dbc57c609371e93415f71eee7f21112", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -245,8 +245,7 @@ impl Coerce {\n         let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n \n         let inner_ty = match *sty_a {\n-            ty::ty_box(typ) => typ,\n-            ty::ty_uniq(mt_a) => mt_a.ty,\n+            ty::ty_box(typ) | ty::ty_uniq(typ) => typ,\n             ty::ty_rptr(_, mt_a) => mt_a.ty,\n             _ => {\n                 return self.subtype(a, b);"}, {"sha": "e5d9ee97098140f6b31b1aae34bb234c04c725c8", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -521,8 +521,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         this.tys(a_inner, b_inner).and_then(|typ| Ok(ty::mk_box(tcx, typ)))\n       }\n \n-      (&ty::ty_uniq(ref a_mt), &ty::ty_uniq(ref b_mt)) => {\n-        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_uniq(tcx, mt)))\n+      (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n+        this.tys(a_inner, b_inner).and_then(|typ| Ok(ty::mk_uniq(tcx, typ)))\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {"}, {"sha": "1db05f16875865ab5b21dfef00e72814bb1826b6", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -634,11 +634,10 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n-            ty::ty_box(typ) => {\n+            ty::ty_uniq(typ) | ty::ty_box(typ) => {\n                 self.add_constraints_from_ty(typ, variance);\n             }\n \n-            ty::ty_uniq(ref mt) |\n             ty::ty_ptr(ref mt) => {\n                 self.add_constraints_from_mt(mt, variance);\n             }"}, {"sha": "213b4ebf257ec2055f7a3e88bea165eb91a0ae74", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -455,7 +455,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_uint(t) => ast_util::uint_ty_to_str(t),\n       ty_float(t) => ast_util::float_ty_to_str(t),\n       ty_box(typ) => ~\"@\" + ty_to_str(cx, typ),\n-      ty_uniq(ref tm) => ~\"~\" + mt_to_str(cx, tm),\n+      ty_uniq(typ) => ~\"~\" + ty_to_str(cx, typ),\n       ty_ptr(ref tm) => ~\"*\" + mt_to_str(cx, tm),\n       ty_rptr(r, ref tm) => {\n         region_ptr_to_str(cx, r) + mt_to_str(cx, tm)"}, {"sha": "e48c0800506f90bd9cf359efb03efb1dfdc4d290", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -377,7 +377,7 @@ pub enum SelfTy {\n     SelfStatic,\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n-    SelfManaged(Mutability),\n+    SelfManaged,\n     SelfOwned,\n }\n \n@@ -388,7 +388,7 @@ impl Clean<SelfTy> for ast::ExplicitSelf {\n             ast::SelfValue(_) => SelfValue,\n             ast::SelfUniq(_) => SelfOwned,\n             ast::SelfRegion(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n-            ast::SelfBox(mt) => SelfManaged(mt.clean()),\n+            ast::SelfBox => SelfManaged,\n         }\n     }\n }"}, {"sha": "e84b5bafaa83e52027e283f2decde54db2cba272", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -405,8 +405,7 @@ impl<'a> fmt::Default for Method<'a> {\n             clean::SelfStatic => {},\n             clean::SelfValue => args.push_str(\"self\"),\n             clean::SelfOwned => args.push_str(\"~self\"),\n-            clean::SelfManaged(clean::Mutable) => args.push_str(\"@mut self\"),\n-            clean::SelfManaged(clean::Immutable) => args.push_str(\"@self\"),\n+            clean::SelfManaged => args.push_str(\"@self\"),\n             clean::SelfBorrowed(Some(ref lt), clean::Immutable) => {\n                 args.push_str(format!(\"&amp;{} self\", *lt));\n             }"}, {"sha": "4e6f64a31e62fc725caf2b29364dde547bc2923f", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -370,13 +370,13 @@ mod test {\n             count: 0,\n         };\n         // FIXME (#7049): Figure out some other way to do this.\n-        //let buf = @mut ~[8, 9];\n+        //let buf = RefCell::new(~[8, 9]);\n         (|| {\n-            //reader.push_bytes(&mut *buf, 4);\n+            //reader.push_bytes(buf.borrow_mut().get(), 4);\n         }).finally(|| {\n             // NB: Using rtassert here to trigger abort on failure since this is a should_fail test\n             // FIXME: #7049 This fails because buf is still borrowed\n-            //rtassert!(*buf == ~[8, 9, 10]);\n+            //rtassert!(buf.borrow().get() == ~[8, 9, 10]);\n         })\n     }\n "}, {"sha": "159337bf5033562dd62dd4cb4b8238776012ddfa", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -187,8 +187,7 @@ pub fn get<T: 'static, U>(key: Key<T>, f: |Option<&T>| -> U) -> U {\n /// if the key provided is not present in TLS currently.\n ///\n /// It is considered a runtime error to attempt to get a value which is already\n-/// on loan via this or the `get` methods. This is similar to how it's a runtime\n-/// error to take two mutable loans on an `@mut` box.\n+/// on loan via this or the `get` methods.\n pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n     get_with(key, MutLoan, |x| {\n         match x {"}, {"sha": "61e78b68adcec8d41036ba89bf80e2d43e0fdb11", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -1837,11 +1837,8 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. There exists the possibility that this\n-            // vector is contained with an `@mut` box and hence is still\n-            // readable by the outside world during the `Eq` comparisons.\n-            // Moreover, those comparisons could fail, so we must ensure\n-            // that the vector is in a valid state at all time.\n+            // *arbitrary* changes. The `Eq` comparisons could fail, so we\n+            // must ensure that the vector is in a valid state at all time.\n             //\n             // The way that we handle this is by using swaps; we iterate\n             // over all the elements, swapping as we go so that at the end"}, {"sha": "b113308ca51512432fbbde8aaf5f33440e26e63e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -959,10 +959,10 @@ pub enum RetStyle {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum ExplicitSelf_ {\n     SelfStatic,                                // no self\n-    SelfValue(Mutability),                     // `self`\n-    SelfRegion(Option<Lifetime>, Mutability),  // `&'lt self`\n-    SelfBox(Mutability),                       // `@self`\n-    SelfUniq(Mutability)                       // `~self`\n+    SelfValue(Mutability),                     // `self`, `mut self`\n+    SelfRegion(Option<Lifetime>, Mutability),  // `&'lt self`, `&'lt mut self`\n+    SelfBox,                                   // `@self`\n+    SelfUniq(Mutability)                       // `~self`, `mut ~self`\n }\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;"}, {"sha": "c2b32b45ce45b2f4d6a0d5216cf187816ed5a3a7", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -251,7 +251,7 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n                 span,\n                 match *ptr {\n                     Send => ast::SelfUniq(ast::MutImmutable),\n-                    Managed => ast::SelfBox(ast::MutImmutable),\n+                    Managed => ast::SelfBox,\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s)));\n                         ast::SelfRegion(lt, mutbl)"}, {"sha": "35b29783b674815fbea99babd139ee9e645f6e3a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -319,7 +319,7 @@ pub trait Folder {\n \n     fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n         match *es {\n-            SelfStatic | SelfValue(_) | SelfUniq(_) | SelfBox(_) => {\n+            SelfStatic | SelfValue(_) | SelfUniq(_) | SelfBox => {\n                 *es\n             }\n             SelfRegion(ref lifetime, m) => {"}, {"sha": "6945eea285d059b7499c678f67a1dbb8a8200aaf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 41, "deletions": 57, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -142,8 +142,6 @@ at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr (\n     ($p:expr) => (\n         {\n-            // This horrible convolution is brought to you by\n-            // @mut, have a terrible day\n             let mut maybe_path = match ($p).token {\n                 INTERPOLATED(token::NtPath(ref pt)) => Some((**pt).clone()),\n                 _ => None,\n@@ -3647,20 +3645,14 @@ impl Parser {\n     // that may have a self type.\n     fn parse_fn_decl_with_self(&mut self, parse_arg_fn: |&mut Parser| -> Arg)\n                                -> (ExplicitSelf, P<FnDecl>) {\n-        fn maybe_parse_explicit_self(cnstr: |v: Mutability| ->\n-                                        ast::ExplicitSelf_,\n+        fn maybe_parse_explicit_self(explicit_self: ast::ExplicitSelf_,\n                                      p: &mut Parser)\n                                      -> ast::ExplicitSelf_ {\n             // We need to make sure it isn't a type\n-            if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) ||\n-                ((p.look_ahead(1, |t| token::is_keyword(keywords::Const, t)) ||\n-                  p.look_ahead(1, |t| token::is_keyword(keywords::Mut, t))) &&\n-                 p.look_ahead(2, |t| token::is_keyword(keywords::Self, t))) {\n-\n+            if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                 p.bump();\n-                let mutability = p.parse_mutability();\n                 p.expect_self_ident();\n-                cnstr(mutability)\n+                explicit_self\n             } else {\n                 SelfStatic\n             }\n@@ -3719,55 +3711,47 @@ impl Parser {\n         // backwards compatible.\n         let lo = self.span.lo;\n         let explicit_self = match self.token {\n-          token::BINOP(token::AND) => {\n-            maybe_parse_borrowed_explicit_self(self)\n-          }\n-          token::AT => {\n-            maybe_parse_explicit_self(SelfBox, self)\n-          }\n-          token::TILDE => {\n-            maybe_parse_explicit_self(|mutability| {\n-                if mutability != MutImmutable {\n-                    self.span_err(self.last_span,\n-                                  \"mutability declaration not allowed here\");\n+            token::BINOP(token::AND) => {\n+                maybe_parse_borrowed_explicit_self(self)\n+            }\n+            token::AT => {\n+                maybe_parse_explicit_self(SelfBox, self)\n+            }\n+            token::TILDE => {\n+                maybe_parse_explicit_self(SelfUniq(MutImmutable), self)\n+            }\n+            token::IDENT(..) if self.is_self_ident() => {\n+                self.bump();\n+                SelfValue(MutImmutable)\n+            }\n+            token::BINOP(token::STAR) => {\n+                // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n+                // emitting cryptic \"unexpected token\" errors.\n+                self.bump();\n+                let mutability = if Parser::token_is_mutability(&self.token) {\n+                    self.parse_mutability()\n+                } else { MutImmutable };\n+                if self.is_self_ident() {\n+                    self.span_err(self.span, \"cannot pass self by unsafe pointer\");\n+                    self.bump();\n                 }\n-                SelfUniq(MutImmutable)\n-            }, self)\n-          }\n-          token::IDENT(..) if self.is_self_ident() => {\n-            self.bump();\n-            SelfValue(MutImmutable)\n-          }\n-          token::BINOP(token::STAR) => {\n-            // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n-            // emitting cryptic \"unexpected token\" errors.\n-            self.bump();\n-            let mutability = if Parser::token_is_mutability(&self.token) {\n-                self.parse_mutability()\n-            } else { MutImmutable };\n-            if self.is_self_ident() {\n-                self.span_err(self.span, \"cannot pass self by unsafe pointer\");\n+                SelfValue(mutability)\n+            }\n+            _ if Parser::token_is_mutability(&self.token) &&\n+                    self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n+                let mutability = self.parse_mutability();\n+                self.expect_self_ident();\n+                SelfValue(mutability)\n+            }\n+            _ if Parser::token_is_mutability(&self.token) &&\n+                    self.look_ahead(1, |t| *t == token::TILDE) &&\n+                    self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n+                let mutability = self.parse_mutability();\n                 self.bump();\n+                self.expect_self_ident();\n+                SelfUniq(mutability)\n             }\n-            SelfValue(mutability)\n-          }\n-          _ if Parser::token_is_mutability(&self.token) &&\n-               self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n-            let mutability = self.parse_mutability();\n-            self.expect_self_ident();\n-            SelfValue(mutability)\n-          }\n-          _ if Parser::token_is_mutability(&self.token) &&\n-               self.look_ahead(1, |t| *t == token::TILDE) &&\n-               self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n-            let mutability = self.parse_mutability();\n-            self.bump();\n-            self.expect_self_ident();\n-            SelfUniq(mutability)\n-          }\n-          _ => {\n-            SelfStatic\n-          }\n+            _ => SelfStatic\n         };\n \n         // If we parsed a self type, expect a comma before the argument list."}, {"sha": "02c7b3f2086d1e89b8ce104ce01d895faa0c6a20", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -1770,8 +1770,8 @@ pub fn print_explicit_self(s: &mut State, explicit_self: ast::ExplicitSelf_) ->\n             print_mutability(s, m);\n             word(&mut s.s, \"self\");\n         }\n-        ast::SelfBox(m) => {\n-            word(&mut s.s, \"@\"); print_mutability(s, m); word(&mut s.s, \"self\");\n+        ast::SelfBox => {\n+            word(&mut s.s, \"@self\");\n         }\n     }\n     return true;"}, {"sha": "d79522b7103829e4f1acaadfb74c5995a1b98e3f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -175,7 +175,7 @@ fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                explicit_self: &ExplicitSelf,\n                                                env: E) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue(_) | SelfBox(_) | SelfUniq(_) => {}\n+        SelfStatic | SelfValue(_) | SelfBox | SelfUniq(_) => {}\n         SelfRegion(ref lifetime, _) => {\n             visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n         }"}, {"sha": "8fb9c5e0e6f840b561f5edb348de210e47b1be94", "filename": "src/test/compile-fail/removed-syntax-uniq-self.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9075025c7b48ffc028b3bddbb983ceac98ce9636/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs?ref=9075025c7b48ffc028b3bddbb983ceac98ce9636", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,5 +11,6 @@\n struct S;\n \n impl S {\n-    fn f(~mut self) {} //~ ERROR mutability declaration not allowed here\n+    fn f(~mut self) {} //~ ERROR found `self` in ident position\n+    //~^ ERROR expected `:` but found `)`\n }"}]}