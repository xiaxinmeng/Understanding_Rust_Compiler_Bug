{"sha": "07cdb853317697c247b41e61f7a429c3fb623524", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3Y2RiODUzMzE3Njk3YzI0N2I0MWU2MWY3YTQyOWMzZmI2MjM1MjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-10T16:54:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-28T10:15:23Z"}, "message": "Move return type an associated type of the `Fn*` traits. Mostly this involves tweaking things in\nthe compiler that assumed two input types to assume two ouputs; we also have to teach `project.rs`\nto project `Output` from the unboxed closure and fn traits.", "tree": {"sha": "4b44f3fb2fa20220413aea7b6c844a5b99e9a196", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b44f3fb2fa20220413aea7b6c844a5b99e9a196"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07cdb853317697c247b41e61f7a429c3fb623524", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07cdb853317697c247b41e61f7a429c3fb623524", "html_url": "https://github.com/rust-lang/rust/commit/07cdb853317697c247b41e61f7a429c3fb623524", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07cdb853317697c247b41e61f7a429c3fb623524/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c61d7889b4bb270102dafe54cdfffbd737d168ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c61d7889b4bb270102dafe54cdfffbd737d168ff", "html_url": "https://github.com/rust-lang/rust/commit/c61d7889b4bb270102dafe54cdfffbd737d168ff"}], "stats": {"total": 497, "additions": 361, "deletions": 136}, "files": [{"sha": "a090e4f24ce1d35ba16d7827e1f270fb8e6c2f0d", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -758,7 +758,9 @@ mod test {\n         expected: &'b [int],\n     }\n \n-    impl<'a, 'b, 'c> FnMut(&'c int) -> bool for Counter<'a, 'b> {\n+    impl<'a, 'b, 'c> FnMut<(&'c int,)> for Counter<'a, 'b> {\n+        type Output = bool;\n+\n         extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c int,)) -> bool {\n             assert_eq!(x, self.expected[*self.i]);\n             *self.i += 1;"}, {"sha": "0e99a2c9c3e1b2e8fc20683ade769707d79ccbd9", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -1117,29 +1117,33 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-pub trait Fn<Args,Result> {\n+#[cfg(stage0)]\n+pub trait Fn<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call(&self, args: Args) -> Result;\n+    extern \"rust-call\" fn call(&self, args: Args) -> Output;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-pub trait FnMut<Args,Result> {\n+#[cfg(stage0)]\n+pub trait FnMut<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Result;\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Output;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n-pub trait FnOnce<Args,Result> {\n+#[cfg(stage0)]\n+pub trait FnOnce<Args,Output> {\n     /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Result;\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Output;\n }\n \n+#[cfg(stage0)]\n impl<F: ?Sized, A, R> FnMut<A, R> for F\n     where F : Fn<A, R>\n {\n@@ -1148,10 +1152,69 @@ impl<F: ?Sized, A, R> FnMut<A, R> for F\n     }\n }\n \n+#[cfg(stage0)]\n impl<F,A,R> FnOnce<A,R> for F\n     where F : FnMut<A,R>\n {\n     extern \"rust-call\" fn call_once(mut self, args: A) -> R {\n         self.call_mut(args)\n     }\n }\n+\n+/// A version of the call operator that takes an immutable receiver.\n+#[lang=\"fn\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait Fn<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a mutable receiver.\n+#[lang=\"fn_mut\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait FnMut<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+/// A version of the call operator that takes a by-value receiver.\n+#[lang=\"fn_once\"]\n+#[unstable(feature = \"core\",\n+           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[cfg(not(stage0))]\n+pub trait FnOnce<Args> {\n+    type Output;\n+\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[cfg(not(stage0))]\n+impl<F: ?Sized, A> FnMut<A> for F\n+    where F : Fn<A>\n+{\n+    type Output = <F as Fn<A>>::Output;\n+\n+    extern \"rust-call\" fn call_mut(&mut self, args: A) -> <F as Fn<A>>::Output {\n+        self.call(args)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<F,A> FnOnce<A> for F\n+    where F : FnMut<A>\n+{\n+    type Output = <F as FnMut<A>>::Output;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: A) -> <F as FnMut<A>>::Output {\n+        self.call_mut(args)\n+    }\n+}"}, {"sha": "101d349c3517084896bf207c22c8df28e055a539", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -461,13 +461,24 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n+#[cfg(stage0)]\n impl<'a> Fn(&'a u8) -> u8 for BytesDeref {\n     #[inline]\n     extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n         *ptr\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Fn<(&'a u8,)> for BytesDeref {\n+    type Output = u8;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n+        *ptr\n+    }\n+}\n+\n /// An iterator over the substrings of a string, separated by `sep`.\n #[derive(Clone)]\n struct CharSplits<'a, Sep> {"}, {"sha": "d1dd086a5a342b0adface7779e15ca9f60ff452f", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 169, "deletions": 68, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -18,13 +18,17 @@ use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableImplData;\n+use super::util;\n \n use middle::infer;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs};\n use middle::ty::{self, AsPredicate, ReferencesError, RegionEscape,\n                  HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use std::rc::Rc;\n+use syntax::ast;\n+use syntax::parse::token;\n+use util::common::FN_OUTPUT_NAME;\n use util::ppaux::Repr;\n \n pub type PolyProjectionObligation<'tcx> =\n@@ -53,6 +57,8 @@ pub struct MismatchedProjectionTypes<'tcx> {\n enum ProjectionTyCandidate<'tcx> {\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n+    Closure(ast::DefId, Substs<'tcx>),\n+    FnPointer(Ty<'tcx>),\n }\n \n struct ProjectionTyCandidateSet<'tcx> {\n@@ -486,20 +492,22 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n \n                 let is_match = same_name && infcx.probe(|_| {\n                     let origin = infer::Misc(obligation.cause.span);\n-                    let obligation_poly_trait_ref =\n-                        obligation_trait_ref.to_poly_trait_ref();\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n+                    let obligation_poly_trait_ref =\n+                        obligation_trait_ref.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n                                               origin,\n-                                              obligation_poly_trait_ref,\n-                                              data_poly_trait_ref).is_ok()\n+                                              data_poly_trait_ref,\n+                                              obligation_poly_trait_ref).is_ok()\n                 });\n \n-                if is_match {\n-                    debug!(\"assemble_candidates_from_predicates: candidate {}\",\n-                           data.repr(selcx.tcx()));\n+                debug!(\"assemble_candidates_from_predicates: candidate {} is_match {} same_name {}\",\n+                       data.repr(selcx.tcx()),\n+                       is_match,\n+                       same_name);\n \n+                if is_match {\n                     candidate_set.vec.push(\n                         ProjectionTyCandidate::ParamEnv(data.clone()));\n                 }\n@@ -573,6 +581,14 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n                 selcx, obligation, obligation_trait_ref, candidate_set,\n                 data.object_ty);\n         }\n+        super::VtableClosure(closure_def_id, substs) => {\n+            candidate_set.vec.push(\n+                ProjectionTyCandidate::Closure(closure_def_id, substs));\n+        }\n+        super::VtableFnPointer(fn_type) => {\n+            candidate_set.vec.push(\n+                ProjectionTyCandidate::FnPointer(fn_type));\n+        }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an\n             // associated type. Consider:\n@@ -600,9 +616,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // projection. And the projection where clause is handled\n             // in `assemble_candidates_from_param_env`.\n         }\n-        super::VtableBuiltin(..) |\n-        super::VtableClosure(..) |\n-        super::VtableFnPointer(..) => {\n+        super::VtableBuiltin(..) => {\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n@@ -628,67 +642,150 @@ fn confirm_candidate<'cx,'tcx>(\n \n     match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection) => {\n-            let projection =\n-                infcx.replace_late_bound_regions_with_fresh_var(\n-                    obligation.cause.span,\n-                    infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    &poly_projection).0;\n-\n-            assert_eq!(projection.projection_ty.item_name,\n-                       obligation.predicate.item_name);\n-\n-            let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n-            match infcx.sub_trait_refs(false,\n-                                       origin,\n-                                       obligation.predicate.trait_ref.clone(),\n-                                       projection.projection_ty.trait_ref.clone()) {\n-                Ok(()) => { }\n-                Err(e) => {\n-                    selcx.tcx().sess.span_bug(\n-                        obligation.cause.span,\n-                        format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n-                                obligation.repr(selcx.tcx()),\n-                                projection.repr(selcx.tcx()),\n-                                ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n-                }\n-            }\n-\n-            (projection.ty, vec!())\n+            confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n         ProjectionTyCandidate::Impl(impl_vtable) => {\n-            // there don't seem to be nicer accessors to these:\n-            let impl_items_map = selcx.tcx().impl_items.borrow();\n-            let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n-\n-            let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n-            let mut impl_ty = None;\n-            for impl_item in impl_items.iter() {\n-                let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n-                    ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n-                    ty::MethodTraitItem(..) => { continue; }\n-                };\n-\n-                if assoc_type.name != obligation.predicate.item_name {\n-                    continue;\n-                }\n+            confirm_impl_candidate(selcx, obligation, impl_vtable)\n+        }\n \n-                let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n-                impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n-                break;\n-            }\n+        ProjectionTyCandidate::Closure(def_id, substs) => {\n+            confirm_closure_candidate(selcx, obligation, def_id, &substs)\n+        }\n \n-            match impl_ty {\n-                Some(ty) => (ty, impl_vtable.nested.into_vec()),\n-                None => {\n-                    // This means that the impl is missing a\n-                    // definition for the associated type. This error\n-                    // ought to be reported by the type checker method\n-                    // `check_impl_items_against_trait`, so here we\n-                    // just return ty_err.\n-                    (selcx.tcx().types.err, vec!())\n-                }\n-            }\n+        ProjectionTyCandidate::FnPointer(fn_type) => {\n+            confirm_fn_pointer_candidate(selcx, obligation, fn_type)\n+        }\n+    }\n+}\n+\n+fn confirm_fn_pointer_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    fn_type: Ty<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let fn_type = selcx.infcx().shallow_resolve(fn_type);\n+    let sig = ty::ty_fn_sig(fn_type);\n+    confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n+}\n+\n+fn confirm_closure_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: &Substs<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let closure_typer = selcx.closure_typer();\n+    let closure_type = closure_typer.closure_type(closure_def_id, substs);\n+    confirm_callable_candidate(selcx, obligation, &closure_type.sig, util::TupleArgumentsFlag::No)\n+}\n+\n+fn confirm_callable_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    fn_sig: &ty::PolyFnSig<'tcx>,\n+    flag: util::TupleArgumentsFlag)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let tcx = selcx.tcx();\n+\n+    debug!(\"confirm_closure_candidate({},{})\",\n+           obligation.repr(tcx),\n+           fn_sig.repr(tcx));\n+\n+    // Note: we unwrap the binder here but re-create it below (1)\n+    let ty::Binder((trait_ref, ret_type)) =\n+        util::closure_trait_ref_and_return_type(tcx,\n+                                                obligation.predicate.trait_ref.def_id,\n+                                                obligation.predicate.trait_ref.self_ty(),\n+                                                fn_sig,\n+                                                flag);\n+\n+    let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n+        projection_ty: ty::ProjectionTy {\n+            trait_ref: trait_ref,\n+            item_name: token::intern(FN_OUTPUT_NAME),\n+        },\n+        ty: ret_type\n+    });\n+\n+    confirm_param_env_candidate(selcx, obligation, predicate)\n+}\n+\n+fn confirm_param_env_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    poly_projection: ty::PolyProjectionPredicate<'tcx>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    let infcx = selcx.infcx();\n+\n+    let projection =\n+        infcx.replace_late_bound_regions_with_fresh_var(\n+            obligation.cause.span,\n+            infer::LateBoundRegionConversionTime::HigherRankedType,\n+            &poly_projection).0;\n+\n+    assert_eq!(projection.projection_ty.item_name,\n+               obligation.predicate.item_name);\n+\n+    let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+    match infcx.sub_trait_refs(false,\n+                               origin,\n+                               obligation.predicate.trait_ref.clone(),\n+                               projection.projection_ty.trait_ref.clone()) {\n+        Ok(()) => { }\n+        Err(e) => {\n+            selcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n+                        obligation.repr(selcx.tcx()),\n+                        projection.repr(selcx.tcx()),\n+                        ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n+        }\n+    }\n+\n+    (projection.ty, vec!())\n+}\n+\n+fn confirm_impl_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+{\n+    // there don't seem to be nicer accessors to these:\n+    let impl_items_map = selcx.tcx().impl_items.borrow();\n+    let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n+\n+    let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n+    let mut impl_ty = None;\n+    for impl_item in impl_items.iter() {\n+        let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n+            ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n+            ty::MethodTraitItem(..) => { continue; }\n+        };\n+\n+        if assoc_type.name != obligation.predicate.item_name {\n+            continue;\n+        }\n+\n+        let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n+        impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n+        break;\n+    }\n+\n+    match impl_ty {\n+        Some(ty) => (ty, impl_vtable.nested.into_vec()),\n+        None => {\n+            // This means that the impl is missing a\n+            // definition for the associated type. This error\n+            // ought to be reported by the type checker method\n+            // `check_impl_items_against_trait`, so here we\n+            // just return ty_err.\n+            (selcx.tcx().types.err, vec!())\n         }\n     }\n }\n@@ -710,7 +807,11 @@ impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n             ProjectionTyCandidate::ParamEnv(ref data) =>\n                 format!(\"ParamEnv({})\", data.repr(tcx)),\n             ProjectionTyCandidate::Impl(ref data) =>\n-                format!(\"Impl({})\", data.repr(tcx))\n+                format!(\"Impl({})\", data.repr(tcx)),\n+            ProjectionTyCandidate::Closure(ref a, ref b) =>\n+                format!(\"Closure(({},{}))\", a.repr(tcx), b.repr(tcx)),\n+            ProjectionTyCandidate::FnPointer(a) =>\n+                format!(\"FnPointer(({}))\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "2ad6f63a341d63bd18881f05c05d9595473ba4f0", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 38, "deletions": 44, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -214,6 +214,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.closure_typer.param_env()\n     }\n \n+    pub fn closure_typer(&self) -> &'cx (ty::UnboxedClosureTyper<'tcx>+'cx) {\n+        self.closure_typer\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -1913,33 +1917,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()));\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        let sig = match self_ty.sty {\n-            ty::ty_bare_fn(_, &ty::BareFnTy {\n-                unsafety: ast::Unsafety::Normal,\n-                abi: abi::Rust,\n-                ref sig\n-            }) => {\n-                sig\n-            }\n-            _ => {\n-                self.tcx().sess.span_bug(\n-                    obligation.cause.span,\n-                    &format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx()))[]);\n-            }\n-        };\n-\n-        let arguments_tuple = ty::mk_tup(self.tcx(), sig.0.inputs.to_vec());\n-        let output_type = sig.0.output.unwrap();\n-        let substs =\n-            Substs::new_trait(\n-                vec![arguments_tuple, output_type],\n-                vec![],\n-                self_ty);\n-        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n-            def_id: obligation.predicate.def_id(),\n-            substs: self.tcx().mk_substs(substs),\n-        }));\n+        let sig = ty::ty_fn_sig(self_ty);\n+        let ty::Binder((trait_ref, _)) =\n+            util::closure_trait_ref_and_return_type(self.tcx(),\n+                                                    obligation.predicate.def_id(),\n+                                                    self_ty,\n+                                                    sig,\n+                                                    util::TupleArgumentsFlag::Yes);\n+        let trait_ref = ty::Binder(trait_ref);\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -1958,23 +1943,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n-\n-        debug!(\"confirm_closure_candidate: closure_def_id={} closure_type={}\",\n-               closure_def_id.repr(self.tcx()),\n-               closure_type.repr(self.tcx()));\n-\n-        let closure_sig = &closure_type.sig;\n-        let arguments_tuple = closure_sig.0.inputs[0];\n-        let trait_substs =\n-            Substs::new_trait(\n-                vec![arguments_tuple, closure_sig.0.output.unwrap()],\n-                vec![],\n-                obligation.self_ty());\n-        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n-            def_id: obligation.predicate.def_id(),\n-            substs: self.tcx().mk_substs(trait_substs),\n-        }));\n+        let trait_ref = self.closure_trait_ref(obligation,\n+                                               closure_def_id,\n+                                               substs);\n \n         debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={})\",\n                closure_def_id.repr(self.tcx()),\n@@ -2280,6 +2251,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn closure_trait_ref(&self,\n+                         obligation: &TraitObligation<'tcx>,\n+                         closure_def_id: ast::DefId,\n+                         substs: &Substs<'tcx>)\n+                         -> ty::PolyTraitRef<'tcx>\n+    {\n+        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n+        let ty::Binder((trait_ref, _)) =\n+            util::closure_trait_ref_and_return_type(self.tcx(),\n+                                                    obligation.predicate.def_id(),\n+                                                    obligation.predicate.0.self_ty(), // (1)\n+                                                    &closure_type.sig,\n+                                                    util::TupleArgumentsFlag::No);\n+\n+        // (1) Feels icky to skip the binder here, but OTOH we know\n+        // that the self-type is an unboxed closure type and hence is\n+        // in fact unparameterized (or at least does not reference any\n+        // regions bound in the obligation). Still probably some\n+        // refactoring could make this nicer.\n+\n+        ty::Binder(trait_ref)\n+    }\n+\n     fn impl_obligations(&mut self,\n                         cause: ObligationCause<'tcx>,\n                         recursion_depth: uint,"}, {"sha": "f8c184896513c324d6d26fc53005ab637a00977c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -353,6 +353,36 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     method_count + method_index_in_trait\n }\n \n+pub fn unboxed_closure_trait_ref_and_return_type<'tcx>(\n+    closure_typer: &ty::UnboxedClosureTyper<'tcx>,\n+    fn_trait_def_id: ast::DefId,\n+    self_ty: Ty<'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: &Substs<'tcx>)\n+    -> ty::Binder<(Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)>\n+{\n+    let tcx = closure_typer.param_env().tcx;\n+    let closure_type = closure_typer.unboxed_closure_type(closure_def_id, substs);\n+\n+    debug!(\"unboxed_closure_trait_ref: closure_def_id={} closure_type={}\",\n+           closure_def_id.repr(tcx),\n+           closure_type.repr(tcx));\n+\n+    let closure_sig = &closure_type.sig;\n+    let arguments_tuple = closure_sig.0.inputs[0];\n+    let trait_substs =\n+        Substs::new_trait(\n+            vec![arguments_tuple],\n+            vec![],\n+            self_ty);\n+    let trait_ref = Rc::new(ty::TraitRef {\n+        def_id: fn_trait_def_id,\n+        substs: tcx.mk_substs(trait_substs),\n+    });\n+\n+    ty::Binder((trait_ref, closure_sig.0.output.unwrap()))\n+}\n+\n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Obligation(predicate={},depth={})\","}, {"sha": "bdb6ea22f8b457fa2c779ac945bef9804e64407b", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -22,6 +22,9 @@ use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+// The name of the associated type for `Fn` return types\n+pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n+\n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n #[derive(Clone, Copy, Show)]"}, {"sha": "c10ce686f08c1fbee22986c8da93c30776893068", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -512,16 +512,15 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n     }\n \n     if cx.lang_items.fn_trait_kind(did).is_some() {\n-        format!(\"{}({}){}\",\n+        format!(\"{}({})\", // TODO\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n                     &strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n                     &strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n                 } else {\n                     &strs[0][]\n-                },\n-                if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n+                })\n     } else if strs.len() > 0 {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {"}, {"sha": "6e8dd6b0ae7551740ba5410cd594cce8dd1a960e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -57,7 +57,7 @@ use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, SpecificRscope,\n              ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n-use util::common::ErrorReported;\n+use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::DefIdMap;\n use util::ppaux::{self, Repr, UserString};\n \n@@ -268,7 +268,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n         ast::ParenthesizedParameters(ref data) => {\n             span_err!(tcx.sess, path.span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n-            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n+            convert_parenthesized_parameters(this, data)\n         }\n     };\n \n@@ -479,7 +479,9 @@ fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n \n fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n                                           data: &ast::ParenthesizedParameterData)\n-                                          -> Vec<Ty<'tcx>>\n+                                          -> (Vec<ty::Region>,\n+                                              Vec<Ty<'tcx>>,\n+                                              Vec<ConvertedBinding<'tcx>>)\n {\n     let binding_rscope = BindingRscope::new();\n     let inputs = data.inputs.iter()\n@@ -492,15 +494,26 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n \n     let input_ty = ty::mk_tup(this.tcx(), inputs);\n \n-    let output = match data.output {\n-        Some(ref output_ty) => convert_ty_with_lifetime_elision(this,\n-                                                                implied_output_region,\n-                                                                params_lifetimes,\n-                                                                &**output_ty),\n-        None => ty::mk_nil(this.tcx()),\n+    let (output, output_span) = match data.output {\n+        Some(ref output_ty) => {\n+            (convert_ty_with_lifetime_elision(this,\n+                                              implied_output_region,\n+                                              params_lifetimes,\n+                                              &**output_ty),\n+             output_ty.span)\n+        }\n+        None => {\n+            (ty::mk_nil(this.tcx()), data.span)\n+        }\n+    };\n+\n+    let output_binding = ConvertedBinding {\n+        item_name: token::intern(FN_OUTPUT_NAME),\n+        ty: output,\n+        span: output_span\n     };\n \n-    vec![input_ty, output]\n+    (vec![], vec![input_ty], vec![output_binding])\n }\n \n pub fn instantiate_poly_trait_ref<'tcx>(\n@@ -630,7 +643,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                             the crate attributes to enable\");\n             }\n \n-            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n+            convert_parenthesized_parameters(this, data)\n         }\n     };\n "}, {"sha": "4dada5bc81ec23f96fb65529c23d9652236c63c8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -347,6 +347,9 @@ impl AngleBracketedParameterData {\n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct ParenthesizedParameterData {\n+    /// Overall span\n+    pub span: Span,\n+\n     /// `(A,B)`\n     pub inputs: Vec<P<Ty>>,\n "}, {"sha": "a1362f5382c979b4f3864039181f5e7e2fd5e434", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -536,9 +536,10 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n                                                          fld: &mut T)\n                                                          -> ParenthesizedParameterData\n {\n-    let ParenthesizedParameterData { inputs, output } = data;\n+    let ParenthesizedParameterData { inputs, output, span } = data;\n     ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-                                 output: output.map(|ty| fld.fold_ty(ty)) }\n+                                 output: output.map(|ty| fld.fold_ty(ty)),\n+                                 span: fld.new_span(span) }\n }\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {"}, {"sha": "4c1ae532d13cdb151064ff0eabfe4400fb92f8e8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07cdb853317697c247b41e61f7a429c3fb623524/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=07cdb853317697c247b41e61f7a429c3fb623524", "patch": "@@ -1796,6 +1796,8 @@ impl<'a> Parser<'a> {\n                     bindings: OwnedSlice::from_vec(bindings),\n                 })\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n+                let lo = self.last_span.lo;\n+\n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n@@ -1807,9 +1809,12 @@ impl<'a> Parser<'a> {\n                     None\n                 };\n \n+                let hi = self.last_span.hi;\n+\n                 ast::ParenthesizedParameters(ast::ParenthesizedParameterData {\n+                    span: mk_sp(lo, hi),\n                     inputs: inputs,\n-                    output: output_ty\n+                    output: output_ty,\n                 })\n             } else {\n                 ast::PathParameters::none()"}]}