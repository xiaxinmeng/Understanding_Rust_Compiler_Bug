{"sha": "779555c1beac90f633c01a773558c4007c99c97f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3OTU1NWMxYmVhYzkwZjYzM2MwMWE3NzM1NThjNDAwN2M5OWM5N2Y=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-08T17:52:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-08T17:52:41Z"}, "message": "Merge #3884\n\n3884: Match check fix missing pattern panic r=flodiebold a=JoshMcguigan\n\nAs reported by @cynecx, match arm exhaustiveness checking could panic when tuple enums were missing their pattern. This was reported in the comments of #3706.\r\n\r\nThis fixes the panic, and adds a similar test to ensure tuples don't have this problem. \r\n\r\nIt turns out malformed tuple patterns are caught in the \"type check\" outside the `is_useful` function, while malformed enum tuple patterns are not. This makes sense to me in hindsight, since the type checker can tell that an enum is the right type even if it is missing its internal pattern, but a tuple (non-enum) just becomes a different type if it is \"missing\" its pattern. This discrepency is why we report a diagnostic in the tuple case (because all arms are filtered out, so there are missing arms), but not in the enum tuple case (because we return an `Err(MalformedMatchArm)` from `is_useful`). I don't think this is that big of a deal, because in both cases this is malformed code and there should eventually be a `MalformedMatchArm` diagnostic or similar. But perhaps we should change things so that if any arm fails the type check we skip the entire diagnostic? That would at least make these two cases behave in the same way.\r\n\r\n@flodiebold \n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>", "tree": {"sha": "115e9461072029b942dbb28f35a73fbe3ae34fec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/115e9461072029b942dbb28f35a73fbe3ae34fec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/779555c1beac90f633c01a773558c4007c99c97f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejg9pCRBK7hj4Ov3rIwAAdHIIABME/JoSXfoB0ihPsRaPZNfb\nFyzMXM12a56+aqTZn67K1s4zTcw2YNmYr6jys9wKZplv9n2kHQTmZqXnBYTIZv0k\nF0YF4pN77RO9JSXpC0QJwFdl2D9sZ6/NUtVXdPEdiunfsUVnnjFtZgJoHtV/ID97\nkFswPrBOfBxnyAMBMxzyZlsi/0UwpN49aYdtHf8gOHKWOr8ZarxYggMXcb2fS4t2\nVI3JiRURIOAjvaXyvZFzrZY5L8oJ/X6cHr4TGqQQ2sUfppSVharBba0kfnYDEJSM\nYtm5C6lmZWVfGkDXMzMpO+y2TUhKrAsLe3AyQkMlREIu/aRAmKcSSv3Bdud0hcc=\n=+a+U\n-----END PGP SIGNATURE-----\n", "payload": "tree 115e9461072029b942dbb28f35a73fbe3ae34fec\nparent 4762c6d9c66dc1b6be9b9010dbe787ef8d69530a\nparent 36c110ee096d46b02aa2a5adfaf138cd8c3872a7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586368361 +0000\ncommitter GitHub <noreply@github.com> 1586368361 +0000\n\nMerge #3884\n\n3884: Match check fix missing pattern panic r=flodiebold a=JoshMcguigan\n\nAs reported by @cynecx, match arm exhaustiveness checking could panic when tuple enums were missing their pattern. This was reported in the comments of #3706.\r\n\r\nThis fixes the panic, and adds a similar test to ensure tuples don't have this problem. \r\n\r\nIt turns out malformed tuple patterns are caught in the \"type check\" outside the `is_useful` function, while malformed enum tuple patterns are not. This makes sense to me in hindsight, since the type checker can tell that an enum is the right type even if it is missing its internal pattern, but a tuple (non-enum) just becomes a different type if it is \"missing\" its pattern. This discrepency is why we report a diagnostic in the tuple case (because all arms are filtered out, so there are missing arms), but not in the enum tuple case (because we return an `Err(MalformedMatchArm)` from `is_useful`). I don't think this is that big of a deal, because in both cases this is malformed code and there should eventually be a `MalformedMatchArm` diagnostic or similar. But perhaps we should change things so that if any arm fails the type check we skip the entire diagnostic? That would at least make these two cases behave in the same way.\r\n\r\n@flodiebold \n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/779555c1beac90f633c01a773558c4007c99c97f", "html_url": "https://github.com/rust-lang/rust/commit/779555c1beac90f633c01a773558c4007c99c97f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/779555c1beac90f633c01a773558c4007c99c97f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4762c6d9c66dc1b6be9b9010dbe787ef8d69530a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4762c6d9c66dc1b6be9b9010dbe787ef8d69530a", "html_url": "https://github.com/rust-lang/rust/commit/4762c6d9c66dc1b6be9b9010dbe787ef8d69530a"}, {"sha": "36c110ee096d46b02aa2a5adfaf138cd8c3872a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/36c110ee096d46b02aa2a5adfaf138cd8c3872a7", "html_url": "https://github.com/rust-lang/rust/commit/36c110ee096d46b02aa2a5adfaf138cd8c3872a7"}], "stats": {"total": 74, "additions": 59, "deletions": 15}, "files": [{"sha": "9e9a9d047519c51ac721871b25768a35a0cb7442", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/779555c1beac90f633c01a773558c4007c99c97f/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/779555c1beac90f633c01a773558c4007c99c97f/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=779555c1beac90f633c01a773558c4007c99c97f", "patch": "@@ -235,7 +235,10 @@ impl From<PatId> for PatIdOrWild {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n-pub struct MatchCheckNotImplemented;\n+pub enum MatchCheckErr {\n+    NotImplemented,\n+    MalformedMatchArm,\n+}\n \n /// The return type of `is_useful` is either an indication of usefulness\n /// of the match arm, or an error in the case the match statement\n@@ -244,7 +247,7 @@ pub struct MatchCheckNotImplemented;\n ///\n /// The `std::result::Result` type is used here rather than a custom enum\n /// to allow the use of `?`.\n-pub type MatchCheckResult<T> = Result<T, MatchCheckNotImplemented>;\n+pub type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n \n #[derive(Debug)]\n /// A row in a Matrix.\n@@ -335,29 +338,36 @@ impl PatStack {\n                     Expr::Literal(Literal::Bool(_)) => None,\n                     // perhaps this is actually unreachable given we have\n                     // already checked that these match arms have the appropriate type?\n-                    _ => return Err(MatchCheckNotImplemented),\n+                    _ => return Err(MatchCheckErr::NotImplemented),\n                 }\n             }\n             (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n             (Pat::Path(_), Constructor::Enum(constructor)) => {\n-                // enums with no associated data become `Pat::Path`\n+                // unit enum variants become `Pat::Path`\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *constructor) {\n                     None\n                 } else {\n                     Some(self.to_tail())\n                 }\n             }\n-            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(constructor)) => {\n+            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(enum_constructor)) => {\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n-                if !enum_variant_matches(cx, pat_id, *constructor) {\n+                if !enum_variant_matches(cx, pat_id, *enum_constructor) {\n                     None\n                 } else {\n+                    // If the enum variant matches, then we need to confirm\n+                    // that the number of patterns aligns with the expected\n+                    // number of patterns for that enum variant.\n+                    if pat_ids.len() != constructor.arity(cx)? {\n+                        return Err(MatchCheckErr::MalformedMatchArm);\n+                    }\n+\n                     Some(self.replace_head_with(pat_ids))\n                 }\n             }\n-            (Pat::Or(_), _) => return Err(MatchCheckNotImplemented),\n-            (_, _) => return Err(MatchCheckNotImplemented),\n+            (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n+            (_, _) => return Err(MatchCheckErr::NotImplemented),\n         };\n \n         Ok(result)\n@@ -514,7 +524,7 @@ pub(crate) fn is_useful(\n         return if any_useful {\n             Ok(Usefulness::Useful)\n         } else if found_unimplemented {\n-            Err(MatchCheckNotImplemented)\n+            Err(MatchCheckErr::NotImplemented)\n         } else {\n             Ok(Usefulness::NotUseful)\n         };\n@@ -567,7 +577,7 @@ pub(crate) fn is_useful(\n                 }\n \n                 if found_unimplemented {\n-                    Err(MatchCheckNotImplemented)\n+                    Err(MatchCheckErr::NotImplemented)\n                 } else {\n                     Ok(Usefulness::NotUseful)\n                 }\n@@ -604,7 +614,7 @@ impl Constructor {\n                 match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n                     VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n                     VariantData::Unit => 0,\n-                    _ => return Err(MatchCheckNotImplemented),\n+                    _ => return Err(MatchCheckErr::NotImplemented),\n                 }\n             }\n         };\n@@ -637,20 +647,20 @@ fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Opt\n         Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n         Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n             Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n-            _ => return Err(MatchCheckNotImplemented),\n+            _ => return Err(MatchCheckErr::NotImplemented),\n         },\n         Pat::TupleStruct { .. } | Pat::Path(_) => {\n             let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n             let variant_id =\n-                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckNotImplemented)?;\n+                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::NotImplemented)?;\n             match variant_id {\n                 VariantId::EnumVariantId(enum_variant_id) => {\n                     Some(Constructor::Enum(enum_variant_id))\n                 }\n-                _ => return Err(MatchCheckNotImplemented),\n+                _ => return Err(MatchCheckErr::NotImplemented),\n             }\n         }\n-        _ => return Err(MatchCheckNotImplemented),\n+        _ => return Err(MatchCheckErr::NotImplemented),\n     };\n \n     Ok(res)\n@@ -1324,6 +1334,40 @@ mod tests {\n         check_diagnostic(content);\n     }\n \n+    #[test]\n+    fn malformed_match_arm_tuple_missing_pattern() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (0) {\n+                    () => (),\n+                }\n+            }\n+        \";\n+\n+        // Match arms with the incorrect type are filtered out.\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_tuple_enum_missing_pattern() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B(u32),\n+            }\n+            fn test_fn() {\n+                match Either::A {\n+                    Either::A => (),\n+                    Either::B() => (),\n+                }\n+            }\n+        \";\n+\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_not_in_scope() {\n         let content = r\""}]}