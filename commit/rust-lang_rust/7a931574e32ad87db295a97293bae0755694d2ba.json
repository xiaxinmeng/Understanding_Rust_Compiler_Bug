{"sha": "7a931574e32ad87db295a97293bae0755694d2ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhOTMxNTc0ZTMyYWQ4N2RiMjk1YTk3MjkzYmFlMDc1NTY5NGQyYmE=", "commit": {"author": {"name": "Johannes Muenzel", "email": "jmuenzel@gmail.com", "date": "2014-01-28T06:28:50Z"}, "committer": {"name": "Johannes Muenzel", "email": "jmuenzel@gmail.com", "date": "2014-01-30T01:33:51Z"}, "message": "Check enum and struct representability properly (issues #3008 and #3779)", "tree": {"sha": "32791b86154951cb200af6dd21f911a2114ba68d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32791b86154951cb200af6dd21f911a2114ba68d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a931574e32ad87db295a97293bae0755694d2ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a931574e32ad87db295a97293bae0755694d2ba", "html_url": "https://github.com/rust-lang/rust/commit/7a931574e32ad87db295a97293bae0755694d2ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a931574e32ad87db295a97293bae0755694d2ba/comments", "author": {"login": "joho-stop", "id": 6258344, "node_id": "MDQ6VXNlcjYyNTgzNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6258344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joho-stop", "html_url": "https://github.com/joho-stop", "followers_url": "https://api.github.com/users/joho-stop/followers", "following_url": "https://api.github.com/users/joho-stop/following{/other_user}", "gists_url": "https://api.github.com/users/joho-stop/gists{/gist_id}", "starred_url": "https://api.github.com/users/joho-stop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joho-stop/subscriptions", "organizations_url": "https://api.github.com/users/joho-stop/orgs", "repos_url": "https://api.github.com/users/joho-stop/repos", "events_url": "https://api.github.com/users/joho-stop/events{/privacy}", "received_events_url": "https://api.github.com/users/joho-stop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joho-stop", "id": 6258344, "node_id": "MDQ6VXNlcjYyNTgzNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6258344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joho-stop", "html_url": "https://github.com/joho-stop", "followers_url": "https://api.github.com/users/joho-stop/followers", "following_url": "https://api.github.com/users/joho-stop/following{/other_user}", "gists_url": "https://api.github.com/users/joho-stop/gists{/gist_id}", "starred_url": "https://api.github.com/users/joho-stop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joho-stop/subscriptions", "organizations_url": "https://api.github.com/users/joho-stop/orgs", "repos_url": "https://api.github.com/users/joho-stop/repos", "events_url": "https://api.github.com/users/joho-stop/events{/privacy}", "received_events_url": "https://api.github.com/users/joho-stop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f84b7291e7606b35e800070bd826e4c2e2154228", "url": "https://api.github.com/repos/rust-lang/rust/commits/f84b7291e7606b35e800070bd826e4c2e2154228", "html_url": "https://github.com/rust-lang/rust/commit/f84b7291e7606b35e800070bd826e4c2e2154228"}], "stats": {"total": 181, "additions": 123, "deletions": 58}, "files": [{"sha": "4a166be9aae484a46a872b0a977891d4a6c0a9cc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 90, "deletions": 40, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7a931574e32ad87db295a97293bae0755694d2ba/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a931574e32ad87db295a97293bae0755694d2ba/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7a931574e32ad87db295a97293bae0755694d2ba", "patch": "@@ -2348,53 +2348,103 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     !subtypes_require(cx, &mut seen, r_ty, r_ty)\n }\n \n-pub fn type_structurally_contains(cx: ctxt, ty: t, test: |x: &sty| -> bool)\n-                                  -> bool {\n-    let sty = &get(ty).sty;\n-    debug!(\"type_structurally_contains: {}\",\n-           ::util::ppaux::ty_to_str(cx, ty));\n-    if test(sty) { return true; }\n-    match *sty {\n-      ty_enum(did, ref substs) => {\n-        for variant in (*enum_variants(cx, did)).iter() {\n-            for aty in variant.args.iter() {\n-                let sty = subst(cx, substs, *aty);\n-                if type_structurally_contains(cx, sty, |x| test(x)) { return true; }\n+/// Describes whether a type is representable. For types that are not\n+/// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n+/// distinguish between types that are recursive with themselves and types that\n+/// contain a different recursive type. These cases can therefore be treated\n+/// differently when reporting errors.\n+#[deriving(Eq)]\n+pub enum Representability {\n+    Representable,\n+    SelfRecursive,\n+    ContainsRecursive,\n+}\n+\n+/// Check whether a type is representable. This means it cannot contain unboxed\n+/// structural recursion. This check is needed for structs and enums.\n+pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n+\n+    // Iterate until something non-representable is found\n+    fn find_nonrepresentable<It: Iterator<t>>(cx: ctxt, seen: &mut ~[DefId],\n+                                              mut iter: It) -> Representability {\n+        for ty in iter {\n+            let r = type_structurally_recursive(cx, seen, ty);\n+            if r != Representable {\n+                 return r\n             }\n         }\n-        return false;\n-      }\n-      ty_struct(did, ref substs) => {\n-        let r = lookup_struct_fields(cx, did);\n-        for field in r.iter() {\n-            let ft = lookup_field_type(cx, did, field.id, substs);\n-            if type_structurally_contains(cx, ft, |x| test(x)) { return true; }\n+        Representable\n+    }\n+\n+    // Does the type `ty` directly (without indirection through a pointer)\n+    // contain any types on stack `seen`?\n+    fn type_structurally_recursive(cx: ctxt, seen: &mut ~[DefId],\n+                                   ty: t) -> Representability {\n+        debug!(\"type_structurally_recursive: {}\",\n+               ::util::ppaux::ty_to_str(cx, ty));\n+\n+        // Compare current type to previously seen types\n+        match get(ty).sty {\n+            ty_struct(did, _) |\n+            ty_enum(did, _) => {\n+                for (i, &seen_did) in seen.iter().enumerate() {\n+                    if did == seen_did {\n+                        return if i == 0 { SelfRecursive }\n+                               else { ContainsRecursive }\n+                    }\n+                }\n+            }\n+            _ => (),\n         }\n-        return false;\n-      }\n \n-      ty_tup(ref ts) => {\n-        for tt in ts.iter() {\n-            if type_structurally_contains(cx, *tt, |x| test(x)) { return true; }\n+        // Check inner types\n+        match get(ty).sty {\n+            // Tuples\n+            ty_tup(ref ts) => {\n+                find_nonrepresentable(cx, seen, ts.iter().map(|t| *t))\n+            }\n+            // Non-zero fixed-length vectors.\n+            ty_vec(mt, vstore_fixed(len)) if len != 0 => {\n+                type_structurally_recursive(cx, seen, mt.ty)\n+            }\n+\n+            // Push struct and enum def-ids onto `seen` before recursing.\n+            ty_struct(did, ref substs) => {\n+                seen.push(did);\n+                let fields = struct_fields(cx, did, substs);\n+                let r = find_nonrepresentable(cx, seen,\n+                                              fields.iter().map(|f| f.mt.ty));\n+                seen.pop();\n+                r\n+            }\n+            ty_enum(did, ref substs) => {\n+                seen.push(did);\n+                let vs = enum_variants(cx, did);\n+\n+                let mut r = Representable;\n+                for variant in vs.iter() {\n+                    let iter = variant.args.iter().map(|aty| subst(cx, substs, *aty));\n+                    r = find_nonrepresentable(cx, seen, iter);\n+\n+                    if r != Representable { break }\n+                }\n+\n+                seen.pop();\n+                r\n+            }\n+\n+            _ => Representable,\n         }\n-        return false;\n-      }\n-      ty_vec(ref mt, vstore_fixed(_)) => {\n-        return type_structurally_contains(cx, mt.ty, test);\n-      }\n-      _ => return false\n     }\n-}\n \n-pub fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n-    return type_structurally_contains(cx, ty, |sty| {\n-        match *sty {\n-          ty_uniq(_) |\n-          ty_vec(_, vstore_uniq) |\n-          ty_str(vstore_uniq) => true,\n-          _ => false,\n-        }\n-    });\n+    debug!(\"is_type_representable: {}\",\n+           ::util::ppaux::ty_to_str(cx, ty));\n+\n+    // To avoid a stack overflow when checking an enum variant or struct that\n+    // contains a different, structurally recursive type, maintain a stack\n+    // of seen types and check recursion for each of them (issues #3008, #3779).\n+    let mut seen: ~[DefId] = ~[];\n+    type_structurally_recursive(cx, &mut seen, ty)\n }\n \n pub fn type_is_trait(ty: t) -> bool {"}, {"sha": "cefda4372749cba983455faf5caa868cd266b873", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7a931574e32ad87db295a97293bae0755694d2ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a931574e32ad87db295a97293bae0755694d2ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7a931574e32ad87db295a97293bae0755694d2ba", "patch": "@@ -531,7 +531,10 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n pub fn check_struct(ccx: @CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n-    // Check that the class is instantiable\n+    // Check that the struct is representable\n+    check_representable(tcx, span, id, \"struct\");\n+\n+    // Check that the struct is instantiable\n     check_instantiable(tcx, span, id);\n \n     if ty::lookup_simd(tcx, local_def(id)) {\n@@ -3410,6 +3413,33 @@ pub fn check_const_with_ty(fcx: @FnCtxt,\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }\n \n+/// Checks whether a type can be represented in memory. In particular, it\n+/// identifies types that contain themselves without indirection through a\n+/// pointer, which would mean their size is unbounded. This is different from\n+/// the question of whether a type can be instantiated. See the definition of\n+/// `check_instantiable`.\n+pub fn check_representable(tcx: ty::ctxt,\n+                           sp: Span,\n+                           item_id: ast::NodeId,\n+                           designation: &str) {\n+    let rty = ty::node_id_to_type(tcx, item_id);\n+\n+    // Check that it is possible to represent this type. This call identifies\n+    // (1) types that contain themselves and (2) types that contain a different\n+    // recursive type. It is only necessary to throw an error on those that\n+    // contain themselves. For case 2, there must be an inner type that will be\n+    // caught by case 1.\n+    match ty::is_type_representable(tcx, rty) {\n+      ty::SelfRecursive => {\n+        tcx.sess.span_err(\n+          sp, format!(\"illegal recursive {} type; \\\n+                       wrap the inner value in a box to make it representable\",\n+                      designation));\n+      }\n+      ty::Representable | ty::ContainsRecursive => (),\n+    }\n+}\n+\n /// Checks whether a type can be created without an instance of itself.\n /// This is similar but different from the question of whether a type\n /// can be represented.  For example, the following type:\n@@ -3565,7 +3595,6 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n         return variants;\n     }\n \n-    let rty = ty::node_id_to_type(ccx.tcx, id);\n     let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { crate: ast::LOCAL_CRATE, node: id });\n     if hint != attr::ReprAny && vs.len() <= 1 {\n         ccx.tcx.sess.span_err(sp, format!(\"unsupported representation for {}variant enum\",\n@@ -3580,22 +3609,8 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n         enum_var_cache.get().insert(local_def(id), @variants);\n     }\n \n-    // Check that it is possible to represent this enum:\n-    let mut outer = true;\n-    let did = local_def(id);\n-    if ty::type_structurally_contains(ccx.tcx, rty, |sty| {\n-        match *sty {\n-          ty::ty_enum(id, _) if id == did => {\n-            if outer { outer = false; false }\n-            else { true }\n-          }\n-          _ => false\n-        }\n-    }) {\n-        ccx.tcx.sess.span_err(sp,\n-                              \"illegal recursive enum type; \\\n-                               wrap the inner value in a box to make it representable\");\n-    }\n+    // Check that it is possible to represent this enum.\n+    check_representable(ccx.tcx, sp, id, \"enum\");\n \n     // Check that it is possible to instantiate this enum:\n     //"}]}