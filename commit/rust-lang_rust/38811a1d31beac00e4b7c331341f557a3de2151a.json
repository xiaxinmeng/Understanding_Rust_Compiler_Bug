{"sha": "38811a1d31beac00e4b7c331341f557a3de2151a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ODExYTFkMzFiZWFjMDBlNGI3YzMzMTM0MWY1NTdhM2RlMjE1MWE=", "commit": {"author": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2019-03-19T11:24:38Z"}, "committer": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2019-03-19T11:24:38Z"}, "message": "Introduce RefCell::try_borrow_unguarded\n\nThis replaces RefCell::borrow_state to something that encodes the use\ncase of Servo better.", "tree": {"sha": "6edc03a86486e22918a9f1971f79e8d4460e0061", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6edc03a86486e22918a9f1971f79e8d4460e0061"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38811a1d31beac00e4b7c331341f557a3de2151a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38811a1d31beac00e4b7c331341f557a3de2151a", "html_url": "https://github.com/rust-lang/rust/commit/38811a1d31beac00e4b7c331341f557a3de2151a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38811a1d31beac00e4b7c331341f557a3de2151a/comments", "author": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9388c28c2a6cfb82724612b4d3601475dee9325", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9388c28c2a6cfb82724612b4d3601475dee9325", "html_url": "https://github.com/rust-lang/rust/commit/a9388c28c2a6cfb82724612b4d3601475dee9325"}], "stats": {"total": 87, "additions": 38, "deletions": 49}, "files": [{"sha": "c67ac26562f135a86c711ecba1a1ba60d28f3437", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/38811a1d31beac00e4b7c331341f557a3de2151a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38811a1d31beac00e4b7c331341f557a3de2151a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=38811a1d31beac00e4b7c331341f557a3de2151a", "patch": "@@ -569,18 +569,6 @@ pub struct RefCell<T: ?Sized> {\n     value: UnsafeCell<T>,\n }\n \n-/// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"borrow_state\", issue = \"27733\")]\n-pub enum BorrowState {\n-    /// The cell is currently being read, there is at least one active `borrow`.\n-    Reading,\n-    /// The cell is currently being written to, there is an active `borrow_mut`.\n-    Writing,\n-    /// There are no outstanding borrows on this cell.\n-    Unused,\n-}\n-\n /// An error returned by [`RefCell::try_borrow`](struct.RefCell.html#method.try_borrow).\n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n pub struct BorrowError {\n@@ -765,43 +753,6 @@ impl<T> RefCell<T> {\n }\n \n impl<T: ?Sized> RefCell<T> {\n-    /// Queries the current state of this `RefCell`.\n-    ///\n-    /// A return value of `BorrowState::Writing` signals that this `RefCell`\n-    /// is currently mutably borrowed, while `BorrowState::Reading` signals\n-    /// that it is immutably borrowed.\n-    ///\n-    /// This is mostly useful in rare use cases with `RefCell::as_ptr` to\n-    /// access the data without changing its borrow state, use with care.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(borrow_state)]\n-    ///\n-    /// use std::cell::{BorrowState, RefCell};\n-    ///\n-    /// let c = RefCell::new(5);\n-    ///\n-    /// match c.borrow_state() {\n-    ///     BorrowState::Writing => println!(\"currently borrowed mutably\"),\n-    ///     BorrowState::Reading => println!(\"currently borrowed immutably\"),\n-    ///     BorrowState::Unused => println!(\"not borrowed\"),\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n-    #[inline]\n-    pub fn borrow_state(&self) -> BorrowState {\n-        let borrow = self.borrow.get();\n-        if is_writing(borrow) {\n-            BorrowState::Writing\n-        } else if is_reading(borrow) {\n-            BorrowState::Reading\n-        } else {\n-            BorrowState::Unused\n-        }\n-    }\n-\n     /// Immutably borrows the wrapped value.\n     ///\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n@@ -1007,6 +958,44 @@ impl<T: ?Sized> RefCell<T> {\n             &mut *self.value.get()\n         }\n     }\n+\n+    /// Immutably borrows the wrapped value, returning an error if the value is\n+    /// currently mutably borrowed.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Unlike `RefCell::borrow`, this method is unsafe because it does not\n+    /// return a `Ref`, thus leaving the borrow flag untouched. Mutably\n+    /// borrowing the `RefCell` while the reference returned by this method\n+    /// is alive is undefined behaviour.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(borrow_state)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// {\n+    ///     let m = c.borrow_mut();\n+    ///     assert!(unsafe { c.try_borrow_unguarded() }.is_err());\n+    /// }\n+    ///\n+    /// {\n+    ///     let m = c.borrow();\n+    ///     assert!(unsafe { c.try_borrow_unguarded() }.is_ok());\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n+    #[inline]\n+    pub unsafe fn try_borrow_unguarded(&self) -> Result<&T, BorrowError> {\n+        if !is_writing(self.borrow.get()) {\n+            Ok(&*self.value.get())\n+        } else {\n+            Err(BorrowError { _private: () })\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}