{"sha": "763cec21f0b030c0d811bea3263b46361e99a14f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2M2NlYzIxZjBiMDMwYzBkODExYmVhMzI2M2I0NjM2MWU5OWExNGY=", "commit": {"author": {"name": "Jonathan Price", "email": "jon.mark.price@gmail.com", "date": "2016-06-28T18:06:15Z"}, "committer": {"name": "Jonathan Price", "email": "jon.mark.price@gmail.com", "date": "2016-06-28T18:06:15Z"}, "message": "Merging my book edits recent commits.", "tree": {"sha": "89118a5ff351834e68fce30aee899551f0706b32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89118a5ff351834e68fce30aee899551f0706b32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/763cec21f0b030c0d811bea3263b46361e99a14f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/763cec21f0b030c0d811bea3263b46361e99a14f", "html_url": "https://github.com/rust-lang/rust/commit/763cec21f0b030c0d811bea3263b46361e99a14f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/763cec21f0b030c0d811bea3263b46361e99a14f/comments", "author": {"login": "jonmarkprice", "id": 6698070, "node_id": "MDQ6VXNlcjY2OTgwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/6698070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonmarkprice", "html_url": "https://github.com/jonmarkprice", "followers_url": "https://api.github.com/users/jonmarkprice/followers", "following_url": "https://api.github.com/users/jonmarkprice/following{/other_user}", "gists_url": "https://api.github.com/users/jonmarkprice/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonmarkprice/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonmarkprice/subscriptions", "organizations_url": "https://api.github.com/users/jonmarkprice/orgs", "repos_url": "https://api.github.com/users/jonmarkprice/repos", "events_url": "https://api.github.com/users/jonmarkprice/events{/privacy}", "received_events_url": "https://api.github.com/users/jonmarkprice/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonmarkprice", "id": 6698070, "node_id": "MDQ6VXNlcjY2OTgwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/6698070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonmarkprice", "html_url": "https://github.com/jonmarkprice", "followers_url": "https://api.github.com/users/jonmarkprice/followers", "following_url": "https://api.github.com/users/jonmarkprice/following{/other_user}", "gists_url": "https://api.github.com/users/jonmarkprice/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonmarkprice/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonmarkprice/subscriptions", "organizations_url": "https://api.github.com/users/jonmarkprice/orgs", "repos_url": "https://api.github.com/users/jonmarkprice/repos", "events_url": "https://api.github.com/users/jonmarkprice/events{/privacy}", "received_events_url": "https://api.github.com/users/jonmarkprice/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eb56e698814c5a626b9c935162ff8487bca0774", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb56e698814c5a626b9c935162ff8487bca0774", "html_url": "https://github.com/rust-lang/rust/commit/8eb56e698814c5a626b9c935162ff8487bca0774"}, {"sha": "ea0dc9297283daff6486807f43e190b4eb561412", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0dc9297283daff6486807f43e190b4eb561412", "html_url": "https://github.com/rust-lang/rust/commit/ea0dc9297283daff6486807f43e190b4eb561412"}], "stats": {"total": 8489, "additions": 4840, "deletions": 3649}, "files": [{"sha": "0bd0c70bd0519bdf39fd4315d3ed82d354c9735c", "filename": "mk/crates.mk", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -57,10 +57,10 @@ TARGET_CRATES := libc std term \\\n \t\t panic_abort panic_unwind unwind\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n-                rustc_data_structures rustc_platform_intrinsics \\\n+                rustc_data_structures rustc_platform_intrinsics rustc_errors \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n                 rustc_const_eval rustc_const_math rustc_incremental\n-HOST_CRATES := syntax syntax_ext $(RUSTC_CRATES) rustdoc fmt_macros \\\n+HOST_CRATES := syntax syntax_ext syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n \t\tflate arena graphviz rbml log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n \n@@ -98,43 +98,45 @@ DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n \n-DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode\n-DEPS_syntax_ext := syntax fmt_macros\n+DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n+DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros\n+DEPS_syntax_pos := serialize\n \n DEPS_rustc_const_math := std syntax log serialize\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n-\t\t\t\t\t     rustc_back graphviz\n+\t\t\t     rustc_back graphviz syntax_pos\n \n DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n-\t\t  \t  rustc_const_math\n+\t      rustc_const_math syntax_pos rustc_errors\n DEPS_rustc_back := std syntax flate log libc\n-DEPS_rustc_borrowck := rustc log graphviz syntax rustc_mir\n+DEPS_rustc_borrowck := rustc log graphviz syntax syntax_pos rustc_errors rustc_mir\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n \t             rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n                      rustc_metadata syntax_ext rustc_passes rustc_save_analysis rustc_const_eval \\\n-                     rustc_incremental\n-DEPS_rustc_lint := rustc log syntax rustc_const_eval\n+                     rustc_incremental syntax_pos rustc_errors\n+DEPS_rustc_errors := log libc serialize syntax_pos\n+DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n-DEPS_rustc_metadata := rustc syntax rbml rustc_const_math\n-DEPS_rustc_passes := syntax rustc core rustc_const_eval\n-DEPS_rustc_mir := rustc syntax rustc_const_math rustc_const_eval rustc_bitflags\n-DEPS_rustc_resolve := arena rustc log syntax\n+DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rbml rustc_const_math\n+DEPS_rustc_passes := syntax syntax_pos rustc core rustc_const_eval rustc_errors\n+DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags\n+DEPS_rustc_resolve := arena rustc log syntax syntax_pos rustc_errors\n DEPS_rustc_platform_intrinsics := std\n-DEPS_rustc_plugin := rustc rustc_metadata syntax\n-DEPS_rustc_privacy := rustc log syntax\n+DEPS_rustc_plugin := rustc rustc_metadata syntax syntax_pos rustc_errors\n+DEPS_rustc_privacy := rustc log syntax syntax_pos\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n-                    rustc_const_math rustc_const_eval rustc_incremental\n-DEPS_rustc_incremental := rbml rustc serialize rustc_data_structures\n-DEPS_rustc_save_analysis := rustc log syntax serialize\n-DEPS_rustc_typeck := rustc syntax rustc_platform_intrinsics rustc_const_math \\\n-                     rustc_const_eval\n+                    rustc_const_math rustc_const_eval rustc_incremental rustc_errors syntax_pos\n+DEPS_rustc_incremental := rbml rustc syntax_pos serialize rustc_data_structures\n+DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n+DEPS_rustc_typeck := rustc syntax syntax_pos rustc_platform_intrinsics rustc_const_math \\\n+                     rustc_const_eval rustc_errors\n \n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n-                test rustc_lint rustc_const_eval\n+                test rustc_lint rustc_const_eval syntax_pos\n \n \n TOOL_DEPS_compiletest := test getopts log serialize"}, {"sha": "8426d5a626549b8ea22b33f3598a78090491e63f", "filename": "src/doc/book/compiler-plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcompiler-plugins.md?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -45,11 +45,11 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ast::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax::ext::build::AstBuilder;  // trait for expr_usize\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])"}, {"sha": "884db34189240d19b1c556fc3c55988f9d1b282b", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -32,9 +32,9 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::ast::Name;\n use syntax::codemap;\n-use syntax::codemap::Pos;\n use syntax::parse::token::{self, BinOpToken, DelimToken, Lit, Token};\n use syntax::parse::lexer::TokenAndSpan;\n+use syntax_pos::Pos;\n \n fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n     fn id() -> token::Token {\n@@ -233,10 +233,10 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_\n     lo -= surrogate_pairs_pos.binary_search(&(lo as usize)).unwrap_or_else(|x| x) as u32;\n     hi -= surrogate_pairs_pos.binary_search(&(hi as usize)).unwrap_or_else(|x| x) as u32;\n \n-    let sp = codemap::Span {\n-        lo: codemap::BytePos(lo),\n-        hi: codemap::BytePos(hi),\n-        expn_id: codemap::NO_EXPANSION\n+    let sp = syntax_pos::Span {\n+        lo: syntax_pos::BytePos(lo),\n+        hi: syntax_pos::BytePos(hi),\n+        expn_id: syntax_pos::NO_EXPANSION\n     };\n \n     TokenAndSpan {"}, {"sha": "aaef8e8423cbec1bce8d247b33c1aa732cadf0f8", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,6 +19,8 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "a1c04dfcab5e66be6616e59a307ff81eaa5fbff4", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -95,7 +95,7 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for CheckAttrVisitor<'a> {\n+impl<'a> Visitor for CheckAttrVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         let target = Target::from_item(item);\n         for attr in &item.attrs {"}, {"sha": "78fd2bbbe0d2590e033ea4d87da820c69aad227f", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,9 +14,9 @@\n use hir::*;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n use syntax::ast::MetaItemKind;\n-use syntax::attr::ThinAttributesExt;\n use hir;\n-use syntax::codemap::{respan, Span, Spanned};\n+use syntax_pos::Span;\n+use syntax::codemap::{respan, Spanned};\n use syntax::ptr::P;\n use syntax::parse::token::keywords;\n use syntax::util::move_map::MoveMap;\n@@ -292,8 +292,11 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n     })\n }\n \n-pub fn fold_attrs<T: Folder>(attrs: HirVec<Attribute>, fld: &mut T) -> HirVec<Attribute> {\n-    attrs.move_flat_map(|x| fld.fold_attribute(x))\n+pub fn fold_attrs<T, F>(attrs: T, fld: &mut F) -> T\n+    where T: Into<Vec<Attribute>> + From<Vec<Attribute>>,\n+          F: Folder,\n+{\n+    attrs.into().move_flat_map(|x| fld.fold_attribute(x)).into()\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n@@ -461,7 +464,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n-            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), fld).into()),\n+            attrs: fold_attrs(attrs, fld),\n         }\n     })\n }\n@@ -1078,7 +1081,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             }\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), folder).into()),\n+        attrs: fold_attrs(attrs, folder),\n     }\n }\n "}, {"sha": "2d5c4ebf8d898bbc3bf0bff24f945a712f48045c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,8 +27,8 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n-use syntax::attr::ThinAttributesExt;\n-use syntax::codemap::{Span, Spanned};\n+use syntax::codemap::Spanned;\n+use syntax_pos::Span;\n use hir::*;\n \n use std::cmp;\n@@ -756,7 +756,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprClosure(_, ref function_declaration, ref body, _fn_decl_span) => {\n-            visitor.visit_fn(FnKind::Closure(expression.attrs.as_attr_slice()),\n+            visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n                              expression.span,"}, {"sha": "5b655522f342f6ef82149b52f6009924e2093af3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 112, "deletions": 114, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -50,12 +50,12 @@ use session::Session;\n use std::collections::BTreeMap;\n use std::iter;\n use syntax::ast::*;\n-use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ptr::P;\n-use syntax::codemap::{respan, Spanned, Span};\n+use syntax::codemap::{respan, Spanned};\n use syntax::parse::token;\n use syntax::std_inject;\n use syntax::visit::{self, Visitor};\n+use syntax_pos::Span;\n \n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n@@ -137,8 +137,8 @@ impl<'a> LoweringContext<'a> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n-        impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n-            fn visit_item(&mut self, item: &'lcx Item) {\n+        impl<'lcx, 'interner> Visitor for ItemLowerer<'lcx, 'interner> {\n+            fn visit_item(&mut self, item: &Item) {\n                 self.items.insert(item.id, self.lctx.lower_item(item));\n                 visit::walk_item(self, item);\n             }\n@@ -237,19 +237,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_decl(&mut self, d: &Decl) -> P<hir::Decl> {\n-        match d.node {\n-            DeclKind::Local(ref l) => P(Spanned {\n-                node: hir::DeclLocal(self.lower_local(l)),\n-                span: d.span,\n-            }),\n-            DeclKind::Item(ref it) => P(Spanned {\n-                node: hir::DeclItem(self.lower_item_id(it)),\n-                span: d.span,\n-            }),\n-        }\n-    }\n-\n     fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n         hir::TypeBinding {\n             id: b.id,\n@@ -587,10 +574,23 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_block(&mut self, b: &Block) -> P<hir::Block> {\n+        let mut stmts = Vec::new();\n+        let mut expr = None;\n+\n+        if let Some((last, rest)) = b.stmts.split_last() {\n+            stmts = rest.iter().map(|s| self.lower_stmt(s)).collect::<Vec<_>>();\n+            let last = self.lower_stmt(last);\n+            if let hir::StmtExpr(e, _) = last.node {\n+                expr = Some(e);\n+            } else {\n+                stmts.push(last);\n+            }\n+        }\n+\n         P(hir::Block {\n             id: b.id,\n-            stmts: b.stmts.iter().map(|s| self.lower_stmt(s)).collect(),\n-            expr: b.expr.as_ref().map(|ref x| self.lower_expr(x)),\n+            stmts: stmts.into(),\n+            expr: expr,\n             rules: self.lower_block_check_mode(&b.rules),\n             span: b.span,\n         })\n@@ -683,6 +683,7 @@ impl<'a> LoweringContext<'a> {\n                         hir::TypeTraitItem(this.lower_bounds(bounds),\n                                            default.as_ref().map(|x| this.lower_ty(x)))\n                     }\n+                    TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n                 },\n                 span: i.span,\n             }\n@@ -866,10 +867,10 @@ impl<'a> LoweringContext<'a> {\n                                               pats.iter().map(|x| self.lower_pat(x)).collect(),\n                                               ddpos)\n                 }\n-                PatKind::Path(ref pth) => {\n+                PatKind::Path(None, ref pth) => {\n                     hir::PatKind::Path(self.lower_path(pth))\n                 }\n-                PatKind::QPath(ref qself, ref pth) => {\n+                PatKind::Path(Some(ref qself), ref pth) => {\n                     let qself = hir::QSelf {\n                         ty: self.lower_ty(&qself.ty),\n                         position: qself.position,\n@@ -962,16 +963,16 @@ impl<'a> LoweringContext<'a> {\n \n                     let make_call = |this: &mut LoweringContext, p, args| {\n                         let path = this.core_path(e.span, p);\n-                        let path = this.expr_path(path, None);\n-                        this.expr_call(e.span, path, args, None)\n+                        let path = this.expr_path(path, ThinVec::new());\n+                        this.expr_call(e.span, path, args)\n                     };\n \n                     let mk_stmt_let = |this: &mut LoweringContext, bind, expr| {\n-                        this.stmt_let(e.span, false, bind, expr, None)\n+                        this.stmt_let(e.span, false, bind, expr)\n                     };\n \n                     let mk_stmt_let_mut = |this: &mut LoweringContext, bind, expr| {\n-                        this.stmt_let(e.span, true, bind, expr, None)\n+                        this.stmt_let(e.span, true, bind, expr)\n                     };\n \n                     // let placer = <placer_expr> ;\n@@ -980,21 +981,21 @@ impl<'a> LoweringContext<'a> {\n                                                                  placer_expr,\n                                                                  e.span,\n                                                                  hir::PopUnstableBlock,\n-                                                                 None);\n+                                                                 ThinVec::new());\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n                     // let mut place = Placer::make_place(placer);\n                     let (s2, place_binding) = {\n-                        let placer = self.expr_ident(e.span, placer_ident, None, placer_binding);\n+                        let placer = self.expr_ident(e.span, placer_ident, placer_binding);\n                         let call = make_call(self, &make_place, hir_vec![placer]);\n                         mk_stmt_let_mut(self, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let (s3, p_ptr_binding) = {\n-                        let agent = self.expr_ident(e.span, place_ident, None, place_binding);\n-                        let args = hir_vec![self.expr_mut_addr_of(e.span, agent, None)];\n+                        let agent = self.expr_ident(e.span, place_ident, place_binding);\n+                        let args = hir_vec![self.expr_mut_addr_of(e.span, agent)];\n                         let call = make_call(self, &place_pointer, args);\n                         mk_stmt_let(self, p_ptr_ident, call)\n                     };\n@@ -1005,31 +1006,33 @@ impl<'a> LoweringContext<'a> {\n                                                                 value_expr,\n                                                                 e.span,\n                                                                 hir::PopUnstableBlock,\n-                                                                None);\n+                                                                ThinVec::new());\n                         self.signal_block_expr(hir_vec![],\n                                                value_expr,\n                                                e.span,\n-                                               hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n+                                               hir::PopUnsafeBlock(hir::CompilerGenerated),\n+                                               ThinVec::new())\n                     };\n \n                     // push_unsafe!({\n                     //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                     //     InPlace::finalize(place)\n                     // })\n                     let expr = {\n-                        let ptr = self.expr_ident(e.span, p_ptr_ident, None, p_ptr_binding);\n+                        let ptr = self.expr_ident(e.span, p_ptr_ident, p_ptr_binding);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n                                 make_call(self, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                                 self.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n-                        let place = self.expr_ident(e.span, place_ident, None, place_binding);\n+                        let place = self.expr_ident(e.span, place_ident, place_binding);\n                         let call = make_call(self, &inplace_finalize, hir_vec![place]);\n                         self.signal_block_expr(hir_vec![call_move_val_init],\n                                                call,\n                                                e.span,\n-                                               hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n+                                               hir::PushUnsafeBlock(hir::CompilerGenerated),\n+                                               ThinVec::new())\n                     };\n \n                     return self.signal_block_expr(hir_vec![s1, s2, s3],\n@@ -1101,7 +1104,7 @@ impl<'a> LoweringContext<'a> {\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n                                 });\n-                                self.expr_block(blk, None)\n+                                self.expr_block(blk, ThinVec::new())\n                             }\n                             _ => self.lower_expr(els),\n                         }\n@@ -1168,7 +1171,7 @@ impl<'a> LoweringContext<'a> {\n                                                                           expr,\n                                                                           e.span,\n                                                                           hir::PopUnstableBlock,\n-                                                                          None);\n+                                                                          ThinVec::new());\n                                 this.field(token::intern(s), signal_block, ast_expr.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n@@ -1180,7 +1183,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir_expr,\n                                                ast_expr.span,\n                                                hir::PushUnstableBlock,\n-                                               None)\n+                                               ThinVec::new())\n                     }\n \n                     use syntax::ast::RangeLimits::*;\n@@ -1223,7 +1226,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprPath(hir_qself, self.lower_path(path))\n                 }\n                 ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n-                ExprKind::Again(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| self.lower_expr(x))),\n                 ExprKind::InlineAsm(InlineAsm {\n                         ref inputs,\n@@ -1267,9 +1270,9 @@ impl<'a> LoweringContext<'a> {\n                             ex.span = e.span;\n                         }\n                         // merge attributes into the inner expression.\n-                        ex.attrs.update(|attrs| {\n-                            attrs.prepend(e.attrs.clone())\n-                        });\n+                        let mut attrs = e.attrs.clone();\n+                        attrs.extend::<Vec<_>>(ex.attrs.into());\n+                        ex.attrs = attrs;\n                         ex\n                     });\n                 }\n@@ -1288,7 +1291,7 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, None);\n+                        let body_expr = self.expr_block(body, ThinVec::new());\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n@@ -1308,7 +1311,7 @@ impl<'a> LoweringContext<'a> {\n                                                 attrs: hir_vec![],\n                                                 pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n-                                                body: self.expr_block(then, None),\n+                                                body: self.expr_block(then, ThinVec::new()),\n                                             });\n                                             else_opt.map(|else_opt| (else_opt, true))\n                                         }\n@@ -1339,7 +1342,7 @@ impl<'a> LoweringContext<'a> {\n                     let else_arm = {\n                         let pat_under = self.pat_wild(e.span);\n                         let else_expr =\n-                            else_opt.unwrap_or_else(|| self.expr_tuple(e.span, hir_vec![], None));\n+                            else_opt.unwrap_or_else(|| self.expr_tuple(e.span, hir_vec![]));\n                         self.arm(hir_vec![pat_under], else_expr)\n                     };\n \n@@ -1374,15 +1377,15 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, None);\n+                        let body_expr = self.expr_block(body, ThinVec::new());\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = self.pat_wild(e.span);\n-                        let break_expr = self.expr_break(e.span, None);\n+                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         self.arm(hir_vec![pat_under], break_expr)\n                     };\n \n@@ -1393,7 +1396,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir::ExprMatch(sub_expr,\n                                                               arms,\n                                                               hir::MatchSource::WhileLetDesugar),\n-                                               None);\n+                                               ThinVec::new());\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n@@ -1435,7 +1438,7 @@ impl<'a> LoweringContext<'a> {\n                             id: self.next_id(),\n                             node: hir::ExprBlock(body_block),\n                             span: body_span,\n-                            attrs: None,\n+                            attrs: ThinVec::new(),\n                         });\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n@@ -1445,7 +1448,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = self.expr_break(e.span, None);\n+                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         let pat = self.pat_none(e.span);\n                         self.arm(hir_vec![pat], break_expr)\n                     };\n@@ -1461,25 +1464,26 @@ impl<'a> LoweringContext<'a> {\n \n                             self.path_global(e.span, strs)\n                         };\n-                        let iter = self.expr_ident(e.span, iter, None, iter_pat.id);\n-                        let ref_mut_iter = self.expr_mut_addr_of(e.span, iter, None);\n-                        let next_path = self.expr_path(next_path, None);\n-                        let next_expr = self.expr_call(e.span,\n-                                                       next_path,\n-                                                       hir_vec![ref_mut_iter],\n-                                                       None);\n+                        let iter = self.expr_ident(e.span, iter, iter_pat.id);\n+                        let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n+                        let next_path = self.expr_path(next_path, ThinVec::new());\n+                        let next_expr = self.expr_call(e.span, next_path, hir_vec![ref_mut_iter]);\n                         let arms = hir_vec![pat_arm, break_arm];\n \n                         self.expr(e.span,\n                                   hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n-                                  None)\n+                                  ThinVec::new())\n                     };\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n                     let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n-                    let loop_expr =\n-                        P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n+                    let loop_expr = P(hir::Expr {\n+                        id: e.id,\n+                        node: loop_expr,\n+                        span: e.span,\n+                        attrs: ThinVec::new(),\n+                    });\n \n                     // `mut iter => { ... }`\n                     let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n@@ -1492,23 +1496,22 @@ impl<'a> LoweringContext<'a> {\n                             self.path_global(e.span, strs)\n                         };\n \n-                        let into_iter = self.expr_path(into_iter_path, None);\n-                        self.expr_call(e.span, into_iter, hir_vec![head], None)\n+                        let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n+                        self.expr_call(e.span, into_iter, hir_vec![head])\n                     };\n \n                     let match_expr = self.expr_match(e.span,\n                                                      into_iter_expr,\n                                                      hir_vec![iter_arm],\n-                                                     hir::MatchSource::ForLoopDesugar,\n-                                                     None);\n+                                                     hir::MatchSource::ForLoopDesugar);\n \n                     // `{ let _result = ...; _result }`\n                     // underscore prevents an unused_variables lint if the head diverges\n                     let result_ident = self.str_to_ident(\"_result\");\n                     let (let_stmt, let_stmt_binding) =\n-                        self.stmt_let(e.span, false, result_ident, match_expr, None);\n+                        self.stmt_let(e.span, false, result_ident, match_expr);\n \n-                    let result = self.expr_ident(e.span, result_ident, None, let_stmt_binding);\n+                    let result = self.expr_ident(e.span, result_ident, let_stmt_binding);\n                     let block = self.block_all(e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n                     return self.expr_block(block, e.attrs.clone());\n@@ -1535,7 +1538,7 @@ impl<'a> LoweringContext<'a> {\n                     let ok_arm = {\n                         let val_ident = self.str_to_ident(\"val\");\n                         let val_pat = self.pat_ident(e.span, val_ident);\n-                        let val_expr = self.expr_ident(e.span, val_ident, None, val_pat.id);\n+                        let val_expr = self.expr_ident(e.span, val_ident, val_pat.id);\n                         let ok_pat = self.pat_ok(e.span, val_pat);\n \n                         self.arm(hir_vec![ok_pat], val_expr)\n@@ -1548,26 +1551,26 @@ impl<'a> LoweringContext<'a> {\n                         let from_expr = {\n                             let path = self.std_path(&[\"convert\", \"From\", \"from\"]);\n                             let path = self.path_global(e.span, path);\n-                            let from = self.expr_path(path, None);\n-                            let err_expr = self.expr_ident(e.span, err_ident, None, err_local.id);\n+                            let from = self.expr_path(path, ThinVec::new());\n+                            let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n-                            self.expr_call(e.span, from, hir_vec![err_expr], None)\n+                            self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n                         let err_expr = {\n                             let path = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n                             let path = self.path_global(e.span, path);\n-                            let err_ctor = self.expr_path(path, None);\n-                            self.expr_call(e.span, err_ctor, hir_vec![from_expr], None)\n+                            let err_ctor = self.expr_path(path, ThinVec::new());\n+                            self.expr_call(e.span, err_ctor, hir_vec![from_expr])\n                         };\n                         let err_pat = self.pat_err(e.span, err_local);\n                         let ret_expr = self.expr(e.span,\n-                                                 hir::Expr_::ExprRet(Some(err_expr)), None);\n-\n+                                                 hir::Expr_::ExprRet(Some(err_expr)),\n+                                                 ThinVec::new());\n                         self.arm(hir_vec![err_pat], ret_expr)\n                     };\n \n                     return self.expr_match(e.span, sub_expr, hir_vec![err_arm, ok_arm],\n-                                           hir::MatchSource::TryDesugar, None);\n+                                           hir::MatchSource::TryDesugar);\n                 }\n \n                 ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n@@ -1579,21 +1582,29 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_stmt(&mut self, s: &Stmt) -> hir::Stmt {\n         match s.node {\n-            StmtKind::Decl(ref d, id) => {\n-                Spanned {\n-                    node: hir::StmtDecl(self.lower_decl(d), id),\n+            StmtKind::Local(ref l) => Spanned {\n+                node: hir::StmtDecl(P(Spanned {\n+                    node: hir::DeclLocal(self.lower_local(l)),\n                     span: s.span,\n-                }\n-            }\n-            StmtKind::Expr(ref e, id) => {\n+                }), s.id),\n+                span: s.span,\n+            },\n+            StmtKind::Item(ref it) => Spanned {\n+                node: hir::StmtDecl(P(Spanned {\n+                    node: hir::DeclItem(self.lower_item_id(it)),\n+                    span: s.span,\n+                }), s.id),\n+                span: s.span,\n+            },\n+            StmtKind::Expr(ref e) => {\n                 Spanned {\n-                    node: hir::StmtExpr(self.lower_expr(e), id),\n+                    node: hir::StmtExpr(self.lower_expr(e), s.id),\n                     span: s.span,\n                 }\n             }\n-            StmtKind::Semi(ref e, id) => {\n+            StmtKind::Semi(ref e) => {\n                 Spanned {\n-                    node: hir::StmtSemi(self.lower_expr(e), id),\n+                    node: hir::StmtSemi(self.lower_expr(e), s.id),\n                     span: s.span,\n                 }\n             }\n@@ -1682,23 +1693,18 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         self.expr(span, hir::ExprBreak(None), attrs)\n     }\n \n-    fn expr_call(&mut self,\n-                 span: Span,\n-                 e: P<hir::Expr>,\n-                 args: hir::HirVec<P<hir::Expr>>,\n-                 attrs: ThinAttributes)\n+    fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<P<hir::Expr>>)\n                  -> P<hir::Expr> {\n-        self.expr(span, hir::ExprCall(e, args), attrs)\n+        self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n     }\n \n-    fn expr_ident(&mut self, span: Span, id: Name, attrs: ThinAttributes, binding: NodeId)\n-                  -> P<hir::Expr> {\n+    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> P<hir::Expr> {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n-        let expr = self.expr(span, expr_path, attrs);\n+        let expr = self.expr(span, expr_path, ThinVec::new());\n \n         let def = self.resolver.definitions().map(|defs| {\n             Def::Local(defs.local_def_id(binding), binding)\n@@ -1708,12 +1714,11 @@ impl<'a> LoweringContext<'a> {\n         expr\n     }\n \n-    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>, attrs: ThinAttributes)\n-                        -> P<hir::Expr> {\n-        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), attrs)\n+    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n+        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n-    fn expr_path(&mut self, path: hir::Path, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n         let expr = self.expr(path.span, hir::ExprPath(None, path), attrs);\n         self.resolver.record_resolution(expr.id, def);\n@@ -1724,34 +1729,32 @@ impl<'a> LoweringContext<'a> {\n                   span: Span,\n                   arg: P<hir::Expr>,\n                   arms: hir::HirVec<hir::Arm>,\n-                  source: hir::MatchSource,\n-                  attrs: ThinAttributes)\n+                  source: hir::MatchSource)\n                   -> P<hir::Expr> {\n-        self.expr(span, hir::ExprMatch(arg, arms, source), attrs)\n+        self.expr(span, hir::ExprMatch(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         self.expr(b.span, hir::ExprBlock(b), attrs)\n     }\n \n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>, attrs: ThinAttributes)\n-                  -> P<hir::Expr> {\n-        self.expr(sp, hir::ExprTup(exprs), attrs)\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>) -> P<hir::Expr> {\n+        self.expr(sp, hir::ExprTup(exprs), ThinVec::new())\n     }\n \n     fn expr_struct(&mut self,\n                    sp: Span,\n                    path: hir::Path,\n                    fields: hir::HirVec<hir::Field>,\n                    e: Option<P<hir::Expr>>,\n-                   attrs: ThinAttributes) -> P<hir::Expr> {\n+                   attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, false);\n         let expr = self.expr(sp, hir::ExprStruct(path, fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n \n-    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         P(hir::Expr {\n             id: self.next_id(),\n             node: node,\n@@ -1760,12 +1763,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn stmt_let(&mut self,\n-                sp: Span,\n-                mutbl: bool,\n-                ident: Name,\n-                ex: P<hir::Expr>,\n-                attrs: ThinAttributes)\n+    fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n                 -> (hir::Stmt, NodeId) {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, hir::BindByValue(hir::MutMutable))\n@@ -1779,7 +1777,7 @@ impl<'a> LoweringContext<'a> {\n             init: Some(ex),\n             id: self.next_id(),\n             span: sp,\n-            attrs: attrs,\n+            attrs: ThinVec::new(),\n         });\n         let decl = respan(sp, hir::DeclLocal(local));\n         (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n@@ -1939,7 +1937,7 @@ impl<'a> LoweringContext<'a> {\n                          expr: P<hir::Expr>,\n                          span: Span,\n                          rule: hir::BlockCheckMode,\n-                         attrs: ThinAttributes)\n+                         attrs: ThinVec<Attribute>)\n                          -> P<hir::Expr> {\n         let id = self.next_id();\n         let block = P(hir::Block {"}, {"sha": "50e8c6e7ab842e59adbec3e7336a1ec2a62492d7", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,9 +27,8 @@ use hir::map::{self, Node};\n use syntax::abi;\n use hir::{Block, FnDecl};\n use syntax::ast::{Attribute, Name, NodeId};\n-use syntax::attr::ThinAttributesExt;\n use hir as ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use hir::intravisit::FnKind;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl\n@@ -257,11 +256,7 @@ impl<'a> FnLikeNode<'a> {\n             }\n             map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, ref decl, ref block, _fn_decl_span) =>\n-                    closure(ClosureParts::new(&decl,\n-                                              &block,\n-                                              e.id,\n-                                              e.span,\n-                                              e.attrs.as_attr_slice())),\n+                    closure(ClosureParts::new(&decl, &block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "693d7a2edfca5cf726d366d74b3e8255bd6bdb2b", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -17,7 +17,7 @@ use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n pub struct NodeCollector<'ast> {"}, {"sha": "ccb3e154d9204906146d775d032b8a088cb45896", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -98,7 +98,7 @@ impl<'ast> DefCollector<'ast> {\n         self.parent_def = parent;\n     }\n \n-    fn visit_ast_const_integer(&mut self, expr: &'ast Expr) {\n+    fn visit_ast_const_integer(&mut self, expr: &Expr) {\n         // Find the node which will be used after lowering.\n         if let ExprKind::Paren(ref inner) = expr.node {\n             return self.visit_ast_const_integer(inner);\n@@ -124,8 +124,8 @@ impl<'ast> DefCollector<'ast> {\n     }\n }\n \n-impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n-    fn visit_item(&mut self, i: &'ast Item) {\n+impl<'ast> visit::Visitor for DefCollector<'ast> {\n+    fn visit_item(&mut self, i: &Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n         // Pick the def data. This need not be unique, but the more\n@@ -183,27 +183,28 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.ident.name));\n \n         self.with_parent(def, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n-    fn visit_generics(&mut self, generics: &'ast Generics) {\n+    fn visit_generics(&mut self, generics: &Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name));\n         }\n \n         visit::walk_generics(self, generics);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.name),\n             TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n+            TraitItemKind::Macro(..) => DefPathData::MacroDef(ti.ident.name),\n         };\n \n         let def = self.create_def(ti.id, def_data);\n@@ -216,7 +217,7 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name),\n@@ -234,7 +235,7 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         });\n     }\n \n-    fn visit_pat(&mut self, pat: &'ast Pat) {\n+    fn visit_pat(&mut self, pat: &Pat) {\n         let parent_def = self.parent_def;\n \n         if let PatKind::Ident(_, id, _) = pat.node {\n@@ -246,7 +247,7 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_expr(&mut self, expr: &'ast Expr) {\n+    fn visit_expr(&mut self, expr: &Expr) {\n         let parent_def = self.parent_def;\n \n         if let ExprKind::Repeat(_, ref count) = expr.node {\n@@ -262,18 +263,18 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_ty(&mut self, ty: &'ast Ty) {\n+    fn visit_ty(&mut self, ty: &Ty) {\n         if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n             self.visit_ast_const_integer(length);\n         }\n         visit::walk_ty(self, ty);\n     }\n \n-    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name));\n     }\n }"}, {"sha": "f9fb8ac66b7ef01292e3744ca870a9e58e375f7a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -23,9 +23,9 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n-use syntax::attr::ThinAttributesExt;\n-use syntax::codemap::{Span, Spanned};\n+use syntax::codemap::Spanned;\n use syntax::visit;\n+use syntax_pos::Span;\n \n use hir::*;\n use hir::fold::Folder;\n@@ -577,7 +577,7 @@ impl<'ast> Map<'ast> {\n             Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n             Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n-            Some(NodeExpr(ref e)) => Some(e.attrs.as_attr_slice()),\n+            Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition."}, {"sha": "a139dd152f006f5bcc51d26c0d26a1cb33ea7a21", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -36,13 +36,15 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FnvHashSet};\n \n-use syntax::codemap::{self, mk_sp, respan, Span, Spanned, ExpnId};\n+use syntax_pos::{mk_sp, Span, ExpnId};\n+use syntax::codemap::{self, respan, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n+use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n-use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n+use syntax::tokenstream::TokenTree;\n+use syntax::util::ThinVec;\n \n use std::collections::BTreeMap;\n use std::fmt;\n@@ -732,7 +734,7 @@ impl Stmt_ {\n         match *self {\n             StmtDecl(ref d, _) => d.node.attrs(),\n             StmtExpr(ref e, _) |\n-            StmtSemi(ref e, _) => e.attrs.as_attr_slice(),\n+            StmtSemi(ref e, _) => &e.attrs,\n         }\n     }\n \n@@ -756,7 +758,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n+    pub attrs: ThinVec<Attribute>,\n }\n \n pub type Decl = Spanned<Decl_>;\n@@ -772,7 +774,7 @@ pub enum Decl_ {\n impl Decl_ {\n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            DeclLocal(ref l) => l.attrs.as_attr_slice(),\n+            DeclLocal(ref l) => &l.attrs,\n             DeclItem(_) => &[]\n         }\n     }\n@@ -817,7 +819,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n+    pub attrs: ThinVec<Attribute>,\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "3bb9b6d260255065bee28fc7986777812297d13e", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,7 +14,8 @@ use hir::{self, PatKind};\n use ty::TyCtxt;\n use util::nodemap::FnvHashMap;\n use syntax::ast;\n-use syntax::codemap::{Span, Spanned, DUMMY_SP};\n+use syntax::codemap::Spanned;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use std::iter::{Enumerate, ExactSizeIterator};\n "}, {"sha": "598a2cfca1320de342cee8c50dc7d75af1c7b221", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,15 +12,16 @@ pub use self::AnnNode::*;\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n-use syntax::errors;\n+use syntax::codemap::{CodeMap, Spanned};\n use syntax::parse::token::{self, keywords, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n+use syntax_pos::{self, BytePos};\n+use errors;\n \n use hir;\n use hir::{Crate, PatKind, RegionTyParamBound, SelfKind, TraitTyParamBound, TraitBoundModifier};\n@@ -368,11 +369,11 @@ impl<'a> State<'a> {\n         self.end() // close the head-box\n     }\n \n-    pub fn bclose_(&mut self, span: codemap::Span, indented: usize) -> io::Result<()> {\n+    pub fn bclose_(&mut self, span: syntax_pos::Span, indented: usize) -> io::Result<()> {\n         self.bclose_maybe_open(span, indented, true)\n     }\n     pub fn bclose_maybe_open(&mut self,\n-                             span: codemap::Span,\n+                             span: syntax_pos::Span,\n                              indented: usize,\n                              close_box: bool)\n                              -> io::Result<()> {\n@@ -384,7 +385,7 @@ impl<'a> State<'a> {\n         }\n         Ok(())\n     }\n-    pub fn bclose(&mut self, span: codemap::Span) -> io::Result<()> {\n+    pub fn bclose(&mut self, span: syntax_pos::Span) -> io::Result<()> {\n         self.bclose_(span, indent_unit)\n     }\n \n@@ -432,7 +433,7 @@ impl<'a> State<'a> {\n                                   mut get_span: G)\n                                   -> io::Result<()>\n         where F: FnMut(&mut State, &T) -> io::Result<()>,\n-              G: FnMut(&T) -> codemap::Span\n+              G: FnMut(&T) -> syntax_pos::Span\n     {\n         self.rbox(0, b)?;\n         let len = elts.len();\n@@ -859,7 +860,7 @@ impl<'a> State<'a> {\n                           enum_definition: &hir::EnumDef,\n                           generics: &hir::Generics,\n                           name: ast::Name,\n-                          span: codemap::Span,\n+                          span: syntax_pos::Span,\n                           visibility: &hir::Visibility)\n                           -> io::Result<()> {\n         self.head(&visibility_qualified(visibility, \"enum\"))?;\n@@ -872,7 +873,7 @@ impl<'a> State<'a> {\n \n     pub fn print_variants(&mut self,\n                           variants: &[hir::Variant],\n-                          span: codemap::Span)\n+                          span: syntax_pos::Span)\n                           -> io::Result<()> {\n         self.bopen()?;\n         for v in variants {\n@@ -902,7 +903,7 @@ impl<'a> State<'a> {\n                         struct_def: &hir::VariantData,\n                         generics: &hir::Generics,\n                         name: ast::Name,\n-                        span: codemap::Span,\n+                        span: syntax_pos::Span,\n                         print_finalizer: bool)\n                         -> io::Result<()> {\n         self.print_name(name)?;\n@@ -2237,7 +2238,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn maybe_print_trailing_comment(&mut self,\n-                                        span: codemap::Span,\n+                                        span: syntax_pos::Span,\n                                         next_pos: Option<BytePos>)\n                                         -> io::Result<()> {\n         let cm = match self.cm {"}, {"sha": "c9235d063cba0981826648b5a7616d2ffd2c0998", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -49,7 +49,7 @@ use ty::relate::{RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n #[derive(Clone)]\n pub struct CombineFields<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {"}, {"sha": "894044296cbd6ecaf1816a3585faf7edc7424f5e", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -91,10 +91,10 @@ use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::errors::{DiagnosticBuilder, check_old_skool};\n-use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax_pos::{self, Pos, Span};\n+use errors::{DiagnosticBuilder, check_old_skool};\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -1933,6 +1933,6 @@ impl LifeGiver {\n \n fn name_to_dummy_lifetime(name: ast::Name) -> hir::Lifetime {\n     hir::Lifetime { id: ast::DUMMY_NODE_ID,\n-                    span: codemap::DUMMY_SP,\n+                    span: syntax_pos::DUMMY_SP,\n                     name: name }\n }"}, {"sha": "03a09917c5343bd1fce8783e2c1a524565290531", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -23,7 +23,7 @@ use super::region_inference::{TaintDirections};\n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n pub struct HrMatchResult<U> {"}, {"sha": "2ea2978b2940d858a482a408b98c424a4d2394b8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -39,9 +39,8 @@ use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n use syntax::ast;\n-use syntax::codemap;\n-use syntax::codemap::{Span, DUMMY_SP};\n-use syntax::errors::DiagnosticBuilder;\n+use errors::DiagnosticBuilder;\n+use syntax_pos::{self, Span, DUMMY_SP};\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use self::combine::CombineFields;\n@@ -1036,7 +1035,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                          -> UnitResult<'tcx>\n     {\n         self.probe(|_| {\n-            let origin = TypeOrigin::Misc(codemap::DUMMY_SP);\n+            let origin = TypeOrigin::Misc(syntax_pos::DUMMY_SP);\n             let trace = TypeTrace::types(origin, true, a, b);\n             self.sub(true, trace, &a, &b).map(|_| ())\n         })\n@@ -1813,7 +1812,7 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n \n     pub fn dummy(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n-            origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n+            origin: TypeOrigin::Misc(syntax_pos::DUMMY_SP),\n             values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n@@ -1887,7 +1886,7 @@ impl RegionVariableOrigin {\n             Coercion(a) => a,\n             EarlyBoundRegion(a, _) => a,\n             LateBoundRegion(a, _, _) => a,\n-            BoundRegionInCoherence(_) => codemap::DUMMY_SP,\n+            BoundRegionInCoherence(_) => syntax_pos::DUMMY_SP,\n             UpvarRegion(_, a) => a\n         }\n     }"}, {"sha": "09ae16540c4f159666c843c18db912ddb0006ab1", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,7 +13,7 @@ use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n use hir::def_id::{DefId};\n use ty::{self, Ty};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use std::cmp::min;\n use std::marker::PhantomData;"}, {"sha": "eb9dd7dfcb36f8d57818042e1c50b973f4b40ce1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -55,8 +55,10 @@ extern crate rustc_data_structures;\n extern crate serialize;\n extern crate collections;\n extern crate rustc_const_math;\n+extern crate rustc_errors as errors;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+#[macro_use] extern crate syntax_pos;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "3e101e1934f294ce80a5d6d76220523321dfe50f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -40,11 +40,10 @@ use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::Span;\n-use syntax::errors::DiagnosticBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n-use syntax::attr::ThinAttributesExt;\n+use syntax_pos::Span;\n+use errors::DiagnosticBuilder;\n use hir;\n use hir::intravisit as hir_visit;\n use hir::intravisit::{IdVisitor, IdVisitingOperation};\n@@ -767,7 +766,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n-        self.with_lint_attrs(e.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n         })\n@@ -832,7 +831,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n-        self.with_lint_attrs(l.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })\n@@ -905,7 +904,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n+impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n     fn visit_item(&mut self, it: &ast::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, early_passes, it);\n@@ -928,7 +927,7 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n     }\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n-        self.with_lint_attrs(e.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, early_passes, e);\n             ast_visit::walk_expr(cx, e);\n         })\n@@ -939,8 +938,8 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         ast_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: ast_visit::FnKind<'v>, decl: &'v ast::FnDecl,\n-                body: &'v ast::Block, span: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: ast_visit::FnKind, decl: &ast::FnDecl,\n+                body: &ast::Block, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, early_passes, fk, decl, body, span, id);\n         ast_visit::walk_fn(self, fk, decl, body, span);\n         run_lints!(self, check_fn_post, early_passes, fk, decl, body, span, id);\n@@ -988,7 +987,7 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n     }\n \n     fn visit_local(&mut self, l: &ast::Local) {\n-        self.with_lint_attrs(l.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, early_passes, l);\n             ast_visit::walk_local(cx, l);\n         })\n@@ -1005,11 +1004,6 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         ast_visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &ast::Decl) {\n-        run_lints!(self, check_decl, early_passes, d);\n-        ast_visit::walk_decl(self, d);\n-    }\n-\n     fn visit_expr_post(&mut self, e: &ast::Expr) {\n         run_lints!(self, check_expr_post, early_passes, e);\n     }"}, {"sha": "92aa446c265f9f791d3911d063357a0a1a0809ea", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -33,7 +33,7 @@ pub use self::LintSource::*;\n \n use std::hash;\n use std::ascii::AsciiExt;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use hir::intravisit::FnKind;\n use syntax::visit as ast_visit;\n use syntax::ast;\n@@ -195,7 +195,6 @@ pub trait EarlyLintPass: LintPass {\n     fn check_stmt(&mut self, _: &EarlyContext, _: &ast::Stmt) { }\n     fn check_arm(&mut self, _: &EarlyContext, _: &ast::Arm) { }\n     fn check_pat(&mut self, _: &EarlyContext, _: &ast::Pat) { }\n-    fn check_decl(&mut self, _: &EarlyContext, _: &ast::Decl) { }\n     fn check_expr(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n     fn check_expr_post(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n     fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }"}, {"sha": "e856eb84ff2c3a93f33259acb9504d9dcb793fe7", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -17,7 +17,7 @@\n use hir::def::Def;\n use ty::{Ty, TyCtxt};\n \n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use hir as ast;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "fd9463b13c055143eb208e4238b719a30ea4514f", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -39,9 +39,9 @@ use std::rc::Rc;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::Span;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n+use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n use hir::intravisit::{IdVisitor, IdVisitingOperation, Visitor};"}, {"sha": "2b59e603cc897f7b33f80846304942b0eda1106c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -26,6 +26,7 @@ use lint;\n use std::collections::HashSet;\n use syntax::{ast, codemap};\n use syntax::attr;\n+use syntax_pos;\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live NodeItem that is a\n@@ -215,7 +216,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_variant_data(&mut self, def: &hir::VariantData, _: ast::Name,\n-                        _: &hir::Generics, _: ast::NodeId, _: codemap::Span) {\n+                        _: &hir::Generics, _: ast::NodeId, _: syntax_pos::Span) {\n         let has_extern_repr = self.struct_has_extern_repr;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n         let live_fields = def.fields().iter().filter(|f| {\n@@ -478,7 +479,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n \n     fn warn_dead_code(&mut self,\n                       id: ast::NodeId,\n-                      span: codemap::Span,\n+                      span: syntax_pos::Span,\n                       name: ast::Name,\n                       node_type: &str) {\n         let name = name.as_str();"}, {"sha": "6fe98119c706088f2d68b2a645237e7d7abafe5e", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,7 +18,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::MethodCall;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use hir;\n use hir::intravisit;\n use hir::intravisit::{FnKind, Visitor};"}, {"sha": "23a261400ed076690f3cddaaf93d789e916947eb", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,8 +15,8 @@ use hir::def_id::{CRATE_DEF_INDEX};\n use session::{config, Session};\n use syntax::ast::NodeId;\n use syntax::attr;\n-use syntax::codemap::Span;\n use syntax::entry::EntryPointType;\n+use syntax_pos::Span;\n use hir::{Item, ItemFn};\n use hir::intravisit::Visitor;\n "}, {"sha": "4e0b76365041c45530dcd99b1284b8c5919839ca", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -30,7 +30,7 @@ use hir::{self, PatKind};\n \n use syntax::ast;\n use syntax::ptr::P;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait"}, {"sha": "d753381d71e252eb5e9ef15f5a76414a0d581d5e", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,7 +18,7 @@ use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n \n use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use hir::intravisit::{self, Visitor, FnKind};\n use hir;\n "}, {"sha": "cb2f68bb5539706ee0c8ca703a6d94eb0de0df6e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -123,9 +123,10 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n-use syntax::codemap::{BytePos, original_sp, Span};\n+use syntax::codemap::original_sp;\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n+use syntax_pos::{BytePos, Span};\n \n use hir::Expr;\n use hir;"}, {"sha": "a70829347f1c155deb61449e060f68efe52734bd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -83,7 +83,7 @@ use hir::{MutImmutable, MutMutable, PatKind};\n use hir::pat_util::EnumerateAndAdjustIterator;\n use hir;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use std::fmt;\n use std::rc::Rc;"}, {"sha": "6f0ad087dc5898ad72b259f267274654ac5c467a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,8 +27,9 @@ use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::fmt;\n use std::mem;\n-use syntax::codemap::{self, Span};\n+use syntax::codemap;\n use syntax::ast::{self, NodeId};\n+use syntax_pos::Span;\n \n use hir;\n use hir::intravisit::{self, Visitor, FnKind};"}, {"sha": "2ba05b4ae3212bbf81409f449b8c5ab0615a94ba", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -29,8 +29,8 @@ use ty;\n use std::fmt;\n use std::mem::replace;\n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n+use syntax_pos::Span;\n use util::nodemap::NodeMap;\n \n use rustc_data_structures::fnv::FnvHashSet;"}, {"sha": "36268a9de960fcdab041ef8e44b4698332ab8170", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -23,7 +23,7 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use ty::{self, TyCtxt};\n use middle::privacy::AccessLevels;\n use syntax::parse::token::InternedString;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};"}, {"sha": "20c5320fd6464f274bc5291c52ff35a39ffd5e83", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,8 +15,8 @@ use session::Session;\n use middle::lang_items;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n+use syntax_pos::Span;\n use hir::intravisit::Visitor;\n use hir::intravisit;\n use hir;"}, {"sha": "1be7d00f072cd884b263ab2ae9208a3f2cce93a3", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,7 +15,7 @@ use mir::repr::{Mir, BasicBlock};\n \n use rustc_serialize as serialize;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct Cache {\n     predecessors: RefCell<Option<IndexVec<BasicBlock, Vec<BasicBlock>>>>\n }"}, {"sha": "62d3421770c2f2cefe0a28ce6115ac5e006e21d1", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,6 +12,9 @@ use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n+use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -24,8 +27,9 @@ use std::cell::Ref;\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n+use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use super::cache::Cache;\n \n@@ -54,7 +58,7 @@ macro_rules! newtype_index {\n }\n \n /// Lowered representation of a single function.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -145,6 +149,11 @@ impl<'tcx> Mir<'tcx> {\n         Ref::map(self.predecessors(), |p| &p[bb])\n     }\n \n+    #[inline]\n+    pub fn dominators(&self) -> Dominators<BasicBlock> {\n+        dominators(self)\n+    }\n+\n     /// Maps locals (Arg's, Var's, Temp's and ReturnPointer, in that order)\n     /// to their index in the whole list of locals. This is useful if you\n     /// want to treat all locals the same instead of repeating yourself.\n@@ -1190,3 +1199,33 @@ fn node_to_string(node_id: ast::NodeId) -> String {\n fn item_path_str(def_id: DefId) -> String {\n     ty::tls::with(|tcx| tcx.item_path_str(def_id))\n }\n+\n+impl<'tcx> ControlFlowGraph for Mir<'tcx> {\n+\n+    type Node = BasicBlock;\n+\n+    fn num_nodes(&self) -> usize { self.basic_blocks.len() }\n+\n+    fn start_node(&self) -> Self::Node { START_BLOCK }\n+\n+    fn predecessors<'graph>(&'graph self, node: Self::Node)\n+                            -> <Self as GraphPredecessors<'graph>>::Iter\n+    {\n+        self.predecessors_for(node).clone().into_iter()\n+    }\n+    fn successors<'graph>(&'graph self, node: Self::Node)\n+                          -> <Self as GraphSuccessors<'graph>>::Iter\n+    {\n+        self.basic_blocks[node].terminator().successors().into_owned().into_iter()\n+    }\n+}\n+\n+impl<'a, 'b> GraphPredecessors<'b> for Mir<'a> {\n+    type Item = BasicBlock;\n+    type Iter = IntoIter<BasicBlock>;\n+}\n+\n+impl<'a, 'b>  GraphSuccessors<'b> for Mir<'a> {\n+    type Item = BasicBlock;\n+    type Iter = IntoIter<BasicBlock>;\n+}"}, {"sha": "3f714ff4d5152b3eef0a134fc49b92232e4b0d62", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,7 +16,7 @@ use mir::repr::*;\n use rustc_const_math::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n // # The MIR Visitor\n //"}, {"sha": "a37990061920b6fa299a2de535010bb78a8490e7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -26,11 +26,12 @@ use middle::cstore;\n use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::errors::{ColorConfig, Handler};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::feature_gate::UnstableFeatures;\n \n+use errors::{ColorConfig, Handler};\n+\n use getopts;\n use std::collections::HashMap;\n use std::env;\n@@ -1420,12 +1421,11 @@ mod tests {\n     use middle::cstore::DummyCrateStore;\n     use session::config::{build_configuration, build_session_options};\n     use session::build_session;\n-\n+    use errors;\n     use std::rc::Rc;\n     use getopts::{getopts, OptGroup};\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n-    use syntax::diagnostics;\n \n     fn optgroups() -> Vec<OptGroup> {\n         super::rustc_optgroups().into_iter()\n@@ -1442,7 +1442,7 @@ mod tests {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n-        let registry = diagnostics::registry::Registry::new(&[]);\n+        let registry = errors::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess);\n@@ -1462,7 +1462,7 @@ mod tests {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n               }\n             };\n-        let registry = diagnostics::registry::Registry::new(&[]);\n+        let registry = errors::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry,\n                                  Rc::new(DummyCrateStore));\n@@ -1479,7 +1479,7 @@ mod tests {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n             ], &optgroups()).unwrap();\n-            let registry = diagnostics::registry::Registry::new(&[]);\n+            let registry = errors::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n@@ -1491,7 +1491,7 @@ mod tests {\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n             ], &optgroups()).unwrap();\n-            let registry = diagnostics::registry::Registry::new(&[]);\n+            let registry = errors::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n@@ -1502,7 +1502,7 @@ mod tests {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n             ], &optgroups()).unwrap();\n-            let registry = diagnostics::registry::Registry::new(&[]);\n+            let registry = errors::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));"}, {"sha": "77259cea24d28265ddac5472e72fb52bb35afe33", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -21,17 +21,16 @@ use util::nodemap::{NodeMap, FnvHashMap};\n use mir::transform as mir_pass;\n \n use syntax::ast::{NodeId, NodeIdAssigner, Name};\n-use syntax::codemap::{Span, MultiSpan};\n-use syntax::errors::{self, DiagnosticBuilder};\n-use syntax::errors::emitter::{Emitter, BasicEmitter, EmitterWriter};\n-use syntax::errors::json::JsonEmitter;\n-use syntax::diagnostics;\n+use errors::{self, DiagnosticBuilder};\n+use errors::emitter::{Emitter, BasicEmitter, EmitterWriter};\n+use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n use syntax::parse::ParseSess;\n use syntax::parse::token;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n+use syntax_pos::{Span, MultiSpan};\n \n use rustc_back::target::Target;\n use llvm;\n@@ -424,7 +423,7 @@ fn split_msg_into_multilines(msg: &str) -> Option<String> {\n pub fn build_session(sopts: config::Options,\n                      dep_graph: &DepGraph,\n                      local_crate_source_file: Option<PathBuf>,\n-                     registry: diagnostics::registry::Registry,\n+                     registry: errors::registry::Registry,\n                      cstore: Rc<for<'a> CrateStore<'a>>)\n                      -> Session {\n     build_session_with_codemap(sopts,\n@@ -438,7 +437,7 @@ pub fn build_session(sopts: config::Options,\n pub fn build_session_with_codemap(sopts: config::Options,\n                                   dep_graph: &DepGraph,\n                                   local_crate_source_file: Option<PathBuf>,\n-                                  registry: diagnostics::registry::Registry,\n+                                  registry: errors::registry::Registry,\n                                   cstore: Rc<for<'a> CrateStore<'a>>,\n                                   codemap: Rc<codemap::CodeMap>)\n                                   -> Session {\n@@ -455,7 +454,10 @@ pub fn build_session_with_codemap(sopts: config::Options,\n \n     let emitter: Box<Emitter> = match sopts.error_format {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(EmitterWriter::stderr(color_config, Some(registry), codemap.clone()))\n+            Box::new(EmitterWriter::stderr(color_config,\n+                                           Some(registry),\n+                                           codemap.clone(),\n+                                           errors::snippet::FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => {\n             Box::new(JsonEmitter::stderr(Some(registry), codemap.clone()))"}, {"sha": "4344eb1ebf6645faf708d6f0c55677fd10c5b004", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -17,7 +17,7 @@ use hir::def_id::DefId;\n use ty::subst::TypeSpace;\n use ty::{self, Ty, TyCtxt};\n use infer::{InferCtxt, TypeOrigin};\n-use syntax::codemap::DUMMY_SP;\n+use syntax_pos::DUMMY_SP;\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);"}, {"sha": "b6591471f0eef76277f2eb60a98e304bbe706587", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -37,8 +37,8 @@ use std::cmp;\n use std::fmt;\n use syntax::ast;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n-use syntax::codemap::Span;\n-use syntax::errors::DiagnosticBuilder;\n+use syntax_pos::Span;\n+use errors::DiagnosticBuilder;\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n pub struct TraitErrorKey<'tcx> {"}, {"sha": "68db5f864763964757e3680b980b6fecc2f5160c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -23,7 +23,7 @@ use infer::InferCtxt;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n pub use self::error_reporting::TraitErrorKey;\n pub use self::coherence::orphan_check;"}, {"sha": "9348def1311eb01de1616d24878b3e00769a3c25", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,7 +27,7 @@ use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, ProjectionMode, ObligationCause, Normalized};\n use ty::{self, TyCtxt};\n-use syntax::codemap::DUMMY_SP;\n+use syntax_pos::DUMMY_SP;\n \n pub mod specialization_graph;\n "}, {"sha": "a097c0093b2e116ec470f8f8f270b74b6f67fdd9", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,7 +12,7 @@ use hir::def_id::DefId;\n use infer::InferCtxt;\n use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n "}, {"sha": "47ca7d335ab822b0c8b1a1bd40f1083c278fba3a", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,7 +15,7 @@ use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFoldable};\n use ty::LvaluePreference::{NoPreference};\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use hir;\n "}, {"sha": "219cb5e383a8d00ebc3b8dc270ca48bcc1e6a593", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -862,7 +862,7 @@ pub mod tls {\n \n     use std::cell::Cell;\n     use std::fmt;\n-    use syntax::codemap;\n+    use syntax_pos;\n \n     /// Marker types used for the scoped TLS slot.\n     /// The type context cannot be used directly because the scoped TLS\n@@ -875,7 +875,7 @@ pub mod tls {\n                                      *const ThreadLocalInterners)>> = Cell::new(None)\n     }\n \n-    fn span_debug(span: codemap::Span, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter) -> fmt::Result {\n         with(|tcx| {\n             write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n         })\n@@ -884,7 +884,7 @@ pub mod tls {\n     pub fn enter_global<'gcx, F, R>(gcx: GlobalCtxt<'gcx>, f: F) -> R\n         where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n     {\n-        codemap::SPAN_DEBUG.with(|span_dbg| {\n+        syntax_pos::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n             let result = enter(&gcx, &gcx.global_interners, f);"}, {"sha": "bddc2dbdb7e779e63c6237837ecda20a86ce89cf", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,8 +16,8 @@ use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n use std::fmt;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::codemap::Span;\n-use syntax::errors::DiagnosticBuilder;\n+use errors::DiagnosticBuilder;\n+use syntax_pos::Span;\n \n use hir;\n "}, {"sha": "61c8aa8fcebf368688950ccbc70503f57dc1d816", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -21,7 +21,7 @@ use util::common::slice_pat;\n \n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n-use syntax::codemap::DUMMY_SP;\n+use syntax_pos::DUMMY_SP;\n \n use std::cmp;\n use std::fmt;"}, {"sha": "14db922d298101e82c941202deb7834743b9f4f4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -44,8 +44,8 @@ use std::slice;\n use std::vec::IntoIter;\n use syntax::ast::{self, CrateNum, Name, NodeId};\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n+use syntax_pos::{DUMMY_SP, Span};\n \n use rustc_const_math::ConstInt;\n "}, {"sha": "595d965ffce262eede9050e22016b4c24b4ecb7e", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -22,7 +22,7 @@ use std::fmt;\n use std::iter::IntoIterator;\n use std::slice::Iter;\n use std::vec::{Vec, IntoIter};\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n ///////////////////////////////////////////////////////////////////////////\n "}, {"sha": "ee7fb5fc94b7752ea8ac31d2e8a778b319f93810", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,7 +27,7 @@ use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n use syntax::ast::{self, Name};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use hir;\n "}, {"sha": "37ba936d2f42a73f71a6e3193cdfbf183345d6e5", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,7 +16,7 @@ use traits;\n use ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use util::common::ErrorReported;\n \n /// Returns the set of obligations needed to make `ty` well-formed."}, {"sha": "d53318f1768480674f384b513b06e281fda7ff82", "filename": "src/librustc_borrowck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,7 +12,9 @@ test = false\n [dependencies]\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n graphviz = { path = \"../libgraphviz\" }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_mir = { path = \"../librustc_mir\" }\n+rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "9cae270984f0047cce5f873e6004b5c47fe6722b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,7 +27,7 @@ use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir;\n \n use std::rc::Rc;"}, {"sha": "d3d6fa9eb52b59dc46db40f6b15d5350eb1d951b", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,8 +27,8 @@ use rustc::middle::mem_categorization as mc;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap::{Span, DUMMY_SP};\n use syntax::attr::AttrMetaMethods;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n enum Fragment {"}, {"sha": "9431dcdbcac8ef897f7200be332b8360ca1c4c4e", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -22,7 +22,7 @@ use rustc::ty;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir::{self, PatKind};\n \n struct GatherMoveInfo<'tcx> {"}, {"sha": "e34c6e567bd8ece197adcf425ef455f1e2d9eb22", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,7 +19,7 @@ use rustc::middle::region;\n use rustc::ty;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n type R = Result<(),()>;\n "}, {"sha": "c982fc091d24c0d8ddebce581190335a86635ca8", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -25,8 +25,8 @@ use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n \n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::ast::NodeId;\n+use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Expr;\n use rustc::hir::intravisit;"}, {"sha": "fc17633d63b93b5a50d9ef1e681e528028c80dba", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,8 +14,8 @@ use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::ty;\n use syntax::ast;\n-use syntax::codemap;\n-use syntax::errors::DiagnosticBuilder;\n+use syntax_pos;\n+use errors::DiagnosticBuilder;\n use rustc::hir;\n \n pub struct MoveErrorCollector<'tcx> {\n@@ -56,7 +56,7 @@ impl<'tcx> MoveError<'tcx> {\n \n #[derive(Clone)]\n pub struct MoveSpanAndPath {\n-    pub span: codemap::Span,\n+    pub span: syntax_pos::Span,\n     pub name: ast::Name,\n }\n \n@@ -169,7 +169,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n fn note_move_destination(mut err: DiagnosticBuilder,\n-                         move_to_span: codemap::Span,\n+                         move_to_span: syntax_pos::Span,\n                          pat_name: ast::Name,\n                          is_first_note: bool) -> DiagnosticBuilder {\n     if is_first_note {"}, {"sha": "3d9df4c8bd0082c2220af04904811d9d4a2a8146", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use borrowck::ToInteriorKind;\n "}, {"sha": "d59bdf93f3225e4e33fb32689fd74b172e9aa238", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::abi::{Abi};\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::repr::{self, Mir};"}, {"sha": "623ea60c5a6d88c508da63434985d1f01ef5ddab", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use std::fmt;\n use std::u32;"}, {"sha": "7481b15685e6991c62b185e00be446523a952026", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,8 +12,8 @@ use borrowck::BorrowckCtxt;\n \n use syntax::ast::{self, MetaItem};\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ptr::P;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir;\n use rustc::hir::intravisit::{FnKind};"}, {"sha": "e86120b73bf97670bf59c2b7496ae76740bf4c2f", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -43,8 +43,8 @@ use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{MultiSpan, Span};\n-use syntax::errors::DiagnosticBuilder;\n+use syntax_pos::{MultiSpan, Span};\n+use errors::DiagnosticBuilder;\n \n use rustc::hir;\n use rustc::hir::{FnDecl, Block};"}, {"sha": "4b8cbbffaa5efafd942300e05aed64a1d4c71fbd", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -28,7 +28,7 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use std::usize;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n "}, {"sha": "16fefee347269318b59f96f326c0f74bf847cd11", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -28,6 +28,8 @@\n #![feature(question_mark)]\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+extern crate syntax_pos;\n+extern crate rustc_errors as errors;\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits."}, {"sha": "01872bbe3c04996a87089b757b494c253dd42c3d", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,3 +16,4 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "c878edcd4b2a80c45865add1582093f72441adf8", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -37,7 +37,8 @@ use rustc::hir::intravisit::{self, IdVisitor, IdVisitingOperation, Visitor, FnKi\n use rustc_back::slice;\n \n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n-use syntax::codemap::{Span, Spanned, DUMMY_SP};\n+use syntax::codemap::Spanned;\n+use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n@@ -451,7 +452,7 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n         id: 0,\n         node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     })\n }\n "}, {"sha": "c03903515abe6885c084d915172c1656263d7f1f", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -33,10 +33,10 @@ use syntax::ast;\n use rustc::hir::{Expr, PatKind};\n use rustc::hir;\n use rustc::hir::intravisit::FnKind;\n-use syntax::codemap::Span;\n use syntax::ptr::P;\n use syntax::codemap;\n use syntax::attr::IntType;\n+use syntax_pos::{self, Span};\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n@@ -301,7 +301,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let field_pats =\n                 try!(fields.iter()\n                            .map(|field| Ok(codemap::Spanned {\n-                               span: codemap::DUMMY_SP,\n+                               span: syntax_pos::DUMMY_SP,\n                                node: hir::FieldPat {\n                                    name: field.name.node,\n                                    pat: try!(const_expr_to_pat(tcx, &field.expr,"}, {"sha": "2da9a55f1fd441c7f1e4d58b04b9a857c7f6354d", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -38,7 +38,7 @@\n extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate graphviz;\n-\n+extern crate syntax_pos;\n extern crate serialize as rustc_serialize; // used by deriving\n \n // NB: This module needs to be declared first so diagnostics are"}, {"sha": "250b89d12ed0510eb8774b2700eb62ef53fad833", "filename": "src/librustc_data_structures/control_flow_graph/dominators/mod.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,284 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Algorithm citation:\n+//! A Simple, Fast Dominance Algorithm.\n+//! Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy\n+//! Rice Computer Science TS-06-33870\n+//! https://www.cs.rice.edu/~keith/EMBED/dom.pdf\n+\n+use super::ControlFlowGraph;\n+use super::iterate::reverse_post_order;\n+use super::super::indexed_vec::{IndexVec, Idx};\n+\n+use std::fmt;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n+    let start_node = graph.start_node();\n+    let rpo = reverse_post_order(graph, start_node);\n+    dominators_given_rpo(graph, &rpo)\n+}\n+\n+pub fn dominators_given_rpo<G: ControlFlowGraph>(graph: &G,\n+                                                 rpo: &[G::Node])\n+                                                 -> Dominators<G::Node> {\n+    let start_node = graph.start_node();\n+    assert_eq!(rpo[0], start_node);\n+\n+    // compute the post order index (rank) for each node\n+    let mut post_order_rank: IndexVec<G::Node, usize> = IndexVec::from_elem_n(usize::default(),\n+                                                                              graph.num_nodes());\n+    for (index, node) in rpo.iter().rev().cloned().enumerate() {\n+        post_order_rank[node] = index;\n+    }\n+\n+    let mut immediate_dominators: IndexVec<G::Node, Option<G::Node>> =\n+        IndexVec::from_elem_n(Option::default(), graph.num_nodes());\n+    immediate_dominators[start_node] = Some(start_node);\n+\n+    let mut changed = true;\n+    while changed {\n+        changed = false;\n+\n+        for &node in &rpo[1..] {\n+            let mut new_idom = None;\n+            for pred in graph.predecessors(node) {\n+                if immediate_dominators[pred].is_some() {\n+                    // (*)\n+                    // (*) dominators for `pred` have been calculated\n+                    new_idom = intersect_opt(&post_order_rank,\n+                                                  &immediate_dominators,\n+                                                  new_idom,\n+                                                  Some(pred));\n+                }\n+            }\n+\n+            if new_idom != immediate_dominators[node] {\n+                immediate_dominators[node] = new_idom;\n+                changed = true;\n+            }\n+        }\n+    }\n+\n+    Dominators {\n+        post_order_rank: post_order_rank,\n+        immediate_dominators: immediate_dominators,\n+    }\n+}\n+\n+fn intersect_opt<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n+                                      immediate_dominators: &IndexVec<Node, Option<Node>>,\n+                                      node1: Option<Node>,\n+                                      node2: Option<Node>)\n+                                      -> Option<Node> {\n+    match (node1, node2) {\n+        (None, None) => None,\n+        (Some(n), None) | (None, Some(n)) => Some(n),\n+        (Some(n1), Some(n2)) => Some(intersect(post_order_rank, immediate_dominators, n1, n2)),\n+    }\n+}\n+\n+fn intersect<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n+                                  immediate_dominators: &IndexVec<Node, Option<Node>>,\n+                                  mut node1: Node,\n+                                  mut node2: Node)\n+                                  -> Node {\n+    while node1 != node2 {\n+        while post_order_rank[node1] < post_order_rank[node2] {\n+            node1 = immediate_dominators[node1].unwrap();\n+        }\n+\n+        while post_order_rank[node2] < post_order_rank[node1] {\n+            node2 = immediate_dominators[node2].unwrap();\n+        }\n+    }\n+    return node1;\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Dominators<N: Idx> {\n+    post_order_rank: IndexVec<N, usize>,\n+    immediate_dominators: IndexVec<N, Option<N>>,\n+}\n+\n+impl<Node: Idx> Dominators<Node> {\n+    pub fn is_reachable(&self, node: Node) -> bool {\n+        self.immediate_dominators[node].is_some()\n+    }\n+\n+    pub fn immediate_dominator(&self, node: Node) -> Node {\n+        assert!(self.is_reachable(node), \"node {:?} is not reachable\", node);\n+        self.immediate_dominators[node].unwrap()\n+    }\n+\n+    pub fn dominators(&self, node: Node) -> Iter<Node> {\n+        assert!(self.is_reachable(node), \"node {:?} is not reachable\", node);\n+        Iter {\n+            dominators: self,\n+            node: Some(node),\n+        }\n+    }\n+\n+    pub fn is_dominated_by(&self, node: Node, dom: Node) -> bool {\n+        // FIXME -- could be optimized by using post-order-rank\n+        self.dominators(node).any(|n| n == dom)\n+    }\n+\n+    pub fn mutual_dominator_node(&self, node1: Node, node2: Node) -> Node {\n+        assert!(self.is_reachable(node1),\n+                \"node {:?} is not reachable\",\n+                node1);\n+        assert!(self.is_reachable(node2),\n+                \"node {:?} is not reachable\",\n+                node2);\n+        intersect::<Node>(&self.post_order_rank,\n+                  &self.immediate_dominators,\n+                  node1,\n+                  node2)\n+    }\n+\n+    pub fn mutual_dominator<I>(&self, iter: I) -> Option<Node>\n+        where I: IntoIterator<Item = Node>\n+    {\n+        let mut iter = iter.into_iter();\n+        iter.next()\n+            .map(|dom| iter.fold(dom, |dom, node| self.mutual_dominator_node(dom, node)))\n+    }\n+\n+    pub fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n+        &self.immediate_dominators\n+    }\n+\n+    pub fn dominator_tree(&self) -> DominatorTree<Node> {\n+        let elem: Vec<Node> = Vec::new();\n+        let mut children: IndexVec<Node, Vec<Node>> =\n+            IndexVec::from_elem_n(elem, self.immediate_dominators.len());\n+        let mut root = None;\n+        for (index, immed_dom) in self.immediate_dominators.iter().enumerate() {\n+            let node = Node::new(index);\n+            match *immed_dom {\n+                None => {\n+                    // node not reachable\n+                }\n+                Some(immed_dom) => {\n+                    if node == immed_dom {\n+                        root = Some(node);\n+                    } else {\n+                        children[immed_dom].push(node);\n+                    }\n+                }\n+            }\n+        }\n+        DominatorTree {\n+            root: root.unwrap(),\n+            children: children,\n+        }\n+    }\n+}\n+\n+pub struct Iter<'dom, Node: Idx + 'dom> {\n+    dominators: &'dom Dominators<Node>,\n+    node: Option<Node>,\n+}\n+\n+impl<'dom, Node: Idx> Iterator for Iter<'dom, Node> {\n+    type Item = Node;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(node) = self.node {\n+            let dom = self.dominators.immediate_dominator(node);\n+            if dom == node {\n+                self.node = None; // reached the root\n+            } else {\n+                self.node = Some(dom);\n+            }\n+            return Some(node);\n+        } else {\n+            return None;\n+        }\n+    }\n+}\n+\n+pub struct DominatorTree<N: Idx> {\n+    root: N,\n+    children: IndexVec<N, Vec<N>>,\n+}\n+\n+impl<Node: Idx> DominatorTree<Node> {\n+    pub fn root(&self) -> Node {\n+        self.root\n+    }\n+\n+    pub fn children(&self, node: Node) -> &[Node] {\n+        &self.children[node]\n+    }\n+\n+    pub fn iter_children_of(&self, node: Node) -> IterChildrenOf<Node> {\n+        IterChildrenOf {\n+            tree: self,\n+            stack: vec![node],\n+        }\n+    }\n+}\n+\n+pub struct IterChildrenOf<'iter, Node: Idx + 'iter> {\n+    tree: &'iter DominatorTree<Node>,\n+    stack: Vec<Node>,\n+}\n+\n+impl<'iter, Node: Idx> Iterator for IterChildrenOf<'iter, Node> {\n+    type Item = Node;\n+\n+    fn next(&mut self) -> Option<Node> {\n+        if let Some(node) = self.stack.pop() {\n+            self.stack.extend(self.tree.children(node));\n+            Some(node)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<Node: Idx> fmt::Debug for DominatorTree<Node> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt::Debug::fmt(&DominatorTreeNode {\n+                            tree: self,\n+                            node: self.root,\n+                        },\n+                        fmt)\n+    }\n+}\n+\n+struct DominatorTreeNode<'tree, Node: Idx> {\n+    tree: &'tree DominatorTree<Node>,\n+    node: Node,\n+}\n+\n+impl<'tree, Node: Idx> fmt::Debug for DominatorTreeNode<'tree, Node> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        let subtrees: Vec<_> = self.tree\n+            .children(self.node)\n+            .iter()\n+            .map(|&child| {\n+                DominatorTreeNode {\n+                    tree: self.tree,\n+                    node: child,\n+                }\n+            })\n+            .collect();\n+        fmt.debug_tuple(\"\")\n+            .field(&self.node)\n+            .field(&subtrees)\n+            .finish()\n+    }\n+}"}, {"sha": "a6db5f2fe3ea1bdfbc58bbcd2042afc730bf3759", "filename": "src/librustc_data_structures/control_flow_graph/dominators/test.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::super::test::TestGraph;\n+\n+use super::*;\n+\n+#[test]\n+fn diamond() {\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (0, 2),\n+        (1, 3),\n+        (2, 3),\n+    ]);\n+\n+    let dominators = dominators(&graph);\n+    let immediate_dominators = dominators.all_immediate_dominators();\n+    assert_eq!(immediate_dominators[0], Some(0));\n+    assert_eq!(immediate_dominators[1], Some(0));\n+    assert_eq!(immediate_dominators[2], Some(0));\n+    assert_eq!(immediate_dominators[3], Some(0));\n+}\n+\n+#[test]\n+fn paper() {\n+    // example from the paper:\n+    let graph = TestGraph::new(6, &[\n+        (6, 5),\n+        (6, 4),\n+        (5, 1),\n+        (4, 2),\n+        (4, 3),\n+        (1, 2),\n+        (2, 3),\n+        (3, 2),\n+        (2, 1),\n+    ]);\n+\n+    let dominators = dominators(&graph);\n+    let immediate_dominators = dominators.all_immediate_dominators();\n+    assert_eq!(immediate_dominators[0], None); // <-- note that 0 is not in graph\n+    assert_eq!(immediate_dominators[1], Some(6));\n+    assert_eq!(immediate_dominators[2], Some(6));\n+    assert_eq!(immediate_dominators[3], Some(6));\n+    assert_eq!(immediate_dominators[4], Some(6));\n+    assert_eq!(immediate_dominators[5], Some(6));\n+    assert_eq!(immediate_dominators[6], Some(6));\n+}\n+"}, {"sha": "11b557cbcadb926f8f91c69a4a47dced996aed8d", "filename": "src/librustc_data_structures/control_flow_graph/iterate/mod.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::ControlFlowGraph;\n+use super::super::indexed_vec::IndexVec;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub fn post_order_from<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n+    post_order_from_to(graph, start_node, None)\n+}\n+\n+pub fn post_order_from_to<G: ControlFlowGraph>(graph: &G,\n+                                               start_node: G::Node,\n+                                               end_node: Option<G::Node>)\n+                                               -> Vec<G::Node> {\n+    let mut visited: IndexVec<G::Node, bool> = IndexVec::from_elem_n(false, graph.num_nodes());\n+    let mut result: Vec<G::Node> = Vec::with_capacity(graph.num_nodes());\n+    if let Some(end_node) = end_node {\n+        visited[end_node] = true;\n+    }\n+    post_order_walk(graph, start_node, &mut result, &mut visited);\n+    result\n+}\n+\n+fn post_order_walk<G: ControlFlowGraph>(graph: &G,\n+                                        node: G::Node,\n+                                        result: &mut Vec<G::Node>,\n+                                        visited: &mut IndexVec<G::Node, bool>) {\n+    if visited[node] {\n+        return;\n+    }\n+    visited[node] = true;\n+\n+    for successor in graph.successors(node) {\n+        post_order_walk(graph, successor, result, visited);\n+    }\n+\n+    result.push(node);\n+}\n+\n+pub fn pre_order_walk<G: ControlFlowGraph>(graph: &G,\n+                                           node: G::Node,\n+                                           result: &mut Vec<G::Node>,\n+                                           visited: &mut IndexVec<G::Node, bool>) {\n+    if visited[node] {\n+        return;\n+    }\n+    visited[node] = true;\n+\n+    result.push(node);\n+\n+    for successor in graph.successors(node) {\n+        pre_order_walk(graph, successor, result, visited);\n+    }\n+}\n+\n+pub fn reverse_post_order<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n+    let mut vec = post_order_from(graph, start_node);\n+    vec.reverse();\n+    vec\n+}"}, {"sha": "28297d55bdf32a3839f3d5a91f864e686e9e8158", "filename": "src/librustc_data_structures/control_flow_graph/iterate/test.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::super::test::TestGraph;\n+use super::super::transpose::TransposedGraph;\n+\n+use super::*;\n+\n+#[test]\n+fn diamond_post_order() {\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (0, 2),\n+        (1, 3),\n+        (2, 3),\n+    ]);\n+\n+    let result = post_order_from(&graph, 0);\n+    assert_eq!(result, vec![3, 1, 2, 0]);\n+}\n+\n+\n+#[test]\n+fn rev_post_order_inner_loop() {\n+    // 0 -> 1 ->     2     -> 3 -> 5\n+    //      ^     ^    v      |\n+    //      |     6 <- 4      |\n+    //      +-----------------+\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (1, 2),\n+        (2, 3),\n+        (3, 5),\n+        (3, 1),\n+        (2, 4),\n+        (4, 6),\n+        (6, 2),\n+    ]);\n+\n+    let rev_graph = TransposedGraph::new(&graph);\n+\n+    let result = post_order_from_to(&rev_graph, 6, Some(2));\n+    assert_eq!(result, vec![4, 6]);\n+\n+    let result = post_order_from_to(&rev_graph, 3, Some(1));\n+    assert_eq!(result, vec![4, 6, 2, 3]);\n+}\n+"}, {"sha": "f9e75b12e0358628f4d93bf48243cf3808ed815a", "filename": "src/librustc_data_structures/control_flow_graph/mod.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::indexed_vec::Idx;\n+pub use std::slice::Iter;\n+\n+pub mod dominators;\n+pub mod iterate;\n+pub mod reachable;\n+mod reference;\n+pub mod transpose;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub trait ControlFlowGraph\n+    where Self: for<'graph> GraphPredecessors<'graph, Item=<Self as ControlFlowGraph>::Node>,\n+          Self: for<'graph> GraphSuccessors<'graph, Item=<Self as ControlFlowGraph>::Node>\n+{\n+    type Node: Idx;\n+\n+    fn num_nodes(&self) -> usize;\n+    fn start_node(&self) -> Self::Node;\n+    fn predecessors<'graph>(&'graph self, node: Self::Node)\n+                            -> <Self as GraphPredecessors<'graph>>::Iter;\n+    fn successors<'graph>(&'graph self, node: Self::Node)\n+                            -> <Self as GraphSuccessors<'graph>>::Iter;\n+}\n+\n+pub trait GraphPredecessors<'graph> {\n+    type Item;\n+    type Iter: Iterator<Item=Self::Item>;\n+}\n+\n+pub trait GraphSuccessors<'graph> {\n+    type Item;\n+    type Iter: Iterator<Item=Self::Item>;\n+}\n\\ No newline at end of file"}, {"sha": "e520e23f3afb822e9738b0535f0e30a8623ed270", "filename": "src/librustc_data_structures/control_flow_graph/reachable/mod.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Compute reachability using a simple dataflow propagation.\n+//! Store end-result in a big NxN bit matrix.\n+\n+use super::ControlFlowGraph;\n+use super::super::bitvec::BitVector;\n+use super::iterate::reverse_post_order;\n+use super::super::indexed_vec::{IndexVec, Idx};\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub fn reachable<G: ControlFlowGraph>(graph: &G)\n+                                      -> Reachability<G::Node> {\n+    let reverse_post_order = reverse_post_order(graph, graph.start_node());\n+    reachable_given_rpo(graph, &reverse_post_order)\n+}\n+\n+pub fn reachable_given_rpo<G: ControlFlowGraph>(graph: &G,\n+                                                reverse_post_order: &[G::Node])\n+                                                -> Reachability<G::Node> {\n+    let mut reachability = Reachability::new(graph);\n+    let mut changed = true;\n+    while changed {\n+        changed = false;\n+        for &node in reverse_post_order.iter().rev() {\n+            // every node can reach itself\n+            changed |= reachability.bits[node].insert(node.index());\n+\n+            // and every pred can reach everything node can reach\n+            for pred in graph.predecessors(node) {\n+                let nodes_bits = reachability.bits[node].clone();\n+                changed |= reachability.bits[pred].insert_all(&nodes_bits);\n+            }\n+        }\n+    }\n+    reachability\n+}\n+\n+pub struct Reachability<Node: Idx> {\n+    bits: IndexVec<Node, BitVector>,\n+}\n+\n+impl<Node: Idx> Reachability<Node> {\n+    fn new<G: ControlFlowGraph>(graph: &G) -> Self {\n+        let num_nodes = graph.num_nodes();\n+        Reachability {\n+            bits: IndexVec::from_elem_n(BitVector::new(num_nodes), num_nodes),\n+        }\n+    }\n+\n+    pub fn can_reach(&self, source: Node, target: Node)-> bool {\n+        let bit: usize = target.index();\n+        self.bits[source].contains(bit)\n+    }\n+}"}, {"sha": "6aa906a0804e2707bd1e92bd1df81c6f34fee104", "filename": "src/librustc_data_structures/control_flow_graph/reachable/test.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::super::test::TestGraph;\n+\n+use super::*;\n+\n+#[test]\n+fn test1() {\n+    // 0 -> 1 -> 2 -> 3\n+    //      ^    v\n+    //      6 <- 4 -> 5\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (1, 2),\n+        (2, 3),\n+        (2, 4),\n+        (4, 5),\n+        (4, 6),\n+        (6, 1),\n+    ]);\n+    let reachable = reachable(&graph);\n+    assert!((0..6).all(|i| reachable.can_reach(0, i)));\n+    assert!((1..6).all(|i| reachable.can_reach(1, i)));\n+    assert!((1..6).all(|i| reachable.can_reach(2, i)));\n+    assert!((1..6).all(|i| reachable.can_reach(4, i)));\n+    assert!((1..6).all(|i| reachable.can_reach(6, i)));\n+    assert!(reachable.can_reach(3, 3));\n+    assert!(!reachable.can_reach(3, 5));\n+    assert!(!reachable.can_reach(5, 3));\n+}\n+\n+/// use bigger indices to cross between words in the bit set\n+#[test]\n+fn test2() {\n+    // 30 -> 31 -> 32 -> 33\n+    //       ^      v\n+    //       36 <- 34 -> 35\n+    let graph = TestGraph::new(30, &[\n+        (30, 31),\n+        (31, 32),\n+        (32, 33),\n+        (32, 34),\n+        (34, 35),\n+        (34, 36),\n+        (36, 31),\n+    ]);\n+    let reachable = reachable(&graph);\n+    assert!((30..36).all(|i| reachable.can_reach(30, i)));\n+    assert!((31..36).all(|i| reachable.can_reach(31, i)));\n+    assert!((31..36).all(|i| reachable.can_reach(32, i)));\n+    assert!((31..36).all(|i| reachable.can_reach(34, i)));\n+    assert!((31..36).all(|i| reachable.can_reach(36, i)));\n+    assert!(reachable.can_reach(33, 33));\n+    assert!(!reachable.can_reach(33, 35));\n+    assert!(!reachable.can_reach(35, 33));\n+}"}, {"sha": "d735be1ed2f543e39dbba62a4302693de7140b84", "filename": "src/librustc_data_structures/control_flow_graph/reference.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+impl<'graph, G: ControlFlowGraph> ControlFlowGraph for &'graph G {\n+    type Node = G::Node;\n+\n+    fn num_nodes(&self) -> usize {\n+        (**self).num_nodes()\n+    }\n+\n+    fn start_node(&self) -> Self::Node {\n+        (**self).start_node()\n+    }\n+\n+    fn predecessors<'iter>(&'iter self, node: Self::Node)\n+                            -> <Self as GraphPredecessors<'iter>>::Iter {\n+        (**self).predecessors(node)\n+    }\n+\n+    fn successors<'iter>(&'iter self, node: Self::Node)\n+                          -> <Self as GraphSuccessors<'iter>>::Iter {\n+        (**self).successors(node)\n+    }\n+}\n+\n+impl<'iter, 'graph, G: ControlFlowGraph> GraphPredecessors<'iter> for &'graph G {\n+    type Item = G::Node;\n+    type Iter = <G as GraphPredecessors<'iter>>::Iter;\n+}\n+\n+impl<'iter, 'graph, G: ControlFlowGraph> GraphSuccessors<'iter> for &'graph G {\n+    type Item = G::Node;\n+    type Iter = <G as GraphSuccessors<'iter>>::Iter;\n+}"}, {"sha": "57b2a858de56803e035d9aa268c3e2b9633f9583", "filename": "src/librustc_data_structures/control_flow_graph/test.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::cmp::max;\n+use std::slice;\n+use std::iter;\n+\n+use super::{ControlFlowGraph, GraphPredecessors, GraphSuccessors};\n+\n+pub struct TestGraph {\n+    num_nodes: usize,\n+    start_node: usize,\n+    successors: HashMap<usize, Vec<usize>>,\n+    predecessors: HashMap<usize, Vec<usize>>,\n+}\n+\n+impl TestGraph {\n+    pub fn new(start_node: usize, edges: &[(usize, usize)]) -> Self {\n+        let mut graph = TestGraph {\n+            num_nodes: start_node + 1,\n+            start_node: start_node,\n+            successors: HashMap::new(),\n+            predecessors: HashMap::new()\n+        };\n+        for &(source, target) in edges {\n+            graph.num_nodes = max(graph.num_nodes, source + 1);\n+            graph.num_nodes = max(graph.num_nodes, target + 1);\n+            graph.successors.entry(source).or_insert(vec![]).push(target);\n+            graph.predecessors.entry(target).or_insert(vec![]).push(source);\n+        }\n+        for node in 0..graph.num_nodes {\n+            graph.successors.entry(node).or_insert(vec![]);\n+            graph.predecessors.entry(node).or_insert(vec![]);\n+        }\n+        graph\n+    }\n+}\n+\n+impl ControlFlowGraph for TestGraph {\n+    type Node = usize;\n+\n+    fn start_node(&self) -> usize {\n+        self.start_node\n+    }\n+\n+    fn num_nodes(&self) -> usize {\n+        self.num_nodes\n+    }\n+\n+    fn predecessors<'graph>(&'graph self, node: usize)\n+                            -> <Self as GraphPredecessors<'graph>>::Iter {\n+       self.predecessors[&node].iter().cloned()\n+    }\n+\n+    fn successors<'graph>(&'graph self, node: usize)\n+                            -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.successors[&node].iter().cloned()\n+    }\n+}\n+\n+impl<'graph> GraphPredecessors<'graph> for TestGraph {\n+    type Item = usize;\n+    type Iter = iter::Cloned<slice::Iter<'graph, usize>>;\n+}\n+\n+impl<'graph> GraphSuccessors<'graph> for TestGraph {\n+    type Item = usize;\n+    type Iter = iter::Cloned<slice::Iter<'graph, usize>>;\n+}\n+"}, {"sha": "792e079c28c85ad670046de4469af4d4d4f9668f", "filename": "src/librustc_data_structures/control_flow_graph/transpose.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub struct TransposedGraph<G: ControlFlowGraph> {\n+    base_graph: G,\n+    start_node: G::Node,\n+}\n+\n+impl<G: ControlFlowGraph> TransposedGraph<G> {\n+    pub fn new(base_graph: G) -> Self {\n+        let start_node = base_graph.start_node();\n+        Self::with_start(base_graph, start_node)\n+    }\n+\n+    pub fn with_start(base_graph: G, start_node: G::Node) -> Self {\n+        TransposedGraph { base_graph: base_graph, start_node: start_node }\n+    }\n+}\n+\n+impl<G: ControlFlowGraph> ControlFlowGraph for TransposedGraph<G> {\n+    type Node = G::Node;\n+\n+    fn num_nodes(&self) -> usize {\n+        self.base_graph.num_nodes()\n+    }\n+\n+    fn start_node(&self) -> Self::Node {\n+        self.start_node\n+    }\n+\n+    fn predecessors<'graph>(&'graph self, node: Self::Node)\n+                            -> <Self as GraphPredecessors<'graph>>::Iter {\n+        self.base_graph.successors(node)\n+    }\n+\n+    fn successors<'graph>(&'graph self, node: Self::Node)\n+                          -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.base_graph.predecessors(node)\n+    }\n+}\n+\n+impl<'graph, G: ControlFlowGraph> GraphPredecessors<'graph> for TransposedGraph<G> {\n+    type Item = G::Node;\n+    type Iter = <G as GraphSuccessors<'graph>>::Iter;\n+}\n+\n+impl<'graph, G: ControlFlowGraph> GraphSuccessors<'graph> for TransposedGraph<G> {\n+    type Item = G::Node;\n+    type Iter = <G as GraphPredecessors<'graph>>::Iter;\n+}"}, {"sha": "b3918f1e4bc8b271900f9ceb329374348885e93e", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt::Debug;\n use std::iter::{self, FromIterator};\n use std::slice;\n use std::marker::PhantomData;\n@@ -20,7 +21,7 @@ use rustc_serialize as serialize;\n /// Represents some newtyped `usize` wrapper.\n ///\n /// (purpose: avoid mixing indexes for different bitvector domains.)\n-pub trait Idx: Copy + 'static {\n+pub trait Idx: Copy + 'static + Eq + Debug {\n     fn new(usize) -> Self;\n     fn index(self) -> usize;\n }\n@@ -76,6 +77,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n         IndexVec { raw: vec![elem; universe.len()], _marker: PhantomData }\n     }\n \n+    #[inline]\n+    pub fn from_elem_n(elem: T, n: usize) -> Self\n+        where T: Clone\n+    {\n+        IndexVec { raw: vec![elem; n], _marker: PhantomData }\n+    }\n+\n     #[inline]\n     pub fn push(&mut self, d: T) -> I {\n         let idx = I::new(self.len());"}, {"sha": "34c3961d5b4c18980c4b2ea36f6729d06dd22f20", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -50,6 +50,7 @@ pub mod unify;\n pub mod fnv;\n pub mod tuple_slice;\n pub mod veccell;\n+pub mod control_flow_graph;\n \n // See comments in src/librustc/lib.rs\n #[doc(hidden)]"}, {"sha": "54c62d3665994018d0e7bc0982438b878b3780f5", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -17,6 +17,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_borrowck = { path = \"../librustc_borrowck\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_mir = { path = \"../librustc_mir\" }\n@@ -32,3 +33,4 @@ rustc_metadata = { path = \"../librustc_metadata\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "eb442c0a34e74cb68ba015fb765b3f2e61e262c3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -763,6 +763,9 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n }\n \n pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n+    use syntax::ptr::P;\n+    use syntax::util::move_map::MoveMap;\n+\n     struct NodeIdAssigner<'a> {\n         sess: &'a Session,\n     }\n@@ -772,6 +775,27 @@ pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n             assert_eq!(old_id, ast::DUMMY_NODE_ID);\n             self.sess.next_node_id()\n         }\n+\n+        fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n+            block.map(|mut block| {\n+                block.id = self.new_id(block.id);\n+\n+                let stmt = block.stmts.pop();\n+                block.stmts = block.stmts.move_flat_map(|s| self.fold_stmt(s).into_iter());\n+                if let Some(ast::Stmt { node: ast::StmtKind::Expr(expr), span, .. }) = stmt {\n+                    let expr = self.fold_expr(expr);\n+                    block.stmts.push(ast::Stmt {\n+                        id: expr.id,\n+                        node: ast::StmtKind::Expr(expr),\n+                        span: span,\n+                    });\n+                } else if let Some(stmt) = stmt {\n+                    block.stmts.extend(self.fold_stmt(stmt));\n+                }\n+\n+                block\n+            })\n+        }\n     }\n \n     let krate = time(sess.time_passes(),"}, {"sha": "32eb3fdd7109232f543b8533637d568bd82c1879", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -42,6 +42,7 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n extern crate rustc_const_eval;\n+extern crate rustc_errors as errors;\n extern crate rustc_passes;\n extern crate rustc_lint;\n extern crate rustc_plugin;\n@@ -60,6 +61,7 @@ extern crate log;\n #[macro_use]\n extern crate syntax;\n extern crate syntax_ext;\n+extern crate syntax_pos;\n \n use driver::CompileController;\n use pretty::{PpMode, UserIdentifiedItem};\n@@ -92,11 +94,12 @@ use std::thread;\n \n use rustc::session::early_error;\n \n-use syntax::{ast, errors, diagnostics};\n-use syntax::codemap::{CodeMap, FileLoader, RealFileLoader, MultiSpan};\n-use syntax::errors::emitter::Emitter;\n+use syntax::{ast, json};\n+use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult, token};\n+use syntax_pos::MultiSpan;\n+use errors::emitter::Emitter;\n \n #[cfg(test)]\n pub mod test;\n@@ -290,7 +293,7 @@ pub trait CompilerCalls<'a> {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &config::Options,\n-                      _: &diagnostics::registry::Registry,\n+                      _: &errors::registry::Registry,\n                       _: ErrorOutputType)\n                       -> Compilation {\n         Compilation::Continue\n@@ -329,7 +332,7 @@ pub trait CompilerCalls<'a> {\n                 _: &config::Options,\n                 _: &Option<PathBuf>,\n                 _: &Option<PathBuf>,\n-                _: &diagnostics::registry::Registry)\n+                _: &errors::registry::Registry)\n                 -> Option<(Input, Option<PathBuf>)> {\n         None\n     }\n@@ -344,7 +347,7 @@ pub trait CompilerCalls<'a> {\n pub struct RustcDefaultCalls;\n \n fn handle_explain(code: &str,\n-                  descriptions: &diagnostics::registry::Registry,\n+                  descriptions: &errors::registry::Registry,\n                   output: ErrorOutputType) {\n     let normalised = if code.starts_with(\"E\") {\n         code.to_string()\n@@ -374,7 +377,7 @@ fn check_cfg(sopts: &config::Options,\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(errors::emitter::BasicEmitter::stderr(color_config))\n         }\n-        config::ErrorOutputType::Json => Box::new(errors::json::JsonEmitter::basic()),\n+        config::ErrorOutputType::Json => Box::new(json::JsonEmitter::basic()),\n     };\n \n     let mut saw_invalid_predicate = false;\n@@ -401,7 +404,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,\n                       sopts: &config::Options,\n-                      descriptions: &diagnostics::registry::Registry,\n+                      descriptions: &errors::registry::Registry,\n                       output: ErrorOutputType)\n                       -> Compilation {\n         if let Some(ref code) = matches.opt_str(\"explain\") {\n@@ -418,7 +421,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 sopts: &config::Options,\n                 odir: &Option<PathBuf>,\n                 ofile: &Option<PathBuf>,\n-                descriptions: &diagnostics::registry::Registry)\n+                descriptions: &errors::registry::Registry)\n                 -> Option<(Input, Option<PathBuf>)> {\n         match matches.free.len() {\n             0 => {\n@@ -1081,8 +1084,8 @@ fn exit_on_err() -> ! {\n     panic!();\n }\n \n-pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n-    use syntax::diagnostics::registry::Registry;\n+pub fn diagnostics_registry() -> errors::registry::Registry {\n+    use errors::registry::Registry;\n \n     let mut all_errors = Vec::new();\n     all_errors.extend_from_slice(&rustc::DIAGNOSTICS);"}, {"sha": "baac455a25f334c7c6c6a3194f0ed6c00f44da56", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -31,12 +31,12 @@ use rustc_mir::pretty::write_mir_pretty;\n use rustc_mir::graphviz::write_mir_graphviz;\n \n use syntax::ast::{self, BlockCheckMode};\n-use syntax::codemap;\n use syntax::fold::{self, Folder};\n use syntax::print::{pp, pprust};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n+use syntax_pos;\n \n use graphviz as dot;\n \n@@ -657,11 +657,14 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode, e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-                expr: e,\n-                stmts: vec![],\n+                stmts: e.map(|e| ast::Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: e.span,\n+                    node: ast::StmtKind::Expr(e),\n+                }).into_iter().collect(),\n                 rules: rules,\n                 id: ast::DUMMY_NODE_ID,\n-                span: codemap::DUMMY_SP,\n+                span: syntax_pos::DUMMY_SP,\n             })\n         }\n \n@@ -671,8 +674,8 @@ impl fold::Folder for ReplaceBodyWithLoop {\n             let loop_expr = P(ast::Expr {\n                 node: ast::ExprKind::Loop(empty_block, None),\n                 id: ast::DUMMY_NODE_ID,\n-                span: codemap::DUMMY_SP,\n-                attrs: None,\n+                span: syntax_pos::DUMMY_SP,\n+                attrs: ast::ThinVec::new(),\n             });\n \n             expr_to_block(b.rules, Some(loop_expr))"}, {"sha": "0f5977cf06618822a0438fc935845a2502568ac3", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -31,12 +31,13 @@ use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap::{CodeMap, DUMMY_SP};\n-use syntax::errors;\n-use syntax::errors::emitter::{CoreEmitter, Emitter};\n-use syntax::errors::{Level, RenderSpan};\n+use syntax::codemap::CodeMap;\n+use errors;\n+use errors::emitter::{CoreEmitter, Emitter};\n+use errors::{Level, RenderSpan};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n "}, {"sha": "128c270eb359cb6378325bc2b95944cfbb5d48d5", "filename": "src/librustc_errors/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_errors\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_errors\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+serialize = { path = \"../libserialize\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "a7c68e3a87b318f418f41ff688894afb493ea3a9", "filename": "src/librustc_errors/emitter.rs", "status": "renamed", "additions": 45, "deletions": 281, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -10,14 +10,14 @@\n \n use self::Destination::*;\n \n-use codemap::{self, COMMAND_LINE_SP, DUMMY_SP, Span, MultiSpan};\n-use diagnostics;\n+use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, Span, MultiSpan, LineInfo};\n+use registry;\n \n-use errors::check_old_skool;\n-use errors::{Level, RenderSpan, CodeSuggestion, DiagnosticBuilder};\n-use errors::RenderSpan::*;\n-use errors::Level::*;\n-use errors::snippet::{RenderedLineKind, SnippetData, Style};\n+use check_old_skool;\n+use {Level, RenderSpan, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n+use RenderSpan::*;\n+use Level::*;\n+use snippet::{RenderedLineKind, SnippetData, Style, FormatMode};\n \n use std::{cmp, fmt};\n use std::io::prelude::*;\n@@ -151,15 +151,15 @@ impl BasicEmitter {\n \n pub struct EmitterWriter {\n     dst: Destination,\n-    registry: Option<diagnostics::registry::Registry>,\n-    cm: Rc<codemap::CodeMap>,\n+    registry: Option<registry::Registry>,\n+    cm: Rc<CodeMapper>,\n \n     /// Is this the first error emitted thus far? If not, we emit a\n     /// `\\n` before the top-level errors.\n     first: bool,\n \n     // For now, allow an old-school mode while we transition\n-    old_school: bool,\n+    format_mode: FormatMode\n }\n \n impl CoreEmitter for EmitterWriter {\n@@ -193,36 +193,36 @@ macro_rules! println_maybe_styled {\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  registry: Option<diagnostics::registry::Registry>,\n-                  code_map: Rc<codemap::CodeMap>)\n+                  registry: Option<registry::Registry>,\n+                  code_map: Rc<CodeMapper>,\n+                  format_mode: FormatMode)\n                   -> EmitterWriter {\n-        let old_school = check_old_skool();\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n             EmitterWriter { dst: dst,\n                             registry: registry,\n                             cm: code_map,\n                             first: true,\n-                            old_school: old_school }\n+                            format_mode: format_mode.clone() }\n         } else {\n             EmitterWriter { dst: Raw(Box::new(io::stderr())),\n                             registry: registry,\n                             cm: code_map,\n                             first: true,\n-                            old_school: old_school }\n+                            format_mode: format_mode.clone() }\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n-               registry: Option<diagnostics::registry::Registry>,\n-               code_map: Rc<codemap::CodeMap>)\n+               registry: Option<registry::Registry>,\n+               code_map: Rc<CodeMapper>,\n+               format_mode: FormatMode)\n                -> EmitterWriter {\n-        let old_school = check_old_skool();\n         EmitterWriter { dst: Raw(dst),\n                         registry: registry,\n                         cm: code_map,\n                         first: true,\n-                        old_school: old_school }\n+                        format_mode: format_mode.clone() }\n     }\n \n     fn emit_message_(&mut self,\n@@ -233,11 +233,17 @@ impl EmitterWriter {\n                      is_header: bool,\n                      show_snippet: bool)\n                      -> io::Result<()> {\n+        let old_school = match self.format_mode {\n+            FormatMode::NewErrorFormat => false,\n+            FormatMode::OriginalErrorFormat => true,\n+            FormatMode::EnvironmentSelected => check_old_skool()\n+        };\n+\n         if is_header {\n             if self.first {\n                 self.first = false;\n             } else {\n-                if !self.old_school {\n+                if !old_school {\n                     write!(self.dst, \"\\n\")?;\n                 }\n             }\n@@ -248,7 +254,7 @@ impl EmitterWriter {\n                                        .and_then(|registry| registry.find_description(code))\n                                        .is_some() => {\n                 let code_with_explain = String::from(\"--explain \") + code;\n-                if self.old_school {\n+                if old_school {\n                     let loc = match rsp.span().primary_span() {\n                         Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n                         Some(ps) => self.cm.span_to_string(ps),\n@@ -261,7 +267,7 @@ impl EmitterWriter {\n                 }\n             }\n             _ => {\n-                if self.old_school {\n+                if old_school {\n                     let loc = match rsp.span().primary_span() {\n                         Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n                         Some(ps) => self.cm.span_to_string(ps),\n@@ -303,7 +309,7 @@ impl EmitterWriter {\n                 }\n             }\n         }\n-        if self.old_school {\n+        if old_school {\n             match code {\n                 Some(code) if self.registry.as_ref()\n                                         .and_then(|registry| registry.find_description(code))\n@@ -326,11 +332,13 @@ impl EmitterWriter {\n \n     fn highlight_suggestion(&mut self, suggestion: &CodeSuggestion) -> io::Result<()>\n     {\n+        use std::borrow::Borrow;\n+\n         let primary_span = suggestion.msp.primary_span().unwrap();\n         let lines = self.cm.span_to_lines(primary_span).unwrap();\n         assert!(!lines.lines.is_empty());\n \n-        let complete = suggestion.splice_lines(&self.cm);\n+        let complete = suggestion.splice_lines(self.cm.borrow());\n         let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n         let display_lines = &lines.lines[..line_count];\n \n@@ -356,19 +364,27 @@ impl EmitterWriter {\n         Ok(())\n     }\n \n-    fn highlight_lines(&mut self,\n+    pub fn highlight_lines(&mut self,\n                        msp: &MultiSpan,\n                        lvl: Level)\n                        -> io::Result<()>\n     {\n+        let old_school = match self.format_mode {\n+            FormatMode::NewErrorFormat => false,\n+            FormatMode::OriginalErrorFormat => true,\n+            FormatMode::EnvironmentSelected => check_old_skool()\n+        };\n+\n         let mut snippet_data = SnippetData::new(self.cm.clone(),\n-                                                msp.primary_span());\n-        if self.old_school {\n+                                                msp.primary_span(),\n+                                                self.format_mode.clone());\n+        if old_school {\n             let mut output_vec = vec![];\n \n             for span_label in msp.span_labels() {\n                 let mut snippet_data = SnippetData::new(self.cm.clone(),\n-                                                        Some(span_label.span));\n+                                                        Some(span_label.span),\n+                                                        self.format_mode.clone());\n \n                 snippet_data.push(span_label.span,\n                                   span_label.is_primary,\n@@ -430,7 +446,7 @@ impl EmitterWriter {\n     }\n }\n \n-fn line_num_max_digits(line: &codemap::LineInfo) -> usize {\n+fn line_num_max_digits(line: &LineInfo) -> usize {\n     let mut max_line_num = line.line_index + 1;\n     let mut digits = 0;\n     while max_line_num > 0 {\n@@ -617,255 +633,3 @@ impl Write for Destination {\n         }\n     }\n }\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use errors::{Level, CodeSuggestion};\n-    use super::EmitterWriter;\n-    use codemap::{mk_sp, CodeMap, Span, MultiSpan, BytePos, NO_EXPANSION};\n-    use std::sync::{Arc, Mutex};\n-    use std::io::{self, Write};\n-    use std::str::from_utf8;\n-    use std::rc::Rc;\n-\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n-        }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-\n-    /// Given a string like \" ^~~~~~~~~~~~ \", produces a span\n-    /// coverting that range. The idea is that the string has the same\n-    /// length as the input, and we uncover the byte positions.  Note\n-    /// that this can span lines and so on.\n-    fn span_from_selection(input: &str, selection: &str) -> Span {\n-        assert_eq!(input.len(), selection.len());\n-        let left_index = selection.find('~').unwrap() as u32;\n-        let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n-    }\n-\n-    // Diagnostic doesn't align properly in span where line number increases by one digit\n-    #[test]\n-    fn test_hilight_suggestion_issue_11715() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n-        let content = \"abcdefg\n-        koksi\n-        line3\n-        line4\n-        cinq\n-        line6\n-        line7\n-        line8\n-        line9\n-        line10\n-        e-l\u00e4-v\u00e4n\n-        tolv\n-        dreizehn\n-        \";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, content);\n-        let start = file.lines.borrow()[10];\n-        let end = file.lines.borrow()[11];\n-        let sp = mk_sp(start, end);\n-        let lvl = Level::Error;\n-        println!(\"highlight_lines\");\n-        ew.highlight_lines(&sp.into(), lvl).unwrap();\n-        println!(\"done\");\n-        let vec = data.lock().unwrap().clone();\n-        let vec: &[u8] = &vec;\n-        let str = from_utf8(vec).unwrap();\n-        println!(\"r#\\\"\\n{}\\\"#\", str);\n-        assert_eq!(str, &r#\"\n-  --> dummy.txt:11:1\n-   |>\n-11 |>         e-l\u00e4-v\u00e4n\n-   |> ^\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn test_single_span_splice() {\n-        // Test that a `MultiSpan` containing a single span splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp = span_from_selection(inputtext, selection);\n-        let msp: MultiSpan = sp.into();\n-\n-        // check that we are extracting the text we thought we were extracting\n-        assert_eq!(&cm.span_to_snippet(sp).unwrap(), \"BB\\nCCC\\nDDDDD\");\n-\n-        let substitute = \"ZZZZZZ\".to_owned();\n-        let expected = \"bbbbZZZZZZddddd\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![substitute],\n-        };\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multi_span_splice() {\n-        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n-        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp1 = span_from_selection(inputtext, selection1);\n-        let sp2 = span_from_selection(inputtext, selection2);\n-        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n-\n-        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![\"ZZZZZZ\".to_owned(),\n-                              \"XYZ\".to_owned()]\n-        };\n-\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n-\n-        let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n-        let sp1 =       \"     ~~~~~~                    \";\n-        let sp2 =       \"               ~~~~~~          \";\n-        let sp3 =       \"                       ~~~~~   \";\n-        let sp4 =       \"                          ~~~~ \";\n-        let sp34 =      \"                       ~~~~~~~ \";\n-\n-        let expect_start = &r#\"\n- --> dummy.txt:1:6\n-  |>\n-1 |> _____aaaaaa____bbbbbb__cccccdd_\n-  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n-\"#[1..];\n-\n-        let span = |sp, expected| {\n-            let sp = span_from_selection(inp, sp);\n-            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n-            sp\n-        };\n-        cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-        let sp1 = span(sp1, \"aaaaaa\");\n-        let sp2 = span(sp2, \"bbbbbb\");\n-        let sp3 = span(sp3, \"ccccc\");\n-        let sp4 = span(sp4, \"ccdd\");\n-        let sp34 = span(sp34, \"cccccdd\");\n-\n-        let spans = vec![sp1, sp2, sp3, sp4];\n-\n-        let test = |expected, highlight: &mut FnMut()| {\n-            data.lock().unwrap().clear();\n-            highlight();\n-            let vec = data.lock().unwrap().clone();\n-            let actual = from_utf8(&vec[..]).unwrap();\n-            println!(\"actual=\\n{}\", actual);\n-            assert_eq!(actual, expected);\n-        };\n-\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n-        test(expect_start, &mut || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-        test(expect_start, &mut || {\n-            let msp = MultiSpan::from_spans(spans.clone());\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-\n-    #[test]\n-    fn test_huge_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n-\n-        let inp = \"aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   bbbbb\\n\\\n-                   ccccc\\n\\\n-                   xxxxx\\n\\\n-                   yyyyy\\n\\\n-                   _____\\n\\\n-                   ddd__eee_\\n\\\n-                   elided\\n\\\n-                   __f_gg\";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-\n-        let span = |lo, hi, (off_lo, off_hi)| {\n-            let lines = file.lines.borrow();\n-            let (mut lo, mut hi): (BytePos, BytePos) = (lines[lo], lines[hi]);\n-            lo.0 += off_lo;\n-            hi.0 += off_hi;\n-            mk_sp(lo, hi)\n-        };\n-        let sp0 = span(4, 6, (0, 5));\n-        let sp1 = span(0, 6, (0, 5));\n-        let sp2 = span(8, 8, (0, 3));\n-        let sp3 = span(8, 8, (5, 8));\n-        let sp4 = span(10, 10, (2, 3));\n-        let sp5 = span(10, 10, (4, 6));\n-\n-        let expect0 = &r#\"\n-   --> dummy.txt:5:1\n-    |>\n-5   |> ccccc\n-    |> ^\n-...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n-\"#[1..];\n-\n-        let expect = &r#\"\n-   --> dummy.txt:1:1\n-    |>\n-1   |> aaaaa\n-    |> ^\n-...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n-\"#[1..];\n-\n-        macro_rules! test {\n-            ($expected: expr, $highlight: expr) => ({\n-                data.lock().unwrap().clear();\n-                $highlight();\n-                let vec = data.lock().unwrap().clone();\n-                let actual = from_utf8(&vec[..]).unwrap();\n-                println!(\"actual:\");\n-                println!(\"{}\", actual);\n-                println!(\"expected:\");\n-                println!(\"{}\", $expected);\n-                assert_eq!(&actual[..], &$expected[..]);\n-            });\n-        }\n-\n-        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n-\n-        test!(expect0, || {\n-            diag.highlight_lines(&msp0, Level::Error).unwrap();\n-        });\n-        test!(expect, || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-}", "previous_filename": "src/libsyntax/errors/emitter.rs"}, {"sha": "18fc826f9aa4bc5840fb8e7b05c10732c07ab33b", "filename": "src/librustc_errors/lib.rs", "status": "renamed", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -8,24 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use errors::emitter::ColorConfig;\n+#![crate_name = \"rustc_errors\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+#![feature(question_mark)]\n+#![feature(range_contains)]\n+#![feature(libc)]\n+#![feature(unicode)]\n+\n+extern crate serialize;\n+extern crate term;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate libc;\n+extern crate rustc_unicode;\n+extern crate serialize as rustc_serialize; // used by deriving\n+extern crate syntax_pos;\n+\n+pub use emitter::ColorConfig;\n \n use self::Level::*;\n use self::RenderSpan::*;\n \n-use codemap::{self, CodeMap, MultiSpan, NO_EXPANSION, Span};\n-use diagnostics;\n-use errors::emitter::{Emitter, EmitterWriter};\n+use emitter::{Emitter, EmitterWriter};\n \n use std::cell::{RefCell, Cell};\n use std::{error, fmt};\n use std::rc::Rc;\n use std::thread::panicking;\n-use term;\n \n pub mod emitter;\n-pub mod json;\n pub mod snippet;\n+pub mod registry;\n+\n+use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION };\n+use syntax_pos::{MacroBacktrace};\n \n #[derive(Clone)]\n pub enum RenderSpan {\n@@ -43,8 +69,16 @@ pub enum RenderSpan {\n \n #[derive(Clone)]\n pub struct CodeSuggestion {\n-    msp: MultiSpan,\n-    substitutes: Vec<String>,\n+    pub msp: MultiSpan,\n+    pub substitutes: Vec<String>,\n+}\n+\n+pub trait CodeMapper {\n+    fn lookup_char_pos(&self, pos: BytePos) -> Loc;\n+    fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n+    fn span_to_string(&self, sp: Span) -> String;\n+    fn span_to_filename(&self, sp: Span) -> FileName;\n+    fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace>;\n }\n \n impl RenderSpan {\n@@ -59,8 +93,8 @@ impl RenderSpan {\n \n impl CodeSuggestion {\n     /// Returns the assembled code suggestion.\n-    pub fn splice_lines(&self, cm: &CodeMap) -> String {\n-        use codemap::{CharPos, Loc, Pos};\n+    pub fn splice_lines(&self, cm: &CodeMapper) -> String {\n+        use syntax_pos::{CharPos, Loc, Pos};\n \n         fn push_trailing(buf: &mut String, line_opt: Option<&str>,\n                          lo: &Loc, hi_opt: Option<&Loc>) {\n@@ -181,20 +215,20 @@ impl error::Error for ExplicitBug {\n #[derive(Clone)]\n pub struct DiagnosticBuilder<'a> {\n     handler: &'a Handler,\n-    level: Level,\n-    message: String,\n-    code: Option<String>,\n-    span: MultiSpan,\n-    children: Vec<SubDiagnostic>,\n+    pub level: Level,\n+    pub message: String,\n+    pub code: Option<String>,\n+    pub span: MultiSpan,\n+    pub children: Vec<SubDiagnostic>,\n }\n \n /// For example a note attached to an error.\n #[derive(Clone)]\n-struct SubDiagnostic {\n-    level: Level,\n-    message: String,\n-    span: MultiSpan,\n-    render_span: Option<RenderSpan>,\n+pub struct SubDiagnostic {\n+    pub level: Level,\n+    pub message: String,\n+    pub span: MultiSpan,\n+    pub render_span: Option<RenderSpan>,\n }\n \n impl<'a> DiagnosticBuilder<'a> {\n@@ -386,12 +420,13 @@ pub struct Handler {\n \n impl Handler {\n     pub fn with_tty_emitter(color_config: ColorConfig,\n-                            registry: Option<diagnostics::registry::Registry>,\n+                            registry: Option<registry::Registry>,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n-                            cm: Rc<codemap::CodeMap>)\n+                            cm: Rc<CodeMapper>)\n                             -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm));\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm,\n+                               snippet::FormatMode::EnvironmentSelected));\n         Handler::with_emitter(can_emit_warnings, treat_err_as_bug, emitter)\n     }\n \n@@ -662,7 +697,7 @@ impl fmt::Display for Level {\n }\n \n impl Level {\n-    fn color(self) -> term::color::Color {\n+    pub fn color(self) -> term::color::Color {\n         match self {\n             Bug | Fatal | PhaseFatal | Error => term::color::BRIGHT_RED,\n             Warning => term::color::YELLOW,\n@@ -672,7 +707,7 @@ impl Level {\n         }\n     }\n \n-    fn to_str(self) -> &'static str {\n+    pub fn to_str(self) -> &'static str {\n         match self {\n             Bug => \"error: internal compiler error\",\n             Fatal | PhaseFatal | Error => \"error\",", "previous_filename": "src/libsyntax/errors/mod.rs"}, {"sha": "a6cfd1a5a9ac3c1e612b02995457433ee344987d", "filename": "src/librustc_errors/registry.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fregistry.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "previous_filename": "src/libsyntax/diagnostics/registry.rs"}, {"sha": "33f40ffc71a9f69b78b965db5c2f7cb066503e4c", "filename": "src/librustc_errors/snippet.rs", "status": "renamed", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -10,18 +10,25 @@\n \n // Code for annotating snippets.\n \n-use codemap::{CharPos, CodeMap, FileMap, LineInfo, Span};\n-use errors::check_old_skool;\n+use syntax_pos::{Span, FileMap, CharPos, LineInfo};\n+use check_old_skool;\n+use CodeMapper;\n use std::cmp;\n use std::rc::Rc;\n use std::mem;\n \n-mod test;\n+#[derive(Clone)]\n+pub enum FormatMode {\n+    NewErrorFormat,\n+    OriginalErrorFormat,\n+    EnvironmentSelected\n+}\n \n #[derive(Clone)]\n pub struct SnippetData {\n-    codemap: Rc<CodeMap>,\n+    codemap: Rc<CodeMapper>,\n     files: Vec<FileInfo>,\n+    format_mode: FormatMode,\n }\n \n #[derive(Clone)]\n@@ -36,6 +43,10 @@ pub struct FileInfo {\n     primary_span: Option<Span>,\n \n     lines: Vec<Line>,\n+\n+    /// The type of error format to render.  We keep it here so that\n+    /// it's easy to configure for both tests and regular usage\n+    format_mode: FormatMode,\n }\n \n #[derive(Clone, Debug)]\n@@ -111,8 +122,9 @@ pub enum RenderedLineKind {\n }\n \n impl SnippetData {\n-    pub fn new(codemap: Rc<CodeMap>,\n-               primary_span: Option<Span>) // (*)\n+    pub fn new(codemap: Rc<CodeMapper>,\n+               primary_span: Option<Span>,\n+               format_mode: FormatMode) // (*)\n                -> Self {\n         // (*) The primary span indicates the file that must appear\n         // first, and which will have a line number etc in its\n@@ -126,7 +138,8 @@ impl SnippetData {\n \n         let mut data = SnippetData {\n             codemap: codemap.clone(),\n-            files: vec![]\n+            files: vec![],\n+            format_mode: format_mode.clone()\n         };\n         if let Some(primary_span) = primary_span {\n             let lo = codemap.lookup_char_pos(primary_span.lo);\n@@ -135,6 +148,7 @@ impl SnippetData {\n                     file: lo.file,\n                     primary_span: Some(primary_span),\n                     lines: vec![],\n+                    format_mode: format_mode.clone(),\n                 });\n         }\n         data\n@@ -167,6 +181,7 @@ impl SnippetData {\n                 file: file_map.clone(),\n                 lines: vec![],\n                 primary_span: None,\n+                format_mode: self.format_mode.clone()\n             });\n         self.files.last_mut().unwrap()\n     }\n@@ -178,7 +193,7 @@ impl SnippetData {\n             self.files.iter()\n                       .flat_map(|f| f.render_file_lines(&self.codemap))\n                       .collect();\n-        prepend_prefixes(&mut rendered_lines);\n+        prepend_prefixes(&mut rendered_lines, &self.format_mode);\n         trim_lines(&mut rendered_lines);\n         rendered_lines\n     }\n@@ -454,8 +469,12 @@ impl FileInfo {\n         return line_index - first_line_index;\n     }\n \n-    fn render_file_lines(&self, codemap: &Rc<CodeMap>) -> Vec<RenderedLine> {\n-        let old_school = check_old_skool();\n+    fn render_file_lines(&self, codemap: &Rc<CodeMapper>) -> Vec<RenderedLine> {\n+        let old_school = match self.format_mode {\n+            FormatMode::OriginalErrorFormat => true,\n+            FormatMode::NewErrorFormat => false,\n+            FormatMode::EnvironmentSelected => check_old_skool()\n+        };\n \n         // As a first step, we elide any instance of more than one\n         // continuous unannotated line.\n@@ -591,7 +610,12 @@ impl FileInfo {\n     }\n \n     fn render_line(&self, line: &Line) -> Vec<RenderedLine> {\n-        let old_school = check_old_skool();\n+        let old_school = match self.format_mode {\n+            FormatMode::OriginalErrorFormat => true,\n+            FormatMode::NewErrorFormat => false,\n+            FormatMode::EnvironmentSelected => check_old_skool()\n+        };\n+\n         let source_string = self.file.get_line(line.line_index)\n                                      .unwrap_or(\"\");\n         let source_kind = RenderedLineKind::SourceText {\n@@ -776,8 +800,12 @@ impl FileInfo {\n     }\n }\n \n-fn prepend_prefixes(rendered_lines: &mut [RenderedLine]) {\n-    let old_school = check_old_skool();\n+fn prepend_prefixes(rendered_lines: &mut [RenderedLine], format_mode: &FormatMode) {\n+    let old_school = match *format_mode {\n+        FormatMode::OriginalErrorFormat => true,\n+        FormatMode::NewErrorFormat => false,\n+        FormatMode::EnvironmentSelected => check_old_skool()\n+    };\n     if old_school {\n         return;\n     }", "previous_filename": "src/libsyntax/errors/snippet/mod.rs"}, {"sha": "7db1a6348b27c9cb737370f602c8eefcb4bee470", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,3 +16,4 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n serialize = { path = \"../libserialize\" }\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "d38f979e33c5ac154b5277ecb0bee115dc234cc4", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -57,8 +57,8 @@ use std::fs::File;\n use std::io::Write;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n+use syntax_pos::Span;\n \n const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";"}, {"sha": "cbc246ac2a11bfc6c902c72e38df0774c2557c93", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -114,8 +114,8 @@ mod svh_visitor {\n     pub use self::SawStmtComponent::*;\n     use self::SawAbiComponent::*;\n     use syntax::ast::{self, Name, NodeId};\n-    use syntax::codemap::Span;\n     use syntax::parse::token;\n+    use syntax_pos::Span;\n     use rustc::ty::TyCtxt;\n     use rustc::hir;\n     use rustc::hir::*;"}, {"sha": "ed31e0ba51056a34fe41af2e76a32b2a58b481ba", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -30,6 +30,7 @@ extern crate serialize as rustc_serialize;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+extern crate syntax_pos;\n \n mod assert_dep_graph;\n mod calculate_svh;"}, {"sha": "4d5c0d7ba0ae1130f253a8e05113c9078ed202e3", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,3 +15,4 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "7e9b6f561b9846f1d0b4f09c72b31918ebd63a64", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,7 +15,7 @@ use lint::{LintPass, LateLintPass};\n \n use syntax::ast;\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;"}, {"sha": "18f9733040e0f46b8e6f6449efb76e2efbe6f2ef", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -45,7 +45,7 @@ use std::collections::HashSet;\n \n use syntax::{ast};\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::{self, Span};\n+use syntax_pos::{self, Span};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -1140,9 +1140,9 @@ impl LateLintPass for DropWithReprExtern {\n                     if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n                         self_type_def.dtor_kind().has_drop_flag() {\n                         let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n-                                                                     codemap::DUMMY_SP);\n+                                                                     syntax_pos::DUMMY_SP);\n                         let self_defn_span = ctx.tcx.map.def_id_span(self_type_did,\n-                                                                     codemap::DUMMY_SP);\n+                                                                     syntax_pos::DUMMY_SP);\n                         ctx.span_lint_note(DROP_WITH_REPR_EXTERN,\n                                            drop_impl_span,\n                                            \"implementing Drop adds hidden state to types, \\"}, {"sha": "4ae5b3afdba19f4bf1d119173c00d92d98da66cd", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -45,6 +45,7 @@ extern crate rustc;\n extern crate log;\n extern crate rustc_back;\n extern crate rustc_const_eval;\n+extern crate syntax_pos;\n \n pub use rustc::lint as lint;\n pub use rustc::middle as middle;"}, {"sha": "97f97a889edc30431de9fe399b0b4afb679fbea0", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,7 +27,8 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::ast;\n use syntax::abi::Abi;\n use syntax::attr;\n-use syntax::codemap::{self, Span};\n+use syntax_pos::Span;\n+use syntax::codemap;\n \n use rustc::hir;\n "}, {"sha": "b5b87718d2df7c352d5d36971aa39a9d47200fbf", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,9 +19,9 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax::ast;\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::Span;\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n use rustc_back::slice;\n use rustc::hir;\n@@ -365,12 +365,9 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n-                ast::DeclKind::Local(ref local) => match local.init {\n-                    Some(ref value) => (value, \"assigned value\"),\n-                    None => return\n-                },\n-                _ => return\n+            ast::StmtKind::Local(ref local) => match local.init {\n+                Some(ref value) => (value, \"assigned value\"),\n+                None => return\n             },\n             _ => return\n         };"}, {"sha": "11896e176301b3bb00057f6167f22528af3c8a80", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,6 +16,8 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "dc37bdf6322af1b4f6a65c523e10b74aeceea4d5", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -37,9 +37,10 @@ use middle::region;\n use rustc::ty::subst;\n use rustc::ty::{self, Ty, TyCtxt};\n \n-use syntax::{ast, codemap};\n+use syntax::ast;\n use syntax::ast::NodeIdAssigner;\n use syntax::ptr::P;\n+use syntax_pos;\n \n use std::cell::Cell;\n use std::io::SeekFrom;\n@@ -115,7 +116,7 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n     fn new_def_id(&self, def_id: DefId) -> DefId {\n         self.tr_def_id(def_id)\n     }\n-    fn new_span(&self, span: codemap::Span) -> codemap::Span {\n+    fn new_span(&self, span: syntax_pos::Span) -> syntax_pos::Span {\n         self.tr_span(span)\n     }\n }\n@@ -206,7 +207,7 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n \n     /// Translates a `Span` from an extern crate to the corresponding `Span`\n     /// within the local crate's codemap.\n-    pub fn tr_span(&self, span: codemap::Span) -> codemap::Span {\n+    pub fn tr_span(&self, span: syntax_pos::Span) -> syntax_pos::Span {\n         decoder::translate_span(self.cdata,\n                                 self.tcx.sess.codemap(),\n                                 &self.last_filemap_index,\n@@ -226,8 +227,8 @@ impl tr for Option<DefId> {\n     }\n }\n \n-impl tr for codemap::Span {\n-    fn tr(&self, dcx: &DecodeContext) -> codemap::Span {\n+impl tr for syntax_pos::Span {\n+    fn tr(&self, dcx: &DecodeContext) -> syntax_pos::Span {\n         dcx.tr_span(*self)\n     }\n }\n@@ -1268,7 +1269,7 @@ fn decode_item_ast(item_doc: rbml::Doc) -> hir::Item {\n \n #[cfg(test)]\n trait FakeExtCtxt {\n-    fn call_site(&self) -> codemap::Span;\n+    fn call_site(&self) -> syntax_pos::Span;\n     fn cfg(&self) -> ast::CrateConfig;\n     fn ident_of(&self, st: &str) -> ast::Ident;\n     fn name_of(&self, st: &str) -> ast::Name;\n@@ -1277,11 +1278,11 @@ trait FakeExtCtxt {\n \n #[cfg(test)]\n impl FakeExtCtxt for parse::ParseSess {\n-    fn call_site(&self) -> codemap::Span {\n-        codemap::Span {\n-            lo: codemap::BytePos(0),\n-            hi: codemap::BytePos(0),\n-            expn_id: codemap::NO_EXPANSION,\n+    fn call_site(&self) -> syntax_pos::Span {\n+        syntax_pos::Span {\n+            lo: syntax_pos::BytePos(0),\n+            hi: syntax_pos::BytePos(0),\n+            expn_id: syntax_pos::NO_EXPANSION,\n         }\n     }\n     fn cfg(&self) -> ast::CrateConfig { Vec::new() }"}, {"sha": "2ccac91ae910545de2e0d3f0c822ab6c942623bb", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -34,12 +34,13 @@ use std::fs;\n \n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap::{self, Span, mk_sp, Pos};\n+use syntax::codemap;\n use syntax::parse;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n use syntax::visit;\n+use syntax_pos::{self, Span, mk_sp, Pos};\n use log;\n \n struct LocalCrateReader<'a> {\n@@ -58,8 +59,8 @@ pub struct CrateReader<'a> {\n     local_crate_name: String,\n }\n \n-impl<'a, 'ast> visit::Visitor<'ast> for LocalCrateReader<'a> {\n-    fn visit_item(&mut self, a: &'ast ast::Item) {\n+impl<'a> visit::Visitor for LocalCrateReader<'a> {\n+    fn visit_item(&mut self, a: &ast::Item) {\n         self.process_item(a);\n         visit::walk_item(self, a);\n     }\n@@ -726,7 +727,7 @@ impl<'a> CrateReader<'a> {\n         info!(\"panic runtime not found -- loading {}\", name);\n \n         let (cnum, data, _) = self.resolve_crate(&None, name, name, None,\n-                                                 codemap::DUMMY_SP,\n+                                                 syntax_pos::DUMMY_SP,\n                                                  PathKind::Crate, false);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n@@ -807,7 +808,7 @@ impl<'a> CrateReader<'a> {\n             &self.sess.target.target.options.exe_allocation_crate\n         };\n         let (cnum, data, _) = self.resolve_crate(&None, name, name, None,\n-                                                 codemap::DUMMY_SP,\n+                                                 syntax_pos::DUMMY_SP,\n                                                  PathKind::Crate, false);\n \n         // Sanity check the crate we loaded to ensure that it is indeed an\n@@ -1076,7 +1077,7 @@ pub fn import_codemap(local_codemap: &codemap::CodeMap,\n             None => {\n                 // We can't reuse an existing FileMap, so allocate a new one\n                 // containing the information we need.\n-                let codemap::FileMap {\n+                let syntax_pos::FileMap {\n                     name,\n                     abs_path,\n                     start_pos,\n@@ -1118,8 +1119,8 @@ pub fn import_codemap(local_codemap: &codemap::CodeMap,\n \n     return imported_filemaps;\n \n-    fn are_equal_modulo_startpos(fm1: &codemap::FileMap,\n-                                 fm2: &codemap::FileMap)\n+    fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap,\n+                                 fm2: &syntax_pos::FileMap)\n                                  -> bool {\n         if fm1.name != fm2.name {\n             return false;"}, {"sha": "e89f428c96f8c1953f9c4048d6da89e768a430dd", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -36,6 +36,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap;\n use syntax::parse::token::IdentInterner;\n+use syntax_pos;\n \n pub use middle::cstore::{NativeLibraryKind, LinkagePreference};\n pub use middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n@@ -52,15 +53,15 @@ pub enum MetadataBlob {\n     MetadataArchive(loader::ArchiveMetadata),\n }\n \n-/// Holds information about a codemap::FileMap imported from another crate.\n+/// Holds information about a syntax_pos::FileMap imported from another crate.\n /// See creader::import_codemap() for more information.\n pub struct ImportedFileMap {\n     /// This FileMap's byte-offset within the codemap of its original crate\n-    pub original_start_pos: codemap::BytePos,\n+    pub original_start_pos: syntax_pos::BytePos,\n     /// The end of this FileMap within the codemap of its original crate\n-    pub original_end_pos: codemap::BytePos,\n+    pub original_end_pos: syntax_pos::BytePos,\n     /// The imported FileMap's representation within the local codemap\n-    pub translated_filemap: Rc<codemap::FileMap>\n+    pub translated_filemap: Rc<syntax_pos::FileMap>\n }\n \n pub struct crate_metadata {"}, {"sha": "3efdf36acd9734673def1463563a8e2d2bc87a9f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -56,10 +56,10 @@ use syntax::attr;\n use syntax::parse::token::{self, IdentInterner};\n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap::{self, Span, BytePos, NO_EXPANSION};\n+use syntax::codemap;\n use syntax::print::pprust;\n use syntax::ptr::P;\n-\n+use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n pub type Cmd<'a> = &'a crate_metadata;\n \n@@ -1230,7 +1230,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n                         value: meta_item,\n                         is_sugared_doc: is_sugared_doc,\n                     },\n-                    span: codemap::DUMMY_SP\n+                    span: syntax_pos::DUMMY_SP\n                 }\n             }).collect()\n         },\n@@ -1380,8 +1380,8 @@ fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n pub fn translate_span(cdata: Cmd,\n                       codemap: &codemap::CodeMap,\n                       last_filemap_index_hint: &Cell<usize>,\n-                      span: codemap::Span)\n-                      -> codemap::Span {\n+                      span: syntax_pos::Span)\n+                      -> syntax_pos::Span {\n     let span = if span.lo > span.hi {\n         // Currently macro expansion sometimes produces invalid Span values\n         // where lo > hi. In order not to crash the compiler when trying to\n@@ -1390,7 +1390,7 @@ pub fn translate_span(cdata: Cmd,\n         // least some of the time).\n         // This workaround is only necessary as long as macro expansion is\n         // not fixed. FIXME(#23480)\n-        codemap::mk_sp(span.lo, span.lo)\n+        syntax_pos::mk_sp(span.lo, span.lo)\n     } else {\n         span\n     };\n@@ -1430,7 +1430,7 @@ pub fn translate_span(cdata: Cmd,\n     let hi = (span.hi - filemap.original_start_pos) +\n               filemap.translated_filemap.start_pos;\n \n-    codemap::mk_sp(lo, hi)\n+    syntax_pos::mk_sp(lo, hi)\n }\n \n pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n@@ -1733,7 +1733,7 @@ pub fn is_default_impl(cdata: Cmd, impl_id: DefIndex) -> bool {\n     item_family(impl_doc) == Family::DefaultImpl\n }\n \n-pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n+pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<syntax_pos::FileMap> {\n     let crate_doc = rbml::Doc::new(metadata);\n     let cm_doc = reader::get_doc(crate_doc, tag_codemap);\n "}, {"sha": "c23ad6d5f078fa2c284b8d379bedb43a15d2c794", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -44,10 +44,10 @@ use std::rc::Rc;\n use std::u32;\n use syntax::abi::Abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n-use syntax::codemap::BytePos;\n use syntax::attr;\n-use syntax::errors::Handler;\n+use errors::Handler;\n use syntax;\n+use syntax_pos::BytePos;\n use rbml::writer::Encoder;\n \n use rustc::hir::{self, PatKind};"}, {"sha": "1cf7282e9e95fe4bce706151681e275a7ac67f33", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -28,10 +28,11 @@\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n-\n+extern crate syntax_pos;\n extern crate flate;\n extern crate rbml;\n extern crate serialize as rustc_serialize; // used by deriving\n+extern crate rustc_errors as errors;\n \n #[macro_use]\n extern crate rustc;"}, {"sha": "56393b79980f62a75107e315267ee7556fd1df24", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -225,8 +225,8 @@ use rustc::util::common;\n use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n use rustc_llvm::archive_ro::ArchiveRO;\n-use syntax::codemap::Span;\n-use syntax::errors::DiagnosticBuilder;\n+use errors::DiagnosticBuilder;\n+use syntax_pos::Span;\n use rustc_back::target::Target;\n \n use std::cmp;"}, {"sha": "7dadf8d108a715f5e4dbf4c0b0e64499d5fc53d1", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,12 +16,12 @@ use cstore::CStore;\n use rustc::session::Session;\n \n use std::collections::{HashSet, HashMap};\n-use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::ext;\n+use syntax_pos::Span;\n \n pub struct MacroLoader<'a> {\n     sess: &'a Session,"}, {"sha": "2b8ba107fefc6c35586c6fd7db3bc2ec2d9c4cbb", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -29,7 +29,7 @@ use rustc::hir;\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::errors::Handler;\n+use errors::Handler;\n \n use rbml::leb128;\n use encoder;"}, {"sha": "2a1a815330675ad9b155a9045f7eb4262c38649f", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,3 +18,4 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "f1487992cb52285365e549e458484be1765592ce", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -24,7 +24,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc::mir::repr::*;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an rvalue."}, {"sha": "8ae23c9103b02ca7c51d7925b05715724e1cda83", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,7 +13,7 @@ use build::scope::LoopScope;\n use hair::*;\n use rustc::middle::region::CodeExtent;\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n "}, {"sha": "a94adafa802138f1c3e7409cb6da3aad36bf9028", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{AdtDef, Ty};\n use rustc::mir::repr::*;\n use hair::*;\n use syntax::ast::{Name, NodeId};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n // helper functions, broken out by category:\n mod simplify;"}, {"sha": "8c9ed53c8ab4de2794b1c5ce499af946d38d29f7", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -23,7 +23,7 @@ use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use std::cmp::Ordering;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {"}, {"sha": "79a4cf73041d7c6e6d120018d37e2297d8ac1a6b", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::{self, Ty};\n \n use rustc::mir::repr::*;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Add a new temporary value of type `ty` storing the result of"}, {"sha": "362e1e26fdf1e4cf79c76208f7c9efbb0abdb20f", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,8 +16,8 @@ use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n+use syntax_pos::Span;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n "}, {"sha": "1703fee9360cc4923929001ae990ef4202401333", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -92,7 +92,7 @@ use rustc::middle::lang_items;\n use rustc::ty::subst::{Substs, Subst, VecPerParamSpace};\n use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::fnv::FnvHashMap;\n "}, {"sha": "b5da50792762f17f33e4202447b0a05f44e143d6", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -17,8 +17,8 @@ use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n-use syntax::codemap::Span;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n /// When there are multiple patterns in a single arm, each one has its\n /// own node-ids for the bindings.  References to the variables always"}, {"sha": "a2746bf30c91f7020702f6bd15f94f243c59c27a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use rustc::hir;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use self::cx::Cx;\n \n pub mod cx;"}, {"sha": "3d01d49c53472ecb57c1429a97ca57b1cea19f16", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -38,6 +38,7 @@ extern crate rustc_back;\n extern crate rustc_bitflags;\n #[macro_use]\n extern crate syntax;\n+extern crate syntax_pos;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n "}, {"sha": "b7c5f35892b0b870c20df88a70913b5a9ca30e56", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -33,7 +33,7 @@ use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use std::mem;\n "}, {"sha": "4b551d6bb083cfa85eeb1af32293f67e1b6f21c8", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -26,7 +26,7 @@ use rustc::mir::repr::*;\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n use rustc::ty::{self, TyCtxt};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use build::Location;\n "}, {"sha": "1d00938fb25eb3d2c636fb0097ddf906d020c77d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -30,8 +30,8 @@ use rustc::mir::transform::{Pass, MirMapPass, MirPassHook, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::util::nodemap::DefIdMap;\n use syntax::abi::Abi;\n-use syntax::codemap::Span;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax_pos::Span;\n \n use std::collections::hash_map::Entry;\n use std::fmt;"}, {"sha": "db49e1e040791803103f66e7e34742e5d4b60248", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -22,7 +22,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{self, Visitor};\n use std::fmt;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_data_structures::indexed_vec::Idx;\n "}, {"sha": "cc710e0ac3563772aa88214d498e9d12488f992d", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,3 +14,5 @@ rustc = { path = \"../librustc\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n\\ No newline at end of file"}, {"sha": "a90b563515eae0e89b2159430200d7cbe03991b9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,10 +19,10 @@\n use rustc::lint;\n use rustc::session::Session;\n use syntax::ast::*;\n-use syntax::codemap::Span;\n-use syntax::errors;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n+use syntax_pos::Span;\n+use errors;\n \n struct AstValidator<'a> {\n     session: &'a Session,\n@@ -57,7 +57,7 @@ impl<'a> AstValidator<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for AstValidator<'a> {\n+impl<'a> Visitor for AstValidator<'a> {\n     fn visit_lifetime(&mut self, lt: &Lifetime) {\n         if lt.name.as_str() == \"'_\" {\n             self.session.add_lint(\n@@ -73,7 +73,7 @@ impl<'a, 'v> Visitor<'v> for AstValidator<'a> {\n         match expr.node {\n             ExprKind::While(_, _, Some(ident)) | ExprKind::Loop(_, Some(ident)) |\n             ExprKind::WhileLet(_, _, _, Some(ident)) | ExprKind::ForLoop(_, _, _, Some(ident)) |\n-            ExprKind::Break(Some(ident)) | ExprKind::Again(Some(ident)) => {\n+            ExprKind::Break(Some(ident)) | ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span, expr.id);\n             }\n             _ => {}"}, {"sha": "27ce03b2d9390c8c250f921282b072a33e3961c0", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -46,7 +46,7 @@ use rustc::lint::builtin::CONST_ERR;\n \n use rustc::hir::{self, PatKind};\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n \n use std::collections::hash_map::Entry;"}, {"sha": "650613f4844f526facb139225cc39d3a8a46e1e4", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -34,6 +34,8 @@ extern crate rustc_const_math;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+extern crate syntax_pos;\n+extern crate rustc_errors as errors;\n \n pub mod diagnostics;\n "}, {"sha": "dd0f16baaa395d524e6e91bf2abdcb3dbe5e0d65", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,7 +15,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n #[derive(Clone, Copy, PartialEq)]\n enum Context {"}, {"sha": "314513a974ecdb826b728523403a5056c635a062", "filename": "src/librustc_passes/no_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -29,7 +29,7 @@ struct CheckNoAsm<'a> {\n     sess: &'a Session,\n }\n \n-impl<'a, 'v> Visitor<'v> for CheckNoAsm<'a> {\n+impl<'a> Visitor for CheckNoAsm<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprKind::InlineAsm(_) => span_err!(self.sess, e.span, E0472,"}, {"sha": "4684683f02501afe32eeb60b76cd2afbe0891827", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -20,7 +20,7 @@ use rustc::traits::ProjectionMode;\n use rustc::hir;\n use rustc::hir::intravisit;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut rvcx = RvalueContext { tcx: tcx };"}, {"sha": "d0938ad09a0da1bced4e17ef57d5c1c1096c97fe", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,8 +18,8 @@ use rustc::hir::def::{Def, DefMap};\n use rustc::util::nodemap::NodeMap;\n \n use syntax::{ast};\n-use syntax::codemap::Span;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n+use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n "}, {"sha": "514d81ecc94f2a9f6b27ca8f5c39520b69f9c1b7", "filename": "src/librustc_plugin/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,3 +15,5 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "ff3038c3d1175326659d82763a0361e867105436", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,8 +12,8 @@\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::Span;\n-use syntax::errors;\n+use errors;\n+use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::Visitor;"}, {"sha": "e60a657ba193d9829e9844b586c825c3c138629f", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -70,6 +70,8 @@\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_metadata;\n+extern crate syntax_pos;\n+extern crate rustc_errors as errors;\n \n pub use self::registry::Registry;\n "}, {"sha": "a3cd9b5da02bc3b2df506cc166614784826529d5", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -20,9 +20,9 @@ use std::env;\n use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n-use syntax::codemap::{Span, COMMAND_LINE_SP};\n use syntax::ptr::P;\n use syntax::attr::AttrMetaMethods;\n+use syntax_pos::{Span, COMMAND_LINE_SP};\n \n /// Pointer to a registrar function.\n pub type PluginRegistrarFun ="}, {"sha": "54fa0197de4fe0fcf2ee7013308ce69a3cb45701", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,11 +18,11 @@ use rustc::mir::transform::MirMapPass;\n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n use syntax::ext::base::{IdentTT, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroExpanderFn, MacroRulesTT};\n-use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n+use syntax_pos::Span;\n \n use std::collections::HashMap;\n use std::borrow::ToOwned;"}, {"sha": "439fa661e0ab52dfc117c8dc48c749d43b4295b3", "filename": "src/librustc_privacy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -11,3 +11,4 @@ crate-type = [\"dylib\"]\n [dependencies]\n rustc = { path = \"../librustc\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "85a6f732dd52e71716efd93395dbcd210f028a99", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -23,6 +23,7 @@\n \n extern crate rustc;\n #[macro_use] extern crate syntax;\n+extern crate syntax_pos;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n@@ -35,7 +36,7 @@ use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::NodeSet;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use std::cmp;\n use std::mem::replace;"}, {"sha": "5ce4c74e735fd6fb11015095554c5777730d2878", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,3 +14,5 @@ log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n rustc = { path = \"../librustc\" }\n arena = { path = \"../libarena\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "5867e48c7ca27b64d5fbea039fffde6a34a6ec8f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -29,15 +29,16 @@ use rustc::ty::{self, VariantKind};\n use syntax::ast::Name;\n use syntax::attr;\n use syntax::parse::token;\n-use syntax::codemap::{Span, DUMMY_SP};\n \n-use syntax::ast::{Block, Crate, DeclKind};\n+use syntax::ast::{Block, Crate};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, PathListItemKind};\n-use syntax::ast::{Stmt, StmtKind, TraitItemKind};\n+use syntax::ast::{StmtKind, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::visit::{self, Visitor};\n \n+use syntax_pos::{Span, DUMMY_SP};\n+\n trait ToNameBinding<'a> {\n     fn to_name_binding(self) -> NameBinding<'a>;\n }\n@@ -84,17 +85,11 @@ impl<'b> Resolver<'b> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        fn is_item(statement: &Stmt) -> bool {\n-            if let StmtKind::Decl(ref declaration, _) = statement.node {\n-                if let DeclKind::Item(_) = declaration.node {\n-                    return true;\n-                }\n-            }\n-            false\n-        }\n-\n         // If any statements are items, we need to create an anonymous module\n-        block.stmts.iter().any(is_item)\n+        block.stmts.iter().any(|statement| match statement.node {\n+            StmtKind::Item(_) => true,\n+            _ => false,\n+        })\n     }\n \n     /// Constructs the reduced graph for one item.\n@@ -313,6 +308,7 @@ impl<'b> Resolver<'b> {\n                             (Def::Method(item_def_id), ValueNS)\n                         }\n                         TraitItemKind::Type(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n+                        TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                     };\n \n                     self.define(module_parent, item.ident.name, ns, (def, item.span, vis));\n@@ -503,7 +499,7 @@ struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n     parent: Module<'b>,\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item) {\n         let old_parent = self.parent;\n         self.resolver.build_reduced_graph_for_item(item, &mut self.parent);"}, {"sha": "3084d9abbe1e4f8cab3a93f271145c4ad03a8f9e", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,7 +27,7 @@ use Namespace::{TypeNS, ValueNS};\n use rustc::lint;\n use syntax::ast::{self, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::visit::{self, Visitor};\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n \n struct UnusedImportCheckVisitor<'a, 'b: 'a> {\n@@ -71,7 +71,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n+impl<'a, 'b> Visitor for UnusedImportCheckVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         visit::walk_item(self, item);\n         // Ignore is_public import statements because there's no way to be sure"}, {"sha": "8ffa95ec7e96f2c860aa98833c7c9811b01bc8cc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,6 +27,8 @@\n extern crate log;\n #[macro_use]\n extern crate syntax;\n+extern crate syntax_pos;\n+extern crate rustc_errors as errors;\n extern crate arena;\n #[macro_use]\n extern crate rustc;\n@@ -54,8 +56,6 @@ use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n use syntax::ext::mtwt;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n-use syntax::codemap::{self, Span};\n-use syntax::errors::DiagnosticBuilder;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -66,6 +66,9 @@ use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n \n+use syntax_pos::Span;\n+use errors::DiagnosticBuilder;\n+\n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n@@ -177,13 +180,13 @@ enum UnresolvedNameContext<'a> {\n }\n \n fn resolve_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n-                                 span: syntax::codemap::Span,\n+                                 span: syntax_pos::Span,\n                                  resolution_error: ResolutionError<'c>) {\n     resolve_struct_error(resolver, span, resolution_error).emit();\n }\n \n fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n-                                        span: syntax::codemap::Span,\n+                                        span: syntax_pos::Span,\n                                         resolution_error: ResolutionError<'c>)\n                                         -> DiagnosticBuilder<'a> {\n     if !resolver.emit_errors {\n@@ -495,7 +498,7 @@ pub enum Namespace {\n     ValueNS,\n }\n \n-impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n+impl<'a> Visitor for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n     }\n@@ -554,9 +557,9 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n         });\n     }\n     fn visit_fn(&mut self,\n-                function_kind: FnKind<'v>,\n-                declaration: &'v FnDecl,\n-                block: &'v Block,\n+                function_kind: FnKind,\n+                declaration: &FnDecl,\n+                block: &Block,\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n@@ -1637,6 +1640,7 @@ impl<'a> Resolver<'a> {\n                                         visit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n+                                TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                             };\n                         }\n                     });\n@@ -1804,10 +1808,10 @@ impl<'a> Resolver<'a> {\n                             self.resolve_crate_relative_path(trait_path.span, segments, TypeNS)\n                         } else {\n                             self.resolve_module_relative_path(trait_path.span, segments, TypeNS)\n-                        }.map(|binding| binding.span).unwrap_or(codemap::DUMMY_SP)\n+                        }.map(|binding| binding.span).unwrap_or(syntax_pos::DUMMY_SP)\n                     };\n \n-                    if definition_site != codemap::DUMMY_SP {\n+                    if definition_site != syntax_pos::DUMMY_SP {\n                         err.span_label(definition_site,\n                                        &format!(\"type aliases cannot be used for traits\"));\n                     }\n@@ -2332,8 +2336,8 @@ impl<'a> Resolver<'a> {\n                     }, \"variant or struct\");\n                 }\n \n-                PatKind::Path(ref path) => {\n-                    self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n+                PatKind::Path(ref qself, ref path) => {\n+                    self.resolve_pattern_path(pat.id, qself.as_ref(), path, ValueNS, |def| {\n                         match def {\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) | Def::Err => true,\n@@ -2342,15 +2346,6 @@ impl<'a> Resolver<'a> {\n                     }, \"variant, struct or constant\");\n                 }\n \n-                PatKind::QPath(ref qself, ref path) => {\n-                    self.resolve_pattern_path(pat.id, Some(qself), path, ValueNS, |def| {\n-                        match def {\n-                            Def::AssociatedConst(..) | Def::Err => true,\n-                            _ => false,\n-                        }\n-                    }, \"associated constant\");\n-                }\n-\n                 PatKind::Struct(ref path, _, _) => {\n                     self.resolve_pattern_path(pat.id, None, path, TypeNS, |def| {\n                         match def {\n@@ -2956,7 +2951,7 @@ impl<'a> Resolver<'a> {\n                 })\n             }\n \n-            ExprKind::Break(Some(label)) | ExprKind::Again(Some(label)) => {\n+            ExprKind::Break(Some(label)) | ExprKind::Continue(Some(label)) => {\n                 match self.search_label(mtwt::resolve(label.node)) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());\n@@ -3338,7 +3333,7 @@ impl<'a> Resolver<'a> {\n             },\n         };\n \n-        if old_binding.span != codemap::DUMMY_SP {\n+        if old_binding.span != syntax_pos::DUMMY_SP {\n             err.span_label(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n         }\n         err.emit();"}, {"sha": "cb308f91204046fae6b06b7a73eafbce7e7e1a8e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -25,8 +25,8 @@ use rustc::lint;\n use rustc::hir::def::*;\n \n use syntax::ast::{NodeId, Name};\n-use syntax::codemap::{Span, DUMMY_SP};\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use std::cell::{Cell, RefCell};\n "}, {"sha": "3d66e5a3007874cecbeaeeff98ddd43e33b481c7", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,3 +13,4 @@ log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n syntax = { path = \"../libsyntax\" }\n serialize = { path = \"../libserialize\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "493f7669337fe17a26cce8851220b2d313a5dc9f", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,7 +15,7 @@\n \n use rustc::hir::def_id::DefId;\n use syntax::ast::{CrateNum, NodeId};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n pub struct CrateData {\n     pub name: String,"}, {"sha": "c1960eeee46b8fb7eccede5f0fda8f5f911e96b4", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -36,11 +36,12 @@ use std::collections::HashSet;\n use std::hash::*;\n \n use syntax::ast::{self, NodeId, PatKind};\n-use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n use syntax::ptr::P;\n+use syntax::codemap::Spanned;\n+use syntax_pos::*;\n \n use super::{escape, generated_code, SaveContext, PathCollector};\n use super::data::*;\n@@ -1037,7 +1038,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n }\n \n-impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx, 'll, D> {\n+impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span, item.id);\n@@ -1215,7 +1216,8 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                     trait_item.span);\n             }\n             ast::TraitItemKind::Const(_, None) |\n-            ast::TraitItemKind::Type(..) => {}\n+            ast::TraitItemKind::Type(..) |\n+            ast::TraitItemKind::Macro(_) => {}\n         }\n     }\n \n@@ -1421,8 +1423,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n     }\n \n     fn visit_stmt(&mut self, s: &ast::Stmt) {\n-        let id = s.node.id();\n-        self.process_macro_use(s.span, id.unwrap());\n+        self.process_macro_use(s.span, s.id);\n         visit::walk_stmt(self, s)\n     }\n "}, {"sha": "65e4f7e869b0d01f3157df9b1b1ac71ac3dc8633", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,7 +12,8 @@ use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use syntax::ast::{CrateNum, NodeId};\n-use syntax::codemap::{Span, CodeMap};\n+use syntax::codemap::CodeMap;\n+use syntax_pos::Span;\n \n use data;\n "}, {"sha": "8eaf398778380be7724bc42cd60dc8d5c60c5e54", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -27,6 +27,7 @@\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n extern crate serialize as rustc_serialize;\n+extern crate syntax_pos;\n \n mod csv_dumper;\n mod json_dumper;\n@@ -49,10 +50,11 @@ use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, NodeId, PatKind};\n-use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{ty_to_string, arg_to_string};\n+use syntax::codemap::MacroAttribute;\n+use syntax_pos::*;\n \n pub use self::csv_dumper::CsvDumper;\n pub use self::json_dumper::JsonDumper;\n@@ -691,16 +693,15 @@ impl PathCollector {\n     }\n }\n \n-impl<'v> Visitor<'v> for PathCollector {\n+impl Visitor for PathCollector {\n     fn visit_pat(&mut self, p: &ast::Pat) {\n         match p.node {\n             PatKind::Struct(ref path, _, _) => {\n                 self.collected_paths.push((p.id, path.clone(),\n                                            ast::Mutability::Mutable, recorder::TypeRef));\n             }\n             PatKind::TupleStruct(ref path, _, _) |\n-            PatKind::Path(ref path) |\n-            PatKind::QPath(_, ref path) => {\n+            PatKind::Path(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(),\n                                            ast::Mutability::Mutable, recorder::VarRef));\n             }"}, {"sha": "953c65549195a9ee00739cafa6f145c7221b23c2", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -17,9 +17,9 @@ use std::env;\n use std::path::Path;\n \n use syntax::ast;\n-use syntax::codemap::*;\n use syntax::parse::lexer::{self, Reader, StringReader};\n use syntax::parse::token::{self, keywords, Token};\n+use syntax_pos::*;\n \n #[derive(Clone)]\n pub struct SpanUtils<'a> {"}, {"sha": "38f9e7ab0c51cce9537b5e3822487ef1d84cc86a", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,8 +19,10 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "15beba0d9a6eeb639bb88bf82513df3e586bec83", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -230,7 +230,7 @@ use std::fmt;\n use std::rc::Rc;\n use rustc::hir::{self, PatKind};\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir::fold::Folder;\n use syntax::ptr::P;\n "}, {"sha": "0ca59cfd7571b8e846712f90e8433a689fae6b0b", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -42,8 +42,8 @@ use std::process::Command;\n use std::str;\n use flate;\n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::attr::AttrMetaMethods;\n+use syntax_pos::Span;\n \n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n // Version 1"}, {"sha": "d644fcca3bad869022a5b9aaaa5c1ca6bb4cf12a", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,9 +19,9 @@ use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n-use syntax::codemap::MultiSpan;\n-use syntax::errors::{self, Handler, Level, RenderSpan};\n-use syntax::errors::emitter::CoreEmitter;\n+use errors::{self, Handler, Level, RenderSpan};\n+use errors::emitter::CoreEmitter;\n+use syntax_pos::MultiSpan;\n \n use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n@@ -357,7 +357,7 @@ struct HandlerFreeVars<'a> {\n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    use syntax::codemap::ExpnId;\n+    use syntax_pos::ExpnId;\n \n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {"}, {"sha": "2998c834aca7a870d4f62011b3c1d13dee6cb4e0", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -101,7 +101,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n use std::str;\n use std::{i8, i16, i32, i64};\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n use syntax::parse::token::InternedString;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;"}, {"sha": "4a7a5736b13a6fd4c49ccd1bc0e1e7d8fb085d27", "filename": "src/librustc_trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,7 +16,7 @@ use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use common::*;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use builder::Builder;\n use type_::Type;"}, {"sha": "d415698660000c229a0c1c44c6439e5c0e6f7b9d", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -24,7 +24,7 @@ use libc::{c_uint, c_char};\n \n use std::ffi::CString;\n use std::ptr;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,"}, {"sha": "9ea65532b35b61c8c3a1cd35deda4ca89861ad34", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -53,8 +53,8 @@ use Disr;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::hir;\n \n-use syntax::codemap::DUMMY_SP;\n-use syntax::errors;\n+use syntax_pos::DUMMY_SP;\n+use errors;\n use syntax::ptr::P;\n \n #[derive(Debug)]"}, {"sha": "eea6aec37260e9e918ed8417a43e850919871494", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -203,8 +203,8 @@ use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n use syntax::abi::Abi;\n-use syntax::codemap::DUMMY_SP;\n-use syntax::errors;\n+use errors;\n+use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};"}, {"sha": "d057f623383d3587b59b0e0b77c813c5b0334fca", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -52,9 +52,9 @@ use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n \n use syntax::ast;\n-use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n+use syntax_pos::{DUMMY_SP, Span};\n \n pub use context::{CrateContext, SharedCrateContext};\n "}, {"sha": "4e12d3d5d82310120897b93bd06d89a99300f65f", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -49,9 +49,9 @@ use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast::{self, LitKind};\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub type FnArgMap<'a> = Option<&'a NodeMap<ValueRef>>;\n "}, {"sha": "875f88e37c916d623d8e9024be1aa7506a0b7d07", "filename": "src/librustc_trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdatum.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -106,7 +106,7 @@ use rustc::ty::Ty;\n \n use std::fmt;\n use syntax::ast;\n-use syntax::codemap::DUMMY_SP;\n+use syntax_pos::DUMMY_SP;\n \n /// A `Datum` encapsulates the result of evaluating an expression.  It\n /// describes where the value is stored, what Rust type the value has,"}, {"sha": "2b079e7dcc8d9cd483c5db3786435f2750a2dae0", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -22,7 +22,7 @@ use rustc::util::nodemap::NodeMap;\n use libc::c_uint;\n use std::ptr;\n \n-use syntax::codemap::{Span, Pos};\n+use syntax_pos::{Span, Pos};\n use syntax::{ast, codemap};\n \n use rustc_data_structures::bitvec::BitVector;"}, {"sha": "34dedeede98e0c6ef480df93c2374cad40164e05", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -44,9 +44,9 @@ use std::ptr;\n use std::rc::Rc;\n use syntax;\n use syntax::util::interner::Interner;\n-use syntax::codemap::Span;\n-use syntax::{ast, codemap};\n+use syntax::ast;\n use syntax::parse::token;\n+use syntax_pos::{self, Span};\n \n \n // From DWARF 5.\n@@ -660,7 +660,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             &[],\n                             containing_scope,\n                             NO_FILE_METADATA,\n-                            codemap::DUMMY_SP)\n+                            syntax_pos::DUMMY_SP)\n }\n \n pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1385,7 +1385,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                             &[sole_struct_member_description],\n                                             self.containing_scope,\n                                             self.file_metadata,\n-                                            codemap::DUMMY_SP);\n+                                            syntax_pos::DUMMY_SP);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -1615,7 +1615,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx,\n                                   adt::ty_of_inttype(cx.tcx(), inttype),\n-                                  codemap::DUMMY_SP);\n+                                  syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n                 let name = CString::new(discriminant_name.as_bytes()).unwrap();\n@@ -1849,7 +1849,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let node_def_id = cx.tcx().map.local_def_id(node_id);\n     let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n \n-    let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n+    let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n         let loc = span_start(cx, span);\n         (file_metadata(cx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n     } else {"}, {"sha": "8c5b3ed54c2f58e04acf399a12b0171084154842", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -42,8 +42,8 @@ use std::cell::{Cell, RefCell};\n use std::ffi::CString;\n use std::ptr;\n \n-use syntax::codemap::{Span, Pos};\n-use syntax::{ast, codemap};\n+use syntax_pos::{self, Span, Pos};\n+use syntax::ast;\n use syntax::attr::IntType;\n \n pub mod gdb;\n@@ -242,7 +242,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (containing_scope, span) = get_containing_scope_and_span(cx, instance);\n \n     // This can be the case for functions inlined from another crate\n-    if span == codemap::DUMMY_SP {\n+    if span == syntax_pos::DUMMY_SP {\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n@@ -327,7 +327,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         signature.push(match sig.output {\n             ty::FnConverging(ret_ty) => match ret_ty.sty {\n                 ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-                _ => type_metadata(cx, ret_ty, codemap::DUMMY_SP)\n+                _ => type_metadata(cx, ret_ty, syntax_pos::DUMMY_SP)\n             },\n             ty::FnDiverging => diverging_type_metadata(cx)\n         });\n@@ -340,13 +340,13 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         // Arguments types\n         for &argument_type in inputs {\n-            signature.push(type_metadata(cx, argument_type, codemap::DUMMY_SP));\n+            signature.push(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP));\n         }\n \n         if abi == Abi::RustCall && !sig.inputs.is_empty() {\n             if let ty::TyTuple(args) = sig.inputs[sig.inputs.len() - 1].sty {\n                 for &argument_type in args {\n-                    signature.push(type_metadata(cx, argument_type, codemap::DUMMY_SP));\n+                    signature.push(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP));\n                 }\n             }\n         }\n@@ -386,7 +386,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n             generics.types.as_slice().iter().enumerate().map(|(i, param)| {\n                 let actual_type = cx.tcx().normalize_associated_type(&actual_types[i]);\n-                let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n+                let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(param.name.as_str().as_bytes()).unwrap();\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n@@ -420,7 +420,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let impl_self_ty = monomorphize::apply_param_substs(cx.tcx(),\n                                                                     instance.substs,\n                                                                     &impl_self_ty);\n-                Some(type_metadata(cx, impl_self_ty, codemap::DUMMY_SP))\n+                Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n             } else {\n                 // For trait method impls we still use the \"parallel namespace\"\n                 // strategy\n@@ -441,7 +441,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         // Try to get some span information, if we have an inlined item.\n         let definition_span = match cx.external().borrow().get(&instance.def) {\n             Some(&Some(node_id)) => cx.tcx().map.span(node_id),\n-            _ => cx.tcx().map.def_id_span(instance.def, codemap::DUMMY_SP)\n+            _ => cx.tcx().map.def_id_span(instance.def, syntax_pos::DUMMY_SP)\n         };\n \n         (containing_scope, definition_span)"}, {"sha": "167229ddfd9856eb24b5f9c42165ec7fd00e888a", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -22,7 +22,7 @@ use common::CrateContext;\n use libc::c_uint;\n use std::ffi::CString;\n use std::ptr;\n-use syntax::codemap::DUMMY_SP;\n+use syntax_pos::DUMMY_SP;\n \n pub fn mangled_name_of_item(ccx: &CrateContext, def_id: DefId, extra: &str) -> String {\n     fn fill_nested(ccx: &CrateContext, def_id: DefId, extra: &str, output: &mut String) {"}, {"sha": "9726001b4d42b71828a51298eee9127a817eff9d", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -21,8 +21,8 @@ use common::{NodeIdAndSpan, CrateContext, FunctionContext};\n \n use libc::c_uint;\n use std::ptr;\n-use syntax::codemap::{Span, Pos};\n-use syntax::{ast, codemap};\n+use syntax_pos::{self, Span, Pos};\n+use syntax::ast;\n \n pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n@@ -70,7 +70,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n                 cleanup_span = Span {\n-                    lo: node_span.hi - codemap::BytePos(1),\n+                    lo: node_span.hi - syntax_pos::BytePos(1),\n                     hi: node_span.hi,\n                     expn_id: node_span.expn_id\n                 };"}, {"sha": "1e0afa4534b15f5f71803582e62031bf4cfede69", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -21,8 +21,8 @@ use machine;\n use common::{CrateContext, FunctionContext};\n use type_::Type;\n \n-use syntax::codemap::Span;\n-use syntax::{ast, codemap};\n+use syntax_pos::{self, Span};\n+use syntax::ast;\n \n pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n {\n@@ -44,8 +44,8 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-/// Return codemap::Loc corresponding to the beginning of the span\n-pub fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n+/// Return syntax_pos::Loc corresponding to the beginning of the span\n+pub fn span_start(cx: &CrateContext, span: Span) -> syntax_pos::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo)\n }\n \n@@ -88,7 +88,7 @@ pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n     // Try to get some span information, if we have an inlined item.\n     let definition_span = match cx.external().borrow().get(&def_id) {\n         Some(&Some(node_id)) => cx.tcx().map.span(node_id),\n-        _ => cx.tcx().map.def_id_span(def_id, codemap::DUMMY_SP)\n+        _ => cx.tcx().map.def_id_span(def_id, syntax_pos::DUMMY_SP)\n     };\n \n     (containing_scope, definition_span)"}, {"sha": "71c6cba9cc22a6866aa221368c44cf21950a94ff", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -81,8 +81,9 @@ use type_::Type;\n \n use rustc::hir;\n \n-use syntax::{ast, codemap};\n+use syntax::ast;\n use syntax::parse::token::InternedString;\n+use syntax_pos;\n use std::fmt;\n use std::mem;\n \n@@ -454,7 +455,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              span: codemap::Span,\n+                              span: syntax_pos::Span,\n                               source: Datum<'tcx, Rvalue>,\n                               target: Datum<'tcx, Rvalue>)\n                               -> Block<'blk, 'tcx> {\n@@ -1265,7 +1266,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             fields: &[hir::Field],\n                             base: Option<&hir::Expr>,\n-                            expr_span: codemap::Span,\n+                            expr_span: syntax_pos::Span,\n                             expr_id: ast::NodeId,\n                             ty: Ty<'tcx>,\n                             dest: Dest) -> Block<'blk, 'tcx> {"}, {"sha": "ac23d713d2727936f91b8cdc042b656363920960", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -43,7 +43,7 @@ use type_::Type;\n use value::Value;\n \n use arena::TypedArena;\n-use syntax::codemap::DUMMY_SP;\n+use syntax_pos::DUMMY_SP;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            v: ValueRef,"}, {"sha": "a721361fce0e3aecbbd152edb8fd663507383df3", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -44,7 +44,7 @@ use syntax::ptr::P;\n use syntax::parse::token;\n \n use rustc::session::Session;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n "}, {"sha": "c369858556d3a454c823b2862d636b6226afdcdd", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -55,6 +55,8 @@ extern crate rustc_const_eval;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+extern crate syntax_pos;\n+extern crate rustc_errors as errors;\n \n pub use rustc::session;\n pub use rustc::middle;"}, {"sha": "ac6af8d66e19ff55b24c84ce9e099147071c4506", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -36,7 +36,7 @@ use value::Value;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use syntax::ast::Name;\n-use syntax::codemap::DUMMY_SP;\n+use syntax_pos::DUMMY_SP;\n \n // drop_glue pointer, size, align.\n const VTABLE_OFFSET: usize = 3;"}, {"sha": "da72793abf6dab869a558e9993e7362c342ef916", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -34,7 +34,7 @@ use type_of;\n use type_::Type;\n use value::Value;\n \n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n use std::ptr;\n "}, {"sha": "0221232a77df5275a89754b15c3e39e5104ce411", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -21,7 +21,7 @@ use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind};\n use machine;\n use type_of;\n \n-use syntax::codemap::DUMMY_SP;\n+use syntax_pos::DUMMY_SP;\n use syntax::parse::token::keywords;\n \n use std::ops::Deref;"}, {"sha": "28bcd8a633c1c96fa792da00036a55ac8f24d953", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -133,8 +133,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n                             use rustc::hir;\n                             use syntax::ast::DUMMY_NODE_ID;\n-                            use syntax::codemap::DUMMY_SP;\n                             use syntax::ptr::P;\n+                            use syntax_pos::DUMMY_SP;\n                             use closure;\n \n                             closure::trans_closure_expr(closure::Dest::Ignore(bcx.ccx()),"}, {"sha": "fa00ea1e7801bb4a7cf31a2b30fba1fc867077b9", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -28,7 +28,7 @@ use rustc::util::ppaux;\n use rustc::hir;\n \n use syntax::attr;\n-use syntax::errors;\n+use errors;\n \n use std::fmt;\n "}, {"sha": "720423371a83a814324e1694a97aca276426940f", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,3 +19,5 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "088ac1aac1a4016926e9507b8790a43d6e3eb335", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -73,10 +73,10 @@ use util::nodemap::{NodeMap, FnvHashSet};\n use rustc_const_math::ConstInt;\n use std::cell::RefCell;\n use syntax::{abi, ast};\n-use syntax::codemap::{Span, Pos};\n-use syntax::errors::DiagnosticBuilder;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token::{self, keywords};\n+use syntax_pos::{Span, Pos};\n+use errors::DiagnosticBuilder;\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;"}, {"sha": "069a09183a738e7fd8cb6cd26fa871f1bbb6ef43", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -21,8 +21,9 @@ use session::Session;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n use syntax::ast;\n-use syntax::codemap::{Span, Spanned};\n+use syntax::codemap::Spanned;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;"}, {"sha": "41f34b9040e832b3d580cba853fe9d575d2495eb", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,7 +13,7 @@ use rustc::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n use rustc::ty::fold::TypeFoldable;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n //FIXME(@jroesch): Ideally we should be able to drop the fulfillment_cx argument.\n pub fn normalize_associated_types_in<'a, 'gcx, 'tcx, T>("}, {"sha": "3c176744fca592b0dd766a9a3db378223bd0cfc4", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::hir;\n \n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use syntax::parse::token;\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "2c7e7d284fa160250de1ba5b9e7b71c37be092b7", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -17,9 +17,9 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use rustc::infer;\n use rustc::ty::{self, LvaluePreference, Ty};\n-use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n use rustc::hir;\n "}, {"sha": "22ac8bc56907bfd9578e94134ea0ea1ad3117c50", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -47,7 +47,7 @@ use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::cast::{CastKind, CastTy};\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use util::common::ErrorReported;\n \n /// Reifies a cast check to be checked once we have full type information for"}, {"sha": "35a5bc9c60967d69512b3b573d26b903e59ce187", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,7 +15,7 @@ use rustc::traits::{self, ProjectionMode};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use CrateCtxt;\n use super::assoc;"}, {"sha": "eeebd6a7f626b74160e7c2d4c27d1844cc3bd5db", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,7 +13,7 @@ use check::FnCtxt;\n use rustc::ty::Ty;\n use rustc::infer::{InferOk, TypeOrigin};\n \n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "56e4108153e1e669f0a2db85a67657be56cf2801", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -21,7 +21,7 @@ use rustc::traits::{self, ProjectionMode};\n use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n-use syntax::codemap::{self, Span};\n+use syntax_pos::{self, Span};\n \n /// check_drop_impl confirms that the Drop implementation identfied by\n /// `drop_impl_did` is not any more specialized than the type it is\n@@ -62,7 +62,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n         _ => {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, so we can panic here.\n-            let span = ccx.tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+            let span = ccx.tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n             span_bug!(span,\n                       \"should have been rejected by coherence check: {}\",\n                       dtor_self_type);\n@@ -91,7 +91,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let named_type = tcx.lookup_item_type(self_type_did).ty;\n         let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n-        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n         let fresh_impl_substs =\n             infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, &fresh_impl_substs);\n@@ -172,7 +172,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n     let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n-    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold."}, {"sha": "5a3268e9e447b25a9165c02eec623c5f6164cedd", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -20,8 +20,8 @@ use {CrateCtxt, require_same_types};\n use std::collections::{HashMap};\n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax_pos::Span;\n \n use rustc::hir;\n "}, {"sha": "5fac65bbfd6552d365eab1b611a55c93994aff70", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir;\n \n use std::ops::Deref;"}, {"sha": "e6401be5b3ef655f9b78785448932ee0a92e525e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::infer;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use rustc::hir;\n "}, {"sha": "373fc83fa7444c1c8cf1f0f5b5e545dbe6939f4e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -22,7 +22,7 @@ use rustc::traits;\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n use syntax::ast;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir;\n use std::collections::HashSet;\n use std::mem;"}, {"sha": "f20dcdc35aea5c7af46ded13c2b84800a42ddc63", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -24,10 +24,10 @@ use rustc::ty::subst::Substs;\n use rustc::traits::{Obligation, SelectionContext};\n use util::nodemap::{FnvHashSet};\n \n-\n use syntax::ast;\n-use syntax::codemap::Span;\n-use syntax::errors::DiagnosticBuilder;\n+use errors::DiagnosticBuilder;\n+use syntax_pos::Span;\n+\n use rustc::hir::print as pprust;\n use rustc::hir;\n use rustc::hir::Expr_;"}, {"sha": "83b5ab71cc2246f5285041e5c1a2005bbba719a7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -115,11 +115,12 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{self, Span, Spanned};\n-use syntax::errors::DiagnosticBuilder;\n+use syntax::codemap::{self, Spanned};\n use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax_pos::{self, Span};\n+use errors::DiagnosticBuilder;\n \n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n@@ -1908,7 +1909,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for ty in &self.unsolved_variables() {\n                 if let ty::TyInfer(_) = self.shallow_resolve(ty).sty {\n                     debug!(\"default_type_parameters: defaulting `{:?}` to error\", ty);\n-                    self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().types.err);\n+                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx().types.err);\n                 }\n             }\n             return;\n@@ -1919,18 +1920,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if self.type_var_diverges(resolved) {\n                 debug!(\"default_type_parameters: defaulting `{:?}` to `()` because it diverges\",\n                        resolved);\n-                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n             } else {\n                 match self.type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n                         debug!(\"default_type_parameters: defaulting `{:?}` to `i32`\",\n                                resolved);\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.i32)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n                     },\n                     UnconstrainedFloat => {\n                         debug!(\"default_type_parameters: defaulting `{:?}` to `f32`\",\n                                resolved);\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.f64)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n                     }\n                     Neither => { }\n                 }\n@@ -1993,7 +1994,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for ty in &unsolved_variables {\n                 let resolved = self.resolve_type_vars_if_possible(ty);\n                 if self.type_var_diverges(resolved) {\n-                    self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n                 } else {\n                     match self.type_is_unconstrained_numeric(resolved) {\n                         UnconstrainedInt | UnconstrainedFloat => {\n@@ -2051,14 +2052,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n                 for ty in &unbound_tyvars {\n                     if self.type_var_diverges(ty) {\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n                     } else {\n                         match self.type_is_unconstrained_numeric(ty) {\n                             UnconstrainedInt => {\n-                                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.i32)\n+                                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n                             },\n                             UnconstrainedFloat => {\n-                                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.f64)\n+                                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n                             }\n                             Neither => {\n                                 if let Some(default) = default_map.get(ty) {\n@@ -2096,7 +2097,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.find_conflicting_default(&unbound_tyvars, &default_map, conflict)\n                             .unwrap_or(type_variable::Default {\n                                 ty: self.next_ty_var(),\n-                                origin_span: codemap::DUMMY_SP,\n+                                origin_span: syntax_pos::DUMMY_SP,\n                                 def_id: self.tcx.map.local_def_id(0) // what do I put here?\n                             });\n \n@@ -2147,14 +2148,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // reporting for more then one conflict.\n         for ty in &unbound_tyvars {\n             if self.type_var_diverges(ty) {\n-                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n             } else {\n                 match self.type_is_unconstrained_numeric(ty) {\n                     UnconstrainedInt => {\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.i32)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n                     },\n                     UnconstrainedFloat => {\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.f64)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n                     },\n                     Neither => {\n                         if let Some(default) = default_map.get(ty) {"}, {"sha": "5a7038a056982cc390709acb49a14c1beebd1f75", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -99,7 +99,7 @@ use rustc::ty::wf::ImpliedBound;\n use std::mem;\n use std::ops::Deref;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n "}, {"sha": "702dd5f8de58a3060cc3430206d119f6a7c09226", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -49,7 +49,7 @@ use rustc::ty::{self, Ty};\n use rustc::infer::UpvarRegion;\n use std::collections::HashSet;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor};\n "}, {"sha": "d101381e2565c72823332aefc602e721c228bfb8", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,9 +19,10 @@ use rustc::ty::{self, Ty, TyCtxt};\n \n use std::collections::HashSet;\n use syntax::ast;\n-use syntax::codemap::{Span};\n-use syntax::errors::DiagnosticBuilder;\n use syntax::parse::token::keywords;\n+use syntax_pos::Span;\n+use errors::DiagnosticBuilder;\n+\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n "}, {"sha": "7f5f3ae120b7a0cad09a8bd9ca6dac5cb1629180", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -25,7 +25,8 @@ use write_ty_to_tcx;\n use std::cell::Cell;\n \n use syntax::ast;\n-use syntax::codemap::{DUMMY_SP, Span};\n+use syntax_pos::{DUMMY_SP, Span};\n+\n use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};"}, {"sha": "2ee0927f3c8ea44e5d8d945aab7fabf0a1c0bff5", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,7 +13,7 @@ use rustc::dep_graph::DepNode;\n use rustc::ty::TyCtxt;\n \n use syntax::ast;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir;\n use rustc::hir::intravisit::Visitor;"}, {"sha": "ade7806e71d12fab312019cc21ad2e7d843216e6", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -34,7 +34,7 @@ use CrateCtxt;\n use rustc::infer::{self, InferCtxt, TypeOrigin};\n use std::cell::RefCell;\n use std::rc::Rc;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use util::nodemap::{DefIdMap, FnvHashMap};\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;"}, {"sha": "15d4026254fa57ec1c8f2ee03cb25e99c81916a9", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,7 +16,7 @@ use hir::def_id::DefId;\n use rustc::traits;\n use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::intravisit;\n use rustc::hir;"}, {"sha": "2c33d1a81556eb9f28cae32520627a8aefa6d822", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -88,9 +88,10 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::rc::Rc;\n \n use syntax::{abi, ast, attr};\n-use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n+\n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit;\n use rustc::hir::print as pprust;"}, {"sha": "7ccff7ad3d87c06da57c00a6d79561a5b6e2e17e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -85,6 +85,7 @@ This API is completely unstable and subject to change.\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+extern crate syntax_pos;\n \n extern crate arena;\n extern crate fmt_macros;\n@@ -93,6 +94,7 @@ extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n+extern crate rustc_errors as errors;\n \n pub use rustc::dep_graph;\n pub use rustc::hir;\n@@ -110,9 +112,9 @@ use rustc::traits::ProjectionMode;\n use session::{config, CompileResult};\n use util::common::time;\n \n-use syntax::codemap::Span;\n use syntax::ast;\n use syntax::abi::Abi;\n+use syntax_pos::Span;\n \n use std::cell::RefCell;\n use util::nodemap::NodeMap;"}, {"sha": "336a61708683e0d6b05bea15cc3b490a54d67632", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,7 +12,7 @@\n use rustc::ty;\n \n use std::cell::Cell;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n #[derive(Clone)]\n pub struct ElisionFailureInfo {"}, {"sha": "cf87aabdfdb5e6c572a637569d6ed8176da35cc6", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,12 +15,14 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_driver = { path = \"../librustc_driver\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_trans = { path = \"../librustc_trans\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n log = { path = \"../liblog\" }\n \n [build-dependencies]"}, {"sha": "659022053128ecb48f9cea7ddbadb51c6ced8663", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -24,15 +24,14 @@ pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::Visibility::*;\n \n-use syntax;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n-use syntax::codemap;\n-use syntax::codemap::{DUMMY_SP, Pos, Spanned};\n+use syntax::codemap::Spanned;\n use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n+use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc_trans::back::link;\n use rustc::middle::cstore;\n@@ -533,7 +532,7 @@ impl attr::AttrMetaMethods for Attribute {\n         }\n     }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n-    fn span(&self) -> codemap::Span { unimplemented!() }\n+    fn span(&self) -> syntax_pos::Span { unimplemented!() }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n@@ -1977,7 +1976,7 @@ impl Span {\n     }\n }\n \n-impl Clean<Span> for syntax::codemap::Span {\n+impl Clean<Span> for syntax_pos::Span {\n     fn clean(&self, cx: &DocContext) -> Span {\n         if *self == DUMMY_SP {\n             return Span::empty();\n@@ -2543,7 +2542,7 @@ trait ToSource {\n     fn to_src(&self, cx: &DocContext) -> String;\n }\n \n-impl ToSource for syntax::codemap::Span {\n+impl ToSource for syntax_pos::Span {\n     fn to_src(&self, cx: &DocContext) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean(cx));\n         let sn = match cx.sess().codemap().span_to_snippet(*self) {"}, {"sha": "f4da8167ea28640fe4f9c8b64a5f9ee9303d267e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -22,10 +22,11 @@ use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n \n-use syntax::{ast, codemap, errors};\n-use syntax::errors::emitter::ColorConfig;\n+use syntax::{ast, codemap};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::parse::token;\n+use errors;\n+use errors::emitter::ColorConfig;\n \n use std::cell::{RefCell, Cell};\n use std::collections::{HashMap, HashSet};"}, {"sha": "04d176c36c8cf3c7c0eb7d17ae5261803b5658cb", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,13 +13,13 @@\n pub use self::StructType::*;\n pub use self::TypeBound::*;\n \n-use syntax;\n-use syntax::codemap::Span;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n use syntax::ptr::P;\n+use syntax_pos::{self, Span};\n+\n use rustc::hir;\n \n pub struct Module {\n@@ -56,8 +56,8 @@ impl Module {\n             vis: hir::Inherited,\n             stab: None,\n             depr: None,\n-            where_outer: syntax::codemap::DUMMY_SP,\n-            where_inner: syntax::codemap::DUMMY_SP,\n+            where_outer: syntax_pos::DUMMY_SP,\n+            where_inner: syntax_pos::DUMMY_SP,\n             attrs      : hir::HirVec::new(),\n             extern_crates: Vec::new(),\n             imports    : Vec::new(),"}, {"sha": "2e2f99897733dc3947b9323217f3227867357b87", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -26,10 +26,11 @@ use std::fmt::Display;\n use std::io;\n use std::io::prelude::*;\n \n-use syntax::codemap::{CodeMap, Span};\n+use syntax::codemap::CodeMap;\n use syntax::parse::lexer::{self, Reader, TokenAndSpan};\n use syntax::parse::token;\n use syntax::parse;\n+use syntax_pos::Span;\n \n /// Highlights `src`, returning the HTML output.\n pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>) -> String {"}, {"sha": "2015bb295eabd7be1f04f7b14bcd4008a61988f4", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -42,9 +42,11 @@ extern crate rustc_back;\n extern crate rustc_metadata;\n extern crate serialize;\n #[macro_use] extern crate syntax;\n+extern crate syntax_pos;\n extern crate test as testing;\n extern crate rustc_unicode;\n #[macro_use] extern crate log;\n+extern crate rustc_errors as errors;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "95d02d6ce4bee33135aae9a295aaf593965bbd6d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -35,8 +35,8 @@ use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n use syntax::codemap::CodeMap;\n-use syntax::errors;\n-use syntax::errors::emitter::ColorConfig;\n+use errors;\n+use errors::emitter::ColorConfig;\n use syntax::parse::token;\n \n use core;\n@@ -229,8 +229,9 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let data = Arc::new(Mutex::new(Vec::new()));\n     let codemap = Rc::new(CodeMap::new());\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n-                                                      None,\n-                                                      codemap.clone());\n+                                                None,\n+                                                codemap.clone(),\n+                                                errors::snippet::FormatMode::EnvironmentSelected);\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n "}, {"sha": "92424f113f987e806693e759028c9200db9d5ebb", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,7 +18,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::Span;\n+use syntax_pos::Span;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;"}, {"sha": "8b61e1b0d3a384c1960b88b4a11751c95edd2d80", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,3 +12,5 @@ crate-type = [\"dylib\"]\n serialize = { path = \"../libserialize\" }\n log = { path = \"../liblog\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "a352715b20b129a21ec56e1776a8a897b932f778", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 28, "deletions": 271, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,22 +14,19 @@ pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n+pub use util::ThinVec;\n \n-use attr::{ThinAttributes, HasAttrs};\n-use codemap::{mk_sp, respan, Span, Spanned, DUMMY_SP, ExpnId};\n+use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n+use codemap::{respan, Spanned};\n use abi::Abi;\n use errors;\n-use ext::base;\n-use ext::tt::macro_parser;\n use parse::token::{self, keywords, InternedString};\n-use parse::lexer;\n-use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use print::pprust;\n use ptr::P;\n+use tokenstream::{TokenTree};\n \n use std::fmt;\n use std::rc::Rc;\n-use std::borrow::Cow;\n use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -560,9 +557,6 @@ impl PartialEq for MetaItemKind {\n pub struct Block {\n     /// Statements in a block\n     pub stmts: Vec<Stmt>,\n-    /// An expression at the end of the block\n-    /// without a semicolon, if any\n-    pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n@@ -611,7 +605,6 @@ impl Pat {\n             PatKind::Range(_, _) |\n             PatKind::Ident(_, _, _) |\n             PatKind::Path(..) |\n-            PatKind::QPath(_, _) |\n             PatKind::Mac(_) => {\n                 true\n             }\n@@ -659,15 +652,11 @@ pub enum PatKind {\n     /// 0 <= position <= subpats.len()\n     TupleStruct(Path, Vec<P<Pat>>, Option<usize>),\n \n-    /// A path pattern.\n-    /// Such pattern can be resolved to a unit struct/variant or a constant.\n-    Path(Path),\n-\n-    /// An associated const named using the qualified path `<T>::CONST` or\n-    /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n-    /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatKind::Path, and the resolver will have to sort that out.\n-    QPath(QSelf, Path),\n+    /// A possibly qualified path pattern.\n+    /// Unquailfied path patterns `A::B::C` can legally refer to variants, structs, constants\n+    /// or associated constants. Quailfied path patterns `<A>::B::C`/`<A as Trait>::B::C` can\n+    /// only legally refer to associated constants.\n+    Path(Option<QSelf>, Path),\n \n     /// A tuple pattern `(a, b)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n@@ -818,45 +807,34 @@ impl UnOp {\n }\n \n /// A statement\n-pub type Stmt = Spanned<StmtKind>;\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+pub struct Stmt {\n+    pub id: NodeId,\n+    pub node: StmtKind,\n+    pub span: Span,\n+}\n \n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"stmt({}: {})\",\n-               self.node.id()\n-                   .map_or(Cow::Borrowed(\"<macro>\"),|id|Cow::Owned(id.to_string())),\n-               pprust::stmt_to_string(self))\n+        write!(f, \"stmt({}: {})\", self.id.to_string(), pprust::stmt_to_string(self))\n     }\n }\n \n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub enum StmtKind {\n-    /// Could be an item or a local (let) binding:\n-    Decl(P<Decl>, NodeId),\n+    /// A local (let) binding.\n+    Local(P<Local>),\n \n-    /// Expr without trailing semi-colon (must have unit type):\n-    Expr(P<Expr>, NodeId),\n+    /// An item definition.\n+    Item(P<Item>),\n \n-    /// Expr with trailing semi-colon (may have any type):\n-    Semi(P<Expr>, NodeId),\n+    /// Expr without trailing semi-colon.\n+    Expr(P<Expr>),\n \n-    Mac(P<Mac>, MacStmtStyle, ThinAttributes),\n-}\n-\n-impl StmtKind {\n-    pub fn id(&self) -> Option<NodeId> {\n-        match *self {\n-            StmtKind::Decl(_, id) => Some(id),\n-            StmtKind::Expr(_, id) => Some(id),\n-            StmtKind::Semi(_, id) => Some(id),\n-            StmtKind::Mac(..) => None,\n-        }\n-    }\n+    Semi(P<Expr>),\n \n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n+    Mac(P<(Mac, MacStmtStyle, ThinVec<Attribute>)>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -883,29 +861,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n-}\n-\n-impl Local {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n-}\n-\n-pub type Decl = Spanned<DeclKind>;\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum DeclKind {\n-    /// A local (let) binding:\n-    Local(P<Local>),\n-    /// An item binding:\n-    Item(P<Item>),\n-}\n-\n-impl Decl {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n+    pub attrs: ThinVec<Attribute>,\n }\n \n /// An arm of a 'match'.\n@@ -953,13 +909,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: ExprKind,\n     pub span: Span,\n-    pub attrs: ThinAttributes\n-}\n-\n-impl Expr {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n+    pub attrs: ThinVec<Attribute>\n }\n \n impl fmt::Debug for Expr {\n@@ -1082,7 +1032,7 @@ pub enum ExprKind {\n     /// A `break`, with an optional label to break\n     Break(Option<SpannedIdent>),\n     /// A `continue`, with an optional label\n-    Again(Option<SpannedIdent>),\n+    Continue(Option<SpannedIdent>),\n     /// A `return`, with an optional value to be returned\n     Ret(Option<P<Expr>>),\n \n@@ -1138,193 +1088,6 @@ pub enum CaptureBy {\n     Ref,\n }\n \n-/// A delimited sequence of token trees\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Delimited {\n-    /// The type of delimiter\n-    pub delim: token::DelimToken,\n-    /// The span covering the opening delimiter\n-    pub open_span: Span,\n-    /// The delimited sequence of token trees\n-    pub tts: Vec<TokenTree>,\n-    /// The span covering the closing delimiter\n-    pub close_span: Span,\n-}\n-\n-impl Delimited {\n-    /// Returns the opening delimiter as a token.\n-    pub fn open_token(&self) -> token::Token {\n-        token::OpenDelim(self.delim)\n-    }\n-\n-    /// Returns the closing delimiter as a token.\n-    pub fn close_token(&self) -> token::Token {\n-        token::CloseDelim(self.delim)\n-    }\n-\n-    /// Returns the opening delimiter as a token tree.\n-    pub fn open_tt(&self) -> TokenTree {\n-        TokenTree::Token(self.open_span, self.open_token())\n-    }\n-\n-    /// Returns the closing delimiter as a token tree.\n-    pub fn close_tt(&self) -> TokenTree {\n-        TokenTree::Token(self.close_span, self.close_token())\n-    }\n-}\n-\n-/// A sequence of token trees\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct SequenceRepetition {\n-    /// The sequence of token trees\n-    pub tts: Vec<TokenTree>,\n-    /// The optional separator\n-    pub separator: Option<token::Token>,\n-    /// Whether the sequence can be repeated zero (*), or one or more times (+)\n-    pub op: KleeneOp,\n-    /// The number of `MatchNt`s that appear in the sequence (and subsequences)\n-    pub num_captures: usize,\n-}\n-\n-/// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n-/// for token sequences.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum KleeneOp {\n-    ZeroOrMore,\n-    OneOrMore,\n-}\n-\n-/// When the main rust parser encounters a syntax-extension invocation, it\n-/// parses the arguments to the invocation as a token-tree. This is a very\n-/// loose structure, such that all sorts of different AST-fragments can\n-/// be passed to syntax extensions using a uniform type.\n-///\n-/// If the syntax extension is an MBE macro, it will attempt to match its\n-/// LHS token tree against the provided token tree, and if it finds a\n-/// match, will transcribe the RHS token tree, splicing in any captured\n-/// macro_parser::matched_nonterminals into the `SubstNt`s it finds.\n-///\n-/// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n-/// Nothing special happens to misnamed or misplaced `SubstNt`s.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TokenTree {\n-    /// A single token\n-    Token(Span, token::Token),\n-    /// A delimited sequence of token trees\n-    Delimited(Span, Rc<Delimited>),\n-\n-    // This only makes sense in MBE macros.\n-\n-    /// A kleene-style repetition sequence with a span\n-    // FIXME(eddyb) #12938 Use DST.\n-    Sequence(Span, Rc<SequenceRepetition>),\n-}\n-\n-impl TokenTree {\n-    pub fn len(&self) -> usize {\n-        match *self {\n-            TokenTree::Token(_, token::DocComment(name)) => {\n-                match doc_comment_style(&name.as_str()) {\n-                    AttrStyle::Outer => 2,\n-                    AttrStyle::Inner => 3\n-                }\n-            }\n-            TokenTree::Token(_, token::SpecialVarNt(..)) => 2,\n-            TokenTree::Token(_, token::MatchNt(..)) => 3,\n-            TokenTree::Delimited(_, ref delimed) => {\n-                delimed.tts.len() + 2\n-            }\n-            TokenTree::Sequence(_, ref seq) => {\n-                seq.tts.len()\n-            }\n-            TokenTree::Token(..) => 0\n-        }\n-    }\n-\n-    pub fn get_tt(&self, index: usize) -> TokenTree {\n-        match (self, index) {\n-            (&TokenTree::Token(sp, token::DocComment(_)), 0) => {\n-                TokenTree::Token(sp, token::Pound)\n-            }\n-            (&TokenTree::Token(sp, token::DocComment(name)), 1)\n-            if doc_comment_style(&name.as_str()) == AttrStyle::Inner => {\n-                TokenTree::Token(sp, token::Not)\n-            }\n-            (&TokenTree::Token(sp, token::DocComment(name)), _) => {\n-                let stripped = strip_doc_comment_decoration(&name.as_str());\n-\n-                // Searches for the occurrences of `\"#*` and returns the minimum number of `#`s\n-                // required to wrap the text.\n-                let num_of_hashes = stripped.chars().scan(0, |cnt, x| {\n-                    *cnt = if x == '\"' {\n-                        1\n-                    } else if *cnt != 0 && x == '#' {\n-                        *cnt + 1\n-                    } else {\n-                        0\n-                    };\n-                    Some(*cnt)\n-                }).max().unwrap_or(0);\n-\n-                TokenTree::Delimited(sp, Rc::new(Delimited {\n-                    delim: token::Bracket,\n-                    open_span: sp,\n-                    tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"))),\n-                              TokenTree::Token(sp, token::Eq),\n-                              TokenTree::Token(sp, token::Literal(\n-                                  token::StrRaw(token::intern(&stripped), num_of_hashes), None))],\n-                    close_span: sp,\n-                }))\n-            }\n-            (&TokenTree::Delimited(_, ref delimed), _) => {\n-                if index == 0 {\n-                    return delimed.open_tt();\n-                }\n-                if index == delimed.tts.len() + 1 {\n-                    return delimed.close_tt();\n-                }\n-                delimed.tts[index - 1].clone()\n-            }\n-            (&TokenTree::Token(sp, token::SpecialVarNt(var)), _) => {\n-                let v = [TokenTree::Token(sp, token::Dollar),\n-                         TokenTree::Token(sp, token::Ident(token::str_to_ident(var.as_str())))];\n-                v[index].clone()\n-            }\n-            (&TokenTree::Token(sp, token::MatchNt(name, kind)), _) => {\n-                let v = [TokenTree::Token(sp, token::SubstNt(name)),\n-                         TokenTree::Token(sp, token::Colon),\n-                         TokenTree::Token(sp, token::Ident(kind))];\n-                v[index].clone()\n-            }\n-            (&TokenTree::Sequence(_, ref seq), _) => {\n-                seq.tts[index].clone()\n-            }\n-            _ => panic!(\"Cannot expand a token tree\")\n-        }\n-    }\n-\n-    /// Returns the `Span` corresponding to this token tree.\n-    pub fn get_span(&self) -> Span {\n-        match *self {\n-            TokenTree::Token(span, _)     => span,\n-            TokenTree::Delimited(span, _) => span,\n-            TokenTree::Sequence(span, _)  => span,\n-        }\n-    }\n-\n-    /// Use this token tree as a matcher to parse given tts.\n-    pub fn parse(cx: &base::ExtCtxt, mtch: &[TokenTree], tts: &[TokenTree])\n-                 -> macro_parser::NamedParseResult {\n-        // `None` is because we're not interpolating\n-        let arg_rdr = lexer::new_tt_reader_with_doc_flag(&cx.parse_sess().span_diagnostic,\n-                                                         None,\n-                                                         None,\n-                                                         tts.iter().cloned().collect(),\n-                                                         true);\n-        macro_parser::parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtch)\n-    }\n-}\n-\n pub type Mac = Spanned<Mac_>;\n \n /// Represents a macro invocation. The Path indicates which macro\n@@ -1337,7 +1100,6 @@ pub type Mac = Spanned<Mac_>;\n pub struct Mac_ {\n     pub path: Path,\n     pub tts: Vec<TokenTree>,\n-    pub ctxt: SyntaxContext,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1430,6 +1192,7 @@ pub enum TraitItemKind {\n     Const(P<Ty>, Option<P<Expr>>),\n     Method(MethodSig, Option<P<Block>>),\n     Type(TyParamBounds, Option<P<Ty>>),\n+    Macro(Mac),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -2109,12 +1872,6 @@ pub struct Item {\n     pub span: Span,\n }\n \n-impl Item {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        &self.attrs\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ItemKind {\n     /// An`extern crate` item, with optional original crate name."}, {"sha": "da2967e306f6500c69aaaa5f4d221d6c26ec8e44", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 22, "deletions": 121, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,16 +16,16 @@ pub use self::IntType::*;\n \n use ast;\n use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaItemKind};\n-use ast::{Stmt, StmtKind, DeclKind};\n-use ast::{Expr, Item, Local, Decl};\n-use codemap::{Span, Spanned, spanned, dummy_spanned};\n-use codemap::BytePos;\n+use ast::{Expr, Item, Local, Stmt, StmtKind};\n+use codemap::{spanned, dummy_spanned, Spanned};\n+use syntax_pos::{Span, BytePos};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n use parse::{ParseSess, token};\n use ptr::P;\n+use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n use std::collections::HashSet;\n@@ -803,100 +803,11 @@ impl IntType {\n     }\n }\n \n-/// A list of attributes, behind a optional box as\n-/// a space optimization.\n-pub type ThinAttributes = Option<Box<Vec<Attribute>>>;\n-\n-pub trait ThinAttributesExt {\n-    fn map_thin_attrs<F>(self, f: F) -> Self\n-        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>;\n-    fn prepend(mut self, attrs: Self) -> Self;\n-    fn append(mut self, attrs: Self) -> Self;\n-    fn update<F>(&mut self, f: F)\n-        where Self: Sized,\n-              F: FnOnce(Self) -> Self;\n-    fn as_attr_slice(&self) -> &[Attribute];\n-    fn into_attr_vec(self) -> Vec<Attribute>;\n-}\n-\n-impl ThinAttributesExt for ThinAttributes {\n-    fn map_thin_attrs<F>(self, f: F) -> Self\n-        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>\n-    {\n-        f(self.map(|b| *b).unwrap_or(Vec::new())).into_thin_attrs()\n-    }\n-\n-    fn prepend(self, attrs: ThinAttributes) -> Self {\n-        attrs.map_thin_attrs(|mut attrs| {\n-            attrs.extend(self.into_attr_vec());\n-            attrs\n-        })\n-    }\n-\n-    fn append(self, attrs: ThinAttributes) -> Self {\n-        self.map_thin_attrs(|mut self_| {\n-            self_.extend(attrs.into_attr_vec());\n-            self_\n-        })\n-    }\n-\n-    fn update<F>(&mut self, f: F)\n-        where Self: Sized,\n-              F: FnOnce(ThinAttributes) -> ThinAttributes\n-    {\n-        let self_ = f(self.take());\n-        *self = self_;\n-    }\n-\n-    fn as_attr_slice(&self) -> &[Attribute] {\n-        match *self {\n-            Some(ref b) => b,\n-            None => &[],\n-        }\n-    }\n-\n-    fn into_attr_vec(self) -> Vec<Attribute> {\n-        match self {\n-            Some(b) => *b,\n-            None => Vec::new(),\n-        }\n-    }\n-}\n-\n-pub trait AttributesExt {\n-    fn into_thin_attrs(self) -> ThinAttributes;\n-}\n-\n-impl AttributesExt for Vec<Attribute> {\n-    fn into_thin_attrs(self) -> ThinAttributes {\n-        if self.len() == 0 {\n-            None\n-        } else {\n-            Some(Box::new(self))\n-        }\n-    }\n-}\n-\n pub trait HasAttrs: Sized {\n     fn attrs(&self) -> &[ast::Attribute];\n     fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;\n }\n \n-/// A cheap way to add Attributes to an AST node.\n-pub trait WithAttrs {\n-    // FIXME: Could be extended to anything IntoIter<Item=Attribute>\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self;\n-}\n-\n-impl<T: HasAttrs> WithAttrs for T {\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n-        self.map_attrs(|mut orig_attrs| {\n-            orig_attrs.extend(attrs.into_attr_vec());\n-            orig_attrs\n-        })\n-    }\n-}\n-\n impl HasAttrs for Vec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n         &self\n@@ -906,12 +817,12 @@ impl HasAttrs for Vec<Attribute> {\n     }\n }\n \n-impl HasAttrs for ThinAttributes {\n+impl HasAttrs for ThinVec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n-        self.as_attr_slice()\n+        &self\n     }\n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        self.map_thin_attrs(f)\n+        f(self.into()).into()\n     }\n }\n \n@@ -924,38 +835,28 @@ impl<T: HasAttrs + 'static> HasAttrs for P<T> {\n     }\n }\n \n-impl HasAttrs for DeclKind {\n-    fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            DeclKind::Local(ref local) => local.attrs(),\n-            DeclKind::Item(ref item) => item.attrs(),\n-        }\n-    }\n-\n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        match self {\n-            DeclKind::Local(local) => DeclKind::Local(local.map_attrs(f)),\n-            DeclKind::Item(item) => DeclKind::Item(item.map_attrs(f)),\n-        }\n-    }\n-}\n-\n impl HasAttrs for StmtKind {\n     fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            StmtKind::Decl(ref decl, _) => decl.attrs(),\n-            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => expr.attrs(),\n-            StmtKind::Mac(_, _, ref attrs) => attrs.attrs(),\n+            StmtKind::Local(ref local) => local.attrs(),\n+            StmtKind::Item(ref item) => item.attrs(),\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n+            StmtKind::Mac(ref mac) => {\n+                let (_, _, ref attrs) = **mac;\n+                attrs.attrs()\n+            }\n         }\n     }\n \n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         match self {\n-            StmtKind::Decl(decl, id) => StmtKind::Decl(decl.map_attrs(f), id),\n-            StmtKind::Expr(expr, id) => StmtKind::Expr(expr.map_attrs(f), id),\n-            StmtKind::Semi(expr, id) => StmtKind::Semi(expr.map_attrs(f), id),\n-            StmtKind::Mac(mac, style, attrs) =>\n-                StmtKind::Mac(mac, style, attrs.map_attrs(f)),\n+            StmtKind::Local(local) => StmtKind::Local(local.map_attrs(f)),\n+            StmtKind::Item(item) => StmtKind::Item(item.map_attrs(f)),\n+            StmtKind::Expr(expr) => StmtKind::Expr(expr.map_attrs(f)),\n+            StmtKind::Semi(expr) => StmtKind::Semi(expr.map_attrs(f)),\n+            StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, style, attrs)| {\n+                (mac, style, attrs.map_attrs(f))\n+            })),\n         }\n     }\n }\n@@ -982,4 +883,4 @@ derive_has_attrs_from_field! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm\n }\n \n-derive_has_attrs_from_field! { Decl: .node, Stmt: .node, ast::Variant: .node.attrs }\n+derive_has_attrs_from_field! { Stmt: .node, ast::Variant: .node.attrs }"}, {"sha": "743f96d737e2da8fe3a179befb42eacb40d3c0ae", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 864, "deletions": 655, "changes": 1519, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,269 +19,18 @@\n \n pub use self::ExpnFormat::*;\n \n-use std::cell::{Cell, RefCell};\n-use std::ops::{Add, Sub};\n+use std::cell::RefCell;\n use std::path::{Path,PathBuf};\n use std::rc::Rc;\n-use std::cmp;\n \n use std::env;\n-use std::{fmt, fs};\n+use std::fs;\n use std::io::{self, Read};\n-\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n+pub use syntax_pos::*;\n+use errors::CodeMapper;\n \n use ast::Name;\n \n-// _____________________________________________________________________________\n-// Pos, BytePos, CharPos\n-//\n-\n-pub trait Pos {\n-    fn from_usize(n: usize) -> Self;\n-    fn to_usize(&self) -> usize;\n-}\n-\n-/// A byte offset. Keep this small (currently 32-bits), as AST contains\n-/// a lot of them.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n-pub struct BytePos(pub u32);\n-\n-/// A character offset. Because of multibyte utf8 characters, a byte offset\n-/// is not equivalent to a character offset. The CodeMap will convert BytePos\n-/// values to CharPos values as necessary.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n-pub struct CharPos(pub usize);\n-\n-// FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n-// have been unsuccessful\n-\n-impl Pos for BytePos {\n-    fn from_usize(n: usize) -> BytePos { BytePos(n as u32) }\n-    fn to_usize(&self) -> usize { let BytePos(n) = *self; n as usize }\n-}\n-\n-impl Add for BytePos {\n-    type Output = BytePos;\n-\n-    fn add(self, rhs: BytePos) -> BytePos {\n-        BytePos((self.to_usize() + rhs.to_usize()) as u32)\n-    }\n-}\n-\n-impl Sub for BytePos {\n-    type Output = BytePos;\n-\n-    fn sub(self, rhs: BytePos) -> BytePos {\n-        BytePos((self.to_usize() - rhs.to_usize()) as u32)\n-    }\n-}\n-\n-impl Encodable for BytePos {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u32(self.0)\n-    }\n-}\n-\n-impl Decodable for BytePos {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<BytePos, D::Error> {\n-        Ok(BytePos(d.read_u32()?))\n-    }\n-}\n-\n-impl Pos for CharPos {\n-    fn from_usize(n: usize) -> CharPos { CharPos(n) }\n-    fn to_usize(&self) -> usize { let CharPos(n) = *self; n }\n-}\n-\n-impl Add for CharPos {\n-    type Output = CharPos;\n-\n-    fn add(self, rhs: CharPos) -> CharPos {\n-        CharPos(self.to_usize() + rhs.to_usize())\n-    }\n-}\n-\n-impl Sub for CharPos {\n-    type Output = CharPos;\n-\n-    fn sub(self, rhs: CharPos) -> CharPos {\n-        CharPos(self.to_usize() - rhs.to_usize())\n-    }\n-}\n-\n-// _____________________________________________________________________________\n-// Span, MultiSpan, Spanned\n-//\n-\n-/// Spans represent a region of code, used for error reporting. Positions in spans\n-/// are *absolute* positions from the beginning of the codemap, not positions\n-/// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n-/// to the original source.\n-/// You must be careful if the span crosses more than one file - you will not be\n-/// able to use many of the functions on spans in codemap and you cannot assume\n-/// that the length of the span = hi - lo; there may be space in the BytePos\n-/// range between files.\n-#[derive(Clone, Copy, Hash, PartialEq, Eq)]\n-pub struct Span {\n-    pub lo: BytePos,\n-    pub hi: BytePos,\n-    /// Information about where the macro came from, if this piece of\n-    /// code was created by a macro expansion.\n-    pub expn_id: ExpnId\n-}\n-\n-/// A collection of spans. Spans have two orthogonal attributes:\n-///\n-/// - they can be *primary spans*. In this case they are the locus of\n-///   the error, and would be rendered with `^^^`.\n-/// - they can have a *label*. In this case, the label is written next\n-///   to the mark in the snippet when we render.\n-#[derive(Clone)]\n-pub struct MultiSpan {\n-    primary_spans: Vec<Span>,\n-    span_labels: Vec<(Span, String)>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct SpanLabel {\n-    /// The span we are going to include in the final snippet.\n-    pub span: Span,\n-\n-    /// Is this a primary span? This is the \"locus\" of the message,\n-    /// and is indicated with a `^^^^` underline, versus `----`.\n-    pub is_primary: bool,\n-\n-    /// What label should we attach to this span (if any)?\n-    pub label: Option<String>,\n-}\n-\n-pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n-\n-// Generic span to be used for code originating from the command line\n-pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n-                                         hi: BytePos(0),\n-                                         expn_id: COMMAND_LINE_EXPN };\n-\n-impl Span {\n-    /// Returns a new span representing just the end-point of this span\n-    pub fn end_point(self) -> Span {\n-        let lo = cmp::max(self.hi.0 - 1, self.lo.0);\n-        Span { lo: BytePos(lo), hi: self.hi, expn_id: self.expn_id}\n-    }\n-\n-    /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n-    pub fn substitute_dummy(self, other: Span) -> Span {\n-        if self.source_equal(&DUMMY_SP) { other } else { self }\n-    }\n-\n-    pub fn contains(self, other: Span) -> bool {\n-        self.lo <= other.lo && other.hi <= self.hi\n-    }\n-\n-    /// Return true if the spans are equal with regards to the source text.\n-    ///\n-    /// Use this instead of `==` when either span could be generated code,\n-    /// and you only care that they point to the same bytes of source text.\n-    pub fn source_equal(&self, other: &Span) -> bool {\n-        self.lo == other.lo && self.hi == other.hi\n-    }\n-\n-    /// Returns `Some(span)`, a union of `self` and `other`, on overlap.\n-    pub fn merge(self, other: Span) -> Option<Span> {\n-        if self.expn_id != other.expn_id {\n-            return None;\n-        }\n-\n-        if (self.lo <= other.lo && self.hi > other.lo) ||\n-           (self.lo >= other.lo && self.lo < other.hi) {\n-            Some(Span {\n-                lo: cmp::min(self.lo, other.lo),\n-                hi: cmp::max(self.hi, other.hi),\n-                expn_id: self.expn_id,\n-            })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns `Some(span)`, where the start is trimmed by the end of `other`\n-    pub fn trim_start(self, other: Span) -> Option<Span> {\n-        if self.hi > other.hi {\n-            Some(Span { lo: cmp::max(self.lo, other.hi), .. self })\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub struct Spanned<T> {\n-    pub node: T,\n-    pub span: Span,\n-}\n-\n-impl Encodable for Span {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"Span\", 2, |s| {\n-            s.emit_struct_field(\"lo\", 0, |s| {\n-                self.lo.encode(s)\n-            })?;\n-\n-            s.emit_struct_field(\"hi\", 1, |s| {\n-                self.hi.encode(s)\n-            })\n-        })\n-    }\n-}\n-\n-impl Decodable for Span {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n-        d.read_struct(\"Span\", 2, |d| {\n-            let lo = d.read_struct_field(\"lo\", 0, |d| {\n-                BytePos::decode(d)\n-            })?;\n-\n-            let hi = d.read_struct_field(\"hi\", 1, |d| {\n-                BytePos::decode(d)\n-            })?;\n-\n-            Ok(mk_sp(lo, hi))\n-        })\n-    }\n-}\n-\n-fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n-    write!(f, \"Span {{ lo: {:?}, hi: {:?}, expn_id: {:?} }}\",\n-           span.lo, span.hi, span.expn_id)\n-}\n-\n-thread_local!(pub static SPAN_DEBUG: Cell<fn(Span, &mut fmt::Formatter) -> fmt::Result> =\n-                Cell::new(default_span_debug));\n-\n-impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        SPAN_DEBUG.with(|span_debug| span_debug.get()(*self, f))\n-    }\n-}\n-\n-pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> Spanned<T> {\n-    respan(mk_sp(lo, hi), t)\n-}\n-\n-pub fn respan<T>(sp: Span, t: T) -> Spanned<T> {\n-    Spanned {node: t, span: sp}\n-}\n-\n-pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n-    respan(DUMMY_SP, t)\n-}\n-\n-/* assuming that we're not in macro expansion */\n-pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span {lo: lo, hi: hi, expn_id: NO_EXPANSION}\n-}\n-\n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n@@ -295,123 +44,31 @@ pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n     }\n }\n \n-impl MultiSpan {\n-    pub fn new() -> MultiSpan {\n-        MultiSpan {\n-            primary_spans: vec![],\n-            span_labels: vec![]\n-        }\n-    }\n-\n-    pub fn from_span(primary_span: Span) -> MultiSpan {\n-        MultiSpan {\n-            primary_spans: vec![primary_span],\n-            span_labels: vec![]\n-        }\n-    }\n-\n-    pub fn from_spans(vec: Vec<Span>) -> MultiSpan {\n-        MultiSpan {\n-            primary_spans: vec,\n-            span_labels: vec![]\n-        }\n-    }\n-\n-    pub fn push_span_label(&mut self, span: Span, label: String) {\n-        self.span_labels.push((span, label));\n-    }\n-\n-    /// Selects the first primary span (if any)\n-    pub fn primary_span(&self) -> Option<Span> {\n-        self.primary_spans.first().cloned()\n-    }\n-\n-    /// Returns all primary spans.\n-    pub fn primary_spans(&self) -> &[Span] {\n-        &self.primary_spans\n-    }\n-\n-    /// Returns the strings to highlight. We always ensure that there\n-    /// is an entry for each of the primary spans -- for each primary\n-    /// span P, if there is at least one label with span P, we return\n-    /// those labels (marked as primary). But otherwise we return\n-    /// `SpanLabel` instances with empty labels.\n-    pub fn span_labels(&self) -> Vec<SpanLabel> {\n-        let is_primary = |span| self.primary_spans.contains(&span);\n-        let mut span_labels = vec![];\n-\n-        for &(span, ref label) in &self.span_labels {\n-            span_labels.push(SpanLabel {\n-                span: span,\n-                is_primary: is_primary(span),\n-                label: Some(label.clone())\n-            });\n-        }\n-\n-        for &span in &self.primary_spans {\n-            if !span_labels.iter().any(|sl| sl.span == span) {\n-                span_labels.push(SpanLabel {\n-                    span: span,\n-                    is_primary: true,\n-                    label: None\n-                });\n-            }\n-        }\n-\n-        span_labels\n-    }\n+/// The source of expansion.\n+#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n+pub enum ExpnFormat {\n+    /// e.g. #[derive(...)] <item>\n+    MacroAttribute(Name),\n+    /// e.g. `format!()`\n+    MacroBang(Name),\n }\n \n-impl From<Span> for MultiSpan {\n-    fn from(span: Span) -> MultiSpan {\n-        MultiSpan::from_span(span)\n-    }\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub struct Spanned<T> {\n+    pub node: T,\n+    pub span: Span,\n }\n \n-// _____________________________________________________________________________\n-// Loc, LocWithOpt, FileMapAndLine, FileMapAndBytePos\n-//\n-\n-/// A source code location used for error reporting\n-#[derive(Debug)]\n-pub struct Loc {\n-    /// Information about the original source\n-    pub file: Rc<FileMap>,\n-    /// The (1-based) line number\n-    pub line: usize,\n-    /// The (0-based) column offset\n-    pub col: CharPos\n+pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> Spanned<T> {\n+    respan(mk_sp(lo, hi), t)\n }\n \n-/// A source code location used as the result of lookup_char_pos_adj\n-// Actually, *none* of the clients use the filename *or* file field;\n-// perhaps they should just be removed.\n-#[derive(Debug)]\n-pub struct LocWithOpt {\n-    pub filename: FileName,\n-    pub line: usize,\n-    pub col: CharPos,\n-    pub file: Option<Rc<FileMap>>,\n+pub fn respan<T>(sp: Span, t: T) -> Spanned<T> {\n+    Spanned {node: t, span: sp}\n }\n \n-// used to be structural records. Better names, anyone?\n-#[derive(Debug)]\n-pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: usize }\n-#[derive(Debug)]\n-pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n-\n-\n-// _____________________________________________________________________________\n-// ExpnFormat, NameAndSpan, ExpnInfo, ExpnId\n-//\n-\n-/// The source of expansion.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n-pub enum ExpnFormat {\n-    /// e.g. #[derive(...)] <item>\n-    MacroAttribute(Name),\n-    /// e.g. `format!()`\n-    MacroBang(Name),\n+pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n+    respan(DUMMY_SP, t)\n }\n \n #[derive(Clone, Hash, Debug)]\n@@ -454,257 +111,10 @@ pub struct ExpnInfo {\n     pub callee: NameAndSpan\n }\n \n-#[derive(PartialEq, Eq, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Copy)]\n-pub struct ExpnId(u32);\n-\n-pub const NO_EXPANSION: ExpnId = ExpnId(!0);\n-// For code appearing from the command line\n-pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(!1);\n-\n-impl ExpnId {\n-    pub fn from_u32(id: u32) -> ExpnId {\n-        ExpnId(id)\n-    }\n-\n-    pub fn into_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n-\n // _____________________________________________________________________________\n // FileMap, MultiByteChar, FileName, FileLines\n //\n \n-pub type FileName = String;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct LineInfo {\n-    /// Index of line, starting from 0.\n-    pub line_index: usize,\n-\n-    /// Column in line where span begins, starting from 0.\n-    pub start_col: CharPos,\n-\n-    /// Column in line where span ends, starting from 0, exclusive.\n-    pub end_col: CharPos,\n-}\n-\n-pub struct FileLines {\n-    pub file: Rc<FileMap>,\n-    pub lines: Vec<LineInfo>\n-}\n-\n-/// Identifies an offset of a multi-byte character in a FileMap\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n-pub struct MultiByteChar {\n-    /// The absolute offset of the character in the CodeMap\n-    pub pos: BytePos,\n-    /// The number of bytes, >=2\n-    pub bytes: usize,\n-}\n-\n-/// A single source in the CodeMap.\n-pub struct FileMap {\n-    /// The name of the file that the source came from, source that doesn't\n-    /// originate from files has names between angle brackets by convention,\n-    /// e.g. `<anon>`\n-    pub name: FileName,\n-    /// The absolute path of the file that the source came from.\n-    pub abs_path: Option<FileName>,\n-    /// The complete source code\n-    pub src: Option<Rc<String>>,\n-    /// The start position of this source in the CodeMap\n-    pub start_pos: BytePos,\n-    /// The end position of this source in the CodeMap\n-    pub end_pos: BytePos,\n-    /// Locations of lines beginnings in the source code\n-    pub lines: RefCell<Vec<BytePos>>,\n-    /// Locations of multi-byte characters in the source code\n-    pub multibyte_chars: RefCell<Vec<MultiByteChar>>,\n-}\n-\n-impl Encodable for FileMap {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"FileMap\", 6, |s| {\n-            s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"abs_path\", 1, |s| self.abs_path.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", 2, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", 3, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", 4, |s| {\n-                let lines = self.lines.borrow();\n-                // store the length\n-                s.emit_u32(lines.len() as u32)?;\n-\n-                if !lines.is_empty() {\n-                    // In order to preserve some space, we exploit the fact that\n-                    // the lines list is sorted and individual lines are\n-                    // probably not that long. Because of that we can store lines\n-                    // as a difference list, using as little space as possible\n-                    // for the differences.\n-                    let max_line_length = if lines.len() == 1 {\n-                        0\n-                    } else {\n-                        lines.windows(2)\n-                             .map(|w| w[1] - w[0])\n-                             .map(|bp| bp.to_usize())\n-                             .max()\n-                             .unwrap()\n-                    };\n-\n-                    let bytes_per_diff: u8 = match max_line_length {\n-                        0 ... 0xFF => 1,\n-                        0x100 ... 0xFFFF => 2,\n-                        _ => 4\n-                    };\n-\n-                    // Encode the number of bytes used per diff.\n-                    bytes_per_diff.encode(s)?;\n-\n-                    // Encode the first element.\n-                    lines[0].encode(s)?;\n-\n-                    let diff_iter = (&lines[..]).windows(2)\n-                                                .map(|w| (w[1] - w[0]));\n-\n-                    match bytes_per_diff {\n-                        1 => for diff in diff_iter { (diff.0 as u8).encode(s)? },\n-                        2 => for diff in diff_iter { (diff.0 as u16).encode(s)? },\n-                        4 => for diff in diff_iter { diff.0.encode(s)? },\n-                        _ => unreachable!()\n-                    }\n-                }\n-\n-                Ok(())\n-            })?;\n-            s.emit_struct_field(\"multibyte_chars\", 5, |s| {\n-                (*self.multibyte_chars.borrow()).encode(s)\n-            })\n-        })\n-    }\n-}\n-\n-impl Decodable for FileMap {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<FileMap, D::Error> {\n-\n-        d.read_struct(\"FileMap\", 6, |d| {\n-            let name: String = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n-            let abs_path: Option<String> =\n-                d.read_struct_field(\"abs_path\", 1, |d| Decodable::decode(d))?;\n-            let start_pos: BytePos = d.read_struct_field(\"start_pos\", 2, |d| Decodable::decode(d))?;\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 3, |d| Decodable::decode(d))?;\n-            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 4, |d| {\n-                let num_lines: u32 = Decodable::decode(d)?;\n-                let mut lines = Vec::with_capacity(num_lines as usize);\n-\n-                if num_lines > 0 {\n-                    // Read the number of bytes used per diff.\n-                    let bytes_per_diff: u8 = Decodable::decode(d)?;\n-\n-                    // Read the first element.\n-                    let mut line_start: BytePos = Decodable::decode(d)?;\n-                    lines.push(line_start);\n-\n-                    for _ in 1..num_lines {\n-                        let diff = match bytes_per_diff {\n-                            1 => d.read_u8()? as u32,\n-                            2 => d.read_u16()? as u32,\n-                            4 => d.read_u32()?,\n-                            _ => unreachable!()\n-                        };\n-\n-                        line_start = line_start + BytePos(diff);\n-\n-                        lines.push(line_start);\n-                    }\n-                }\n-\n-                Ok(lines)\n-            })?;\n-            let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", 5, |d| Decodable::decode(d))?;\n-            Ok(FileMap {\n-                name: name,\n-                abs_path: abs_path,\n-                start_pos: start_pos,\n-                end_pos: end_pos,\n-                src: None,\n-                lines: RefCell::new(lines),\n-                multibyte_chars: RefCell::new(multibyte_chars)\n-            })\n-        })\n-    }\n-}\n-\n-impl fmt::Debug for FileMap {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"FileMap({})\", self.name)\n-    }\n-}\n-\n-impl FileMap {\n-    /// EFFECT: register a start-of-line offset in the\n-    /// table of line-beginnings.\n-    /// UNCHECKED INVARIANT: these offsets must be added in the right\n-    /// order and must be in the right places; there is shared knowledge\n-    /// about what ends a line between this file and parse.rs\n-    /// WARNING: pos param here is the offset relative to start of CodeMap,\n-    /// and CodeMap will append a newline when adding a filemap without a newline at the end,\n-    /// so the safe way to call this is with value calculated as\n-    /// filemap.start_pos + newline_offset_relative_to_the_start_of_filemap.\n-    pub fn next_line(&self, pos: BytePos) {\n-        // the new charpos must be > the last one (or it's the first one).\n-        let mut lines = self.lines.borrow_mut();\n-        let line_len = lines.len();\n-        assert!(line_len == 0 || ((*lines)[line_len - 1] < pos));\n-        lines.push(pos);\n-    }\n-\n-    /// get a line from the list of pre-computed line-beginnings.\n-    /// line-number here is 0-based.\n-    pub fn get_line(&self, line_number: usize) -> Option<&str> {\n-        match self.src {\n-            Some(ref src) => {\n-                let lines = self.lines.borrow();\n-                lines.get(line_number).map(|&line| {\n-                    let begin: BytePos = line - self.start_pos;\n-                    let begin = begin.to_usize();\n-                    // We can't use `lines.get(line_number+1)` because we might\n-                    // be parsing when we call this function and thus the current\n-                    // line is the last one we have line info for.\n-                    let slice = &src[begin..];\n-                    match slice.find('\\n') {\n-                        Some(e) => &slice[..e],\n-                        None => slice\n-                    }\n-                })\n-            }\n-            None => None\n-        }\n-    }\n-\n-    pub fn record_multibyte_char(&self, pos: BytePos, bytes: usize) {\n-        assert!(bytes >=2 && bytes <= 4);\n-        let mbc = MultiByteChar {\n-            pos: pos,\n-            bytes: bytes,\n-        };\n-        self.multibyte_chars.borrow_mut().push(mbc);\n-    }\n-\n-    pub fn is_real_file(&self) -> bool {\n-        !(self.name.starts_with(\"<\") &&\n-          self.name.ends_with(\">\"))\n-    }\n-\n-    pub fn is_imported(&self) -> bool {\n-        self.src.is_none()\n-    }\n-\n-    fn count_lines(&self) -> usize {\n-        self.lines.borrow().len()\n-    }\n-}\n-\n /// An abstraction over the fs operations used by the Parser.\n pub trait FileLoader {\n     /// Query the existence of a file.\n@@ -1392,59 +802,38 @@ impl CodeMap {\n     }\n }\n \n-pub struct MacroBacktrace {\n-    /// span where macro was applied to generate this code\n-    pub call_site: Span,\n-\n-    /// name of macro that was applied (e.g., \"foo!\" or \"#[derive(Eq)]\")\n-    pub macro_decl_name: String,\n-\n-    /// span where macro was defined (if known)\n-    pub def_site_span: Option<Span>,\n-}\n-\n-// _____________________________________________________________________________\n-// SpanLinesError, SpanSnippetError, DistinctSources, MalformedCodemapPositions\n-//\n-\n-pub type FileLinesResult = Result<FileLines, SpanLinesError>;\n-\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum SpanLinesError {\n-    IllFormedSpan(Span),\n-    DistinctSources(DistinctSources),\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum SpanSnippetError {\n-    IllFormedSpan(Span),\n-    DistinctSources(DistinctSources),\n-    MalformedForCodemap(MalformedCodemapPositions),\n-    SourceNotAvailable { filename: String }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct DistinctSources {\n-    begin: (String, BytePos),\n-    end: (String, BytePos)\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct MalformedCodemapPositions {\n-    name: String,\n-    source_len: usize,\n-    begin_pos: BytePos,\n-    end_pos: BytePos\n+impl CodeMapper for CodeMap {\n+    fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n+        self.lookup_char_pos(pos)\n+    }\n+    fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n+        self.span_to_lines(sp)\n+    }\n+    fn span_to_string(&self, sp: Span) -> String {\n+        self.span_to_string(sp)\n+    }\n+    fn span_to_filename(&self, sp: Span) -> FileName {\n+        self.span_to_filename(sp)\n+    }\n+    fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n+        self.macro_backtrace(span)\n+    }\n }\n \n-\n // _____________________________________________________________________________\n // Tests\n //\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use errors::{Level, CodeSuggestion};\n+    use errors::emitter::EmitterWriter;\n+    use errors::snippet::{SnippetData, RenderedLine, FormatMode};\n+    use std::sync::{Arc, Mutex};\n+    use std::io::{self, Write};\n+    use std::str::from_utf8;\n+    use std::rc::Rc;\n \n     #[test]\n     fn t1 () {\n@@ -1688,6 +1077,69 @@ mod tests {\n                     blork.rs:1:1: 1:12\\n  `first line.`\\n\");\n     }\n \n+    /// Returns the span corresponding to the `n`th occurrence of\n+    /// `substring` in `source_text`.\n+    trait CodeMapExtension {\n+        fn span_substr(&self,\n+                    file: &Rc<FileMap>,\n+                    source_text: &str,\n+                    substring: &str,\n+                    n: usize)\n+                    -> Span;\n+    }\n+\n+    impl CodeMapExtension for CodeMap {\n+        fn span_substr(&self,\n+                    file: &Rc<FileMap>,\n+                    source_text: &str,\n+                    substring: &str,\n+                    n: usize)\n+                    -> Span\n+        {\n+            println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n+                    file.name, file.start_pos, substring, n);\n+            let mut i = 0;\n+            let mut hi = 0;\n+            loop {\n+                let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n+                    panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n+                        source_text, n, substring, i);\n+                });\n+                let lo = hi + offset;\n+                hi = lo + substring.len();\n+                if i == n {\n+                    let span = Span {\n+                        lo: BytePos(lo as u32 + file.start_pos.0),\n+                        hi: BytePos(hi as u32 + file.start_pos.0),\n+                        expn_id: NO_EXPANSION,\n+                    };\n+                    assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n+                            substring);\n+                    return span;\n+                }\n+                i += 1;\n+            }\n+        }\n+    }\n+\n+    fn splice(start: Span, end: Span) -> Span {\n+        Span {\n+            lo: start.lo,\n+            hi: end.hi,\n+            expn_id: NO_EXPANSION,\n+        }\n+    }\n+\n+    fn make_string(lines: &[RenderedLine]) -> String {\n+        lines.iter()\n+            .flat_map(|rl| {\n+                rl.text.iter()\n+                        .map(|s| &s.text[..])\n+                        .chain(Some(\"\\n\"))\n+            })\n+            .collect()\n+    }\n+\n     fn init_expansion_chain(cm: &CodeMap) -> Span {\n         // Creates an expansion chain containing two recursive calls\n         // root -> expA -> expA -> expB -> expB -> end\n@@ -1767,4 +1219,761 @@ r\"blork2.rs:2:1: 2:12\n \";\n         assert_eq!(sstr, res_str);\n     }\n+\n+    struct Sink(Arc<Mutex<Vec<u8>>>);\n+    impl Write for Sink {\n+        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+            Write::write(&mut *self.0.lock().unwrap(), data)\n+        }\n+        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    }\n+\n+    // Diagnostic doesn't align properly in span where line number increases by one digit\n+    #[test]\n+    fn test_hilight_suggestion_issue_11715() {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())),\n+                                        None,\n+                                        cm.clone(),\n+                                        FormatMode::NewErrorFormat);\n+        let content = \"abcdefg\n+        koksi\n+        line3\n+        line4\n+        cinq\n+        line6\n+        line7\n+        line8\n+        line9\n+        line10\n+        e-l\u00e4-v\u00e4n\n+        tolv\n+        dreizehn\n+        \";\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, content);\n+        let start = file.lines.borrow()[10];\n+        let end = file.lines.borrow()[11];\n+        let sp = mk_sp(start, end);\n+        let lvl = Level::Error;\n+        println!(\"highlight_lines\");\n+        ew.highlight_lines(&sp.into(), lvl).unwrap();\n+        println!(\"done\");\n+        let vec = data.lock().unwrap().clone();\n+        let vec: &[u8] = &vec;\n+        let str = from_utf8(vec).unwrap();\n+        println!(\"r#\\\"\\n{}\\\"#\", str);\n+        assert_eq!(str, &r#\"\n+  --> dummy.txt:11:1\n+   |>\n+11 |>         e-l\u00e4-v\u00e4n\n+   |> ^\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn test_single_span_splice() {\n+        // Test that a `MultiSpan` containing a single span splices a substition correctly\n+        let cm = CodeMap::new();\n+        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        let sp = span_from_selection(inputtext, selection);\n+        let msp: MultiSpan = sp.into();\n+\n+        // check that we are extracting the text we thought we were extracting\n+        assert_eq!(&cm.span_to_snippet(sp).unwrap(), \"BB\\nCCC\\nDDDDD\");\n+\n+        let substitute = \"ZZZZZZ\".to_owned();\n+        let expected = \"bbbbZZZZZZddddd\";\n+        let suggest = CodeSuggestion {\n+            msp: msp,\n+            substitutes: vec![substitute],\n+        };\n+        assert_eq!(suggest.splice_lines(&cm), expected);\n+    }\n+\n+    #[test]\n+    fn test_multi_span_splice() {\n+        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n+        let cm = CodeMap::new();\n+        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n+        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        let sp1 = span_from_selection(inputtext, selection1);\n+        let sp2 = span_from_selection(inputtext, selection2);\n+        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n+\n+        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n+        let suggest = CodeSuggestion {\n+            msp: msp,\n+            substitutes: vec![\"ZZZZZZ\".to_owned(),\n+                              \"XYZ\".to_owned()]\n+        };\n+\n+        assert_eq!(suggest.splice_lines(&cm), expected);\n+    }\n+\n+    #[test]\n+    fn test_multispan_highlight() {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())),\n+                                          None,\n+                                          cm.clone(),\n+                                          FormatMode::NewErrorFormat);\n+\n+        let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n+        let sp1 =       \"     ~~~~~~                    \";\n+        let sp2 =       \"               ~~~~~~          \";\n+        let sp3 =       \"                       ~~~~~   \";\n+        let sp4 =       \"                          ~~~~ \";\n+        let sp34 =      \"                       ~~~~~~~ \";\n+\n+        let expect_start = &r#\"\n+ --> dummy.txt:1:6\n+  |>\n+1 |> _____aaaaaa____bbbbbb__cccccdd_\n+  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n+\"#[1..];\n+\n+        let span = |sp, expected| {\n+            let sp = span_from_selection(inp, sp);\n+            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n+            sp\n+        };\n+        cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n+        let sp1 = span(sp1, \"aaaaaa\");\n+        let sp2 = span(sp2, \"bbbbbb\");\n+        let sp3 = span(sp3, \"ccccc\");\n+        let sp4 = span(sp4, \"ccdd\");\n+        let sp34 = span(sp34, \"cccccdd\");\n+\n+        let spans = vec![sp1, sp2, sp3, sp4];\n+\n+        let test = |expected, highlight: &mut FnMut()| {\n+            data.lock().unwrap().clear();\n+            highlight();\n+            let vec = data.lock().unwrap().clone();\n+            let actual = from_utf8(&vec[..]).unwrap();\n+            println!(\"actual=\\n{}\", actual);\n+            assert_eq!(actual, expected);\n+        };\n+\n+        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n+        test(expect_start, &mut || {\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+        test(expect_start, &mut || {\n+            let msp = MultiSpan::from_spans(spans.clone());\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+    }\n+\n+    #[test]\n+    fn test_huge_multispan_highlight() {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())),\n+                                          None,\n+                                          cm.clone(),\n+                                          FormatMode::NewErrorFormat);\n+\n+        let inp = \"aaaaa\\n\\\n+                   aaaaa\\n\\\n+                   aaaaa\\n\\\n+                   bbbbb\\n\\\n+                   ccccc\\n\\\n+                   xxxxx\\n\\\n+                   yyyyy\\n\\\n+                   _____\\n\\\n+                   ddd__eee_\\n\\\n+                   elided\\n\\\n+                   __f_gg\";\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n+\n+        let span = |lo, hi, (off_lo, off_hi)| {\n+            let lines = file.lines.borrow();\n+            let (mut lo, mut hi): (BytePos, BytePos) = (lines[lo], lines[hi]);\n+            lo.0 += off_lo;\n+            hi.0 += off_hi;\n+            mk_sp(lo, hi)\n+        };\n+        let sp0 = span(4, 6, (0, 5));\n+        let sp1 = span(0, 6, (0, 5));\n+        let sp2 = span(8, 8, (0, 3));\n+        let sp3 = span(8, 8, (5, 8));\n+        let sp4 = span(10, 10, (2, 3));\n+        let sp5 = span(10, 10, (4, 6));\n+\n+        let expect0 = &r#\"\n+   --> dummy.txt:5:1\n+    |>\n+5   |> ccccc\n+    |> ^\n+...\n+9   |> ddd__eee_\n+    |> ^^^  ^^^\n+10  |> elided\n+11  |> __f_gg\n+    |>   ^ ^^\n+\"#[1..];\n+\n+        let expect = &r#\"\n+   --> dummy.txt:1:1\n+    |>\n+1   |> aaaaa\n+    |> ^\n+...\n+9   |> ddd__eee_\n+    |> ^^^  ^^^\n+10  |> elided\n+11  |> __f_gg\n+    |>   ^ ^^\n+\"#[1..];\n+\n+        macro_rules! test {\n+            ($expected: expr, $highlight: expr) => ({\n+                data.lock().unwrap().clear();\n+                $highlight();\n+                let vec = data.lock().unwrap().clone();\n+                let actual = from_utf8(&vec[..]).unwrap();\n+                println!(\"actual:\");\n+                println!(\"{}\", actual);\n+                println!(\"expected:\");\n+                println!(\"{}\", $expected);\n+                assert_eq!(&actual[..], &$expected[..]);\n+            });\n+        }\n+\n+        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n+        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n+\n+        test!(expect0, || {\n+            diag.highlight_lines(&msp0, Level::Error).unwrap();\n+        });\n+        test!(expect, || {\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+    }\n+\n+    #[test]\n+    fn tab() {\n+        let file_text = \"\n+fn foo() {\n+\\tbar;\n+}\n+\";\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n+\n+        let mut snippet = SnippetData::new(cm, Some(span_bar), FormatMode::NewErrorFormat);\n+        snippet.push(span_bar, true, None);\n+\n+        let lines = snippet.render_lines();\n+        let text = make_string(&lines);\n+        assert_eq!(&text[..], &\"\n+ --> foo.rs:3:2\n+  |>\n+3 |> \\tbar;\n+  |> \\t^^^\n+\"[1..]);\n+    }\n+\n+    #[test]\n+    fn one_line() {\n+        let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n+        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=\\n{}\", text);\n+        assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn two_files() {\n+        let file_text_foo = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let file_text_bar = r#\"\n+fn bar() {\n+    // these blank links here\n+    // serve to ensure that the line numbers\n+    // from bar.rs\n+    // require more digits\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    vec.push();\n+\n+    // this line will get elided\n+\n+    vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n+        let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n+        let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n+        let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n+\n+        let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n+        let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n+        let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n+        let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n+\n+        let mut snippet = SnippetData::new(cm, Some(span_foo_vec1), FormatMode::NewErrorFormat);\n+        snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n+        snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n+        snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n+        snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n+        snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n+        snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=\\n{}\", text);\n+\n+        // Note that the `|>` remain aligned across both files:\n+        assert_eq!(&text[..], &r#\"\n+   --> foo.rs:3:14\n+    |>\n+3   |>     vec.push(vec.pop().unwrap());\n+    |>     ---      ^^^                - c\n+    |>     |        |\n+    |>     |        b\n+    |>     a\n+   ::: bar.rs\n+    |>\n+17  |>     vec.push();\n+    |>     ---       - f\n+    |>     |\n+    |>     d\n+...\n+21  |>     vec.pop().unwrap());\n+    |>     --- e\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn multi_line() {\n+        let file_text = r#\"\n+fn foo() {\n+    let name = find_id(&data, 22).unwrap();\n+\n+    // Add one more item we forgot to the vector. Silly us.\n+    data.push(Data { name: format!(\"Hera\"), id: 66 });\n+\n+    // Print everything out.\n+    println!(\"Name: {:?}\", name);\n+    println!(\"Data: {:?}\", data);\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n+        let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n+        let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n+\n+        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n+        snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n+        snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n+        snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=\\n{}\", text);\n+        assert_eq!(&text[..], &r#\"\n+   ::: foo.rs\n+    |>\n+3   |>     let name = find_id(&data, 22).unwrap();\n+    |>                         ---- immutable borrow begins here\n+...\n+6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n+    |>     ---- mutable borrow occurs here\n+...\n+11  |> }\n+    |> - immutable borrow ends here\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn overlapping() {\n+        let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n+        let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+        let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n+        let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n+\n+        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n+        snippet.push(span0, false, Some(format!(\"A\")));\n+        snippet.push(span1, false, Some(format!(\"B\")));\n+        snippet.push(span2, false, Some(format!(\"C\")));\n+        snippet.push(span3, false, Some(format!(\"D\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+        assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     --------           ------ D\n+  |>     ||\n+  |>     |C\n+  |>     A\n+  |>     B\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn one_line_out_of_order() {\n+        let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+        // intentionally don't push the snippets left to right\n+        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n+        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+        assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn elide_unnecessary_lines() {\n+        let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n+        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n+\n+        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n+        snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n+            has type `collections::vec::Vec<i32>`\")));\n+        snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+        let text: String = make_string(&lines);\n+        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+        assert_eq!(&text[..], &r#\"\n+   ::: foo.rs\n+    |>\n+4   |>     let mut vec2 = vec;\n+    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n+...\n+9   |>     vec.push(7);\n+    |>     --- use of moved value: `vec`\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn spans_without_labels() {\n+        let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n+        for i in 0..4 {\n+            let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n+            snippet.push(span_veci, false, None);\n+        }\n+\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     let mut vec = vec![0, 1, 2];\n+  |>             ---   ---\n+4 |>     let mut vec2 = vec;\n+  |>             ---    ---\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_long_selection() {\n+        let file_text = r#\"\n+impl SomeTrait for () {\n+    fn foo(x: u32) {\n+        // impl 1\n+        // impl 2\n+        // impl 3\n+    }\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n+        let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n+        let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+        snippet.push(splice(fn_span, rbrace_span), false, None);\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     fn foo(x: u32) {\n+  |>     -\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_overlap_label() {\n+        // Test that we don't put `x_span` to the right of its highlight,\n+        // since there is another highlight that overlaps it.\n+\n+        let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n+        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n+        let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n+        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+        snippet.push(x_span, false, Some(format!(\"x_span\")));\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_overlap_label2() {\n+        // Test that we don't put `x_span` to the right of its highlight,\n+        // since there is another highlight that overlaps it. In this\n+        // case, the overlap is only at the beginning, but it's still\n+        // better to show the beginning more clearly.\n+\n+        let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n+        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n+        let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n+        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+        snippet.push(x_span, false, Some(format!(\"x_span\")));\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_overlap_label3() {\n+        // Test that we don't put `x_span` to the right of its highlight,\n+        // since there is another highlight that overlaps it. In this\n+        // case, the overlap is only at the beginning, but it's still\n+        // better to show the beginning more clearly.\n+\n+        let file_text = r#\"\n+    fn foo() {\n+       let closure = || {\n+           inner\n+       };\n+    }\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n+\n+        let closure_span = {\n+            let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n+            let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+            splice(closure_start_span, closure_end_span)\n+        };\n+\n+        let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n+\n+        snippet.push(closure_span, false, Some(format!(\"foo\")));\n+        snippet.push(inner_span, false, Some(format!(\"bar\")));\n+\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>        let closure = || {\n+  |>                      - foo\n+4 |>            inner\n+  |>            ----- bar\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_empty() {\n+        // In one of the unit tests, we found that the parser sometimes\n+        // gives empty spans, and in particular it supplied an EOF span\n+        // like this one, which points at the very end. We want to\n+        // fallback gracefully in this case.\n+\n+        let file_text = r#\"\n+fn main() {\n+    struct Foo;\n+\n+    impl !Sync for Foo {}\n+\n+    unsafe impl Send for &'static Foo {\n+    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n+    //        can only be implemented for a struct/enum type, not\n+    //        `&'static Foo`\n+}\"#;\n+\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n+        rbrace_span.lo = rbrace_span.hi;\n+\n+        let mut snippet = SnippetData::new(cm.clone(),\n+                                           Some(rbrace_span),\n+                                           FormatMode::NewErrorFormat);\n+        snippet.push(rbrace_span, false, None);\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+  --> foo.rs:11:2\n+   |>\n+11 |> }\n+   |>  -\n+\"#[1..]);\n+    }\n }"}, {"sha": "961763c6025fd8d84828165452961ac9488d8093", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -11,7 +11,8 @@\n use attr::{AttrMetaMethods, HasAttrs};\n use feature_gate::{emit_feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use fold::Folder;\n-use {ast, fold, attr};\n+use {fold, attr};\n+use ast;\n use codemap::{Spanned, respan};\n use parse::{ParseSess, token};\n use ptr::P;\n@@ -212,17 +213,10 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        let is_item = match stmt.node {\n-            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n-                ast::DeclKind::Item(_) => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        };\n-\n         // avoid calling `visit_stmt_or_expr_attrs` on items\n-        if !is_item {\n-            self.visit_stmt_or_expr_attrs(stmt.attrs());\n+        match stmt.node {\n+            ast::StmtKind::Item(_) => {}\n+            _ => self.visit_stmt_or_expr_attrs(stmt.attrs()),\n         }\n \n         self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))"}, {"sha": "5bbd18bd9ee2e02f64af3b2f15f3ea092af48dbc", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -20,7 +20,7 @@ use std::io::Write;\n use std::error::Error;\n use rustc_serialize::json::as_json;\n \n-use codemap::Span;\n+use syntax_pos::Span;\n use ext::base::ExtCtxt;\n use diagnostics::plugin::{ErrorMap, ErrorInfo};\n "}, {"sha": "4e50299e836b3b71ef58be94ef9175bb342dc868", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,16 +13,19 @@ use std::collections::BTreeMap;\n use std::env;\n \n use ast;\n-use ast::{Ident, Name, TokenTree};\n-use codemap::Span;\n+use ast::{Ident, Name};\n+use syntax_pos::Span;\n use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n use parse::token;\n use ptr::P;\n+use tokenstream::{TokenTree};\n use util::small_vector::SmallVector;\n \n use diagnostics::metadata::output_metadata;\n \n+pub use errors::*;\n+\n // Maximum width of any line in an extended error description (inclusive).\n const MAX_DESCRIPTION_WIDTH: usize = 80;\n "}, {"sha": "79e40a091659e106381ec3eacfcd84bdc38a4152", "filename": "src/libsyntax/errors/snippet/test.rs", "status": "removed", "additions": 0, "deletions": 597, "changes": 597, "blob_url": "https://github.com/rust-lang/rust/blob/8eb56e698814c5a626b9c935162ff8487bca0774/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb56e698814c5a626b9c935162ff8487bca0774/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs?ref=8eb56e698814c5a626b9c935162ff8487bca0774", "patch": "@@ -1,597 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Code for testing annotated snippets.\n-\n-#![cfg(test)]\n-\n-use codemap::{BytePos, CodeMap, FileMap, NO_EXPANSION, Span};\n-use std::rc::Rc;\n-use super::{RenderedLine, SnippetData};\n-\n-/// Returns the span corresponding to the `n`th occurrence of\n-/// `substring` in `source_text`.\n-trait CodeMapExtension {\n-    fn span_substr(&self,\n-                   file: &Rc<FileMap>,\n-                   source_text: &str,\n-                   substring: &str,\n-                   n: usize)\n-                   -> Span;\n-}\n-\n-impl CodeMapExtension for CodeMap {\n-    fn span_substr(&self,\n-                   file: &Rc<FileMap>,\n-                   source_text: &str,\n-                   substring: &str,\n-                   n: usize)\n-                   -> Span\n-    {\n-        println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n-                 file.name, file.start_pos, substring, n);\n-        let mut i = 0;\n-        let mut hi = 0;\n-        loop {\n-            let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n-                panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n-                       source_text, n, substring, i);\n-            });\n-            let lo = hi + offset;\n-            hi = lo + substring.len();\n-            if i == n {\n-                let span = Span {\n-                    lo: BytePos(lo as u32 + file.start_pos.0),\n-                    hi: BytePos(hi as u32 + file.start_pos.0),\n-                    expn_id: NO_EXPANSION,\n-                };\n-                assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n-                           substring);\n-                return span;\n-            }\n-            i += 1;\n-        }\n-    }\n-}\n-\n-fn splice(start: Span, end: Span) -> Span {\n-    Span {\n-        lo: start.lo,\n-        hi: end.hi,\n-        expn_id: NO_EXPANSION,\n-    }\n-}\n-\n-fn make_string(lines: &[RenderedLine]) -> String {\n-    lines.iter()\n-         .flat_map(|rl| {\n-             rl.text.iter()\n-                    .map(|s| &s.text[..])\n-                    .chain(Some(\"\\n\"))\n-         })\n-         .collect()\n-}\n-\n-#[test]\n-fn tab() {\n-    let file_text = \"\n-fn foo() {\n-\\tbar;\n-}\n-\";\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, Some(span_bar));\n-    snippet.push(span_bar, true, None);\n-\n-    let lines = snippet.render_lines();\n-    let text = make_string(&lines);\n-    assert_eq!(&text[..], &\"\n- --> foo.rs:3:2\n-  |>\n-3 |> \\tbar;\n-  |> \\t^^^\n-\"[1..]);\n-}\n-\n-#[test]\n-fn one_line() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn two_files() {\n-    let file_text_foo = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let file_text_bar = r#\"\n-fn bar() {\n-    // these blank links here\n-    // serve to ensure that the line numbers\n-    // from bar.rs\n-    // require more digits\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-    vec.push();\n-\n-    // this line will get elided\n-\n-    vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n-    let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n-    let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n-    let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n-\n-    let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n-    let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n-    let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n-    let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, Some(span_foo_vec1));\n-    snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n-    snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n-    snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n-    snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n-    snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n-    snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-\n-    // Note that the `|>` remain aligned across both files:\n-    assert_eq!(&text[..], &r#\"\n-   --> foo.rs:3:14\n-    |>\n-3   |>     vec.push(vec.pop().unwrap());\n-    |>     ---      ^^^                - c\n-    |>     |        |\n-    |>     |        b\n-    |>     a\n-   ::: bar.rs\n-    |>\n-17  |>     vec.push();\n-    |>     ---       - f\n-    |>     |\n-    |>     d\n-...\n-21  |>     vec.pop().unwrap());\n-    |>     --- e\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn multi_line() {\n-    let file_text = r#\"\n-fn foo() {\n-    let name = find_id(&data, 22).unwrap();\n-\n-    // Add one more item we forgot to the vector. Silly us.\n-    data.push(Data { name: format!(\"Hera\"), id: 66 });\n-\n-    // Print everything out.\n-    println!(\"Name: {:?}\", name);\n-    println!(\"Data: {:?}\", data);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n-    let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n-    let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n-    snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n-    snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-    assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-3   |>     let name = find_id(&data, 22).unwrap();\n-    |>                         ---- immutable borrow begins here\n-...\n-6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n-    |>     ---- mutable borrow occurs here\n-...\n-11  |> }\n-    |> - immutable borrow ends here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn overlapping() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n-    let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n-    let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span0, false, Some(format!(\"A\")));\n-    snippet.push(span1, false, Some(format!(\"B\")));\n-    snippet.push(span2, false, Some(format!(\"C\")));\n-    snippet.push(span3, false, Some(format!(\"D\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     --------           ------ D\n-  |>     ||\n-  |>     |C\n-  |>     A\n-  |>     B\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn one_line_out_of_order() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-    // intentionally don't push the snippets left to right\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn elide_unnecessary_lines() {\n-    let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n-        has type `collections::vec::Vec<i32>`\")));\n-    snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-4   |>     let mut vec2 = vec;\n-    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n-...\n-9   |>     vec.push(7);\n-    |>     --- use of moved value: `vec`\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn spans_without_labels() {\n-    let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    for i in 0..4 {\n-        let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n-        snippet.push(span_veci, false, None);\n-    }\n-\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     let mut vec = vec![0, 1, 2];\n-  |>             ---   ---\n-4 |>     let mut vec2 = vec;\n-  |>             ---    ---\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_long_selection() {\n-    let file_text = r#\"\n-impl SomeTrait for () {\n-    fn foo(x: u32) {\n-        // impl 1\n-        // impl 2\n-        // impl 3\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n-    let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-    snippet.push(splice(fn_span, rbrace_span), false, None);\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     fn foo(x: u32) {\n-  |>     -\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it.\n-\n-    let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n-    let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n-    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-    snippet.push(x_span, false, Some(format!(\"x_span\")));\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label2() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it. In this\n-    // case, the overlap is only at the beginning, but it's still\n-    // better to show the beginning more clearly.\n-\n-    let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n-    let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n-    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-    snippet.push(x_span, false, Some(format!(\"x_span\")));\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label3() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it. In this\n-    // case, the overlap is only at the beginning, but it's still\n-    // better to show the beginning more clearly.\n-\n-    let file_text = r#\"\n-    fn foo() {\n-       let closure = || {\n-           inner\n-       };\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-\n-    let closure_span = {\n-        let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n-        let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-        splice(closure_start_span, closure_end_span)\n-    };\n-\n-    let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n-\n-    snippet.push(closure_span, false, Some(format!(\"foo\")));\n-    snippet.push(inner_span, false, Some(format!(\"bar\")));\n-\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>        let closure = || {\n-  |>                      - foo\n-4 |>            inner\n-  |>            ----- bar\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_empty() {\n-    // In one of the unit tests, we found that the parser sometimes\n-    // gives empty spans, and in particular it supplied an EOF span\n-    // like this one, which points at the very end. We want to\n-    // fallback gracefully in this case.\n-\n-    let file_text = r#\"\n-fn main() {\n-    struct Foo;\n-\n-    impl !Sync for Foo {}\n-\n-    unsafe impl Send for &'static Foo {\n-    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n-    //        can only be implemented for a struct/enum type, not\n-    //        `&'static Foo`\n-}\"#;\n-\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n-    rbrace_span.lo = rbrace_span.hi;\n-\n-    let mut snippet = SnippetData::new(cm.clone(), Some(rbrace_span));\n-    snippet.push(rbrace_span, false, None);\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n-  --> foo.rs:11:2\n-   |>\n-11 |> }\n-   |>  -\n-\"#[1..]);\n-}"}, {"sha": "757b039fcac8a658b535631d79c1a2c5a5bf9d50", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,8 +13,8 @@ pub use self::SyntaxExtension::*;\n use ast;\n use ast::{Name, PatKind};\n use attr::HasAttrs;\n-use codemap;\n-use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n+use codemap::{self, CodeMap, ExpnInfo};\n+use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n use ext;\n use ext::expand;\n@@ -32,6 +32,7 @@ use fold::Folder;\n use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n use std::default::Default;\n+use tokenstream;\n \n \n #[derive(Debug,Clone)]\n@@ -168,20 +169,22 @@ pub trait TTMacroExpander {\n     fn expand<'cx>(&self,\n                    ecx: &'cx mut ExtCtxt,\n                    span: Span,\n-                   token_tree: &[ast::TokenTree])\n+                   token_tree: &[tokenstream::TokenTree])\n                    -> Box<MacResult+'cx>;\n }\n \n pub type MacroExpanderFn =\n-    for<'cx> fn(&'cx mut ExtCtxt, Span, &[ast::TokenTree]) -> Box<MacResult+'cx>;\n+    for<'cx> fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree])\n+                -> Box<MacResult+'cx>;\n \n impl<F> TTMacroExpander for F\n-    where F : for<'cx> Fn(&'cx mut ExtCtxt, Span, &[ast::TokenTree]) -> Box<MacResult+'cx>\n+    where F : for<'cx> Fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree])\n+                          -> Box<MacResult+'cx>\n {\n     fn expand<'cx>(&self,\n                    ecx: &'cx mut ExtCtxt,\n                    span: Span,\n-                   token_tree: &[ast::TokenTree])\n+                   token_tree: &[tokenstream::TokenTree])\n                    -> Box<MacResult+'cx> {\n         (*self)(ecx, span, token_tree)\n     }\n@@ -192,22 +195,23 @@ pub trait IdentMacroExpander {\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n-                   token_tree: Vec<ast::TokenTree> )\n+                   token_tree: Vec<tokenstream::TokenTree> )\n                    -> Box<MacResult+'cx>;\n }\n \n pub type IdentMacroExpanderFn =\n-    for<'cx> fn(&'cx mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree>) -> Box<MacResult+'cx>;\n+    for<'cx> fn(&'cx mut ExtCtxt, Span, ast::Ident, Vec<tokenstream::TokenTree>)\n+                -> Box<MacResult+'cx>;\n \n impl<F> IdentMacroExpander for F\n     where F : for<'cx> Fn(&'cx mut ExtCtxt, Span, ast::Ident,\n-                          Vec<ast::TokenTree>) -> Box<MacResult+'cx>\n+                          Vec<tokenstream::TokenTree>) -> Box<MacResult+'cx>\n {\n     fn expand<'cx>(&self,\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n-                   token_tree: Vec<ast::TokenTree> )\n+                   token_tree: Vec<tokenstream::TokenTree> )\n                    -> Box<MacResult+'cx>\n     {\n         (*self)(cx, sp, ident, token_tree)\n@@ -217,10 +221,11 @@ impl<F> IdentMacroExpander for F\n // Use a macro because forwarding to a simple function has type system issues\n macro_rules! make_stmts_default {\n     ($me:expr) => {\n-        $me.make_expr().map(|e| {\n-            SmallVector::one(codemap::respan(\n-                e.span, ast::StmtKind::Expr(e, ast::DUMMY_NODE_ID)))\n-        })\n+        $me.make_expr().map(|e| SmallVector::one(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: e.span,\n+            node: ast::StmtKind::Expr(e),\n+        }))\n     }\n }\n \n@@ -241,6 +246,11 @@ pub trait MacResult {\n         None\n     }\n \n+    /// Create zero or more trait items.\n+    fn make_trait_items(self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n+        None\n+    }\n+\n     /// Create a pattern.\n     fn make_pat(self: Box<Self>) -> Option<P<ast::Pat>> {\n         None\n@@ -288,6 +298,7 @@ make_MacEager! {\n     pat: P<ast::Pat>,\n     items: SmallVector<P<ast::Item>>,\n     impl_items: SmallVector<ast::ImplItem>,\n+    trait_items: SmallVector<ast::TraitItem>,\n     stmts: SmallVector<ast::Stmt>,\n     ty: P<ast::Ty>,\n }\n@@ -305,6 +316,10 @@ impl MacResult for MacEager {\n         self.impl_items\n     }\n \n+    fn make_trait_items(self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n+        self.trait_items\n+    }\n+\n     fn make_stmts(self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n         match self.stmts.as_ref().map_or(0, |s| s.len()) {\n             0 => make_stmts_default!(self),\n@@ -365,7 +380,7 @@ impl DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ExprKind::Lit(P(codemap::respan(sp, ast::LitKind::Bool(false)))),\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         })\n     }\n \n@@ -413,11 +428,20 @@ impl MacResult for DummyResult {\n         }\n     }\n \n+    fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVector<ast::TraitItem>> {\n+        if self.expr_only {\n+            None\n+        } else {\n+            Some(SmallVector::zero())\n+        }\n+    }\n+\n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<ast::Stmt>> {\n-        Some(SmallVector::one(\n-            codemap::respan(self.span,\n-                            ast::StmtKind::Expr(DummyResult::raw_expr(self.span),\n-                                                ast::DUMMY_NODE_ID))))\n+        Some(SmallVector::one(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Expr(DummyResult::raw_expr(self.span)),\n+            span: self.span,\n+        }))\n     }\n }\n \n@@ -612,7 +636,7 @@ impl<'a> ExtCtxt<'a> {\n         expand::MacroExpander::new(self)\n     }\n \n-    pub fn new_parser_from_tts(&self, tts: &[ast::TokenTree])\n+    pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree])\n         -> parser::Parser<'a> {\n         parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg())\n     }\n@@ -811,7 +835,7 @@ pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n /// done as rarely as possible).\n pub fn check_zero_tts(cx: &ExtCtxt,\n                       sp: Span,\n-                      tts: &[ast::TokenTree],\n+                      tts: &[tokenstream::TokenTree],\n                       name: &str) {\n     if !tts.is_empty() {\n         cx.span_err(sp, &format!(\"{} takes no arguments\", name));\n@@ -822,7 +846,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n /// is not a string literal, emit an error and return None.\n pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n                                sp: Span,\n-                               tts: &[ast::TokenTree],\n+                               tts: &[tokenstream::TokenTree],\n                                name: &str)\n                                -> Option<String> {\n     let mut p = cx.new_parser_from_tts(tts);\n@@ -843,7 +867,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n /// parsing error, emit a non-fatal error and return None.\n pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::TokenTree]) -> Option<Vec<P<ast::Expr>>> {\n+                          tts: &[tokenstream::TokenTree]) -> Option<Vec<P<ast::Expr>>> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {"}, {"sha": "435241f426ec6f4329e90a2dc6dea8c093e3e723", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 52, "deletions": 38, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -11,7 +11,8 @@\n use abi::Abi;\n use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n-use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n+use syntax_pos::{Span, DUMMY_SP, Pos};\n+use codemap::{respan, Spanned};\n use ext::base::ExtCtxt;\n use parse::token::{self, keywords, InternedString};\n use ptr::P;\n@@ -87,6 +88,7 @@ pub trait AstBuilder {\n \n     // statements\n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;\n+    fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n@@ -98,12 +100,8 @@ pub trait AstBuilder {\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n-             expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n-    fn block_all(&self, span: Span,\n-                 stmts: Vec<ast::Stmt>,\n-                 expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n     fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;\n@@ -508,7 +506,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        respan(expr.span, ast::StmtKind::Semi(expr, ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: expr.span,\n+            node: ast::StmtKind::Expr(expr),\n+        }\n+    }\n+\n+    fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt {\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: expr.span,\n+            node: ast::StmtKind::Semi(expr),\n+        }\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n@@ -525,10 +535,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         });\n-        let decl = respan(sp, ast::DeclKind::Local(local));\n-        respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: sp,\n+        }\n     }\n \n     fn stmt_let_typed(&self,\n@@ -550,44 +563,45 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         });\n-        let decl = respan(sp, ast::DeclKind::Local(local));\n-        P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n-    }\n-\n-    fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n-             expr: Option<P<Expr>>) -> P<ast::Block> {\n-        self.block_all(span, stmts, expr)\n+        P(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: sp,\n+        })\n     }\n \n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n-        let decl = respan(sp, ast::DeclKind::Item(item));\n-        respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Item(item),\n+            span: sp,\n+        }\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n-        self.block_all(expr.span, Vec::new(), Some(expr))\n-    }\n-    fn block_all(&self,\n-                 span: Span,\n-                 stmts: Vec<ast::Stmt>,\n-                 expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n-            P(ast::Block {\n-               stmts: stmts,\n-               expr: expr,\n-               id: ast::DUMMY_NODE_ID,\n-               rules: BlockCheckMode::Default,\n-               span: span,\n-            })\n+        self.block(expr.span, vec![ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: expr.span,\n+            node: ast::StmtKind::Expr(expr),\n+        }])\n+    }\n+    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n+        P(ast::Block {\n+           stmts: stmts,\n+           id: ast::DUMMY_NODE_ID,\n+           rules: BlockCheckMode::Default,\n+           span: span,\n+        })\n     }\n \n     fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         })\n     }\n \n@@ -830,7 +844,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n     fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         let pat = if subpats.is_empty() {\n-            PatKind::Path(path)\n+            PatKind::Path(None, path)\n         } else {\n             PatKind::TupleStruct(path, subpats, None)\n         };\n@@ -948,14 +962,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     ids: Vec<ast::Ident>,\n                     stmts: Vec<ast::Stmt>)\n                     -> P<ast::Expr> {\n-        self.lambda(span, ids, self.block(span, stmts, None))\n+        self.lambda(span, ids, self.block(span, stmts))\n     }\n     fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n-        self.lambda0(span, self.block(span, stmts, None))\n+        self.lambda0(span, self.block(span, stmts))\n     }\n     fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda1(span, self.block(span, stmts, None), ident)\n+        self.lambda1(span, self.block(span, stmts), ident)\n     }\n \n     fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {"}, {"sha": "3036a88430a2be6e82360049b2f121f745d15f91", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 122, "deletions": 148, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, DeclKind, PatKind};\n+use ast::{Block, Crate, PatKind};\n use ast::{Local, Ident, Mac_, Name, SpannedIdent};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n-use ast::TokenTree;\n use ast;\n use attr::HasAttrs;\n use ext::mtwt;\n-use ext::build::AstBuilder;\n use attr;\n-use attr::{AttrMetaMethods, WithAttrs, ThinAttributesExt};\n-use codemap;\n-use codemap::{Span, Spanned, ExpnInfo, ExpnId, NameAndSpan, MacroBang, MacroAttribute};\n+use attr::AttrMetaMethods;\n+use codemap::{Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n use ext::base::*;\n use feature_gate::{self, Features};\n@@ -28,6 +26,7 @@ use fold::*;\n use util::move_map::MoveMap;\n use parse::token::{fresh_mark, fresh_name, intern, keywords};\n use ptr::P;\n+use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n@@ -42,7 +41,7 @@ trait MacroGenerable: Sized {\n \n     // Fold this node or list of nodes using the given folder.\n     fn fold_with<F: Folder>(self, folder: &mut F) -> Self;\n-    fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V);\n+    fn visit_with<V: Visitor>(&self, visitor: &mut V);\n \n     // Return a placeholder expansion to allow compilation to continue after an erroring expansion.\n     fn dummy(span: Span) -> Self;\n@@ -63,7 +62,7 @@ macro_rules! impl_macro_generable {\n                 $( folder.$fold(self) )*\n                 $( self.into_iter().flat_map(|item| folder. $fold_elt (item)).collect() )*\n             }\n-            fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V) {\n+            fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n                 $( visitor.$visit(self) )*\n                 $( for item in self.as_slice() { visitor. $visit_elt (item) } )*\n             }\n@@ -81,8 +80,11 @@ impl_macro_generable! {\n         \"statement\",  .make_stmts, lift .fold_stmt, lift .visit_stmt, |_span| SmallVector::zero();\n     SmallVector<P<ast::Item>>:\n         \"item\",       .make_items, lift .fold_item, lift .visit_item, |_span| SmallVector::zero();\n+    SmallVector<ast::TraitItem>:\n+        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item,\n+        |_span| SmallVector::zero();\n     SmallVector<ast::ImplItem>:\n-        \"impl item\",  .make_impl_items, lift .fold_impl_item, lift .visit_impl_item,\n+        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item,\n         |_span| SmallVector::zero();\n }\n \n@@ -95,24 +97,23 @@ impl MacroGenerable for Option<P<ast::Expr>> {\n     fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n         self.and_then(|expr| folder.fold_opt_expr(expr))\n     }\n-    fn visit_with<'v, V: Visitor<'v>>(&'v self, visitor: &mut V) {\n+    fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n         self.as_ref().map(|expr| visitor.visit_expr(expr));\n     }\n }\n \n-pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n+pub fn expand_expr(mut expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n     match expr.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n-            expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, fld)\n+            return expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, fld);\n         }\n \n         ast::ExprKind::While(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(expr.span, ast::ExprKind::While(cond, body, opt_ident))\n-                .with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::While(cond, body, opt_ident);\n         }\n \n         ast::ExprKind::WhileLet(pat, cond, body, opt_ident) => {\n@@ -129,14 +130,12 @@ pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n             });\n             assert!(rewritten_pats.len() == 1);\n \n-            let wl = ast::ExprKind::WhileLet(rewritten_pats.remove(0), cond, body, opt_ident);\n-            fld.cx.expr(expr.span, wl).with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::WhileLet(rewritten_pats.remove(0), cond, body, opt_ident);\n         }\n \n         ast::ExprKind::Loop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            fld.cx.expr(expr.span, ast::ExprKind::Loop(loop_block, opt_ident))\n-                .with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::Loop(loop_block, opt_ident);\n         }\n \n         ast::ExprKind::ForLoop(pat, head, body, opt_ident) => {\n@@ -153,8 +152,7 @@ pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n             assert!(rewritten_pats.len() == 1);\n \n             let head = fld.fold_expr(head);\n-            let fl = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n-            fld.cx.expr(expr.span, fl).with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n         }\n \n         ast::ExprKind::IfLet(pat, sub_expr, body, else_opt) => {\n@@ -172,25 +170,21 @@ pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n             let sub_expr = fld.fold_expr(sub_expr);\n-            let il = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n-            fld.cx.expr(expr.span, il).with_attrs(fold_thin_attrs(expr.attrs, fld))\n+            expr.node = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n         }\n \n         ast::ExprKind::Closure(capture_clause, fn_decl, block, fn_decl_span) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            let new_node = ast::ExprKind::Closure(capture_clause,\n-                                                  rewritten_fn_decl,\n-                                                  rewritten_block,\n-                                                  fn_decl_span);\n-            P(ast::Expr{ id: expr.id,\n-                         node: new_node,\n-                         span: expr.span,\n-                         attrs: fold_thin_attrs(expr.attrs, fld) })\n+            expr.node = ast::ExprKind::Closure(capture_clause,\n+                                               rewritten_fn_decl,\n+                                               rewritten_block,\n+                                               fn_decl_span);\n         }\n \n-        _ => P(noop_fold_expr(expr, fld)),\n-    }\n+        _ => expr = noop_fold_expr(expr, fld),\n+    };\n+    P(expr)\n }\n \n /// Expand a macro invocation. Returns the result of expansion.\n@@ -249,7 +243,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     },\n                 });\n \n-                let marked_tts = mark_tts(&tts[..], mark);\n+                let marked_tts = mark_tts(tts, mark);\n                 Some(expandfun.expand(fld.cx, call_site, &marked_tts))\n             }\n \n@@ -269,7 +263,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     }\n                 });\n \n-                let marked_tts = mark_tts(&tts, mark);\n+                let marked_tts = mark_tts(tts, mark);\n                 Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n             }\n \n@@ -445,25 +439,25 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     };\n \n     let (mac, style, attrs) = match stmt.node {\n-        StmtKind::Mac(mac, style, attrs) => (mac, style, attrs),\n+        StmtKind::Mac(mac) => mac.unwrap(),\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n-        expand_mac_invoc(mac.unwrap(), None, attrs.into_attr_vec(), stmt.span, fld);\n+        expand_mac_invoc(mac, None, attrs.into(), stmt.span, fld);\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n     if style == MacStmtStyle::Semicolon {\n         if let Some(stmt) = fully_expanded.pop() {\n-            let new_stmt = Spanned {\n+            fully_expanded.push(Stmt {\n+                id: stmt.id,\n                 node: match stmt.node {\n-                    StmtKind::Expr(e, stmt_id) => StmtKind::Semi(e, stmt_id),\n+                    StmtKind::Expr(expr) => StmtKind::Semi(expr),\n                     _ => stmt.node /* might already have a semi */\n                 },\n-                span: stmt.span\n-            };\n-            fully_expanded.push(new_stmt);\n+                span: stmt.span,\n+            });\n         }\n     }\n \n@@ -472,73 +466,53 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroExpander)\n+fn expand_non_macro_stmt(stmt: Stmt, fld: &mut MacroExpander)\n                          -> SmallVector<Stmt> {\n     // is it a let?\n-    match node {\n-        StmtKind::Decl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n-            DeclKind::Local(local) => {\n-                // take it apart:\n-                let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n-                    // expand the ty since TyKind::FixedLengthVec contains an Expr\n-                    // and thus may have a macro use\n-                    let expanded_ty = ty.map(|t| fld.fold_ty(t));\n-                    // expand the pat (it might contain macro uses):\n-                    let expanded_pat = fld.fold_pat(pat);\n-                    // find the PatIdents in the pattern:\n-                    // oh dear heaven... this is going to include the enum\n-                    // names, as well... but that should be okay, as long as\n-                    // the new names are gensyms for the old ones.\n-                    // generate fresh names, push them to a new pending list\n-                    let idents = pattern_bindings(&expanded_pat);\n-                    let mut new_pending_renames =\n-                        idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n-                    // rewrite the pattern using the new names (the old\n-                    // ones have already been applied):\n-                    let rewritten_pat = {\n-                        // nested binding to allow borrow to expire:\n-                        let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n-                        rename_fld.fold_pat(expanded_pat)\n-                    };\n-                    // add them to the existing pending renames:\n-                    fld.cx.syntax_env.info().pending_renames\n-                          .extend(new_pending_renames);\n-                    Local {\n-                        id: id,\n-                        ty: expanded_ty,\n-                        pat: rewritten_pat,\n-                        // also, don't forget to expand the init:\n-                        init: init.map(|e| fld.fold_expr(e)),\n-                        span: span,\n-                        attrs: fold::fold_thin_attrs(attrs, fld),\n-                    }\n-                });\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Decl(P(Spanned {\n-                            node: DeclKind::Local(rewritten_local),\n-                            span: span\n-                        }),\n-                        node_id),\n-                    span: stmt_span\n-                })\n-            }\n-            _ => {\n-                noop_fold_stmt(Spanned {\n-                    node: StmtKind::Decl(P(Spanned {\n-                            node: decl,\n-                            span: span\n-                        }),\n-                        node_id),\n-                    span: stmt_span\n-                }, fld)\n-            }\n-        }),\n-        _ => {\n-            noop_fold_stmt(Spanned {\n-                node: node,\n-                span: stmt_span\n-            }, fld)\n+    match stmt.node {\n+        StmtKind::Local(local) => {\n+            // take it apart:\n+            let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n+                // expand the ty since TyKind::FixedLengthVec contains an Expr\n+                // and thus may have a macro use\n+                let expanded_ty = ty.map(|t| fld.fold_ty(t));\n+                // expand the pat (it might contain macro uses):\n+                let expanded_pat = fld.fold_pat(pat);\n+                // find the PatIdents in the pattern:\n+                // oh dear heaven... this is going to include the enum\n+                // names, as well... but that should be okay, as long as\n+                // the new names are gensyms for the old ones.\n+                // generate fresh names, push them to a new pending list\n+                let idents = pattern_bindings(&expanded_pat);\n+                let mut new_pending_renames =\n+                    idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n+                // rewrite the pattern using the new names (the old\n+                // ones have already been applied):\n+                let rewritten_pat = {\n+                    // nested binding to allow borrow to expire:\n+                    let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n+                    rename_fld.fold_pat(expanded_pat)\n+                };\n+                // add them to the existing pending renames:\n+                fld.cx.syntax_env.info().pending_renames\n+                      .extend(new_pending_renames);\n+                Local {\n+                    id: id,\n+                    ty: expanded_ty,\n+                    pat: rewritten_pat,\n+                    // also, don't forget to expand the init:\n+                    init: init.map(|e| fld.fold_expr(e)),\n+                    span: span,\n+                    attrs: fold::fold_thin_attrs(attrs, fld),\n+                }\n+            });\n+            SmallVector::one(Stmt {\n+                id: stmt.id,\n+                node: StmtKind::Local(rewritten_local),\n+                span: stmt.span,\n+            })\n         }\n+        _ => noop_fold_stmt(stmt, fld),\n     }\n }\n \n@@ -596,7 +570,7 @@ struct PatIdentFinder {\n     ident_accumulator: Vec<ast::Ident>\n }\n \n-impl<'v> Visitor<'v> for PatIdentFinder {\n+impl Visitor for PatIdentFinder {\n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         match *pattern {\n             ast::Pat { id: _, node: PatKind::Ident(_, ref path1, ref inner), span: _ } => {\n@@ -637,23 +611,14 @@ pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n \n // expand the elements of a block.\n pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, stmts, expr, rules, span}| {\n+    b.map(|Block {id, stmts, rules, span}| {\n         let new_stmts = stmts.into_iter().flat_map(|x| {\n             // perform pending renames and expand macros in the statement\n             fld.fold_stmt(x).into_iter()\n         }).collect();\n-        let new_expr = expr.map(|x| {\n-            let expr = {\n-                let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n-                let mut rename_fld = IdentRenamer{renames:pending_renames};\n-                rename_fld.fold_expr(x)\n-            };\n-            fld.fold_expr(expr)\n-        });\n         Block {\n             id: fld.new_id(id),\n             stmts: new_stmts,\n-            expr: new_expr,\n             rules: rules,\n             span: span\n         }\n@@ -754,25 +719,10 @@ fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector\n             _ => noop_fold_item(it, fld),\n         }.into_iter().map(|i| Annotatable::Item(i)).collect(),\n \n-        Annotatable::TraitItem(it) => match it.node {\n-            ast::TraitItemKind::Method(_, Some(_)) => {\n-                let ti = it.unwrap();\n-                SmallVector::one(ast::TraitItem {\n-                    id: ti.id,\n-                    ident: ti.ident,\n-                    attrs: ti.attrs,\n-                    node: match ti.node  {\n-                        ast::TraitItemKind::Method(sig, Some(body)) => {\n-                            let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                            ast::TraitItemKind::Method(sig, Some(body))\n-                        }\n-                        _ => unreachable!()\n-                    },\n-                    span: ti.span,\n-                })\n-            }\n-            _ => fold::noop_fold_trait_item(it.unwrap(), fld)\n-        }.into_iter().map(|ti| Annotatable::TraitItem(P(ti))).collect(),\n+        Annotatable::TraitItem(it) => {\n+            expand_trait_item(it.unwrap(), fld).into_iter().\n+                map(|it| Annotatable::TraitItem(P(it))).collect()\n+        }\n \n         Annotatable::ImplItem(ii) => {\n             expand_impl_item(ii.unwrap(), fld).into_iter().\n@@ -900,6 +850,31 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n     }\n }\n \n+fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n+                     -> SmallVector<ast::TraitItem> {\n+    match ti.node {\n+        ast::TraitItemKind::Method(_, Some(_)) => {\n+            SmallVector::one(ast::TraitItem {\n+                id: ti.id,\n+                ident: ti.ident,\n+                attrs: ti.attrs,\n+                node: match ti.node  {\n+                    ast::TraitItemKind::Method(sig, Some(body)) => {\n+                        let (sig, body) = expand_and_rename_method(sig, body, fld);\n+                        ast::TraitItemKind::Method(sig, Some(body))\n+                    }\n+                    _ => unreachable!()\n+                },\n+                span: ti.span,\n+            })\n+        }\n+        ast::TraitItemKind::Macro(mac) => {\n+            expand_mac_invoc(mac, None, ti.attrs, ti.span, fld)\n+        }\n+        _ => fold::noop_fold_trait_item(ti, fld)\n+    }\n+}\n+\n /// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n /// PatIdents in its arguments to perform renaming in the FnDecl and\n /// the block, returning both the new FnDecl and the new Block.\n@@ -980,9 +955,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             at_crate_root: bool,\n         }\n \n-        impl<'a, 'b, 'v> Visitor<'v> for MacroLoadingVisitor<'a, 'b> {\n-            fn visit_mac(&mut self, _: &'v ast::Mac) {}\n-            fn visit_item(&mut self, item: &'v ast::Item) {\n+        impl<'a, 'b> Visitor for MacroLoadingVisitor<'a, 'b> {\n+            fn visit_mac(&mut self, _: &ast::Mac) {}\n+            fn visit_item(&mut self, item: &ast::Item) {\n                 if let ast::ItemKind::ExternCrate(..) = item.node {\n                     // We need to error on `#[macro_use] extern crate` when it isn't at the\n                     // crate root, because `$crate` won't work properly.\n@@ -995,7 +970,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.at_crate_root = at_crate_root;\n                 }\n             }\n-            fn visit_block(&mut self, block: &'v ast::Block) {\n+            fn visit_block(&mut self, block: &ast::Block) {\n                 let at_crate_root = ::std::mem::replace(&mut self.at_crate_root, false);\n                 visit::walk_block(self, block);\n                 self.at_crate_root = at_crate_root;\n@@ -1022,7 +997,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         expr.and_then(|expr| match expr.node {\n             ast::ExprKind::Mac(mac) =>\n-                expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, self),\n+                expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, self),\n             _ => Some(expand_expr(expr, self)),\n         })\n     }\n@@ -1040,7 +1015,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n                 result = expand_item(item, self);\n                 self.pop_mod_path();\n             } else {\n-                let filename = if inner != codemap::DUMMY_SP {\n+                let filename = if inner != syntax_pos::DUMMY_SP {\n                     Some(self.cx.parse_sess.codemap().span_to_filename(inner))\n                 } else { None };\n                 let orig_filename = replace(&mut self.cx.filename, filename);\n@@ -1202,8 +1177,7 @@ impl Folder for Marker {\n         Spanned {\n             node: Mac_ {\n                 path: self.fold_path(node.path),\n-                tts: self.fold_tts(&node.tts),\n-                ctxt: mtwt::apply_mark(self.mark, node.ctxt),\n+                tts: self.fold_tts(node.tts),\n             },\n             span: self.new_span(span),\n         }\n@@ -1218,7 +1192,7 @@ impl Folder for Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n+fn mark_tts(tts: Vec<TokenTree>, m: Mrk) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n \n@@ -1229,7 +1203,7 @@ mod tests {\n     use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer, ExpansionConfig};\n     use ast;\n     use ast::Name;\n-    use codemap;\n+    use syntax_pos;\n     use ext::base::{ExtCtxt, DummyMacroLoader};\n     use ext::mtwt;\n     use fold::Folder;\n@@ -1248,7 +1222,7 @@ mod tests {\n         path_accumulator: Vec<ast::Path> ,\n     }\n \n-    impl<'v> Visitor<'v> for PathExprFinderContext {\n+    impl Visitor for PathExprFinderContext {\n         fn visit_expr(&mut self, expr: &ast::Expr) {\n             if let ast::ExprKind::Path(None, ref p) = expr.node {\n                 self.path_accumulator.push(p.clone());\n@@ -1270,8 +1244,8 @@ mod tests {\n         ident_accumulator: Vec<ast::Ident>\n     }\n \n-    impl<'v> Visitor<'v> for IdentFinder {\n-        fn visit_ident(&mut self, _: codemap::Span, id: ast::Ident){\n+    impl Visitor for IdentFinder {\n+        fn visit_ident(&mut self, _: syntax_pos::Span, id: ast::Ident){\n             self.ident_accumulator.push(id);\n         }\n     }"}, {"sha": "68527b0797d5b6031da5ca6dcc4a2d9eb2c24341", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{self, Arg, Arm, Block, Expr, Item, Pat, Stmt, TokenTree, Ty};\n-use codemap::Span;\n+use ast::{self, Arg, Arm, Block, Expr, Item, Pat, Stmt, Ty};\n+use syntax_pos::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n use ext::build::AstBuilder;\n use parse::parser::{Parser, PathStyle};\n use parse::token::*;\n use parse::token;\n use ptr::P;\n+use tokenstream::{self, TokenTree};\n \n /// Quasiquoting works via token trees.\n ///\n@@ -31,12 +32,12 @@ pub mod rt {\n     use ext::base::ExtCtxt;\n     use parse::{self, token, classify};\n     use ptr::P;\n-    use std::rc::Rc;\n \n-    use ast::TokenTree;\n+    use tokenstream::{self, TokenTree};\n \n     pub use parse::new_parser_from_tts;\n-    pub use codemap::{BytePos, Span, dummy_spanned, DUMMY_SP};\n+    pub use syntax_pos::{BytePos, Span, DUMMY_SP};\n+    pub use codemap::{dummy_spanned};\n \n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree>;\n@@ -214,12 +215,12 @@ pub mod rt {\n             if self.node.style == ast::AttrStyle::Inner {\n                 r.push(TokenTree::Token(self.span, token::Not));\n             }\n-            r.push(TokenTree::Delimited(self.span, Rc::new(ast::Delimited {\n+            r.push(TokenTree::Delimited(self.span, tokenstream::Delimited {\n                 delim: token::Bracket,\n                 open_span: self.span,\n                 tts: self.node.value.to_tokens(cx),\n                 close_span: self.span,\n-            })));\n+            }));\n             r\n         }\n     }\n@@ -234,12 +235,12 @@ pub mod rt {\n \n     impl ToTokens for () {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Delimited(DUMMY_SP, Rc::new(ast::Delimited {\n+            vec![TokenTree::Delimited(DUMMY_SP, tokenstream::Delimited {\n                 delim: token::Paren,\n                 open_span: DUMMY_SP,\n                 tts: vec![],\n                 close_span: DUMMY_SP,\n-            }))]\n+            })]\n         }\n     }\n \n@@ -250,7 +251,7 @@ pub mod rt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprKind::Lit(P(self.clone())),\n                 span: DUMMY_SP,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             }).to_tokens(cx)\n         }\n     }\n@@ -281,7 +282,7 @@ pub mod rt {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Lit(P(dummy_spanned(lit))),\n                         span: DUMMY_SP,\n-                        attrs: None,\n+                        attrs: ast::ThinVec::new(),\n                     });\n                     if *self >= 0 {\n                         return lit.to_tokens(cx);\n@@ -290,7 +291,7 @@ pub mod rt {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Unary(ast::UnOp::Neg, lit),\n                         span: DUMMY_SP,\n-                        attrs: None,\n+                        attrs: ast::ThinVec::new(),\n                     }).to_tokens(cx)\n                 }\n             }\n@@ -512,10 +513,8 @@ pub fn expand_quote_matcher(cx: &mut ExtCtxt,\n     let (cx_expr, tts) = parse_arguments_to_quote(cx, tts);\n     let mut vector = mk_stmts_let(cx, sp);\n     vector.extend(statements_mk_tts(cx, &tts[..], true));\n-    let block = cx.expr_block(\n-        cx.block_all(sp,\n-                     vector,\n-                     Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+    vector.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+    let block = cx.expr_block(cx.block(sp, vector));\n \n     let expanded = expand_wrapper(cx, sp, cx_expr, block, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]]);\n     base::MacEager::expr(expanded)\n@@ -548,7 +547,7 @@ fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n }\n \n fn mk_tt_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n-    let idents = vec!(id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(\"TokenTree\"), id_ext(name));\n+    let idents = vec!(id_ext(\"syntax\"), id_ext(\"tokenstream\"), id_ext(\"TokenTree\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n@@ -765,19 +764,20 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stm\n             let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n             let mut tts_stmts = vec![stmt_let_tt];\n             tts_stmts.extend(statements_mk_tts(cx, &seq.tts[..], matcher));\n-            let e_tts = cx.expr_block(cx.block(sp, tts_stmts,\n-                                                   Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+            tts_stmts.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+            let e_tts = cx.expr_block(cx.block(sp, tts_stmts));\n+\n             let e_separator = match seq.separator {\n                 Some(ref sep) => cx.expr_some(sp, expr_mk_token(cx, sp, sep)),\n                 None => cx.expr_none(sp),\n             };\n             let e_op = match seq.op {\n-                ast::KleeneOp::ZeroOrMore => \"ZeroOrMore\",\n-                ast::KleeneOp::OneOrMore => \"OneOrMore\",\n+                tokenstream::KleeneOp::ZeroOrMore => \"ZeroOrMore\",\n+                tokenstream::KleeneOp::OneOrMore => \"OneOrMore\",\n             };\n             let e_op_idents = vec![\n                 id_ext(\"syntax\"),\n-                id_ext(\"ast\"),\n+                id_ext(\"tokenstream\"),\n                 id_ext(\"KleeneOp\"),\n                 id_ext(e_op),\n             ];\n@@ -787,16 +787,13 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stm\n                               cx.field_imm(sp, id_ext(\"op\"), e_op),\n                               cx.field_imm(sp, id_ext(\"num_captures\"),\n                                                cx.expr_usize(sp, seq.num_captures))];\n-            let seq_path = vec![id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(\"SequenceRepetition\")];\n+            let seq_path = vec![id_ext(\"syntax\"),\n+                                id_ext(\"tokenstream\"),\n+                                id_ext(\"SequenceRepetition\")];\n             let e_seq_struct = cx.expr_struct(sp, cx.path_global(sp, seq_path), fields);\n-            let e_rc_new = cx.expr_call_global(sp, vec![id_ext(\"std\"),\n-                                                        id_ext(\"rc\"),\n-                                                        id_ext(\"Rc\"),\n-                                                        id_ext(\"new\")],\n-                                                   vec![e_seq_struct]);\n             let e_tok = cx.expr_call(sp,\n                                      mk_tt_path(cx, sp, \"Sequence\"),\n-                                     vec!(e_sp, e_rc_new));\n+                                     vec!(e_sp, e_seq_struct));\n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n@@ -884,10 +881,8 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[TokenTree])\n \n     let mut vector = mk_stmts_let(cx, sp);\n     vector.extend(statements_mk_tts(cx, &tts[..], false));\n-    let block = cx.expr_block(\n-        cx.block_all(sp,\n-                     vector,\n-                     Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+    vector.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+    let block = cx.expr_block(cx.block(sp, vector));\n \n     (cx_expr, block)\n }\n@@ -901,13 +896,14 @@ fn expand_wrapper(cx: &ExtCtxt,\n     let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n \n-    let stmts = imports.iter().map(|path| {\n+    let mut stmts = imports.iter().map(|path| {\n         // make item: `use ...;`\n         let path = path.iter().map(|s| s.to_string()).collect();\n         cx.stmt_item(sp, cx.item_use_glob(sp, ast::Visibility::Inherited, ids_ext(path)))\n-    }).chain(Some(stmt_let_ext_cx)).collect();\n+    }).chain(Some(stmt_let_ext_cx)).collect::<Vec<_>>();\n+    stmts.push(cx.stmt_expr(expr));\n \n-    cx.expr_block(cx.block_all(sp, stmts, Some(expr)))\n+    cx.expr_block(cx.block(sp, stmts))\n }\n \n fn expand_parse_call(cx: &ExtCtxt,"}, {"sha": "97cb09991ec40b953901517cf1726d163aaa39e1", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use ast;\n-use codemap::{Pos, Span};\n-use codemap;\n+use syntax_pos::{self, Pos, Span};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse::token;\n use parse;\n use print::pprust;\n use ptr::P;\n+use tokenstream;\n use util::small_vector::SmallVector;\n \n use std::fs::File;\n@@ -30,7 +30,7 @@ use std::rc::Rc;\n // a given file into the current one.\n \n /// line!(): expands to the current line number\n-pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -41,7 +41,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n /* column!(): expands to the current column number */\n-pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n@@ -54,7 +54,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n /// file!(): expands to the current filename */\n /// The filemap (`loc.file`) contains a bunch more information we could spit\n /// out if we wanted.\n-pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -64,14 +64,14 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     base::MacEager::expr(cx.expr_str(topmost, filename))\n }\n \n-pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacEager::expr(cx.expr_str(sp,\n                                    token::intern_and_get_ident(&s[..])))\n }\n \n-pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n@@ -87,7 +87,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n /// include! : parse the given file as an expr\n /// This is generally a bad idea because it's going to behave\n /// unhygienically.\n-pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                            -> Box<base::MacResult+'cx> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n@@ -130,7 +130,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                           -> Box<base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n@@ -167,7 +167,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     }\n }\n \n-pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                             -> Box<base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {\n         Some(f) => f,\n@@ -194,7 +194,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> PathBuf {\n+fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: &Path) -> PathBuf {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n         let callsite = cx.codemap().source_callsite(sp);"}, {"sha": "813afb935762e9e7d9a40ac40e8ee6d6fb29882f", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -79,9 +79,9 @@ pub use self::ParseResult::*;\n use self::TokenTreeOrTokenTreeVec::*;\n \n use ast;\n-use ast::{TokenTree, Name, Ident};\n-use codemap::{BytePos, mk_sp, Span, Spanned};\n-use codemap;\n+use ast::{Name, Ident};\n+use syntax_pos::{self, BytePos, mk_sp, Span};\n+use codemap::Spanned;\n use errors::FatalError;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n@@ -91,6 +91,7 @@ use parse::token::{Token, Nonterminal};\n use parse::token;\n use print::pprust;\n use ptr::P;\n+use tokenstream::{self, TokenTree};\n \n use std::mem;\n use std::rc::Rc;\n@@ -102,8 +103,8 @@ use std::collections::hash_map::Entry::{Vacant, Occupied};\n \n #[derive(Clone)]\n enum TokenTreeOrTokenTreeVec {\n-    Tt(ast::TokenTree),\n-    TtSeq(Rc<Vec<ast::TokenTree>>),\n+    Tt(tokenstream::TokenTree),\n+    TtSeq(Rc<Vec<tokenstream::TokenTree>>),\n }\n \n impl TokenTreeOrTokenTreeVec {\n@@ -196,15 +197,15 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n /// token tree it was derived from.\n \n pub enum NamedMatch {\n-    MatchedSeq(Vec<Rc<NamedMatch>>, codemap::Span),\n+    MatchedSeq(Vec<Rc<NamedMatch>>, syntax_pos::Span),\n     MatchedNonterminal(Nonterminal)\n }\n \n pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n             -> ParseResult<HashMap<Name, Rc<NamedMatch>>> {\n     fn n_rec(p_s: &ParseSess, m: &TokenTree, res: &[Rc<NamedMatch>],\n              ret_val: &mut HashMap<Name, Rc<NamedMatch>>, idx: &mut usize)\n-             -> Result<(), (codemap::Span, String)> {\n+             -> Result<(), (syntax_pos::Span, String)> {\n         match *m {\n             TokenTree::Sequence(_, ref seq) => {\n                 for next_m in &seq.tts {\n@@ -251,9 +252,9 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n pub enum ParseResult<T> {\n     Success(T),\n     /// Arm failed to match\n-    Failure(codemap::Span, String),\n+    Failure(syntax_pos::Span, String),\n     /// Fatal error (malformed macro?). Abort compilation.\n-    Error(codemap::Span, String)\n+    Error(syntax_pos::Span, String)\n }\n \n pub type NamedParseResult = ParseResult<HashMap<Name, Rc<NamedMatch>>>;\n@@ -374,7 +375,7 @@ pub fn parse(sess: &ParseSess,\n                 match ei.top_elts.get_tt(idx) {\n                     /* need to descend into sequence */\n                     TokenTree::Sequence(sp, seq) => {\n-                        if seq.op == ast::KleeneOp::ZeroOrMore {\n+                        if seq.op == tokenstream::KleeneOp::ZeroOrMore {\n                             let mut new_ei = ei.clone();\n                             new_ei.match_cur += seq.num_captures;\n                             new_ei.idx += 1;"}, {"sha": "23f0b1fff0ae72b79c28763d4bfab6befbfc8706", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{self, TokenTree};\n-use codemap::{Span, DUMMY_SP};\n+use ast;\n+use syntax_pos::{Span, DUMMY_SP};\n use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n use ext::tt::macro_parser::{Success, Error, Failure};\n@@ -21,13 +21,13 @@ use parse::token::{self, gensym_ident, NtTT, Token};\n use parse::token::Token::*;\n use print;\n use ptr::P;\n+use tokenstream::{self, TokenTree};\n \n use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::collections::{HashMap};\n use std::collections::hash_map::{Entry};\n-use std::rc::Rc;\n \n struct ParserAnyMacro<'a> {\n     parser: RefCell<Parser<'a>>,\n@@ -100,6 +100,21 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n+    fn make_trait_items(self: Box<ParserAnyMacro<'a>>)\n+                       -> Option<SmallVector<ast::TraitItem>> {\n+        let mut ret = SmallVector::zero();\n+        loop {\n+            let mut parser = self.parser.borrow_mut();\n+            match parser.token {\n+                token::Eof => break,\n+                _ => ret.push(panictry!(parser.parse_trait_item()))\n+            }\n+        }\n+        self.ensure_complete_parse(false, \"item\");\n+        Some(ret)\n+    }\n+\n+\n     fn make_stmts(self: Box<ParserAnyMacro<'a>>)\n                  -> Option<SmallVector<ast::Stmt>> {\n         let mut ret = SmallVector::zero();\n@@ -246,27 +261,25 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     // These spans won't matter, anyways\n     let match_lhs_tok = MatchNt(lhs_nm, token::str_to_ident(\"tt\"));\n     let match_rhs_tok = MatchNt(rhs_nm, token::str_to_ident(\"tt\"));\n-    let argument_gram = vec!(\n-        TokenTree::Sequence(DUMMY_SP,\n-                   Rc::new(ast::SequenceRepetition {\n-                       tts: vec![\n-                           TokenTree::Token(DUMMY_SP, match_lhs_tok),\n-                           TokenTree::Token(DUMMY_SP, token::FatArrow),\n-                           TokenTree::Token(DUMMY_SP, match_rhs_tok)],\n-                       separator: Some(token::Semi),\n-                       op: ast::KleeneOp::OneOrMore,\n-                       num_captures: 2\n-                   })),\n-        //to phase into semicolon-termination instead of\n-        //semicolon-separation\n-        TokenTree::Sequence(DUMMY_SP,\n-                   Rc::new(ast::SequenceRepetition {\n-                       tts: vec![TokenTree::Token(DUMMY_SP, token::Semi)],\n-                       separator: None,\n-                       op: ast::KleeneOp::ZeroOrMore,\n-                       num_captures: 0\n-                   })));\n-\n+    let argument_gram = vec![\n+        TokenTree::Sequence(DUMMY_SP, tokenstream::SequenceRepetition {\n+            tts: vec![\n+                TokenTree::Token(DUMMY_SP, match_lhs_tok),\n+                TokenTree::Token(DUMMY_SP, token::FatArrow),\n+                TokenTree::Token(DUMMY_SP, match_rhs_tok),\n+            ],\n+            separator: Some(token::Semi),\n+            op: tokenstream::KleeneOp::OneOrMore,\n+            num_captures: 2,\n+        }),\n+        // to phase into semicolon-termination instead of semicolon-separation\n+        TokenTree::Sequence(DUMMY_SP, tokenstream::SequenceRepetition {\n+            tts: vec![TokenTree::Token(DUMMY_SP, token::Semi)],\n+            separator: None,\n+            op: tokenstream::KleeneOp::ZeroOrMore,\n+            num_captures: 0\n+        }),\n+    ];\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,\n@@ -427,7 +440,7 @@ impl FirstSets {\n                         }\n \n                         // Reverse scan: Sequence comes before `first`.\n-                        if subfirst.maybe_empty || seq_rep.op == ast::KleeneOp::ZeroOrMore {\n+                        if subfirst.maybe_empty || seq_rep.op == tokenstream::KleeneOp::ZeroOrMore {\n                             // If sequence is potentially empty, then\n                             // union them (preserving first emptiness).\n                             first.add_all(&TokenSet { maybe_empty: true, ..subfirst });\n@@ -474,7 +487,8 @@ impl FirstSets {\n \n                             assert!(first.maybe_empty);\n                             first.add_all(subfirst);\n-                            if subfirst.maybe_empty || seq_rep.op == ast::KleeneOp::ZeroOrMore {\n+                            if subfirst.maybe_empty ||\n+                               seq_rep.op == tokenstream::KleeneOp::ZeroOrMore {\n                                 // continue scanning for more first\n                                 // tokens, but also make sure we\n                                 // restore empty-tracking state"}, {"sha": "58328eb4246756607aa037cf4d35a8731a929224", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n use self::LockstepIterSize::*;\n \n-use ast;\n-use ast::{TokenTree, Ident, Name};\n-use codemap::{Span, DUMMY_SP};\n+use ast::{Ident, Name};\n+use syntax_pos::{Span, DUMMY_SP};\n use errors::{Handler, DiagnosticBuilder};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{DocComment, MatchNt, SubstNt};\n use parse::token::{Token, NtIdent, SpecialMacroVar};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n+use tokenstream::{self, TokenTree};\n \n use std::rc::Rc;\n use std::ops::Add;\n@@ -59,7 +59,7 @@ pub struct TtReader<'a> {\n pub fn new_tt_reader(sp_diag: &Handler,\n                      interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                      imported_from: Option<Ident>,\n-                     src: Vec<ast::TokenTree>)\n+                     src: Vec<tokenstream::TokenTree>)\n                      -> TtReader {\n     new_tt_reader_with_doc_flag(sp_diag, interp, imported_from, src, false)\n }\n@@ -73,17 +73,17 @@ pub fn new_tt_reader(sp_diag: &Handler,\n pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n                                    interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                                    imported_from: Option<Ident>,\n-                                   src: Vec<ast::TokenTree>,\n+                                   src: Vec<tokenstream::TokenTree>,\n                                    desugar_doc_comments: bool)\n                                    -> TtReader {\n     let mut r = TtReader {\n         sp_diag: sp_diag,\n         stack: vec!(TtFrame {\n-            forest: TokenTree::Sequence(DUMMY_SP, Rc::new(ast::SequenceRepetition {\n+            forest: TokenTree::Sequence(DUMMY_SP, tokenstream::SequenceRepetition {\n                 tts: src,\n                 // doesn't matter. This merely holds the root unzipping.\n-                separator: None, op: ast::KleeneOp::ZeroOrMore, num_captures: 0\n-            })),\n+                separator: None, op: tokenstream::KleeneOp::ZeroOrMore, num_captures: 0\n+            }),\n             idx: 0,\n             dotdotdoted: false,\n             sep: None,\n@@ -259,7 +259,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                     }\n                     LisConstraint(len, _) => {\n                         if len == 0 {\n-                            if seq.op == ast::KleeneOp::OneOrMore {\n+                            if seq.op == tokenstream::KleeneOp::OneOrMore {\n                                 // FIXME #2887 blame invoker\n                                 panic!(r.sp_diag.span_fatal(sp.clone(),\n                                                      \"this must repeat at least once\"));"}, {"sha": "d6476fdb2f0159fbb001f51daf2cd500912c0af4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -30,10 +30,10 @@ use ast::{NodeId, PatKind};\n use ast;\n use attr;\n use attr::AttrMetaMethods;\n-use codemap::{CodeMap, Span};\n+use codemap::CodeMap;\n+use syntax_pos::Span;\n use errors::Handler;\n-use visit;\n-use visit::{FnKind, Visitor};\n+use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n use parse::token::InternedString;\n \n@@ -800,7 +800,7 @@ macro_rules! gate_feature_post {\n     }}\n }\n \n-impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n+impl<'a> Visitor for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if !self.context.cm.span_allows_unstable(attr.span) {\n             self.context.check_attribute(attr, false);\n@@ -996,9 +996,9 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_fn(&mut self,\n-                fn_kind: FnKind<'v>,\n-                fn_decl: &'v ast::FnDecl,\n-                block: &'v ast::Block,\n+                fn_kind: FnKind,\n+                fn_decl: &ast::FnDecl,\n+                block: &ast::Block,\n                 span: Span,\n                 _node_id: NodeId) {\n         // check for const fn declarations\n@@ -1037,7 +1037,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_fn(self, fn_kind, fn_decl, block, span);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n         match ti.node {\n             ast::TraitItemKind::Const(..) => {\n                 gate_feature_post!(&self, associated_consts,\n@@ -1058,7 +1058,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_trait_item(self, ti);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n         if ii.defaultness == ast::Defaultness::Default {\n             gate_feature_post!(&self, specialization,\n                               ii.span,\n@@ -1081,7 +1081,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_vis(&mut self, vis: &'v ast::Visibility) {\n+    fn visit_vis(&mut self, vis: &ast::Visibility) {\n         let span = match *vis {\n             ast::Visibility::Crate(span) => span,\n             ast::Visibility::Restricted { ref path, .. } => path.span,"}, {"sha": "6789e7be058bfcd7177991c3e2bb7c0b5a9c7176", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 67, "deletions": 87, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -20,15 +20,14 @@\n \n use ast::*;\n use ast;\n-use attr::{ThinAttributes, ThinAttributesExt};\n-use codemap::{respan, Span, Spanned};\n+use syntax_pos::Span;\n+use codemap::{Spanned, respan};\n use parse::token::{self, keywords};\n use ptr::P;\n+use tokenstream::*;\n use util::small_vector::SmallVector;\n use util::move_map::MoveMap;\n \n-use std::rc::Rc;\n-\n pub trait Folder : Sized {\n     // Any additions to this trait should happen in form\n     // of a call to a public `noop_*` function that only calls\n@@ -102,10 +101,6 @@ pub trait Folder : Sized {\n         noop_fold_pat(p, self)\n     }\n \n-    fn fold_decl(&mut self, d: P<Decl>) -> SmallVector<P<Decl>> {\n-        noop_fold_decl(d, self)\n-    }\n-\n     fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n         e.map(|e| noop_fold_expr(e, self))\n     }\n@@ -227,11 +222,11 @@ pub trait Folder : Sized {\n         noop_fold_ty_params(tps, self)\n     }\n \n-    fn fold_tt(&mut self, tt: &TokenTree) -> TokenTree {\n+    fn fold_tt(&mut self, tt: TokenTree) -> TokenTree {\n         noop_fold_tt(tt, self)\n     }\n \n-    fn fold_tts(&mut self, tts: &[TokenTree]) -> Vec<TokenTree> {\n+    fn fold_tts(&mut self, tts: Vec<TokenTree>) -> Vec<TokenTree> {\n         noop_fold_tts(tts, self)\n     }\n \n@@ -336,8 +331,8 @@ pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribut\n     attrs.move_flat_map(|x| fld.fold_attribute(x))\n }\n \n-pub fn fold_thin_attrs<T: Folder>(attrs: ThinAttributes, fld: &mut T) -> ThinAttributes {\n-    attrs.map_thin_attrs(|v| fold_attrs(v, fld))\n+pub fn fold_thin_attrs<T: Folder>(attrs: ThinVec<Attribute>, fld: &mut T) -> ThinVec<Attribute> {\n+    fold_attrs(attrs.into(), fld).into()\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n@@ -349,19 +344,6 @@ pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T\n     }\n }\n \n-pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n-    d.and_then(|Spanned {node, span}| match node {\n-        DeclKind::Local(l) => SmallVector::one(P(Spanned {\n-            node: DeclKind::Local(fld.fold_local(l)),\n-            span: fld.new_span(span)\n-        })),\n-        DeclKind::Item(it) => fld.fold_item(it).into_iter().map(|i| P(Spanned {\n-            node: DeclKind::Item(i),\n-            span: fld.new_span(span)\n-        })).collect()\n-    })\n-}\n-\n pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n     TypeBinding {\n         id: fld.new_id(b.id),\n@@ -498,7 +480,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n         pat: fld.fold_pat(pat),\n         init: init.map(|e| fld.fold_expr(e)),\n         span: fld.new_span(span),\n-        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, fld)),\n+        attrs: fold_attrs(attrs.into(), fld).into(),\n     })\n }\n \n@@ -519,8 +501,7 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     Spanned {\n         node: Mac_ {\n             path: fld.fold_path(node.path),\n-            tts: fld.fold_tts(&node.tts),\n-            ctxt: node.ctxt,\n+            tts: fld.fold_tts(node.tts),\n         },\n         span: fld.new_span(span)\n     }\n@@ -547,34 +528,26 @@ pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n     }\n }\n \n-pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n-    match *tt {\n+pub fn noop_fold_tt<T: Folder>(tt: TokenTree, fld: &mut T) -> TokenTree {\n+    match tt {\n         TokenTree::Token(span, ref tok) =>\n             TokenTree::Token(span, fld.fold_token(tok.clone())),\n-        TokenTree::Delimited(span, ref delimed) => {\n-            TokenTree::Delimited(span, Rc::new(\n-                            Delimited {\n-                                delim: delimed.delim,\n-                                open_span: delimed.open_span,\n-                                tts: fld.fold_tts(&delimed.tts),\n-                                close_span: delimed.close_span,\n-                            }\n-                        ))\n-        },\n-        TokenTree::Sequence(span, ref seq) =>\n-            TokenTree::Sequence(span,\n-                       Rc::new(SequenceRepetition {\n-                           tts: fld.fold_tts(&seq.tts),\n-                           separator: seq.separator.clone().map(|tok| fld.fold_token(tok)),\n-                           ..**seq\n-                       })),\n+        TokenTree::Delimited(span, delimed) => TokenTree::Delimited(span, Delimited {\n+            delim: delimed.delim,\n+            open_span: delimed.open_span,\n+            tts: fld.fold_tts(delimed.tts),\n+            close_span: delimed.close_span,\n+        }),\n+        TokenTree::Sequence(span, seq) => TokenTree::Sequence(span, SequenceRepetition {\n+            tts: fld.fold_tts(seq.tts),\n+            separator: seq.separator.clone().map(|tok| fld.fold_token(tok)),\n+            ..seq\n+        }),\n     }\n }\n \n-pub fn noop_fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n-    // FIXME: Does this have to take a tts slice?\n-    // Could use move_map otherwise...\n-    tts.iter().map(|tt| fld.fold_tt(tt)).collect()\n+pub fn noop_fold_tts<T: Folder>(tts: Vec<TokenTree>, fld: &mut T) -> Vec<TokenTree> {\n+    tts.move_map(|tt| fld.fold_tt(tt))\n }\n \n // apply ident folder if it's an ident, apply other folds to interpolated nodes\n@@ -632,7 +605,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n             token::NtIdent(Box::new(Spanned::<Ident>{node: fld.fold_ident(id.node), ..*id})),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n         token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n-        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&tt))),\n+        token::NtTT(tt) => token::NtTT(tt.map(|tt| fld.fold_tt(tt))),\n         token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n         token::NtImplItem(arm) =>\n             token::NtImplItem(arm.map(|arm| fld.fold_impl_item(arm)\n@@ -845,10 +818,9 @@ fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block {id, stmts, expr, rules, span}| Block {\n+    b.map(|Block {id, stmts, rules, span}| Block {\n         id: folder.new_id(id),\n         stmts: stmts.move_flat_map(|s| folder.fold_stmt(s).into_iter()),\n-        expr: expr.and_then(|x| folder.fold_opt_expr(x)),\n         rules: rules,\n         span: folder.new_span(span),\n     })\n@@ -945,6 +917,9 @@ pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T)\n                 TraitItemKind::Type(folder.fold_bounds(bounds),\n                               default.map(|x| folder.fold_ty(x)))\n             }\n+            ast::TraitItemKind::Macro(mac) => {\n+                TraitItemKind::Macro(folder.fold_mac(mac))\n+            }\n         },\n         span: folder.new_span(i.span)\n     })\n@@ -1088,12 +1063,11 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                 PatKind::TupleStruct(folder.fold_path(pth),\n                         pats.move_map(|x| folder.fold_pat(x)), ddpos)\n             }\n-            PatKind::Path(pth) => {\n-                PatKind::Path(folder.fold_path(pth))\n-            }\n-            PatKind::QPath(qself, pth) => {\n-                let qself = QSelf {ty: folder.fold_ty(qself.ty), .. qself};\n-                PatKind::QPath(qself, folder.fold_path(pth))\n+            PatKind::Path(opt_qself, pth) => {\n+                let opt_qself = opt_qself.map(|qself| {\n+                    QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n+                });\n+                PatKind::Path(opt_qself, folder.fold_path(pth))\n             }\n             PatKind::Struct(pth, fields, etc) => {\n                 let pth = folder.fold_path(pth);\n@@ -1255,7 +1229,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n             ),\n-            ExprKind::Again(opt_ident) => ExprKind::Again(opt_ident.map(|label|\n+            ExprKind::Continue(opt_ident) => ExprKind::Continue(opt_ident.map(|label|\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n             ),\n@@ -1300,7 +1274,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, folder)),\n+        attrs: fold_attrs(attrs.into(), folder).into(),\n     }\n }\n \n@@ -1312,44 +1286,50 @@ pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Exp\n     es.move_flat_map(|e| folder.fold_opt_expr(e))\n }\n \n-pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n+pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T)\n                                  -> SmallVector<Stmt> {\n+    let id = folder.new_id(id);\n     let span = folder.new_span(span);\n+\n     match node {\n-        StmtKind::Decl(d, id) => {\n-            let id = folder.new_id(id);\n-            folder.fold_decl(d).into_iter().map(|d| Spanned {\n-                node: StmtKind::Decl(d, id),\n-                span: span\n-            }).collect()\n-        }\n-        StmtKind::Expr(e, id) => {\n-            let id = folder.new_id(id);\n-            if let Some(e) = folder.fold_opt_expr(e) {\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Expr(e, id),\n-                    span: span\n+        StmtKind::Local(local) => SmallVector::one(Stmt {\n+            id: id,\n+            node: StmtKind::Local(folder.fold_local(local)),\n+            span: span,\n+        }),\n+        StmtKind::Item(item) => folder.fold_item(item).into_iter().map(|item| Stmt {\n+            id: id,\n+            node: StmtKind::Item(item),\n+            span: span,\n+        }).collect(),\n+        StmtKind::Expr(expr) => {\n+            if let Some(expr) = folder.fold_opt_expr(expr) {\n+                SmallVector::one(Stmt {\n+                    id: id,\n+                    node: StmtKind::Expr(expr),\n+                    span: span,\n                 })\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtKind::Semi(e, id) => {\n-            let id = folder.new_id(id);\n-            if let Some(e) = folder.fold_opt_expr(e) {\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Semi(e, id),\n-                    span: span\n+        StmtKind::Semi(expr) => {\n+            if let Some(expr) = folder.fold_opt_expr(expr) {\n+                SmallVector::one(Stmt {\n+                    id: id,\n+                    node: StmtKind::Semi(expr),\n+                    span: span,\n                 })\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtKind::Mac(mac, semi, attrs) => SmallVector::one(Spanned {\n-            node: StmtKind::Mac(mac.map(|m| folder.fold_mac(m)),\n-                                semi,\n-                                attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n-            span: span\n+        StmtKind::Mac(mac) => SmallVector::one(Stmt {\n+            id: id,\n+            node: StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n+                (folder.fold_mac(mac), semi, fold_attrs(attrs.into(), folder).into())\n+            })),\n+            span: span,\n         })\n     }\n }"}, {"sha": "dc9a5ee46645fbabb28aa1775d9b8864df6694b0", "filename": "src/libsyntax/json.rs", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,10 +19,10 @@\n \n // FIXME spec the JSON output properly.\n \n-\n-use codemap::{self, MacroBacktrace, Span, SpanLabel, MultiSpan, CodeMap};\n-use diagnostics::registry::Registry;\n-use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n+use codemap::CodeMap;\n+use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n+use errors::registry::Registry;\n+use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n use errors::emitter::Emitter;\n \n use std::rc::Rc;\n@@ -34,7 +34,7 @@ use rustc_serialize::json::as_json;\n pub struct JsonEmitter {\n     dst: Box<Write + Send>,\n     registry: Option<Registry>,\n-    cm: Rc<CodeMap>,\n+    cm: Rc<CodeMapper + 'static>,\n }\n \n impl JsonEmitter {\n@@ -303,7 +303,7 @@ impl DiagnosticSpan {\n }\n \n impl DiagnosticSpanLine {\n-    fn line_from_filemap(fm: &codemap::FileMap,\n+    fn line_from_filemap(fm: &syntax_pos::FileMap,\n                          index: usize,\n                          h_start: usize,\n                          h_end: usize)\n@@ -354,12 +354,14 @@ impl DiagnosticCode {\n \n impl JsonEmitter {\n     fn render(&self, render_span: &RenderSpan) -> Option<String> {\n+        use std::borrow::Borrow;\n+\n         match *render_span {\n             RenderSpan::FullSpan(_) => {\n                 None\n             }\n             RenderSpan::Suggestion(ref suggestion) => {\n-                Some(suggestion.splice_lines(&self.cm))\n+                Some(suggestion.splice_lines(self.cm.borrow()))\n             }\n         }\n     }", "previous_filename": "src/libsyntax/errors/json.rs"}, {"sha": "652cf68db07592b7f3d66fb9ebf660d67c02127f", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -33,17 +33,19 @@\n #![feature(str_escape)]\n #![feature(unicode)]\n #![feature(question_mark)]\n-#![feature(range_contains)]\n \n extern crate serialize;\n extern crate term;\n extern crate libc;\n #[macro_use] extern crate log;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n extern crate rustc_unicode;\n+pub extern crate rustc_errors as errors;\n+extern crate syntax_pos;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+\n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n // errors; eventually we plan to convert all code using panictry to just use\n@@ -53,7 +55,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use $crate::errors::FatalError;\n+        use errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(mut e) => {\n@@ -73,16 +75,18 @@ pub mod util {\n     pub mod parser_testing;\n     pub mod small_vector;\n     pub mod move_map;\n+\n+    mod thin_vec;\n+    pub use self::thin_vec::ThinVec;\n }\n \n pub mod diagnostics {\n     pub mod macros;\n     pub mod plugin;\n-    pub mod registry;\n     pub mod metadata;\n }\n \n-pub mod errors;\n+pub mod json;\n \n pub mod syntax {\n     pub use ext;\n@@ -104,6 +108,7 @@ pub mod show_span;\n pub mod std_inject;\n pub mod str;\n pub mod test;\n+pub mod tokenstream;\n pub mod visit;\n \n pub mod print {"}, {"sha": "f6e94b7caeabe617ceb2e17a3e5f34512c4410e8", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -10,7 +10,8 @@\n \n use attr;\n use ast;\n-use codemap::{spanned, Spanned, mk_sp, Span};\n+use syntax_pos::{mk_sp, Span};\n+use codemap::{spanned, Spanned};\n use parse::common::SeqSep;\n use parse::PResult;\n use parse::token;"}, {"sha": "4fe4ec7e4c0ed3f785fb498ded087152b4b67892", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -47,13 +47,9 @@ pub fn expr_is_simple_block(e: &ast::Expr) -> bool {\n /// seen the semicolon, and thus don't need another.\n pub fn stmt_ends_with_semi(stmt: &ast::StmtKind) -> bool {\n     match *stmt {\n-        ast::StmtKind::Decl(ref d, _) => {\n-            match d.node {\n-                ast::DeclKind::Local(_) => true,\n-                ast::DeclKind::Item(_) => false,\n-            }\n-        }\n-        ast::StmtKind::Expr(ref e, _) => expr_requires_semi_to_be_stmt(e),\n+        ast::StmtKind::Local(_) => true,\n+        ast::StmtKind::Item(_) => false,\n+        ast::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(e),\n         ast::StmtKind::Semi(..) => false,\n         ast::StmtKind::Mac(..) => false,\n     }"}, {"sha": "5eb5605ea71a0e4f93a575b364216fb2adddc09a", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -11,7 +11,8 @@\n pub use self::CommentStyle::*;\n \n use ast;\n-use codemap::{BytePos, CharPos, CodeMap, Pos};\n+use codemap::CodeMap;\n+use syntax_pos::{BytePos, CharPos, Pos};\n use errors;\n use parse::lexer::is_block_doc_comment;\n use parse::lexer::{StringReader, TokenAndSpan};"}, {"sha": "809f4daa3616d7a481dace362d62e59499668db0", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use ast;\n-use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n-use codemap;\n+use syntax_pos::{self, BytePos, CharPos, Pos, Span};\n+use codemap::CodeMap;\n use errors::{FatalError, Handler, DiagnosticBuilder};\n use ext::tt::transcribe::tt_next_token;\n use parse::token::{self, keywords, str_to_ident};\n@@ -84,7 +84,7 @@ pub struct StringReader<'a> {\n     pub col: CharPos,\n     /// The last character to be read\n     pub curr: Option<char>,\n-    pub filemap: Rc<codemap::FileMap>,\n+    pub filemap: Rc<syntax_pos::FileMap>,\n     // cached:\n     pub peek_tok: token::Token,\n     pub peek_span: Span,\n@@ -162,7 +162,7 @@ impl<'a> Reader for TtReader<'a> {\n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into pos and curr\n     pub fn new_raw<'b>(span_diagnostic: &'b Handler,\n-                       filemap: Rc<codemap::FileMap>)\n+                       filemap: Rc<syntax_pos::FileMap>)\n                        -> StringReader<'b> {\n         if filemap.src.is_none() {\n             span_diagnostic.bug(&format!(\"Cannot lex filemap \\\n@@ -181,7 +181,7 @@ impl<'a> StringReader<'a> {\n             filemap: filemap,\n             // dummy values; not read\n             peek_tok: token::Eof,\n-            peek_span: codemap::DUMMY_SP,\n+            peek_span: syntax_pos::DUMMY_SP,\n             source_text: source_text,\n             fatal_errs: Vec::new(),\n         };\n@@ -190,7 +190,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn new<'b>(span_diagnostic: &'b Handler,\n-                   filemap: Rc<codemap::FileMap>)\n+                   filemap: Rc<syntax_pos::FileMap>)\n                    -> StringReader<'b> {\n         let mut sr = StringReader::new_raw(span_diagnostic, filemap);\n         if let Err(_) = sr.advance_token() {\n@@ -217,12 +217,12 @@ impl<'a> StringReader<'a> {\n \n     /// Report a fatal error spanning [`from_pos`, `to_pos`).\n     fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> FatalError {\n-        self.fatal_span(codemap::mk_sp(from_pos, to_pos), m)\n+        self.fatal_span(syntax_pos::mk_sp(from_pos, to_pos), m)\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`).\n     fn err_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n-        self.err_span(codemap::mk_sp(from_pos, to_pos), m)\n+        self.err_span(syntax_pos::mk_sp(from_pos, to_pos), m)\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -246,7 +246,7 @@ impl<'a> StringReader<'a> {\n         for c in c.escape_default() {\n             m.push(c)\n         }\n-        self.span_diagnostic.struct_span_fatal(codemap::mk_sp(from_pos, to_pos), &m[..])\n+        self.span_diagnostic.struct_span_fatal(syntax_pos::mk_sp(from_pos, to_pos), &m[..])\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -270,7 +270,7 @@ impl<'a> StringReader<'a> {\n         for c in c.escape_default() {\n             m.push(c)\n         }\n-        self.span_diagnostic.struct_span_err(codemap::mk_sp(from_pos, to_pos), &m[..])\n+        self.span_diagnostic.struct_span_err(syntax_pos::mk_sp(from_pos, to_pos), &m[..])\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n@@ -294,11 +294,11 @@ impl<'a> StringReader<'a> {\n             None => {\n                 if self.is_eof() {\n                     self.peek_tok = token::Eof;\n-                    self.peek_span = codemap::mk_sp(self.filemap.end_pos, self.filemap.end_pos);\n+                    self.peek_span = syntax_pos::mk_sp(self.filemap.end_pos, self.filemap.end_pos);\n                 } else {\n                     let start_bytepos = self.last_pos;\n                     self.peek_tok = self.next_token_inner()?;\n-                    self.peek_span = codemap::mk_sp(start_bytepos, self.last_pos);\n+                    self.peek_span = syntax_pos::mk_sp(start_bytepos, self.last_pos);\n                 };\n             }\n         }\n@@ -473,7 +473,7 @@ impl<'a> StringReader<'a> {\n         match self.curr {\n             Some(c) => {\n                 if c.is_whitespace() {\n-                    self.span_diagnostic.span_err(codemap::mk_sp(self.last_pos, self.last_pos),\n+                    self.span_diagnostic.span_err(syntax_pos::mk_sp(self.last_pos, self.last_pos),\n                                                   \"called consume_any_line_comment, but there \\\n                                                    was whitespace\");\n                 }\n@@ -524,13 +524,13 @@ impl<'a> StringReader<'a> {\n \n                             Some(TokenAndSpan {\n                                 tok: tok,\n-                                sp: codemap::mk_sp(start_bpos, self.last_pos),\n+                                sp: syntax_pos::mk_sp(start_bpos, self.last_pos),\n                             })\n                         })\n                     } else {\n                         Some(TokenAndSpan {\n                             tok: token::Comment,\n-                            sp: codemap::mk_sp(start_bpos, self.last_pos),\n+                            sp: syntax_pos::mk_sp(start_bpos, self.last_pos),\n                         })\n                     };\n                 }\n@@ -563,7 +563,7 @@ impl<'a> StringReader<'a> {\n                     }\n                     return Some(TokenAndSpan {\n                         tok: token::Shebang(self.name_from(start)),\n-                        sp: codemap::mk_sp(start, self.last_pos),\n+                        sp: syntax_pos::mk_sp(start, self.last_pos),\n                     });\n                 }\n             }\n@@ -591,7 +591,7 @@ impl<'a> StringReader<'a> {\n                 }\n                 let c = Some(TokenAndSpan {\n                     tok: token::Whitespace,\n-                    sp: codemap::mk_sp(start_bpos, self.last_pos),\n+                    sp: syntax_pos::mk_sp(start_bpos, self.last_pos),\n                 });\n                 debug!(\"scanning whitespace: {:?}\", c);\n                 c\n@@ -653,7 +653,7 @@ impl<'a> StringReader<'a> {\n \n             Some(TokenAndSpan {\n                 tok: tok,\n-                sp: codemap::mk_sp(start_bpos, self.last_pos),\n+                sp: syntax_pos::mk_sp(start_bpos, self.last_pos),\n             })\n         })\n     }\n@@ -850,7 +850,7 @@ impl<'a> StringReader<'a> {\n                                 let valid = if self.curr_is('{') {\n                                     self.scan_unicode_escape(delim) && !ascii_only\n                                 } else {\n-                                    let span = codemap::mk_sp(start, self.last_pos);\n+                                    let span = syntax_pos::mk_sp(start, self.last_pos);\n                                     self.span_diagnostic\n                                         .struct_span_err(span, \"incorrect unicode escape sequence\")\n                                         .span_help(span,\n@@ -888,13 +888,13 @@ impl<'a> StringReader<'a> {\n                                                                         },\n                                                                         c);\n                                 if e == '\\r' {\n-                                    err.span_help(codemap::mk_sp(escaped_pos, last_pos),\n+                                    err.span_help(syntax_pos::mk_sp(escaped_pos, last_pos),\n                                                   \"this is an isolated carriage return; consider \\\n                                                    checking your editor and version control \\\n                                                    settings\");\n                                 }\n                                 if (e == '{' || e == '}') && !ascii_only {\n-                                    err.span_help(codemap::mk_sp(escaped_pos, last_pos),\n+                                    err.span_help(syntax_pos::mk_sp(escaped_pos, last_pos),\n                                                   \"if used in a formatting string, curly braces \\\n                                                    are escaped with `{{` and `}}`\");\n                                 }\n@@ -1677,7 +1677,8 @@ fn ident_continue(c: Option<char>) -> bool {\n mod tests {\n     use super::*;\n \n-    use codemap::{BytePos, CodeMap, Span, NO_EXPANSION};\n+    use syntax_pos::{BytePos, Span, NO_EXPANSION};\n+    use codemap::CodeMap;\n     use errors;\n     use parse::token;\n     use parse::token::str_to_ident;\n@@ -1686,7 +1687,10 @@ mod tests {\n \n     fn mk_sh(cm: Rc<CodeMap>) -> errors::Handler {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-        let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()), None, cm);\n+        let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n+                                                None,\n+                                                cm,\n+                                                errors::snippet::FormatMode::EnvironmentSelected);\n         errors::Handler::with_emitter(true, false, Box::new(emitter))\n     }\n \n@@ -1889,7 +1893,7 @@ mod tests {\n         let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();\n         assert_eq!(comment.tok, token::Comment);\n-        assert_eq!(comment.sp, ::codemap::mk_sp(BytePos(0), BytePos(7)));\n+        assert_eq!(comment.sp, ::syntax_pos::mk_sp(BytePos(0), BytePos(7)));\n         assert_eq!(lexer.next_token().tok, token::Whitespace);\n         assert_eq!(lexer.next_token().tok,\n                    token::DocComment(token::intern(\"/// test\")));"}, {"sha": "dab97d1d5a6ffc8872ec6733758086ea49e468e2", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -11,7 +11,7 @@\n // Characters and their corresponding confusables were collected from\n // http://www.unicode.org/Public/security/revision-06/confusables.txt\n \n-use codemap::mk_sp as make_span;\n+use syntax_pos::mk_sp as make_span;\n use errors::DiagnosticBuilder;\n use super::StringReader;\n "}, {"sha": "bbcc044d43c6b74b8701924847df75867f0a8ec6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -11,12 +11,14 @@\n //! The main parser interface\n \n use ast;\n-use codemap::{self, Span, CodeMap, FileMap};\n+use codemap::CodeMap;\n+use syntax_pos::{self, Span, FileMap};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use parse::parser::Parser;\n use parse::token::InternedString;\n use ptr::P;\n use str::char_at;\n+use tokenstream;\n \n use std::cell::RefCell;\n use std::iter;\n@@ -160,7 +162,7 @@ pub fn parse_tts_from_source_str<'a>(name: String,\n                                      source: String,\n                                      cfg: ast::CrateConfig,\n                                      sess: &'a ParseSess)\n-                                     -> PResult<'a, Vec<ast::TokenTree>> {\n+                                     -> PResult<'a, Vec<tokenstream::TokenTree>> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -211,8 +213,8 @@ pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n     let end_pos = filemap.end_pos;\n     let mut parser = tts_to_parser(sess, filemap_to_tts(sess, filemap), cfg);\n \n-    if parser.token == token::Eof && parser.span == codemap::DUMMY_SP {\n-        parser.span = codemap::mk_sp(end_pos, end_pos);\n+    if parser.token == token::Eof && parser.span == syntax_pos::DUMMY_SP {\n+        parser.span = syntax_pos::mk_sp(end_pos, end_pos);\n     }\n \n     parser\n@@ -222,7 +224,7 @@ pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n // compiler expands into it\n pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n                                cfg: ast::CrateConfig,\n-                               tts: Vec<ast::TokenTree>) -> Parser<'a> {\n+                               tts: Vec<tokenstream::TokenTree>) -> Parser<'a> {\n     tts_to_parser(sess, tts, cfg)\n }\n \n@@ -247,7 +249,7 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n \n /// Given a filemap, produce a sequence of token-trees\n pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n-    -> Vec<ast::TokenTree> {\n+    -> Vec<tokenstream::TokenTree> {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = Vec::new();\n@@ -258,7 +260,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n \n /// Given tts and cfg, produce a parser\n pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n-                         tts: Vec<ast::TokenTree>,\n+                         tts: Vec<tokenstream::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n     let mut p = Parser::new(sess, cfg, Box::new(trdr));\n@@ -660,20 +662,22 @@ pub fn integer_lit(s: &str,\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use std::rc::Rc;\n-    use codemap::{Span, BytePos, Pos, Spanned, NO_EXPANSION};\n-    use ast::{self, TokenTree, PatKind};\n+    use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n+    use codemap::Spanned;\n+    use ast::{self, PatKind};\n     use abi::Abi;\n     use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n     use parse;\n     use parse::parser::Parser;\n     use parse::token::{str_to_ident};\n     use print::pprust::item_to_string;\n     use ptr::P;\n+    use tokenstream::{self, TokenTree};\n     use util::parser_testing::{string_to_tts, string_to_parser};\n     use util::parser_testing::{string_to_expr, string_to_item, string_to_stmt};\n+    use util::ThinVec;\n \n-    // produce a codemap::span\n+    // produce a syntax_pos::span\n     fn sp(a: u32, b: u32) -> Span {\n         Span {lo: BytePos(a), hi: BytePos(b), expn_id: NO_EXPANSION}\n     }\n@@ -693,7 +697,7 @@ mod tests {\n                         ),\n                     }),\n                     span: sp(0, 1),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n@@ -716,7 +720,7 @@ mod tests {\n                             )\n                         }),\n                     span: sp(0, 6),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n@@ -729,7 +733,7 @@ mod tests {\n     #[test]\n     fn string_to_tts_macro () {\n         let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n-        let tts: &[ast::TokenTree] = &tts[..];\n+        let tts: &[tokenstream::TokenTree] = &tts[..];\n \n         match (tts.len(), tts.get(0), tts.get(1), tts.get(2), tts.get(3)) {\n             (\n@@ -759,7 +763,7 @@ mod tests {\n                             )\n                             if first_delimed.delim == token::Paren\n                             && ident.name.as_str() == \"a\" => {},\n-                            _ => panic!(\"value 3: {:?}\", **first_delimed),\n+                            _ => panic!(\"value 3: {:?}\", *first_delimed),\n                         }\n                         let tts = &second_delimed.tts[..];\n                         match (tts.len(), tts.get(0), tts.get(1)) {\n@@ -770,10 +774,10 @@ mod tests {\n                             )\n                             if second_delimed.delim == token::Paren\n                             && ident.name.as_str() == \"a\" => {},\n-                            _ => panic!(\"value 4: {:?}\", **second_delimed),\n+                            _ => panic!(\"value 4: {:?}\", *second_delimed),\n                         }\n                     },\n-                    _ => panic!(\"value 2: {:?}\", **macro_delimed),\n+                    _ => panic!(\"value 2: {:?}\", *macro_delimed),\n                 }\n             },\n             _ => panic!(\"value: {:?}\",tts),\n@@ -789,7 +793,7 @@ mod tests {\n             TokenTree::Token(sp(3, 4), token::Ident(str_to_ident(\"a\"))),\n             TokenTree::Delimited(\n                 sp(5, 14),\n-                Rc::new(ast::Delimited {\n+                tokenstream::Delimited {\n                     delim: token::DelimToken::Paren,\n                     open_span: sp(5, 6),\n                     tts: vec![\n@@ -798,18 +802,18 @@ mod tests {\n                         TokenTree::Token(sp(10, 13), token::Ident(str_to_ident(\"i32\"))),\n                     ],\n                     close_span: sp(13, 14),\n-                })),\n+                }),\n             TokenTree::Delimited(\n                 sp(15, 21),\n-                Rc::new(ast::Delimited {\n+                tokenstream::Delimited {\n                     delim: token::DelimToken::Brace,\n                     open_span: sp(15, 16),\n                     tts: vec![\n                         TokenTree::Token(sp(17, 18), token::Ident(str_to_ident(\"b\"))),\n                         TokenTree::Token(sp(18, 19), token::Semi),\n                     ],\n                     close_span: sp(20, 21),\n-                }))\n+                })\n         ];\n \n         assert_eq!(tts, expected);\n@@ -832,16 +836,16 @@ mod tests {\n                             ),\n                         }),\n                         span:sp(7,8),\n-                        attrs: None,\n+                        attrs: ThinVec::new(),\n                     }))),\n                     span:sp(0,8),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   Some(Spanned{\n+                   Some(ast::Stmt {\n                        node: ast::StmtKind::Expr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprKind::Path(None, ast::Path {\n@@ -855,8 +859,8 @@ mod tests {\n                                ),\n                             }),\n                            span: sp(0,1),\n-                           attrs: None}),\n-                                           ast::DUMMY_NODE_ID),\n+                           attrs: ThinVec::new()})),\n+                       id: ast::DUMMY_NODE_ID,\n                        span: sp(0,1)}))\n \n     }\n@@ -932,7 +936,7 @@ mod tests {\n                                         }\n                                     },\n                                     P(ast::Block {\n-                                        stmts: vec!(Spanned{\n+                                        stmts: vec!(ast::Stmt {\n                                             node: ast::StmtKind::Semi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprKind::Path(None,\n@@ -950,10 +954,9 @@ mod tests {\n                                                         ),\n                                                       }),\n                                                 span: sp(17,18),\n-                                                attrs: None,}),\n-                                                ast::DUMMY_NODE_ID),\n+                                                attrs: ThinVec::new()})),\n+                                            id: ast::DUMMY_NODE_ID,\n                                             span: sp(17,19)}),\n-                                        expr: None,\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::BlockCheckMode::Default, // no idea\n                                         span: sp(15,21),\n@@ -992,8 +995,8 @@ mod tests {\n         struct PatIdentVisitor {\n             spans: Vec<Span>\n         }\n-        impl<'v> ::visit::Visitor<'v> for PatIdentVisitor {\n-            fn visit_pat(&mut self, p: &'v ast::Pat) {\n+        impl ::visit::Visitor for PatIdentVisitor {\n+            fn visit_pat(&mut self, p: &ast::Pat) {\n                 match p.node {\n                     PatKind::Ident(_ , ref spannedident, _) => {\n                         self.spans.push(spannedident.span.clone());"}, {"sha": "a1d7ddcdf4bdf5fbe19a2af879c034ad65bdf051", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,7 +13,7 @@\n //!\n //! Obsolete syntax that becomes too hard to parse can be removed.\n \n-use codemap::Span;\n+use syntax_pos::Span;\n use parse::parser;\n \n /// The specific types of unsupported syntax"}, {"sha": "813d90103b8878000bf4f103078bc3781c3e28dd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 299, "deletions": 281, "changes": 580, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,8 +16,8 @@ use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n-use ast::{Decl, DeclKind, Defaultness};\n-use ast::{EMPTY_CTXT, EnumDef};\n+use ast::Defaultness;\n+use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n@@ -33,14 +33,14 @@ use ast::{Stmt, StmtKind};\n use ast::{VariantData, StructField};\n use ast::StrStyle;\n use ast::SelfKind;\n-use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n+use ast::{TraitItem, TraitRef};\n use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n-use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast::{BinOpKind, UnOp};\n use ast;\n-use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n+use codemap::{self, CodeMap, Spanned, spanned};\n+use syntax_pos::{self, Span, BytePos, mk_sp};\n use errors::{self, DiagnosticBuilder};\n use ext::tt::macro_parser;\n use parse;\n@@ -55,6 +55,8 @@ use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n use parse::PResult;\n+use tokenstream::{self, Delimited, SequenceRepetition, TokenTree};\n+use util::ThinVec;\n \n use std::collections::HashSet;\n use std::mem;\n@@ -120,7 +122,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), ThinVec::new()))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -130,7 +132,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), ThinVec::new()))\n                 }\n                 _ => None\n             };\n@@ -316,12 +318,12 @@ pub struct ModulePathError {\n \n pub enum LhsExpr {\n     NotYetParsed,\n-    AttributesParsed(ThinAttributes),\n+    AttributesParsed(ThinVec<Attribute>),\n     AlreadyParsed(P<Expr>),\n }\n \n-impl From<Option<ThinAttributes>> for LhsExpr {\n-    fn from(o: Option<ThinAttributes>) -> Self {\n+impl From<Option<ThinVec<Attribute>>> for LhsExpr {\n+    fn from(o: Option<ThinVec<Attribute>>) -> Self {\n         if let Some(attrs) = o {\n             LhsExpr::AttributesParsed(attrs)\n         } else {\n@@ -344,7 +346,7 @@ impl<'a> Parser<'a> {\n     {\n         let tok0 = rdr.real_token();\n         let span = tok0.sp;\n-        let filename = if span != codemap::DUMMY_SP {\n+        let filename = if span != syntax_pos::DUMMY_SP {\n             Some(sess.codemap().span_to_filename(span))\n         } else { None };\n         let placeholder = TokenAndSpan {\n@@ -1232,73 +1234,88 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the items in a trait declaration\n-    pub fn parse_trait_items(&mut self) -> PResult<'a,  Vec<TraitItem>> {\n-        self.parse_unspanned_seq(\n-            &token::OpenDelim(token::Brace),\n-            &token::CloseDelim(token::Brace),\n-            SeqSep::none(),\n-            |p| -> PResult<'a, TraitItem> {\n-            maybe_whole!(no_clone_from_p p, NtTraitItem);\n-            let mut attrs = p.parse_outer_attributes()?;\n-            let lo = p.span.lo;\n-\n-            let (name, node) = if p.eat_keyword(keywords::Type) {\n-                let TyParam {ident, bounds, default, ..} = p.parse_ty_param()?;\n-                p.expect(&token::Semi)?;\n-                (ident, TraitItemKind::Type(bounds, default))\n-            } else if p.is_const_item() {\n-                p.expect_keyword(keywords::Const)?;\n-                let ident = p.parse_ident()?;\n-                p.expect(&token::Colon)?;\n-                let ty = p.parse_ty_sum()?;\n-                let default = if p.check(&token::Eq) {\n-                    p.bump();\n-                    let expr = p.parse_expr()?;\n-                    p.commit_expr_expecting(&expr, token::Semi)?;\n-                    Some(expr)\n-                } else {\n-                    p.expect(&token::Semi)?;\n-                    None\n-                };\n-                (ident, TraitItemKind::Const(ty, default))\n+    pub fn parse_trait_item(&mut self) -> PResult<'a, TraitItem> {\n+        maybe_whole!(no_clone_from_p self, NtTraitItem);\n+        let mut attrs = self.parse_outer_attributes()?;\n+        let lo = self.span.lo;\n+\n+        let (name, node) = if self.eat_keyword(keywords::Type) {\n+            let TyParam {ident, bounds, default, ..} = self.parse_ty_param()?;\n+            self.expect(&token::Semi)?;\n+            (ident, TraitItemKind::Type(bounds, default))\n+        } else if self.is_const_item() {\n+                self.expect_keyword(keywords::Const)?;\n+            let ident = self.parse_ident()?;\n+            self.expect(&token::Colon)?;\n+            let ty = self.parse_ty_sum()?;\n+            let default = if self.check(&token::Eq) {\n+                self.bump();\n+                let expr = self.parse_expr()?;\n+                self.commit_expr_expecting(&expr, token::Semi)?;\n+                Some(expr)\n+            } else {\n+                self.expect(&token::Semi)?;\n+                None\n+            };\n+            (ident, TraitItemKind::Const(ty, default))\n+        } else if !self.token.is_any_keyword()\n+            && self.look_ahead(1, |t| *t == token::Not)\n+            && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n+                || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n+                // trait item macro.\n+                // code copied from parse_macro_use_or_failure... abstraction!\n+                let lo = self.span.lo;\n+                let pth = self.parse_ident_into_path()?;\n+                self.expect(&token::Not)?;\n+\n+                // eat a matched-delimiter token tree:\n+                let delim = self.expect_open_delim()?;\n+                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                             SeqSep::none(),\n+                                             |pp| pp.parse_token_tree())?;\n+                let m_ = Mac_ { path: pth, tts: tts };\n+                let m: ast::Mac = codemap::Spanned { node: m_,\n+                                                     span: mk_sp(lo,\n+                                                                 self.last_span.hi) };\n+                if delim != token::Brace {\n+                    self.expect(&token::Semi)?\n+                }\n+                (keywords::Invalid.ident(), ast::TraitItemKind::Macro(m))\n             } else {\n-                let (constness, unsafety, abi) = match p.parse_fn_front_matter() {\n+                let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n                     Ok(cua) => cua,\n                     Err(e) => {\n                         loop {\n-                            match p.token {\n+                            match self.token {\n                                 token::Eof => break,\n-\n                                 token::CloseDelim(token::Brace) |\n                                 token::Semi => {\n-                                    p.bump();\n+                                    self.bump();\n                                     break;\n                                 }\n-\n                                 token::OpenDelim(token::Brace) => {\n-                                    p.parse_token_tree()?;\n+                                    self.parse_token_tree()?;\n                                     break;\n                                 }\n-\n-                                _ => p.bump()\n+                                _ => self.bump()\n                             }\n                         }\n \n                         return Err(e);\n                     }\n                 };\n \n-                let ident = p.parse_ident()?;\n-                let mut generics = p.parse_generics()?;\n+                let ident = self.parse_ident()?;\n+                let mut generics = self.parse_generics()?;\n \n-                let d = p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+                let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n                     // This is somewhat dubious; We don't want to allow\n                     // argument names to be left off if there is a\n                     // definition...\n                     p.parse_arg_general(false)\n                 })?;\n \n-                generics.where_clause = p.parse_where_clause()?;\n+                generics.where_clause = self.parse_where_clause()?;\n                 let sig = ast::MethodSig {\n                     unsafety: unsafety,\n                     constness: constness,\n@@ -1307,37 +1324,47 @@ impl<'a> Parser<'a> {\n                     abi: abi,\n                 };\n \n-                let body = match p.token {\n-                  token::Semi => {\n-                    p.bump();\n-                    debug!(\"parse_trait_methods(): parsing required method\");\n-                    None\n-                  }\n-                  token::OpenDelim(token::Brace) => {\n-                    debug!(\"parse_trait_methods(): parsing provided method\");\n-                    let (inner_attrs, body) =\n-                        p.parse_inner_attrs_and_block()?;\n-                    attrs.extend(inner_attrs.iter().cloned());\n-                    Some(body)\n-                  }\n+                let body = match self.token {\n+                    token::Semi => {\n+                        self.bump();\n+                        debug!(\"parse_trait_methods(): parsing required method\");\n+                        None\n+                    }\n+                    token::OpenDelim(token::Brace) => {\n+                        debug!(\"parse_trait_methods(): parsing provided method\");\n+                        let (inner_attrs, body) =\n+                            self.parse_inner_attrs_and_block()?;\n+                        attrs.extend(inner_attrs.iter().cloned());\n+                        Some(body)\n+                    }\n \n-                  _ => {\n-                      let token_str = p.this_token_to_string();\n-                      return Err(p.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n-                                       token_str)[..]))\n-                  }\n+                    _ => {\n+                        let token_str = self.this_token_to_string();\n+                        return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n+                                                    token_str)[..]))\n+                    }\n                 };\n                 (ident, ast::TraitItemKind::Method(sig, body))\n             };\n+        Ok(TraitItem {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: name,\n+            attrs: attrs,\n+            node: node,\n+            span: mk_sp(lo, self.last_span.hi),\n+        })\n+    }\n \n-            Ok(TraitItem {\n-                id: ast::DUMMY_NODE_ID,\n-                ident: name,\n-                attrs: attrs,\n-                node: node,\n-                span: mk_sp(lo, p.last_span.hi),\n+\n+    /// Parse the items in a trait declaration\n+    pub fn parse_trait_items(&mut self) -> PResult<'a,  Vec<TraitItem>> {\n+        self.parse_unspanned_seq(\n+            &token::OpenDelim(token::Brace),\n+            &token::CloseDelim(token::Brace),\n+            SeqSep::none(),\n+            |p| -> PResult<'a, TraitItem> {\n+                p.parse_trait_item()\n             })\n-        })\n     }\n \n     /// Parse a possibly mutable type\n@@ -1467,7 +1494,7 @@ impl<'a> Parser<'a> {\n                                                 SeqSep::none(),\n                                                 |p| p.parse_token_tree())?;\n                 let hi = self.span.hi;\n-                TyKind::Mac(spanned(lo, hi, Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT }))\n+                TyKind::Mac(spanned(lo, hi, Mac_ { path: path, tts: tts }))\n             } else {\n                 // NAMED TYPE\n                 TyKind::Path(None, path)\n@@ -1676,12 +1703,12 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let literal = P(self.parse_lit()?);\n         let hi = self.last_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), None);\n+        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), ThinVec::new());\n \n         if minus_present {\n             let minus_hi = self.last_span.hi;\n             let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo, minus_hi, unary, None))\n+            Ok(self.mk_expr(minus_lo, minus_hi, unary, ThinVec::new()))\n         } else {\n             Ok(expr)\n         }\n@@ -2039,13 +2066,13 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos,\n-                   node: ExprKind, attrs: ThinAttributes) -> P<Expr> {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: ExprKind, attrs: ThinVec<Attribute>)\n+                   -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n-            attrs: attrs,\n+            attrs: attrs.into(),\n         })\n     }\n \n@@ -2102,7 +2129,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n-                       m: Mac_, attrs: ThinAttributes) -> P<Expr> {\n+                       m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprKind::Mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n@@ -2111,7 +2138,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinAttributes) -> P<Expr> {\n+    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinVec<Attribute>) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n             node: LitKind::Int(i as u64, ast::LitIntType::Unsigned(UintTy::U32)),\n@@ -2152,7 +2179,7 @@ impl<'a> Parser<'a> {\n         //\n         // Therefore, prevent sub-parser from parsing\n         // attributes by giving them a empty \"already parsed\" list.\n-        let mut attrs = None;\n+        let mut attrs = ThinVec::new();\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n@@ -2164,9 +2191,7 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Paren) => {\n                 self.bump();\n \n-                let attrs = self.parse_inner_attributes()?\n-                    .into_thin_attrs()\n-                    .prepend(attrs);\n+                attrs.extend(self.parse_inner_attributes()?);\n \n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n@@ -2204,9 +2229,7 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n-                let inner_attrs = self.parse_inner_attributes()?\n-                    .into_thin_attrs();\n-                attrs.update(|attrs| attrs.append(inner_attrs));\n+                attrs.extend(self.parse_inner_attributes()?);\n \n                 if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n@@ -2285,14 +2308,14 @@ impl<'a> Parser<'a> {\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n                     let ex = if self.token.is_lifetime() {\n-                        let ex = ExprKind::Again(Some(Spanned{\n+                        let ex = ExprKind::Continue(Some(Spanned{\n                             node: self.get_lifetime(),\n                             span: self.span\n                         }));\n                         self.bump();\n                         ex\n                     } else {\n-                        ExprKind::Again(None)\n+                        ExprKind::Continue(None)\n                     };\n                     let hi = self.last_span.hi;\n                     return Ok(self.mk_expr(lo, hi, ex, attrs));\n@@ -2348,7 +2371,7 @@ impl<'a> Parser<'a> {\n \n                         return Ok(self.mk_mac_expr(lo,\n                                                    hi,\n-                                                   Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT },\n+                                                   Mac_ { path: pth, tts: tts },\n                                                    attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n@@ -2363,9 +2386,7 @@ impl<'a> Parser<'a> {\n                             let mut fields = Vec::new();\n                             let mut base = None;\n \n-                            let attrs = attrs.append(\n-                                self.parse_inner_attributes()?\n-                                    .into_thin_attrs());\n+                            attrs.extend(self.parse_inner_attributes()?);\n \n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if self.eat(&token::DotDot) {\n@@ -2432,33 +2453,32 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_or_use_outer_attributes(&mut self,\n-                                     already_parsed_attrs: Option<ThinAttributes>)\n-                                     -> PResult<'a, ThinAttributes> {\n+                                     already_parsed_attrs: Option<ThinVec<Attribute>>)\n+                                     -> PResult<'a, ThinVec<Attribute>> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {\n-            self.parse_outer_attributes().map(|a| a.into_thin_attrs())\n+            self.parse_outer_attributes().map(|a| a.into())\n         }\n     }\n \n     /// Parse a block or unsafe block\n     pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode,\n-                            attrs: ThinAttributes)\n+                            outer_attrs: ThinVec<Attribute>)\n                             -> PResult<'a, P<Expr>> {\n \n-        let outer_attrs = attrs;\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n-        let inner_attrs = self.parse_inner_attributes()?.into_thin_attrs();\n-        let attrs = outer_attrs.append(inner_attrs);\n+        let mut attrs = outer_attrs;\n+        attrs.extend(self.parse_inner_attributes()?);\n \n         let blk = self.parse_block_tail(lo, blk_mode)?;\n         return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n     pub fn parse_dot_or_call_expr(&mut self,\n-                                  already_parsed_attrs: Option<ThinAttributes>)\n+                                  already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                   -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n \n@@ -2470,20 +2490,21 @@ impl<'a> Parser<'a> {\n     pub fn parse_dot_or_call_expr_with(&mut self,\n                                        e0: P<Expr>,\n                                        lo: BytePos,\n-                                       attrs: ThinAttributes)\n+                                       mut attrs: ThinVec<Attribute>)\n                                        -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n         self.parse_dot_or_call_expr_with_(e0, lo)\n         .map(|expr|\n             expr.map(|mut expr| {\n-                expr.attrs.update(|a| a.prepend(attrs));\n+                attrs.extend::<Vec<_>>(expr.attrs.into());\n+                expr.attrs = attrs;\n                 match expr.node {\n                     ExprKind::If(..) | ExprKind::IfLet(..) => {\n-                        if !expr.attrs.as_attr_slice().is_empty() {\n+                        if !expr.attrs.is_empty() {\n                             // Just point to the first attribute in there...\n-                            let span = expr.attrs.as_attr_slice()[0].span;\n+                            let span = expr.attrs[0].span;\n \n                             self.span_err(span,\n                                 \"attributes are not yet allowed on `if` \\\n@@ -2531,7 +2552,7 @@ impl<'a> Parser<'a> {\n                 es.insert(0, self_value);\n                 let id = spanned(ident_span.lo, ident_span.hi, ident);\n                 let nd = self.mk_method_call(id, tys, es);\n-                self.mk_expr(lo, hi, nd, None)\n+                self.mk_expr(lo, hi, nd, ThinVec::new())\n             }\n             // Field access.\n             _ => {\n@@ -2544,7 +2565,7 @@ impl<'a> Parser<'a> {\n \n                 let id = spanned(ident_span.lo, ident_span.hi, ident);\n                 let field = self.mk_field(self_value, id);\n-                self.mk_expr(lo, ident_span.hi, field, None)\n+                self.mk_expr(lo, ident_span.hi, field, ThinVec::new())\n             }\n         })\n     }\n@@ -2556,7 +2577,7 @@ impl<'a> Parser<'a> {\n             // expr?\n             while self.eat(&token::Question) {\n                 let hi = self.last_span.hi;\n-                e = self.mk_expr(lo, hi, ExprKind::Try(e), None);\n+                e = self.mk_expr(lo, hi, ExprKind::Try(e), ThinVec::new());\n             }\n \n             // expr.f\n@@ -2584,7 +2605,7 @@ impl<'a> Parser<'a> {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n                             let field = self.mk_tup_field(e, id);\n-                            e = self.mk_expr(lo, hi, field, None);\n+                            e = self.mk_expr(lo, hi, field, ThinVec::new());\n                         }\n                         None => {\n                             let last_span = self.last_span;\n@@ -2636,7 +2657,7 @@ impl<'a> Parser<'a> {\n                 hi = self.last_span.hi;\n \n                 let nd = self.mk_call(e, es);\n-                e = self.mk_expr(lo, hi, nd, None);\n+                e = self.mk_expr(lo, hi, nd, ThinVec::new());\n               }\n \n               // expr[...]\n@@ -2647,7 +2668,7 @@ impl<'a> Parser<'a> {\n                 hi = self.span.hi;\n                 self.commit_expr_expecting(&ix, token::CloseDelim(token::Bracket))?;\n                 let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index, None)\n+                e = self.mk_expr(lo, hi, index, ThinVec::new())\n               }\n               _ => return Ok(e)\n             }\n@@ -2671,13 +2692,12 @@ impl<'a> Parser<'a> {\n                     )?;\n                     let (sep, repeat) = self.parse_sep_and_kleene_op()?;\n                     let name_num = macro_parser::count_names(&seq);\n-                    return Ok(TokenTree::Sequence(mk_sp(sp.lo, seq_span.hi),\n-                                      Rc::new(SequenceRepetition {\n-                                          tts: seq,\n-                                          separator: sep,\n-                                          op: repeat,\n-                                          num_captures: name_num\n-                                      })));\n+                    return Ok(TokenTree::Sequence(mk_sp(sp.lo, seq_span.hi), SequenceRepetition {\n+                        tts: seq,\n+                        separator: sep,\n+                        op: repeat,\n+                        num_captures: name_num\n+                    }));\n                 } else if self.token.is_keyword(keywords::Crate) {\n                     self.bump();\n                     return Ok(TokenTree::Token(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar)));\n@@ -2720,16 +2740,17 @@ impl<'a> Parser<'a> {\n     /// Parse an optional separator followed by a Kleene-style\n     /// repetition token (+ or *).\n     pub fn parse_sep_and_kleene_op(&mut self)\n-                                   -> PResult<'a, (Option<token::Token>, ast::KleeneOp)> {\n-        fn parse_kleene_op<'a>(parser: &mut Parser<'a>) -> PResult<'a,  Option<ast::KleeneOp>> {\n+                                   -> PResult<'a, (Option<token::Token>, tokenstream::KleeneOp)> {\n+        fn parse_kleene_op<'a>(parser: &mut Parser<'a>) ->\n+          PResult<'a,  Option<tokenstream::KleeneOp>> {\n             match parser.token {\n                 token::BinOp(token::Star) => {\n                     parser.bump();\n-                    Ok(Some(ast::KleeneOp::ZeroOrMore))\n+                    Ok(Some(tokenstream::KleeneOp::ZeroOrMore))\n                 },\n                 token::BinOp(token::Plus) => {\n                     parser.bump();\n-                    Ok(Some(ast::KleeneOp::OneOrMore))\n+                    Ok(Some(tokenstream::KleeneOp::OneOrMore))\n                 },\n                 _ => Ok(None)\n             }\n@@ -2832,12 +2853,12 @@ impl<'a> Parser<'a> {\n                     _ => {}\n                 }\n \n-                Ok(TokenTree::Delimited(span, Rc::new(Delimited {\n+                Ok(TokenTree::Delimited(span, Delimited {\n                     delim: delim,\n                     open_span: open_span,\n                     tts: tts,\n                     close_span: close_span,\n-                })))\n+                }))\n             },\n             _ => {\n                 // invariants: the current token is not a left-delimiter,\n@@ -2878,7 +2899,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a prefix-unary-operator expr\n     pub fn parse_prefix_expr(&mut self,\n-                             already_parsed_attrs: Option<ThinAttributes>)\n+                             already_parsed_attrs: Option<ThinVec<Attribute>>)\n                              -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.span.lo;\n@@ -2923,8 +2944,7 @@ impl<'a> Parser<'a> {\n                 let blk = self.parse_block()?;\n                 let span = blk.span;\n                 hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, span.hi, ExprKind::Block(blk),\n-                                            None);\n+                let blk_expr = self.mk_expr(span.lo, hi, ExprKind::Block(blk), ThinVec::new());\n                 ExprKind::InPlace(place, blk_expr)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n@@ -2944,7 +2964,7 @@ impl<'a> Parser<'a> {\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n     pub fn parse_assoc_expr(&mut self,\n-                            already_parsed_attrs: Option<ThinAttributes>)\n+                            already_parsed_attrs: Option<ThinVec<Attribute>>)\n                             -> PResult<'a, P<Expr>> {\n         self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n@@ -2997,13 +3017,13 @@ impl<'a> Parser<'a> {\n             // Special cases:\n             if op == AssocOp::As {\n                 let rhs = self.parse_ty()?;\n-                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprKind::Cast(lhs, rhs), None);\n+                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n+                lhs = self.mk_expr(lo, hi, ExprKind::Cast(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = self.parse_ty()?;\n-                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprKind::Type(lhs, rhs), None);\n+                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n+                lhs = self.mk_expr(lo, hi, ExprKind::Type(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotDot {\n                 // If we didn\u2019t have to handle `x..`/`x...`, it would be pretty easy to\n@@ -3029,7 +3049,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let r = try!(self.mk_range(Some(lhs), rhs, limits));\n-                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n+                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, ThinVec::new());\n                 break\n             }\n \n@@ -3056,21 +3076,21 @@ impl<'a> Parser<'a> {\n                 }),\n             }?;\n \n+            let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n             lhs = match op {\n                 AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n                 AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n                 AssocOp::BitAnd | AssocOp::BitOr | AssocOp::ShiftLeft | AssocOp::ShiftRight |\n                 AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n-                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n+                    self.mk_expr(lo, hi, binary, ThinVec::new())\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::Assign(lhs, rhs), None),\n+                    self.mk_expr(lo, hi, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::InPlace(lhs, rhs), None),\n+                    self.mk_expr(lo, hi, ExprKind::InPlace(lhs, rhs), ThinVec::new()),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,\n@@ -3084,9 +3104,8 @@ impl<'a> Parser<'a> {\n                         token::Shl =>     BinOpKind::Shl,\n                         token::Shr =>     BinOpKind::Shr,\n                     };\n-                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n+                    self.mk_expr(lo, hi, aopexpr, ThinVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotDot => {\n                     self.bug(\"As, Colon, DotDot or DotDotDot branch reached\")\n@@ -3121,7 +3140,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse prefix-forms of range notation: `..expr`, `..`, `...expr`\n     fn parse_prefix_range_expr(&mut self,\n-                               already_parsed_attrs: Option<ThinAttributes>)\n+                               already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                -> PResult<'a, P<Expr>> {\n         debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n         let tok = self.token.clone();\n@@ -3166,7 +3185,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+    pub fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.check_keyword(keywords::Let) {\n             return self.parse_if_let_expr(attrs);\n         }\n@@ -3184,7 +3203,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_let_expr(&mut self, attrs: ThinAttributes)\n+    pub fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>> {\n         let lo = self.last_span.lo;\n         self.expect_keyword(keywords::Let)?;\n@@ -3205,7 +3224,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_lambda_expr(&mut self,\n                              lo: BytePos,\n                              capture_clause: CaptureBy,\n-                             attrs: ThinAttributes)\n+                             attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>>\n     {\n         let decl = self.parse_fn_block_decl()?;\n@@ -3217,9 +3236,12 @@ impl<'a> Parser<'a> {\n                 let body_expr = self.parse_expr()?;\n                 P(ast::Block {\n                     id: ast::DUMMY_NODE_ID,\n-                    stmts: vec![],\n                     span: body_expr.span,\n-                    expr: Some(body_expr),\n+                    stmts: vec![Stmt {\n+                        span: body_expr.span,\n+                        node: StmtKind::Expr(body_expr),\n+                        id: ast::DUMMY_NODE_ID,\n+                    }],\n                     rules: BlockCheckMode::Default,\n                 })\n             }\n@@ -3240,24 +3262,24 @@ impl<'a> Parser<'a> {\n     // `else` token already eaten\n     pub fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         if self.eat_keyword(keywords::If) {\n-            return self.parse_if_expr(None);\n+            return self.parse_if_expr(ThinVec::new());\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), None));\n+            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), ThinVec::new()));\n         }\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                           span_lo: BytePos,\n-                          attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                          mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let pat = self.parse_pat()?;\n         self.expect_keyword(keywords::In)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n \n         let hi = self.last_span.hi;\n \n@@ -3269,13 +3291,13 @@ impl<'a> Parser<'a> {\n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                             span_lo: BytePos,\n-                            attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n         let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(span_lo, hi, ExprKind::While(cond, body, opt_ident),\n                                attrs));\n@@ -3284,29 +3306,29 @@ impl<'a> Parser<'a> {\n     /// Parse a 'while let' expression ('while' token already eaten)\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                                 span_lo: BytePos,\n-                                attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                                mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(span_lo, hi, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                            span_lo: BytePos,\n-                           attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n     // `match` token already eaten\n-    fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n@@ -3318,8 +3340,8 @@ impl<'a> Parser<'a> {\n             }\n             return Err(e)\n         }\n-        let attrs = attrs.append(\n-            self.parse_inner_attributes()?.into_thin_attrs());\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n             match self.parse_arm() {\n@@ -3392,7 +3414,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression, subject to the given restrictions\n     pub fn parse_expr_res(&mut self, r: Restrictions,\n-                          already_parsed_attrs: Option<ThinAttributes>)\n+                          already_parsed_attrs: Option<ThinVec<Attribute>>)\n                           -> PResult<'a, P<Expr>> {\n         self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n@@ -3500,7 +3522,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<codemap::Spanned<ast::FieldPat>> , bool)> {\n+    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<codemap::Spanned<ast::FieldPat>>, bool)> {\n         let mut fields = Vec::new();\n         let mut etc = false;\n         let mut first = true;\n@@ -3570,9 +3592,9 @@ impl<'a> Parser<'a> {\n             };\n \n             fields.push(codemap::Spanned { span: mk_sp(lo, hi),\n-                                           node: ast::FieldPat { ident: fieldname,\n-                                                                 pat: subpat,\n-                                                                 is_shorthand: is_shorthand }});\n+                                              node: ast::FieldPat { ident: fieldname,\n+                                                                    pat: subpat,\n+                                                                    is_shorthand: is_shorthand }});\n         }\n         return Ok((fields, etc));\n     }\n@@ -3590,7 +3612,7 @@ impl<'a> Parser<'a> {\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), None))\n+            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new()))\n         } else {\n             self.parse_pat_literal_maybe_minus()\n         }\n@@ -3661,9 +3683,9 @@ impl<'a> Parser<'a> {\n                         let tts = self.parse_seq_to_end(\n                             &token::CloseDelim(delim),\n                             SeqSep::none(), |p| p.parse_token_tree())?;\n-                        let mac = Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT };\n+                        let mac = Mac_ { path: path, tts: tts };\n                         pat = PatKind::Mac(codemap::Spanned {node: mac,\n-                                                       span: mk_sp(lo, self.last_span.hi)});\n+                                                               span: mk_sp(lo, self.last_span.hi)});\n                     } else {\n                         // Parse ident @ pat\n                         // This can give false positives and parse nullary enums,\n@@ -3685,7 +3707,8 @@ impl<'a> Parser<'a> {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprKind::Path(qself, path), None);\n+                        let begin =\n+                              self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n                         pat = PatKind::Range(begin, end);\n@@ -3715,12 +3738,7 @@ impl<'a> Parser<'a> {\n                         pat = PatKind::TupleStruct(path, fields, ddpos)\n                       }\n                       _ => {\n-                        pat = match qself {\n-                            // Parse qualified path\n-                            Some(qself) => PatKind::QPath(qself, path),\n-                            // Parse nullary enum\n-                            None => PatKind::Path(path)\n-                        };\n+                        pat = PatKind::Path(qself, path);\n                       }\n                     }\n                 }\n@@ -3785,7 +3803,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a local variable declaration\n-    fn parse_local(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Local>> {\n+    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n         let lo = self.span.lo;\n         let pat = self.parse_pat()?;\n \n@@ -3804,13 +3822,6 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Parse a \"let\" stmt\n-    fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Decl>> {\n-        let lo = self.span.lo;\n-        let local = self.parse_local(attrs)?;\n-        Ok(P(spanned(lo, self.last_span.hi, DeclKind::Local(local))))\n-    }\n-\n     /// Parse a structure field\n     fn parse_name_and_ty(&mut self, pr: Visibility,\n                          attrs: Vec<Attribute> ) -> PResult<'a, StructField> {\n@@ -3923,12 +3934,12 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n \n-        Ok(Some(if self.check_keyword(keywords::Let) {\n-            self.expect_keyword(keywords::Let)?;\n-            let decl = self.parse_let(attrs.into_thin_attrs())?;\n-            let hi = decl.span.hi;\n-            let stmt = StmtKind::Decl(decl, ast::DUMMY_NODE_ID);\n-            spanned(lo, hi, stmt)\n+        Ok(Some(if self.eat_keyword(keywords::Let) {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Local(self.parse_local(attrs.into())?),\n+                span: mk_sp(lo, self.last_span.hi),\n+            }\n         } else if self.token.is_ident()\n             && !self.token.is_any_keyword()\n             && self.look_ahead(1, |t| *t == token::Not) {\n@@ -3979,9 +3990,12 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == keywords::Invalid.name() {\n-                let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n-                let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n-                spanned(lo, hi, stmt)\n+                let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts });\n+                Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Mac(P((mac, style, attrs.into()))),\n+                    span: mk_sp(lo, hi),\n+                }\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 //\n@@ -3995,25 +4009,28 @@ impl<'a> Parser<'a> {\n                                        followed by a semicolon\");\n                     }\n                 }\n-                spanned(lo, hi, StmtKind::Decl(\n-                    P(spanned(lo, hi, DeclKind::Item(\n+                Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: mk_sp(lo, hi),\n+                    node: StmtKind::Item({\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n-                            ItemKind::Mac(spanned(lo, hi,\n-                                            Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n-                            Visibility::Inherited, attrs)))),\n-                    ast::DUMMY_NODE_ID))\n+                            ItemKind::Mac(spanned(lo, hi, Mac_ { path: pth, tts: tts })),\n+                            Visibility::Inherited,\n+                            attrs)\n+                    }),\n+                }\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n             let restrictions = self.restrictions | Restrictions::NO_NONINLINE_MOD;\n             match self.with_res(restrictions,\n                                 |this| this.parse_item_(attrs.clone(), false, true))? {\n-                Some(i) => {\n-                    let hi = i.span.hi;\n-                    let decl = P(spanned(lo, hi, DeclKind::Item(i)));\n-                    spanned(lo, hi, StmtKind::Decl(decl, ast::DUMMY_NODE_ID))\n-                }\n+                Some(i) => Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: mk_sp(lo, i.span.hi),\n+                    node: StmtKind::Item(i),\n+                },\n                 None => {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n                         if attrs.len() > 0 {\n@@ -4036,10 +4053,12 @@ impl<'a> Parser<'a> {\n \n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n-                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_thin_attrs()))?;\n-                    let hi = e.span.hi;\n-                    let stmt = StmtKind::Expr(e, ast::DUMMY_NODE_ID);\n-                    spanned(lo, hi, stmt)\n+                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n+                    Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: mk_sp(lo, e.span.hi),\n+                        node: StmtKind::Expr(e),\n+                    }\n                 }\n             }\n         }))\n@@ -4082,71 +4101,23 @@ impl<'a> Parser<'a> {\n     /// Precondition: already parsed the '{'.\n     fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n-        let mut expr = None;\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n+            let Stmt {node, span, ..} = if let Some(s) = self.parse_stmt_() {\n                 s\n             } else if self.token == token::Eof {\n                 break;\n             } else {\n                 // Found only `;` or `}`.\n                 continue;\n             };\n+\n             match node {\n-                StmtKind::Expr(e, _) => {\n-                    self.handle_expression_like_statement(e, span, &mut stmts, &mut expr)?;\n+                StmtKind::Expr(e) => {\n+                    self.handle_expression_like_statement(e, span, &mut stmts)?;\n                 }\n-                StmtKind::Mac(mac, MacStmtStyle::NoBraces, attrs) => {\n-                    // statement macro without braces; might be an\n-                    // expr depending on whether a semicolon follows\n-                    match self.token {\n-                        token::Semi => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(mac, MacStmtStyle::Semicolon, attrs),\n-                                span: mk_sp(span.lo, self.span.hi),\n-                            });\n-                            self.bump();\n-                        }\n-                        _ => {\n-                            let e = self.mk_mac_expr(span.lo, span.hi,\n-                                                     mac.and_then(|m| m.node),\n-                                                     None);\n-                            let lo = e.span.lo;\n-                            let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-                            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                            self.handle_expression_like_statement(\n-                                e,\n-                                span,\n-                                &mut stmts,\n-                                &mut expr)?;\n-                        }\n-                    }\n-                }\n-                StmtKind::Mac(m, style, attrs) => {\n-                    // statement macro; might be an expr\n-                    match self.token {\n-                        token::Semi => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(m, MacStmtStyle::Semicolon, attrs),\n-                                span: mk_sp(span.lo, self.span.hi),\n-                            });\n-                            self.bump();\n-                        }\n-                        token::CloseDelim(token::Brace) => {\n-                            // if a block ends in `m!(arg)` without\n-                            // a `;`, it must be an expr\n-                            expr = Some(self.mk_mac_expr(span.lo, span.hi,\n-                                                         m.and_then(|x| x.node),\n-                                                         attrs));\n-                        }\n-                        _ => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(m, style, attrs),\n-                                span: span\n-                            });\n-                        }\n-                    }\n+                StmtKind::Mac(mac) => {\n+                    self.handle_macro_in_block(mac.unwrap(), span, &mut stmts)?;\n                 }\n                 _ => { // all other kinds of statements:\n                     let mut hi = span.hi;\n@@ -4155,7 +4126,8 @@ impl<'a> Parser<'a> {\n                         hi = self.last_span.hi;\n                     }\n \n-                    stmts.push(Spanned {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n                         node: node,\n                         span: mk_sp(span.lo, hi)\n                     });\n@@ -4165,18 +4137,64 @@ impl<'a> Parser<'a> {\n \n         Ok(P(ast::Block {\n             stmts: stmts,\n-            expr: expr,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n             span: mk_sp(lo, self.last_span.hi),\n         }))\n     }\n \n+    fn handle_macro_in_block(&mut self,\n+                             (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinVec<Attribute>),\n+                             span: Span,\n+                             stmts: &mut Vec<Stmt>)\n+                             -> PResult<'a, ()> {\n+        if style == MacStmtStyle::NoBraces {\n+            // statement macro without braces; might be an\n+            // expr depending on whether a semicolon follows\n+            match self.token {\n+                token::Semi => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n+                        span: mk_sp(span.lo, self.span.hi),\n+                    });\n+                    self.bump();\n+                }\n+                _ => {\n+                    let e = self.mk_mac_expr(span.lo, span.hi, mac.node, ThinVec::new());\n+                    let lo = e.span.lo;\n+                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n+                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                    self.handle_expression_like_statement(e, span, stmts)?;\n+                }\n+            }\n+        } else {\n+            // statement macro; might be an expr\n+            match self.token {\n+                token::Semi => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n+                        span: mk_sp(span.lo, self.span.hi),\n+                    });\n+                    self.bump();\n+                }\n+                _ => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, style, attrs))),\n+                        span: span\n+                    });\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn handle_expression_like_statement(&mut self,\n                                         e: P<Expr>,\n                                         span: Span,\n-                                        stmts: &mut Vec<Stmt>,\n-                                        last_block_expr: &mut Option<P<Expr>>)\n+                                        stmts: &mut Vec<Stmt>)\n                                         -> PResult<'a, ()> {\n         // expression without semicolon\n         if classify::expr_requires_semi_to_be_stmt(&e) {\n@@ -4197,15 +4215,16 @@ impl<'a> Parser<'a> {\n                     hi: self.last_span.hi,\n                     expn_id: span.expn_id,\n                 };\n-                stmts.push(Spanned {\n-                    node: StmtKind::Semi(e, ast::DUMMY_NODE_ID),\n+                stmts.push(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Semi(e),\n                     span: span_with_semi,\n                 });\n             }\n-            token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n             _ => {\n-                stmts.push(Spanned {\n-                    node: StmtKind::Expr(e, ast::DUMMY_NODE_ID),\n+                stmts.push(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Expr(e),\n                     span: span\n                 });\n             }\n@@ -4913,10 +4932,10 @@ impl<'a> Parser<'a> {\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n-            let m_ = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n+            let m_ = Mac_ { path: pth, tts: tts };\n             let m: ast::Mac = codemap::Spanned { node: m_,\n-                                                span: mk_sp(lo,\n-                                                            self.last_span.hi) };\n+                                                    span: mk_sp(lo,\n+                                                                self.last_span.hi) };\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n@@ -4940,7 +4959,6 @@ impl<'a> Parser<'a> {\n \n     /// Parse trait Foo { ... }\n     fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n-\n         let ident = self.parse_ident()?;\n         let mut tps = self.parse_generics()?;\n \n@@ -5255,7 +5273,7 @@ impl<'a> Parser<'a> {\n             return Err(self.fatal(&format!(\"expected item, found `{}`\", token_str)));\n         }\n \n-        let hi = if self.span == codemap::DUMMY_SP {\n+        let hi = if self.span == syntax_pos::DUMMY_SP {\n             inner_lo\n         } else {\n             self.last_span.hi\n@@ -5999,10 +6017,10 @@ impl<'a> Parser<'a> {\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n             // single-variant-enum... :\n-            let m = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n+            let m = Mac_ { path: pth, tts: tts };\n             let m: ast::Mac = codemap::Spanned { node: m,\n-                                             span: mk_sp(mac_lo,\n-                                                         self.last_span.hi) };\n+                                                 span: mk_sp(mac_lo,\n+                                                             self.last_span.hi) };\n \n             if delim != token::Brace {\n                 if !self.eat(&token::Semi) {"}, {"sha": "8376d28164dee58ad0b0f81354ec30a5e63a729b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,6 +19,7 @@ use ext::mtwt;\n use ptr::P;\n use util::interner::{RcStr, StrInterner};\n use util::interner;\n+use tokenstream;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n@@ -338,7 +339,7 @@ pub enum Nonterminal {\n     /// Stuff inside brackets for attributes\n     NtMeta(P<ast::MetaItem>),\n     NtPath(Box<ast::Path>),\n-    NtTT(P<ast::TokenTree>), // needs P'ed to break a circularity\n+    NtTT(P<tokenstream::TokenTree>), // needs P'ed to break a circularity\n     // These are not exposed to macros, but are used by quasiquote.\n     NtArm(ast::Arm),\n     NtImplItem(P<ast::ImplItem>),"}, {"sha": "b56cec72a956e0555a8b0d5a710c0378c8e72690", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 79, "deletions": 76, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -11,14 +11,14 @@\n pub use self::AnnNode::*;\n \n use abi::{self, Abi};\n-use ast::{self, TokenTree, BlockCheckMode, PatKind};\n+use ast::{self, BlockCheckMode, PatKind};\n use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n-use attr::ThinAttributesExt;\n use util::parser::AssocOp;\n use attr;\n use attr::{AttrMetaMethods, AttributeMethods};\n-use codemap::{self, CodeMap, BytePos};\n+use codemap::{self, CodeMap};\n+use syntax_pos::{self, BytePos};\n use errors;\n use parse::token::{self, keywords, BinOpToken, Token, InternedString};\n use parse::lexer::comments;\n@@ -28,6 +28,7 @@ use print::pp::{Breaks, eof};\n use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n+use tokenstream::{self, TokenTree};\n \n use std::ascii;\n use std::io::{self, Write, Read};\n@@ -330,11 +331,11 @@ pub fn lifetime_to_string(e: &ast::Lifetime) -> String {\n     to_string(|s| s.print_lifetime(e))\n }\n \n-pub fn tt_to_string(tt: &ast::TokenTree) -> String {\n+pub fn tt_to_string(tt: &tokenstream::TokenTree) -> String {\n     to_string(|s| s.print_tt(tt))\n }\n \n-pub fn tts_to_string(tts: &[ast::TokenTree]) -> String {\n+pub fn tts_to_string(tts: &[tokenstream::TokenTree]) -> String {\n     to_string(|s| s.print_tts(tts))\n }\n \n@@ -842,11 +843,11 @@ impl<'a> State<'a> {\n         self.end() // close the head-box\n     }\n \n-    pub fn bclose_(&mut self, span: codemap::Span,\n+    pub fn bclose_(&mut self, span: syntax_pos::Span,\n                    indented: usize) -> io::Result<()> {\n         self.bclose_maybe_open(span, indented, true)\n     }\n-    pub fn bclose_maybe_open(&mut self, span: codemap::Span,\n+    pub fn bclose_maybe_open(&mut self, span: syntax_pos::Span,\n                              indented: usize, close_box: bool) -> io::Result<()> {\n         try!(self.maybe_print_comment(span.hi));\n         try!(self.break_offset_if_not_bol(1, -(indented as isize)));\n@@ -856,7 +857,7 @@ impl<'a> State<'a> {\n         }\n         Ok(())\n     }\n-    pub fn bclose(&mut self, span: codemap::Span) -> io::Result<()> {\n+    pub fn bclose(&mut self, span: syntax_pos::Span) -> io::Result<()> {\n         self.bclose_(span, INDENT_UNIT)\n     }\n \n@@ -900,7 +901,7 @@ impl<'a> State<'a> {\n                                   mut op: F,\n                                   mut get_span: G) -> io::Result<()> where\n         F: FnMut(&mut State, &T) -> io::Result<()>,\n-        G: FnMut(&T) -> codemap::Span,\n+        G: FnMut(&T) -> syntax_pos::Span,\n     {\n         try!(self.rbox(0, b));\n         let len = elts.len();\n@@ -1352,7 +1353,7 @@ impl<'a> State<'a> {\n \n     pub fn print_enum_def(&mut self, enum_definition: &ast::EnumDef,\n                           generics: &ast::Generics, ident: ast::Ident,\n-                          span: codemap::Span,\n+                          span: syntax_pos::Span,\n                           visibility: &ast::Visibility) -> io::Result<()> {\n         try!(self.head(&visibility_qualified(visibility, \"enum\")));\n         try!(self.print_ident(ident));\n@@ -1364,7 +1365,7 @@ impl<'a> State<'a> {\n \n     pub fn print_variants(&mut self,\n                           variants: &[ast::Variant],\n-                          span: codemap::Span) -> io::Result<()> {\n+                          span: syntax_pos::Span) -> io::Result<()> {\n         try!(self.bopen());\n         for v in variants {\n             try!(self.space_if_not_bol());\n@@ -1393,7 +1394,7 @@ impl<'a> State<'a> {\n                         struct_def: &ast::VariantData,\n                         generics: &ast::Generics,\n                         ident: ast::Ident,\n-                        span: codemap::Span,\n+                        span: syntax_pos::Span,\n                         print_finalizer: bool) -> io::Result<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n@@ -1445,7 +1446,7 @@ impl<'a> State<'a> {\n     /// appropriate macro, transcribe back into the grammar we just parsed from,\n     /// and then pretty-print the resulting AST nodes (so, e.g., we print\n     /// expression arguments as expressions). It can be done! I think.\n-    pub fn print_tt(&mut self, tt: &ast::TokenTree) -> io::Result<()> {\n+    pub fn print_tt(&mut self, tt: &tokenstream::TokenTree) -> io::Result<()> {\n         match *tt {\n             TokenTree::Token(_, ref tk) => {\n                 try!(word(&mut self.s, &token_to_string(tk)));\n@@ -1476,14 +1477,14 @@ impl<'a> State<'a> {\n                     None => {},\n                 }\n                 match seq.op {\n-                    ast::KleeneOp::ZeroOrMore => word(&mut self.s, \"*\"),\n-                    ast::KleeneOp::OneOrMore => word(&mut self.s, \"+\"),\n+                    tokenstream::KleeneOp::ZeroOrMore => word(&mut self.s, \"*\"),\n+                    tokenstream::KleeneOp::OneOrMore => word(&mut self.s, \"+\"),\n                 }\n             }\n         }\n     }\n \n-    pub fn print_tts(&mut self, tts: &[ast::TokenTree]) -> io::Result<()> {\n+    pub fn print_tts(&mut self, tts: &[tokenstream::TokenTree]) -> io::Result<()> {\n         try!(self.ibox(0));\n         for (i, tt) in tts.iter().enumerate() {\n             if i != 0 {\n@@ -1550,6 +1551,17 @@ impl<'a> State<'a> {\n                 try!(self.print_associated_type(ti.ident, Some(bounds),\n                                            default.as_ref().map(|ty| &**ty)));\n             }\n+            ast::TraitItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n+                // code copied from ItemKind::Mac:\n+                self.print_path(&node.path, false, 0)?;\n+                word(&mut self.s, \"! \")?;\n+                self.cbox(INDENT_UNIT)?;\n+                self.popen()?;\n+                self.print_tts(&node.tts[..])?;\n+                self.pclose()?;\n+                word(&mut self.s, \";\")?;\n+                self.end()?\n+            }\n         }\n         self.ann.post(self, NodeSubItem(ti.id))\n     }\n@@ -1593,21 +1605,40 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n-            ast::StmtKind::Decl(ref decl, _) => {\n-                try!(self.print_decl(&decl));\n+            ast::StmtKind::Local(ref loc) => {\n+                try!(self.print_outer_attributes(&loc.attrs));\n+                try!(self.space_if_not_bol());\n+                try!(self.ibox(INDENT_UNIT));\n+                try!(self.word_nbsp(\"let\"));\n+\n+                try!(self.ibox(INDENT_UNIT));\n+                try!(self.print_local_decl(&loc));\n+                try!(self.end());\n+                if let Some(ref init) = loc.init {\n+                    try!(self.nbsp());\n+                    try!(self.word_space(\"=\"));\n+                    try!(self.print_expr(&init));\n+                }\n+                try!(word(&mut self.s, \";\"));\n+                self.end()?;\n             }\n-            ast::StmtKind::Expr(ref expr, _) => {\n+            ast::StmtKind::Item(ref item) => self.print_item(&item)?,\n+            ast::StmtKind::Expr(ref expr) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&expr, false));\n+                if parse::classify::expr_requires_semi_to_be_stmt(expr) {\n+                    try!(word(&mut self.s, \";\"));\n+                }\n             }\n-            ast::StmtKind::Semi(ref expr, _) => {\n+            ast::StmtKind::Semi(ref expr) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&expr, false));\n                 try!(word(&mut self.s, \";\"));\n             }\n-            ast::StmtKind::Mac(ref mac, style, ref attrs) => {\n+            ast::StmtKind::Mac(ref mac) => {\n+                let (ref mac, style, ref attrs) = **mac;\n                 try!(self.space_if_not_bol());\n-                try!(self.print_outer_attributes(attrs.as_attr_slice()));\n+                try!(self.print_outer_attributes(&attrs));\n                 let delim = match style {\n                     ast::MacStmtStyle::Braces => token::Brace,\n                     _ => token::Paren\n@@ -1619,9 +1650,6 @@ impl<'a> State<'a> {\n                 }\n             }\n         }\n-        if parse::classify::stmt_ends_with_semi(&st.node) {\n-            try!(word(&mut self.s, \";\"));\n-        }\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n@@ -1665,17 +1693,17 @@ impl<'a> State<'a> {\n \n         try!(self.print_inner_attributes(attrs));\n \n-        for st in &blk.stmts {\n-            try!(self.print_stmt(st));\n-        }\n-        match blk.expr {\n-            Some(ref expr) => {\n-                try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&expr, false));\n-                try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n+        for (i, st) in blk.stmts.iter().enumerate() {\n+            match st.node {\n+                ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n+                    try!(self.space_if_not_bol());\n+                    try!(self.print_expr_outer_attr_style(&expr, false));\n+                    try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n+                }\n+                _ => try!(self.print_stmt(st)),\n             }\n-            _ => ()\n         }\n+\n         try!(self.bclose_maybe_open(blk.span, indented, close_box));\n         self.ann.post(self, NodeBlock(blk))\n     }\n@@ -1947,7 +1975,7 @@ impl<'a> State<'a> {\n                                   is_inline: bool) -> io::Result<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n \n-        let attrs = expr.attrs.as_attr_slice();\n+        let attrs = &expr.attrs;\n         if is_inline {\n             try!(self.print_outer_attributes_inline(attrs));\n         } else {\n@@ -2084,24 +2112,21 @@ impl<'a> State<'a> {\n                     _ => false\n                 };\n \n-                if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    try!(self.print_block_unclosed(&body));\n-                } else {\n-                    // we extract the block, so as not to create another set of boxes\n-                    let i_expr = body.expr.as_ref().unwrap();\n-                    match i_expr.node {\n-                        ast::ExprKind::Block(ref blk) => {\n-                            try!(self.print_block_unclosed_with_attrs(\n-                                &blk,\n-                                i_expr.attrs.as_attr_slice()));\n-                        }\n-                        _ => {\n+                match body.stmts.last().map(|stmt| &stmt.node) {\n+                    Some(&ast::StmtKind::Expr(ref i_expr)) if default_return &&\n+                                                              body.stmts.len() == 1 => {\n+                        // we extract the block, so as not to create another set of boxes\n+                        if let ast::ExprKind::Block(ref blk) = i_expr.node {\n+                            try!(self.print_block_unclosed_with_attrs(&blk, &i_expr.attrs));\n+                        } else {\n                             // this is a bare expression\n                             try!(self.print_expr(&i_expr));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n+                    _ => try!(self.print_block_unclosed(&body)),\n                 }\n+\n                 // a box will be closed by print_expr, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close.\n@@ -2170,7 +2195,7 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s));\n                 }\n             }\n-            ast::ExprKind::Again(opt_ident) => {\n+            ast::ExprKind::Continue(opt_ident) => {\n                 try!(word(&mut self.s, \"continue\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n@@ -2278,29 +2303,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_decl(&mut self, decl: &ast::Decl) -> io::Result<()> {\n-        try!(self.maybe_print_comment(decl.span.lo));\n-        match decl.node {\n-            ast::DeclKind::Local(ref loc) => {\n-                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n-                try!(self.space_if_not_bol());\n-                try!(self.ibox(INDENT_UNIT));\n-                try!(self.word_nbsp(\"let\"));\n-\n-                try!(self.ibox(INDENT_UNIT));\n-                try!(self.print_local_decl(&loc));\n-                try!(self.end());\n-                if let Some(ref init) = loc.init {\n-                    try!(self.nbsp());\n-                    try!(self.word_space(\"=\"));\n-                    try!(self.print_expr(&init));\n-                }\n-                self.end()\n-            }\n-            ast::DeclKind::Item(ref item) => self.print_item(&item)\n-        }\n-    }\n-\n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         try!(word(&mut self.s, &ident.name.as_str()));\n         self.ann.post(self, NodeIdent(&ident))\n@@ -2483,10 +2485,10 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n-            PatKind::Path(ref path) => {\n+            PatKind::Path(None, ref path) => {\n                 try!(self.print_path(path, true, 0));\n             }\n-            PatKind::QPath(ref qself, ref path) => {\n+            PatKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, false));\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n@@ -2999,7 +3001,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn maybe_print_trailing_comment(&mut self, span: codemap::Span,\n+    pub fn maybe_print_trailing_comment(&mut self, span: syntax_pos::Span,\n                                         next_pos: Option<BytePos>)\n         -> io::Result<()> {\n         let cm = match self.cm {\n@@ -3104,14 +3106,15 @@ mod tests {\n     use ast;\n     use codemap;\n     use parse::token;\n+    use syntax_pos;\n \n     #[test]\n     fn test_fun_to_string() {\n         let abba_ident = token::str_to_ident(\"abba\");\n \n         let decl = ast::FnDecl {\n             inputs: Vec::new(),\n-            output: ast::FunctionRetTy::Default(codemap::DUMMY_SP),\n+            output: ast::FunctionRetTy::Default(syntax_pos::DUMMY_SP),\n             variadic: false\n         };\n         let generics = ast::Generics::default();\n@@ -3125,7 +3128,7 @@ mod tests {\n     fn test_variant_to_string() {\n         let ident = token::str_to_ident(\"principal_skinner\");\n \n-        let var = codemap::respan(codemap::DUMMY_SP, ast::Variant_ {\n+        let var = codemap::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n             name: ident,\n             attrs: Vec::new(),\n             // making this up as I go.... ?"}, {"sha": "928ffb202d0b331594608d40be1c3cc00ed4c22d", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -44,7 +44,7 @@ struct ShowSpanVisitor<'a> {\n     mode: Mode,\n }\n \n-impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n+impl<'a> Visitor for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         if let Mode::Expression = self.mode {\n             self.span_diagnostic.span_warn(e.span, \"expression\");"}, {"sha": "d1454ab06cbc8179bbb87b294777d68e2ef6f46f", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -10,8 +10,8 @@\n \n use ast;\n use attr;\n-use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n-use codemap;\n+use syntax_pos::{DUMMY_SP, Span};\n+use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n use parse::token::{intern, InternedString, keywords};\n use parse::{token, ParseSess};\n use ptr::P;"}, {"sha": "0a60b7fd430c427277fcbe33cf3d7668388c9ae5", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,6 +12,7 @@\n \n #![allow(dead_code)]\n #![allow(unused_imports)]\n+\n use self::HasTestSignature::*;\n \n use std::iter;\n@@ -20,9 +21,12 @@ use std::mem;\n use std::vec;\n use attr::AttrMetaMethods;\n use attr;\n-use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n-use codemap;\n+use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n+use std::rc::Rc;\n+\n+use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute};\n use errors;\n+use errors::snippet::{RenderedLine, SnippetData};\n use config;\n use entry::{self, EntryPointType};\n use ext::base::{ExtCtxt, DummyMacroLoader};\n@@ -474,7 +478,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n-    let main_body = ecx.block_all(sp, vec![call_test_main], None);\n+    let main_body = ecx.block(sp, vec![call_test_main]);\n     let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal,\n                            ast::Constness::NotConst,\n@@ -604,10 +608,10 @@ fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n                     mk_test_desc_and_fn_rec(cx, test)\n                 }).collect()),\n                 span: DUMMY_SP,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             })),\n         span: DUMMY_SP,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     })\n }\n "}, {"sha": "35377d14bab7cc0fe4618fb7be541311b1a987c9", "filename": "src/libsyntax/tokenstream.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,210 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Token Trees\n+//! TokenTrees are syntactic forms for dealing with tokens. The description below is\n+//! more complete; in short a TokenTree is a single token, a delimited sequence of token\n+//! trees, or a sequence with repetition for list splicing as part of macro expansion.\n+\n+use ast::{AttrStyle};\n+use codemap::{Span};\n+use ext::base;\n+use ext::tt::macro_parser;\n+use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use parse::lexer;\n+use parse::token;\n+\n+/// A delimited sequence of token trees\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Delimited {\n+    /// The type of delimiter\n+    pub delim: token::DelimToken,\n+    /// The span covering the opening delimiter\n+    pub open_span: Span,\n+    /// The delimited sequence of token trees\n+    pub tts: Vec<TokenTree>,\n+    /// The span covering the closing delimiter\n+    pub close_span: Span,\n+}\n+\n+impl Delimited {\n+    /// Returns the opening delimiter as a token.\n+    pub fn open_token(&self) -> token::Token {\n+        token::OpenDelim(self.delim)\n+    }\n+\n+    /// Returns the closing delimiter as a token.\n+    pub fn close_token(&self) -> token::Token {\n+        token::CloseDelim(self.delim)\n+    }\n+\n+    /// Returns the opening delimiter as a token tree.\n+    pub fn open_tt(&self) -> TokenTree {\n+        TokenTree::Token(self.open_span, self.open_token())\n+    }\n+\n+    /// Returns the closing delimiter as a token tree.\n+    pub fn close_tt(&self) -> TokenTree {\n+        TokenTree::Token(self.close_span, self.close_token())\n+    }\n+}\n+\n+/// A sequence of token trees\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct SequenceRepetition {\n+    /// The sequence of token trees\n+    pub tts: Vec<TokenTree>,\n+    /// The optional separator\n+    pub separator: Option<token::Token>,\n+    /// Whether the sequence can be repeated zero (*), or one or more times (+)\n+    pub op: KleeneOp,\n+    /// The number of `MatchNt`s that appear in the sequence (and subsequences)\n+    pub num_captures: usize,\n+}\n+\n+/// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n+/// for token sequences.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum KleeneOp {\n+    ZeroOrMore,\n+    OneOrMore,\n+}\n+\n+/// When the main rust parser encounters a syntax-extension invocation, it\n+/// parses the arguments to the invocation as a token-tree. This is a very\n+/// loose structure, such that all sorts of different AST-fragments can\n+/// be passed to syntax extensions using a uniform type.\n+///\n+/// If the syntax extension is an MBE macro, it will attempt to match its\n+/// LHS token tree against the provided token tree, and if it finds a\n+/// match, will transcribe the RHS token tree, splicing in any captured\n+/// macro_parser::matched_nonterminals into the `SubstNt`s it finds.\n+///\n+/// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n+/// Nothing special happens to misnamed or misplaced `SubstNt`s.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TokenTree {\n+    /// A single token\n+    Token(Span, token::Token),\n+    /// A delimited sequence of token trees\n+    Delimited(Span, Delimited),\n+\n+    // This only makes sense in MBE macros.\n+\n+    /// A kleene-style repetition sequence with a span\n+    // FIXME(eddyb) #12938 Use DST.\n+    Sequence(Span, SequenceRepetition),\n+}\n+\n+impl TokenTree {\n+    pub fn len(&self) -> usize {\n+        match *self {\n+            TokenTree::Token(_, token::DocComment(name)) => {\n+                match doc_comment_style(&name.as_str()) {\n+                    AttrStyle::Outer => 2,\n+                    AttrStyle::Inner => 3\n+                }\n+            }\n+            TokenTree::Token(_, token::SpecialVarNt(..)) => 2,\n+            TokenTree::Token(_, token::MatchNt(..)) => 3,\n+            TokenTree::Delimited(_, ref delimed) => {\n+                delimed.tts.len() + 2\n+            }\n+            TokenTree::Sequence(_, ref seq) => {\n+                seq.tts.len()\n+            }\n+            TokenTree::Token(..) => 0\n+        }\n+    }\n+\n+    pub fn get_tt(&self, index: usize) -> TokenTree {\n+        match (self, index) {\n+            (&TokenTree::Token(sp, token::DocComment(_)), 0) => {\n+                TokenTree::Token(sp, token::Pound)\n+            }\n+            (&TokenTree::Token(sp, token::DocComment(name)), 1)\n+            if doc_comment_style(&name.as_str()) == AttrStyle::Inner => {\n+                TokenTree::Token(sp, token::Not)\n+            }\n+            (&TokenTree::Token(sp, token::DocComment(name)), _) => {\n+                let stripped = strip_doc_comment_decoration(&name.as_str());\n+\n+                // Searches for the occurrences of `\"#*` and returns the minimum number of `#`s\n+                // required to wrap the text.\n+                let num_of_hashes = stripped.chars().scan(0, |cnt, x| {\n+                    *cnt = if x == '\"' {\n+                        1\n+                    } else if *cnt != 0 && x == '#' {\n+                        *cnt + 1\n+                    } else {\n+                        0\n+                    };\n+                    Some(*cnt)\n+                }).max().unwrap_or(0);\n+\n+                TokenTree::Delimited(sp, Delimited {\n+                    delim: token::Bracket,\n+                    open_span: sp,\n+                    tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"))),\n+                              TokenTree::Token(sp, token::Eq),\n+                              TokenTree::Token(sp, token::Literal(\n+                                  token::StrRaw(token::intern(&stripped), num_of_hashes), None))],\n+                    close_span: sp,\n+                })\n+            }\n+            (&TokenTree::Delimited(_, ref delimed), _) => {\n+                if index == 0 {\n+                    return delimed.open_tt();\n+                }\n+                if index == delimed.tts.len() + 1 {\n+                    return delimed.close_tt();\n+                }\n+                delimed.tts[index - 1].clone()\n+            }\n+            (&TokenTree::Token(sp, token::SpecialVarNt(var)), _) => {\n+                let v = [TokenTree::Token(sp, token::Dollar),\n+                         TokenTree::Token(sp, token::Ident(token::str_to_ident(var.as_str())))];\n+                v[index].clone()\n+            }\n+            (&TokenTree::Token(sp, token::MatchNt(name, kind)), _) => {\n+                let v = [TokenTree::Token(sp, token::SubstNt(name)),\n+                         TokenTree::Token(sp, token::Colon),\n+                         TokenTree::Token(sp, token::Ident(kind))];\n+                v[index].clone()\n+            }\n+            (&TokenTree::Sequence(_, ref seq), _) => {\n+                seq.tts[index].clone()\n+            }\n+            _ => panic!(\"Cannot expand a token tree\")\n+        }\n+    }\n+\n+    /// Returns the `Span` corresponding to this token tree.\n+    pub fn get_span(&self) -> Span {\n+        match *self {\n+            TokenTree::Token(span, _)     => span,\n+            TokenTree::Delimited(span, _) => span,\n+            TokenTree::Sequence(span, _)  => span,\n+        }\n+    }\n+\n+    /// Use this token tree as a matcher to parse given tts.\n+    pub fn parse(cx: &base::ExtCtxt, mtch: &[TokenTree], tts: &[TokenTree])\n+                 -> macro_parser::NamedParseResult {\n+        // `None` is because we're not interpolating\n+        let arg_rdr = lexer::new_tt_reader_with_doc_flag(&cx.parse_sess().span_diagnostic,\n+                                                         None,\n+                                                         None,\n+                                                         tts.iter().cloned().collect(),\n+                                                         true);\n+        macro_parser::parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtch)\n+    }\n+}\n+"}, {"sha": "14244bbdddf28c05cf1ab6c04bbf5d29e54f1cb2", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,7 +12,7 @@\n \n use visit::*;\n use ast::*;\n-use codemap::Span;\n+use syntax_pos::Span;\n \n pub struct NodeCounter {\n     pub count: usize,\n@@ -26,133 +26,129 @@ impl NodeCounter {\n     }\n }\n \n-impl<'v> Visitor<'v> for NodeCounter {\n+impl Visitor for NodeCounter {\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n         self.count += 1;\n         walk_ident(self, span, ident);\n     }\n-    fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) {\n+    fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) {\n         self.count += 1;\n         walk_mod(self, m)\n     }\n-    fn visit_foreign_item(&mut self, i: &'v ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &ForeignItem) {\n         self.count += 1;\n         walk_foreign_item(self, i)\n     }\n-    fn visit_item(&mut self, i: &'v Item) {\n+    fn visit_item(&mut self, i: &Item) {\n         self.count += 1;\n         walk_item(self, i)\n     }\n-    fn visit_local(&mut self, l: &'v Local) {\n+    fn visit_local(&mut self, l: &Local) {\n         self.count += 1;\n         walk_local(self, l)\n     }\n-    fn visit_block(&mut self, b: &'v Block) {\n+    fn visit_block(&mut self, b: &Block) {\n         self.count += 1;\n         walk_block(self, b)\n     }\n-    fn visit_stmt(&mut self, s: &'v Stmt) {\n+    fn visit_stmt(&mut self, s: &Stmt) {\n         self.count += 1;\n         walk_stmt(self, s)\n     }\n-    fn visit_arm(&mut self, a: &'v Arm) {\n+    fn visit_arm(&mut self, a: &Arm) {\n         self.count += 1;\n         walk_arm(self, a)\n     }\n-    fn visit_pat(&mut self, p: &'v Pat) {\n+    fn visit_pat(&mut self, p: &Pat) {\n         self.count += 1;\n         walk_pat(self, p)\n     }\n-    fn visit_decl(&mut self, d: &'v Decl) {\n-        self.count += 1;\n-        walk_decl(self, d)\n-    }\n-    fn visit_expr(&mut self, ex: &'v Expr) {\n+    fn visit_expr(&mut self, ex: &Expr) {\n         self.count += 1;\n         walk_expr(self, ex)\n     }\n-    fn visit_ty(&mut self, t: &'v Ty) {\n+    fn visit_ty(&mut self, t: &Ty) {\n         self.count += 1;\n         walk_ty(self, t)\n     }\n-    fn visit_generics(&mut self, g: &'v Generics) {\n+    fn visit_generics(&mut self, g: &Generics) {\n         self.count += 1;\n         walk_generics(self, g)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n         self.count += 1;\n         walk_fn(self, fk, fd, b, s)\n     }\n-    fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &TraitItem) {\n         self.count += 1;\n         walk_trait_item(self, ti)\n     }\n-    fn visit_impl_item(&mut self, ii: &'v ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &ImplItem) {\n         self.count += 1;\n         walk_impl_item(self, ii)\n     }\n-    fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n+    fn visit_trait_ref(&mut self, t: &TraitRef) {\n         self.count += 1;\n         walk_trait_ref(self, t)\n     }\n-    fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n+    fn visit_ty_param_bound(&mut self, bounds: &TyParamBound) {\n         self.count += 1;\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &PolyTraitRef, m: &TraitBoundModifier) {\n         self.count += 1;\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_variant_data(&mut self, s: &'v VariantData, _: Ident,\n-                        _: &'v Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &VariantData, _: Ident,\n+                          _: &Generics, _: NodeId, _: Span) {\n         self.count += 1;\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &'v StructField) {\n+    fn visit_struct_field(&mut self, s: &StructField) {\n         self.count += 1;\n         walk_struct_field(self, s)\n     }\n-    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n-                      generics: &'v Generics, item_id: NodeId, _: Span) {\n+    fn visit_enum_def(&mut self, enum_definition: &EnumDef,\n+                      generics: &Generics, item_id: NodeId, _: Span) {\n         self.count += 1;\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n         self.count += 1;\n         walk_variant(self, v, g, item_id)\n     }\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n         self.count += 1;\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lifetime: &LifetimeDef) {\n         self.count += 1;\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_mac(&mut self, _mac: &'v Mac) {\n+    fn visit_mac(&mut self, _mac: &Mac) {\n         self.count += 1;\n         walk_mac(self, _mac)\n     }\n-    fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n+    fn visit_path(&mut self, path: &Path, _id: NodeId) {\n         self.count += 1;\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &'v Path, item: &'v PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &Path, item: &PathListItem) {\n         self.count += 1;\n         walk_path_list_item(self, prefix, item)\n     }\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &PathParameters) {\n         self.count += 1;\n         walk_path_parameters(self, path_span, path_parameters)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) {\n         self.count += 1;\n         walk_assoc_type_binding(self, type_binding)\n     }\n-    fn visit_attribute(&mut self, _attr: &'v Attribute) {\n+    fn visit_attribute(&mut self, _attr: &Attribute) {\n         self.count += 1;\n     }\n-    fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         self.count += 1;\n         walk_macro_def(self, macro_def)\n     }"}, {"sha": "f59428bf536cfdd73e7e0196a9ddd5ef025c3493", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,10 +14,11 @@ use parse::{lexer, new_parser_from_source_str};\n use parse::parser::Parser;\n use parse::token;\n use ptr::P;\n+use tokenstream;\n use std::iter::Peekable;\n \n /// Map a string to tts, using a made-up filename:\n-pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n+pub fn string_to_tts(source_str: String) -> Vec<tokenstream::TokenTree> {\n     let ps = ParseSess::new();\n     filemap_to_tts(&ps, ps.codemap().new_filemap(\"bogofile\".to_string(), None, source_str))\n }"}, {"sha": "546686b46b8db4c92f2474b4f64ee354938cbe5a", "filename": "src/libsyntax/util/thin_vec.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Futil%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Futil%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fthin_vec.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A vector type optimized for cases where this size is usually 0 (c.f. `SmallVector`).\n+/// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n+/// which uses only a single (null) pointer.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ThinVec<T>(Option<Box<Vec<T>>>);\n+\n+impl<T> ThinVec<T> {\n+    pub fn new() -> Self {\n+        ThinVec(None)\n+    }\n+}\n+\n+impl<T> From<Vec<T>> for ThinVec<T> {\n+    fn from(vec: Vec<T>) -> Self {\n+        if vec.is_empty() {\n+            ThinVec(None)\n+        } else {\n+            ThinVec(Some(Box::new(vec)))\n+        }\n+    }\n+}\n+\n+impl<T> Into<Vec<T>> for ThinVec<T> {\n+    fn into(self) -> Vec<T> {\n+        match self {\n+            ThinVec(None) => Vec::new(),\n+            ThinVec(Some(vec)) => *vec,\n+        }\n+    }\n+}\n+\n+impl<T> ::std::ops::Deref for ThinVec<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        match *self {\n+            ThinVec(None) => &[],\n+            ThinVec(Some(ref vec)) => vec,\n+        }\n+    }\n+}\n+\n+impl<T> Extend<T> for ThinVec<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        match *self {\n+            ThinVec(Some(ref mut vec)) => vec.extend(iter),\n+            ThinVec(None) => *self = iter.into_iter().collect::<Vec<_>>().into(),\n+        }\n+    }\n+}"}, {"sha": "1fc4e54d21807c26145f6d10e98e7d85f34eed15", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 106, "deletions": 130, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -25,8 +25,8 @@\n \n use abi::Abi;\n use ast::*;\n-use attr::ThinAttributesExt;\n-use codemap::{Span, Spanned};\n+use syntax_pos::Span;\n+use codemap::Spanned;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n@@ -49,84 +49,83 @@ pub enum FnKind<'a> {\n /// explicitly, you need to override each method.  (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor<'v> : Sized {\n+pub trait Visitor: Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n         walk_ident(self, span, ident);\n     }\n-    fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n-    fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n-    fn visit_item(&mut self, i: &'v Item) { walk_item(self, i) }\n-    fn visit_local(&mut self, l: &'v Local) { walk_local(self, l) }\n-    fn visit_block(&mut self, b: &'v Block) { walk_block(self, b) }\n-    fn visit_stmt(&mut self, s: &'v Stmt) { walk_stmt(self, s) }\n-    fn visit_arm(&mut self, a: &'v Arm) { walk_arm(self, a) }\n-    fn visit_pat(&mut self, p: &'v Pat) { walk_pat(self, p) }\n-    fn visit_decl(&mut self, d: &'v Decl) { walk_decl(self, d) }\n-    fn visit_expr(&mut self, ex: &'v Expr) { walk_expr(self, ex) }\n-    fn visit_expr_post(&mut self, _ex: &'v Expr) { }\n-    fn visit_ty(&mut self, t: &'v Ty) { walk_ty(self, t) }\n-    fn visit_generics(&mut self, g: &'v Generics) { walk_generics(self, g) }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n+    fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n+    fn visit_foreign_item(&mut self, i: &ForeignItem) { walk_foreign_item(self, i) }\n+    fn visit_item(&mut self, i: &Item) { walk_item(self, i) }\n+    fn visit_local(&mut self, l: &Local) { walk_local(self, l) }\n+    fn visit_block(&mut self, b: &Block) { walk_block(self, b) }\n+    fn visit_stmt(&mut self, s: &Stmt) { walk_stmt(self, s) }\n+    fn visit_arm(&mut self, a: &Arm) { walk_arm(self, a) }\n+    fn visit_pat(&mut self, p: &Pat) { walk_pat(self, p) }\n+    fn visit_expr(&mut self, ex: &Expr) { walk_expr(self, ex) }\n+    fn visit_expr_post(&mut self, _ex: &Expr) { }\n+    fn visit_ty(&mut self, t: &Ty) { walk_ty(self, t) }\n+    fn visit_generics(&mut self, g: &Generics) { walk_generics(self, g) }\n+    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, b, s)\n     }\n-    fn visit_trait_item(&mut self, ti: &'v TraitItem) { walk_trait_item(self, ti) }\n-    fn visit_impl_item(&mut self, ii: &'v ImplItem) { walk_impl_item(self, ii) }\n-    fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n-    fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n+    fn visit_trait_item(&mut self, ti: &TraitItem) { walk_trait_item(self, ti) }\n+    fn visit_impl_item(&mut self, ii: &ImplItem) { walk_impl_item(self, ii) }\n+    fn visit_trait_ref(&mut self, t: &TraitRef) { walk_trait_ref(self, t) }\n+    fn visit_ty_param_bound(&mut self, bounds: &TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &PolyTraitRef, m: &TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_variant_data(&mut self, s: &'v VariantData, _: Ident,\n-                        _: &'v Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &VariantData, _: Ident,\n+                          _: &Generics, _: NodeId, _: Span) {\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &'v StructField) { walk_struct_field(self, s) }\n-    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n-                      generics: &'v Generics, item_id: NodeId, _: Span) {\n+    fn visit_struct_field(&mut self, s: &StructField) { walk_struct_field(self, s) }\n+    fn visit_enum_def(&mut self, enum_definition: &EnumDef,\n+                      generics: &Generics, item_id: NodeId, _: Span) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n         walk_variant(self, v, g, item_id)\n     }\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lifetime: &LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_mac(&mut self, _mac: &'v Mac) {\n+    fn visit_mac(&mut self, _mac: &Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a visitor that\n         // works on macros, use this\n         // definition in your trait impl:\n         // visit::walk_mac(self, _mac)\n     }\n-    fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n+    fn visit_path(&mut self, path: &Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &'v Path, item: &'v PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &Path, item: &PathListItem) {\n         walk_path_list_item(self, prefix, item)\n     }\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n-    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &PathParameters) {\n         walk_path_parameters(self, path_span, path_parameters)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) {\n         walk_assoc_type_binding(self, type_binding)\n     }\n-    fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n-    fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n+    fn visit_attribute(&mut self, _attr: &Attribute) {}\n+    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         walk_macro_def(self, macro_def)\n     }\n-    fn visit_vis(&mut self, vis: &'v Visibility) {\n+    fn visit_vis(&mut self, vis: &Visibility) {\n         walk_vis(self, vis)\n     }\n }\n@@ -145,81 +144,74 @@ macro_rules! walk_list {\n     }\n }\n \n-pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n+pub fn walk_opt_name<V: Visitor>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n     if let Some(name) = opt_name {\n         visitor.visit_name(span, name);\n     }\n }\n \n-pub fn walk_opt_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n+pub fn walk_opt_ident<V: Visitor>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n     if let Some(ident) = opt_ident {\n         visitor.visit_ident(span, ident);\n     }\n }\n \n-pub fn walk_opt_sp_ident<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             opt_sp_ident: &Option<Spanned<Ident>>) {\n+pub fn walk_opt_sp_ident<V: Visitor>(visitor: &mut V, opt_sp_ident: &Option<Spanned<Ident>>) {\n     if let Some(ref sp_ident) = *opt_sp_ident {\n         visitor.visit_ident(sp_ident.span, sp_ident.node);\n     }\n }\n \n-pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n+pub fn walk_ident<V: Visitor>(visitor: &mut V, span: Span, ident: Ident) {\n     visitor.visit_name(span, ident.name);\n }\n \n-pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n+pub fn walk_crate<V: Visitor>(visitor: &mut V, krate: &Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n     walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n }\n \n-pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n+pub fn walk_macro_def<V: Visitor>(visitor: &mut V, macro_def: &MacroDef) {\n     visitor.visit_ident(macro_def.span, macro_def.ident);\n     walk_opt_ident(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n+pub fn walk_mod<V: Visitor>(visitor: &mut V, module: &Mod) {\n     walk_list!(visitor, visit_item, &module.items);\n }\n \n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n-    for attr in local.attrs.as_attr_slice() {\n+pub fn walk_local<V: Visitor>(visitor: &mut V, local: &Local) {\n+    for attr in local.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n     walk_list!(visitor, visit_expr, &local.init);\n }\n \n-pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+pub fn walk_lifetime<V: Visitor>(visitor: &mut V, lifetime: &Lifetime) {\n     visitor.visit_name(lifetime.span, lifetime.name);\n }\n \n-pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              lifetime_def: &'v LifetimeDef) {\n+pub fn walk_lifetime_def<V: Visitor>(visitor: &mut V, lifetime_def: &LifetimeDef) {\n     visitor.visit_lifetime(&lifetime_def.lifetime);\n     walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n-pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n-                                  trait_ref: &'v PolyTraitRef,\n-                                  _modifier: &'v TraitBoundModifier)\n-    where V: Visitor<'v>\n+pub fn walk_poly_trait_ref<V>(visitor: &mut V, trait_ref: &PolyTraitRef, _: &TraitBoundModifier)\n+    where V: Visitor,\n {\n     walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n-pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n-                                   trait_ref: &'v TraitRef)\n-    where V: Visitor<'v>\n-{\n+pub fn walk_trait_ref<V: Visitor>(visitor: &mut V, trait_ref: &TraitRef) {\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n }\n \n-pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n+pub fn walk_item<V: Visitor>(visitor: &mut V, item: &Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n@@ -298,25 +290,24 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n-pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                         enum_definition: &'v EnumDef,\n-                                         generics: &'v Generics,\n-                                         item_id: NodeId) {\n+pub fn walk_enum_def<V: Visitor>(visitor: &mut V,\n+                                 enum_definition: &EnumDef,\n+                                 generics: &Generics,\n+                                 item_id: NodeId) {\n     walk_list!(visitor, visit_variant, &enum_definition.variants, generics, item_id);\n }\n \n-pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                        variant: &'v Variant,\n-                                        generics: &'v Generics,\n-                                        item_id: NodeId) {\n+pub fn walk_variant<V>(visitor: &mut V, variant: &Variant, generics: &Generics, item_id: NodeId)\n+    where V: Visitor,\n+{\n     visitor.visit_ident(variant.span, variant.node.name);\n     visitor.visit_variant_data(&variant.node.data, variant.node.name,\n                              generics, item_id, variant.span);\n     walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n-pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n+pub fn walk_ty<V: Visitor>(visitor: &mut V, typ: &Ty) {\n     match typ.node {\n         TyKind::Vec(ref ty) | TyKind::Paren(ref ty) => {\n             visitor.visit_ty(ty)\n@@ -362,28 +353,25 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n+pub fn walk_path<V: Visitor>(visitor: &mut V, path: &Path) {\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n }\n \n-pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, _prefix: &'v Path,\n-                                               item: &'v PathListItem) {\n+pub fn walk_path_list_item<V: Visitor>(visitor: &mut V, _prefix: &Path, item: &PathListItem) {\n     walk_opt_ident(visitor, item.span, item.node.name());\n     walk_opt_ident(visitor, item.span, item.node.rename());\n }\n \n-pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             path_span: Span,\n-                                             segment: &'v PathSegment) {\n+pub fn walk_path_segment<V: Visitor>(visitor: &mut V, path_span: Span, segment: &PathSegment) {\n     visitor.visit_ident(path_span, segment.identifier);\n     visitor.visit_path_parameters(path_span, &segment.parameters);\n }\n \n-pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                _path_span: Span,\n-                                                path_parameters: &'v PathParameters) {\n+pub fn walk_path_parameters<V>(visitor: &mut V, _path_span: Span, path_parameters: &PathParameters)\n+    where V: Visitor,\n+{\n     match *path_parameters {\n         PathParameters::AngleBracketed(ref data) => {\n             walk_list!(visitor, visit_ty, &data.types);\n@@ -397,23 +385,21 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                   type_binding: &'v TypeBinding) {\n+pub fn walk_assoc_type_binding<V: Visitor>(visitor: &mut V, type_binding: &TypeBinding) {\n     visitor.visit_ident(type_binding.span, type_binding.ident);\n     visitor.visit_ty(&type_binding.ty);\n }\n \n-pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n+pub fn walk_pat<V: Visitor>(visitor: &mut V, pattern: &Pat) {\n     match pattern.node {\n         PatKind::TupleStruct(ref path, ref children, _) => {\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, children);\n         }\n-        PatKind::Path(ref path) => {\n-            visitor.visit_path(path, pattern.id);\n-        }\n-        PatKind::QPath(ref qself, ref path) => {\n-            visitor.visit_ty(&qself.ty);\n+        PatKind::Path(ref opt_qself, ref path) => {\n+            if let Some(ref qself) = *opt_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, pattern.id)\n         }\n         PatKind::Struct(ref path, ref fields, _) => {\n@@ -449,8 +435,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     }\n }\n \n-pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             foreign_item: &'v ForeignItem) {\n+pub fn walk_foreign_item<V: Visitor>(visitor: &mut V, foreign_item: &ForeignItem) {\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.span, foreign_item.ident);\n \n@@ -465,8 +450,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n     walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n }\n \n-pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                               bound: &'v TyParamBound) {\n+pub fn walk_ty_param_bound<V: Visitor>(visitor: &mut V, bound: &TyParamBound) {\n     match *bound {\n         TraitTyParamBound(ref typ, ref modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n@@ -477,7 +461,7 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n+pub fn walk_generics<V: Visitor>(visitor: &mut V, generics: &Generics) {\n     for param in &generics.ty_params {\n         visitor.visit_ident(param.span, param.ident);\n         walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n@@ -511,22 +495,21 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n+pub fn walk_fn_ret_ty<V: Visitor>(visitor: &mut V, ret_ty: &FunctionRetTy) {\n     if let FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n \n-pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n+pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, function_declaration: &FnDecl) {\n     for argument in &function_declaration.inputs {\n         visitor.visit_pat(&argument.pat);\n         visitor.visit_ty(&argument.ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n-pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                        function_kind: FnKind<'v>) {\n+pub fn walk_fn_kind<V: Visitor>(visitor: &mut V, function_kind: FnKind) {\n     match function_kind {\n         FnKind::ItemFn(_, generics, _, _, _, _) => {\n             visitor.visit_generics(generics);\n@@ -538,17 +521,15 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                   function_kind: FnKind<'v>,\n-                                   function_declaration: &'v FnDecl,\n-                                   function_body: &'v Block,\n-                                   _span: Span) {\n-    walk_fn_decl(visitor, function_declaration);\n-    walk_fn_kind(visitor, function_kind);\n-    visitor.visit_block(function_body)\n+pub fn walk_fn<V>(visitor: &mut V, kind: FnKind, declaration: &FnDecl, body: &Block, _span: Span)\n+    where V: Visitor,\n+{\n+    walk_fn_decl(visitor, declaration);\n+    walk_fn_kind(visitor, kind);\n+    visitor.visit_block(body)\n }\n \n-pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n+pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_item: &TraitItem) {\n     visitor.visit_ident(trait_item.span, trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n@@ -568,10 +549,13 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n+        TraitItemKind::Macro(ref mac) => {\n+            visitor.visit_mac(mac);\n+        }\n     }\n }\n \n-pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n+pub fn walk_impl_item<V: Visitor>(visitor: &mut V, impl_item: &ImplItem) {\n     visitor.visit_vis(&impl_item.vis);\n     visitor.visit_ident(impl_item.span, impl_item.ident);\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n@@ -593,52 +577,44 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     }\n }\n \n-pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                           struct_definition: &'v VariantData) {\n+pub fn walk_struct_def<V: Visitor>(visitor: &mut V, struct_definition: &VariantData) {\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n-pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             struct_field: &'v StructField) {\n+pub fn walk_struct_field<V: Visitor>(visitor: &mut V, struct_field: &StructField) {\n     visitor.visit_vis(&struct_field.vis);\n     walk_opt_ident(visitor, struct_field.span, struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n }\n \n-pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n+pub fn walk_block<V: Visitor>(visitor: &mut V, block: &Block) {\n     walk_list!(visitor, visit_stmt, &block.stmts);\n-    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n-pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n+pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {\n     match statement.node {\n-        StmtKind::Decl(ref declaration, _) => visitor.visit_decl(declaration),\n-        StmtKind::Expr(ref expression, _) | StmtKind::Semi(ref expression, _) => {\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(ref item) => visitor.visit_item(item),\n+        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n-        StmtKind::Mac(ref mac, _, ref attrs) => {\n+        StmtKind::Mac(ref mac) => {\n+            let (ref mac, _, ref attrs) = **mac;\n             visitor.visit_mac(mac);\n-            for attr in attrs.as_attr_slice() {\n+            for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);\n             }\n         }\n     }\n }\n \n-pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n-    match declaration.node {\n-        DeclKind::Local(ref local) => visitor.visit_local(local),\n-        DeclKind::Item(ref item) => visitor.visit_item(item),\n-    }\n-}\n-\n-pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n+pub fn walk_mac<V: Visitor>(_: &mut V, _: &Mac) {\n     // Empty!\n }\n \n-pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n-    for attr in expression.attrs.as_attr_slice() {\n+pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n+    for attr in expression.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }\n     match expression.node {\n@@ -761,7 +737,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_sp_ident) | ExprKind::Again(ref opt_sp_ident) => {\n+        ExprKind::Break(ref opt_sp_ident) | ExprKind::Continue(ref opt_sp_ident) => {\n             walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Ret(ref optional_expression) => {\n@@ -787,14 +763,14 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     visitor.visit_expr_post(expression)\n }\n \n-pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n+pub fn walk_arm<V: Visitor>(visitor: &mut V, arm: &Arm) {\n     walk_list!(visitor, visit_pat, &arm.pats);\n     walk_list!(visitor, visit_expr, &arm.guard);\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }\n \n-pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n+pub fn walk_vis<V: Visitor>(visitor: &mut V, vis: &Visibility) {\n     if let Visibility::Restricted { ref path, id } = *vis {\n         visitor.visit_path(path, id);\n     }"}, {"sha": "040c6c8ebff26db4dc39724b2117cfa0cae9675b", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,3 +12,5 @@ crate-type = [\"dylib\"]\n fmt_macros = { path = \"../libfmt_macros\" }\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n\\ No newline at end of file"}, {"sha": "56a8c28ffedc2fe6547bca57842d320da96d388a", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,14 +15,15 @@ use self::State::*;\n \n use syntax::ast;\n use syntax::codemap;\n-use syntax::codemap::Span;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n use syntax::parse::token::intern;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n use syntax::ast::AsmDialect;\n+use syntax_pos::Span;\n+use syntax::tokenstream;\n \n enum State {\n     Asm,\n@@ -48,7 +49,7 @@ impl State {\n \n const OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n-pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                        -> Box<base::MacResult+'cx> {\n     if !cx.ecfg.enable_asm() {\n         feature_gate::emit_feature_err(\n@@ -62,8 +63,8 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     // parsed as `asm!(z)` with `z = \"x\": y` which is type ascription.\n     let first_colon = tts.iter().position(|tt| {\n         match *tt {\n-            ast::TokenTree::Token(_, token::Colon) |\n-            ast::TokenTree::Token(_, token::ModSep) => true,\n+            tokenstream::TokenTree::Token(_, token::Colon) |\n+            tokenstream::TokenTree::Token(_, token::ModSep) => true,\n             _ => false\n         }\n     }).unwrap_or(tts.len());\n@@ -260,6 +261,6 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             expn_id: expn_id,\n         }),\n         span: sp,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     }))\n }"}, {"sha": "dbf23328f41fe3394a95359f95ab35283f57ecc0", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,17 +12,17 @@\n /// a literal `true` or `false` based on whether the given cfg matches the\n /// current compilation environment.\n \n-use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::attr;\n+use syntax::tokenstream;\n use syntax::parse::token;\n+use syntax_pos::Span;\n \n pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        sp: Span,\n-                       tts: &[ast::TokenTree])\n+                       tts: &[tokenstream::TokenTree])\n                        -> Box<base::MacResult+'static> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let cfg = panictry!(p.parse_meta_item());"}, {"sha": "22c4aeefbd169c03fa2fea10cd7144999faec45a", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -9,16 +9,17 @@\n // except according to those terms.\n \n use syntax::ast;\n-use syntax::codemap;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n+use syntax_pos;\n+use syntax::tokenstream;\n \n use std::string::String;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n-                         sp: codemap::Span,\n-                         tts: &[ast::TokenTree])\n+                         sp: syntax_pos::Span,\n+                         tts: &[tokenstream::TokenTree])\n                          -> Box<base::MacResult+'static> {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,"}, {"sha": "870413a7f61b0526823f23356f5726e7170a3b52", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast::{self, TokenTree};\n-use syntax::codemap::Span;\n+use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::parse::token::str_to_ident;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n+use syntax::tokenstream::TokenTree;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n                               -> Box<base::MacResult+'cx> {\n@@ -70,7 +71,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprKind::Path(None, self.path()),\n                 span: self.span,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             }))\n         }\n "}, {"sha": "36818e000b55bf0d3f94fdcd73325f77122ac202", "filename": "src/libsyntax_ext/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,8 +12,8 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::MetaItem;\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax_pos::Span;\n \n pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt,\n                                     span: Span,"}, {"sha": "1e47ebb85837a761a9596bfafcb1369ba783db7e", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,11 +13,11 @@ use deriving::generic::ty::*;\n \n use syntax::ast::{Expr, ItemKind, Generics, MetaItem, VariantData};\n use syntax::attr;\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n #[derive(PartialEq)]\n enum Mode { Deep, Shallow }\n@@ -145,12 +145,10 @@ fn cs_clone(\n \n     match mode {\n         Mode::Shallow => {\n-            cx.expr_block(cx.block(trait_span,\n-                                   all_fields.iter()\n-                                             .map(subcall)\n-                                             .map(|e| cx.stmt_expr(e))\n-                                             .collect(),\n-                                   Some(cx.expr_deref(trait_span, cx.expr_self(trait_span)))))\n+            let mut stmts: Vec<_> =\n+                all_fields.iter().map(subcall).map(|e| cx.stmt_expr(e)).collect();\n+            stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n+            cx.expr_block(cx.block(trait_span, stmts))\n         }\n         Mode::Deep => {\n             match *vdata {"}, {"sha": "9c5072eeb3e0b79dc9ba58c4b447eba4efc146a9", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,11 +12,11 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{MetaItem, Expr};\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n@@ -30,7 +30,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 // create `a.<method>(); b.<method>(); c.<method>(); ...`\n                 // (where method is `assert_receiver_is_total_eq`)\n                 let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-                let block = cx.block(span, stmts, None);\n+                let block = cx.block(span, stmts);\n                 cx.expr_block(block)\n             },\n             Box::new(|cx, sp, _, _| {"}, {"sha": "cbd7ac0eadad039ae287dc25781ed596f0edee3a", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,11 +12,11 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{MetaItem, Expr, self};\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,"}, {"sha": "b5a8167fb555093be14b8940764d6c4d33f2bd43", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,11 +12,11 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{MetaItem, Expr, BinOpKind};\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                                   span: Span,"}, {"sha": "26c14ae934f72796e58c20b6727d04603ff50bdc", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,11 +14,11 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{MetaItem, Expr, BinOpKind, self};\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    span: Span,"}, {"sha": "34c872bef11d10916698f2a57a6475dfe798fa66", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,11 +13,11 @@ use deriving::generic::ty::*;\n \n use syntax::ast;\n use syntax::ast::{MetaItem, Expr};\n-use syntax::codemap::{Span, respan, DUMMY_SP};\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax_pos::{Span, DUMMY_SP};\n \n pub fn expand_deriving_debug(cx: &mut ExtCtxt,\n                             span: Span,\n@@ -78,7 +78,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n     let fmt = substr.nonself_args[0].clone();\n \n-    let stmts = match *substr.fields {\n+    let mut stmts = match *substr.fields {\n         Struct(_, ref fields) | EnumMatching(_, _, ref fields) => {\n             let mut stmts = vec![];\n             if !is_struct {\n@@ -136,7 +136,8 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                                    token::str_to_ident(\"finish\"),\n                                    vec![]);\n \n-    let block = cx.block(span, stmts, Some(expr));\n+    stmts.push(cx.stmt_expr(expr));\n+    let block = cx.block(span, stmts);\n     cx.expr_block(block)\n }\n \n@@ -149,8 +150,11 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         init: Some(expr),\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     });\n-    let decl = respan(sp, ast::DeclKind::Local(local));\n-    respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+    ast::Stmt {\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::StmtKind::Local(local),\n+        span: sp,\n+    }\n }"}, {"sha": "488402c48f70a985bde3775011b26719ec601ee2", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,12 +16,12 @@ use deriving::generic::ty::*;\n \n use syntax::ast;\n use syntax::ast::{MetaItem, Expr, Mutability};\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n                                        span: Span,"}, {"sha": "2711ccba81914ec7e05a5962455e9e4492e3bdaf", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -12,11 +12,11 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{MetaItem, Expr};\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                span: Span,"}, {"sha": "ad3786212475eaa76f23a82963fab1270827aa13", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -93,11 +93,11 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{MetaItem, Expr, ExprKind, Mutability};\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt,Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n                                        span: Span,\n@@ -285,7 +285,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                 blk\n             ));\n-            cx.expr_block(cx.block(trait_span, vec!(me), Some(ret)))\n+            cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\")"}, {"sha": "647e414a7fd2736cf6443e36ed8ce7be8b36458d", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -197,12 +197,12 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::{self, respan, DUMMY_SP};\n-use syntax::codemap::Span;\n-use syntax::errors::Handler;\n+use syntax::codemap::{self, respan};\n use syntax::util::move_map::MoveMap;\n use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n+use syntax_pos::{Span, DUMMY_SP};\n+use errors::Handler;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n \n@@ -353,8 +353,8 @@ fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast\n         types: Vec<P<ast::Ty>>,\n     }\n \n-    impl<'a> visit::Visitor<'a> for Visitor<'a> {\n-        fn visit_ty(&mut self, ty: &'a ast::Ty) {\n+    impl<'a> visit::Visitor for Visitor<'a> {\n+        fn visit_ty(&mut self, ty: &ast::Ty) {\n             match ty.node {\n                 ast::TyKind::Path(_, ref path) if !path.global => {\n                     match path.segments.first() {\n@@ -1332,8 +1332,8 @@ impl<'a> MethodDef<'a> {\n             //  }\n             let all_match = cx.expr_match(sp, match_arg, match_arms);\n             let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n-            cx.expr_block(\n-                cx.block_all(sp, index_let_stmts, Some(arm_expr)))\n+            index_let_stmts.push(cx.stmt_expr(arm_expr));\n+            cx.expr_block(cx.block(sp, index_let_stmts))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler"}, {"sha": "626fbaada5cbf1e6745f2c246d1aa8a12d984e39", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,8 +18,9 @@ use syntax::ast;\n use syntax::ast::{Expr, Generics, Ident, SelfKind};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::{Span,respan};\n+use syntax::codemap::respan;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n /// The types of pointers\n #[derive(Clone, Eq, PartialEq)]"}, {"sha": "0fad96c84ef3d2a859569768a4115995ebfc54b0", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,10 +13,10 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::{MetaItem, Expr, Mutability};\n-use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n@@ -99,5 +99,5 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         stmts.push(call_hash(span, self_.clone()));\n     }\n \n-    cx.expr_block(cx.block(trait_span, stmts, None))\n+    cx.expr_block(cx.block(trait_span, stmts))\n }"}, {"sha": "169e8073661976cf56c709ac1b1aa3bcb641d3a5", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,9 +16,10 @@ use syntax::ext::base::{ExtCtxt, SyntaxEnv, Annotatable};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n-use syntax::codemap::{self, Span};\n+use syntax::codemap;\n use syntax::parse::token::{intern, intern_and_get_ident};\n use syntax::ptr::P;\n+use syntax_pos::Span;\n \n macro_rules! pathvec {\n     ($($x:ident)::+) => (\n@@ -297,8 +298,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     let call = cx.expr_call_global(span, path, args);\n \n     cx.expr_block(P(ast::Block {\n-        stmts: vec![],\n-        expr: Some(call),\n+        stmts: vec![cx.stmt_expr(call)],\n         id: ast::DUMMY_NODE_ID,\n         rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n         span: span }))"}, {"sha": "546f8eaa692863d8280f9cba0c8a1a35aff2e965", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,15 +15,16 @@\n  */\n \n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n+use syntax_pos::Span;\n+use syntax::tokenstream;\n \n use std::env;\n \n-pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n     let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n         None => return DummyResult::expr(sp),\n@@ -56,7 +57,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n     MacEager::expr(e)\n }\n \n-pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                        -> Box<base::MacResult+'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.is_empty() => {"}, {"sha": "f311f16f11b0efbebd7c59390f75102f537c171b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,13 +14,14 @@ use self::Position::*;\n use fmt_macros as parse;\n \n use syntax::ast;\n-use syntax::codemap::{Span, respan, DUMMY_SP};\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::fold::Folder;\n use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n+use syntax_pos::{Span, DUMMY_SP};\n+use syntax::tokenstream;\n \n use std::collections::HashMap;\n \n@@ -80,7 +81,7 @@ struct Context<'a, 'b:'a> {\n /// Some((fmtstr, unnamed arguments, ordering of named arguments,\n ///       named arguments))\n /// ```\n-fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n               -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n                          HashMap<String, P<ast::Expr>>)> {\n     let mut args = Vec::new();\n@@ -441,12 +442,14 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         let name = ecx.ident_of(name);\n         let item = ecx.item(sp, name, vec![], st);\n-        let decl = respan(sp, ast::DeclKind::Item(item));\n+        let stmt = ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Item(item),\n+            span: sp,\n+        };\n \n         // Wrap the declaration in a block so that it forms a single expression.\n-        ecx.expr_block(ecx.block(sp,\n-            vec![respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))],\n-            Some(ecx.expr_ident(sp, name))))\n+        ecx.expr_block(ecx.block(sp, vec![stmt, ecx.stmt_expr(ecx.expr_ident(sp, name))]))\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded\n@@ -606,7 +609,7 @@ impl<'a, 'b> Context<'a, 'b> {\n }\n \n pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n-                               tts: &[ast::TokenTree])\n+                               tts: &[tokenstream::TokenTree])\n                                -> Box<base::MacResult+'cx> {\n \n     match parse_args(ecx, sp, tts) {"}, {"sha": "17b200bac58c5440cead5e7f212a1f0f580fcc25", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -26,6 +26,8 @@ extern crate fmt_macros;\n #[macro_use] extern crate log;\n #[macro_use]\n extern crate syntax;\n+extern crate syntax_pos;\n+extern crate rustc_errors as errors;\n \n use syntax::ext::base::{MacroExpanderFn, NormalTT};\n use syntax::ext::base::{SyntaxEnv, SyntaxExtension};"}, {"sha": "9645c5bb42723dbdc43831a5fec0ef321ee3e83c", "filename": "src/libsyntax_ext/log_syntax.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flog_syntax.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast;\n-use syntax::codemap;\n use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::print;\n+use syntax::tokenstream;\n+use syntax_pos;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt,\n-                              sp: codemap::Span,\n-                              tts: &[ast::TokenTree])\n+                              sp: syntax_pos::Span,\n+                              tts: &[tokenstream::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n     if !cx.ecfg.enable_log_syntax() {\n         feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,"}, {"sha": "ad396d38de9f56b7a2470a9bd6be91c760919187", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast::TokenTree;\n-use syntax::codemap::Span;\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::parse::token::keywords;\n-\n+use syntax_pos::Span;\n+use syntax::tokenstream::TokenTree;\n \n pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,"}, {"sha": "760aaa8a9578419b809032fc86a1e3f6396cfb4c", "filename": "src/libsyntax_pos/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_pos%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_pos%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2FCargo.toml?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"syntax_pos\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"syntax_pos\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+serialize = { path = \"../libserialize\" }"}, {"sha": "39bb5956312bce7b752388892d7e33c00dea7625", "filename": "src/libsyntax_pos/lib.rs", "status": "added", "additions": 667, "deletions": 0, "changes": 667, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,667 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The source positions and related helper functions\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"syntax_pos\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+#![feature(question_mark)]\n+\n+use std::cell::{Cell, RefCell};\n+use std::ops::{Add, Sub};\n+use std::rc::Rc;\n+use std::cmp;\n+\n+use std::fmt;\n+\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n+\n+extern crate serialize;\n+extern crate serialize as rustc_serialize; // used by deriving\n+\n+pub type FileName = String;\n+\n+/// Spans represent a region of code, used for error reporting. Positions in spans\n+/// are *absolute* positions from the beginning of the codemap, not positions\n+/// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n+/// to the original source.\n+/// You must be careful if the span crosses more than one file - you will not be\n+/// able to use many of the functions on spans in codemap and you cannot assume\n+/// that the length of the span = hi - lo; there may be space in the BytePos\n+/// range between files.\n+#[derive(Clone, Copy, Hash, PartialEq, Eq)]\n+pub struct Span {\n+    pub lo: BytePos,\n+    pub hi: BytePos,\n+    /// Information about where the macro came from, if this piece of\n+    /// code was created by a macro expansion.\n+    pub expn_id: ExpnId\n+}\n+\n+/// A collection of spans. Spans have two orthogonal attributes:\n+///\n+/// - they can be *primary spans*. In this case they are the locus of\n+///   the error, and would be rendered with `^^^`.\n+/// - they can have a *label*. In this case, the label is written next\n+///   to the mark in the snippet when we render.\n+#[derive(Clone)]\n+pub struct MultiSpan {\n+    primary_spans: Vec<Span>,\n+    span_labels: Vec<(Span, String)>,\n+}\n+\n+impl Span {\n+    /// Returns a new span representing just the end-point of this span\n+    pub fn end_point(self) -> Span {\n+        let lo = cmp::max(self.hi.0 - 1, self.lo.0);\n+        Span { lo: BytePos(lo), hi: self.hi, expn_id: self.expn_id}\n+    }\n+\n+    /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n+    pub fn substitute_dummy(self, other: Span) -> Span {\n+        if self.source_equal(&DUMMY_SP) { other } else { self }\n+    }\n+\n+    pub fn contains(self, other: Span) -> bool {\n+        self.lo <= other.lo && other.hi <= self.hi\n+    }\n+\n+    /// Return true if the spans are equal with regards to the source text.\n+    ///\n+    /// Use this instead of `==` when either span could be generated code,\n+    /// and you only care that they point to the same bytes of source text.\n+    pub fn source_equal(&self, other: &Span) -> bool {\n+        self.lo == other.lo && self.hi == other.hi\n+    }\n+\n+    /// Returns `Some(span)`, a union of `self` and `other`, on overlap.\n+    pub fn merge(self, other: Span) -> Option<Span> {\n+        if self.expn_id != other.expn_id {\n+            return None;\n+        }\n+\n+        if (self.lo <= other.lo && self.hi > other.lo) ||\n+           (self.lo >= other.lo && self.lo < other.hi) {\n+            Some(Span {\n+                lo: cmp::min(self.lo, other.lo),\n+                hi: cmp::max(self.hi, other.hi),\n+                expn_id: self.expn_id,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns `Some(span)`, where the start is trimmed by the end of `other`\n+    pub fn trim_start(self, other: Span) -> Option<Span> {\n+        if self.hi > other.hi {\n+            Some(Span { lo: cmp::max(self.lo, other.hi), .. self })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct SpanLabel {\n+    /// The span we are going to include in the final snippet.\n+    pub span: Span,\n+\n+    /// Is this a primary span? This is the \"locus\" of the message,\n+    /// and is indicated with a `^^^^` underline, versus `----`.\n+    pub is_primary: bool,\n+\n+    /// What label should we attach to this span (if any)?\n+    pub label: Option<String>,\n+}\n+\n+impl Encodable for Span {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_struct(\"Span\", 2, |s| {\n+            s.emit_struct_field(\"lo\", 0, |s| {\n+                self.lo.encode(s)\n+            })?;\n+\n+            s.emit_struct_field(\"hi\", 1, |s| {\n+                self.hi.encode(s)\n+            })\n+        })\n+    }\n+}\n+\n+impl Decodable for Span {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n+        d.read_struct(\"Span\", 2, |d| {\n+            let lo = d.read_struct_field(\"lo\", 0, |d| {\n+                BytePos::decode(d)\n+            })?;\n+\n+            let hi = d.read_struct_field(\"hi\", 1, |d| {\n+                BytePos::decode(d)\n+            })?;\n+\n+            Ok(mk_sp(lo, hi))\n+        })\n+    }\n+}\n+\n+fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n+    write!(f, \"Span {{ lo: {:?}, hi: {:?}, expn_id: {:?} }}\",\n+           span.lo, span.hi, span.expn_id)\n+}\n+\n+impl fmt::Debug for Span {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        SPAN_DEBUG.with(|span_debug| span_debug.get()(*self, f))\n+    }\n+}\n+\n+pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n+\n+// Generic span to be used for code originating from the command line\n+pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n+                                         hi: BytePos(0),\n+                                         expn_id: COMMAND_LINE_EXPN };\n+\n+impl MultiSpan {\n+    pub fn new() -> MultiSpan {\n+        MultiSpan {\n+            primary_spans: vec![],\n+            span_labels: vec![]\n+        }\n+    }\n+\n+    pub fn from_span(primary_span: Span) -> MultiSpan {\n+        MultiSpan {\n+            primary_spans: vec![primary_span],\n+            span_labels: vec![]\n+        }\n+    }\n+\n+    pub fn from_spans(vec: Vec<Span>) -> MultiSpan {\n+        MultiSpan {\n+            primary_spans: vec,\n+            span_labels: vec![]\n+        }\n+    }\n+\n+    pub fn push_span_label(&mut self, span: Span, label: String) {\n+        self.span_labels.push((span, label));\n+    }\n+\n+    /// Selects the first primary span (if any)\n+    pub fn primary_span(&self) -> Option<Span> {\n+        self.primary_spans.first().cloned()\n+    }\n+\n+    /// Returns all primary spans.\n+    pub fn primary_spans(&self) -> &[Span] {\n+        &self.primary_spans\n+    }\n+\n+    /// Returns the strings to highlight. We always ensure that there\n+    /// is an entry for each of the primary spans -- for each primary\n+    /// span P, if there is at least one label with span P, we return\n+    /// those labels (marked as primary). But otherwise we return\n+    /// `SpanLabel` instances with empty labels.\n+    pub fn span_labels(&self) -> Vec<SpanLabel> {\n+        let is_primary = |span| self.primary_spans.contains(&span);\n+        let mut span_labels = vec![];\n+\n+        for &(span, ref label) in &self.span_labels {\n+            span_labels.push(SpanLabel {\n+                span: span,\n+                is_primary: is_primary(span),\n+                label: Some(label.clone())\n+            });\n+        }\n+\n+        for &span in &self.primary_spans {\n+            if !span_labels.iter().any(|sl| sl.span == span) {\n+                span_labels.push(SpanLabel {\n+                    span: span,\n+                    is_primary: true,\n+                    label: None\n+                });\n+            }\n+        }\n+\n+        span_labels\n+    }\n+}\n+\n+impl From<Span> for MultiSpan {\n+    fn from(span: Span) -> MultiSpan {\n+        MultiSpan::from_span(span)\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Copy)]\n+pub struct ExpnId(pub u32);\n+\n+pub const NO_EXPANSION: ExpnId = ExpnId(!0);\n+// For code appearing from the command line\n+pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(!1);\n+\n+impl ExpnId {\n+    pub fn from_u32(id: u32) -> ExpnId {\n+        ExpnId(id)\n+    }\n+\n+    pub fn into_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+/// Identifies an offset of a multi-byte character in a FileMap\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+pub struct MultiByteChar {\n+    /// The absolute offset of the character in the CodeMap\n+    pub pos: BytePos,\n+    /// The number of bytes, >=2\n+    pub bytes: usize,\n+}\n+\n+/// A single source in the CodeMap.\n+pub struct FileMap {\n+    /// The name of the file that the source came from, source that doesn't\n+    /// originate from files has names between angle brackets by convention,\n+    /// e.g. `<anon>`\n+    pub name: FileName,\n+    /// The absolute path of the file that the source came from.\n+    pub abs_path: Option<FileName>,\n+    /// The complete source code\n+    pub src: Option<Rc<String>>,\n+    /// The start position of this source in the CodeMap\n+    pub start_pos: BytePos,\n+    /// The end position of this source in the CodeMap\n+    pub end_pos: BytePos,\n+    /// Locations of lines beginnings in the source code\n+    pub lines: RefCell<Vec<BytePos>>,\n+    /// Locations of multi-byte characters in the source code\n+    pub multibyte_chars: RefCell<Vec<MultiByteChar>>,\n+}\n+\n+impl Encodable for FileMap {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_struct(\"FileMap\", 6, |s| {\n+            s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n+            s.emit_struct_field(\"abs_path\", 1, |s| self.abs_path.encode(s))?;\n+            s.emit_struct_field(\"start_pos\", 2, |s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(\"end_pos\", 3, |s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(\"lines\", 4, |s| {\n+                let lines = self.lines.borrow();\n+                // store the length\n+                s.emit_u32(lines.len() as u32)?;\n+\n+                if !lines.is_empty() {\n+                    // In order to preserve some space, we exploit the fact that\n+                    // the lines list is sorted and individual lines are\n+                    // probably not that long. Because of that we can store lines\n+                    // as a difference list, using as little space as possible\n+                    // for the differences.\n+                    let max_line_length = if lines.len() == 1 {\n+                        0\n+                    } else {\n+                        lines.windows(2)\n+                             .map(|w| w[1] - w[0])\n+                             .map(|bp| bp.to_usize())\n+                             .max()\n+                             .unwrap()\n+                    };\n+\n+                    let bytes_per_diff: u8 = match max_line_length {\n+                        0 ... 0xFF => 1,\n+                        0x100 ... 0xFFFF => 2,\n+                        _ => 4\n+                    };\n+\n+                    // Encode the number of bytes used per diff.\n+                    bytes_per_diff.encode(s)?;\n+\n+                    // Encode the first element.\n+                    lines[0].encode(s)?;\n+\n+                    let diff_iter = (&lines[..]).windows(2)\n+                                                .map(|w| (w[1] - w[0]));\n+\n+                    match bytes_per_diff {\n+                        1 => for diff in diff_iter { (diff.0 as u8).encode(s)? },\n+                        2 => for diff in diff_iter { (diff.0 as u16).encode(s)? },\n+                        4 => for diff in diff_iter { diff.0.encode(s)? },\n+                        _ => unreachable!()\n+                    }\n+                }\n+\n+                Ok(())\n+            })?;\n+            s.emit_struct_field(\"multibyte_chars\", 5, |s| {\n+                (*self.multibyte_chars.borrow()).encode(s)\n+            })\n+        })\n+    }\n+}\n+\n+impl Decodable for FileMap {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<FileMap, D::Error> {\n+\n+        d.read_struct(\"FileMap\", 6, |d| {\n+            let name: String = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n+            let abs_path: Option<String> =\n+                d.read_struct_field(\"abs_path\", 1, |d| Decodable::decode(d))?;\n+            let start_pos: BytePos = d.read_struct_field(\"start_pos\", 2, |d| Decodable::decode(d))?;\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 3, |d| Decodable::decode(d))?;\n+            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 4, |d| {\n+                let num_lines: u32 = Decodable::decode(d)?;\n+                let mut lines = Vec::with_capacity(num_lines as usize);\n+\n+                if num_lines > 0 {\n+                    // Read the number of bytes used per diff.\n+                    let bytes_per_diff: u8 = Decodable::decode(d)?;\n+\n+                    // Read the first element.\n+                    let mut line_start: BytePos = Decodable::decode(d)?;\n+                    lines.push(line_start);\n+\n+                    for _ in 1..num_lines {\n+                        let diff = match bytes_per_diff {\n+                            1 => d.read_u8()? as u32,\n+                            2 => d.read_u16()? as u32,\n+                            4 => d.read_u32()?,\n+                            _ => unreachable!()\n+                        };\n+\n+                        line_start = line_start + BytePos(diff);\n+\n+                        lines.push(line_start);\n+                    }\n+                }\n+\n+                Ok(lines)\n+            })?;\n+            let multibyte_chars: Vec<MultiByteChar> =\n+                d.read_struct_field(\"multibyte_chars\", 5, |d| Decodable::decode(d))?;\n+            Ok(FileMap {\n+                name: name,\n+                abs_path: abs_path,\n+                start_pos: start_pos,\n+                end_pos: end_pos,\n+                src: None,\n+                lines: RefCell::new(lines),\n+                multibyte_chars: RefCell::new(multibyte_chars)\n+            })\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for FileMap {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"FileMap({})\", self.name)\n+    }\n+}\n+\n+impl FileMap {\n+    /// EFFECT: register a start-of-line offset in the\n+    /// table of line-beginnings.\n+    /// UNCHECKED INVARIANT: these offsets must be added in the right\n+    /// order and must be in the right places; there is shared knowledge\n+    /// about what ends a line between this file and parse.rs\n+    /// WARNING: pos param here is the offset relative to start of CodeMap,\n+    /// and CodeMap will append a newline when adding a filemap without a newline at the end,\n+    /// so the safe way to call this is with value calculated as\n+    /// filemap.start_pos + newline_offset_relative_to_the_start_of_filemap.\n+    pub fn next_line(&self, pos: BytePos) {\n+        // the new charpos must be > the last one (or it's the first one).\n+        let mut lines = self.lines.borrow_mut();\n+        let line_len = lines.len();\n+        assert!(line_len == 0 || ((*lines)[line_len - 1] < pos));\n+        lines.push(pos);\n+    }\n+\n+    /// get a line from the list of pre-computed line-beginnings.\n+    /// line-number here is 0-based.\n+    pub fn get_line(&self, line_number: usize) -> Option<&str> {\n+        match self.src {\n+            Some(ref src) => {\n+                let lines = self.lines.borrow();\n+                lines.get(line_number).map(|&line| {\n+                    let begin: BytePos = line - self.start_pos;\n+                    let begin = begin.to_usize();\n+                    // We can't use `lines.get(line_number+1)` because we might\n+                    // be parsing when we call this function and thus the current\n+                    // line is the last one we have line info for.\n+                    let slice = &src[begin..];\n+                    match slice.find('\\n') {\n+                        Some(e) => &slice[..e],\n+                        None => slice\n+                    }\n+                })\n+            }\n+            None => None\n+        }\n+    }\n+\n+    pub fn record_multibyte_char(&self, pos: BytePos, bytes: usize) {\n+        assert!(bytes >=2 && bytes <= 4);\n+        let mbc = MultiByteChar {\n+            pos: pos,\n+            bytes: bytes,\n+        };\n+        self.multibyte_chars.borrow_mut().push(mbc);\n+    }\n+\n+    pub fn is_real_file(&self) -> bool {\n+        !(self.name.starts_with(\"<\") &&\n+          self.name.ends_with(\">\"))\n+    }\n+\n+    pub fn is_imported(&self) -> bool {\n+        self.src.is_none()\n+    }\n+\n+    pub fn count_lines(&self) -> usize {\n+        self.lines.borrow().len()\n+    }\n+}\n+\n+// _____________________________________________________________________________\n+// Pos, BytePos, CharPos\n+//\n+\n+pub trait Pos {\n+    fn from_usize(n: usize) -> Self;\n+    fn to_usize(&self) -> usize;\n+}\n+\n+/// A byte offset. Keep this small (currently 32-bits), as AST contains\n+/// a lot of them.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n+pub struct BytePos(pub u32);\n+\n+/// A character offset. Because of multibyte utf8 characters, a byte offset\n+/// is not equivalent to a character offset. The CodeMap will convert BytePos\n+/// values to CharPos values as necessary.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n+pub struct CharPos(pub usize);\n+\n+// FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n+// have been unsuccessful\n+\n+impl Pos for BytePos {\n+    fn from_usize(n: usize) -> BytePos { BytePos(n as u32) }\n+    fn to_usize(&self) -> usize { let BytePos(n) = *self; n as usize }\n+}\n+\n+impl Add for BytePos {\n+    type Output = BytePos;\n+\n+    fn add(self, rhs: BytePos) -> BytePos {\n+        BytePos((self.to_usize() + rhs.to_usize()) as u32)\n+    }\n+}\n+\n+impl Sub for BytePos {\n+    type Output = BytePos;\n+\n+    fn sub(self, rhs: BytePos) -> BytePos {\n+        BytePos((self.to_usize() - rhs.to_usize()) as u32)\n+    }\n+}\n+\n+impl Encodable for BytePos {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u32(self.0)\n+    }\n+}\n+\n+impl Decodable for BytePos {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<BytePos, D::Error> {\n+        Ok(BytePos(d.read_u32()?))\n+    }\n+}\n+\n+impl Pos for CharPos {\n+    fn from_usize(n: usize) -> CharPos { CharPos(n) }\n+    fn to_usize(&self) -> usize { let CharPos(n) = *self; n }\n+}\n+\n+impl Add for CharPos {\n+    type Output = CharPos;\n+\n+    fn add(self, rhs: CharPos) -> CharPos {\n+        CharPos(self.to_usize() + rhs.to_usize())\n+    }\n+}\n+\n+impl Sub for CharPos {\n+    type Output = CharPos;\n+\n+    fn sub(self, rhs: CharPos) -> CharPos {\n+        CharPos(self.to_usize() - rhs.to_usize())\n+    }\n+}\n+\n+// _____________________________________________________________________________\n+// Loc, LocWithOpt, FileMapAndLine, FileMapAndBytePos\n+//\n+\n+/// A source code location used for error reporting\n+#[derive(Debug)]\n+pub struct Loc {\n+    /// Information about the original source\n+    pub file: Rc<FileMap>,\n+    /// The (1-based) line number\n+    pub line: usize,\n+    /// The (0-based) column offset\n+    pub col: CharPos\n+}\n+\n+/// A source code location used as the result of lookup_char_pos_adj\n+// Actually, *none* of the clients use the filename *or* file field;\n+// perhaps they should just be removed.\n+#[derive(Debug)]\n+pub struct LocWithOpt {\n+    pub filename: FileName,\n+    pub line: usize,\n+    pub col: CharPos,\n+    pub file: Option<Rc<FileMap>>,\n+}\n+\n+// used to be structural records. Better names, anyone?\n+#[derive(Debug)]\n+pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: usize }\n+#[derive(Debug)]\n+pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct LineInfo {\n+    /// Index of line, starting from 0.\n+    pub line_index: usize,\n+\n+    /// Column in line where span begins, starting from 0.\n+    pub start_col: CharPos,\n+\n+    /// Column in line where span ends, starting from 0, exclusive.\n+    pub end_col: CharPos,\n+}\n+\n+pub struct FileLines {\n+    pub file: Rc<FileMap>,\n+    pub lines: Vec<LineInfo>\n+}\n+\n+thread_local!(pub static SPAN_DEBUG: Cell<fn(Span, &mut fmt::Formatter) -> fmt::Result> =\n+                Cell::new(default_span_debug));\n+\n+/* assuming that we're not in macro expansion */\n+pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n+    Span {lo: lo, hi: hi, expn_id: NO_EXPANSION}\n+}\n+\n+pub struct MacroBacktrace {\n+    /// span where macro was applied to generate this code\n+    pub call_site: Span,\n+\n+    /// name of macro that was applied (e.g., \"foo!\" or \"#[derive(Eq)]\")\n+    pub macro_decl_name: String,\n+\n+    /// span where macro was defined (if known)\n+    pub def_site_span: Option<Span>,\n+}\n+\n+// _____________________________________________________________________________\n+// SpanLinesError, SpanSnippetError, DistinctSources, MalformedCodemapPositions\n+//\n+\n+pub type FileLinesResult = Result<FileLines, SpanLinesError>;\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum SpanLinesError {\n+    IllFormedSpan(Span),\n+    DistinctSources(DistinctSources),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum SpanSnippetError {\n+    IllFormedSpan(Span),\n+    DistinctSources(DistinctSources),\n+    MalformedForCodemap(MalformedCodemapPositions),\n+    SourceNotAvailable { filename: String }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct DistinctSources {\n+    pub begin: (String, BytePos),\n+    pub end: (String, BytePos)\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct MalformedCodemapPositions {\n+    pub name: String,\n+    pub source_len: usize,\n+    pub begin_pos: BytePos,\n+    pub end_pos: BytePos\n+}\n+"}, {"sha": "9c6ed991df8a6b0d6b9e948abcb7ff7d2f42661b", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -62,9 +62,11 @@ dependencies = [\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -88,8 +90,10 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -103,6 +107,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -134,6 +139,7 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_lint 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n@@ -149,6 +155,16 @@ dependencies = [\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_errors\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -162,6 +178,7 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -173,6 +190,7 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -195,9 +213,11 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -213,6 +233,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -223,7 +244,9 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -238,8 +261,10 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -248,6 +273,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"rustc 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -257,7 +283,9 @@ dependencies = [\n  \"arena 0.0.0\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -268,6 +296,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -283,11 +312,13 @@ dependencies = [\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -301,8 +332,10 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -317,12 +350,14 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_driver 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"rustc_lint 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_resolve 0.0.0\",\n  \"rustc_trans 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -338,7 +373,9 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]\n@@ -347,6 +384,15 @@ version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"log 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"syntax_pos\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"serialize 0.0.0\",\n ]\n "}, {"sha": "a6bc9db199c8be156ec2c2f49ce470b93a720e15", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,14 +13,16 @@\n #![feature(plugin_registrar, quote, rustc_private)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n-use syntax::codemap::Span;\n+use syntax::ast::{self, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n use syntax::ext::base::*;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n+use syntax::tokenstream::TokenTree;\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n #[macro_export]"}, {"sha": "dade0e946c5bf92587d042bf18e1679a523e46b5", "filename": "src/test/compile-fail-fulldeps/gated-quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -22,8 +22,8 @@\n extern crate syntax;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::parse;\n+use syntax_pos::Span;\n \n struct ParseSess;\n "}, {"sha": "e29ded8a052c6f73b16462e0a89b0ddd26e7f714", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -13,11 +13,12 @@\n #![feature(quote, rustc_private)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n \n use syntax::ast;\n-use syntax::codemap::{self, DUMMY_SP};\n use syntax::parse;\n use syntax::print::pprust;\n+use syntax_pos::DUMMY_SP;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();"}, {"sha": "8c58c8c60627d76132eb2f0338a0105040904650", "filename": "src/test/compile-fail/bad-format-args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail%2Fbad-format-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail%2Fbad-format-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-format-args.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n // error-pattern: requires at least a format string argument\n-// error-pattern: bad-format-args.rs:19:5: 19:15 note: in this expansion\n+// error-pattern: in this expansion\n \n // error-pattern: expected token: `,`\n-// error-pattern: bad-format-args.rs:20:5: 20:19 note: in this expansion\n-// error-pattern: bad-format-args.rs:21:5: 21:22 note: in this expansion\n+// error-pattern: in this expansion\n+// error-pattern: in this expansion\n \n fn main() {\n     format!();"}, {"sha": "6bc0add2205175d48846f91ec0971971238b21ca", "filename": "src/test/compile-fail/issue-34418.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail%2Fissue-34418.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail%2Fissue-34418.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34418.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+macro_rules! make_item {\n+    () => { fn f() {} }\n+}\n+\n+macro_rules! make_stmt {\n+    () => { let x = 0; }\n+}\n+\n+fn f() {\n+    make_item! {}\n+}\n+\n+fn g() {\n+    make_stmt! {}\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "3ae792f9c0f3783985ccbcc0e1d44312ae4d1753", "filename": "src/test/compile-fail/method-resolvable-path-in-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -19,6 +19,6 @@ impl MyTrait for Foo {}\n fn main() {\n     match 0u32 {\n         <Foo as MyTrait>::trait_bar => {}\n-        //~^ ERROR expected associated constant, found method `trait_bar`\n+        //~^ ERROR expected variant, struct or constant, found method `trait_bar`\n     }\n }"}, {"sha": "fd356f4a81792cf277915e0b340e13f6bb0513af", "filename": "src/test/parse-fail/trait-non-item-macros.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! bah {\n+    ($a:expr) => ($a)\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `2`\n+}\n+\n+trait bar {\n+    bah!(2);\n+}\n+\n+fn main() {}"}, {"sha": "e1461c7847e4ca5050cc33ad598533cce26096da", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,11 +15,13 @@\n #![feature(quote, rustc_private)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n \n use syntax::ast;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap;\n use syntax::parse;\n use syntax::print::pprust;\n+use syntax_pos::DUMMY_SP;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();"}, {"sha": "a94b2a85c7754046716f305773b3f514a7df9aa0", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -18,6 +18,8 @@ extern crate rustc_lint;\n extern crate rustc_llvm as llvm;\n extern crate rustc_metadata;\n extern crate rustc_resolve;\n+extern crate rustc_errors;\n+extern crate rustc_errors as errors;\n #[macro_use] extern crate syntax;\n \n use std::ffi::{CStr, CString};\n@@ -38,7 +40,7 @@ use rustc_metadata::creader::read_local_crates;\n use rustc_metadata::cstore::CStore;\n use libc::c_void;\n \n-use syntax::diagnostics::registry::Registry;\n+use rustc_errors::registry::Registry;\n use syntax::parse::token;\n \n fn main() {"}, {"sha": "aa3495ec5eebb56869e1476cbf3674752af59855", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,14 +14,15 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n+extern crate rustc_errors;\n extern crate syntax;\n \n use rustc::dep_graph::DepGraph;\n use rustc::session::{build_session, Session};\n use rustc::session::config::{basic_options, build_configuration, Input, OutputType};\n use rustc_driver::driver::{compile_input, CompileController, anon_src};\n use rustc_metadata::cstore::CStore;\n-use syntax::diagnostics::registry::Registry;\n+use rustc_errors::registry::Registry;\n use syntax::parse::token;\n \n use std::path::PathBuf;"}, {"sha": "64747002a65b03542eab3abc54bd4f4950be6a02", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -86,7 +86,7 @@ fn check_expr_attrs(es: &str, expected: &[&str]) {\n     let actual = &e.attrs;\n     str_compare(es,\n                 &expected.iter().map(|r| attr(r, &ps).unwrap()).collect::<Vec<_>>(),\n-                actual.as_attr_slice(),\n+                &actual,\n                 pprust::attribute_to_string);\n }\n "}, {"sha": "42135703b75a4e9f3f9576ad71dc28f5c55bf109", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,17 +16,18 @@\n \n extern crate syntax;\n extern crate syntax_ext;\n+extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n #[plugin_registrar]"}, {"sha": "eeecd0b24e29ee60ef314c8c8a4b8b8e88279f5c", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,19 +16,20 @@\n \n extern crate syntax;\n extern crate syntax_ext;\n+extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::Span;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n #[plugin_registrar]"}, {"sha": "7f8a741465b30598b32e32b73592c94a8720ab1c", "filename": "src/test/run-pass-fulldeps/auxiliary/issue_16723_multiple_items_syntax_ext.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -16,19 +16,21 @@\n extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n+extern crate syntax_pos;\n \n use syntax::ast;\n-use syntax::codemap;\n use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n use syntax::util::small_vector::SmallVector;\n+use syntax::tokenstream;\n use rustc_plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"multiple_items\", expand)\n }\n \n-fn expand(cx: &mut ExtCtxt, _: codemap::Span, _: &[ast::TokenTree]) -> Box<MacResult+'static> {\n+fn expand(cx: &mut ExtCtxt, _: syntax_pos::Span, _: &[tokenstream::TokenTree])\n+          -> Box<MacResult+'static> {\n     MacEager::items(SmallVector::many(vec![\n         quote_item!(cx, struct Struct1;).unwrap(),\n         quote_item!(cx, struct Struct2;).unwrap()"}, {"sha": "11d81eda55625960ae69fcca3483de8072e7de35", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,12 +15,14 @@\n extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n+extern crate syntax_pos;\n \n-use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n-use syntax::codemap::Span;\n+use syntax::ast::{self, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n use syntax::ext::base::*;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n+use syntax::tokenstream::TokenTree;\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n #[macro_export]"}, {"sha": "f0edc0f2b120f887dde338ce2b9ae1774a1c4f9a", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,17 +14,19 @@\n #![feature(box_syntax, rustc_private)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n use std::borrow::ToOwned;\n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager, NormalTT};\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n+use syntax_pos::Span;\n+use syntax::tokenstream;\n use rustc_plugin::Registry;\n \n struct Expander {\n@@ -35,7 +37,7 @@ impl TTMacroExpander for Expander {\n     fn expand<'cx>(&self,\n                    ecx: &'cx mut ExtCtxt,\n                    sp: Span,\n-                   _: &[ast::TokenTree]) -> Box<MacResult+'cx> {\n+                   _: &[tokenstream::TokenTree]) -> Box<MacResult+'cx> {\n         let args = self.args.iter().map(|i| pprust::meta_item_to_string(&*i))\n             .collect::<Vec<_>>().join(\", \");\n         let interned = token::intern_and_get_ident(&args[..]);"}, {"sha": "5b1e210b0b2586b9449b341868910557cc1dbdb7", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -14,17 +14,19 @@\n #![feature(plugin_registrar, quote, rustc_private)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::codemap::Span;\n use syntax::parse::token::{self, str_to_ident, NtExpr, NtPat};\n-use syntax::ast::{TokenTree, Pat};\n+use syntax::ast::{Pat};\n+use syntax::tokenstream::{TokenTree};\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use syntax::ext::tt::macro_parser::{Success, Failure, Error};\n use syntax::ptr::P;\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])"}, {"sha": "0c8af013fd12d2ed69c467285ff233fa7f492415", "filename": "src/test/run-pass-fulldeps/auxiliary/roman_numerals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman_numerals.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,14 +15,15 @@\n #![feature(slice_patterns)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::codemap::Span;\n-use syntax::ast::TokenTree;\n use syntax::parse::token;\n+use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax::ext::build::AstBuilder;  // trait for expr_usize\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n // WARNING WARNING WARNING WARNING WARNING"}, {"sha": "72d262853555698199c17c2a9ce4d16bfd0b24c4", "filename": "src/test/run-pass-fulldeps/auxiliary/syntax_extension_with_dll_deps_2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763cec21f0b030c0d811bea3263b46361e99a14f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs?ref=763cec21f0b030c0d811bea3263b46361e99a14f", "patch": "@@ -15,12 +15,14 @@\n \n extern crate syntax_extension_with_dll_deps_1 as other;\n extern crate syntax;\n+extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::ast::{TokenTree, Item, MetaItem};\n-use syntax::codemap::Span;\n+use syntax::ast::{Item, MetaItem};\n use syntax::ext::base::*;\n+use syntax::tokenstream::TokenTree;\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n #[plugin_registrar]"}]}