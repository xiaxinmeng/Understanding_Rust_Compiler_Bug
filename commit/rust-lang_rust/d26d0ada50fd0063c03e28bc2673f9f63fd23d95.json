{"sha": "d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNmQwYWRhNTBmZDAwNjNjMDNlMjhiYzI2NzNmOWY2M2ZkMjNkOTU=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-12T15:47:17Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:47:31Z"}, "message": "restructure a bit", "tree": {"sha": "1292e2a6352b2bf886baed12cc69dab04dd82462", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1292e2a6352b2bf886baed12cc69dab04dd82462"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "html_url": "https://github.com/rust-lang/rust/commit/d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dd08b8023eba053725d5032149808b8733be263", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dd08b8023eba053725d5032149808b8733be263", "html_url": "https://github.com/rust-lang/rust/commit/0dd08b8023eba053725d5032149808b8733be263"}], "stats": {"total": 1570, "additions": 870, "deletions": 700}, "files": [{"sha": "c35d8da4104bde6672920d313e10fcc400412b68", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n use crate::{\n     db::RootDatabase,\n     display::ShortLabel,\n-    name_kind::{classify_name_ref, NameKind::*},\n+    references::{classify_name_ref, NameKind::*},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -54,8 +54,7 @@ pub(crate) fn reference_definition(\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n \n-    let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-    let name_kind = classify_name_ref(db, file_id, &analyzer, &name_ref).and_then(|d| Some(d.item));\n+    let name_kind = classify_name_ref(db, file_id, &name_ref).and_then(|d| Some(d.item));\n     match name_kind {\n         Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n         Some(FieldAccess(field)) => return Exact(NavigationTarget::from_field(db, field)),"}, {"sha": "189094ae5f5685ce51de4b5a984528599f76658c", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -14,7 +14,7 @@ use crate::{\n         description_from_symbol, docs_from_symbol, macro_label, rust_code_markup,\n         rust_code_markup_with_doc, ShortLabel,\n     },\n-    name_kind::{classify_name_ref, NameKind::*},\n+    references::{classify_name_ref, NameKind::*},\n     FilePosition, FileRange, RangeInfo,\n };\n \n@@ -99,11 +99,9 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n     let mut range = None;\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n-        let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-\n         let mut no_fallback = false;\n-        let name_kind = classify_name_ref(db, position.file_id, &analyzer, &name_ref)\n-            .and_then(|d| Some(d.item));\n+        let name_kind =\n+            classify_name_ref(db, position.file_id, &name_ref).and_then(|d| Some(d.item));\n         match name_kind {\n             Some(Macro(it)) => {\n                 let src = it.source(db);"}, {"sha": "19669a7f021c954fddd26e89a8b601e4edfdc35c", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -19,7 +19,6 @@ mod feature_flags;\n mod status;\n mod completion;\n mod runnables;\n-mod name_kind;\n mod goto_definition;\n mod goto_type_definition;\n mod extend_selection;\n@@ -41,7 +40,6 @@ mod matching_brace;\n mod display;\n mod inlay_hints;\n mod wasm_shims;\n-mod search_scope;\n \n #[cfg(test)]\n mod marks;"}, {"sha": "583399cfe9b4e65c535659f9a2ec608c316604b9", "filename": "crates/ra_ide_api/src/name_kind.rs", "status": "removed", "additions": 0, "deletions": 287, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/0dd08b8023eba053725d5032149808b8733be263/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd08b8023eba053725d5032149808b8733be263/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs?ref=0dd08b8023eba053725d5032149808b8733be263", "patch": "@@ -1,287 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use hir::{\n-    db::AstDatabase, Adt, AssocItem, DefWithBody, Either, EnumVariant, FromSource, HasSource,\n-    HirFileId, MacroDef, Module, ModuleDef, ModuleSource, Path, PathResolution, Source,\n-    SourceAnalyzer, StructField, Ty, VariantDef,\n-};\n-use ra_db::FileId;\n-use ra_syntax::{ast, ast::VisibilityOwner, match_ast, AstNode, AstPtr};\n-\n-use crate::db::RootDatabase;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub enum NameKind {\n-    Macro(MacroDef),\n-    FieldAccess(StructField),\n-    AssocItem(AssocItem),\n-    Def(ModuleDef),\n-    SelfType(Ty),\n-    Pat((DefWithBody, AstPtr<ast::BindPat>)),\n-    SelfParam(AstPtr<ast::SelfParam>),\n-    GenericParam(u32),\n-}\n-\n-#[derive(PartialEq, Eq)]\n-pub(crate) struct Definition {\n-    pub visibility: Option<ast::Visibility>,\n-    pub container: Module,\n-    pub item: NameKind,\n-}\n-\n-trait HasDefinition {\n-    type Def;\n-    type Ref;\n-\n-    fn definition(self, db: &RootDatabase) -> Definition;\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition>;\n-    fn from_ref(\n-        db: &RootDatabase,\n-        analyzer: &SourceAnalyzer,\n-        refer: Self::Ref,\n-    ) -> Option<Definition>;\n-}\n-\n-pub(crate) fn classify_name_ref(\n-    db: &RootDatabase,\n-    file_id: FileId,\n-    analyzer: &SourceAnalyzer,\n-    name_ref: &ast::NameRef,\n-) -> Option<Definition> {\n-    let parent = name_ref.syntax().parent()?;\n-    match_ast! {\n-        match parent {\n-            ast::MethodCallExpr(it) => {\n-                return AssocItem::from_ref(db, analyzer, it);\n-            },\n-            ast::FieldExpr(it) => {\n-                if let Some(field) = analyzer.resolve_field(&it) {\n-                    return Some(field.definition(db));\n-                }\n-            },\n-            ast::RecordField(it) => {\n-                if let Some(record_lit) = it.syntax().ancestors().find_map(ast::RecordLit::cast) {\n-                    let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n-                    let hir_path = Path::from_name_ref(name_ref);\n-                    let hir_name = hir_path.as_ident()?;\n-                    let field = variant_def.field(db, hir_name)?;\n-                    return Some(field.definition(db));\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    let ast = ModuleSource::from_child_node(db, file_id, &parent);\n-    let file_id = file_id.into();\n-    let container = Module::from_definition(db, Source { file_id, ast })?;\n-    let visibility = None;\n-\n-    if let Some(macro_call) =\n-        parent.parent().and_then(|node| node.parent()).and_then(ast::MacroCall::cast)\n-    {\n-        if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n-            return Some(Definition { item: NameKind::Macro(mac), container, visibility });\n-        }\n-    }\n-\n-    // General case, a path or a local:\n-    let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n-    let resolved = analyzer.resolve_path(db, &path)?;\n-    match resolved {\n-        PathResolution::Def(def) => Some(def.definition(db)),\n-        PathResolution::LocalBinding(Either::A(pat)) => decl_from_pat(db, file_id, pat),\n-        PathResolution::LocalBinding(Either::B(par)) => {\n-            Some(Definition { item: NameKind::SelfParam(par), container, visibility })\n-        }\n-        PathResolution::GenericParam(par) => {\n-            // FIXME: get generic param def\n-            Some(Definition { item: NameKind::GenericParam(par), container, visibility })\n-        }\n-        PathResolution::Macro(def) => {\n-            Some(Definition { item: NameKind::Macro(def), container, visibility })\n-        }\n-        PathResolution::SelfType(impl_block) => {\n-            let ty = impl_block.target_ty(db);\n-            let container = impl_block.module();\n-            Some(Definition { item: NameKind::SelfType(ty), container, visibility })\n-        }\n-        PathResolution::AssocItem(assoc) => Some(assoc.definition(db)),\n-    }\n-}\n-\n-pub(crate) fn classify_name(\n-    db: &RootDatabase,\n-    file_id: FileId,\n-    name: &ast::Name,\n-) -> Option<Definition> {\n-    let parent = name.syntax().parent()?;\n-    let file_id = file_id.into();\n-\n-    match_ast! {\n-        match parent {\n-            ast::BindPat(it) => {\n-                decl_from_pat(db, file_id, AstPtr::new(&it))\n-            },\n-            ast::RecordFieldDef(it) => {\n-                StructField::from_def(db, file_id, it)\n-            },\n-            ast::ImplItem(it) => {\n-                AssocItem::from_def(db, file_id, it.clone()).or_else(|| {\n-                    match it {\n-                        ast::ImplItem::FnDef(f) => ModuleDef::from_def(db, file_id, f.into()),\n-                        ast::ImplItem::ConstDef(c) => ModuleDef::from_def(db, file_id, c.into()),\n-                        ast::ImplItem::TypeAliasDef(a) => ModuleDef::from_def(db, file_id, a.into()),\n-                    }\n-                })\n-            },\n-            ast::EnumVariant(it) => {\n-                let src = hir::Source { file_id, ast: it.clone() };\n-                let def: ModuleDef = EnumVariant::from_source(db, src)?.into();\n-                Some(def.definition(db))\n-            },\n-            ast::ModuleItem(it) => {\n-                ModuleDef::from_def(db, file_id, it)\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n-\n-fn decl_from_pat(\n-    db: &RootDatabase,\n-    file_id: HirFileId,\n-    pat: AstPtr<ast::BindPat>,\n-) -> Option<Definition> {\n-    let root = db.parse_or_expand(file_id)?;\n-    // FIXME: use match_ast!\n-    let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n-        if let Some(it) = ast::FnDef::cast(node.clone()) {\n-            let src = hir::Source { file_id, ast: it };\n-            Some(hir::Function::from_source(db, src)?.into())\n-        } else if let Some(it) = ast::ConstDef::cast(node.clone()) {\n-            let src = hir::Source { file_id, ast: it };\n-            Some(hir::Const::from_source(db, src)?.into())\n-        } else if let Some(it) = ast::StaticDef::cast(node.clone()) {\n-            let src = hir::Source { file_id, ast: it };\n-            Some(hir::Static::from_source(db, src)?.into())\n-        } else {\n-            None\n-        }\n-    })?;\n-    let item = NameKind::Pat((def, pat));\n-    let container = def.module(db);\n-    Some(Definition { item, container, visibility: None })\n-}\n-\n-impl HasDefinition for StructField {\n-    type Def = ast::RecordFieldDef;\n-    type Ref = ast::FieldExpr;\n-\n-    fn definition(self, db: &RootDatabase) -> Definition {\n-        let item = NameKind::FieldAccess(self);\n-        let parent = self.parent_def(db);\n-        let container = parent.module(db);\n-        let visibility = match parent {\n-            VariantDef::Struct(s) => s.source(db).ast.visibility(),\n-            VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n-        };\n-        Definition { item, container, visibility }\n-    }\n-\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n-        let src = hir::Source { file_id, ast: hir::FieldSource::Named(def) };\n-        let field = StructField::from_source(db, src)?;\n-        Some(field.definition(db))\n-    }\n-\n-    fn from_ref(\n-        db: &RootDatabase,\n-        analyzer: &SourceAnalyzer,\n-        refer: Self::Ref,\n-    ) -> Option<Definition> {\n-        let field = analyzer.resolve_field(&refer)?;\n-        Some(field.definition(db))\n-    }\n-}\n-\n-impl HasDefinition for AssocItem {\n-    type Def = ast::ImplItem;\n-    type Ref = ast::MethodCallExpr;\n-\n-    fn definition(self, db: &RootDatabase) -> Definition {\n-        let item = NameKind::AssocItem(self);\n-        let container = self.module(db);\n-        let visibility = match self {\n-            AssocItem::Function(f) => f.source(db).ast.visibility(),\n-            AssocItem::Const(c) => c.source(db).ast.visibility(),\n-            AssocItem::TypeAlias(a) => a.source(db).ast.visibility(),\n-        };\n-        Definition { item, container, visibility }\n-    }\n-\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n-        if def.syntax().parent().and_then(ast::ItemList::cast).is_none() {\n-            return None;\n-        }\n-        let src = hir::Source { file_id, ast: def };\n-        let item = AssocItem::from_source(db, src)?;\n-        Some(item.definition(db))\n-    }\n-\n-    fn from_ref(\n-        db: &RootDatabase,\n-        analyzer: &SourceAnalyzer,\n-        refer: Self::Ref,\n-    ) -> Option<Definition> {\n-        let func: AssocItem = analyzer.resolve_method_call(&refer)?.into();\n-        Some(func.definition(db))\n-    }\n-}\n-\n-impl HasDefinition for ModuleDef {\n-    type Def = ast::ModuleItem;\n-    type Ref = ast::Path;\n-\n-    fn definition(self, db: &RootDatabase) -> Definition {\n-        let (container, visibility) = match self {\n-            ModuleDef::Module(it) => {\n-                let container = it.parent(db).or_else(|| Some(it)).unwrap();\n-                let visibility = it.declaration_source(db).and_then(|s| s.ast.visibility());\n-                (container, visibility)\n-            }\n-            ModuleDef::EnumVariant(it) => {\n-                let container = it.module(db);\n-                let visibility = it.source(db).ast.parent_enum().visibility();\n-                (container, visibility)\n-            }\n-            ModuleDef::Function(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Const(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Static(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Trait(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).ast.visibility()),\n-            ModuleDef::BuiltinType(..) => unreachable!(),\n-        };\n-        let item = NameKind::Def(self);\n-        Definition { item, container, visibility }\n-    }\n-\n-    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n-        let src = hir::Source { file_id, ast: def };\n-        let def = ModuleDef::from_source(db, src)?;\n-        Some(def.definition(db))\n-    }\n-\n-    fn from_ref(\n-        db: &RootDatabase,\n-        analyzer: &SourceAnalyzer,\n-        refer: Self::Ref,\n-    ) -> Option<Definition> {\n-        None\n-    }\n-}\n-\n-// FIXME: impl HasDefinition for hir::MacroDef"}, {"sha": "f5454278755db37aa1198ef2735ee9a4c8095a7a", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 66, "deletions": 351, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -1,16 +1,19 @@\n //! FIXME: write short doc here\n \n-use hir::ModuleSource;\n+mod classify;\n+mod definition;\n+mod rename;\n+mod search_scope;\n+\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n-use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SyntaxNode};\n-use relative_path::{RelativePath, RelativePathBuf};\n-\n-use crate::{\n-    db::RootDatabase,\n-    name_kind::{classify_name, classify_name_ref, Definition, NameKind::*},\n-    search_scope::find_refs,\n-    FileId, FilePosition, FileRange, FileSystemEdit, NavigationTarget, RangeInfo, SourceChange,\n-    SourceFileEdit, TextRange,\n+use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxNode, TextUnit};\n+\n+use crate::{db::RootDatabase, FileId, FilePosition, FileRange, NavigationTarget, RangeInfo};\n+\n+pub(crate) use self::{\n+    classify::{classify_name, classify_name_ref},\n+    definition::{Definition, NameKind},\n+    rename::rename,\n };\n \n #[derive(Debug, Clone)]\n@@ -59,169 +62,84 @@ pub(crate) fn find_all_refs(\n     let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position)?;\n \n     let declaration = match def.item {\n-        Macro(mac) => NavigationTarget::from_macro_def(db, mac),\n-        FieldAccess(field) => NavigationTarget::from_field(db, field),\n-        AssocItem(assoc) => NavigationTarget::from_assoc_item(db, assoc),\n-        Def(def) => NavigationTarget::from_def(db, def)?,\n-        SelfType(ref ty) => match ty.as_adt() {\n+        NameKind::Macro(mac) => NavigationTarget::from_macro_def(db, mac),\n+        NameKind::FieldAccess(field) => NavigationTarget::from_field(db, field),\n+        NameKind::AssocItem(assoc) => NavigationTarget::from_assoc_item(db, assoc),\n+        NameKind::Def(def) => NavigationTarget::from_def(db, def)?,\n+        NameKind::SelfType(ref ty) => match ty.as_adt() {\n             Some((def_id, _)) => NavigationTarget::from_adt_def(db, def_id),\n             None => return None,\n         },\n-        Pat((_, pat)) => NavigationTarget::from_pat(db, position.file_id, pat),\n-        SelfParam(par) => NavigationTarget::from_self_param(position.file_id, par),\n-        GenericParam(_) => return None,\n+        NameKind::Pat((_, pat)) => NavigationTarget::from_pat(db, position.file_id, pat),\n+        NameKind::SelfParam(par) => NavigationTarget::from_self_param(position.file_id, par),\n+        NameKind::GenericParam(_) => return None,\n     };\n \n-    // let references = match name_kind {\n-    //     Pat((_, pat)) => analyzer\n-    //         .find_all_refs(&pat.to_node(&syntax))\n-    //         .into_iter()\n-    //         .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n-    //         .collect::<Vec<_>>(),\n-    //     _ => vec![],\n-    // };\n-    let references = find_refs(db, def, name);\n-\n-    return Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }));\n-\n-    fn find_name<'a>(\n-        db: &RootDatabase,\n-        syntax: &SyntaxNode,\n-        position: FilePosition,\n-    ) -> Option<RangeInfo<(String, Definition)>> {\n-        if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n-            let def = classify_name(db, position.file_id, &name)?;\n-            let range = name.syntax().text_range();\n-            return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n-        }\n-        let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n-        let range = name_ref.syntax().text_range();\n-        let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-        let def = classify_name_ref(db, position.file_id, &analyzer, &name_ref)?;\n-        Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n-    }\n-}\n+    let references = process_definition(db, def, name);\n \n-pub(crate) fn rename(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-    new_name: &str,\n-) -> Option<RangeInfo<SourceChange>> {\n-    let parse = db.parse(position.file_id);\n-    if let Some((ast_name, ast_module)) =\n-        find_name_and_module_at_offset(parse.tree().syntax(), position)\n-    {\n-        let range = ast_name.syntax().text_range();\n-        rename_mod(db, &ast_name, &ast_module, position, new_name)\n-            .map(|info| RangeInfo::new(range, info))\n-    } else {\n-        rename_reference(db, position, new_name)\n-    }\n+    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n }\n \n-fn find_name_and_module_at_offset(\n+fn find_name<'a>(\n+    db: &RootDatabase,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> Option<(ast::Name, ast::Module)> {\n-    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset)?;\n-    let ast_module = ast::Module::cast(ast_name.syntax().parent()?)?;\n-    Some((ast_name, ast_module))\n-}\n-\n-fn source_edit_from_file_id_range(\n-    file_id: FileId,\n-    range: TextRange,\n-    new_name: &str,\n-) -> SourceFileEdit {\n-    SourceFileEdit {\n-        file_id,\n-        edit: {\n-            let mut builder = ra_text_edit::TextEditBuilder::default();\n-            builder.replace(range, new_name.into());\n-            builder.finish()\n-        },\n+) -> Option<RangeInfo<(String, Definition)>> {\n+    if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n+        let def = classify_name(db, position.file_id, &name)?;\n+        let range = name.syntax().text_range();\n+        return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n     }\n+    let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n+    let def = classify_name_ref(db, position.file_id, &name_ref)?;\n+    let range = name_ref.syntax().text_range();\n+    Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n }\n \n-fn rename_mod(\n-    db: &RootDatabase,\n-    ast_name: &ast::Name,\n-    ast_module: &ast::Module,\n-    position: FilePosition,\n-    new_name: &str,\n-) -> Option<SourceChange> {\n-    let mut source_file_edits = Vec::new();\n-    let mut file_system_edits = Vec::new();\n-    let module_src = hir::Source { file_id: position.file_id.into(), ast: ast_module.clone() };\n-    if let Some(module) = hir::Module::from_declaration(db, module_src) {\n-        let src = module.definition_source(db);\n-        let file_id = src.file_id.original_file(db);\n-        match src.ast {\n-            ModuleSource::SourceFile(..) => {\n-                let mod_path: RelativePathBuf = db.file_relative_path(file_id);\n-                // mod is defined in path/to/dir/mod.rs\n-                let dst_path = if mod_path.file_stem() == Some(\"mod\") {\n-                    mod_path\n-                        .parent()\n-                        .and_then(|p| p.parent())\n-                        .or_else(|| Some(RelativePath::new(\"\")))\n-                        .map(|p| p.join(new_name).join(\"mod.rs\"))\n-                } else {\n-                    Some(mod_path.with_file_name(new_name).with_extension(\"rs\"))\n-                };\n-                if let Some(path) = dst_path {\n-                    let move_file = FileSystemEdit::MoveFile {\n-                        src: file_id,\n-                        dst_source_root: db.file_source_root(position.file_id),\n-                        dst_path: path,\n-                    };\n-                    file_system_edits.push(move_file);\n-                }\n-            }\n-            ModuleSource::Module(..) => {}\n+fn process_definition(db: &RootDatabase, def: Definition, name: String) -> Vec<FileRange> {\n+    let pat = name.as_str();\n+    let scope = def.scope(db).scope;\n+    let mut refs = vec![];\n+\n+    let is_match = |file_id: FileId, name_ref: &ast::NameRef| -> bool {\n+        let classified = classify_name_ref(db, file_id, &name_ref);\n+        if let Some(d) = classified {\n+            d == def\n+        } else {\n+            false\n         }\n-    }\n-\n-    let edit = SourceFileEdit {\n-        file_id: position.file_id,\n-        edit: {\n-            let mut builder = ra_text_edit::TextEditBuilder::default();\n-            builder.replace(ast_name.syntax().text_range(), new_name.into());\n-            builder.finish()\n-        },\n     };\n-    source_file_edits.push(edit);\n-\n-    Some(SourceChange::from_edits(\"rename\", source_file_edits, file_system_edits))\n-}\n-\n-fn rename_reference(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-    new_name: &str,\n-) -> Option<RangeInfo<SourceChange>> {\n-    let RangeInfo { range, info: refs } = find_all_refs(db, position)?;\n-\n-    let edit = refs\n-        .into_iter()\n-        .map(|range| source_edit_from_file_id_range(range.file_id, range.range, new_name))\n-        .collect::<Vec<_>>();\n \n-    if edit.is_empty() {\n-        return None;\n+    for (file_id, text_range) in scope {\n+        let text = db.file_text(file_id);\n+        let parse = SourceFile::parse(&text);\n+        let syntax = parse.tree().syntax().clone();\n+\n+        for (idx, _) in text.match_indices(pat) {\n+            let offset = TextUnit::from_usize(idx);\n+            if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&syntax, offset) {\n+                let range = name_ref.syntax().text_range();\n+\n+                if let Some(text_range) = text_range {\n+                    if range.is_subrange(&text_range) && is_match(file_id, &name_ref) {\n+                        refs.push(FileRange { file_id, range });\n+                    }\n+                } else if is_match(file_id, &name_ref) {\n+                    refs.push(FileRange { file_id, range });\n+                }\n+            }\n+        }\n     }\n \n-    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"rename\", edit)))\n+    return refs;\n }\n \n #[cfg(test)]\n mod tests {\n     use crate::{\n-        mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n+        mock_analysis::analysis_and_position, mock_analysis::single_file_with_position,\n         ReferenceSearchResult,\n     };\n-    use insta::assert_debug_snapshot;\n-    use test_utils::assert_eq_text;\n \n     #[test]\n     fn test_find_all_refs_for_local() {\n@@ -353,207 +271,4 @@ mod tests {\n         let (analysis, position) = single_file_with_position(text);\n         analysis.find_all_refs(position).unwrap().unwrap()\n     }\n-\n-    #[test]\n-    fn test_rename_for_local() {\n-        test_rename(\n-            r#\"\n-    fn main() {\n-        let mut i = 1;\n-        let j = 1;\n-        i = i<|> + j;\n-\n-        {\n-            i = 0;\n-        }\n-\n-        i = 5;\n-    }\"#,\n-            \"k\",\n-            r#\"\n-    fn main() {\n-        let mut k = 1;\n-        let j = 1;\n-        k = k + j;\n-\n-        {\n-            k = 0;\n-        }\n-\n-        k = 5;\n-    }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_rename_for_param_inside() {\n-        test_rename(\n-            r#\"\n-    fn foo(i : u32) -> u32 {\n-        i<|>\n-    }\"#,\n-            \"j\",\n-            r#\"\n-    fn foo(j : u32) -> u32 {\n-        j\n-    }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_rename_refs_for_fn_param() {\n-        test_rename(\n-            r#\"\n-    fn foo(i<|> : u32) -> u32 {\n-        i\n-    }\"#,\n-            \"new_name\",\n-            r#\"\n-    fn foo(new_name : u32) -> u32 {\n-        new_name\n-    }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_rename_for_mut_param() {\n-        test_rename(\n-            r#\"\n-    fn foo(mut i<|> : u32) -> u32 {\n-        i\n-    }\"#,\n-            \"new_name\",\n-            r#\"\n-    fn foo(mut new_name : u32) -> u32 {\n-        new_name\n-    }\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_rename_mod() {\n-        let (analysis, position) = analysis_and_position(\n-            \"\n-            //- /lib.rs\n-            mod bar;\n-\n-            //- /bar.rs\n-            mod foo<|>;\n-\n-            //- /bar/foo.rs\n-            // emtpy\n-            \",\n-        );\n-        let new_name = \"foo2\";\n-        let source_change = analysis.rename(position, new_name).unwrap();\n-        assert_debug_snapshot!(&source_change,\n-@r###\"\n-        Some(\n-            RangeInfo {\n-                range: [4; 7),\n-                info: SourceChange {\n-                    label: \"rename\",\n-                    source_file_edits: [\n-                        SourceFileEdit {\n-                            file_id: FileId(\n-                                2,\n-                            ),\n-                            edit: TextEdit {\n-                                atoms: [\n-                                    AtomTextEdit {\n-                                        delete: [4; 7),\n-                                        insert: \"foo2\",\n-                                    },\n-                                ],\n-                            },\n-                        },\n-                    ],\n-                    file_system_edits: [\n-                        MoveFile {\n-                            src: FileId(\n-                                3,\n-                            ),\n-                            dst_source_root: SourceRootId(\n-                                0,\n-                            ),\n-                            dst_path: \"bar/foo2.rs\",\n-                        },\n-                    ],\n-                    cursor_position: None,\n-                },\n-            },\n-        )\n-        \"###);\n-    }\n-\n-    #[test]\n-    fn test_rename_mod_in_dir() {\n-        let (analysis, position) = analysis_and_position(\n-            \"\n-            //- /lib.rs\n-            mod fo<|>o;\n-            //- /foo/mod.rs\n-            // emtpy\n-            \",\n-        );\n-        let new_name = \"foo2\";\n-        let source_change = analysis.rename(position, new_name).unwrap();\n-        assert_debug_snapshot!(&source_change,\n-        @r###\"\n-        Some(\n-            RangeInfo {\n-                range: [4; 7),\n-                info: SourceChange {\n-                    label: \"rename\",\n-                    source_file_edits: [\n-                        SourceFileEdit {\n-                            file_id: FileId(\n-                                1,\n-                            ),\n-                            edit: TextEdit {\n-                                atoms: [\n-                                    AtomTextEdit {\n-                                        delete: [4; 7),\n-                                        insert: \"foo2\",\n-                                    },\n-                                ],\n-                            },\n-                        },\n-                    ],\n-                    file_system_edits: [\n-                        MoveFile {\n-                            src: FileId(\n-                                2,\n-                            ),\n-                            dst_source_root: SourceRootId(\n-                                0,\n-                            ),\n-                            dst_path: \"foo2/mod.rs\",\n-                        },\n-                    ],\n-                    cursor_position: None,\n-                },\n-            },\n-        )\n-        \"###\n-               );\n-    }\n-\n-    fn test_rename(text: &str, new_name: &str, expected: &str) {\n-        let (analysis, position) = single_file_with_position(text);\n-        let source_change = analysis.rename(position, new_name).unwrap();\n-        let mut text_edit_builder = ra_text_edit::TextEditBuilder::default();\n-        let mut file_id: Option<FileId> = None;\n-        if let Some(change) = source_change {\n-            for edit in change.info.source_file_edits {\n-                file_id = Some(edit.file_id);\n-                for atom in edit.edit.as_atoms() {\n-                    text_edit_builder.replace(atom.delete, atom.insert.clone());\n-                }\n-            }\n-        }\n-        let result =\n-            text_edit_builder.finish().apply(&*analysis.file_text(file_id.unwrap()).unwrap());\n-        assert_eq_text!(expected, &*result);\n-    }\n }"}, {"sha": "0b604a5cf7c9fc8cb8d267e1eac4a78b000f491c", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -0,0 +1,143 @@\n+use hir::{\n+    AssocItem, Either, EnumVariant, FromSource, Module, ModuleDef, ModuleSource, Path,\n+    PathResolution, Source, SourceAnalyzer, StructField,\n+};\n+use ra_db::FileId;\n+use ra_syntax::{ast, match_ast, AstNode, AstPtr};\n+\n+use super::{definition::HasDefinition, Definition, NameKind};\n+use crate::db::RootDatabase;\n+\n+use hir::{db::AstDatabase, HirFileId};\n+\n+pub(crate) fn classify_name(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    name: &ast::Name,\n+) -> Option<Definition> {\n+    let parent = name.syntax().parent()?;\n+    let file_id = file_id.into();\n+\n+    match_ast! {\n+        match parent {\n+            ast::BindPat(it) => {\n+                decl_from_pat(db, file_id, AstPtr::new(&it))\n+            },\n+            ast::RecordFieldDef(it) => {\n+                StructField::from_def(db, file_id, it)\n+            },\n+            ast::ImplItem(it) => {\n+                AssocItem::from_def(db, file_id, it.clone()).or_else(|| {\n+                    match it {\n+                        ast::ImplItem::FnDef(f) => ModuleDef::from_def(db, file_id, f.into()),\n+                        ast::ImplItem::ConstDef(c) => ModuleDef::from_def(db, file_id, c.into()),\n+                        ast::ImplItem::TypeAliasDef(a) => ModuleDef::from_def(db, file_id, a.into()),\n+                    }\n+                })\n+            },\n+            ast::EnumVariant(it) => {\n+                let src = hir::Source { file_id, ast: it.clone() };\n+                let def: ModuleDef = EnumVariant::from_source(db, src)?.into();\n+                Some(def.definition(db))\n+            },\n+            ast::ModuleItem(it) => {\n+                ModuleDef::from_def(db, file_id, it)\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub(crate) fn classify_name_ref(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    name_ref: &ast::NameRef,\n+) -> Option<Definition> {\n+    let analyzer = SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n+    let parent = name_ref.syntax().parent()?;\n+    match_ast! {\n+        match parent {\n+            ast::MethodCallExpr(it) => {\n+                return AssocItem::from_ref(db, &analyzer, it);\n+            },\n+            ast::FieldExpr(it) => {\n+                if let Some(field) = analyzer.resolve_field(&it) {\n+                    return Some(field.definition(db));\n+                }\n+            },\n+            ast::RecordField(it) => {\n+                if let Some(record_lit) = it.syntax().ancestors().find_map(ast::RecordLit::cast) {\n+                    let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n+                    let hir_path = Path::from_name_ref(name_ref);\n+                    let hir_name = hir_path.as_ident()?;\n+                    let field = variant_def.field(db, hir_name)?;\n+                    return Some(field.definition(db));\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    let ast = ModuleSource::from_child_node(db, file_id, &parent);\n+    let file_id = file_id.into();\n+    let container = Module::from_definition(db, Source { file_id, ast })?;\n+    let visibility = None;\n+\n+    if let Some(macro_call) =\n+        parent.parent().and_then(|node| node.parent()).and_then(ast::MacroCall::cast)\n+    {\n+        if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n+            return Some(Definition { item: NameKind::Macro(mac), container, visibility });\n+        }\n+    }\n+\n+    // General case, a path or a local:\n+    let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n+    let resolved = analyzer.resolve_path(db, &path)?;\n+    match resolved {\n+        PathResolution::Def(def) => Some(def.definition(db)),\n+        PathResolution::LocalBinding(Either::A(pat)) => decl_from_pat(db, file_id, pat),\n+        PathResolution::LocalBinding(Either::B(par)) => {\n+            Some(Definition { item: NameKind::SelfParam(par), container, visibility })\n+        }\n+        PathResolution::GenericParam(par) => {\n+            // FIXME: get generic param def\n+            Some(Definition { item: NameKind::GenericParam(par), container, visibility })\n+        }\n+        PathResolution::Macro(def) => {\n+            Some(Definition { item: NameKind::Macro(def), container, visibility })\n+        }\n+        PathResolution::SelfType(impl_block) => {\n+            let ty = impl_block.target_ty(db);\n+            let container = impl_block.module();\n+            Some(Definition { item: NameKind::SelfType(ty), container, visibility })\n+        }\n+        PathResolution::AssocItem(assoc) => Some(assoc.definition(db)),\n+    }\n+}\n+\n+fn decl_from_pat(\n+    db: &RootDatabase,\n+    file_id: HirFileId,\n+    pat: AstPtr<ast::BindPat>,\n+) -> Option<Definition> {\n+    let root = db.parse_or_expand(file_id)?;\n+    // FIXME: use match_ast!\n+    let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n+        if let Some(it) = ast::FnDef::cast(node.clone()) {\n+            let src = hir::Source { file_id, ast: it };\n+            Some(hir::Function::from_source(db, src)?.into())\n+        } else if let Some(it) = ast::ConstDef::cast(node.clone()) {\n+            let src = hir::Source { file_id, ast: it };\n+            Some(hir::Const::from_source(db, src)?.into())\n+        } else if let Some(it) = ast::StaticDef::cast(node.clone()) {\n+            let src = hir::Source { file_id, ast: it };\n+            Some(hir::Static::from_source(db, src)?.into())\n+        } else {\n+            None\n+        }\n+    })?;\n+    let item = NameKind::Pat((def, pat));\n+    let container = def.module(db);\n+    Some(Definition { item, container, visibility: None })\n+}"}, {"sha": "65b1f8dd77d38075db3ebc56ea75c51c5ef14c9e", "filename": "crates/ra_ide_api/src/references/definition.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fdefinition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fdefinition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fdefinition.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -0,0 +1,177 @@\n+use hir::{\n+    db::AstDatabase, Adt, AssocItem, DefWithBody, FromSource, HasSource, HirFileId, MacroDef,\n+    Module, ModuleDef, SourceAnalyzer, StructField, Ty, VariantDef,\n+};\n+use ra_syntax::{ast, ast::VisibilityOwner, AstNode, AstPtr};\n+\n+use crate::db::RootDatabase;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum NameKind {\n+    Macro(MacroDef),\n+    FieldAccess(StructField),\n+    AssocItem(AssocItem),\n+    Def(ModuleDef),\n+    SelfType(Ty),\n+    Pat((DefWithBody, AstPtr<ast::BindPat>)),\n+    SelfParam(AstPtr<ast::SelfParam>),\n+    GenericParam(u32),\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub(crate) struct Definition {\n+    pub visibility: Option<ast::Visibility>,\n+    pub container: Module,\n+    pub item: NameKind,\n+}\n+\n+pub(super) trait HasDefinition {\n+    type Def;\n+    type Ref;\n+\n+    fn definition(self, db: &RootDatabase) -> Definition;\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition>;\n+    fn from_ref(\n+        db: &RootDatabase,\n+        analyzer: &SourceAnalyzer,\n+        refer: Self::Ref,\n+    ) -> Option<Definition>;\n+}\n+\n+// fn decl_from_pat(\n+//     db: &RootDatabase,\n+//     file_id: HirFileId,\n+//     pat: AstPtr<ast::BindPat>,\n+// ) -> Option<Definition> {\n+//     let root = db.parse_or_expand(file_id)?;\n+//     // FIXME: use match_ast!\n+//     let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n+//         if let Some(it) = ast::FnDef::cast(node.clone()) {\n+//             let src = hir::Source { file_id, ast: it };\n+//             Some(hir::Function::from_source(db, src)?.into())\n+//         } else if let Some(it) = ast::ConstDef::cast(node.clone()) {\n+//             let src = hir::Source { file_id, ast: it };\n+//             Some(hir::Const::from_source(db, src)?.into())\n+//         } else if let Some(it) = ast::StaticDef::cast(node.clone()) {\n+//             let src = hir::Source { file_id, ast: it };\n+//             Some(hir::Static::from_source(db, src)?.into())\n+//         } else {\n+//             None\n+//         }\n+//     })?;\n+//     let item = NameKind::Pat((def, pat));\n+//     let container = def.module(db);\n+//     Some(Definition { item, container, visibility: None })\n+// }\n+\n+impl HasDefinition for StructField {\n+    type Def = ast::RecordFieldDef;\n+    type Ref = ast::FieldExpr;\n+\n+    fn definition(self, db: &RootDatabase) -> Definition {\n+        let item = NameKind::FieldAccess(self);\n+        let parent = self.parent_def(db);\n+        let container = parent.module(db);\n+        let visibility = match parent {\n+            VariantDef::Struct(s) => s.source(db).ast.visibility(),\n+            VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n+        };\n+        Definition { item, container, visibility }\n+    }\n+\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n+        let src = hir::Source { file_id, ast: hir::FieldSource::Named(def) };\n+        let field = StructField::from_source(db, src)?;\n+        Some(field.definition(db))\n+    }\n+\n+    fn from_ref(\n+        db: &RootDatabase,\n+        analyzer: &SourceAnalyzer,\n+        refer: Self::Ref,\n+    ) -> Option<Definition> {\n+        let field = analyzer.resolve_field(&refer)?;\n+        Some(field.definition(db))\n+    }\n+}\n+\n+impl HasDefinition for AssocItem {\n+    type Def = ast::ImplItem;\n+    type Ref = ast::MethodCallExpr;\n+\n+    fn definition(self, db: &RootDatabase) -> Definition {\n+        let item = NameKind::AssocItem(self);\n+        let container = self.module(db);\n+        let visibility = match self {\n+            AssocItem::Function(f) => f.source(db).ast.visibility(),\n+            AssocItem::Const(c) => c.source(db).ast.visibility(),\n+            AssocItem::TypeAlias(a) => a.source(db).ast.visibility(),\n+        };\n+        Definition { item, container, visibility }\n+    }\n+\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n+        if def.syntax().parent().and_then(ast::ItemList::cast).is_none() {\n+            return None;\n+        }\n+        let src = hir::Source { file_id, ast: def };\n+        let item = AssocItem::from_source(db, src)?;\n+        Some(item.definition(db))\n+    }\n+\n+    fn from_ref(\n+        db: &RootDatabase,\n+        analyzer: &SourceAnalyzer,\n+        refer: Self::Ref,\n+    ) -> Option<Definition> {\n+        let func: AssocItem = analyzer.resolve_method_call(&refer)?.into();\n+        Some(func.definition(db))\n+    }\n+}\n+\n+impl HasDefinition for ModuleDef {\n+    type Def = ast::ModuleItem;\n+    type Ref = ast::Path;\n+\n+    fn definition(self, db: &RootDatabase) -> Definition {\n+        let (container, visibility) = match self {\n+            ModuleDef::Module(it) => {\n+                let container = it.parent(db).or_else(|| Some(it)).unwrap();\n+                let visibility = it.declaration_source(db).and_then(|s| s.ast.visibility());\n+                (container, visibility)\n+            }\n+            ModuleDef::EnumVariant(it) => {\n+                let container = it.module(db);\n+                let visibility = it.source(db).ast.parent_enum().visibility();\n+                (container, visibility)\n+            }\n+            ModuleDef::Function(it) => (it.module(db), it.source(db).ast.visibility()),\n+            ModuleDef::Const(it) => (it.module(db), it.source(db).ast.visibility()),\n+            ModuleDef::Static(it) => (it.module(db), it.source(db).ast.visibility()),\n+            ModuleDef::Trait(it) => (it.module(db), it.source(db).ast.visibility()),\n+            ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).ast.visibility()),\n+            ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).ast.visibility()),\n+            ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).ast.visibility()),\n+            ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).ast.visibility()),\n+            ModuleDef::BuiltinType(..) => unreachable!(),\n+        };\n+        let item = NameKind::Def(self);\n+        Definition { item, container, visibility }\n+    }\n+\n+    fn from_def(db: &RootDatabase, file_id: HirFileId, def: Self::Def) -> Option<Definition> {\n+        let src = hir::Source { file_id, ast: def };\n+        let def = ModuleDef::from_source(db, src)?;\n+        Some(def.definition(db))\n+    }\n+\n+    fn from_ref(\n+        db: &RootDatabase,\n+        analyzer: &SourceAnalyzer,\n+        refer: Self::Ref,\n+    ) -> Option<Definition> {\n+        None\n+    }\n+}\n+\n+// FIXME: impl HasDefinition for hir::MacroDef"}, {"sha": "7e564a40eb1a4210a3ca7d9ec3ea120f36e3ed0f", "filename": "crates/ra_ide_api/src/references/rename.rs", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -0,0 +1,467 @@\n+use hir::ModuleSource;\n+use ra_db::SourceDatabase;\n+use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SyntaxNode};\n+use relative_path::{RelativePath, RelativePathBuf};\n+\n+use crate::{\n+    db::RootDatabase, FileId, FilePosition, FileSystemEdit, RangeInfo, SourceChange,\n+    SourceFileEdit, TextRange,\n+};\n+\n+use super::find_all_refs;\n+\n+pub(crate) fn rename(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    new_name: &str,\n+) -> Option<RangeInfo<SourceChange>> {\n+    let parse = db.parse(position.file_id);\n+    if let Some((ast_name, ast_module)) =\n+        find_name_and_module_at_offset(parse.tree().syntax(), position)\n+    {\n+        let range = ast_name.syntax().text_range();\n+        rename_mod(db, &ast_name, &ast_module, position, new_name)\n+            .map(|info| RangeInfo::new(range, info))\n+    } else {\n+        rename_reference(db, position, new_name)\n+    }\n+}\n+\n+fn find_name_and_module_at_offset(\n+    syntax: &SyntaxNode,\n+    position: FilePosition,\n+) -> Option<(ast::Name, ast::Module)> {\n+    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset)?;\n+    let ast_module = ast::Module::cast(ast_name.syntax().parent()?)?;\n+    Some((ast_name, ast_module))\n+}\n+\n+fn source_edit_from_file_id_range(\n+    file_id: FileId,\n+    range: TextRange,\n+    new_name: &str,\n+) -> SourceFileEdit {\n+    SourceFileEdit {\n+        file_id,\n+        edit: {\n+            let mut builder = ra_text_edit::TextEditBuilder::default();\n+            builder.replace(range, new_name.into());\n+            builder.finish()\n+        },\n+    }\n+}\n+\n+fn rename_mod(\n+    db: &RootDatabase,\n+    ast_name: &ast::Name,\n+    ast_module: &ast::Module,\n+    position: FilePosition,\n+    new_name: &str,\n+) -> Option<SourceChange> {\n+    let mut source_file_edits = Vec::new();\n+    let mut file_system_edits = Vec::new();\n+    let module_src = hir::Source { file_id: position.file_id.into(), ast: ast_module.clone() };\n+    if let Some(module) = hir::Module::from_declaration(db, module_src) {\n+        let src = module.definition_source(db);\n+        let file_id = src.file_id.original_file(db);\n+        match src.ast {\n+            ModuleSource::SourceFile(..) => {\n+                let mod_path: RelativePathBuf = db.file_relative_path(file_id);\n+                // mod is defined in path/to/dir/mod.rs\n+                let dst_path = if mod_path.file_stem() == Some(\"mod\") {\n+                    mod_path\n+                        .parent()\n+                        .and_then(|p| p.parent())\n+                        .or_else(|| Some(RelativePath::new(\"\")))\n+                        .map(|p| p.join(new_name).join(\"mod.rs\"))\n+                } else {\n+                    Some(mod_path.with_file_name(new_name).with_extension(\"rs\"))\n+                };\n+                if let Some(path) = dst_path {\n+                    let move_file = FileSystemEdit::MoveFile {\n+                        src: file_id,\n+                        dst_source_root: db.file_source_root(position.file_id),\n+                        dst_path: path,\n+                    };\n+                    file_system_edits.push(move_file);\n+                }\n+            }\n+            ModuleSource::Module(..) => {}\n+        }\n+    }\n+\n+    let edit = SourceFileEdit {\n+        file_id: position.file_id,\n+        edit: {\n+            let mut builder = ra_text_edit::TextEditBuilder::default();\n+            builder.replace(ast_name.syntax().text_range(), new_name.into());\n+            builder.finish()\n+        },\n+    };\n+    source_file_edits.push(edit);\n+\n+    Some(SourceChange::from_edits(\"rename\", source_file_edits, file_system_edits))\n+}\n+\n+fn rename_reference(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    new_name: &str,\n+) -> Option<RangeInfo<SourceChange>> {\n+    let RangeInfo { range, info: refs } = find_all_refs(db, position)?;\n+\n+    let edit = refs\n+        .into_iter()\n+        .map(|range| source_edit_from_file_id_range(range.file_id, range.range, new_name))\n+        .collect::<Vec<_>>();\n+\n+    if edit.is_empty() {\n+        return None;\n+    }\n+\n+    Some(RangeInfo::new(range, SourceChange::source_file_edits(\"rename\", edit)))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n+        ReferenceSearchResult,\n+    };\n+    use insta::assert_debug_snapshot;\n+    use test_utils::assert_eq_text;\n+\n+    #[test]\n+    fn test_find_all_refs_for_local() {\n+        let code = r#\"\n+    fn main() {\n+        let mut i = 1;\n+        let j = 1;\n+        i = i<|> + j;\n+\n+        {\n+            i = 0;\n+        }\n+\n+        i = 5;\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 5);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_param_inside() {\n+        let code = r#\"\n+    fn foo(i : u32) -> u32 {\n+        i<|>\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_fn_param() {\n+        let code = r#\"\n+    fn foo(i<|> : u32) -> u32 {\n+        i\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_field_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo {\n+                pub spam<|>: u32,\n+            }\n+\n+            fn main(s: Foo) {\n+                let f = s.spam;\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_impl_item_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo;\n+            impl Foo {\n+                fn f<|>(&self) {  }\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_enum_var_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            enum Foo {\n+                A,\n+                B<|>,\n+                C,\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_modules() {\n+        let code = r#\"\n+            //- /lib.rs\n+            pub mod foo;\n+            pub mod bar;\n+\n+            fn f() {\n+                let i = foo::Foo { n: 5 };\n+            }\n+\n+            //- /foo.rs\n+            use crate::bar;\n+\n+            pub struct Foo {\n+                pub n: u32,\n+            }\n+\n+            fn f() {\n+                let i = bar::Bar { n: 5 };\n+            }\n+\n+            //- /bar.rs\n+            use crate::foo;\n+\n+            pub struct Bar {\n+                pub n: u32,\n+            }\n+\n+            fn f() {\n+                let i = foo::Foo<|> { n: 5 };\n+            }\n+        \"#;\n+\n+        let (analysis, pos) = analysis_and_position(code);\n+        let refs = analysis.find_all_refs(pos).unwrap().unwrap();\n+        assert_eq!(refs.len(), 3);\n+    }\n+\n+    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n+        let (analysis, position) = single_file_with_position(text);\n+        analysis.find_all_refs(position).unwrap().unwrap()\n+    }\n+\n+    #[test]\n+    fn test_rename_for_local() {\n+        test_rename(\n+            r#\"\n+    fn main() {\n+        let mut i = 1;\n+        let j = 1;\n+        i = i<|> + j;\n+\n+        {\n+            i = 0;\n+        }\n+\n+        i = 5;\n+    }\"#,\n+            \"k\",\n+            r#\"\n+    fn main() {\n+        let mut k = 1;\n+        let j = 1;\n+        k = k + j;\n+\n+        {\n+            k = 0;\n+        }\n+\n+        k = 5;\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_for_param_inside() {\n+        test_rename(\n+            r#\"\n+    fn foo(i : u32) -> u32 {\n+        i<|>\n+    }\"#,\n+            \"j\",\n+            r#\"\n+    fn foo(j : u32) -> u32 {\n+        j\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_refs_for_fn_param() {\n+        test_rename(\n+            r#\"\n+    fn foo(i<|> : u32) -> u32 {\n+        i\n+    }\"#,\n+            \"new_name\",\n+            r#\"\n+    fn foo(new_name : u32) -> u32 {\n+        new_name\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_for_mut_param() {\n+        test_rename(\n+            r#\"\n+    fn foo(mut i<|> : u32) -> u32 {\n+        i\n+    }\"#,\n+            \"new_name\",\n+            r#\"\n+    fn foo(mut new_name : u32) -> u32 {\n+        new_name\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_mod() {\n+        let (analysis, position) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod bar;\n+\n+            //- /bar.rs\n+            mod foo<|>;\n+\n+            //- /bar/foo.rs\n+            // emtpy\n+            \",\n+        );\n+        let new_name = \"foo2\";\n+        let source_change = analysis.rename(position, new_name).unwrap();\n+        assert_debug_snapshot!(&source_change,\n+@r###\"\n+        Some(\n+            RangeInfo {\n+                range: [4; 7),\n+                info: SourceChange {\n+                    label: \"rename\",\n+                    source_file_edits: [\n+                        SourceFileEdit {\n+                            file_id: FileId(\n+                                2,\n+                            ),\n+                            edit: TextEdit {\n+                                atoms: [\n+                                    AtomTextEdit {\n+                                        delete: [4; 7),\n+                                        insert: \"foo2\",\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                    ],\n+                    file_system_edits: [\n+                        MoveFile {\n+                            src: FileId(\n+                                3,\n+                            ),\n+                            dst_source_root: SourceRootId(\n+                                0,\n+                            ),\n+                            dst_path: \"bar/foo2.rs\",\n+                        },\n+                    ],\n+                    cursor_position: None,\n+                },\n+            },\n+        )\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn test_rename_mod_in_dir() {\n+        let (analysis, position) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod fo<|>o;\n+            //- /foo/mod.rs\n+            // emtpy\n+            \",\n+        );\n+        let new_name = \"foo2\";\n+        let source_change = analysis.rename(position, new_name).unwrap();\n+        assert_debug_snapshot!(&source_change,\n+        @r###\"\n+        Some(\n+            RangeInfo {\n+                range: [4; 7),\n+                info: SourceChange {\n+                    label: \"rename\",\n+                    source_file_edits: [\n+                        SourceFileEdit {\n+                            file_id: FileId(\n+                                1,\n+                            ),\n+                            edit: TextEdit {\n+                                atoms: [\n+                                    AtomTextEdit {\n+                                        delete: [4; 7),\n+                                        insert: \"foo2\",\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                    ],\n+                    file_system_edits: [\n+                        MoveFile {\n+                            src: FileId(\n+                                2,\n+                            ),\n+                            dst_source_root: SourceRootId(\n+                                0,\n+                            ),\n+                            dst_path: \"foo2/mod.rs\",\n+                        },\n+                    ],\n+                    cursor_position: None,\n+                },\n+            },\n+        )\n+        \"###\n+               );\n+    }\n+\n+    fn test_rename(text: &str, new_name: &str, expected: &str) {\n+        let (analysis, position) = single_file_with_position(text);\n+        let source_change = analysis.rename(position, new_name).unwrap();\n+        let mut text_edit_builder = ra_text_edit::TextEditBuilder::default();\n+        let mut file_id: Option<FileId> = None;\n+        if let Some(change) = source_change {\n+            for edit in change.info.source_file_edits {\n+                file_id = Some(edit.file_id);\n+                for atom in edit.edit.as_atoms() {\n+                    text_edit_builder.replace(atom.delete, atom.insert.clone());\n+                }\n+            }\n+        }\n+        let result =\n+            text_edit_builder.finish().apply(&*analysis.file_text(file_id.unwrap()).unwrap());\n+        assert_eq_text!(expected, &*result);\n+    }\n+}"}, {"sha": "557ee7b57684ae9c8b0338aff57b728ada1baeb6", "filename": "crates/ra_ide_api/src/references/search_scope.rs", "status": "renamed", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -1,55 +1,15 @@\n-use hir::{DefWithBody, HasSource, ModuleSource, SourceAnalyzer};\n-use ra_db::{FileId, FileRange, SourceDatabase};\n-use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, TextRange, TextUnit};\n+use hir::{DefWithBody, HasSource, ModuleSource};\n+use ra_db::{FileId, SourceDatabase};\n+use ra_syntax::{AstNode, TextRange};\n \n-use crate::{\n-    db::RootDatabase,\n-    name_kind::{classify_name_ref, Definition, NameKind},\n-};\n+use crate::db::RootDatabase;\n+\n+use super::{Definition, NameKind};\n \n pub(crate) struct SearchScope {\n     pub scope: Vec<(FileId, Option<TextRange>)>,\n }\n \n-pub(crate) fn find_refs(db: &RootDatabase, def: Definition, name: String) -> Vec<FileRange> {\n-    let pat = name.as_str();\n-    let scope = def.scope(db).scope;\n-    let mut refs = vec![];\n-\n-    let is_match = |file_id: FileId, name_ref: &ast::NameRef| -> bool {\n-        let analyzer = SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-        let classified = classify_name_ref(db, file_id, &analyzer, &name_ref);\n-        if let Some(d) = classified {\n-            d == def\n-        } else {\n-            false\n-        }\n-    };\n-\n-    for (file_id, text_range) in scope {\n-        let text = db.file_text(file_id);\n-        let parse = SourceFile::parse(&text);\n-        let syntax = parse.tree().syntax().clone();\n-\n-        for (idx, _) in text.match_indices(pat) {\n-            let offset = TextUnit::from_usize(idx);\n-            if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&syntax, offset) {\n-                let range = name_ref.syntax().text_range();\n-\n-                if let Some(text_range) = text_range {\n-                    if range.is_subrange(&text_range) && is_match(file_id, &name_ref) {\n-                        refs.push(FileRange { file_id, range });\n-                    }\n-                } else if is_match(file_id, &name_ref) {\n-                    refs.push(FileRange { file_id, range });\n-                }\n-            }\n-        }\n-    }\n-\n-    return refs;\n-}\n-\n impl Definition {\n     pub fn scope(&self, db: &RootDatabase) -> SearchScope {\n         let module_src = self.container.definition_source(db);", "previous_filename": "crates/ra_ide_api/src/search_scope.rs"}, {"sha": "28c50102e06d3a9dfacd11a8bb9a01d5f36ca58a", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -14,7 +14,7 @@ use ra_syntax::{\n \n use crate::{\n     db::RootDatabase,\n-    name_kind::{classify_name_ref, NameKind::*},\n+    references::{classify_name_ref, NameKind::*},\n     FileId,\n };\n \n@@ -101,10 +101,8 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                     continue;\n                 }\n                 if let Some(name_ref) = node.as_node().cloned().and_then(ast::NameRef::cast) {\n-                    // FIXME: try to reuse the SourceAnalyzers\n-                    let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                    let name_kind = classify_name_ref(db, file_id, &analyzer, &name_ref)\n-                        .and_then(|d| Some(d.item));\n+                    let name_kind =\n+                        classify_name_ref(db, file_id, &name_ref).and_then(|d| Some(d.item));\n                     match name_kind {\n                         Some(Macro(_)) => \"macro\",\n                         Some(FieldAccess(_)) => \"field\",\n@@ -131,6 +129,8 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                                     Some(calc_binding_hash(file_id, &text, *shadow_count))\n                             }\n \n+                            let analyzer =\n+                                hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n                             if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n                                 \"variable.mut\"\n                             } else {"}, {"sha": "e08e0dbae51c7a4c535f016fec43dfd0d6b548f3", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26d0ada50fd0063c03e28bc2673f9f63fd23d95/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=d26d0ada50fd0063c03e28bc2673f9f63fd23d95", "patch": "@@ -481,7 +481,7 @@ pub fn handle_references(\n     params: req::ReferenceParams,\n ) -> Result<Option<Vec<Location>>> {\n     let position = params.text_document_position.try_conv_with(&world)?;\n-    \n+\n     let refs = match world.analysis().find_all_refs(position)? {\n         None => return Ok(None),\n         Some(refs) => refs,"}]}