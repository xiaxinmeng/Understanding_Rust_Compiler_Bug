{"sha": "d8b0a1910ab424a17b065138234baea47285a7a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YjBhMTkxMGFiNDI0YTE3YjA2NTEzODIzNGJhZWE0NzI4NWE3YTA=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-01-16T04:20:06Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-01-16T04:20:06Z"}, "message": "Added string functions: split_func, split_char, lines, lines_any, words,\nand more tests", "tree": {"sha": "b2d4ccd26d90cfbe02467daa606fd59de6ba1dbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2d4ccd26d90cfbe02467daa606fd59de6ba1dbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8b0a1910ab424a17b065138234baea47285a7a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b0a1910ab424a17b065138234baea47285a7a0", "html_url": "https://github.com/rust-lang/rust/commit/d8b0a1910ab424a17b065138234baea47285a7a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8b0a1910ab424a17b065138234baea47285a7a0/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3466c9b4befd03fd39b099466b97fea92bb5109f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3466c9b4befd03fd39b099466b97fea92bb5109f", "html_url": "https://github.com/rust-lang/rust/commit/3466c9b4befd03fd39b099466b97fea92bb5109f"}], "stats": {"total": 198, "additions": 189, "deletions": 9}, "files": [{"sha": "4816d913c46daf4a26e9c58473bab3c3e45da6b7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 97, "deletions": 9, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d8b0a1910ab424a17b065138234baea47285a7a0/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8b0a1910ab424a17b065138234baea47285a7a0/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d8b0a1910ab424a17b065138234baea47285a7a0", "patch": "@@ -7,7 +7,8 @@ String manipulation.\n export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n        byte_len_range, index,\n        rindex, find, starts_with, ends_with, substr, slice, split, splitn,\n-       split_str, concat, connect, to_lower, to_upper, replace, char_slice,\n+       split_str, split_func, split_char, lines, lines_any, words,\n+       concat, connect, to_lower, to_upper, replace, char_slice,\n        trim_left, trim_right, trim, unshift_char, shift_char, pop_char,\n        push_char, is_utf8, from_chars, to_chars, char_len, char_len_range,\n        char_at, bytes, is_ascii, shift_byte, pop_byte,\n@@ -252,7 +253,7 @@ fn from_chars(chs: [char]) -> str {\n /*\n Function: utf8_char_width\n \n-FIXME: What does this function do?\n+Given a first byte, determine how many bytes are in this UTF-8 character\n */\n pure fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n@@ -275,15 +276,27 @@ Pluck a character out of a string and return the index of the next character.\n This function can be used to iterate over the unicode characters of a string.\n \n Example:\n-\n-> let s = \"Clam chowder, hot sauce, pork rinds\";\n-> let i = 0;\n-> while i < len(s) {\n->   let {ch, next} = char_range_at(s, i);\n->   log(debug, ch);\n->   i = next;\n+> let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+> let i = 0u;\n+> while i < str::byte_len(s) {\n+>    let {ch, next} = str::char_range_at(s, i);\n+>    std::io::println(#fmt(\"%u: %c\",i,ch));\n+>    i = next;\n > }\n \n+Example output:\n+\n+      0: \u4e2d\n+      3: \u534e\n+      6: V\n+      7: i\n+      8: \u1ec7\n+      11: t\n+      12:\n+      13: N\n+      14: a\n+      15: m\n+\n Parameters:\n \n s - The string\n@@ -721,6 +734,8 @@ Split a string at each occurance of a given separator\n Returns:\n \n A vector containing all the strings between each occurance of the separator\n+\n+FIXME: should be renamed to split_byte\n */\n fn split(s: str, sep: u8) -> [str] {\n     let v: [str] = [];\n@@ -772,6 +787,9 @@ leading fields are suppressed, and empty trailing fields are preserved.\n Returns:\n \n A vector containing all the strings between each occurrence of the separator.\n+\n+FIXME: should behave like split and split_char:\n+         assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\");\n */\n fn split_str(s: str, sep: str) -> [str] {\n     assert byte_len(sep) > 0u;\n@@ -799,6 +817,76 @@ fn split_str(s: str, sep: str) -> [str] {\n     ret v;\n }\n \n+/*\n+Function: split_func\n+\n+Splits a string into substrings using a function\n+(unicode safe)\n+\n+FIXME: will be renamed to split.\n+*/\n+fn split_func(ss: str, sepfn: fn&(cc: char)->bool) -> [str] {\n+    let vv: [str] = [];\n+    let accum: str = \"\";\n+    let ends_with_sep: bool = false;\n+\n+    str::iter_chars(ss, {|cc| if sepfn(cc) {\n+            vv += [accum];\n+            accum = \"\";\n+            ends_with_sep = true;\n+        } else {\n+            str::push_char(accum, cc);\n+            ends_with_sep = false;\n+        }\n+    });\n+\n+    if char_len(accum) >= 0u || ends_with_sep {\n+        vv += [accum];\n+    }\n+\n+    ret vv;\n+}\n+\n+/*\n+Function: split_char\n+\n+Splits a string into a vector of the substrings separated by a given character\n+*/\n+fn split_char(ss: str, cc: char) -> [str] {\n+   split_func(ss, {|kk| kk == cc})\n+}\n+\n+/*\n+Function: lines\n+\n+Splits a string into a vector of the substrings\n+separated by LF ('\\n')\n+*/\n+fn lines(ss: str) -> [str] {\n+    split_func(ss, {|cc| cc == '\\n'})\n+}\n+\n+/*\n+Function: lines_any\n+\n+Splits a string into a vector of the substrings\n+separated by LF ('\\n') and/or CR LF ('\\r\\n')\n+*/\n+fn lines_any(ss: str) -> [str] {\n+    vec::map(lines(ss), {|s| trim_right(s)})\n+}\n+\n+/*\n+Function: words\n+\n+Splits a string into a vector of the substrings\n+separated by whitespace\n+*/\n+fn words(ss: str) -> [str] {\n+    ret vec::filter( split_func(ss, {|cc| char::is_whitespace(cc)}),\n+                     {|w| 0u < str::char_len(w)});\n+}\n+\n /*\n Function: concat\n "}, {"sha": "26b5c2e9df76150e8754a1613a61466918ce6326", "filename": "src/test/stdtest/str.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d8b0a1910ab424a17b065138234baea47285a7a0/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8b0a1910ab424a17b065138234baea47285a7a0/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=d8b0a1910ab424a17b065138234baea47285a7a0", "patch": "@@ -80,12 +80,83 @@ fn test_split_str() {\n         let v = str::split_str(s, sep);\n         assert str::eq(v[i], k);\n     }\n+\n+    //FIXME: should behave like split and split_char:\n+    //assert [\"\", \"XXX\", \"YYY\", \"\"] == str::split_str(\".XXX.YYY.\", \".\");\n+\n     t(\"abc::hello::there\", \"::\", 0, \"abc\");\n     t(\"abc::hello::there\", \"::\", 1, \"hello\");\n     t(\"abc::hello::there\", \"::\", 2, \"there\");\n     t(\"::hello::there\", \"::\", 0, \"hello\");\n     t(\"hello::there::\", \"::\", 2, \"\");\n     t(\"::hello::there::\", \"::\", 2, \"\");\n+    t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", 0, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\");\n+    t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", 1, \"Vi\u1ec7t Nam\");\n+}\n+\n+#[test]\n+fn test_split_func () {\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+        == str::split_func (data, {|cc| cc == '\u534e'});\n+\n+    assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n+         == str::split_func(\"zzXXXzYYYz\", char::is_lowercase);\n+\n+    assert [\"zz\", \"\", \"\", \"z\", \"\", \"\", \"z\"]\n+         == str::split_func(\"zzXXXzYYYz\", char::is_uppercase);\n+\n+    assert [\"\",\"\"] == str::split_func(\"z\", {|cc| cc == 'z'});\n+    assert [\"\"] == str::split_func(\"\", {|cc| cc == 'z'});\n+    assert [\"ok\"] == str::split_func(\"ok\", {|cc| cc == 'z'});\n+}\n+\n+#[test]\n+fn test_split_char () {\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    assert [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+        == str::split_char(data, '\u534e');\n+\n+    assert [\"\", \"\", \"XXX\", \"YYY\", \"\"]\n+         == str::split_char(\"zzXXXzYYYz\", 'z');\n+    assert [\"\",\"\"] == str::split_char(\"z\", 'z');\n+    assert [\"\"] == str::split_char(\"\", 'z');\n+    assert [\"ok\"] == str::split_char(\"ok\", 'z');\n+}\n+\n+#[test]\n+fn test_lines () {\n+    let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+    let crlf = \"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n+\n+    assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+      == str::lines(lf);\n+\n+    assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+      == str::lines_any(lf);\n+\n+    assert [\"\\r\", \"Mary had a little lamb\\r\", \"Little lamb\\r\", \"\"]\n+      == str::lines(crlf);\n+\n+    assert [\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+      == str::lines_any(crlf);\n+\n+    assert [\"\"] == str::lines    (\"\");\n+    assert [\"\"] == str::lines_any(\"\");\n+    assert [\"\",\"\"] == str::lines    (\"\\n\");\n+    assert [\"\",\"\"] == str::lines_any(\"\\n\");\n+    assert [\"banana\"] == str::lines    (\"banana\");\n+    assert [\"banana\"] == str::lines_any(\"banana\");\n+}\n+\n+#[test]\n+fn test_words () {\n+    let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+    assert [\"Mary\",\"had\",\"a\",\"little\",\"lamb\",\"Little\",\"lamb\"]\n+        == str::words(data);\n+\n+    assert [\"ok\"] == str::words(\"ok\");\n+    assert [] == str::words(\"\");\n }\n \n #[test]\n@@ -215,6 +286,27 @@ fn test_char_slice() {\n     assert (str::eq(\"bc\", str::char_slice(\"abc\", 1u, 3u)));\n     assert (str::eq(\"\", str::char_slice(\"abc\", 1u, 1u)));\n     assert (str::eq(\"\\u65e5\", str::char_slice(\"\\u65e5\\u672c\", 0u, 1u)));\n+\n+    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+    assert (str::eq(\"\u0e1b\", str::char_slice(data, 0u, 1u)));\n+    assert (str::eq(\"\u0e23\", str::char_slice(data, 1u, 2u)));\n+    assert (str::eq(\"\u534e\", str::char_slice(data, 10u, 11u)));\n+    assert (str::eq(\"\", str::char_slice(data, 1u, 1u)));\n+\n+    fn a_million_letter_X() -> str {\n+        let i = 0;\n+        let rs = \"\";\n+        while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n+        ret rs;\n+    }\n+    fn half_a_million_letter_X() -> str {\n+        let i = 0;\n+        let rs = \"\";\n+        while i < 100000 { rs += \"\u534e\u534e\u534e\u534e\u534e\"; i += 1; }\n+        ret rs;\n+    }\n+    assert (str::eq(half_a_million_letter_X(),\n+                    str::char_slice(a_million_letter_X(), 0u, 500000u)));\n }\n \n #[test]"}]}