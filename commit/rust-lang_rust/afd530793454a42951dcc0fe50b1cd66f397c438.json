{"sha": "afd530793454a42951dcc0fe50b1cd66f397c438", "node_id": "C_kwDOAAsO6NoAKGFmZDUzMDc5MzQ1NGE0Mjk1MWRjYzBmZTUwYjFjZDY2ZjM5N2M0Mzg", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-31T10:00:41Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-01-21T10:19:46Z"}, "message": "Move `ty::tls` to seperate file", "tree": {"sha": "3bd9e119c1f5b62fe3d67dd541dbd230711b3ea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bd9e119c1f5b62fe3d67dd541dbd230711b3ea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afd530793454a42951dcc0fe50b1cd66f397c438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afd530793454a42951dcc0fe50b1cd66f397c438", "html_url": "https://github.com/rust-lang/rust/commit/afd530793454a42951dcc0fe50b1cd66f397c438", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afd530793454a42951dcc0fe50b1cd66f397c438/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e098eb17e1514bcd604ac4bd57cec362944687af", "url": "https://api.github.com/repos/rust-lang/rust/commits/e098eb17e1514bcd604ac4bd57cec362944687af", "html_url": "https://github.com/rust-lang/rust/commit/e098eb17e1514bcd604ac4bd57cec362944687af"}], "stats": {"total": 343, "additions": 171, "deletions": 172}, "files": [{"sha": "ed23297dba78c8a9a138275a657fcf0008e216e0", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 172, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/afd530793454a42951dcc0fe50b1cd66f397c438/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd530793454a42951dcc0fe50b1cd66f397c438/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=afd530793454a42951dcc0fe50b1cd66f397c438", "patch": "@@ -2,6 +2,8 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n+pub mod tls;\n+\n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n@@ -1188,178 +1190,6 @@ CloneLiftImpls! { for<'tcx> {\n     Constness, traits::WellFormedLoc, ImplPolarity, crate::mir::ReturnConstraint,\n } }\n \n-pub mod tls {\n-    use super::{ptr_eq, GlobalCtxt, TyCtxt};\n-\n-    use crate::dep_graph::TaskDepsRef;\n-    use crate::ty::query;\n-    use rustc_data_structures::sync::{self, Lock};\n-    use rustc_errors::Diagnostic;\n-    use std::mem;\n-    use thin_vec::ThinVec;\n-\n-    #[cfg(not(parallel_compiler))]\n-    use std::cell::Cell;\n-\n-    #[cfg(parallel_compiler)]\n-    use rustc_rayon_core as rayon_core;\n-\n-    /// This is the implicit state of rustc. It contains the current\n-    /// `TyCtxt` and query. It is updated when creating a local interner or\n-    /// executing a new query. Whenever there's a `TyCtxt` value available\n-    /// you should also have access to an `ImplicitCtxt` through the functions\n-    /// in this module.\n-    #[derive(Clone)]\n-    pub struct ImplicitCtxt<'a, 'tcx> {\n-        /// The current `TyCtxt`.\n-        pub tcx: TyCtxt<'tcx>,\n-\n-        /// The current query job, if any. This is updated by `JobOwner::start` in\n-        /// `ty::query::plumbing` when executing a query.\n-        pub query: Option<query::QueryJobId>,\n-\n-        /// Where to store diagnostics for the current query job, if any.\n-        /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n-        pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n-\n-        /// Used to prevent queries from calling too deeply.\n-        pub query_depth: usize,\n-\n-        /// The current dep graph task. This is used to add dependencies to queries\n-        /// when executing them.\n-        pub task_deps: TaskDepsRef<'a>,\n-    }\n-\n-    impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n-        pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n-            let tcx = TyCtxt { gcx };\n-            ImplicitCtxt {\n-                tcx,\n-                query: None,\n-                diagnostics: None,\n-                query_depth: 0,\n-                task_deps: TaskDepsRef::Ignore,\n-            }\n-        }\n-    }\n-\n-    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n-    /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[cfg(parallel_compiler)]\n-    #[inline]\n-    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n-        rayon_core::tlv::with(value, f)\n-    }\n-\n-    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current `ImplicitCtxt`.\n-    #[cfg(parallel_compiler)]\n-    #[inline]\n-    pub fn get_tlv() -> usize {\n-        rayon_core::tlv::get()\n-    }\n-\n-    #[cfg(not(parallel_compiler))]\n-    thread_local! {\n-        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n-        static TLV: Cell<usize> = const { Cell::new(0) };\n-    }\n-\n-    /// Sets TLV to `value` during the call to `f`.\n-    /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[cfg(not(parallel_compiler))]\n-    #[inline]\n-    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n-        let old = get_tlv();\n-        let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n-        TLV.with(|tlv| tlv.set(value));\n-        f()\n-    }\n-\n-    /// Gets the pointer to the current `ImplicitCtxt`.\n-    #[cfg(not(parallel_compiler))]\n-    #[inline]\n-    fn get_tlv() -> usize {\n-        TLV.with(|tlv| tlv.get())\n-    }\n-\n-    /// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n-    #[inline]\n-    pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n-    {\n-        set_tlv(context as *const _ as usize, || f(&context))\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n-    #[inline]\n-    pub fn with_context_opt<F, R>(f: F) -> R\n-    where\n-        F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n-    {\n-        let context = get_tlv();\n-        if context == 0 {\n-            f(None)\n-        } else {\n-            // We could get an `ImplicitCtxt` pointer from another thread.\n-            // Ensure that `ImplicitCtxt` is `Sync`.\n-            sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n-\n-            unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n-        }\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt`.\n-    /// Panics if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with_context<F, R>(f: F) -> R\n-    where\n-        F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n-    {\n-        with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt` whose tcx field is the same as the tcx argument\n-    /// passed in. This means the closure is given an `ImplicitCtxt` with the same `'tcx` lifetime\n-    /// as the `TyCtxt` passed in.\n-    /// This will panic if you pass it a `TyCtxt` which is different from the current\n-    /// `ImplicitCtxt`'s `tcx` field.\n-    #[inline]\n-    pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n-    {\n-        with_context(|context| unsafe {\n-            assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n-            let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n-            f(context)\n-        })\n-    }\n-\n-    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n-    /// Panics if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n-    {\n-        with_context(|context| f(context.tcx))\n-    }\n-\n-    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n-    /// The closure is passed None if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with_opt<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n-    {\n-        with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n-    }\n-}\n-\n macro_rules! sty_debug_print {\n     ($fmt: expr, $ctxt: expr, $($variant: ident),*) => {{\n         // Curious inner module to allow variant names to be used as"}, {"sha": "0737131f1794e161a7cfe4fcf69022cb3ac08c55", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/afd530793454a42951dcc0fe50b1cd66f397c438/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd530793454a42951dcc0fe50b1cd66f397c438/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=afd530793454a42951dcc0fe50b1cd66f397c438", "patch": "@@ -0,0 +1,169 @@\n+use super::{ptr_eq, GlobalCtxt, TyCtxt};\n+\n+use crate::dep_graph::TaskDepsRef;\n+use crate::ty::query;\n+use rustc_data_structures::sync::{self, Lock};\n+use rustc_errors::Diagnostic;\n+use std::mem;\n+use thin_vec::ThinVec;\n+\n+#[cfg(not(parallel_compiler))]\n+use std::cell::Cell;\n+\n+#[cfg(parallel_compiler)]\n+use rustc_rayon_core as rayon_core;\n+\n+/// This is the implicit state of rustc. It contains the current\n+/// `TyCtxt` and query. It is updated when creating a local interner or\n+/// executing a new query. Whenever there's a `TyCtxt` value available\n+/// you should also have access to an `ImplicitCtxt` through the functions\n+/// in this module.\n+#[derive(Clone)]\n+pub struct ImplicitCtxt<'a, 'tcx> {\n+    /// The current `TyCtxt`.\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// The current query job, if any. This is updated by `JobOwner::start` in\n+    /// `ty::query::plumbing` when executing a query.\n+    pub query: Option<query::QueryJobId>,\n+\n+    /// Where to store diagnostics for the current query job, if any.\n+    /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n+    pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n+\n+    /// Used to prevent queries from calling too deeply.\n+    pub query_depth: usize,\n+\n+    /// The current dep graph task. This is used to add dependencies to queries\n+    /// when executing them.\n+    pub task_deps: TaskDepsRef<'a>,\n+}\n+\n+impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n+    pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n+        let tcx = TyCtxt { gcx };\n+        ImplicitCtxt {\n+            tcx,\n+            query: None,\n+            diagnostics: None,\n+            query_depth: 0,\n+            task_deps: TaskDepsRef::Ignore,\n+        }\n+    }\n+}\n+\n+/// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n+/// to `value` during the call to `f`. It is restored to its previous value after.\n+/// This is used to set the pointer to the new `ImplicitCtxt`.\n+#[cfg(parallel_compiler)]\n+#[inline]\n+fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n+    rayon_core::tlv::with(value, f)\n+}\n+\n+/// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n+/// This is used to get the pointer to the current `ImplicitCtxt`.\n+#[cfg(parallel_compiler)]\n+#[inline]\n+pub fn get_tlv() -> usize {\n+    rayon_core::tlv::get()\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+thread_local! {\n+    /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n+    static TLV: Cell<usize> = const { Cell::new(0) };\n+}\n+\n+/// Sets TLV to `value` during the call to `f`.\n+/// It is restored to its previous value after.\n+/// This is used to set the pointer to the new `ImplicitCtxt`.\n+#[cfg(not(parallel_compiler))]\n+#[inline]\n+fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n+    let old = get_tlv();\n+    let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n+    TLV.with(|tlv| tlv.set(value));\n+    f()\n+}\n+\n+/// Gets the pointer to the current `ImplicitCtxt`.\n+#[cfg(not(parallel_compiler))]\n+#[inline]\n+fn get_tlv() -> usize {\n+    TLV.with(|tlv| tlv.get())\n+}\n+\n+/// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n+#[inline]\n+pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n+where\n+    F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n+{\n+    set_tlv(context as *const _ as usize, || f(&context))\n+}\n+\n+/// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n+#[inline]\n+pub fn with_context_opt<F, R>(f: F) -> R\n+where\n+    F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n+{\n+    let context = get_tlv();\n+    if context == 0 {\n+        f(None)\n+    } else {\n+        // We could get an `ImplicitCtxt` pointer from another thread.\n+        // Ensure that `ImplicitCtxt` is `Sync`.\n+        sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n+\n+        unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n+    }\n+}\n+\n+/// Allows access to the current `ImplicitCtxt`.\n+/// Panics if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with_context<F, R>(f: F) -> R\n+where\n+    F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n+{\n+    with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n+}\n+\n+/// Allows access to the current `ImplicitCtxt` whose tcx field is the same as the tcx argument\n+/// passed in. This means the closure is given an `ImplicitCtxt` with the same `'tcx` lifetime\n+/// as the `TyCtxt` passed in.\n+/// This will panic if you pass it a `TyCtxt` which is different from the current\n+/// `ImplicitCtxt`'s `tcx` field.\n+#[inline]\n+pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n+where\n+    F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n+{\n+    with_context(|context| unsafe {\n+        assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n+        let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n+        f(context)\n+    })\n+}\n+\n+/// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+/// Panics if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with<F, R>(f: F) -> R\n+where\n+    F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n+{\n+    with_context(|context| f(context.tcx))\n+}\n+\n+/// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+/// The closure is passed None if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with_opt<F, R>(f: F) -> R\n+where\n+    F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n+{\n+    with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n+}"}]}