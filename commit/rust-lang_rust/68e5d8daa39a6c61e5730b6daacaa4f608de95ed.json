{"sha": "68e5d8daa39a6c61e5730b6daacaa4f608de95ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZTVkOGRhYTM5YTZjNjFlNTczMGI2ZGFhY2FhNGY2MDhkZTk1ZWQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-05-29T01:27:30Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-05-29T01:27:30Z"}, "message": "Merge pull request #2455 from erickt/master\n\nFleshing out result methods", "tree": {"sha": "555bd8b2514b75e148b3cb6d2f94f4b7cb39df54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/555bd8b2514b75e148b3cb6d2f94f4b7cb39df54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68e5d8daa39a6c61e5730b6daacaa4f608de95ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68e5d8daa39a6c61e5730b6daacaa4f608de95ed", "html_url": "https://github.com/rust-lang/rust/commit/68e5d8daa39a6c61e5730b6daacaa4f608de95ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68e5d8daa39a6c61e5730b6daacaa4f608de95ed/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07db8c8382888975fe1045686a73bba66e13034d", "url": "https://api.github.com/repos/rust-lang/rust/commits/07db8c8382888975fe1045686a73bba66e13034d", "html_url": "https://github.com/rust-lang/rust/commit/07db8c8382888975fe1045686a73bba66e13034d"}, {"sha": "ed5af70a3634915004f24c391a33cbebb8beb7bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed5af70a3634915004f24c391a33cbebb8beb7bd", "html_url": "https://github.com/rust-lang/rust/commit/ed5af70a3634915004f24c391a33cbebb8beb7bd"}], "stats": {"total": 263, "additions": 253, "deletions": 10}, "files": [{"sha": "3c6622ba69dd961ce803e6a981f69db82e4c03e6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 138, "deletions": 4, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/68e5d8daa39a6c61e5730b6daacaa4f608de95ed/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e5d8daa39a6c61e5730b6daacaa4f608de95ed/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=68e5d8daa39a6c61e5730b6daacaa4f608de95ed", "patch": "@@ -107,6 +107,79 @@ fn chain_err<T: copy, U: copy, V: copy>(\n     }\n }\n \n+#[doc = \"\n+Call a function based on a previous result\n+\n+If `res` is `ok` then the value is extracted and passed to `op` whereupon\n+`op`s result is returned. if `res` is `err` then it is immediately returned.\n+This function can be used to compose the results of two functions.\n+\n+Example:\n+\n+    iter(read_file(file)) { |buf|\n+        print_buf(buf)\n+    }\n+\"]\n+fn iter<T, E>(res: result<T, E>, f: fn(T)) {\n+    alt res {\n+      ok(t) { f(t) }\n+      err(_) { }\n+    }\n+}\n+\n+#[doc = \"\n+Call a function based on a previous result\n+\n+If `res` is `err` then the value is extracted and passed to `op` whereupon\n+`op`s result is returned. if `res` is `ok` then it is immediately returned.\n+This function can be used to pass through a successful result while handling\n+an error.\n+\"]\n+fn iter_err<T, E>(res: result<T, E>, f: fn(E)) {\n+    alt res {\n+      ok(_) { }\n+      err(e) { f(e) }\n+    }\n+}\n+\n+#[doc = \"\n+Call a function based on a previous result\n+\n+If `res` is `ok` then the value is extracted and passed to `op` whereupon\n+`op`s result is wrapped in `ok` and returned. if `res` is `err` then it is\n+immediately returned.  This function can be used to compose the results of two\n+functions.\n+\n+Example:\n+\n+    let res = map(read_file(file)) { |buf|\n+        parse_buf(buf)\n+    }\n+\"]\n+fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n+  -> result<U, E> {\n+    alt res {\n+      ok(t) { ok(op(t)) }\n+      err(e) { err(e) }\n+    }\n+}\n+\n+#[doc = \"\n+Call a function based on a previous result\n+\n+If `res` is `err` then the value is extracted and passed to `op` whereupon\n+`op`s result is wrapped in an `err` and returned. if `res` is `ok` then it is\n+immediately returned.  This function can be used to pass through a successful\n+result while handling an error.\n+\"]\n+fn map_err<T: copy, E, F: copy>(res: result<T, E>, op: fn(E) -> F)\n+  -> result<T, F> {\n+    alt res {\n+      ok(t) { ok(t) }\n+      err(e) { err(op(e)) }\n+    }\n+}\n+\n impl extensions<T:copy, E:copy> for result<T,E> {\n     fn get() -> T { get(self) }\n \n@@ -123,6 +196,34 @@ impl extensions<T:copy, E:copy> for result<T,E> {\n     fn chain_err<F:copy>(op: fn(E) -> result<T,F>) -> result<T,F> {\n         chain_err(self, op)\n     }\n+\n+    fn iter(f: fn(T)) {\n+        alt self {\n+          ok(t) { f(t) }\n+          err(_) { }\n+        }\n+    }\n+\n+    fn iter_err(f: fn(E)) {\n+        alt self {\n+          ok(_) { }\n+          err(e) { f(e) }\n+        }\n+    }\n+\n+    fn map<U:copy>(op: fn(T) -> U) -> result<U,E> {\n+        alt self {\n+          ok(t) { ok(op(t)) }\n+          err(e) { err(e) }\n+        }\n+    }\n+\n+    fn map_err<F:copy>(op: fn(E) -> F) -> result<T,F> {\n+        alt self {\n+          ok(t) { ok(t) }\n+          err(e) { err(op(e)) }\n+        }\n+    }\n }\n \n #[doc = \"\n@@ -142,7 +243,7 @@ checking for overflow:\n         assert incd == [2u, 3u, 4u];\n     }\n \"]\n-fn map<T,U:copy,V:copy>(\n+fn map_vec<T,U:copy,V:copy>(\n     ts: [T], op: fn(T) -> result<V,U>) -> result<[V],U> {\n \n     let mut vs: [V] = [];\n@@ -177,7 +278,7 @@ length.  While we do not often use preconditions in the standard\n library, a precondition is used here because result::t is generally\n used in 'careful' code contexts where it is both appropriate and easy\n to accommodate an error like the vectors being of different lengths.\"]\n-fn map2<S,T,U:copy,V:copy>(ss: [S], ts: [T], op: fn(S,T) -> result<V,U>)\n+fn map_vec2<S,T,U:copy,V:copy>(ss: [S], ts: [T], op: fn(S,T) -> result<V,U>)\n     : vec::same_length(ss, ts) -> result<[V],U> {\n \n     let n = vec::len(ts);\n@@ -199,8 +300,8 @@ Applies op to the pairwise elements from `ss` and `ts`, aborting on\n error.  This could be implemented using `map2()` but it is more efficient\n on its own as no result vector is built.\n \"]\n-fn iter2<S,T,U:copy>(ss: [S], ts: [T],\n-                     op: fn(S,T) -> result<(),U>)\n+fn iter_vec2<S,T,U:copy>(ss: [S], ts: [T],\n+                         op: fn(S,T) -> result<(),U>)\n     : vec::same_length(ss, ts)\n     -> result<(),U> {\n \n@@ -248,4 +349,37 @@ mod tests {\n     fn chain_failure() {\n         assert get_err(chain(op3(), op2)) == \"sadface\";\n     }\n+\n+    #[test]\n+    fn test_impl_iter() {\n+        let mut valid = false;\n+        ok::<str, str>(\"a\").iter { |_x| valid = true; };\n+        assert valid;\n+\n+        err::<str, str>(\"b\").iter { |_x| valid = false; };\n+        assert valid;\n+    }\n+\n+    #[test]\n+    fn test_impl_iter_err() {\n+        let mut valid = true;\n+        ok::<str, str>(\"a\").iter_err { |_x| valid = false; };\n+        assert valid;\n+\n+        valid = false;\n+        err::<str, str>(\"b\").iter_err { |_x| valid = true; };\n+        assert valid;\n+    }\n+\n+    #[test]\n+    fn test_impl_map() {\n+        assert ok::<str, str>(\"a\").map { |_x| \"b\" } == ok(\"b\");\n+        assert err::<str, str>(\"a\").map { |_x| \"b\" } == err(\"a\");\n+    }\n+\n+    #[test]\n+    fn test_impl_map_err() {\n+        assert ok::<str, str>(\"a\").map_err { |_x| \"b\" } == ok(\"a\");\n+        assert err::<str, str>(\"a\").map_err { |_x| \"b\" } == err(\"b\");\n+    }\n }"}, {"sha": "5d9427c72b8603be0aa70f571a64e3f4b44a1718", "filename": "src/libstd/json.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/68e5d8daa39a6c61e5730b6daacaa4f608de95ed/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e5d8daa39a6c61e5730b6daacaa4f608de95ed/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=68e5d8daa39a6c61e5730b6daacaa4f608de95ed", "patch": "@@ -16,6 +16,7 @@ export to_str;\n export from_reader;\n export from_str;\n export eq;\n+export to_json;\n \n export num;\n export string;\n@@ -498,6 +499,110 @@ fn eq(value0: json, value1: json) -> bool {\n     }\n }\n \n+iface to_json { fn to_json() -> json; }\n+\n+impl of to_json for json {\n+    fn to_json() -> json { self }\n+}\n+\n+impl of to_json for i8 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for i16 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for i32 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for i64 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for u8 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for u16 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for u32 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for u64 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for float {\n+    fn to_json() -> json { num(self) }\n+}\n+\n+impl of to_json for f32 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for f64 {\n+    fn to_json() -> json { num(self as float) }\n+}\n+\n+impl of to_json for () {\n+    fn to_json() -> json { null }\n+}\n+\n+impl of to_json for bool {\n+    fn to_json() -> json { boolean(self) }\n+}\n+\n+impl of to_json for str {\n+    fn to_json() -> json { string(self) }\n+}\n+\n+impl <A: to_json copy, B: to_json copy> of to_json for (A, B) {\n+    fn to_json() -> json {\n+        let (a, b) = self;\n+        list([a.to_json(), b.to_json()])\n+    }\n+}\n+\n+impl <A: to_json copy, B: to_json copy, C: to_json copy>\n+  of to_json for (A, B, C) {\n+    fn to_json() -> json {\n+        let (a, b, c) = self;\n+        list([a.to_json(), b.to_json(), c.to_json()])\n+    }\n+}\n+\n+impl <A: to_json> of to_json for [A] {\n+    fn to_json() -> json { list(self.map { |elt| elt.to_json() }) }\n+}\n+\n+impl <A: to_json copy> of to_json for hashmap<str, A> {\n+    fn to_json() -> json {\n+        let d = map::str_hash();\n+        for self.each() { |key, value|\n+            d.insert(key, value.to_json());\n+        }\n+        dict(d)\n+    }\n+}\n+\n+impl <A: to_json> of to_json for option<A> {\n+    fn to_json() -> json {\n+        alt self {\n+          none { null }\n+          some(value) { value.to_json() }\n+        }\n+    }\n+}\n+\n+impl of to_str::to_str for json {\n+    fn to_str() -> str { to_str(self) }\n+}\n+\n #[cfg(test)]\n mod tests {\n     fn mk_dict(items: [(str, json)]) -> json {"}, {"sha": "1f4d479671c2cc8eb78480c6f40404135104c945", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68e5d8daa39a6c61e5730b6daacaa4f608de95ed/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e5d8daa39a6c61e5730b6daacaa4f608de95ed/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=68e5d8daa39a6c61e5730b6daacaa4f608de95ed", "patch": "@@ -151,7 +151,7 @@ import middle::ty::{ty_vid, tys_in_fn_ty, region_vid, vid};\n import syntax::{ast, ast_util};\n import syntax::ast::{ret_style};\n import util::ppaux::{ty_to_str, mt_to_str};\n-import result::{result, extensions, ok, err, map, map2, iter2};\n+import result::{result, extensions, ok, err, map_vec, map_vec2, iter_vec2};\n import ty::{mk_fn, type_is_bot};\n import check::regionmanip::{collect_bound_regions_in_tys,\n                             replace_bound_regions};\n@@ -753,7 +753,7 @@ impl unify_methods for infer_ctxt {\n         as: [@ty::type_constr], bs: [@ty::type_constr]) -> ures {\n \n         if check vec::same_length(as, bs) {\n-            iter2(as, bs) {|a,b|\n+            iter_vec2(as, bs) {|a,b|\n                 self.constrs(a, b)\n             }\n         } else {\n@@ -1237,7 +1237,9 @@ fn super_tps<C:combine>(\n     // variance.\n \n     if check vec::same_length(as, bs) {\n-        iter2(as, bs) {|a, b| self.infcx().eq_tys(a, b) }.then {||\n+        iter_vec2(as, bs) {|a, b|\n+            self.infcx().eq_tys(a, b)\n+        }.then {||\n             ok(as)\n         }\n     } else {\n@@ -1331,7 +1333,7 @@ fn super_fns<C:combine>(\n         self: C, a_args: [ty::arg], b_args: [ty::arg]) -> cres<[ty::arg]> {\n \n         if check vec::same_length(a_args, b_args) {\n-            map2(a_args, b_args) {|a, b| self.args(a, b) }\n+            map_vec2(a_args, b_args) {|a, b| self.args(a, b) }\n         } else {\n             err(ty::terr_arg_count)\n         }\n@@ -1469,7 +1471,9 @@ fn super_tys<C:combine>(\n \n       (ty::ty_rec(as), ty::ty_rec(bs)) {\n         if check vec::same_length(as, bs) {\n-            map2(as, bs) {|a,b| self.flds(a, b) }.chain {|flds|\n+            map_vec2(as, bs) {|a,b|\n+                self.flds(a, b)\n+            }.chain {|flds|\n                 ok(ty::mk_rec(tcx, flds))\n             }\n         } else {\n@@ -1479,7 +1483,7 @@ fn super_tys<C:combine>(\n \n       (ty::ty_tup(as), ty::ty_tup(bs)) {\n         if check vec::same_length(as, bs) {\n-            map2(as, bs) {|a, b| self.tys(a, b) }.chain {|ts|\n+            map_vec2(as, bs) {|a, b| self.tys(a, b) }.chain {|ts|\n                 ok(ty::mk_tup(tcx, ts))\n             }\n         } else {"}]}