{"sha": "436d9fa45d7df98f49bc036de4254d5946478c5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNmQ5ZmE0NWQ3ZGY5OGY0OWJjMDM2ZGU0MjU0ZDU5NDY0NzhjNWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-30T19:16:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-30T19:16:20Z"}, "message": "auto merge of #8133 : blake2-ppc/rust/overlong-utf8, r=cmr\n\nFix is_utf8 and UTF-8 char width functions to deny non-canonical 'overlong encodings' in UTF-8.\r\n\r\nWe address the function is_utf8 to make it more strict and correct, but no changes are made to the handling of invalid UTF-8.\r\n\r\nFixes issue #3787", "tree": {"sha": "6cb0e41fd912d3ac46b9ad0bf35cdd32e4bf06f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cb0e41fd912d3ac46b9ad0bf35cdd32e4bf06f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/436d9fa45d7df98f49bc036de4254d5946478c5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/436d9fa45d7df98f49bc036de4254d5946478c5c", "html_url": "https://github.com/rust-lang/rust/commit/436d9fa45d7df98f49bc036de4254d5946478c5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/436d9fa45d7df98f49bc036de4254d5946478c5c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0068bd73e0b8a22d59ec3a979bba2376964c2dae", "url": "https://api.github.com/repos/rust-lang/rust/commits/0068bd73e0b8a22d59ec3a979bba2376964c2dae", "html_url": "https://github.com/rust-lang/rust/commit/0068bd73e0b8a22d59ec3a979bba2376964c2dae"}, {"sha": "8f9014c15996321d214a84e0fcd6437874e87483", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f9014c15996321d214a84e0fcd6437874e87483", "html_url": "https://github.com/rust-lang/rust/commit/8f9014c15996321d214a84e0fcd6437874e87483"}], "stats": {"total": 76, "additions": 58, "deletions": 18}, "files": [{"sha": "1026b454c07e988dedd7ed26a512e42707489518", "filename": "src/libstd/str.rs", "status": "modified", "additions": 58, "deletions": 18, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/436d9fa45d7df98f49bc036de4254d5946478c5c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/436d9fa45d7df98f49bc036de4254d5946478c5c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=436d9fa45d7df98f49bc036de4254d5946478c5c", "patch": "@@ -564,6 +564,18 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n Section: Misc\n */\n \n+// Return the initial codepoint accumulator for the first byte.\n+// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+// for width 3, and 3 bits for width 4\n+macro_rules! utf8_first_byte(\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as uint)\n+)\n+\n+// return the value of $ch updated with continuation byte $byte\n+macro_rules! utf8_acc_cont_byte(\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n+)\n+\n /// Determines if a vector of bytes contains valid UTF-8\n pub fn is_utf8(v: &[u8]) -> bool {\n     let mut i = 0u;\n@@ -577,11 +589,26 @@ pub fn is_utf8(v: &[u8]) -> bool {\n \n             let nexti = i + w;\n             if nexti > total { return false; }\n+            // 1. Make sure the correct number of continuation bytes are present\n+            // 2. Check codepoint ranges (deny overlong encodings)\n+            //    2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n+            //    3-byte encoding is for codepoints  \\u0800 to  \\uffff\n+            //    4-byte encoding is for codepoints \\u10000 to \\u10ffff\n \n+            //    2-byte encodings are correct if the width and continuation match up\n             if v[i + 1] & 192u8 != TAG_CONT_U8 { return false; }\n             if w > 2 {\n+                let mut ch;\n+                ch = utf8_first_byte!(v[i], w);\n+                ch = utf8_acc_cont_byte!(ch, v[i + 1]);\n                 if v[i + 2] & 192u8 != TAG_CONT_U8 { return false; }\n-                if w > 3 && (v[i + 3] & 192u8 != TAG_CONT_U8) { return false; }\n+                ch = utf8_acc_cont_byte!(ch, v[i + 2]);\n+                if w == 3 && ch < MAX_TWO_B { return false; }\n+                if w > 3 {\n+                    if v[i + 3] & 192u8 != TAG_CONT_U8 { return false; }\n+                    ch = utf8_acc_cont_byte!(ch, v[i + 3]);\n+                    if ch < MAX_THREE_B || ch >= MAX_UNICODE { return false; }\n+                }\n             }\n \n             i = nexti;\n@@ -699,7 +726,7 @@ pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n }\n \n // https://tools.ietf.org/html/rfc3629\n-static UTF8_CHAR_WIDTH: [u8, ..256] = [\n+priv static UTF8_CHAR_WIDTH: [u8, ..256] = [\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n@@ -712,7 +739,7 @@ static UTF8_CHAR_WIDTH: [u8, ..256] = [\n 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n+0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n 4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n@@ -730,14 +757,15 @@ pub struct CharRange {\n }\n \n // UTF-8 tags and ranges\n-static TAG_CONT_U8: u8 = 128u8;\n-static TAG_CONT: uint = 128u;\n-static MAX_ONE_B: uint = 128u;\n-static TAG_TWO_B: uint = 192u;\n-static MAX_TWO_B: uint = 2048u;\n-static TAG_THREE_B: uint = 224u;\n-static MAX_THREE_B: uint = 65536u;\n-static TAG_FOUR_B: uint = 240u;\n+priv static TAG_CONT_U8: u8 = 128u8;\n+priv static TAG_CONT: uint = 128u;\n+priv static MAX_ONE_B: uint = 128u;\n+priv static TAG_TWO_B: uint = 192u;\n+priv static MAX_TWO_B: uint = 2048u;\n+priv static TAG_THREE_B: uint = 224u;\n+priv static MAX_THREE_B: uint = 65536u;\n+priv static TAG_FOUR_B: uint = 240u;\n+priv static MAX_UNICODE: uint = 1114112u;\n \n /// Unsafe operations\n pub mod raw {\n@@ -1665,12 +1693,10 @@ impl<'self> StrSlice<'self> for &'self str {\n             let w = UTF8_CHAR_WIDTH[val] as uint;\n             assert!((w != 0));\n \n-            // First byte is special, only want bottom 5 bits for width 2, 4 bits\n-            // for width 3, and 3 bits for width 4\n-            val &= 0x7Fu >> w;\n-            val = (val << 6) | (s[i + 1] & 63u8) as uint;\n-            if w > 2 { val = (val << 6) | (s[i + 2] & 63u8) as uint; }\n-            if w > 3 { val = (val << 6) | (s[i + 3] & 63u8) as uint; }\n+            val = utf8_first_byte!(val, w);\n+            val = utf8_acc_cont_byte!(val, s[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n             return CharRange {ch: val as char, next: i + w};\n         }\n@@ -2035,7 +2061,7 @@ impl OwnedStr for ~str {\n     /// Appends a character to the back of a string\n     #[inline]\n     fn push_char(&mut self, c: char) {\n-        assert!(c as uint <= 0x10ffff); // FIXME: #7609: should be enforced on all `char`\n+        assert!((c as uint) < MAX_UNICODE); // FIXME: #7609: should be enforced on all `char`\n         unsafe {\n             let code = c as uint;\n             let nb = if code < MAX_ONE_B { 1u }\n@@ -2799,9 +2825,23 @@ mod tests {\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n                   0x6d_u8];\n \n+\n         assert_eq!(ss, from_bytes(bb));\n+        assert_eq!(~\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\",\n+                   from_bytes(bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\")));\n     }\n \n+    #[test]\n+    fn test_is_utf8_deny_overlong() {\n+        assert!(!is_utf8([0xc0, 0x80]));\n+        assert!(!is_utf8([0xc0, 0xae]));\n+        assert!(!is_utf8([0xe0, 0x80, 0x80]));\n+        assert!(!is_utf8([0xe0, 0x80, 0xaf]));\n+        assert!(!is_utf8([0xe0, 0x81, 0x81]));\n+        assert!(!is_utf8([0xf0, 0x82, 0x82, 0xac]));\n+    }\n+\n+\n     #[test]\n     #[ignore(cfg(windows))]\n     fn test_from_bytes_fail() {"}]}