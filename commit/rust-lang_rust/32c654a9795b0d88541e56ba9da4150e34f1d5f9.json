{"sha": "32c654a9795b0d88541e56ba9da4150e34f1d5f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYzY1NGE5Nzk1YjBkODg1NDFlNTZiYTlkYTQxNTBlMzRmMWQ1Zjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-19T20:20:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-19T20:20:31Z"}, "message": "Auto merge of #75590 - Mark-Simulacrum:tagged-ptr, r=ecstatic-morse\n\nAdd a packed/tagged pointer abstraction and utilize it for ParamEnv\n\nThe intent here is mostly just to add the abstraction; I suspect that there are definitely more use cases for it, and we can explore those over time now that there's a (mostly) safe abstraction that can be used in rustc.", "tree": {"sha": "93d81cd6fa34aaacdbde42299a4cdfeaeac7bb82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93d81cd6fa34aaacdbde42299a4cdfeaeac7bb82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32c654a9795b0d88541e56ba9da4150e34f1d5f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32c654a9795b0d88541e56ba9da4150e34f1d5f9", "html_url": "https://github.com/rust-lang/rust/commit/32c654a9795b0d88541e56ba9da4150e34f1d5f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32c654a9795b0d88541e56ba9da4150e34f1d5f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9900178cba95369cd5822c8ce579edcc89ffeb76", "url": "https://api.github.com/repos/rust-lang/rust/commits/9900178cba95369cd5822c8ce579edcc89ffeb76", "html_url": "https://github.com/rust-lang/rust/commit/9900178cba95369cd5822c8ce579edcc89ffeb76"}, {"sha": "107e2904bffed4c2fb2af1ce92dadd1ad3752049", "url": "https://api.github.com/repos/rust-lang/rust/commits/107e2904bffed4c2fb2af1ce92dadd1ad3752049", "html_url": "https://github.com/rust-lang/rust/commit/107e2904bffed4c2fb2af1ce92dadd1ad3752049"}], "stats": {"total": 593, "additions": 533, "deletions": 60}, "files": [{"sha": "af4a7bd18813e28b3c774946e5ae3126825b3874", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=32c654a9795b0d88541e56ba9da4150e34f1d5f9", "patch": "@@ -7,6 +7,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![allow(incomplete_features)]\n #![feature(in_band_lifetimes)]\n #![feature(unboxed_closures)]\n #![feature(generators)]\n@@ -23,6 +24,8 @@\n #![feature(associated_type_bounds)]\n #![feature(thread_id_value)]\n #![feature(extend_one)]\n+#![feature(const_panic)]\n+#![feature(const_generics)]\n #![allow(rustc::default_hash_types)]\n \n #[macro_use]\n@@ -97,6 +100,7 @@ pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n+pub mod tagged_ptr;\n pub mod temp_dir;\n \n pub struct OnDrop<F: Fn()>(pub F);"}, {"sha": "e3839d193651d8c03e29cf409440cf91a3c8937b", "filename": "src/librustc_data_structures/tagged_ptr.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_data_structures%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_data_structures%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftagged_ptr.rs?ref=32c654a9795b0d88541e56ba9da4150e34f1d5f9", "patch": "@@ -0,0 +1,157 @@\n+//! This module implements tagged pointers.\n+//!\n+//! In order to utilize the pointer packing, you must have two types: a pointer,\n+//! and a tag.\n+//!\n+//! The pointer must implement the `Pointer` trait, with the primary requirement\n+//! being conversion to and from a usize. Note that the pointer must be\n+//! dereferenceable, so raw pointers generally cannot implement the `Pointer`\n+//! trait. This implies that the pointer must also be nonzero.\n+//!\n+//! Many common pointer types already implement the `Pointer` trait.\n+//!\n+//! The tag must implement the `Tag` trait. We assert that the tag and `Pointer`\n+//! are compatible at compile time.\n+\n+use std::mem::ManuallyDrop;\n+use std::ops::Deref;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+mod copy;\n+mod drop;\n+\n+pub use copy::CopyTaggedPtr;\n+pub use drop::TaggedPtr;\n+\n+/// This describes the pointer type encaspulated by TaggedPtr.\n+///\n+/// # Safety\n+///\n+/// The usize returned from `into_usize` must be a valid, dereferenceable,\n+/// pointer to `<Self as Deref>::Target`. Note that pointers to `Pointee` must\n+/// be thin, even though `Pointee` may not be sized.\n+///\n+/// Note that the returned pointer from `into_usize` should be castable to `&mut\n+/// <Self as Deref>::Target` if `Pointer: DerefMut`.\n+///\n+/// The BITS constant must be correct. At least `BITS` bits, least-significant,\n+/// must be zero on all returned pointers from `into_usize`.\n+///\n+/// For example, if the alignment of `Pointee` is 2, then `BITS` should be 1.\n+pub unsafe trait Pointer: Deref {\n+    /// Most likely the value you want to use here is the following, unless\n+    /// your Pointee type is unsized (e.g., `ty::List<T>` in rustc) in which\n+    /// case you'll need to manually figure out what the right type to pass to\n+    /// align_of is.\n+    ///\n+    /// ```rust\n+    /// std::mem::align_of::<<Self as Deref>::Target>().trailing_zeros() as usize;\n+    /// ```\n+    const BITS: usize;\n+    fn into_usize(self) -> usize;\n+\n+    /// # Safety\n+    ///\n+    /// The passed `ptr` must be returned from `into_usize`.\n+    ///\n+    /// This acts as `ptr::read` semantically, it should not be called more than\n+    /// once on non-`Copy` `Pointer`s.\n+    unsafe fn from_usize(ptr: usize) -> Self;\n+\n+    /// This provides a reference to the `Pointer` itself, rather than the\n+    /// `Deref::Target`. It is used for cases where we want to call methods that\n+    /// may be implement differently for the Pointer than the Pointee (e.g.,\n+    /// `Rc::clone` vs cloning the inner value).\n+    ///\n+    /// # Safety\n+    ///\n+    /// The passed `ptr` must be returned from `into_usize`.\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R;\n+}\n+\n+/// This describes tags that the `TaggedPtr` struct can hold.\n+///\n+/// # Safety\n+///\n+/// The BITS constant must be correct.\n+///\n+/// No more than `BITS` least significant bits may be set in the returned usize.\n+pub unsafe trait Tag: Copy {\n+    const BITS: usize;\n+\n+    fn into_usize(self) -> usize;\n+\n+    /// # Safety\n+    ///\n+    /// The passed `tag` must be returned from `into_usize`.\n+    unsafe fn from_usize(tag: usize) -> Self;\n+}\n+\n+unsafe impl<T> Pointer for Box<T> {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        Box::into_raw(self) as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        Box::from_raw(ptr as *mut T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+        f(&raw)\n+    }\n+}\n+\n+unsafe impl<T> Pointer for Rc<T> {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        Rc::into_raw(self) as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        Rc::from_raw(ptr as *const T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+        f(&raw)\n+    }\n+}\n+\n+unsafe impl<T> Pointer for Arc<T> {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        Arc::into_raw(self) as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        Arc::from_raw(ptr as *const T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+        f(&raw)\n+    }\n+}\n+\n+unsafe impl<'a, T: 'a> Pointer for &'a T {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        self as *const T as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        &*(ptr as *const T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        f(&*(&ptr as *const usize as *const Self))\n+    }\n+}\n+\n+unsafe impl<'a, T: 'a> Pointer for &'a mut T {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        self as *mut T as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        &mut *(ptr as *mut T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        f(&*(&ptr as *const usize as *const Self))\n+    }\n+}"}, {"sha": "d39d146db318f230f11e8ff1ae909c14e2e47175", "filename": "src/librustc_data_structures/tagged_ptr/copy.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fcopy.rs?ref=32c654a9795b0d88541e56ba9da4150e34f1d5f9", "patch": "@@ -0,0 +1,183 @@\n+use super::{Pointer, Tag};\n+use crate::stable_hasher::{HashStable, StableHasher};\n+use std::fmt;\n+use std::marker::PhantomData;\n+use std::num::NonZeroUsize;\n+\n+/// A `Copy` TaggedPtr.\n+///\n+/// You should use this instead of the `TaggedPtr` type in all cases where\n+/// `P: Copy`.\n+///\n+/// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n+/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n+/// wrap the TaggedPtr.\n+pub struct CopyTaggedPtr<P, T, const COMPARE_PACKED: bool>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    packed: NonZeroUsize,\n+    data: PhantomData<(P, T)>,\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> Copy for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+    P: Copy,\n+{\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> Clone for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+    P: Copy,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n+// value; a left shift is a multiplication and those are embeddable in\n+// instruction encoding.\n+impl<P, T, const COMPARE_PACKED: bool> CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    const TAG_BIT_SHIFT: usize = (8 * std::mem::size_of::<usize>()) - T::BITS;\n+    const ASSERTION: () = {\n+        assert!(T::BITS <= P::BITS);\n+        // Used for the transmute_copy's below\n+        assert!(std::mem::size_of::<&P::Target>() == std::mem::size_of::<usize>());\n+    };\n+\n+    pub fn new(pointer: P, tag: T) -> Self {\n+        // Trigger assert!\n+        let () = Self::ASSERTION;\n+        let packed_tag = tag.into_usize() << Self::TAG_BIT_SHIFT;\n+\n+        Self {\n+            // SAFETY: We know that the pointer is non-null, as it must be\n+            // dereferenceable per `Pointer` safety contract.\n+            packed: unsafe {\n+                NonZeroUsize::new_unchecked((P::into_usize(pointer) >> T::BITS) | packed_tag)\n+            },\n+            data: PhantomData,\n+        }\n+    }\n+\n+    pub(super) fn pointer_raw(&self) -> usize {\n+        self.packed.get() << T::BITS\n+    }\n+    pub fn pointer(self) -> P\n+    where\n+        P: Copy,\n+    {\n+        // SAFETY: pointer_raw returns the original pointer\n+        //\n+        // Note that this isn't going to double-drop or anything because we have\n+        // P: Copy\n+        unsafe { P::from_usize(self.pointer_raw()) }\n+    }\n+    pub fn pointer_ref(&self) -> &P::Target {\n+        // SAFETY: pointer_raw returns the original pointer\n+        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n+    }\n+    pub fn pointer_mut(&mut self) -> &mut P::Target\n+    where\n+        P: std::ops::DerefMut,\n+    {\n+        // SAFETY: pointer_raw returns the original pointer\n+        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n+    }\n+    pub fn tag(&self) -> T {\n+        unsafe { T::from_usize(self.packed.get() >> Self::TAG_BIT_SHIFT) }\n+    }\n+    pub fn set_tag(&mut self, tag: T) {\n+        let mut packed = self.packed.get();\n+        let new_tag = T::into_usize(tag) << Self::TAG_BIT_SHIFT;\n+        let tag_mask = (1 << T::BITS) - 1;\n+        packed &= !(tag_mask << Self::TAG_BIT_SHIFT);\n+        packed |= new_tag;\n+        self.packed = unsafe { NonZeroUsize::new_unchecked(packed) };\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    type Target = P::Target;\n+    fn deref(&self) -> &Self::Target {\n+        self.pointer_ref()\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> std::ops::DerefMut for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + std::ops::DerefMut,\n+    T: Tag,\n+{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.pointer_mut()\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> fmt::Debug for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    P::Target: fmt::Debug,\n+    T: Tag + fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"CopyTaggedPtr\")\n+            .field(\"pointer\", &self.pointer_ref())\n+            .field(\"tag\", &self.tag())\n+            .finish()\n+    }\n+}\n+\n+impl<P, T> PartialEq for CopyTaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.packed == other.packed\n+    }\n+}\n+\n+impl<P, T> Eq for CopyTaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+}\n+\n+impl<P, T> std::hash::Hash for CopyTaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.packed.hash(state);\n+    }\n+}\n+\n+impl<P, T, HCX, const COMPARE_PACKED: bool> HashStable<HCX> for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + HashStable<HCX>,\n+    T: Tag + HashStable<HCX>,\n+{\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        unsafe {\n+            Pointer::with_ref(self.pointer_raw(), |p: &P| p.hash_stable(hcx, hasher));\n+        }\n+        self.tag().hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "63f64beae5a07089e24bebecb2b35f8d882361e2", "filename": "src/librustc_data_structures/tagged_ptr/drop.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fdrop.rs?ref=32c654a9795b0d88541e56ba9da4150e34f1d5f9", "patch": "@@ -0,0 +1,142 @@\n+use super::{Pointer, Tag};\n+use crate::stable_hasher::{HashStable, StableHasher};\n+use std::fmt;\n+\n+use super::CopyTaggedPtr;\n+\n+/// A TaggedPtr implementing `Drop`.\n+///\n+/// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n+/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n+/// wrap the TaggedPtr.\n+pub struct TaggedPtr<P, T, const COMPARE_PACKED: bool>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    raw: CopyTaggedPtr<P, T, COMPARE_PACKED>,\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> Clone for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + Clone,\n+    T: Tag,\n+{\n+    fn clone(&self) -> Self {\n+        unsafe { Self::new(P::with_ref(self.raw.pointer_raw(), |p| p.clone()), self.raw.tag()) }\n+    }\n+}\n+\n+// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n+// value; a right shift is a multiplication and those are embeddable in\n+// instruction encoding.\n+impl<P, T, const COMPARE_PACKED: bool> TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    pub fn new(pointer: P, tag: T) -> Self {\n+        TaggedPtr { raw: CopyTaggedPtr::new(pointer, tag) }\n+    }\n+\n+    pub fn pointer_ref(&self) -> &P::Target {\n+        self.raw.pointer_ref()\n+    }\n+    pub fn pointer_mut(&mut self) -> &mut P::Target\n+    where\n+        P: std::ops::DerefMut,\n+    {\n+        self.raw.pointer_mut()\n+    }\n+    pub fn tag(&self) -> T {\n+        self.raw.tag()\n+    }\n+    pub fn set_tag(&mut self, tag: T) {\n+        self.raw.set_tag(tag);\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    type Target = P::Target;\n+    fn deref(&self) -> &Self::Target {\n+        self.raw.pointer_ref()\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> std::ops::DerefMut for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + std::ops::DerefMut,\n+    T: Tag,\n+{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.raw.pointer_mut()\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> Drop for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn drop(&mut self) {\n+        // No need to drop the tag, as it's Copy\n+        unsafe {\n+            std::mem::drop(P::from_usize(self.raw.pointer_raw()));\n+        }\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> fmt::Debug for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    P::Target: fmt::Debug,\n+    T: Tag + fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"TaggedPtr\")\n+            .field(\"pointer\", &self.pointer_ref())\n+            .field(\"tag\", &self.tag())\n+            .finish()\n+    }\n+}\n+\n+impl<P, T> PartialEq for TaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.raw.eq(&other.raw)\n+    }\n+}\n+\n+impl<P, T> Eq for TaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+}\n+\n+impl<P, T> std::hash::Hash for TaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.raw.hash(state);\n+    }\n+}\n+\n+impl<P, T, HCX, const COMPARE_PACKED: bool> HashStable<HCX> for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + HashStable<HCX>,\n+    T: Tag + HashStable<HCX>,\n+{\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        self.raw.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "83a2bdf90f9af0843baa178201445f830e012449", "filename": "src/librustc_middle/ty/list.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=32c654a9795b0d88541e56ba9da4150e34f1d5f9", "patch": "@@ -35,6 +35,21 @@ pub struct List<T> {\n     opaque: OpaqueListContents,\n }\n \n+unsafe impl<'a, T: 'a> rustc_data_structures::tagged_ptr::Pointer for &'a List<T> {\n+    const BITS: usize = std::mem::align_of::<usize>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        self as *const List<T> as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        &*(ptr as *const List<T>)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        // Self: Copy so this is fine\n+        let ptr = Self::from_usize(ptr);\n+        f(&ptr)\n+    }\n+}\n+\n unsafe impl<T: Sync> Sync for List<T> {}\n \n impl<T: Copy> List<T> {"}, {"sha": "4fa86a91254ce698cffbe64a1a4ee8d000015d57", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 32, "deletions": 60, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32c654a9795b0d88541e56ba9da4150e34f1d5f9/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=32c654a9795b0d88541e56ba9da4150e34f1d5f9", "patch": "@@ -27,6 +27,7 @@ use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, par_iter, ParallelIterator};\n+use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Namespace, Res};\n@@ -46,7 +47,6 @@ use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::marker::PhantomData;\n use std::ops::Range;\n use std::ptr;\n use std::str;\n@@ -1713,41 +1713,45 @@ impl WithOptConstParam<DefId> {\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ParamEnv<'tcx> {\n-    // We pack the caller_bounds List pointer and a Reveal enum into this usize.\n-    // Specifically, the low bit represents Reveal, with 0 meaning `UserFacing`\n-    // and 1 meaning `All`. The rest is the pointer.\n-    //\n-    // This relies on the List<Predicate<'tcx>> type having at least 2-byte\n-    // alignment. Lists start with a usize and are repr(C) so this should be\n-    // fine; there is a debug_assert in the constructor as well.\n-    //\n-    // Note that the choice of 0 for UserFacing is intentional -- since it is the\n-    // first variant in Reveal this means that joining the pointer is a simple `or`.\n-    packed_data: usize,\n-\n-    /// `Obligation`s that the caller must satisfy. This is basically\n-    /// the set of bounds on the in-scope type parameters, translated\n+    /// This packs both caller bounds and the reveal enum into one pointer.\n+    ///\n+    /// Caller bounds are `Obligation`s that the caller must satisfy. This is\n+    /// basically the set of bounds on the in-scope type parameters, translated\n     /// into `Obligation`s, and elaborated and normalized.\n     ///\n-    /// Note: This is packed into the `packed_data` usize above, use the\n-    /// `caller_bounds()` method to access it.\n-    caller_bounds: PhantomData<&'tcx List<Predicate<'tcx>>>,\n-\n+    /// Use the `caller_bounds()` method to access.\n+    ///\n     /// Typically, this is `Reveal::UserFacing`, but during codegen we\n     /// want `Reveal::All`.\n     ///\n-    /// Note: This is packed into the caller_bounds usize above, use the reveal()\n-    /// method to access it.\n-    reveal: PhantomData<traits::Reveal>,\n+    /// Note: This is packed, use the reveal() method to access it.\n+    packed: CopyTaggedPtr<&'tcx List<Predicate<'tcx>>, traits::Reveal, true>,\n \n     /// If this `ParamEnv` comes from a call to `tcx.param_env(def_id)`,\n     /// register that `def_id` (useful for transitioning to the chalk trait\n     /// solver).\n     pub def_id: Option<DefId>,\n }\n \n+unsafe impl rustc_data_structures::tagged_ptr::Tag for traits::Reveal {\n+    const BITS: usize = 1;\n+    fn into_usize(self) -> usize {\n+        match self {\n+            traits::Reveal::UserFacing => 0,\n+            traits::Reveal::All => 1,\n+        }\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        match ptr {\n+            0 => traits::Reveal::UserFacing,\n+            1 => traits::Reveal::All,\n+            _ => std::hint::unreachable_unchecked(),\n+        }\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for ParamEnv<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"ParamEnv\")\n@@ -1758,24 +1762,6 @@ impl<'tcx> fmt::Debug for ParamEnv<'tcx> {\n     }\n }\n \n-impl<'tcx> Hash for ParamEnv<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        // List hashes as the raw pointer, so we can skip splitting into the\n-        // pointer and the enum.\n-        self.packed_data.hash(state);\n-        self.def_id.hash(state);\n-    }\n-}\n-\n-impl<'tcx> PartialEq for ParamEnv<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.caller_bounds() == other.caller_bounds()\n-            && self.reveal() == other.reveal()\n-            && self.def_id == other.def_id\n-    }\n-}\n-impl<'tcx> Eq for ParamEnv<'tcx> {}\n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ParamEnv<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.caller_bounds().hash_stable(hcx, hasher);\n@@ -1812,13 +1798,12 @@ impl<'tcx> ParamEnv<'tcx> {\n \n     #[inline]\n     pub fn caller_bounds(self) -> &'tcx List<Predicate<'tcx>> {\n-        // mask out bottom bit\n-        unsafe { &*((self.packed_data & (!1)) as *const _) }\n+        self.packed.pointer()\n     }\n \n     #[inline]\n     pub fn reveal(self) -> traits::Reveal {\n-        if self.packed_data & 1 == 0 { traits::Reveal::UserFacing } else { traits::Reveal::All }\n+        self.packed.tag()\n     }\n \n     /// Construct a trait environment with no where-clauses in scope\n@@ -1840,24 +1825,11 @@ impl<'tcx> ParamEnv<'tcx> {\n         reveal: Reveal,\n         def_id: Option<DefId>,\n     ) -> Self {\n-        let packed_data = caller_bounds as *const _ as usize;\n-        // Check that we can pack the reveal data into the pointer.\n-        debug_assert!(packed_data & 1 == 0);\n-        ty::ParamEnv {\n-            packed_data: packed_data\n-                | match reveal {\n-                    Reveal::UserFacing => 0,\n-                    Reveal::All => 1,\n-                },\n-            caller_bounds: PhantomData,\n-            reveal: PhantomData,\n-            def_id,\n-        }\n+        ty::ParamEnv { packed: CopyTaggedPtr::new(caller_bounds, reveal), def_id }\n     }\n \n     pub fn with_user_facing(mut self) -> Self {\n-        // clear bottom bit\n-        self.packed_data &= !1;\n+        self.packed.set_tag(Reveal::UserFacing);\n         self\n     }\n \n@@ -1871,7 +1843,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// will be normalized to their underlying types.\n     /// See PR #65989 and issue #65918 for more details\n     pub fn with_reveal_all_normalized(self, tcx: TyCtxt<'tcx>) -> Self {\n-        if self.packed_data & 1 == 1 {\n+        if self.packed.tag() == traits::Reveal::All {\n             return self;\n         }\n "}]}