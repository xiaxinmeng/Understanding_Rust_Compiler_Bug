{"sha": "1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYzU2MDhkMGJiNmJmMmVlZTVhMWI5MTkwZmNiMmY4Y2RmYTJlZjM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-31T18:05:12Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-31T18:05:12Z"}, "message": "Merge #176\n\n176: Move completio to ra_analysis r=matklad a=matklad\n\nWhile we should handle completion for isolated file, it's better\r\nachieved by using empty Analysis, rather than working only with &File:\r\nwe need memoization for type inference even inside a single file.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b3c8a97880c625a81a814f4afa4e461ce5a58b82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3c8a97880c625a81a814f4afa4e461ce5a58b82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "html_url": "https://github.com/rust-lang/rust/commit/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "e60ef6260f49b2b0438f8649ca71034fbafef631", "url": "https://api.github.com/repos/rust-lang/rust/commits/e60ef6260f49b2b0438f8649ca71034fbafef631", "html_url": "https://github.com/rust-lang/rust/commit/e60ef6260f49b2b0438f8649ca71034fbafef631"}, {"sha": "c09e14a4ff02f774460a70472e1aeb3c598e01dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c09e14a4ff02f774460a70472e1aeb3c598e01dc", "html_url": "https://github.com/rust-lang/rust/commit/c09e14a4ff02f774460a70472e1aeb3c598e01dc"}], "stats": {"total": 2132, "additions": 1066, "deletions": 1066}, "files": [{"sha": "340ae3f664319320c3c6684dc21d3ef989bba0d6", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 619, "deletions": 4, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -1,16 +1,32 @@\n-use ra_editor::{CompletionItem, find_node_at_offset};\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use ra_editor::{find_node_at_offset};\n use ra_syntax::{\n-    AtomEdit, File, TextUnit, AstNode,\n-    ast::{self, ModuleItemOwner, AstChildren},\n+    AtomEdit, File, TextUnit, AstNode, SyntaxNodeRef,\n+    algo::visit::{visitor, visitor_ctx, Visitor, VisitorCtx},\n+    ast::{self, AstChildren, LoopBodyOwner, ModuleItemOwner},\n+    SyntaxKind::*,\n };\n \n use crate::{\n     FileId, Cancelable,\n     input::FilesDatabase,\n     db::{self, SyntaxDatabase},\n-    descriptors::module::{ModulesDatabase, ModuleTree, ModuleId, scope::ModuleScope},\n+    descriptors::DescriptorDatabase,\n+    descriptors::function::FnScopes,\n+    descriptors::module::{ModuleTree, ModuleId, ModuleScope},\n };\n \n+\n+#[derive(Debug)]\n+pub struct CompletionItem {\n+    /// What user sees in pop-up\n+    pub label: String,\n+    /// What string is used for filtering, defaults to label\n+    pub lookup: Option<String>,\n+    /// What is inserted, defaults to label\n+    pub snippet: Option<String>,\n+}\n+\n pub(crate) fn resolve_based_completion(db: &db::RootDatabase, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n     let source_root_id = db.file_source_root(file_id);\n     let file = db.file_syntax(file_id);\n@@ -72,3 +88,602 @@ fn crate_path(name_ref: ast::NameRef) -> Option<Vec<ast::NameRef>> {\n     res.reverse();\n     Some(res)\n }\n+\n+\n+pub(crate) fn scope_completion(\n+    db: &db::RootDatabase,\n+    file_id: FileId,\n+    offset: TextUnit,\n+) -> Option<Vec<CompletionItem>> {\n+    let original_file = db.file_syntax(file_id);\n+    // Insert a fake ident to get a valid parse tree\n+    let file = {\n+        let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n+        original_file.reparse(&edit)\n+    };\n+    let mut has_completions = false;\n+    let mut res = Vec::new();\n+    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n+        has_completions = true;\n+        complete_name_ref(&file, name_ref, &mut res);\n+        // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n+        if is_node::<ast::Param>(name_ref.syntax()) {\n+            param_completions(name_ref.syntax(), &mut res);\n+        }\n+        let name_range = name_ref.syntax().range();\n+        let top_node = name_ref\n+            .syntax()\n+            .ancestors()\n+            .take_while(|it| it.range() == name_range)\n+            .last()\n+            .unwrap();\n+        match top_node.parent().map(|it| it.kind()) {\n+            Some(ROOT) | Some(ITEM_LIST) => complete_mod_item_snippets(&mut res),\n+            _ => (),\n+        }\n+    }\n+    if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n+        if is_node::<ast::Param>(name.syntax()) {\n+            has_completions = true;\n+            param_completions(name.syntax(), &mut res);\n+        }\n+    }\n+    if has_completions {\n+        Some(res)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn complete_module_items(\n+    file: &File,\n+    items: AstChildren<ast::ModuleItem>,\n+    this_item: Option<ast::NameRef>,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n+    let scope = ModuleScope::from_items(items);\n+    acc.extend(\n+        scope\n+            .entries()\n+            .iter()\n+            .filter(|entry| {\n+                let syntax = entry.ptr().resolve(file);\n+                Some(syntax.borrowed()) != this_item.map(|it| it.syntax())\n+            })\n+            .map(|entry| CompletionItem {\n+                label: entry.name().to_string(),\n+                lookup: None,\n+                snippet: None,\n+            }),\n+    );\n+}\n+\n+fn complete_name_ref(\n+    file: &File,\n+    name_ref: ast::NameRef,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n+    if !is_node::<ast::Path>(name_ref.syntax()) {\n+        return;\n+    }\n+    let mut visited_fn = false;\n+    for node in name_ref.syntax().ancestors() {\n+        if let Some(items) = visitor()\n+            .visit::<ast::Root, _>(|it| Some(it.items()))\n+            .visit::<ast::Module, _>(|it| Some(it.item_list()?.items()))\n+            .accept(node)\n+        {\n+            if let Some(items) = items {\n+                complete_module_items(file, items, Some(name_ref), acc);\n+            }\n+            break;\n+        } else if !visited_fn {\n+            if let Some(fn_def) = ast::FnDef::cast(node) {\n+                visited_fn = true;\n+                complete_expr_keywords(&file, fn_def, name_ref, acc);\n+                complete_expr_snippets(acc);\n+                let scopes = FnScopes::new(fn_def);\n+                complete_fn(name_ref, &scopes, acc);\n+            }\n+        }\n+    }\n+}\n+\n+fn param_completions(ctx: SyntaxNodeRef, acc: &mut Vec<CompletionItem>) {\n+    let mut params = FxHashMap::default();\n+    for node in ctx.ancestors() {\n+        let _ = visitor_ctx(&mut params)\n+            .visit::<ast::Root, _>(process)\n+            .visit::<ast::ItemList, _>(process)\n+            .accept(node);\n+    }\n+    params\n+        .into_iter()\n+        .filter_map(|(label, (count, param))| {\n+            let lookup = param.pat()?.syntax().text().to_string();\n+            if count < 2 {\n+                None\n+            } else {\n+                Some((label, lookup))\n+            }\n+        })\n+        .for_each(|(label, lookup)| {\n+            acc.push(CompletionItem {\n+                label,\n+                lookup: Some(lookup),\n+                snippet: None,\n+            })\n+        });\n+\n+    fn process<'a, N: ast::FnDefOwner<'a>>(\n+        node: N,\n+        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n+    ) {\n+        node.functions()\n+            .filter_map(|it| it.param_list())\n+            .flat_map(|it| it.params())\n+            .for_each(|param| {\n+                let text = param.syntax().text().to_string();\n+                params.entry(text).or_insert((0, param)).0 += 1;\n+            })\n+    }\n+}\n+\n+fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n+    match node.ancestors().filter_map(N::cast).next() {\n+        None => false,\n+        Some(n) => n.syntax().range() == node.range(),\n+    }\n+}\n+\n+fn complete_expr_keywords(\n+    file: &File,\n+    fn_def: ast::FnDef,\n+    name_ref: ast::NameRef,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n+    acc.push(keyword(\"if\", \"if $0 {}\"));\n+    acc.push(keyword(\"match\", \"match $0 {}\"));\n+    acc.push(keyword(\"while\", \"while $0 {}\"));\n+    acc.push(keyword(\"loop\", \"loop {$0}\"));\n+\n+    if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n+        if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n+            if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n+                acc.push(keyword(\"else\", \"else {$0}\"));\n+                acc.push(keyword(\"else if\", \"else if $0 {}\"));\n+            }\n+        }\n+    }\n+    if is_in_loop_body(name_ref) {\n+        acc.push(keyword(\"continue\", \"continue\"));\n+        acc.push(keyword(\"break\", \"break\"));\n+    }\n+    acc.extend(complete_return(fn_def, name_ref));\n+}\n+\n+fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n+    for node in name_ref.syntax().ancestors() {\n+        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n+            break;\n+        }\n+        let loop_body = visitor()\n+            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n+            .accept(node);\n+        if let Some(Some(body)) = loop_body {\n+            if name_ref.syntax().range().is_subrange(&body.syntax().range()) {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<CompletionItem> {\n+    // let is_last_in_block = name_ref.syntax().ancestors().filter_map(ast::Expr::cast)\n+    //     .next()\n+    //     .and_then(|it| it.syntax().parent())\n+    //     .and_then(ast::Block::cast)\n+    //     .is_some();\n+\n+    // if is_last_in_block {\n+    //     return None;\n+    // }\n+\n+    let is_stmt = match name_ref\n+        .syntax()\n+        .ancestors()\n+        .filter_map(ast::ExprStmt::cast)\n+        .next()\n+    {\n+        None => false,\n+        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n+    };\n+    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n+        (true, true) => \"return $0;\",\n+        (true, false) => \"return;\",\n+        (false, true) => \"return $0\",\n+        (false, false) => \"return\",\n+    };\n+    Some(keyword(\"return\", snip))\n+}\n+\n+fn keyword(kw: &str, snip: &str) -> CompletionItem {\n+    CompletionItem {\n+        label: kw.to_string(),\n+        lookup: None,\n+        snippet: Some(snip.to_string()),\n+    }\n+}\n+\n+fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n+    acc.push(CompletionItem {\n+        label: \"pd\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n+    });\n+    acc.push(CompletionItem {\n+        label: \"ppd\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n+    });\n+}\n+\n+fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n+    acc.push(CompletionItem {\n+        label: \"tfn\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\".to_string()),\n+    });\n+    acc.push(CompletionItem {\n+        label: \"pub(crate)\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"pub(crate) $0\".to_string()),\n+    })\n+}\n+\n+fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n+    let mut shadowed = FxHashSet::default();\n+    acc.extend(\n+        scopes\n+            .scope_chain(name_ref.syntax())\n+            .flat_map(|scope| scopes.entries(scope).iter())\n+            .filter(|entry| shadowed.insert(entry.name()))\n+            .map(|entry| CompletionItem {\n+                label: entry.name().to_string(),\n+                lookup: None,\n+                snippet: None,\n+            }),\n+    );\n+    if scopes.self_param.is_some() {\n+        acc.push(CompletionItem {\n+            label: \"self\".to_string(),\n+            lookup: None,\n+            snippet: None,\n+        })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::{assert_eq_dbg, extract_offset};\n+\n+    use crate::FileId;\n+    use crate::mock_analysis::MockAnalysis;\n+\n+    use super::*;\n+\n+    fn check_scope_completion(code: &str, expected_completions: &str) {\n+        let (off, code) = extract_offset(&code);\n+        let analysis = MockAnalysis::with_files(&[(\"/main.rs\", &code)]).analysis();\n+        let file_id = FileId(1);\n+        let completions = scope_completion(&analysis.imp.db, file_id, off)\n+            .unwrap()\n+            .into_iter()\n+            .filter(|c| c.snippet.is_none())\n+            .collect::<Vec<_>>();\n+        assert_eq_dbg(expected_completions, &completions);\n+    }\n+\n+    fn check_snippet_completion(code: &str, expected_completions: &str) {\n+        let (off, code) = extract_offset(&code);\n+        let analysis = MockAnalysis::with_files(&[(\"/main.rs\", &code)]).analysis();\n+        let file_id = FileId(1);\n+        let completions = scope_completion(&analysis.imp.db, file_id, off)\n+            .unwrap()\n+            .into_iter()\n+            .filter(|c| c.snippet.is_some())\n+            .collect::<Vec<_>>();\n+        assert_eq_dbg(expected_completions, &completions);\n+    }\n+\n+    #[test]\n+    fn test_completion_let_scope() {\n+        check_scope_completion(\n+            r\"\n+            fn quux(x: i32) {\n+                let y = 92;\n+                1 + <|>;\n+                let z = ();\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"y\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"x\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_if_let_scope() {\n+        check_scope_completion(\n+            r\"\n+            fn quux() {\n+                if let Some(x) = foo() {\n+                    let y = 92;\n+                };\n+                if let Some(a) = bar() {\n+                    let b = 62;\n+                    1 + <|>\n+                }\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"b\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"a\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_for_scope() {\n+        check_scope_completion(\n+            r\"\n+            fn quux() {\n+                for x in &[1, 2, 3] {\n+                    <|>\n+                }\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"x\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope() {\n+        check_scope_completion(\n+            r\"\n+            struct Foo;\n+            enum Baz {}\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"Baz\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_no_self_use() {\n+        check_scope_completion(\n+            r\"\n+            use foo<|>;\n+            \",\n+            r#\"[]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_nested() {\n+        check_scope_completion(\n+            r\"\n+            struct Foo;\n+            mod m {\n+                struct Bar;\n+                fn quux() { <|> }\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_type() {\n+        check_scope_completion(\n+            r\"\n+            struct Foo;\n+            fn x() -> <|>\n+        \",\n+            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n+               CompletionItem { label: \"x\", lookup: None, snippet: None }]\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_shadowing() {\n+        check_scope_completion(\n+            r\"\n+            fn foo() -> {\n+                let bar = 92;\n+                {\n+                    let bar = 62;\n+                    <|>\n+                }\n+            }\n+        \",\n+            r#\"[CompletionItem { label: \"bar\", lookup: None, snippet: None },\n+               CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_self() {\n+        check_scope_completion(\n+            r\"\n+            impl S { fn foo(&self) { <|> } }\n+        \",\n+            r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None }]\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_completion_kewords() {\n+        check_snippet_completion(r\"\n+            fn quux() {\n+                <|>\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_completion_else() {\n+        check_snippet_completion(r\"\n+            fn quux() {\n+                if true {\n+                    ()\n+                } <|>\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"else\", lookup: None, snippet: Some(\"else {$0}\") },\n+                   CompletionItem { label: \"else if\", lookup: None, snippet: Some(\"else if $0 {}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_completion_return_value() {\n+        check_snippet_completion(r\"\n+            fn quux() -> i32 {\n+                <|>\n+                92\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0;\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+        check_snippet_completion(r\"\n+            fn quux() {\n+                <|>\n+                92\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return;\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_completion_return_no_stmt() {\n+        check_snippet_completion(r\"\n+            fn quux() -> i32 {\n+                match () {\n+                    () => <|>\n+                }\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_continue_break_completion() {\n+        check_snippet_completion(r\"\n+            fn quux() -> i32 {\n+                loop { <|> }\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"continue\", lookup: None, snippet: Some(\"continue\") },\n+                   CompletionItem { label: \"break\", lookup: None, snippet: Some(\"break\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+        check_snippet_completion(r\"\n+            fn quux() -> i32 {\n+                loop { || { <|> } }\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_param_completion_last_param() {\n+        check_scope_completion(r\"\n+            fn foo(file_id: FileId) {}\n+            fn bar(file_id: FileId) {}\n+            fn baz(file<|>) {}\n+        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_param_completion_nth_param() {\n+        check_scope_completion(r\"\n+            fn foo(file_id: FileId) {}\n+            fn bar(file_id: FileId) {}\n+            fn baz(file<|>, x: i32) {}\n+        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_param_completion_trait_param() {\n+        check_scope_completion(r\"\n+            pub(crate) trait SourceRoot {\n+                pub fn contains(&self, file_id: FileId) -> bool;\n+                pub fn module_map(&self) -> &ModuleMap;\n+                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n+                pub fn syntax(&self, file<|>)\n+            }\n+        \", r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None },\n+               CompletionItem { label: \"SourceRoot\", lookup: None, snippet: None },\n+               CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_item_snippets() {\n+        // check_snippet_completion(r\"\n+        //     <|>\n+        //     \",\n+        //     r##\"[CompletionItem { label: \"tfn\", lookup: None, snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\") }]\"##,\n+        // );\n+        check_snippet_completion(r\"\n+            #[cfg(test)]\n+            mod tests {\n+                <|>\n+            }\n+            \",\n+            r##\"[CompletionItem { label: \"tfn\", lookup: None, snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\") },\n+                 CompletionItem { label: \"pub(crate)\", lookup: None, snippet: Some(\"pub(crate) $0\") }]\"##,\n+        );\n+    }\n+}"}, {"sha": "fe6587f208807150386c8dae16807a625ea5967f", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -9,7 +9,10 @@ use salsa;\n use crate::{\n     db,\n     Cancelable, Canceled,\n-    descriptors::module::{SubmodulesQuery, ModuleTreeQuery, ModulesDatabase, ModuleScopeQuery},\n+    descriptors::{\n+        DescriptorDatabase, SubmodulesQuery, ModuleTreeQuery, ModuleScopeQuery,\n+        FnSyntaxQuery, FnScopesQuery\n+    },\n     symbol_index::SymbolIndex,\n     syntax_ptr::{SyntaxPtrDatabase, ResolveSyntaxPtrQuery},\n     FileId,\n@@ -63,10 +66,12 @@ salsa::database_storage! {\n             fn file_lines() for FileLinesQuery;\n             fn file_symbols() for FileSymbolsQuery;\n         }\n-        impl ModulesDatabase {\n+        impl DescriptorDatabase {\n             fn module_tree() for ModuleTreeQuery;\n             fn module_descriptor() for SubmodulesQuery;\n             fn module_scope() for ModuleScopeQuery;\n+            fn fn_syntax() for FnSyntaxQuery;\n+            fn fn_scopes() for FnScopesQuery;\n         }\n         impl SyntaxPtrDatabase {\n             fn resolve_syntax_ptr() for ResolveSyntaxPtrQuery;"}, {"sha": "0a006f7331000df8f8607f915b19795ffb5211d4", "filename": "crates/ra_analysis/src/descriptors/function/imp.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -0,0 +1,26 @@\n+use std::sync::Arc;\n+\n+use ra_syntax::{\n+    ast::{AstNode, FnDef, FnDefNode},\n+};\n+\n+use crate::{\n+    descriptors::{\n+        DescriptorDatabase,\n+        function::{FnId, FnScopes},\n+    },\n+};\n+\n+/// Resolve `FnId` to the corresponding `SyntaxNode`\n+/// TODO: this should return something more type-safe then `SyntaxNode`\n+pub(crate) fn fn_syntax(db: &impl DescriptorDatabase, fn_id: FnId) -> FnDefNode {\n+    let syntax = db.resolve_syntax_ptr(fn_id.0);\n+    let fn_def = FnDef::cast(syntax.borrowed()).unwrap();\n+    FnDefNode::new(fn_def)\n+}\n+\n+pub(crate) fn fn_scopes(db: &impl DescriptorDatabase, fn_id: FnId) -> Arc<FnScopes> {\n+    let syntax = db.fn_syntax(fn_id);\n+    let res = FnScopes::new(syntax.ast());\n+    Arc::new(res)\n+}"}, {"sha": "bb68b0ce757976d51613c4baa8fd039009cadbf9", "filename": "crates/ra_analysis/src/descriptors/function/mod.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fmod.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -0,0 +1,83 @@\n+pub(super) mod imp;\n+mod scope;\n+\n+use ra_syntax::{\n+    ast::{self, AstNode, NameOwner}\n+};\n+\n+use crate::{\n+    FileId,\n+    syntax_ptr::SyntaxPtr\n+};\n+\n+pub(crate) use self::scope::{FnScopes, resolve_local_name};\n+\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct FnId(SyntaxPtr);\n+\n+impl FnId {\n+    pub(crate) fn new(file_id: FileId, fn_def: ast::FnDef) -> FnId {\n+        let ptr = SyntaxPtr::new(file_id, fn_def.syntax());\n+        FnId(ptr)\n+    }\n+}\n+\n+\n+#[derive(Debug, Clone)]\n+pub struct FnDescriptor {\n+    pub name: String,\n+    pub label: String,\n+    pub ret_type: Option<String>,\n+    pub params: Vec<String>,\n+}\n+\n+impl FnDescriptor {\n+    pub fn new(node: ast::FnDef) -> Option<Self> {\n+        let name = node.name()?.text().to_string();\n+\n+        // Strip the body out for the label.\n+        let label: String = if let Some(body) = node.body() {\n+            let body_range = body.syntax().range();\n+            let label: String = node\n+                .syntax()\n+                .children()\n+                .filter(|child| !child.range().is_subrange(&body_range))\n+                .map(|node| node.text().to_string())\n+                .collect();\n+            label\n+        } else {\n+            node.syntax().text().to_string()\n+        };\n+\n+        let params = FnDescriptor::param_list(node);\n+        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n+\n+        Some(FnDescriptor {\n+            name,\n+            ret_type,\n+            params,\n+            label,\n+        })\n+    }\n+\n+    fn param_list(node: ast::FnDef) -> Vec<String> {\n+        let mut res = vec![];\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                res.push(self_param.syntax().text().to_string())\n+            }\n+\n+            // Maybe use param.pat here? See if we can just extract the name?\n+            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n+            res.extend(\n+                param_list\n+                    .params()\n+                    .filter_map(|p| p.pat())\n+                    .map(|pat| pat.syntax().text().to_string()),\n+            );\n+        }\n+        res\n+    }\n+}\n+"}, {"sha": "d9929414c1a0342e8a457bd40faa8c10a5e7119b", "filename": "crates/ra_analysis/src/descriptors/function/scope.rs", "status": "renamed", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fscope.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -1,29 +1,42 @@\n-use std::fmt;\n-\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n     algo::generate,\n     ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n-    AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n+    AstNode, SmolStr, SyntaxNodeRef,\n };\n \n-type ScopeId = usize;\n+use crate::syntax_ptr::LocalSyntaxPtr;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub(crate) struct ScopeId(u32);\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n pub struct FnScopes {\n-    pub self_param: Option<SyntaxNode>,\n+    pub(crate) self_param: Option<LocalSyntaxPtr>,\n     scopes: Vec<ScopeData>,\n-    scope_for: FxHashMap<SyntaxNode, ScopeId>,\n+    scope_for: FxHashMap<LocalSyntaxPtr, ScopeId>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeEntry {\n+    name: SmolStr,\n+    ptr: LocalSyntaxPtr,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct ScopeData {\n+    parent: Option<ScopeId>,\n+    entries: Vec<ScopeEntry>,\n }\n \n impl FnScopes {\n-    pub fn new(fn_def: ast::FnDef) -> FnScopes {\n+    pub(crate) fn new(fn_def: ast::FnDef) -> FnScopes {\n         let mut scopes = FnScopes {\n             self_param: fn_def\n                 .param_list()\n                 .and_then(|it| it.self_param())\n-                .map(|it| it.syntax().owned()),\n+                .map(|it| LocalSyntaxPtr::new(it.syntax())),\n             scopes: Vec::new(),\n             scope_for: FxHashMap::default(),\n         };\n@@ -34,24 +47,24 @@ impl FnScopes {\n         }\n         scopes\n     }\n-    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n+    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.get(scope).entries\n     }\n     pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n         generate(self.scope_for(node), move |&scope| {\n-            self.scopes[scope].parent\n+            self.get(scope).parent\n         })\n     }\n     fn root_scope(&mut self) -> ScopeId {\n-        let res = self.scopes.len();\n+        let res = ScopeId(self.scopes.len() as u32);\n         self.scopes.push(ScopeData {\n             parent: None,\n             entries: vec![],\n         });\n         res\n     }\n     fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        let res = self.scopes.len();\n+        let res = ScopeId(self.scopes.len() as u32);\n         self.scopes.push(ScopeData {\n             parent: Some(parent),\n             entries: vec![],\n@@ -64,7 +77,7 @@ impl FnScopes {\n             .descendants()\n             .filter_map(ast::BindPat::cast)\n             .filter_map(ScopeEntry::new);\n-        self.scopes[scope].entries.extend(entries);\n+        self.get_mut(scope).entries.extend(entries);\n     }\n     fn add_params_bindings(&mut self, scope: ScopeId, params: Option<ast::ParamList>) {\n         params\n@@ -74,43 +87,36 @@ impl FnScopes {\n             .for_each(|it| self.add_bindings(scope, it));\n     }\n     fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n-        self.scope_for.insert(node.owned(), scope);\n+        self.scope_for.insert(LocalSyntaxPtr::new(node), scope);\n     }\n     fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n         node.ancestors()\n-            .filter_map(|it| self.scope_for.get(&it.owned()).map(|&scope| scope))\n+            .map(LocalSyntaxPtr::new)\n+            .filter_map(|it| self.scope_for.get(&it).map(|&scope| scope))\n             .next()\n     }\n-}\n-\n-pub struct ScopeEntry {\n-    syntax: SyntaxNode,\n+    fn get(&self, scope: ScopeId) -> &ScopeData {\n+        &self.scopes[scope.0 as usize]\n+    }\n+    fn get_mut(&mut self, scope: ScopeId) -> &mut ScopeData {\n+        &mut self.scopes[scope.0 as usize]\n+    }\n }\n \n impl ScopeEntry {\n     fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n-        if pat.name().is_some() {\n-            Some(ScopeEntry {\n-                syntax: pat.syntax().owned(),\n-            })\n-        } else {\n-            None\n-        }\n-    }\n-    pub fn name(&self) -> SmolStr {\n-        self.ast().name().unwrap().text()\n+        let name = pat.name()?;\n+        let res = ScopeEntry {\n+            name: name.text(),\n+            ptr: LocalSyntaxPtr::new(pat.syntax()),\n+        };\n+        Some(res)\n     }\n-    pub fn ast(&self) -> ast::BindPat {\n-        ast::BindPat::cast(self.syntax.borrowed()).unwrap()\n+    pub(crate) fn name(&self) -> &SmolStr {\n+        &self.name\n     }\n-}\n-\n-impl fmt::Debug for ScopeEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ScopeEntry\")\n-            .field(\"name\", &self.name())\n-            .field(\"syntax\", &self.syntax)\n-            .finish()\n+    pub(crate) fn ptr(&self) -> LocalSyntaxPtr {\n+        self.ptr\n     }\n }\n \n@@ -251,33 +257,28 @@ fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n     }\n }\n \n-#[derive(Debug)]\n-struct ScopeData {\n-    parent: Option<ScopeId>,\n-    entries: Vec<ScopeEntry>,\n-}\n-\n pub fn resolve_local_name<'a>(\n     name_ref: ast::NameRef,\n     scopes: &'a FnScopes,\n ) -> Option<&'a ScopeEntry> {\n-    use rustc_hash::FxHashSet;\n-\n     let mut shadowed = FxHashSet::default();\n     let ret = scopes\n         .scope_chain(name_ref.syntax())\n         .flat_map(|scope| scopes.entries(scope).iter())\n         .filter(|entry| shadowed.insert(entry.name()))\n-        .filter(|entry| entry.name() == name_ref.text())\n+        .filter(|entry| entry.name() == &name_ref.text())\n         .nth(0);\n     ret\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use crate::{find_node_at_offset, test_utils::extract_offset};\n     use ra_syntax::File;\n+    use test_utils::extract_offset;\n+    use ra_editor::{find_node_at_offset};\n+\n+    use super::*;\n+\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let (off, code) = extract_offset(code);\n@@ -384,14 +385,11 @@ mod tests {\n \n         let scopes = FnScopes::new(fn_def);\n \n-        let local_name = resolve_local_name(name_ref, &scopes)\n-            .unwrap()\n-            .ast()\n-            .name()\n-            .unwrap();\n+        let local_name_entry = resolve_local_name(name_ref, &scopes).unwrap();\n+        let local_name = local_name_entry.ptr().resolve(&file);\n         let expected_name =\n             find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();\n-        assert_eq!(local_name.syntax().range(), expected_name.syntax().range());\n+        assert_eq!(local_name.range(), expected_name.syntax().range());\n     }\n \n     #[test]", "previous_filename": "crates/ra_editor/src/scope/fn_scope.rs"}, {"sha": "0c4991757d28f82510f19761acbc1778eda3278b", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "modified", "additions": 36, "deletions": 52, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -1,62 +1,46 @@\n pub(crate) mod module;\n+pub(crate) mod function;\n+\n+use std::sync::Arc;\n \n use ra_syntax::{\n-    ast::{self, AstNode, NameOwner},\n+    SmolStr,\n+    ast::{FnDefNode},\n };\n \n-#[derive(Debug, Clone)]\n-pub struct FnDescriptor {\n-    pub name: String,\n-    pub label: String,\n-    pub ret_type: Option<String>,\n-    pub params: Vec<String>,\n-}\n-\n-impl FnDescriptor {\n-    pub fn new(node: ast::FnDef) -> Option<Self> {\n-        let name = node.name()?.text().to_string();\n-\n-        // Strip the body out for the label.\n-        let label: String = if let Some(body) = node.body() {\n-            let body_range = body.syntax().range();\n-            let label: String = node\n-                .syntax()\n-                .children()\n-                .filter(|child| !child.range().is_subrange(&body_range))\n-                .map(|node| node.text().to_string())\n-                .collect();\n-            label\n-        } else {\n-            node.syntax().text().to_string()\n-        };\n-\n-        let params = FnDescriptor::param_list(node);\n-        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n-\n-        Some(FnDescriptor {\n-            name,\n-            ret_type,\n-            params,\n-            label,\n-        })\n-    }\n+use crate::{\n+    FileId, Cancelable,\n+    db::SyntaxDatabase,\n+    descriptors::module::{ModuleTree, ModuleId, ModuleScope},\n+    descriptors::function::{FnId, FnScopes},\n+    input::SourceRootId,\n+    syntax_ptr::SyntaxPtrDatabase,\n+};\n \n-    fn param_list(node: ast::FnDef) -> Vec<String> {\n-        let mut res = vec![];\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                res.push(self_param.syntax().text().to_string())\n-            }\n \n-            // Maybe use param.pat here? See if we can just extract the name?\n-            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n-            res.extend(\n-                param_list\n-                    .params()\n-                    .filter_map(|p| p.pat())\n-                    .map(|pat| pat.syntax().text().to_string()),\n-            );\n+salsa::query_group! {\n+    pub(crate) trait DescriptorDatabase: SyntaxDatabase + SyntaxPtrDatabase {\n+        fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n+            type ModuleTreeQuery;\n+            use fn module::imp::module_tree;\n+        }\n+        fn submodules(file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n+            type SubmodulesQuery;\n+            use fn module::imp::submodules;\n+        }\n+        fn module_scope(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleScope>> {\n+            type ModuleScopeQuery;\n+            use fn module::imp::module_scope;\n+        }\n+        fn fn_syntax(fn_id: FnId) -> FnDefNode {\n+            type FnSyntaxQuery;\n+            // Don't retain syntax trees in memory\n+            storage volatile;\n+            use fn function::imp::fn_syntax;\n+        }\n+        fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n+            type FnScopesQuery;\n+            use fn function::imp::fn_scopes;\n         }\n-        res\n     }\n }"}, {"sha": "dae3a356d4cdb972cdd61e627ff4f82d868f4794", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -10,22 +10,23 @@ use ra_syntax::{\n use crate::{\n     FileId, Cancelable, FileResolverImp, db,\n     input::{SourceRoot, SourceRootId},\n+    descriptors::DescriptorDatabase,\n };\n \n use super::{\n-    ModuleData, ModuleTree, ModuleId, LinkId, LinkData, Problem, ModulesDatabase, ModuleScope\n+    ModuleData, ModuleTree, ModuleId, LinkId, LinkData, Problem, ModuleScope\n };\n \n \n-pub(super) fn submodules(db: &impl ModulesDatabase, file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n+pub(crate) fn submodules(db: &impl DescriptorDatabase, file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n     db::check_canceled(db)?;\n     let file = db.file_syntax(file_id);\n     let root = file.ast();\n     let submodules = modules(root).map(|(name, _)| name).collect();\n     Ok(Arc::new(submodules))\n }\n \n-pub(super) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast::Module<'_>)> {\n+pub(crate) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast::Module<'_>)> {\n     root.modules().filter_map(|module| {\n         let name = module.name()?.text();\n         if !module.has_semi() {\n@@ -35,8 +36,8 @@ pub(super) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast\n     })\n }\n \n-pub(super) fn module_scope(\n-    db: &impl ModulesDatabase,\n+pub(crate) fn module_scope(\n+    db: &impl DescriptorDatabase,\n     source_root_id: SourceRootId,\n     module_id: ModuleId,\n ) -> Cancelable<Arc<ModuleScope>> {\n@@ -47,8 +48,8 @@ pub(super) fn module_scope(\n     Ok(Arc::new(res))\n }\n \n-pub(super) fn module_tree(\n-    db: &impl ModulesDatabase,\n+pub(crate) fn module_tree(\n+    db: &impl DescriptorDatabase,\n     source_root: SourceRootId,\n ) -> Cancelable<Arc<ModuleTree>> {\n     db::check_canceled(db)?;\n@@ -64,7 +65,7 @@ pub struct Submodule {\n \n \n fn create_module_tree<'a>(\n-    db: &impl ModulesDatabase,\n+    db: &impl DescriptorDatabase,\n     source_root: SourceRootId,\n ) -> Cancelable<ModuleTree> {\n     let mut tree = ModuleTree {\n@@ -88,7 +89,7 @@ fn create_module_tree<'a>(\n }\n \n fn build_subtree(\n-    db: &impl ModulesDatabase,\n+    db: &impl DescriptorDatabase,\n     source_root: &SourceRoot,\n     tree: &mut ModuleTree,\n     visited: &mut FxHashSet<FileId>,"}, {"sha": "667553f74960ab73284e952a96f1bf711bab7208", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -1,37 +1,13 @@\n-mod imp;\n+pub(super) mod imp;\n pub(crate) mod scope;\n \n-use std::sync::Arc;\n-\n use relative_path::RelativePathBuf;\n use ra_syntax::{ast::{self, NameOwner, AstNode}, SmolStr, SyntaxNode};\n \n-use crate::{\n-    FileId, Cancelable,\n-    db::SyntaxDatabase,\n-    input::SourceRootId,\n-};\n+use crate::FileId;\n \n pub(crate) use self::scope::ModuleScope;\n \n-salsa::query_group! {\n-    pub(crate) trait ModulesDatabase: SyntaxDatabase {\n-        fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n-            type ModuleTreeQuery;\n-            use fn imp::module_tree;\n-        }\n-        fn submodules(file_id: FileId) -> Cancelable<Arc<Vec<SmolStr>>> {\n-            type SubmodulesQuery;\n-            use fn imp::submodules;\n-        }\n-        fn module_scope(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleScope>> {\n-            type ModuleScopeQuery;\n-            use fn imp::module_scope;\n-        }\n-    }\n-}\n-\n-\n #[derive(Debug, PartialEq, Eq, Hash)]\n pub(crate) struct ModuleTree {\n     mods: Vec<ModuleData>,"}, {"sha": "846b8b44f0aa5761cd18498d2c20a4fa5074d43a", "filename": "crates/ra_analysis/src/descriptors/module/scope.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -2,8 +2,8 @@\n \n \n use ra_syntax::{\n-    ast::{self, AstChildren, ModuleItemOwner},\n-    File, AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n+    ast::{self, ModuleItemOwner},\n+    File, AstNode, SmolStr,\n };\n \n use crate::syntax_ptr::LocalSyntaxPtr;\n@@ -30,8 +30,12 @@ enum EntryKind {\n \n impl ModuleScope {\n     pub fn new(file: &File) -> ModuleScope {\n+        ModuleScope::from_items(file.ast().items())\n+    }\n+\n+    pub fn from_items<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n         let mut entries = Vec::new();\n-        for item in file.ast().items() {\n+        for item in items {\n             let entry = match item {\n                 ast::ModuleItem::StructDef(item) => Entry::new(item),\n                 ast::ModuleItem::EnumDef(item) => Entry::new(item),\n@@ -99,7 +103,7 @@ fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ra_syntax::{ast::ModuleItemOwner, File};\n+    use ra_syntax::{File};\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let file = File::parse(&code);"}, {"sha": "38d4b6a232aac98ce3f56886abb978a1792e205e", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -3,7 +3,7 @@ use std::{\n     sync::Arc,\n };\n \n-use ra_editor::{self, find_node_at_offset, resolve_local_name, FileSymbol, LineIndex, LocalEdit, CompletionItem};\n+use ra_editor::{self, find_node_at_offset, FileSymbol, LineIndex, LocalEdit};\n use ra_syntax::{\n     ast::{self, ArgListOwner, Expr, NameOwner},\n     AstNode, File, SmolStr,\n@@ -21,9 +21,14 @@ use crate::{\n         self, SyntaxDatabase, FileSyntaxQuery,\n     },\n     input::{SourceRootId, FilesDatabase, SourceRoot, WORKSPACE},\n-    descriptors::module::{ModulesDatabase, ModuleTree, Problem},\n-    descriptors::{FnDescriptor},\n+    descriptors::{\n+        DescriptorDatabase,\n+        module::{ModuleTree, Problem},\n+        function::{FnDescriptor, FnId},\n+    },\n+    completion::{scope_completion, resolve_based_completion, CompletionItem},\n     symbol_index::SymbolIndex,\n+    syntax_ptr::SyntaxPtrDatabase,\n     CrateGraph, CrateId, Diagnostic, FileId, FileResolver, FileSystemEdit, Position,\n     Query, SourceChange, SourceFileEdit, Cancelable,\n };\n@@ -175,7 +180,7 @@ impl AnalysisHostImpl {\n \n #[derive(Debug)]\n pub(crate) struct AnalysisImpl {\n-    db: db::RootDatabase,\n+    pub(crate) db: db::RootDatabase,\n }\n \n impl AnalysisImpl {\n@@ -245,12 +250,11 @@ impl AnalysisImpl {\n     pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let mut res = Vec::new();\n         let mut has_completions = false;\n-        let file = self.file_syntax(file_id);\n-        if let Some(scope_based) = ra_editor::scope_completion(&file, offset) {\n+        if let Some(scope_based) = scope_completion(&self.db, file_id, offset) {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n-        if let Some(scope_based) = crate::completion::resolve_based_completion(&self.db, file_id, offset)? {\n+        if let Some(scope_based) = resolve_based_completion(&self.db, file_id, offset)? {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n@@ -271,7 +275,7 @@ impl AnalysisImpl {\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n             // First try to resolve the symbol locally\n-            return if let Some((name, range)) = resolve_local_name(name_ref) {\n+            return if let Some((name, range)) = resolve_local_name(&self.db, file_id, name_ref) {\n                 let mut vec = vec![];\n                 vec.push((\n                     file_id,\n@@ -325,15 +329,15 @@ impl AnalysisImpl {\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n \n             // We are only handing local references for now\n-            if let Some(resolved) = resolve_local_name(name_ref) {\n+            if let Some(resolved) = resolve_local_name(&self.db, file_id, name_ref) {\n \n                 ret.push((file_id, resolved.1));\n \n                 if let Some(fn_def) = find_node_at_offset::<ast::FnDef>(syntax, offset) {\n \n                     let refs : Vec<_> = fn_def.syntax().descendants()\n                         .filter_map(ast::NameRef::cast)\n-                        .filter(|&n: &ast::NameRef| resolve_local_name(n) == Some(resolved.clone()))\n+                        .filter(|&n: &ast::NameRef| resolve_local_name(&self.db, file_id, n) == Some(resolved.clone()))\n                         .collect();\n \n                     for r in refs {\n@@ -597,3 +601,16 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n }\n+\n+fn resolve_local_name(\n+    db: &db::RootDatabase,\n+    file_id: FileId,\n+    name_ref: ast::NameRef,\n+) -> Option<(SmolStr, TextRange)> {\n+    let fn_def = name_ref.syntax().ancestors().find_map(ast::FnDef::cast)?;\n+    let fn_id = FnId::new(file_id, fn_def);\n+    let scopes = db.fn_scopes(fn_id);\n+    let scope_entry = crate::descriptors::function::resolve_local_name(name_ref, &scopes)?;\n+    let syntax = db.resolve_syntax_ptr(scope_entry.ptr().into_global(file_id));\n+    Some((scope_entry.name().clone(), syntax.range()))\n+}"}, {"sha": "77601028165f06c94131da9ce043c193ec8336f2", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -13,6 +13,7 @@ mod imp;\n mod symbol_index;\n mod completion;\n mod syntax_ptr;\n+mod mock_analysis;\n \n use std::{\n     fmt,\n@@ -29,11 +30,13 @@ use crate::{\n };\n \n pub use crate::{\n-    descriptors::FnDescriptor,\n-    input::{FileId, FileResolver, CrateGraph, CrateId}\n+    descriptors::function::FnDescriptor,\n+    completion::CompletionItem,\n+    input::{FileId, FileResolver, CrateGraph, CrateId},\n+    mock_analysis::MockAnalysis,\n };\n pub use ra_editor::{\n-    CompletionItem, FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable,\n+    FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable,\n     RunnableKind, StructureNode,\n };\n \n@@ -197,7 +200,7 @@ impl Query {\n \n #[derive(Debug)]\n pub struct Analysis {\n-    imp: AnalysisImpl,\n+    pub(crate) imp: AnalysisImpl,\n }\n \n impl Analysis {"}, {"sha": "1c1dbee7c75250387ca90e73104c31aef460d6a3", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -0,0 +1,71 @@\n+\n+use std::sync::Arc;\n+\n+use relative_path::{RelativePath, RelativePathBuf};\n+\n+use crate::{\n+    AnalysisChange, Analysis, AnalysisHost, FileId, FileResolver,\n+};\n+\n+/// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n+/// from a set of in-memory files.\n+#[derive(Debug, Default)]\n+pub struct MockAnalysis {\n+    files: Vec<(String, String)>,\n+}\n+\n+impl MockAnalysis {\n+    pub fn new() -> MockAnalysis {\n+        MockAnalysis::default()\n+    }\n+    pub fn with_files(files: &[(&str, &str)]) -> MockAnalysis {\n+        let files = files.iter()\n+            .map(|it| (it.0.to_string(), it.1.to_string()))\n+            .collect();\n+        MockAnalysis { files }\n+    }\n+    pub fn analysis_host(self) -> AnalysisHost {\n+        let mut host = AnalysisHost::new();\n+        let mut file_map = Vec::new();\n+        let mut change = AnalysisChange::new();\n+        for (id, (path, contents)) in self.files.into_iter().enumerate() {\n+            let file_id = FileId((id + 1) as u32);\n+            assert!(path.starts_with('/'));\n+            let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n+            change.add_file(file_id, contents);\n+            file_map.push((file_id, path));\n+        }\n+        change.set_file_resolver(Arc::new(FileMap(file_map)));\n+        host.apply_change(change);\n+        host\n+    }\n+    pub fn analysis(self) -> Analysis {\n+        self.analysis_host().analysis()\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct FileMap(Vec<(FileId, RelativePathBuf)>);\n+\n+impl FileMap {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = (FileId, &'a RelativePath)> + 'a {\n+        self.0\n+            .iter()\n+            .map(|(id, path)| (*id, path.as_relative_path()))\n+    }\n+\n+    fn path(&self, id: FileId) -> &RelativePath {\n+        self.iter().find(|&(it, _)| it == id).unwrap().1\n+    }\n+}\n+\n+impl FileResolver for FileMap {\n+    fn file_stem(&self, id: FileId) -> String {\n+        self.path(id).file_stem().unwrap().to_string()\n+    }\n+    fn resolve(&self, id: FileId, rel: &RelativePath) -> Option<FileId> {\n+        let path = self.path(id).join(rel).normalize();\n+        let id = self.iter().find(|&(_, p)| path == p)?.0;\n+        Some(id)\n+    }\n+}"}, {"sha": "c3c904633d073383ecfb2658ba665476a4a71d03", "filename": "crates/ra_analysis/src/syntax_ptr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -12,6 +12,7 @@ salsa::query_group! {\n     pub(crate) trait SyntaxPtrDatabase: SyntaxDatabase {\n         fn resolve_syntax_ptr(ptr: SyntaxPtr) -> SyntaxNode {\n             type ResolveSyntaxPtrQuery;\n+            // Don't retain syntax trees in memory\n             storage volatile;\n         }\n     }\n@@ -83,6 +84,10 @@ impl LocalSyntaxPtr {\n                 .unwrap_or_else(|| panic!(\"can't resolve local ptr to SyntaxNode: {:?}\", self))\n         }\n     }\n+\n+    pub(crate) fn into_global(self, file_id: FileId) -> SyntaxPtr {\n+        SyntaxPtr { file_id, local: self}\n+    }\n }\n \n "}, {"sha": "f5683aec5b5cd36edc0e80dc84a6adf021c3fe00", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 6, "deletions": 50, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -5,62 +5,16 @@ extern crate relative_path;\n extern crate rustc_hash;\n extern crate test_utils;\n \n-use std::{\n-    sync::Arc,\n-};\n-\n use ra_syntax::TextRange;\n-use relative_path::{RelativePath, RelativePathBuf};\n use test_utils::{assert_eq_dbg, extract_offset};\n \n use ra_analysis::{\n-    AnalysisChange, Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, FnDescriptor,\n+    MockAnalysis,\n+    AnalysisChange, Analysis, CrateGraph, CrateId, FileId, FnDescriptor,\n };\n \n-#[derive(Debug)]\n-struct FileMap(Vec<(FileId, RelativePathBuf)>);\n-\n-impl FileMap {\n-    fn iter<'a>(&'a self) -> impl Iterator<Item = (FileId, &'a RelativePath)> + 'a {\n-        self.0\n-            .iter()\n-            .map(|(id, path)| (*id, path.as_relative_path()))\n-    }\n-\n-    fn path(&self, id: FileId) -> &RelativePath {\n-        self.iter().find(|&(it, _)| it == id).unwrap().1\n-    }\n-}\n-\n-impl FileResolver for FileMap {\n-    fn file_stem(&self, id: FileId) -> String {\n-        self.path(id).file_stem().unwrap().to_string()\n-    }\n-    fn resolve(&self, id: FileId, rel: &RelativePath) -> Option<FileId> {\n-        let path = self.path(id).join(rel).normalize();\n-        let id = self.iter().find(|&(_, p)| path == p)?.0;\n-        Some(id)\n-    }\n-}\n-\n-fn analysis_host(files: &[(&str, &str)]) -> AnalysisHost {\n-    let mut host = AnalysisHost::new();\n-    let mut file_map = Vec::new();\n-    let mut change = AnalysisChange::new();\n-    for (id, &(path, contents)) in files.iter().enumerate() {\n-        let file_id = FileId((id + 1) as u32);\n-        assert!(path.starts_with('/'));\n-        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        change.add_file(file_id, contents.to_string());\n-        file_map.push((file_id, path));\n-    }\n-    change.set_file_resolver(Arc::new(FileMap(file_map)));\n-    host.apply_change(change);\n-    host\n-}\n-\n fn analysis(files: &[(&str, &str)]) -> Analysis {\n-    analysis_host(files).analysis()\n+    MockAnalysis::with_files(files).analysis()\n }\n \n fn get_signature(text: &str) -> (FnDescriptor, Option<usize>) {\n@@ -125,7 +79,9 @@ fn test_resolve_parent_module() {\n \n #[test]\n fn test_resolve_crate_root() {\n-    let mut host = analysis_host(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]);\n+    let mut host = MockAnalysis::with_files(\n+        &[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]\n+    ).analysis_host();\n     let snap = host.analysis();\n     assert!(snap.crate_for(FileId(2)).unwrap().is_empty());\n "}, {"sha": "20c8546a471b878ff6eee3f3d344cd2f9539b8da", "filename": "crates/ra_editor/src/completion.rs", "status": "removed", "additions": 0, "deletions": 602, "changes": 602, "blob_url": "https://github.com/rust-lang/rust/blob/e60ef6260f49b2b0438f8649ca71034fbafef631/crates%2Fra_editor%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60ef6260f49b2b0438f8649ca71034fbafef631/crates%2Fra_editor%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fcompletion.rs?ref=e60ef6260f49b2b0438f8649ca71034fbafef631", "patch": "@@ -1,602 +0,0 @@\n-/// FIXME: move completion from ra_editor to ra_analysis\n-\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use ra_syntax::{\n-    algo::visit::{visitor, visitor_ctx, Visitor, VisitorCtx},\n-    ast::{self, AstChildren, LoopBodyOwner, ModuleItemOwner},\n-    AstNode, File,\n-    SyntaxKind::*,\n-    SyntaxNodeRef, TextUnit,\n-};\n-\n-use crate::{\n-    find_node_at_offset,\n-    scope::{FnScopes, ModuleScope},\n-    AtomEdit,\n-};\n-\n-#[derive(Debug)]\n-pub struct CompletionItem {\n-    /// What user sees in pop-up\n-    pub label: String,\n-    /// What string is used for filtering, defaults to label\n-    pub lookup: Option<String>,\n-    /// What is inserted, defaults to label\n-    pub snippet: Option<String>,\n-}\n-\n-pub fn scope_completion(file: &File, offset: TextUnit) -> Option<Vec<CompletionItem>> {\n-    // Insert a fake ident to get a valid parse tree\n-    let file = {\n-        let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n-        file.reparse(&edit)\n-    };\n-    let mut has_completions = false;\n-    let mut res = Vec::new();\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n-        has_completions = true;\n-        complete_name_ref(&file, name_ref, &mut res);\n-        // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n-        if is_node::<ast::Param>(name_ref.syntax()) {\n-            param_completions(name_ref.syntax(), &mut res);\n-        }\n-        let name_range = name_ref.syntax().range();\n-        let top_node = name_ref\n-            .syntax()\n-            .ancestors()\n-            .take_while(|it| it.range() == name_range)\n-            .last()\n-            .unwrap();\n-        match top_node.parent().map(|it| it.kind()) {\n-            Some(ROOT) | Some(ITEM_LIST) => complete_mod_item_snippets(&mut res),\n-            _ => (),\n-        }\n-    }\n-    if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n-        if is_node::<ast::Param>(name.syntax()) {\n-            has_completions = true;\n-            param_completions(name.syntax(), &mut res);\n-        }\n-    }\n-    if has_completions {\n-        Some(res)\n-    } else {\n-        None\n-    }\n-}\n-\n-pub fn complete_module_items(items: AstChildren<ast::ModuleItem>, this_item: Option<ast::NameRef>, acc: &mut Vec<CompletionItem>) {\n-    let scope = ModuleScope::new(items);\n-    acc.extend(\n-        scope\n-            .entries()\n-            .iter()\n-            .filter(|entry| Some(entry.syntax()) != this_item.map(|it| it.syntax()))\n-            .map(|entry| CompletionItem {\n-                label: entry.name().to_string(),\n-                lookup: None,\n-                snippet: None,\n-            }),\n-    );\n-}\n-\n-fn complete_name_ref(file: &File, name_ref: ast::NameRef, acc: &mut Vec<CompletionItem>) {\n-    if !is_node::<ast::Path>(name_ref.syntax()) {\n-        return;\n-    }\n-    let mut visited_fn = false;\n-    for node in name_ref.syntax().ancestors() {\n-        if let Some(items) = visitor()\n-            .visit::<ast::Root, _>(|it| Some(it.items()))\n-            .visit::<ast::Module, _>(|it| Some(it.item_list()?.items()))\n-            .accept(node)\n-        {\n-            if let Some(items) = items {\n-                complete_module_items(items, Some(name_ref), acc);\n-            }\n-            break;\n-        } else if !visited_fn {\n-            if let Some(fn_def) = ast::FnDef::cast(node) {\n-                visited_fn = true;\n-                complete_expr_keywords(&file, fn_def, name_ref, acc);\n-                complete_expr_snippets(acc);\n-                let scopes = FnScopes::new(fn_def);\n-                complete_fn(name_ref, &scopes, acc);\n-            }\n-        }\n-    }\n-}\n-\n-fn param_completions(ctx: SyntaxNodeRef, acc: &mut Vec<CompletionItem>) {\n-    let mut params = FxHashMap::default();\n-    for node in ctx.ancestors() {\n-        let _ = visitor_ctx(&mut params)\n-            .visit::<ast::Root, _>(process)\n-            .visit::<ast::ItemList, _>(process)\n-            .accept(node);\n-    }\n-    params\n-        .into_iter()\n-        .filter_map(|(label, (count, param))| {\n-            let lookup = param.pat()?.syntax().text().to_string();\n-            if count < 2 {\n-                None\n-            } else {\n-                Some((label, lookup))\n-            }\n-        })\n-        .for_each(|(label, lookup)| {\n-            acc.push(CompletionItem {\n-                label,\n-                lookup: Some(lookup),\n-                snippet: None,\n-            })\n-        });\n-\n-    fn process<'a, N: ast::FnDefOwner<'a>>(\n-        node: N,\n-        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n-    ) {\n-        node.functions()\n-            .filter_map(|it| it.param_list())\n-            .flat_map(|it| it.params())\n-            .for_each(|param| {\n-                let text = param.syntax().text().to_string();\n-                params.entry(text).or_insert((0, param)).0 += 1;\n-            })\n-    }\n-}\n-\n-fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n-    match node.ancestors().filter_map(N::cast).next() {\n-        None => false,\n-        Some(n) => n.syntax().range() == node.range(),\n-    }\n-}\n-\n-fn complete_expr_keywords(\n-    file: &File,\n-    fn_def: ast::FnDef,\n-    name_ref: ast::NameRef,\n-    acc: &mut Vec<CompletionItem>,\n-) {\n-    acc.push(keyword(\"if\", \"if $0 {}\"));\n-    acc.push(keyword(\"match\", \"match $0 {}\"));\n-    acc.push(keyword(\"while\", \"while $0 {}\"));\n-    acc.push(keyword(\"loop\", \"loop {$0}\"));\n-\n-    if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-        if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n-            if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                acc.push(keyword(\"else\", \"else {$0}\"));\n-                acc.push(keyword(\"else if\", \"else if $0 {}\"));\n-            }\n-        }\n-    }\n-    if is_in_loop_body(name_ref) {\n-        acc.push(keyword(\"continue\", \"continue\"));\n-        acc.push(keyword(\"break\", \"break\"));\n-    }\n-    acc.extend(complete_return(fn_def, name_ref));\n-}\n-\n-fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n-    for node in name_ref.syntax().ancestors() {\n-        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n-            break;\n-        }\n-        let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n-            .accept(node);\n-        if let Some(Some(body)) = loop_body {\n-            if name_ref.syntax().range().is_subrange(&body.syntax().range()) {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<CompletionItem> {\n-    // let is_last_in_block = name_ref.syntax().ancestors().filter_map(ast::Expr::cast)\n-    //     .next()\n-    //     .and_then(|it| it.syntax().parent())\n-    //     .and_then(ast::Block::cast)\n-    //     .is_some();\n-\n-    // if is_last_in_block {\n-    //     return None;\n-    // }\n-\n-    let is_stmt = match name_ref\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::ExprStmt::cast)\n-        .next()\n-    {\n-        None => false,\n-        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n-    };\n-    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n-        (true, true) => \"return $0;\",\n-        (true, false) => \"return;\",\n-        (false, true) => \"return $0\",\n-        (false, false) => \"return\",\n-    };\n-    Some(keyword(\"return\", snip))\n-}\n-\n-fn keyword(kw: &str, snip: &str) -> CompletionItem {\n-    CompletionItem {\n-        label: kw.to_string(),\n-        lookup: None,\n-        snippet: Some(snip.to_string()),\n-    }\n-}\n-\n-fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n-    acc.push(CompletionItem {\n-        label: \"pd\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n-    });\n-    acc.push(CompletionItem {\n-        label: \"ppd\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n-    });\n-}\n-\n-fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n-    acc.push(CompletionItem {\n-        label: \"tfn\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\".to_string()),\n-    });\n-    acc.push(CompletionItem {\n-        label: \"pub(crate)\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"pub(crate) $0\".to_string()),\n-    })\n-}\n-\n-fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n-    let mut shadowed = FxHashSet::default();\n-    acc.extend(\n-        scopes\n-            .scope_chain(name_ref.syntax())\n-            .flat_map(|scope| scopes.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .map(|entry| CompletionItem {\n-                label: entry.name().to_string(),\n-                lookup: None,\n-                snippet: None,\n-            }),\n-    );\n-    if scopes.self_param.is_some() {\n-        acc.push(CompletionItem {\n-            label: \"self\".to_string(),\n-            lookup: None,\n-            snippet: None,\n-        })\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::{assert_eq_dbg, extract_offset};\n-\n-    fn check_scope_completion(code: &str, expected_completions: &str) {\n-        let (off, code) = extract_offset(&code);\n-        let file = File::parse(&code);\n-        let completions = scope_completion(&file, off)\n-            .unwrap()\n-            .into_iter()\n-            .filter(|c| c.snippet.is_none())\n-            .collect::<Vec<_>>();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    fn check_snippet_completion(code: &str, expected_completions: &str) {\n-        let (off, code) = extract_offset(&code);\n-        let file = File::parse(&code);\n-        let completions = scope_completion(&file, off)\n-            .unwrap()\n-            .into_iter()\n-            .filter(|c| c.snippet.is_some())\n-            .collect::<Vec<_>>();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    #[test]\n-    fn test_completion_let_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux(x: i32) {\n-                let y = 92;\n-                1 + <|>;\n-                let z = ();\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"y\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_if_let_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux() {\n-                if let Some(x) = foo() {\n-                    let y = 92;\n-                };\n-                if let Some(a) = bar() {\n-                    let b = 62;\n-                    1 + <|>\n-                }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"b\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"a\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_for_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux() {\n-                for x in &[1, 2, 3] {\n-                    <|>\n-                }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            enum Baz {}\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"Baz\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_no_self_use() {\n-        check_scope_completion(\n-            r\"\n-            use foo<|>;\n-            \",\n-            r#\"[]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_nested() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            mod m {\n-                struct Bar;\n-                fn quux() { <|> }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_type() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            fn x() -> <|>\n-        \",\n-            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-               CompletionItem { label: \"x\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_shadowing() {\n-        check_scope_completion(\n-            r\"\n-            fn foo() -> {\n-                let bar = 92;\n-                {\n-                    let bar = 62;\n-                    <|>\n-                }\n-            }\n-        \",\n-            r#\"[CompletionItem { label: \"bar\", lookup: None, snippet: None },\n-               CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_self() {\n-        check_scope_completion(\n-            r\"\n-            impl S { fn foo(&self) { <|> } }\n-        \",\n-            r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_completion_kewords() {\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                <|>\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_else() {\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                if true {\n-                    ()\n-                } <|>\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"else\", lookup: None, snippet: Some(\"else {$0}\") },\n-                   CompletionItem { label: \"else if\", lookup: None, snippet: Some(\"else if $0 {}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_return_value() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                <|>\n-                92\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0;\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                <|>\n-                92\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return;\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_return_no_stmt() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                match () {\n-                    () => <|>\n-                }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_continue_break_completion() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                loop { <|> }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"continue\", lookup: None, snippet: Some(\"continue\") },\n-                   CompletionItem { label: \"break\", lookup: None, snippet: Some(\"break\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                loop { || { <|> } }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_last_param() {\n-        check_scope_completion(r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>) {}\n-        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_nth_param() {\n-        check_scope_completion(r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>, x: i32) {}\n-        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_trait_param() {\n-        check_scope_completion(r\"\n-            pub(crate) trait SourceRoot {\n-                pub fn contains(&self, file_id: FileId) -> bool;\n-                pub fn module_map(&self) -> &ModuleMap;\n-                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n-                pub fn syntax(&self, file<|>)\n-            }\n-        \", r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None },\n-               CompletionItem { label: \"SourceRoot\", lookup: None, snippet: None },\n-               CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_item_snippets() {\n-        // check_snippet_completion(r\"\n-        //     <|>\n-        //     \",\n-        //     r##\"[CompletionItem { label: \"tfn\", lookup: None, snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\") }]\"##,\n-        // );\n-        check_snippet_completion(r\"\n-            #[cfg(test)]\n-            mod tests {\n-                <|>\n-            }\n-            \",\n-            r##\"[CompletionItem { label: \"tfn\", lookup: None, snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\") },\n-                 CompletionItem { label: \"pub(crate)\", lookup: None, snippet: Some(\"pub(crate) $0\") }]\"##,\n-        );\n-    }\n-}"}, {"sha": "02a1b2d45c4c628a36be05217d9f1acb9a5cdc9f", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -8,20 +8,17 @@ extern crate superslice;\n extern crate test_utils as _test_utils;\n \n mod code_actions;\n-mod completion;\n mod edit;\n mod extend_selection;\n mod folding_ranges;\n mod line_index;\n-mod scope;\n mod symbols;\n #[cfg(test)]\n mod test_utils;\n mod typing;\n \n pub use self::{\n     code_actions::{add_derive, add_impl, flip_comma, introduce_variable, LocalEdit},\n-    completion::{scope_completion, complete_module_items, CompletionItem},\n     edit::{Edit, EditBuilder},\n     extend_selection::extend_selection,\n     folding_ranges::{folding_ranges, Fold, FoldKind},\n@@ -33,7 +30,7 @@ pub use ra_syntax::AtomEdit;\n use ra_syntax::{\n     algo::find_leaf_at_offset,\n     ast::{self, AstNode, NameOwner},\n-    File, SmolStr,\n+    File,\n     SyntaxKind::{self, *},\n     SyntaxNodeRef, TextRange, TextUnit,\n };\n@@ -151,15 +148,7 @@ pub fn find_node_at_offset<'a, N: AstNode<'a>>(\n     leaf.ancestors().filter_map(N::cast).next()\n }\n \n-pub fn resolve_local_name(\n-    name_ref: ast::NameRef,\n-) -> Option<(SmolStr, TextRange)> {\n-    let fn_def = name_ref.syntax().ancestors().find_map(ast::FnDef::cast)?;\n-    let scopes = scope::FnScopes::new(fn_def);\n-    let scope_entry = scope::resolve_local_name(name_ref, &scopes)?;\n-    let name = scope_entry.ast().name()?;\n-    Some((scope_entry.name(), name.syntax().range()))\n-}\n+\n \n #[cfg(test)]\n mod tests {"}, {"sha": "cc2d493926c20326d9118dcbe915189c48341b46", "filename": "crates/ra_editor/src/scope/mod.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e60ef6260f49b2b0438f8649ca71034fbafef631/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60ef6260f49b2b0438f8649ca71034fbafef631/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs?ref=e60ef6260f49b2b0438f8649ca71034fbafef631", "patch": "@@ -1,7 +0,0 @@\n-mod fn_scope;\n-mod mod_scope;\n-\n-pub use self::{\n-    fn_scope::{resolve_local_name, FnScopes},\n-    mod_scope::ModuleScope,\n-};"}, {"sha": "818749a1258f17ce8dcbfd2a495ac410f21222f3", "filename": "crates/ra_editor/src/scope/mod_scope.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e60ef6260f49b2b0438f8649ca71034fbafef631/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60ef6260f49b2b0438f8649ca71034fbafef631/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs?ref=e60ef6260f49b2b0438f8649ca71034fbafef631", "patch": "@@ -1,124 +0,0 @@\n-/// FIXME: this is now moved to ra_analysis::descriptors::module::scope.\n-///\n-/// Current copy will be deleted as soon as we move the rest of the completion\n-/// to the analyezer.\n-\n-\n-use ra_syntax::{\n-    ast::{self, AstChildren},\n-    AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n-};\n-\n-pub struct ModuleScope {\n-    entries: Vec<Entry>,\n-}\n-\n-pub struct Entry {\n-    node: SyntaxNode,\n-    kind: EntryKind,\n-}\n-\n-enum EntryKind {\n-    Item,\n-    Import,\n-}\n-\n-impl ModuleScope {\n-    pub fn new(items: AstChildren<ast::ModuleItem>) -> ModuleScope {\n-        let mut entries = Vec::new();\n-        for item in items {\n-            let entry = match item {\n-                ast::ModuleItem::StructDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::EnumDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::FnDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::ConstDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::StaticDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::TraitDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::TypeDef(item) => Entry::new_item(item),\n-                ast::ModuleItem::Module(item) => Entry::new_item(item),\n-                ast::ModuleItem::UseItem(item) => {\n-                    if let Some(tree) = item.use_tree() {\n-                        collect_imports(tree, &mut entries);\n-                    }\n-                    continue;\n-                }\n-                ast::ModuleItem::ExternCrateItem(_) | ast::ModuleItem::ImplItem(_) => continue,\n-            };\n-            entries.extend(entry)\n-        }\n-\n-        ModuleScope { entries }\n-    }\n-\n-    pub fn entries(&self) -> &[Entry] {\n-        self.entries.as_slice()\n-    }\n-}\n-\n-impl Entry {\n-    fn new_item<'a>(item: impl ast::NameOwner<'a>) -> Option<Entry> {\n-        let name = item.name()?;\n-        Some(Entry {\n-            node: name.syntax().owned(),\n-            kind: EntryKind::Item,\n-        })\n-    }\n-    fn new_import(path: ast::Path) -> Option<Entry> {\n-        let name_ref = path.segment()?.name_ref()?;\n-        Some(Entry {\n-            node: name_ref.syntax().owned(),\n-            kind: EntryKind::Import,\n-        })\n-    }\n-    pub fn name(&self) -> SmolStr {\n-        match self.kind {\n-            EntryKind::Item => ast::Name::cast(self.node.borrowed()).unwrap().text(),\n-            EntryKind::Import => ast::NameRef::cast(self.node.borrowed()).unwrap().text(),\n-        }\n-    }\n-    pub fn syntax(&self) -> SyntaxNodeRef {\n-        self.node.borrowed()\n-    }\n-}\n-\n-fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n-    if let Some(use_tree_list) = tree.use_tree_list() {\n-        return use_tree_list\n-            .use_trees()\n-            .for_each(|it| collect_imports(it, acc));\n-    }\n-    if let Some(path) = tree.path() {\n-        acc.extend(Entry::new_import(path));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ra_syntax::{ast::ModuleItemOwner, File};\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let file = File::parse(&code);\n-        let scope = ModuleScope::new(file.ast().items());\n-        let actual = scope.entries.iter().map(|it| it.name()).collect::<Vec<_>>();\n-        assert_eq!(expected, actual.as_slice());\n-    }\n-\n-    #[test]\n-    fn test_module_scope() {\n-        do_check(\n-            \"\n-            struct Foo;\n-            enum Bar {}\n-            mod baz {}\n-            fn quux() {}\n-            use x::{\n-                y::z,\n-                t,\n-            };\n-            type T = ();\n-        \",\n-            &[\"Foo\", \"Bar\", \"baz\", \"quux\", \"z\", \"t\", \"T\"],\n-        )\n-    }\n-}"}, {"sha": "d0cd060d301181d2bf012dc04030d2dbb7b72021", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -15,7 +15,7 @@ use crate::{\n pub struct ArgListNode(SyntaxNode);\n \n impl ArgListNode {\n-    pub fn new(&self, ast: ArgList) -> ArgListNode {\n+    pub fn new(ast: ArgList) -> ArgListNode {\n         let syntax = ast.syntax().owned();\n         ArgListNode(syntax)\n     }\n@@ -50,7 +50,7 @@ impl<'a> ArgList<'a> {\n pub struct ArrayExprNode(SyntaxNode);\n \n impl ArrayExprNode {\n-    pub fn new(&self, ast: ArrayExpr) -> ArrayExprNode {\n+    pub fn new(ast: ArrayExpr) -> ArrayExprNode {\n         let syntax = ast.syntax().owned();\n         ArrayExprNode(syntax)\n     }\n@@ -81,7 +81,7 @@ impl<'a> ArrayExpr<'a> {}\n pub struct ArrayTypeNode(SyntaxNode);\n \n impl ArrayTypeNode {\n-    pub fn new(&self, ast: ArrayType) -> ArrayTypeNode {\n+    pub fn new(ast: ArrayType) -> ArrayTypeNode {\n         let syntax = ast.syntax().owned();\n         ArrayTypeNode(syntax)\n     }\n@@ -112,7 +112,7 @@ impl<'a> ArrayType<'a> {}\n pub struct AttrNode(SyntaxNode);\n \n impl AttrNode {\n-    pub fn new(&self, ast: Attr) -> AttrNode {\n+    pub fn new(ast: Attr) -> AttrNode {\n         let syntax = ast.syntax().owned();\n         AttrNode(syntax)\n     }\n@@ -147,7 +147,7 @@ impl<'a> Attr<'a> {\n pub struct BinExprNode(SyntaxNode);\n \n impl BinExprNode {\n-    pub fn new(&self, ast: BinExpr) -> BinExprNode {\n+    pub fn new(ast: BinExpr) -> BinExprNode {\n         let syntax = ast.syntax().owned();\n         BinExprNode(syntax)\n     }\n@@ -178,7 +178,7 @@ impl<'a> BinExpr<'a> {}\n pub struct BindPatNode(SyntaxNode);\n \n impl BindPatNode {\n-    pub fn new(&self, ast: BindPat) -> BindPatNode {\n+    pub fn new(ast: BindPat) -> BindPatNode {\n         let syntax = ast.syntax().owned();\n         BindPatNode(syntax)\n     }\n@@ -210,7 +210,7 @@ impl<'a> BindPat<'a> {}\n pub struct BlockNode(SyntaxNode);\n \n impl BlockNode {\n-    pub fn new(&self, ast: Block) -> BlockNode {\n+    pub fn new(ast: Block) -> BlockNode {\n         let syntax = ast.syntax().owned();\n         BlockNode(syntax)\n     }\n@@ -249,7 +249,7 @@ impl<'a> Block<'a> {\n pub struct BlockExprNode(SyntaxNode);\n \n impl BlockExprNode {\n-    pub fn new(&self, ast: BlockExpr) -> BlockExprNode {\n+    pub fn new(ast: BlockExpr) -> BlockExprNode {\n         let syntax = ast.syntax().owned();\n         BlockExprNode(syntax)\n     }\n@@ -284,7 +284,7 @@ impl<'a> BlockExpr<'a> {\n pub struct BreakExprNode(SyntaxNode);\n \n impl BreakExprNode {\n-    pub fn new(&self, ast: BreakExpr) -> BreakExprNode {\n+    pub fn new(ast: BreakExpr) -> BreakExprNode {\n         let syntax = ast.syntax().owned();\n         BreakExprNode(syntax)\n     }\n@@ -315,7 +315,7 @@ impl<'a> BreakExpr<'a> {}\n pub struct CallExprNode(SyntaxNode);\n \n impl CallExprNode {\n-    pub fn new(&self, ast: CallExpr) -> CallExprNode {\n+    pub fn new(ast: CallExpr) -> CallExprNode {\n         let syntax = ast.syntax().owned();\n         CallExprNode(syntax)\n     }\n@@ -351,7 +351,7 @@ impl<'a> CallExpr<'a> {\n pub struct CastExprNode(SyntaxNode);\n \n impl CastExprNode {\n-    pub fn new(&self, ast: CastExpr) -> CastExprNode {\n+    pub fn new(ast: CastExpr) -> CastExprNode {\n         let syntax = ast.syntax().owned();\n         CastExprNode(syntax)\n     }\n@@ -382,7 +382,7 @@ impl<'a> CastExpr<'a> {}\n pub struct CommentNode(SyntaxNode);\n \n impl CommentNode {\n-    pub fn new(&self, ast: Comment) -> CommentNode {\n+    pub fn new(ast: Comment) -> CommentNode {\n         let syntax = ast.syntax().owned();\n         CommentNode(syntax)\n     }\n@@ -413,7 +413,7 @@ impl<'a> Comment<'a> {}\n pub struct ConditionNode(SyntaxNode);\n \n impl ConditionNode {\n-    pub fn new(&self, ast: Condition) -> ConditionNode {\n+    pub fn new(ast: Condition) -> ConditionNode {\n         let syntax = ast.syntax().owned();\n         ConditionNode(syntax)\n     }\n@@ -452,7 +452,7 @@ impl<'a> Condition<'a> {\n pub struct ConstDefNode(SyntaxNode);\n \n impl ConstDefNode {\n-    pub fn new(&self, ast: ConstDef) -> ConstDefNode {\n+    pub fn new(ast: ConstDef) -> ConstDefNode {\n         let syntax = ast.syntax().owned();\n         ConstDefNode(syntax)\n     }\n@@ -486,7 +486,7 @@ impl<'a> ConstDef<'a> {}\n pub struct ContinueExprNode(SyntaxNode);\n \n impl ContinueExprNode {\n-    pub fn new(&self, ast: ContinueExpr) -> ContinueExprNode {\n+    pub fn new(ast: ContinueExpr) -> ContinueExprNode {\n         let syntax = ast.syntax().owned();\n         ContinueExprNode(syntax)\n     }\n@@ -517,7 +517,7 @@ impl<'a> ContinueExpr<'a> {}\n pub struct DynTraitTypeNode(SyntaxNode);\n \n impl DynTraitTypeNode {\n-    pub fn new(&self, ast: DynTraitType) -> DynTraitTypeNode {\n+    pub fn new(ast: DynTraitType) -> DynTraitTypeNode {\n         let syntax = ast.syntax().owned();\n         DynTraitTypeNode(syntax)\n     }\n@@ -548,7 +548,7 @@ impl<'a> DynTraitType<'a> {}\n pub struct EnumDefNode(SyntaxNode);\n \n impl EnumDefNode {\n-    pub fn new(&self, ast: EnumDef) -> EnumDefNode {\n+    pub fn new(ast: EnumDef) -> EnumDefNode {\n         let syntax = ast.syntax().owned();\n         EnumDefNode(syntax)\n     }\n@@ -582,7 +582,7 @@ impl<'a> EnumDef<'a> {}\n pub struct ExprNode(SyntaxNode);\n \n impl ExprNode {\n-    pub fn new(&self, ast: Expr) -> ExprNode {\n+    pub fn new(ast: Expr) -> ExprNode {\n         let syntax = ast.syntax().owned();\n         ExprNode(syntax)\n     }\n@@ -710,7 +710,7 @@ impl<'a> Expr<'a> {}\n pub struct ExprStmtNode(SyntaxNode);\n \n impl ExprStmtNode {\n-    pub fn new(&self, ast: ExprStmt) -> ExprStmtNode {\n+    pub fn new(ast: ExprStmt) -> ExprStmtNode {\n         let syntax = ast.syntax().owned();\n         ExprStmtNode(syntax)\n     }\n@@ -745,7 +745,7 @@ impl<'a> ExprStmt<'a> {\n pub struct ExternCrateItemNode(SyntaxNode);\n \n impl ExternCrateItemNode {\n-    pub fn new(&self, ast: ExternCrateItem) -> ExternCrateItemNode {\n+    pub fn new(ast: ExternCrateItem) -> ExternCrateItemNode {\n         let syntax = ast.syntax().owned();\n         ExternCrateItemNode(syntax)\n     }\n@@ -776,7 +776,7 @@ impl<'a> ExternCrateItem<'a> {}\n pub struct FieldExprNode(SyntaxNode);\n \n impl FieldExprNode {\n-    pub fn new(&self, ast: FieldExpr) -> FieldExprNode {\n+    pub fn new(ast: FieldExpr) -> FieldExprNode {\n         let syntax = ast.syntax().owned();\n         FieldExprNode(syntax)\n     }\n@@ -807,7 +807,7 @@ impl<'a> FieldExpr<'a> {}\n pub struct FieldPatListNode(SyntaxNode);\n \n impl FieldPatListNode {\n-    pub fn new(&self, ast: FieldPatList) -> FieldPatListNode {\n+    pub fn new(ast: FieldPatList) -> FieldPatListNode {\n         let syntax = ast.syntax().owned();\n         FieldPatListNode(syntax)\n     }\n@@ -838,7 +838,7 @@ impl<'a> FieldPatList<'a> {}\n pub struct FnDefNode(SyntaxNode);\n \n impl FnDefNode {\n-    pub fn new(&self, ast: FnDef) -> FnDefNode {\n+    pub fn new(ast: FnDef) -> FnDefNode {\n         let syntax = ast.syntax().owned();\n         FnDefNode(syntax)\n     }\n@@ -884,7 +884,7 @@ impl<'a> FnDef<'a> {\n pub struct FnPointerTypeNode(SyntaxNode);\n \n impl FnPointerTypeNode {\n-    pub fn new(&self, ast: FnPointerType) -> FnPointerTypeNode {\n+    pub fn new(ast: FnPointerType) -> FnPointerTypeNode {\n         let syntax = ast.syntax().owned();\n         FnPointerTypeNode(syntax)\n     }\n@@ -915,7 +915,7 @@ impl<'a> FnPointerType<'a> {}\n pub struct ForExprNode(SyntaxNode);\n \n impl ForExprNode {\n-    pub fn new(&self, ast: ForExpr) -> ForExprNode {\n+    pub fn new(ast: ForExpr) -> ForExprNode {\n         let syntax = ast.syntax().owned();\n         ForExprNode(syntax)\n     }\n@@ -955,7 +955,7 @@ impl<'a> ForExpr<'a> {\n pub struct ForTypeNode(SyntaxNode);\n \n impl ForTypeNode {\n-    pub fn new(&self, ast: ForType) -> ForTypeNode {\n+    pub fn new(ast: ForType) -> ForTypeNode {\n         let syntax = ast.syntax().owned();\n         ForTypeNode(syntax)\n     }\n@@ -986,7 +986,7 @@ impl<'a> ForType<'a> {}\n pub struct IfExprNode(SyntaxNode);\n \n impl IfExprNode {\n-    pub fn new(&self, ast: IfExpr) -> IfExprNode {\n+    pub fn new(ast: IfExpr) -> IfExprNode {\n         let syntax = ast.syntax().owned();\n         IfExprNode(syntax)\n     }\n@@ -1021,7 +1021,7 @@ impl<'a> IfExpr<'a> {\n pub struct ImplItemNode(SyntaxNode);\n \n impl ImplItemNode {\n-    pub fn new(&self, ast: ImplItem) -> ImplItemNode {\n+    pub fn new(ast: ImplItem) -> ImplItemNode {\n         let syntax = ast.syntax().owned();\n         ImplItemNode(syntax)\n     }\n@@ -1052,7 +1052,7 @@ impl<'a> ImplItem<'a> {}\n pub struct ImplTraitTypeNode(SyntaxNode);\n \n impl ImplTraitTypeNode {\n-    pub fn new(&self, ast: ImplTraitType) -> ImplTraitTypeNode {\n+    pub fn new(ast: ImplTraitType) -> ImplTraitTypeNode {\n         let syntax = ast.syntax().owned();\n         ImplTraitTypeNode(syntax)\n     }\n@@ -1083,7 +1083,7 @@ impl<'a> ImplTraitType<'a> {}\n pub struct IndexExprNode(SyntaxNode);\n \n impl IndexExprNode {\n-    pub fn new(&self, ast: IndexExpr) -> IndexExprNode {\n+    pub fn new(ast: IndexExpr) -> IndexExprNode {\n         let syntax = ast.syntax().owned();\n         IndexExprNode(syntax)\n     }\n@@ -1114,7 +1114,7 @@ impl<'a> IndexExpr<'a> {}\n pub struct ItemListNode(SyntaxNode);\n \n impl ItemListNode {\n-    pub fn new(&self, ast: ItemList) -> ItemListNode {\n+    pub fn new(ast: ItemList) -> ItemListNode {\n         let syntax = ast.syntax().owned();\n         ItemListNode(syntax)\n     }\n@@ -1147,7 +1147,7 @@ impl<'a> ItemList<'a> {}\n pub struct LabelNode(SyntaxNode);\n \n impl LabelNode {\n-    pub fn new(&self, ast: Label) -> LabelNode {\n+    pub fn new(ast: Label) -> LabelNode {\n         let syntax = ast.syntax().owned();\n         LabelNode(syntax)\n     }\n@@ -1178,7 +1178,7 @@ impl<'a> Label<'a> {}\n pub struct LambdaExprNode(SyntaxNode);\n \n impl LambdaExprNode {\n-    pub fn new(&self, ast: LambdaExpr) -> LambdaExprNode {\n+    pub fn new(ast: LambdaExpr) -> LambdaExprNode {\n         let syntax = ast.syntax().owned();\n         LambdaExprNode(syntax)\n     }\n@@ -1217,7 +1217,7 @@ impl<'a> LambdaExpr<'a> {\n pub struct LetStmtNode(SyntaxNode);\n \n impl LetStmtNode {\n-    pub fn new(&self, ast: LetStmt) -> LetStmtNode {\n+    pub fn new(ast: LetStmt) -> LetStmtNode {\n         let syntax = ast.syntax().owned();\n         LetStmtNode(syntax)\n     }\n@@ -1256,7 +1256,7 @@ impl<'a> LetStmt<'a> {\n pub struct LifetimeNode(SyntaxNode);\n \n impl LifetimeNode {\n-    pub fn new(&self, ast: Lifetime) -> LifetimeNode {\n+    pub fn new(ast: Lifetime) -> LifetimeNode {\n         let syntax = ast.syntax().owned();\n         LifetimeNode(syntax)\n     }\n@@ -1287,7 +1287,7 @@ impl<'a> Lifetime<'a> {}\n pub struct LifetimeParamNode(SyntaxNode);\n \n impl LifetimeParamNode {\n-    pub fn new(&self, ast: LifetimeParam) -> LifetimeParamNode {\n+    pub fn new(ast: LifetimeParam) -> LifetimeParamNode {\n         let syntax = ast.syntax().owned();\n         LifetimeParamNode(syntax)\n     }\n@@ -1322,7 +1322,7 @@ impl<'a> LifetimeParam<'a> {\n pub struct LiteralNode(SyntaxNode);\n \n impl LiteralNode {\n-    pub fn new(&self, ast: Literal) -> LiteralNode {\n+    pub fn new(ast: Literal) -> LiteralNode {\n         let syntax = ast.syntax().owned();\n         LiteralNode(syntax)\n     }\n@@ -1353,7 +1353,7 @@ impl<'a> Literal<'a> {}\n pub struct LoopExprNode(SyntaxNode);\n \n impl LoopExprNode {\n-    pub fn new(&self, ast: LoopExpr) -> LoopExprNode {\n+    pub fn new(ast: LoopExpr) -> LoopExprNode {\n         let syntax = ast.syntax().owned();\n         LoopExprNode(syntax)\n     }\n@@ -1385,7 +1385,7 @@ impl<'a> LoopExpr<'a> {}\n pub struct MatchArmNode(SyntaxNode);\n \n impl MatchArmNode {\n-    pub fn new(&self, ast: MatchArm) -> MatchArmNode {\n+    pub fn new(ast: MatchArm) -> MatchArmNode {\n         let syntax = ast.syntax().owned();\n         MatchArmNode(syntax)\n     }\n@@ -1428,7 +1428,7 @@ impl<'a> MatchArm<'a> {\n pub struct MatchArmListNode(SyntaxNode);\n \n impl MatchArmListNode {\n-    pub fn new(&self, ast: MatchArmList) -> MatchArmListNode {\n+    pub fn new(ast: MatchArmList) -> MatchArmListNode {\n         let syntax = ast.syntax().owned();\n         MatchArmListNode(syntax)\n     }\n@@ -1463,7 +1463,7 @@ impl<'a> MatchArmList<'a> {\n pub struct MatchExprNode(SyntaxNode);\n \n impl MatchExprNode {\n-    pub fn new(&self, ast: MatchExpr) -> MatchExprNode {\n+    pub fn new(ast: MatchExpr) -> MatchExprNode {\n         let syntax = ast.syntax().owned();\n         MatchExprNode(syntax)\n     }\n@@ -1502,7 +1502,7 @@ impl<'a> MatchExpr<'a> {\n pub struct MatchGuardNode(SyntaxNode);\n \n impl MatchGuardNode {\n-    pub fn new(&self, ast: MatchGuard) -> MatchGuardNode {\n+    pub fn new(ast: MatchGuard) -> MatchGuardNode {\n         let syntax = ast.syntax().owned();\n         MatchGuardNode(syntax)\n     }\n@@ -1533,7 +1533,7 @@ impl<'a> MatchGuard<'a> {}\n pub struct MethodCallExprNode(SyntaxNode);\n \n impl MethodCallExprNode {\n-    pub fn new(&self, ast: MethodCallExpr) -> MethodCallExprNode {\n+    pub fn new(ast: MethodCallExpr) -> MethodCallExprNode {\n         let syntax = ast.syntax().owned();\n         MethodCallExprNode(syntax)\n     }\n@@ -1569,7 +1569,7 @@ impl<'a> MethodCallExpr<'a> {\n pub struct ModuleNode(SyntaxNode);\n \n impl ModuleNode {\n-    pub fn new(&self, ast: Module) -> ModuleNode {\n+    pub fn new(ast: Module) -> ModuleNode {\n         let syntax = ast.syntax().owned();\n         ModuleNode(syntax)\n     }\n@@ -1606,7 +1606,7 @@ impl<'a> Module<'a> {\n pub struct ModuleItemNode(SyntaxNode);\n \n impl ModuleItemNode {\n-    pub fn new(&self, ast: ModuleItem) -> ModuleItemNode {\n+    pub fn new(ast: ModuleItem) -> ModuleItemNode {\n         let syntax = ast.syntax().owned();\n         ModuleItemNode(syntax)\n     }\n@@ -1671,7 +1671,7 @@ impl<'a> ModuleItem<'a> {}\n pub struct NameNode(SyntaxNode);\n \n impl NameNode {\n-    pub fn new(&self, ast: Name) -> NameNode {\n+    pub fn new(ast: Name) -> NameNode {\n         let syntax = ast.syntax().owned();\n         NameNode(syntax)\n     }\n@@ -1702,7 +1702,7 @@ impl<'a> Name<'a> {}\n pub struct NameRefNode(SyntaxNode);\n \n impl NameRefNode {\n-    pub fn new(&self, ast: NameRef) -> NameRefNode {\n+    pub fn new(ast: NameRef) -> NameRefNode {\n         let syntax = ast.syntax().owned();\n         NameRefNode(syntax)\n     }\n@@ -1733,7 +1733,7 @@ impl<'a> NameRef<'a> {}\n pub struct NamedFieldNode(SyntaxNode);\n \n impl NamedFieldNode {\n-    pub fn new(&self, ast: NamedField) -> NamedFieldNode {\n+    pub fn new(ast: NamedField) -> NamedFieldNode {\n         let syntax = ast.syntax().owned();\n         NamedFieldNode(syntax)\n     }\n@@ -1764,7 +1764,7 @@ impl<'a> NamedField<'a> {}\n pub struct NamedFieldDefNode(SyntaxNode);\n \n impl NamedFieldDefNode {\n-    pub fn new(&self, ast: NamedFieldDef) -> NamedFieldDefNode {\n+    pub fn new(ast: NamedFieldDef) -> NamedFieldDefNode {\n         let syntax = ast.syntax().owned();\n         NamedFieldDefNode(syntax)\n     }\n@@ -1797,7 +1797,7 @@ impl<'a> NamedFieldDef<'a> {}\n pub struct NamedFieldListNode(SyntaxNode);\n \n impl NamedFieldListNode {\n-    pub fn new(&self, ast: NamedFieldList) -> NamedFieldListNode {\n+    pub fn new(ast: NamedFieldList) -> NamedFieldListNode {\n         let syntax = ast.syntax().owned();\n         NamedFieldListNode(syntax)\n     }\n@@ -1828,7 +1828,7 @@ impl<'a> NamedFieldList<'a> {}\n pub struct NeverTypeNode(SyntaxNode);\n \n impl NeverTypeNode {\n-    pub fn new(&self, ast: NeverType) -> NeverTypeNode {\n+    pub fn new(ast: NeverType) -> NeverTypeNode {\n         let syntax = ast.syntax().owned();\n         NeverTypeNode(syntax)\n     }\n@@ -1859,7 +1859,7 @@ impl<'a> NeverType<'a> {}\n pub struct NominalDefNode(SyntaxNode);\n \n impl NominalDefNode {\n-    pub fn new(&self, ast: NominalDef) -> NominalDefNode {\n+    pub fn new(ast: NominalDef) -> NominalDefNode {\n         let syntax = ast.syntax().owned();\n         NominalDefNode(syntax)\n     }\n@@ -1900,7 +1900,7 @@ impl<'a> NominalDef<'a> {}\n pub struct ParamNode(SyntaxNode);\n \n impl ParamNode {\n-    pub fn new(&self, ast: Param) -> ParamNode {\n+    pub fn new(ast: Param) -> ParamNode {\n         let syntax = ast.syntax().owned();\n         ParamNode(syntax)\n     }\n@@ -1935,7 +1935,7 @@ impl<'a> Param<'a> {\n pub struct ParamListNode(SyntaxNode);\n \n impl ParamListNode {\n-    pub fn new(&self, ast: ParamList) -> ParamListNode {\n+    pub fn new(ast: ParamList) -> ParamListNode {\n         let syntax = ast.syntax().owned();\n         ParamListNode(syntax)\n     }\n@@ -1974,7 +1974,7 @@ impl<'a> ParamList<'a> {\n pub struct ParenExprNode(SyntaxNode);\n \n impl ParenExprNode {\n-    pub fn new(&self, ast: ParenExpr) -> ParenExprNode {\n+    pub fn new(ast: ParenExpr) -> ParenExprNode {\n         let syntax = ast.syntax().owned();\n         ParenExprNode(syntax)\n     }\n@@ -2005,7 +2005,7 @@ impl<'a> ParenExpr<'a> {}\n pub struct ParenTypeNode(SyntaxNode);\n \n impl ParenTypeNode {\n-    pub fn new(&self, ast: ParenType) -> ParenTypeNode {\n+    pub fn new(ast: ParenType) -> ParenTypeNode {\n         let syntax = ast.syntax().owned();\n         ParenTypeNode(syntax)\n     }\n@@ -2036,7 +2036,7 @@ impl<'a> ParenType<'a> {}\n pub struct PatNode(SyntaxNode);\n \n impl PatNode {\n-    pub fn new(&self, ast: Pat) -> PatNode {\n+    pub fn new(ast: Pat) -> PatNode {\n         let syntax = ast.syntax().owned();\n         PatNode(syntax)\n     }\n@@ -2098,7 +2098,7 @@ impl<'a> Pat<'a> {}\n pub struct PathNode(SyntaxNode);\n \n impl PathNode {\n-    pub fn new(&self, ast: Path) -> PathNode {\n+    pub fn new(ast: Path) -> PathNode {\n         let syntax = ast.syntax().owned();\n         PathNode(syntax)\n     }\n@@ -2137,7 +2137,7 @@ impl<'a> Path<'a> {\n pub struct PathExprNode(SyntaxNode);\n \n impl PathExprNode {\n-    pub fn new(&self, ast: PathExpr) -> PathExprNode {\n+    pub fn new(ast: PathExpr) -> PathExprNode {\n         let syntax = ast.syntax().owned();\n         PathExprNode(syntax)\n     }\n@@ -2172,7 +2172,7 @@ impl<'a> PathExpr<'a> {\n pub struct PathPatNode(SyntaxNode);\n \n impl PathPatNode {\n-    pub fn new(&self, ast: PathPat) -> PathPatNode {\n+    pub fn new(ast: PathPat) -> PathPatNode {\n         let syntax = ast.syntax().owned();\n         PathPatNode(syntax)\n     }\n@@ -2203,7 +2203,7 @@ impl<'a> PathPat<'a> {}\n pub struct PathSegmentNode(SyntaxNode);\n \n impl PathSegmentNode {\n-    pub fn new(&self, ast: PathSegment) -> PathSegmentNode {\n+    pub fn new(ast: PathSegment) -> PathSegmentNode {\n         let syntax = ast.syntax().owned();\n         PathSegmentNode(syntax)\n     }\n@@ -2238,7 +2238,7 @@ impl<'a> PathSegment<'a> {\n pub struct PathTypeNode(SyntaxNode);\n \n impl PathTypeNode {\n-    pub fn new(&self, ast: PathType) -> PathTypeNode {\n+    pub fn new(ast: PathType) -> PathTypeNode {\n         let syntax = ast.syntax().owned();\n         PathTypeNode(syntax)\n     }\n@@ -2269,7 +2269,7 @@ impl<'a> PathType<'a> {}\n pub struct PlaceholderPatNode(SyntaxNode);\n \n impl PlaceholderPatNode {\n-    pub fn new(&self, ast: PlaceholderPat) -> PlaceholderPatNode {\n+    pub fn new(ast: PlaceholderPat) -> PlaceholderPatNode {\n         let syntax = ast.syntax().owned();\n         PlaceholderPatNode(syntax)\n     }\n@@ -2300,7 +2300,7 @@ impl<'a> PlaceholderPat<'a> {}\n pub struct PlaceholderTypeNode(SyntaxNode);\n \n impl PlaceholderTypeNode {\n-    pub fn new(&self, ast: PlaceholderType) -> PlaceholderTypeNode {\n+    pub fn new(ast: PlaceholderType) -> PlaceholderTypeNode {\n         let syntax = ast.syntax().owned();\n         PlaceholderTypeNode(syntax)\n     }\n@@ -2331,7 +2331,7 @@ impl<'a> PlaceholderType<'a> {}\n pub struct PointerTypeNode(SyntaxNode);\n \n impl PointerTypeNode {\n-    pub fn new(&self, ast: PointerType) -> PointerTypeNode {\n+    pub fn new(ast: PointerType) -> PointerTypeNode {\n         let syntax = ast.syntax().owned();\n         PointerTypeNode(syntax)\n     }\n@@ -2362,7 +2362,7 @@ impl<'a> PointerType<'a> {}\n pub struct PrefixExprNode(SyntaxNode);\n \n impl PrefixExprNode {\n-    pub fn new(&self, ast: PrefixExpr) -> PrefixExprNode {\n+    pub fn new(ast: PrefixExpr) -> PrefixExprNode {\n         let syntax = ast.syntax().owned();\n         PrefixExprNode(syntax)\n     }\n@@ -2393,7 +2393,7 @@ impl<'a> PrefixExpr<'a> {}\n pub struct RangeExprNode(SyntaxNode);\n \n impl RangeExprNode {\n-    pub fn new(&self, ast: RangeExpr) -> RangeExprNode {\n+    pub fn new(ast: RangeExpr) -> RangeExprNode {\n         let syntax = ast.syntax().owned();\n         RangeExprNode(syntax)\n     }\n@@ -2424,7 +2424,7 @@ impl<'a> RangeExpr<'a> {}\n pub struct RangePatNode(SyntaxNode);\n \n impl RangePatNode {\n-    pub fn new(&self, ast: RangePat) -> RangePatNode {\n+    pub fn new(ast: RangePat) -> RangePatNode {\n         let syntax = ast.syntax().owned();\n         RangePatNode(syntax)\n     }\n@@ -2455,7 +2455,7 @@ impl<'a> RangePat<'a> {}\n pub struct RefExprNode(SyntaxNode);\n \n impl RefExprNode {\n-    pub fn new(&self, ast: RefExpr) -> RefExprNode {\n+    pub fn new(ast: RefExpr) -> RefExprNode {\n         let syntax = ast.syntax().owned();\n         RefExprNode(syntax)\n     }\n@@ -2486,7 +2486,7 @@ impl<'a> RefExpr<'a> {}\n pub struct RefPatNode(SyntaxNode);\n \n impl RefPatNode {\n-    pub fn new(&self, ast: RefPat) -> RefPatNode {\n+    pub fn new(ast: RefPat) -> RefPatNode {\n         let syntax = ast.syntax().owned();\n         RefPatNode(syntax)\n     }\n@@ -2517,7 +2517,7 @@ impl<'a> RefPat<'a> {}\n pub struct ReferenceTypeNode(SyntaxNode);\n \n impl ReferenceTypeNode {\n-    pub fn new(&self, ast: ReferenceType) -> ReferenceTypeNode {\n+    pub fn new(ast: ReferenceType) -> ReferenceTypeNode {\n         let syntax = ast.syntax().owned();\n         ReferenceTypeNode(syntax)\n     }\n@@ -2548,7 +2548,7 @@ impl<'a> ReferenceType<'a> {}\n pub struct RetTypeNode(SyntaxNode);\n \n impl RetTypeNode {\n-    pub fn new(&self, ast: RetType) -> RetTypeNode {\n+    pub fn new(ast: RetType) -> RetTypeNode {\n         let syntax = ast.syntax().owned();\n         RetTypeNode(syntax)\n     }\n@@ -2579,7 +2579,7 @@ impl<'a> RetType<'a> {}\n pub struct ReturnExprNode(SyntaxNode);\n \n impl ReturnExprNode {\n-    pub fn new(&self, ast: ReturnExpr) -> ReturnExprNode {\n+    pub fn new(ast: ReturnExpr) -> ReturnExprNode {\n         let syntax = ast.syntax().owned();\n         ReturnExprNode(syntax)\n     }\n@@ -2610,7 +2610,7 @@ impl<'a> ReturnExpr<'a> {}\n pub struct RootNode(SyntaxNode);\n \n impl RootNode {\n-    pub fn new(&self, ast: Root) -> RootNode {\n+    pub fn new(ast: Root) -> RootNode {\n         let syntax = ast.syntax().owned();\n         RootNode(syntax)\n     }\n@@ -2647,7 +2647,7 @@ impl<'a> Root<'a> {\n pub struct SelfParamNode(SyntaxNode);\n \n impl SelfParamNode {\n-    pub fn new(&self, ast: SelfParam) -> SelfParamNode {\n+    pub fn new(ast: SelfParam) -> SelfParamNode {\n         let syntax = ast.syntax().owned();\n         SelfParamNode(syntax)\n     }\n@@ -2678,7 +2678,7 @@ impl<'a> SelfParam<'a> {}\n pub struct SlicePatNode(SyntaxNode);\n \n impl SlicePatNode {\n-    pub fn new(&self, ast: SlicePat) -> SlicePatNode {\n+    pub fn new(ast: SlicePat) -> SlicePatNode {\n         let syntax = ast.syntax().owned();\n         SlicePatNode(syntax)\n     }\n@@ -2709,7 +2709,7 @@ impl<'a> SlicePat<'a> {}\n pub struct SliceTypeNode(SyntaxNode);\n \n impl SliceTypeNode {\n-    pub fn new(&self, ast: SliceType) -> SliceTypeNode {\n+    pub fn new(ast: SliceType) -> SliceTypeNode {\n         let syntax = ast.syntax().owned();\n         SliceTypeNode(syntax)\n     }\n@@ -2740,7 +2740,7 @@ impl<'a> SliceType<'a> {}\n pub struct StaticDefNode(SyntaxNode);\n \n impl StaticDefNode {\n-    pub fn new(&self, ast: StaticDef) -> StaticDefNode {\n+    pub fn new(ast: StaticDef) -> StaticDefNode {\n         let syntax = ast.syntax().owned();\n         StaticDefNode(syntax)\n     }\n@@ -2774,7 +2774,7 @@ impl<'a> StaticDef<'a> {}\n pub struct StmtNode(SyntaxNode);\n \n impl StmtNode {\n-    pub fn new(&self, ast: Stmt) -> StmtNode {\n+    pub fn new(ast: Stmt) -> StmtNode {\n         let syntax = ast.syntax().owned();\n         StmtNode(syntax)\n     }\n@@ -2812,7 +2812,7 @@ impl<'a> Stmt<'a> {}\n pub struct StructDefNode(SyntaxNode);\n \n impl StructDefNode {\n-    pub fn new(&self, ast: StructDef) -> StructDefNode {\n+    pub fn new(ast: StructDef) -> StructDefNode {\n         let syntax = ast.syntax().owned();\n         StructDefNode(syntax)\n     }\n@@ -2850,7 +2850,7 @@ impl<'a> StructDef<'a> {\n pub struct StructLitNode(SyntaxNode);\n \n impl StructLitNode {\n-    pub fn new(&self, ast: StructLit) -> StructLitNode {\n+    pub fn new(ast: StructLit) -> StructLitNode {\n         let syntax = ast.syntax().owned();\n         StructLitNode(syntax)\n     }\n@@ -2881,7 +2881,7 @@ impl<'a> StructLit<'a> {}\n pub struct StructPatNode(SyntaxNode);\n \n impl StructPatNode {\n-    pub fn new(&self, ast: StructPat) -> StructPatNode {\n+    pub fn new(ast: StructPat) -> StructPatNode {\n         let syntax = ast.syntax().owned();\n         StructPatNode(syntax)\n     }\n@@ -2912,7 +2912,7 @@ impl<'a> StructPat<'a> {}\n pub struct TokenTreeNode(SyntaxNode);\n \n impl TokenTreeNode {\n-    pub fn new(&self, ast: TokenTree) -> TokenTreeNode {\n+    pub fn new(ast: TokenTree) -> TokenTreeNode {\n         let syntax = ast.syntax().owned();\n         TokenTreeNode(syntax)\n     }\n@@ -2943,7 +2943,7 @@ impl<'a> TokenTree<'a> {}\n pub struct TraitDefNode(SyntaxNode);\n \n impl TraitDefNode {\n-    pub fn new(&self, ast: TraitDef) -> TraitDefNode {\n+    pub fn new(ast: TraitDef) -> TraitDefNode {\n         let syntax = ast.syntax().owned();\n         TraitDefNode(syntax)\n     }\n@@ -2976,7 +2976,7 @@ impl<'a> TraitDef<'a> {}\n pub struct TryExprNode(SyntaxNode);\n \n impl TryExprNode {\n-    pub fn new(&self, ast: TryExpr) -> TryExprNode {\n+    pub fn new(ast: TryExpr) -> TryExprNode {\n         let syntax = ast.syntax().owned();\n         TryExprNode(syntax)\n     }\n@@ -3007,7 +3007,7 @@ impl<'a> TryExpr<'a> {}\n pub struct TupleExprNode(SyntaxNode);\n \n impl TupleExprNode {\n-    pub fn new(&self, ast: TupleExpr) -> TupleExprNode {\n+    pub fn new(ast: TupleExpr) -> TupleExprNode {\n         let syntax = ast.syntax().owned();\n         TupleExprNode(syntax)\n     }\n@@ -3038,7 +3038,7 @@ impl<'a> TupleExpr<'a> {}\n pub struct TuplePatNode(SyntaxNode);\n \n impl TuplePatNode {\n-    pub fn new(&self, ast: TuplePat) -> TuplePatNode {\n+    pub fn new(ast: TuplePat) -> TuplePatNode {\n         let syntax = ast.syntax().owned();\n         TuplePatNode(syntax)\n     }\n@@ -3069,7 +3069,7 @@ impl<'a> TuplePat<'a> {}\n pub struct TupleStructPatNode(SyntaxNode);\n \n impl TupleStructPatNode {\n-    pub fn new(&self, ast: TupleStructPat) -> TupleStructPatNode {\n+    pub fn new(ast: TupleStructPat) -> TupleStructPatNode {\n         let syntax = ast.syntax().owned();\n         TupleStructPatNode(syntax)\n     }\n@@ -3100,7 +3100,7 @@ impl<'a> TupleStructPat<'a> {}\n pub struct TupleTypeNode(SyntaxNode);\n \n impl TupleTypeNode {\n-    pub fn new(&self, ast: TupleType) -> TupleTypeNode {\n+    pub fn new(ast: TupleType) -> TupleTypeNode {\n         let syntax = ast.syntax().owned();\n         TupleTypeNode(syntax)\n     }\n@@ -3131,7 +3131,7 @@ impl<'a> TupleType<'a> {}\n pub struct TypeDefNode(SyntaxNode);\n \n impl TypeDefNode {\n-    pub fn new(&self, ast: TypeDef) -> TypeDefNode {\n+    pub fn new(ast: TypeDef) -> TypeDefNode {\n         let syntax = ast.syntax().owned();\n         TypeDefNode(syntax)\n     }\n@@ -3165,7 +3165,7 @@ impl<'a> TypeDef<'a> {}\n pub struct TypeParamNode(SyntaxNode);\n \n impl TypeParamNode {\n-    pub fn new(&self, ast: TypeParam) -> TypeParamNode {\n+    pub fn new(ast: TypeParam) -> TypeParamNode {\n         let syntax = ast.syntax().owned();\n         TypeParamNode(syntax)\n     }\n@@ -3197,7 +3197,7 @@ impl<'a> TypeParam<'a> {}\n pub struct TypeParamListNode(SyntaxNode);\n \n impl TypeParamListNode {\n-    pub fn new(&self, ast: TypeParamList) -> TypeParamListNode {\n+    pub fn new(ast: TypeParamList) -> TypeParamListNode {\n         let syntax = ast.syntax().owned();\n         TypeParamListNode(syntax)\n     }\n@@ -3236,7 +3236,7 @@ impl<'a> TypeParamList<'a> {\n pub struct TypeRefNode(SyntaxNode);\n \n impl TypeRefNode {\n-    pub fn new(&self, ast: TypeRef) -> TypeRefNode {\n+    pub fn new(ast: TypeRef) -> TypeRefNode {\n         let syntax = ast.syntax().owned();\n         TypeRefNode(syntax)\n     }\n@@ -3307,7 +3307,7 @@ impl<'a> TypeRef<'a> {}\n pub struct UseItemNode(SyntaxNode);\n \n impl UseItemNode {\n-    pub fn new(&self, ast: UseItem) -> UseItemNode {\n+    pub fn new(ast: UseItem) -> UseItemNode {\n         let syntax = ast.syntax().owned();\n         UseItemNode(syntax)\n     }\n@@ -3342,7 +3342,7 @@ impl<'a> UseItem<'a> {\n pub struct UseTreeNode(SyntaxNode);\n \n impl UseTreeNode {\n-    pub fn new(&self, ast: UseTree) -> UseTreeNode {\n+    pub fn new(ast: UseTree) -> UseTreeNode {\n         let syntax = ast.syntax().owned();\n         UseTreeNode(syntax)\n     }\n@@ -3381,7 +3381,7 @@ impl<'a> UseTree<'a> {\n pub struct UseTreeListNode(SyntaxNode);\n \n impl UseTreeListNode {\n-    pub fn new(&self, ast: UseTreeList) -> UseTreeListNode {\n+    pub fn new(ast: UseTreeList) -> UseTreeListNode {\n         let syntax = ast.syntax().owned();\n         UseTreeListNode(syntax)\n     }\n@@ -3416,7 +3416,7 @@ impl<'a> UseTreeList<'a> {\n pub struct WhereClauseNode(SyntaxNode);\n \n impl WhereClauseNode {\n-    pub fn new(&self, ast: WhereClause) -> WhereClauseNode {\n+    pub fn new(ast: WhereClause) -> WhereClauseNode {\n         let syntax = ast.syntax().owned();\n         WhereClauseNode(syntax)\n     }\n@@ -3447,7 +3447,7 @@ impl<'a> WhereClause<'a> {}\n pub struct WhileExprNode(SyntaxNode);\n \n impl WhileExprNode {\n-    pub fn new(&self, ast: WhileExpr) -> WhileExprNode {\n+    pub fn new(ast: WhileExpr) -> WhileExprNode {\n         let syntax = ast.syntax().owned();\n         WhileExprNode(syntax)\n     }\n@@ -3483,7 +3483,7 @@ impl<'a> WhileExpr<'a> {\n pub struct WhitespaceNode(SyntaxNode);\n \n impl WhitespaceNode {\n-    pub fn new(&self, ast: Whitespace) -> WhitespaceNode {\n+    pub fn new(ast: Whitespace) -> WhitespaceNode {\n         let syntax = ast.syntax().owned();\n         WhitespaceNode(syntax)\n     }"}, {"sha": "d30038cba4407e48ff7d01b1d5703a7e77e3dfd6", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=1dc5608d0bb6bf2eee5a1b9190fcb2f8cdfa2ef3", "patch": "@@ -17,7 +17,7 @@ use crate::{\n pub struct {{ node }}Node(SyntaxNode);\n \n impl {{ node }}Node {\n-    pub fn new(&self, ast: {{ node }}) -> {{ node }}Node {\n+    pub fn new(ast: {{ node }}) -> {{ node }}Node {\n         let syntax = ast.syntax().owned();\n         {{ node }}Node(syntax)\n     }"}]}