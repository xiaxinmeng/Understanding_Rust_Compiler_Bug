{"sha": "26610dbbc8d39f98b11797b16cabdb573c00863d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NjEwZGJiYzhkMzlmOThiMTE3OTdiMTZjYWJkYjU3M2MwMDg2M2Q=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-11T11:49:33Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-11T19:33:44Z"}, "message": "Convert std::deque over to an iface", "tree": {"sha": "7d65f70b5a7a3f8268e654adcb7666654b4d8252", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d65f70b5a7a3f8268e654adcb7666654b4d8252"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26610dbbc8d39f98b11797b16cabdb573c00863d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26610dbbc8d39f98b11797b16cabdb573c00863d", "html_url": "https://github.com/rust-lang/rust/commit/26610dbbc8d39f98b11797b16cabdb573c00863d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26610dbbc8d39f98b11797b16cabdb573c00863d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15744210e7913c6607bf033f4ffd53d36de116e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/15744210e7913c6607bf033f4ffd53d36de116e6", "html_url": "https://github.com/rust-lang/rust/commit/15744210e7913c6607bf033f4ffd53d36de116e6"}], "stats": {"total": 108, "additions": 56, "deletions": 52}, "files": [{"sha": "f76d0f5cbf437290a0cdc46c5d2cf5926ec49308", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/26610dbbc8d39f98b11797b16cabdb573c00863d/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26610dbbc8d39f98b11797b16cabdb573c00863d/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=26610dbbc8d39f98b11797b16cabdb573c00863d", "patch": "@@ -1,13 +1,15 @@\n+import option::{some, none};\n+\n /*\n Module: deque\n \n A deque.  Untested as of yet.  Likely buggy.\n */\n \n /*\n-Object: t\n+Iface: t\n */\n-type t<T> = obj {\n+iface t<T> {\n     // Method: size\n     fn size() -> uint;\n     // Method: add_front\n@@ -24,7 +26,7 @@ type t<T> = obj {\n     fn peek_back() -> T;\n     // Method: get\n     fn get(int) -> T;\n-    };\n+}\n \n /*\n Section: Functions\n@@ -33,6 +35,8 @@ Section: Functions\n /*\n Function: create\n */\n+// FIXME eventually, a proper datatype plus an exported impl would be\n+// preferrable\n fn create<T: copy>() -> t<T> {\n     type cell<T> = option::t<T>;\n \n@@ -51,79 +55,79 @@ fn create<T: copy>() -> t<T> {\n         while i < nalloc {\n             if i < nelts {\n                 rv += [mutable elts[(lo + i) % nelts]];\n-            } else { rv += [mutable option::none]; }\n+            } else { rv += [mutable none]; }\n             i += 1u;\n         }\n \n         ret rv;\n     }\n     fn get<T: copy>(elts: [mutable cell<T>], i: uint) -> T {\n-        ret alt elts[i] { option::some(t) { t } _ { fail } };\n+        ret alt elts[i] { some(t) { t } _ { fail } };\n     }\n-    obj deque<T: copy>(mutable nelts: uint,\n-                      mutable lo: uint,\n-                      mutable hi: uint,\n-                      mutable elts: [mutable cell<T>]) {\n-        fn size() -> uint { ret nelts; }\n+\n+    type repr<T> = {mutable nelts: uint,\n+                    mutable lo: uint,\n+                    mutable hi: uint,\n+                    mutable elts: [mutable cell<T>]};\n+\n+    impl <T: copy> of t<T> for repr<T> {\n+        fn size() -> uint { ret self.nelts; }\n         fn add_front(t: T) {\n-            let oldlo: uint = lo;\n-            if lo == 0u {\n-                lo = vec::len::<cell<T>>(elts) - 1u;\n-            } else { lo -= 1u; }\n-            if lo == hi {\n-                elts = grow::<T>(nelts, oldlo, elts);\n-                lo = vec::len::<cell<T>>(elts) - 1u;\n-                hi = nelts;\n+            let oldlo: uint = self.lo;\n+            if self.lo == 0u {\n+                self.lo = vec::len(self.elts) - 1u;\n+            } else { self.lo -= 1u; }\n+            if self.lo == self.hi {\n+                self.elts = grow(self.nelts, oldlo, self.elts);\n+                self.lo = vec::len(self.elts) - 1u;\n+                self.hi = self.nelts;\n             }\n-            elts[lo] = option::some::<T>(t);\n-            nelts += 1u;\n+            self.elts[self.lo] = some(t);\n+            self.nelts += 1u;\n         }\n         fn add_back(t: T) {\n-            if lo == hi && nelts != 0u {\n-                elts = grow::<T>(nelts, lo, elts);\n-                lo = 0u;\n-                hi = nelts;\n+            if self.lo == self.hi && self.nelts != 0u {\n+                self.elts = grow(self.nelts, self.lo, self.elts);\n+                self.lo = 0u;\n+                self.hi = self.nelts;\n             }\n-            elts[hi] = option::some::<T>(t);\n-            hi = (hi + 1u) % vec::len::<cell<T>>(elts);\n-            nelts += 1u;\n+            self.elts[self.hi] = some(t);\n+            self.hi = (self.hi + 1u) % vec::len(self.elts);\n+            self.nelts += 1u;\n         }\n-\n         /**\n          * We actually release (turn to none()) the T we're popping so\n          * that we don't keep anyone's refcount up unexpectedly.\n          */\n         fn pop_front() -> T {\n-            let t: T = get::<T>(elts, lo);\n-            elts[lo] = option::none::<T>;\n-            lo = (lo + 1u) % vec::len::<cell<T>>(elts);\n-            nelts -= 1u;\n+            let t: T = get(self.elts, self.lo);\n+            self.elts[self.lo] = none;\n+            self.lo = (self.lo + 1u) % vec::len(self.elts);\n+            self.nelts -= 1u;\n             ret t;\n         }\n         fn pop_back() -> T {\n-            if hi == 0u {\n-                hi = vec::len::<cell<T>>(elts) - 1u;\n-            } else { hi -= 1u; }\n-            let t: T = get::<T>(elts, hi);\n-            elts[hi] = option::none::<T>;\n-            nelts -= 1u;\n+            if self.hi == 0u {\n+                self.hi = vec::len(self.elts) - 1u;\n+            } else { self.hi -= 1u; }\n+            let t: T = get(self.elts, self.hi);\n+            self.elts[self.hi] = none;\n+            self.nelts -= 1u;\n             ret t;\n         }\n-        fn peek_front() -> T { ret get::<T>(elts, lo); }\n-        fn peek_back() -> T { ret get::<T>(elts, hi - 1u); }\n+        fn peek_front() -> T { ret get(self.elts, self.lo); }\n+        fn peek_back() -> T { ret get(self.elts, self.hi - 1u); }\n         fn get(i: int) -> T {\n-            let idx: uint = (lo + (i as uint)) % vec::len::<cell<T>>(elts);\n-            ret get::<T>(elts, idx);\n+            let idx = (self.lo + (i as uint)) % vec::len(self.elts);\n+            ret get(self.elts, idx);\n         }\n     }\n-    let v: [mutable cell<T>] =\n-        vec::init_elt_mut(option::none, initial_capacity);\n-    ret deque::<T>(0u, 0u, 0u, v);\n+\n+    let repr: repr<T> = {\n+        mutable nelts: 0u,\n+        mutable lo: 0u,\n+        mutable hi: 0u,\n+        mutable elts: vec::init_elt_mut(none, initial_capacity)\n+    };\n+    repr as t::<T>\n }\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}]}