{"sha": "42a1239a18138db3b765d9b249b1ef83e19cccfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYTEyMzlhMTgxMzhkYjNiNzY1ZDliMjQ5YjFlZjgzZTE5Y2NjZmE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-18T09:53:15Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T11:08:39Z"}, "message": "avoid some redundant alignment checks", "tree": {"sha": "2c5e1dd6995dbdadcaa3eff12e4882ea98b70ef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c5e1dd6995dbdadcaa3eff12e4882ea98b70ef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42a1239a18138db3b765d9b249b1ef83e19cccfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42a1239a18138db3b765d9b249b1ef83e19cccfa", "html_url": "https://github.com/rust-lang/rust/commit/42a1239a18138db3b765d9b249b1ef83e19cccfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42a1239a18138db3b765d9b249b1ef83e19cccfa/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3b4f8e6c76ee9b30fa92749df0f139ec5d45ed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3b4f8e6c76ee9b30fa92749df0f139ec5d45ed7", "html_url": "https://github.com/rust-lang/rust/commit/e3b4f8e6c76ee9b30fa92749df0f139ec5d45ed7"}], "stats": {"total": 25, "additions": 18, "deletions": 7}, "files": [{"sha": "89c308d87ef28a5c3062fbb4d0915a882cface59", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/42a1239a18138db3b765d9b249b1ef83e19cccfa/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a1239a18138db3b765d9b249b1ef83e19cccfa/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=42a1239a18138db3b765d9b249b1ef83e19cccfa", "patch": "@@ -1,3 +1,11 @@\n+//! The memory subsystem.\n+//!\n+//! Generally, we use `Pointer` to denote memory addresses. However, some operations\n+//! have a \"size\"-like parameter, and they take `Scalar` for the address because\n+//! if the size is 0, then the pointer can also be a (properly aligned, non-NULL)\n+//! integer.  It is crucial that these operations call `check_align` *before*\n+//! short-circuiting the empty case!\n+\n use std::collections::VecDeque;\n use std::hash::{Hash, Hasher};\n use std::ptr;\n@@ -16,6 +24,7 @@ use syntax::ast::Mutability;\n \n use super::{EvalContext, Machine};\n \n+\n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n@@ -256,7 +265,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.tcx.data_layout.endian\n     }\n \n-    /// Check that the pointer is aligned AND non-NULL.\n+    /// Check that the pointer is aligned AND non-NULL. This supports scalars\n+    /// for the benefit of other parts of miri that need to check alignment even for ZST.\n     pub fn check_align(&self, ptr: Scalar, required_align: Align) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr {\n@@ -632,10 +642,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         length: u64,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n-        // Empty accesses don't need to be valid pointers, but they should still be aligned\n-        self.check_align(src, src_align)?;\n-        self.check_align(dest, dest_align)?;\n         if size.bytes() == 0 {\n+            // Nothing to do for ZST, other than checking alignment and non-NULLness.\n+            self.check_align(src, src_align)?;\n+            self.check_align(dest, dest_align)?;\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -661,6 +671,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             new_relocations\n         };\n \n+        // This also checks alignment.\n         let src_bytes = self.get_bytes_unchecked(src, size, src_align)?.as_ptr();\n         let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n \n@@ -718,8 +729,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn read_bytes(&self, ptr: Scalar, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n-        self.check_align(ptr, align)?;\n         if size.bytes() == 0 {\n+            self.check_align(ptr, align)?;\n             return Ok(&[]);\n         }\n         self.get_bytes(ptr.to_ptr()?, size, align)\n@@ -728,8 +739,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn write_bytes(&mut self, ptr: Scalar, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n-        self.check_align(ptr, align)?;\n         if src.is_empty() {\n+            self.check_align(ptr, align)?;\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, Size::from_bytes(src.len() as u64), align)?;\n@@ -740,8 +751,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn write_repeat(&mut self, ptr: Scalar, val: u8, count: Size) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n-        self.check_align(ptr, align)?;\n         if count.bytes() == 0 {\n+            self.check_align(ptr, align)?;\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, align)?;"}]}