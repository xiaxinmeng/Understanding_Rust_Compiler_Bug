{"sha": "154835e5e70ff4e735c8a344a9c13c63433eb670", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NDgzNWU1ZTcwZmY0ZTczNWM4YTM0NGE5YzEzYzYzNDMzZWI2NzA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-07T09:07:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-07T15:54:31Z"}, "message": "only count deref_operand as actual deref, but not all ref-to-place conversions", "tree": {"sha": "bc176e449989fbae246f65ef19f7ec3b7e5ef682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc176e449989fbae246f65ef19f7ec3b7e5ef682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154835e5e70ff4e735c8a344a9c13c63433eb670", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154835e5e70ff4e735c8a344a9c13c63433eb670", "html_url": "https://github.com/rust-lang/rust/commit/154835e5e70ff4e735c8a344a9c13c63433eb670", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154835e5e70ff4e735c8a344a9c13c63433eb670/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f174099885fed58c8053cf02bf353b6822897b75", "url": "https://api.github.com/repos/rust-lang/rust/commits/f174099885fed58c8053cf02bf353b6822897b75", "html_url": "https://github.com/rust-lang/rust/commit/f174099885fed58c8053cf02bf353b6822897b75"}], "stats": {"total": 63, "additions": 31, "deletions": 32}, "files": [{"sha": "7c704e97911407e047dc752b14e67d824fdba8fa", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=154835e5e70ff4e735c8a344a9c13c63433eb670", "patch": "@@ -183,18 +183,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         } else if Some(def_id) == self.tcx.lang_items().panic_fn() {\n             assert!(args.len() == 1);\n             // &(&'static str, &'static str, u32, u32)\n-            let ptr = self.read_immediate(args[0])?;\n-            let place = self.ref_to_mplace(ptr)?;\n+            let place = self.deref_operand(args[0])?;\n             let (msg, file, line, col) = (\n                 self.mplace_field(place, 0)?,\n                 self.mplace_field(place, 1)?,\n                 self.mplace_field(place, 2)?,\n                 self.mplace_field(place, 3)?,\n             );\n \n-            let msg_place = self.ref_to_mplace(self.read_immediate(msg.into())?)?;\n+            let msg_place = self.deref_operand(msg.into())?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.ref_to_mplace(self.read_immediate(file.into())?)?;\n+            let file_place = self.deref_operand(file.into())?;\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n@@ -203,17 +202,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             assert!(args.len() == 2);\n             // &'static str, &(&'static str, u32, u32)\n             let msg = args[0];\n-            let ptr = self.read_immediate(args[1])?;\n-            let place = self.ref_to_mplace(ptr)?;\n+            let place = self.deref_operand(args[1])?;\n             let (file, line, col) = (\n                 self.mplace_field(place, 0)?,\n                 self.mplace_field(place, 1)?,\n                 self.mplace_field(place, 2)?,\n             );\n \n-            let msg_place = self.ref_to_mplace(self.read_immediate(msg.into())?)?;\n+            let msg_place = self.deref_operand(msg.into())?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.ref_to_mplace(self.read_immediate(file.into())?)?;\n+            let file_place = self.deref_operand(file.into())?;\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;"}, {"sha": "a97bf95e7345d05e93c8115c45deb98f32f49ad2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=154835e5e70ff4e735c8a344a9c13c63433eb670", "patch": "@@ -555,17 +555,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         })\n     }\n \n-    // Take an operand, representing a pointer, and dereference it to a place -- that\n-    // will always be a MemPlace.\n-    pub(super) fn deref_operand(\n-        &self,\n-        src: OpTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let val = self.read_immediate(src)?;\n-        trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        Ok(self.ref_to_mplace(val)?)\n-    }\n-\n     pub fn operand_projection(\n         &self,\n         base: OpTy<'tcx, M::PointerTag>,"}, {"sha": "510b5826e489b4ee2ef7f7ff7ddd613745eab215", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=154835e5e70ff4e735c8a344a9c13c63433eb670", "patch": "@@ -277,18 +277,34 @@ where\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n+    /// This does NOT call the \"deref\" machine hook, so it does NOT count as a\n+    /// deref as far as Stacked Borrows is concerned.  Use `deref_operand` for that!\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n \n-        let align = layout.align;\n-        let meta = val.to_meta()?;\n-        let ptr = val.to_scalar_ptr()?;\n-        let mplace = MemPlace { ptr, align, meta };\n-        let mut mplace = MPlaceTy { mplace, layout };\n+        let mplace = MemPlace {\n+            ptr: val.to_scalar_ptr()?,\n+            align: layout.align,\n+            meta: val.to_meta()?,\n+        };\n+        Ok(MPlaceTy { mplace, layout })\n+    }\n+\n+    // Take an operand, representing a pointer, and dereference it to a place -- that\n+    // will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n+    // This calls the \"deref\" machine hook, and counts as a deref as far as\n+    // Stacked Borrows is concerned.\n+    pub fn deref_operand(\n+        &self,\n+        src: OpTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let val = self.read_immediate(src)?;\n+        trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n+        let mut place = self.ref_to_mplace(val)?;\n         // Pointer tag tracking might want to adjust the tag.\n         let mutbl = match val.layout.ty.sty {\n             // `builtin_deref` considers boxes immutable, that's useless for our purposes\n@@ -297,9 +313,8 @@ where\n             ty::RawPtr(_) => None,\n             _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n         };\n-        mplace.mplace.ptr = M::tag_dereference(self, mplace, mutbl)?;\n-        // Done\n-        Ok(mplace)\n+        place.mplace.ptr = M::tag_dereference(self, place, mutbl)?;\n+        Ok(place)\n     }\n \n     /// Offset a pointer to project to a field. Unlike place_field, this is always"}, {"sha": "6070b31d3e7a3f7d67c6926223acb2e183f8ffeb", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=154835e5e70ff4e735c8a344a9c13c63433eb670", "patch": "@@ -402,7 +402,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 let vtable = ptr.vtable()?;\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), self)?,"}, {"sha": "97bce651c05a16fcf2220a56c5dcd69bcf08f6ca", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154835e5e70ff4e735c8a344a9c13c63433eb670/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=154835e5e70ff4e735c8a344a9c13c63433eb670", "patch": "@@ -322,13 +322,10 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         }\n                     }\n                 }\n-                // Turn ptr into place.\n-                // `ref_to_mplace` also calls the machine hook for (re)activating the tag,\n-                // which in turn will (in full miri) check if the pointer is dereferencable.\n-                let place = self.ecx.ref_to_mplace(value)?;\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking {\n                     assert!(self.const_mode, \"We should only do recursie checking in const mode\");\n+                    let place = self.ecx.ref_to_mplace(value)?;\n                     if size != Size::ZERO {\n                         // Non-ZST also have to be dereferencable\n                         let ptr = try_validation!(place.ptr.to_ptr(),"}]}