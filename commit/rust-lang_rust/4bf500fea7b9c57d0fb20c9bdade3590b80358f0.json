{"sha": "4bf500fea7b9c57d0fb20c9bdade3590b80358f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZjUwMGZlYTdiOWM1N2QwZmIyMGM5YmRhZGUzNTkwYjgwMzU4ZjA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-08T12:24:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-20T08:44:02Z"}, "message": "elliminate mem::uninitialize from docs in libcore", "tree": {"sha": "6a530d1c77ceded17e09192bc8452c477a3b2f18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a530d1c77ceded17e09192bc8452c477a3b2f18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bf500fea7b9c57d0fb20c9bdade3590b80358f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bf500fea7b9c57d0fb20c9bdade3590b80358f0", "html_url": "https://github.com/rust-lang/rust/commit/4bf500fea7b9c57d0fb20c9bdade3590b80358f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bf500fea7b9c57d0fb20c9bdade3590b80358f0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11fba52c0758659b7238d99251e19d3b65c9119b", "url": "https://api.github.com/repos/rust-lang/rust/commits/11fba52c0758659b7238d99251e19d3b65c9119b", "html_url": "https://github.com/rust-lang/rust/commit/11fba52c0758659b7238d99251e19d3b65c9119b"}], "stats": {"total": 64, "additions": 4, "deletions": 60}, "files": [{"sha": "b7af9c0cef9c71558346ddde56af6282e2a0e64c", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4bf500fea7b9c57d0fb20c9bdade3590b80358f0/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf500fea7b9c57d0fb20c9bdade3590b80358f0/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=4bf500fea7b9c57d0fb20c9bdade3590b80358f0", "patch": "@@ -63,62 +63,6 @@ pub use crate::intrinsics::transmute;\n /// The practical use cases for `forget` are rather specialized and mainly come\n /// up in unsafe or FFI code.\n ///\n-/// ## Use case 1\n-///\n-/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n-/// You must either initialize or `forget` it on every computation path before\n-/// Rust drops it automatically, like at the end of a scope or after a panic.\n-/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// # let some_condition = false;\n-/// unsafe {\n-///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n-///\n-///     if some_condition {\n-///         // Initialize the variable.\n-///         ptr::write(&mut uninit_vec, Vec::new());\n-///     } else {\n-///         // Forget the uninitialized value so its destructor doesn't run.\n-///         mem::forget(uninit_vec);\n-///     }\n-/// }\n-/// ```\n-///\n-/// ## Use case 2\n-///\n-/// You have duplicated the bytes making up a value, without doing a proper\n-/// [`Clone`][clone]. You need the value's destructor to run only once,\n-/// because a double `free` is undefined behavior.\n-///\n-/// An example is a possible implementation of [`mem::swap`][swap]:\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// # #[allow(dead_code)]\n-/// fn swap<T>(x: &mut T, y: &mut T) {\n-///     unsafe {\n-///         // Give ourselves some scratch space to work with\n-///         let mut t: T = mem::uninitialized();\n-///\n-///         // Perform the swap, `&mut` pointers never alias\n-///         ptr::copy_nonoverlapping(&*x, &mut t, 1);\n-///         ptr::copy_nonoverlapping(&*y, x, 1);\n-///         ptr::copy_nonoverlapping(&t, y, 1);\n-///\n-///         // y and t now point to the same thing, but we need to completely\n-///         // forget `t` because we do not want to run the destructor for `T`\n-///         // on its value, which is still owned somewhere outside this function.\n-///         mem::forget(t);\n-///     }\n-/// }\n-/// ```\n-///\n /// [drop]: fn.drop.html\n /// [uninit]: fn.uninitialized.html\n /// [clone]: ../clone/trait.Clone.html"}, {"sha": "dd321dcdfae6c8ab200a688aff273c8eb940854f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bf500fea7b9c57d0fb20c9bdade3590b80358f0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf500fea7b9c57d0fb20c9bdade3590b80358f0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4bf500fea7b9c57d0fb20c9bdade3590b80358f0", "patch": "@@ -155,12 +155,12 @@ pub use crate::intrinsics::write_bytes;\n /// location first:\n /// ```\n /// use std::ptr;\n-/// use std::mem;\n+/// use std::mem::{self, MaybeUninit};\n ///\n /// unsafe fn drop_after_copy<T>(to_drop: *mut T) {\n-///     let mut copy: T = mem::uninitialized();\n-///     ptr::copy(to_drop, &mut copy, 1);\n-///     drop(copy);\n+///     let mut copy: MaybeUninit<T> = MaybeUninit::uninit();\n+///     ptr::copy(to_drop, copy.as_mut_ptr(), 1);\n+///     drop(copy.assume_init());\n /// }\n ///\n /// #[repr(packed, C)]"}]}