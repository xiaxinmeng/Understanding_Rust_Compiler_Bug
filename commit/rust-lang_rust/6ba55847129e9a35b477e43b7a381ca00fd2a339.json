{"sha": "6ba55847129e9a35b477e43b7a381ca00fd2a339", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYTU1ODQ3MTI5ZTlhMzViNDc3ZTQzYjdhMzgxY2EwMGZkMmEzMzk=", "commit": {"author": {"name": "Gabriel Majeri", "email": "gabriel.majeri6@gmail.com", "date": "2018-10-05T05:50:17Z"}, "committer": {"name": "Gabriel Majeri", "email": "gabriel.majeri6@gmail.com", "date": "2018-10-05T05:50:17Z"}, "message": "Address review comments", "tree": {"sha": "7e40b07b62f6cbdd7a8fe3e1688243917769c0c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e40b07b62f6cbdd7a8fe3e1688243917769c0c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ba55847129e9a35b477e43b7a381ca00fd2a339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba55847129e9a35b477e43b7a381ca00fd2a339", "html_url": "https://github.com/rust-lang/rust/commit/6ba55847129e9a35b477e43b7a381ca00fd2a339", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ba55847129e9a35b477e43b7a381ca00fd2a339/comments", "author": {"login": "GabrielMajeri", "id": 3010346, "node_id": "MDQ6VXNlcjMwMTAzNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/3010346?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GabrielMajeri", "html_url": "https://github.com/GabrielMajeri", "followers_url": "https://api.github.com/users/GabrielMajeri/followers", "following_url": "https://api.github.com/users/GabrielMajeri/following{/other_user}", "gists_url": "https://api.github.com/users/GabrielMajeri/gists{/gist_id}", "starred_url": "https://api.github.com/users/GabrielMajeri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GabrielMajeri/subscriptions", "organizations_url": "https://api.github.com/users/GabrielMajeri/orgs", "repos_url": "https://api.github.com/users/GabrielMajeri/repos", "events_url": "https://api.github.com/users/GabrielMajeri/events{/privacy}", "received_events_url": "https://api.github.com/users/GabrielMajeri/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GabrielMajeri", "id": 3010346, "node_id": "MDQ6VXNlcjMwMTAzNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/3010346?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GabrielMajeri", "html_url": "https://github.com/GabrielMajeri", "followers_url": "https://api.github.com/users/GabrielMajeri/followers", "following_url": "https://api.github.com/users/GabrielMajeri/following{/other_user}", "gists_url": "https://api.github.com/users/GabrielMajeri/gists{/gist_id}", "starred_url": "https://api.github.com/users/GabrielMajeri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GabrielMajeri/subscriptions", "organizations_url": "https://api.github.com/users/GabrielMajeri/orgs", "repos_url": "https://api.github.com/users/GabrielMajeri/repos", "events_url": "https://api.github.com/users/GabrielMajeri/events{/privacy}", "received_events_url": "https://api.github.com/users/GabrielMajeri/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e921aa59090096593cb4fa202041c91a5d1e36b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e921aa59090096593cb4fa202041c91a5d1e36b", "html_url": "https://github.com/rust-lang/rust/commit/7e921aa59090096593cb4fa202041c91a5d1e36b"}], "stats": {"total": 110, "additions": 67, "deletions": 43}, "files": [{"sha": "d69ebc17622720200a1db22eb5262621e99946ce", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 67, "deletions": 43, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6ba55847129e9a35b477e43b7a381ca00fd2a339/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba55847129e9a35b477e43b7a381ca00fd2a339/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=6ba55847129e9a35b477e43b7a381ca00fd2a339", "patch": "@@ -12,11 +12,11 @@\n //!\n //! ## The need for synchronization\n //!\n-//! Conceptually, a Rust program is simply a series of operations which will\n-//! be executed on a computer. The timeline of events happening in the program\n-//! is consistent with the order of the operations in the code.\n+//! Conceptually, a Rust program is a series of operations which will\n+//! be executed on a computer. The timeline of events happening in the\n+//! program is consistent with the order of the operations in the code.\n //!\n-//! Considering the following code, operating on some global static variables:\n+//! Consider the following code, operating on some global static variables:\n //!\n //! ```rust\n //! static mut A: u32 = 0;\n@@ -35,8 +35,10 @@\n //! }\n //! ```\n //!\n-//! It appears _as if_ some variables stored in memory are changed, an addition\n-//! is performed, result is stored in `A` and the variable `C` is modified twice.\n+//! It appears as if some variables stored in memory are changed, an addition\n+//! is performed, result is stored in `A` and the variable `C` is\n+//! modified twice.\n+//!\n //! When only a single thread is involved, the results are as expected:\n //! the line `7 4 4` gets printed.\n //!\n@@ -50,17 +52,19 @@\n //!   in a temporary location until it gets printed, with the global variable\n //!   never getting updated.\n //!\n-//! - The final result could be determined just by looking at the code at compile time,\n-//!   so [constant folding] might turn the whole block into a simple `println!(\"7 4 4\")`.\n+//! - The final result could be determined just by looking at the code\n+//!   at compile time, so [constant folding] might turn the whole\n+//!   block into a simple `println!(\"7 4 4\")`.\n //!\n-//! The compiler is allowed to perform any combination of these optimizations, as long\n-//! as the final optimized code, when executed, produces the same results as the one\n-//! without optimizations.\n+//! The compiler is allowed to perform any combination of these\n+//! optimizations, as long as the final optimized code, when executed,\n+//! produces the same results as the one without optimizations.\n //!\n-//! Due to the [concurrency] involved in modern computers, assumptions about\n-//! the program's execution order are often wrong. Access to global variables\n-//! can lead to nondeterministic results, **even if** compiler optimizations\n-//! are disabled, and it is **still possible** to introduce synchronization bugs.\n+//! Due to the [concurrency] involved in modern computers, assumptions\n+//! about the program's execution order are often wrong. Access to\n+//! global variables can lead to nondeterministic results, **even if**\n+//! compiler optimizations are disabled, and it is **still possible**\n+//! to introduce synchronization bugs.\n //!\n //! Note that thanks to Rust's safety guarantees, accessing global (static)\n //! variables requires `unsafe` code, assuming we don't use any of the\n@@ -74,7 +78,7 @@\n //! Instructions can execute in a different order from the one we define, due to\n //! various reasons:\n //!\n-//! - **Compiler** reordering instructions: if the compiler can issue an\n+//! - The **compiler** reordering instructions: If the compiler can issue an\n //!   instruction at an earlier point, it will try to do so. For example, it\n //!   might hoist memory loads at the top of a code block, so that the CPU can\n //!   start [prefetching] the values from memory.\n@@ -83,20 +87,20 @@\n //!   signal handlers or certain kinds of low-level code.\n //!   Use [compiler fences] to prevent this reordering.\n //!\n-//! - **Single processor** executing instructions [out-of-order]: modern CPUs are\n-//!   capable of [superscalar] execution, i.e. multiple instructions might be\n-//!   executing at the same time, even though the machine code describes a\n-//!   sequential process.\n+//! - A **single processor** executing instructions [out-of-order]:\n+//!   Modern CPUs are capable of [superscalar] execution,\n+//!   i.e. multiple instructions might be executing at the same time,\n+//!   even though the machine code describes a sequential process.\n //!\n //!   This kind of reordering is handled transparently by the CPU.\n //!\n-//! - **Multiprocessor** system, where multiple hardware threads run at the same time.\n-//!   In multi-threaded scenarios, you can use two kinds of primitives to deal\n-//!   with synchronization:\n-//!   - [memory fences] to ensure memory accesses are made visibile to other\n-//!     CPUs in the right order.\n-//!   - [atomic operations] to ensure simultaneous access to the same memory\n-//!     location doesn't lead to undefined behavior.\n+//! - A **multiprocessor** system executing multiple hardware threads\n+//!   at the same time: In multi-threaded scenarios, you can use two\n+//!   kinds of primitives to deal with synchronization:\n+//!   - [memory fences] to ensure memory accesses are made visibile to\n+//!   other CPUs in the right order.\n+//!   - [atomic operations] to ensure simultaneous access to the same\n+//!   memory location doesn't lead to undefined behavior.\n //!\n //! [prefetching]: https://en.wikipedia.org/wiki/Cache_prefetching\n //! [compiler fences]: crate::sync::atomic::compiler_fence\n@@ -111,29 +115,49 @@\n //! inconvenient to use, which is why the standard library also exposes some\n //! higher-level synchronization objects.\n //!\n-//! These abstractions can be built out of lower-level primitives. For efficiency,\n-//! the sync objects in the standard library are usually implemented with help\n-//! from the operating system's kernel, which is able to reschedule the threads\n-//! while they are blocked on acquiring a lock.\n+//! These abstractions can be built out of lower-level primitives.\n+//! For efficiency, the sync objects in the standard library are usually\n+//! implemented with help from the operating system's kernel, which is\n+//! able to reschedule the threads while they are blocked on acquiring\n+//! a lock.\n+//!\n+//! The following is an overview of the available synchronization\n+//! objects:\n+//!\n+//! - [`Arc`]: Atomically Reference-Counted pointer, which can be used\n+//!   in multithreaded environments to prolong the lifetime of some\n+//!   data until all the threads have finished using it.\n+//!\n+//! - [`Barrier`]: Ensures multiple threads will wait for each other\n+//!   to reach a point in the program, before continuing execution all\n+//!   together.\n+//!\n+//! - [`Condvar`]: Condition Variable, providing the ability to block\n+//!   a thread while waiting for an event to occur.\n //!\n-//! ## Efficiency\n+//! - [`mpsc`]: Multi-producer, single-consumer queues, used for\n+//!   message-based communication. Can provide a lightweight\n+//!   inter-thread synchronisation mechanism, at the cost of some\n+//!   extra memory.\n //!\n-//! Higher-level synchronization mechanisms are usually heavy-weight.\n-//! While most atomic operations can execute instantaneously, acquiring a\n-//! [`Mutex`] can involve blocking until another thread releases it.\n-//! For [`RwLock`], while any number of readers may acquire it without\n-//! blocking, each writer will have exclusive access.\n+//! - [`Mutex`]: Mutual Exclusion mechanism, which ensures that at\n+//!   most one thread at a time is able to access some data.\n //!\n-//! On the other hand, communication over [channels] can provide a fairly\n-//! high-level interface without sacrificing performance, at the cost of\n-//! somewhat more memory.\n+//! - [`Once`]: Used for thread-safe, one-time initialization of a\n+//!   global variable.\n //!\n-//! The more synchronization exists between CPUs, the smaller the performance\n-//! gains from multithreading will be.\n+//! - [`RwLock`]: Provides a mutual exclusion mechanism which allows\n+//!   multiple readers at the same time, while allowing only one\n+//!   writer at a time. In some cases, this can be more efficient than\n+//!   a mutex.\n //!\n+//! [`Arc`]: crate::sync::Arc\n+//! [`Barrier`]: crate::sync::Barrier\n+//! [`Condvar`]: crate::sync::Condvar\n+//! [`mpsc`]: crate::sync::mpsc\n //! [`Mutex`]: crate::sync::Mutex\n+//! [`Once`]: crate::sync::Once\n //! [`RwLock`]: crate::sync::RwLock\n-//! [channels]: crate::sync::mpsc\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}