{"sha": "f305579e490a9fa046b1b7a14e62daf643e41865", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMDU1NzllNDkwYTlmYTA0NmIxYjdhMTRlNjJkYWY2NDNlNDE4NjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-17T20:38:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-17T20:38:18Z"}, "message": "Auto merge of #24461 - nikomatsakis:issue-22077-unused-lifetimes, r=aturon\n\nThis makes it illegal to have unconstrained lifetimes that appear in an associated type definition. Arguably, we should prohibit all unconstrained lifetimes -- but it would break various macros. It'd be good to evaluate how large a break change it would be. But this seems like the minimal change we need to do to establish soundness, so we should land it regardless. Another variant would be to prohibit all lifetimes that appear in any impl item, not just associated types. I don't think that's necessary for soundness -- associated types are different because they can be projected -- but it would feel a bit more consistent and \"obviously\" safe. I'll experiment with that in the meantime.\r\n\r\nr? @aturon \r\n\r\nFixes #22077.", "tree": {"sha": "4db877cb45e780d62f3cfb69374d6dc3ca8f9a92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4db877cb45e780d62f3cfb69374d6dc3ca8f9a92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f305579e490a9fa046b1b7a14e62daf643e41865", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f305579e490a9fa046b1b7a14e62daf643e41865", "html_url": "https://github.com/rust-lang/rust/commit/f305579e490a9fa046b1b7a14e62daf643e41865", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f305579e490a9fa046b1b7a14e62daf643e41865/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b2530c74832d8434ae7d87d01aa44936c0b0f84", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2530c74832d8434ae7d87d01aa44936c0b0f84", "html_url": "https://github.com/rust-lang/rust/commit/3b2530c74832d8434ae7d87d01aa44936c0b0f84"}, {"sha": "5368070228a90b38bc3c36841ca5d882c9afc301", "url": "https://api.github.com/repos/rust-lang/rust/commits/5368070228a90b38bc3c36841ca5d882c9afc301", "html_url": "https://github.com/rust-lang/rust/commit/5368070228a90b38bc3c36841ca5d882c9afc301"}], "stats": {"total": 403, "additions": 303, "deletions": 100}, "files": [{"sha": "955905ee2634d46de25c0d0ac4f5dad8819dd50d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -341,7 +341,12 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n         let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n         let nm = token::str_to_ident(&parse_str(st, ']'));\n-        ty::ReEarlyBound(node_id, space, index, nm.name)\n+        ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            param_id: node_id,\n+            space: space,\n+            index: index,\n+            name: nm.name\n+        })\n       }\n       'f' => {\n         assert_eq!(next(st), '[');"}, {"sha": "8a27881128255e55bd3bf2a5ed09edcaba559914", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -241,12 +241,12 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n             enc_bound_region(w, cx, br);\n             mywrite!(w, \"]\");\n         }\n-        ty::ReEarlyBound(node_id, space, index, name) => {\n+        ty::ReEarlyBound(ref data) => {\n             mywrite!(w, \"B[{}|{}|{}|{}]\",\n-                     node_id,\n-                     space.to_uint(),\n-                     index,\n-                     token::get_name(name));\n+                     data.param_id,\n+                     data.space.to_uint(),\n+                     data.index,\n+                     token::get_name(data.name));\n         }\n         ty::ReFree(ref fr) => {\n             mywrite!(w, \"f[\");"}, {"sha": "7ee0ea4fd664bac53a1bc146149ce3f8f082311e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -496,8 +496,13 @@ impl tr for ty::Region {\n             ty::ReLateBound(debruijn, br) => {\n                 ty::ReLateBound(debruijn, br.tr(dcx))\n             }\n-            ty::ReEarlyBound(id, space, index, ident) => {\n-                ty::ReEarlyBound(dcx.tr_id(id), space, index, ident)\n+            ty::ReEarlyBound(data) => {\n+                ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    param_id: dcx.tr_id(data.param_id),\n+                    space: data.space,\n+                    index: data.index,\n+                    name: data.name,\n+                })\n             }\n             ty::ReScope(scope) => {\n                 ty::ReScope(scope.tr(dcx))"}, {"sha": "2f7296051c566cb14ab0d40612e9113c5b3425c3", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -603,14 +603,11 @@ impl RegionMaps {\n                     self.sub_free_region(sub_fr, super_fr)\n                 }\n \n-                (ty::ReEarlyBound(param_id_a, param_space_a, index_a, _),\n-                 ty::ReEarlyBound(param_id_b, param_space_b, index_b, _)) => {\n+                (ty::ReEarlyBound(data_a), ty::ReEarlyBound(data_b)) => {\n                     // This case is used only to make sure that explicitly-\n                     // specified `Self` types match the real self type in\n-                    // implementations.\n-                    param_id_a == param_id_b &&\n-                        param_space_a == param_space_b &&\n-                        index_a == index_b\n+                    // implementations. Yuck.\n+                    data_a == data_b\n                 }\n \n                 _ => {"}, {"sha": "29f718fd0976942062053bb582cac9c1b6bd61fd", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -622,11 +622,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         // regions that appear in a function signature is done using\n         // the specialized routine `ty::replace_late_regions()`.\n         match r {\n-            ty::ReEarlyBound(_, space, i, region_name) => {\n+            ty::ReEarlyBound(data) => {\n                 match self.substs.regions {\n                     ErasedRegions => ty::ReStatic,\n                     NonerasedRegions(ref regions) =>\n-                        match regions.opt_get(space, i as usize) {\n+                        match regions.opt_get(data.space, data.index as usize) {\n                             Some(&r) => {\n                                 self.shift_region_through_binders(r)\n                             }\n@@ -635,11 +635,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                 self.tcx().sess.span_bug(\n                                     span,\n                                     &format!(\"Type parameter out of range \\\n-                                     when substituting in region {} (root type={}) \\\n-                                     (space={:?}, index={})\",\n-                                    region_name.as_str(),\n-                                    self.root_ty.repr(self.tcx()),\n-                                    space, i));\n+                                              when substituting in region {} (root type={}) \\\n+                                              (space={:?}, index={})\",\n+                                             data.name.as_str(),\n+                                             self.root_ty.repr(self.tcx()),\n+                                             data.space,\n+                                             data.index));\n                             }\n                         }\n                 }"}, {"sha": "53c3cdd02af8923f22c232fd10ab74d876ad5e1b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -1134,10 +1134,7 @@ pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n     // parameters are substituted.\n-    ReEarlyBound(/* param id */ ast::NodeId,\n-                 subst::ParamSpace,\n-                 /*index*/ u32,\n-                 ast::Name),\n+    ReEarlyBound(EarlyBoundRegion),\n \n     // Region bound in a function scope, which will be substituted when the\n     // function is called.\n@@ -1169,6 +1166,14 @@ pub enum Region {\n     ReEmpty,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+pub struct EarlyBoundRegion {\n+    pub param_id: ast::NodeId,\n+    pub space: subst::ParamSpace,\n+    pub index: u32,\n+    pub name: ast::Name,\n+}\n+\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n@@ -1761,7 +1766,12 @@ pub struct RegionParameterDef {\n \n impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n-        ty::ReEarlyBound(self.def_id.node, self.space, self.index, self.name)\n+        ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            param_id: self.def_id.node,\n+            space: self.space,\n+            index: self.index,\n+            name: self.name,\n+        })\n     }\n     pub fn to_bound_region(&self) -> ty::BoundRegion {\n         ty::BoundRegion::BrNamed(self.def_id, self.name)\n@@ -7071,8 +7081,7 @@ pub fn make_substs_for_receiver_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let meth_regions: Vec<ty::Region> =\n         method.generics.regions.get_slice(subst::FnSpace)\n               .iter()\n-              .map(|def| ty::ReEarlyBound(def.def_id.node, def.space,\n-                                          def.index, def.name))\n+              .map(|def| def.to_early_bound_region())\n               .collect();\n     trait_ref.substs.clone().with_method(meth_tps, meth_regions)\n }"}, {"sha": "12a6d5848572d7b35660664a3645adccc0cdf36c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -163,8 +163,8 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n \n       ReEmpty => { (\"the empty lifetime\".to_string(), None) }\n \n-      ReEarlyBound(_, _, _, name) => {\n-        (format!(\"{}\", token::get_name(name)), None)\n+      ReEarlyBound(ref data) => {\n+        (format!(\"{}\", token::get_name(data.name)), None)\n       }\n \n       // I believe these cases should not occur (except when debugging,\n@@ -223,8 +223,8 @@ pub fn region_to_string(cx: &ctxt, prefix: &str, space: bool, region: Region) ->\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n         ty::ReScope(_) => prefix.to_string(),\n-        ty::ReEarlyBound(_, _, _, name) => {\n-            token::get_name(name).to_string()\n+        ty::ReEarlyBound(ref data) => {\n+            token::get_name(data.name).to_string()\n         }\n         ty::ReLateBound(_, br) => bound_region_to_string(cx, prefix, space, br),\n         ty::ReFree(ref fr) => bound_region_to_string(cx, prefix, space, fr.bound_region),\n@@ -903,12 +903,12 @@ impl<'tcx> Repr<'tcx> for ty::BoundRegion {\n impl<'tcx> Repr<'tcx> for ty::Region {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n-            ty::ReEarlyBound(id, space, index, name) => {\n+            ty::ReEarlyBound(ref data) => {\n                 format!(\"ReEarlyBound({}, {:?}, {}, {})\",\n-                               id,\n-                               space,\n-                               index,\n-                               token::get_name(name))\n+                        data.param_id,\n+                        data.space,\n+                        data.index,\n+                        token::get_name(data.name))\n             }\n \n             ty::ReLateBound(binder_id, ref bound_region) => {"}, {"sha": "12b16e95a71a43601b7448d4a1abdf7541c650c8", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -290,7 +290,12 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                           -> ty::Region\n     {\n         let name = token::intern(name);\n-        ty::ReEarlyBound(ast::DUMMY_NODE_ID, space, index, name)\n+        ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            param_id: ast::DUMMY_NODE_ID,\n+            space: space,\n+            index: index,\n+            name: name\n+        })\n     }\n \n     pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex) -> ty::Region {"}, {"sha": "171c83d00e465240ae906f1a8fa8f5f0e7e7a9a9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -161,7 +161,12 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n         }\n \n         Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n-            ty::ReEarlyBound(id, space, index, lifetime.name)\n+            ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                param_id: id,\n+                space: space,\n+                index: index,\n+                name: lifetime.name\n+            })\n         }\n \n         Some(&rl::DefFreeRegion(scope, id)) => {"}, {"sha": "83e0c398590f539ed80c2db58049878a8a2284df", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -10,7 +10,7 @@\n \n use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n-use constrained_type_params::identify_constrained_type_params;\n+use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use middle::region;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n@@ -287,10 +287,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         let mut constrained_parameters: HashSet<_> =\n             variances.types\n-            .iter_enumerated()\n-            .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n-            .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n-            .collect();\n+                     .iter_enumerated()\n+                     .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n+                     .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+                     .map(|p| Parameter::Type(p))\n+                     .collect();\n \n         identify_constrained_type_params(self.tcx(),\n                                          ty_predicates.predicates.as_slice(),\n@@ -299,7 +300,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         for (space, index, _) in variances.types.iter_enumerated() {\n             let param_ty = self.param_ty(ast_generics, space, index);\n-            if constrained_parameters.contains(&param_ty) {\n+            if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n                 continue;\n             }\n             let span = self.ty_param_span(ast_generics, item, space, index);"}, {"sha": "5ed93703d977f25ced3824755210b2a0648739fd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 95, "deletions": 31, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -66,7 +66,7 @@ There are some shortcomings in this design:\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use middle::def;\n-use constrained_type_params::identify_constrained_type_params;\n+use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -902,9 +902,10 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n             }\n \n-            enforce_impl_ty_params_are_constrained(tcx,\n-                                                   generics,\n-                                                   local_def(it.id));\n+            enforce_impl_params_are_constrained(tcx,\n+                                                generics,\n+                                                local_def(it.id),\n+                                                impl_items);\n         },\n         ast::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n@@ -1217,10 +1218,12 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             generics.lifetimes\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| ty::ReEarlyBound(def.lifetime.id,\n-                                                     TypeSpace,\n-                                                     i as u32,\n-                                                     def.lifetime.name))\n+                    .map(|(i, def)| ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                        param_id: def.lifetime.id,\n+                        space: TypeSpace,\n+                        index: i as u32,\n+                        name: def.lifetime.name\n+                    }))\n                     .collect();\n \n         // Start with the generics in the type parameters...\n@@ -1691,7 +1694,13 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n     for (index, param) in early_lifetimes.iter().enumerate() {\n         let index = index as u32;\n-        let region = ty::ReEarlyBound(param.lifetime.id, space, index, param.lifetime.name);\n+        let region =\n+            ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                param_id: param.lifetime.id,\n+                space: space,\n+                index: index,\n+                name: param.lifetime.name\n+            });\n         for bound in &param.bounds {\n             let bound_region = ast_region_to_region(ccx.tcx, bound);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n@@ -2168,10 +2177,10 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n \n         ty_fold::fold_regions(tcx, value, |region, _| {\n             match region {\n-                ty::ReEarlyBound(id, _, _, name) => {\n-                    let def_id = local_def(id);\n+                ty::ReEarlyBound(data) => {\n+                    let def_id = local_def(data.param_id);\n                     ty::ReFree(ty::FreeRegion { scope: scope,\n-                                                bound_region: ty::BrNamed(def_id, name) })\n+                                                bound_region: ty::BrNamed(def_id, data.name) })\n                 }\n                 _ => region\n             }\n@@ -2180,9 +2189,10 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n }\n \n /// Checks that all the type parameters on an impl\n-fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                                ast_generics: &ast::Generics,\n-                                                impl_def_id: ast::DefId)\n+fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                             ast_generics: &ast::Generics,\n+                                             impl_def_id: ast::DefId,\n+                                             impl_items: &[P<ast::ImplItem>])\n {\n     let impl_scheme = ty::lookup_item_type(tcx, impl_def_id);\n     let impl_predicates = ty::lookup_predicates(tcx, impl_def_id);\n@@ -2192,27 +2202,81 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n     let mut input_parameters: HashSet<_> =\n-        impl_trait_ref.iter()\n-                      .flat_map(|t| t.input_types().iter()) // Types in trait ref, if any\n-                      .chain(Some(impl_scheme.ty).iter())   // Self type, always\n-                      .flat_map(|t| t.walk())\n-                      .filter_map(|t| t.as_opt_param_ty())\n-                      .collect();\n-\n-    identify_constrained_type_params(tcx,\n-                                     impl_predicates.predicates.as_slice(),\n-                                     impl_trait_ref,\n-                                     &mut input_parameters);\n+        ctp::parameters_for_type(impl_scheme.ty).into_iter().collect();\n+    if let Some(ref trait_ref) = impl_trait_ref {\n+        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref));\n+    }\n+\n+    ctp::identify_constrained_type_params(tcx,\n+                                          impl_predicates.predicates.as_slice(),\n+                                          impl_trait_ref,\n+                                          &mut input_parameters);\n \n     for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n         let param_ty = ty::ParamTy { space: TypeSpace,\n                                      idx: index as u32,\n                                      name: ty_param.ident.name };\n-        if !input_parameters.contains(&param_ty) {\n-            span_err!(tcx.sess, ty_param.span, E0207,\n-                \"the type parameter `{}` is not constrained by the \\\n-                         impl trait, self type, or predicates\",\n-                        param_ty.user_string(tcx));\n+        if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n+            report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.user_string(tcx));\n         }\n     }\n+\n+    // Every lifetime used in an associated type must be constrained.\n+\n+    let lifetimes_in_associated_types: HashSet<_> =\n+        impl_items.iter()\n+                  .filter_map(|item| match item.node {\n+                      ast::TypeImplItem(..) => Some(ty::node_id_to_type(tcx, item.id)),\n+                      ast::MethodImplItem(..) | ast::MacImplItem(..) => None,\n+                  })\n+                  .flat_map(|ty| ctp::parameters_for_type(ty).into_iter())\n+                  .filter_map(|p| match p {\n+                      ctp::Parameter::Type(_) => None,\n+                      ctp::Parameter::Region(r) => Some(r),\n+                  })\n+                  .collect();\n+\n+    for (index, lifetime_def) in ast_generics.lifetimes.iter().enumerate() {\n+        let region = ty::EarlyBoundRegion { param_id: lifetime_def.lifetime.id,\n+                                            space: TypeSpace,\n+                                            index: index as u32,\n+                                            name: lifetime_def.lifetime.name };\n+        if\n+            lifetimes_in_associated_types.contains(&region) && // (*)\n+            !input_parameters.contains(&ctp::Parameter::Region(region))\n+        {\n+            report_unused_parameter(tcx, lifetime_def.lifetime.span,\n+                                    \"lifetime\", &region.name.user_string(tcx));\n+        }\n+    }\n+\n+    // (*) This is a horrible concession to reality. I think it'd be\n+    // better to just ban unconstrianed lifetimes outright, but in\n+    // practice people do non-hygenic macros like:\n+    //\n+    // ```\n+    // macro_rules! __impl_slice_eq1 {\n+    //     ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+    //         impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+    //            ....\n+    //         }\n+    //     }\n+    // }\n+    // ```\n+    //\n+    // In a concession to backwards compatbility, we continue to\n+    // permit those, so long as the lifetimes aren't used in\n+    // associated types. I believe this is sound, because lifetimes\n+    // used elsewhere are not projected back out.\n+}\n+\n+fn report_unused_parameter(tcx: &ty::ctxt,\n+                           span: Span,\n+                           kind: &str,\n+                           name: &str)\n+{\n+    span_err!(tcx.sess, span, E0207,\n+              \"the {} parameter `{}` is not constrained by the \\\n+               impl trait, self type, or predicates\",\n+              kind, name);\n }"}, {"sha": "fad8fbef2a4d40ce8a1425b112be0d980cac8306", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 72, "deletions": 20, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -8,49 +8,101 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::ty::{self};\n+use middle::subst;\n+use middle::ty::{self, Ty};\n \n use std::collections::HashSet;\n use std::rc::Rc;\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Parameter {\n+    Type(ty::ParamTy),\n+    Region(ty::EarlyBoundRegion),\n+}\n+\n+pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n+    ty.walk()\n+      .flat_map(|ty| parameters_for_type_shallow(ty).into_iter())\n+      .collect()\n+}\n+\n+pub fn parameters_for_trait_ref<'tcx>(trait_ref: &Rc<ty::TraitRef<'tcx>>) -> Vec<Parameter> {\n+    let mut region_parameters =\n+        parameters_for_regions_in_substs(&trait_ref.substs);\n+\n+    let type_parameters =\n+        trait_ref.substs.types.iter()\n+                              .flat_map(|ty| parameters_for_type(ty).into_iter());\n+\n+    region_parameters.extend(type_parameters);\n+\n+    region_parameters\n+}\n+\n+fn parameters_for_type_shallow<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n+    match ty.sty {\n+        ty::ty_param(ref d) =>\n+            vec![Parameter::Type(d.clone())],\n+        ty::ty_rptr(region, _) =>\n+            parameters_for_region(region).into_iter().collect(),\n+        ty::ty_struct(_, substs) |\n+        ty::ty_enum(_, substs) =>\n+            parameters_for_regions_in_substs(substs),\n+        ty::ty_trait(ref data) =>\n+            parameters_for_regions_in_substs(&data.principal.skip_binder().substs),\n+        _ =>\n+            vec![],\n+    }\n+}\n+\n+fn parameters_for_regions_in_substs(substs: &subst::Substs) -> Vec<Parameter> {\n+    substs.regions()\n+          .iter()\n+          .filter_map(|r| parameters_for_region(r))\n+          .collect()\n+}\n+\n+fn parameters_for_region(region: &ty::Region) -> Option<Parameter> {\n+    match *region {\n+        ty::ReEarlyBound(data) => Some(Parameter::Region(data)),\n+        _ => None,\n+    }\n+}\n+\n pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n                                               predicates: &[ty::Predicate<'tcx>],\n                                               impl_trait_ref: Option<Rc<ty::TraitRef<'tcx>>>,\n-                                              input_parameters: &mut HashSet<ty::ParamTy>)\n+                                              input_parameters: &mut HashSet<Parameter>)\n {\n     loop {\n         let num_inputs = input_parameters.len();\n \n-        let projection_predicates =\n+        let poly_projection_predicates = // : iterator over PolyProjectionPredicate\n             predicates.iter()\n                       .filter_map(|predicate| {\n                           match *predicate {\n-                              // Ignore higher-ranked binders. For the purposes\n-                              // of this check, they don't matter because they\n-                              // only affect named regions, and we're just\n-                              // concerned about type parameters here.\n-                              ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                              ty::Predicate::Projection(ref data) => Some(data.clone()),\n                               _ => None,\n                           }\n                       });\n \n-        for projection in projection_predicates {\n+        for poly_projection in poly_projection_predicates {\n+            // Note that we can skip binder here because the impl\n+            // trait ref never contains any late-bound regions.\n+            let projection = poly_projection.skip_binder();\n+\n             // Special case: watch out for some kind of sneaky attempt\n-            // to project out an associated type defined by this very trait.\n-            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n+            // to project out an associated type defined by this very\n+            // trait.\n+            let unbound_trait_ref = &projection.projection_ty.trait_ref;\n+            if Some(unbound_trait_ref.clone()) == impl_trait_ref {\n                 continue;\n             }\n \n-            let relies_only_on_inputs =\n-                projection.projection_ty.trait_ref.input_types()\n-                                                  .iter()\n-                                                  .flat_map(|t| t.walk())\n-                                                  .filter_map(|t| t.as_opt_param_ty())\n-                                                  .all(|t| input_parameters.contains(&t));\n-\n+            let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref);\n+            let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n             if relies_only_on_inputs {\n-                input_parameters.extend(\n-                    projection.ty.walk().filter_map(|t| t.as_opt_param_ty()));\n+                input_parameters.extend(parameters_for_type(projection.ty));\n             }\n         }\n "}, {"sha": "7575f12878a56c400709d9c837a484143449bbfd", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -1046,9 +1046,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region: ty::Region,\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n-            ty::ReEarlyBound(param_id, _, _, _) => {\n-                if self.is_to_be_inferred(param_id) {\n-                    let index = self.inferred_index(param_id);\n+            ty::ReEarlyBound(ref data) => {\n+                if self.is_to_be_inferred(data.param_id) {\n+                    let index = self.inferred_index(data.param_id);\n                     self.add_constraint(index, variance);\n                 }\n             }"}, {"sha": "23c9edde77c33ea423a1f26fde6fd932c13ea3bf", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -775,7 +775,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n                 Some(Lifetime(token::get_name(name).to_string())),\n-            ty::ReEarlyBound(_, _, _, name) => Some(Lifetime(name.clean(cx))),\n+            ty::ReEarlyBound(ref data) => Some(Lifetime(data.name.clean(cx))),\n \n             ty::ReLateBound(..) |\n             ty::ReFree(..) |"}, {"sha": "23401db21d89063643045ccf10d4fcac92783807", "filename": "src/test/compile-fail/impl-unused-rps-in-assoc-type.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Ftest%2Fcompile-fail%2Fimpl-unused-rps-in-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Ftest%2Fcompile-fail%2Fimpl-unused-rps-in-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-unused-rps-in-assoc-type.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that lifetime parameters must be constrained if they appear in\n+// an associated type def'n. Issue #22077.\n+\n+trait Fun {\n+    type Output;\n+    fn call<'x>(&'x self) -> Self::Output;\n+}\n+\n+struct Holder { x: String }\n+\n+impl<'a> Fun for Holder { //~ ERROR E0207\n+    type Output = &'a str;\n+    fn call<'b>(&'b self) -> &'b str {\n+        &self.x[..]\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "4aa2571cad0cc9418709407687ff5ba9ac19056d", "filename": "src/test/compile-fail/issue-22886.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Ftest%2Fcompile-fail%2Fissue-22886.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f305579e490a9fa046b1b7a14e62daf643e41865/src%2Ftest%2Fcompile-fail%2Fissue-22886.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22886.rs?ref=f305579e490a9fa046b1b7a14e62daf643e41865", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #22886.\n+\n+fn crash_please() {\n+    let mut iter = Newtype(Some(Box::new(0)));\n+    let saved = iter.next().unwrap();\n+    println!(\"{}\", saved);\n+    iter.0 = None;\n+    println!(\"{}\", saved);\n+}\n+\n+struct Newtype(Option<Box<usize>>);\n+\n+impl<'a> Iterator for Newtype { //~ ERROR E0207\n+    type Item = &'a Box<usize>;\n+\n+    fn next(&mut self) -> Option<&Box<usize>> {\n+        self.0.as_ref()\n+    }\n+}\n+\n+fn main() { }"}]}