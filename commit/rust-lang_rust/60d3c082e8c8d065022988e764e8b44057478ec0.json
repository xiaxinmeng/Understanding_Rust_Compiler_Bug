{"sha": "60d3c082e8c8d065022988e764e8b44057478ec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZDNjMDgyZThjOGQwNjUwMjI5ODhlNzY0ZThiNDQwNTc0NzhlYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-05T13:01:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-05T13:01:36Z"}, "message": "auto merge of #13331 : pongad/rust/remove-wrapper, r=thestinger\n\nFixes #12713", "tree": {"sha": "7c95c16612adacb3f507b82f365577856e50b3da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c95c16612adacb3f507b82f365577856e50b3da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60d3c082e8c8d065022988e764e8b44057478ec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60d3c082e8c8d065022988e764e8b44057478ec0", "html_url": "https://github.com/rust-lang/rust/commit/60d3c082e8c8d065022988e764e8b44057478ec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60d3c082e8c8d065022988e764e8b44057478ec0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7148592adde0b09d7bf34426e215c6c25fc7cd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7148592adde0b09d7bf34426e215c6c25fc7cd1", "html_url": "https://github.com/rust-lang/rust/commit/e7148592adde0b09d7bf34426e215c6c25fc7cd1"}, {"sha": "d27dd8251d42f04737b168f5694584af48228bf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27dd8251d42f04737b168f5694584af48228bf2", "html_url": "https://github.com/rust-lang/rust/commit/d27dd8251d42f04737b168f5694584af48228bf2"}], "stats": {"total": 289, "additions": 84, "deletions": 205}, "files": [{"sha": "7c5fe4ff274842c22687c30d22f4a4dcd9cdaffd", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 39, "deletions": 102, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/60d3c082e8c8d065022988e764e8b44057478ec0/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d3c082e8c8d065022988e764e8b44057478ec0/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=60d3c082e8c8d065022988e764e8b44057478ec0", "patch": "@@ -16,7 +16,7 @@ use prelude::*;\n \n use default::Default;\n use from_str::FromStr;\n-use libc::{c_float, c_int};\n+use libc::{c_int};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use num::{Zero, One, Bounded, strconv};\n use num;\n@@ -62,67 +62,6 @@ mod cmath {\n     }\n }\n \n-macro_rules! delegate(\n-    (\n-        $(\n-            fn $name:ident(\n-                $(\n-                    $arg:ident : $arg_ty:ty\n-                ),*\n-            ) -> $rv:ty = $bound_name:path\n-        ),*\n-    ) => (\n-        $(\n-            #[inline]\n-            pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n-                unsafe {\n-                    $bound_name($( $arg ),*)\n-                }\n-            }\n-        )*\n-    )\n-)\n-\n-delegate!(\n-    // intrinsics\n-    fn sqrt(n: f32) -> f32 = intrinsics::sqrtf32,\n-    fn powi(n: f32, e: i32) -> f32 = intrinsics::powif32,\n-    fn sin(n: f32) -> f32 = intrinsics::sinf32,\n-    fn cos(n: f32) -> f32 = intrinsics::cosf32,\n-    fn pow(n: f32, e: f32) -> f32 = intrinsics::powf32,\n-    fn exp(n: f32) -> f32 = intrinsics::expf32,\n-    fn exp2(n: f32) -> f32 = intrinsics::exp2f32,\n-    fn ln(n: f32) -> f32 = intrinsics::logf32,\n-    fn log10(n: f32) -> f32 = intrinsics::log10f32,\n-    fn log2(n: f32) -> f32 = intrinsics::log2f32,\n-    fn mul_add(a: f32, b: f32, c: f32) -> f32 = intrinsics::fmaf32,\n-    fn abs(n: f32) -> f32 = intrinsics::fabsf32,\n-    fn copysign(x: f32, y: f32) -> f32 = intrinsics::copysignf32,\n-    fn floor(x: f32) -> f32 = intrinsics::floorf32,\n-    fn ceil(n: f32) -> f32 = intrinsics::ceilf32,\n-    fn trunc(n: f32) -> f32 = intrinsics::truncf32,\n-    fn rint(n: f32) -> f32 = intrinsics::rintf32,\n-    fn nearbyint(n: f32) -> f32 = intrinsics::nearbyintf32,\n-    fn round(n: f32) -> f32 = intrinsics::roundf32,\n-\n-    fn acos(n: c_float) -> c_float = cmath::acosf,\n-    fn asin(n: c_float) -> c_float = cmath::asinf,\n-    fn atan(n: c_float) -> c_float = cmath::atanf,\n-    fn atan2(a: c_float, b: c_float) -> c_float = cmath::atan2f,\n-    fn cbrt(n: c_float) -> c_float = cmath::cbrtf,\n-    fn cosh(n: c_float) -> c_float = cmath::coshf,\n-    fn exp_m1(n: c_float) -> c_float = cmath::expm1f,\n-    fn abs_sub(a: c_float, b: c_float) -> c_float = cmath::fdimf,\n-    fn next_after(x: c_float, y: c_float) -> c_float = cmath::nextafterf,\n-    fn frexp(n: c_float, value: &mut c_int) -> c_float = cmath::frexpf,\n-    fn hypot(x: c_float, y: c_float) -> c_float = cmath::hypotf,\n-    fn ldexp(x: c_float, n: c_int) -> c_float = cmath::ldexpf,\n-    fn ln_1p(n: c_float) -> c_float = cmath::log1pf,\n-    fn sinh(n: c_float) -> c_float = cmath::sinhf,\n-    fn tan(n: c_float) -> c_float = cmath::tanf,\n-    fn tanh(n: c_float) -> c_float = cmath::tanhf\n-)\n-\n // FIXME(#11621): These constants should be deprecated once CTFE is implemented\n // in favour of calling their respective functions in `Bounded` and `Float`.\n \n@@ -274,12 +213,12 @@ impl Neg<f32> for f32 {\n impl Signed for f32 {\n     /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n     #[inline]\n-    fn abs(&self) -> f32 { abs(*self) }\n+    fn abs(&self) -> f32 { unsafe{intrinsics::fabsf32(*self)} }\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     #[inline]\n-    fn abs_sub(&self, other: &f32) -> f32 { abs_sub(*self, *other) }\n+    fn abs_sub(&self, other: &f32) -> f32 { unsafe{cmath::fdimf(*self, *other)} }\n \n     /// # Returns\n     ///\n@@ -288,7 +227,7 @@ impl Signed for f32 {\n     /// - `NAN` if the number is NaN\n     #[inline]\n     fn signum(&self) -> f32 {\n-        if self.is_nan() { NAN } else { copysign(1.0, *self) }\n+        if self.is_nan() { NAN } else { unsafe{intrinsics::copysignf32(1.0, *self)} }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n@@ -303,19 +242,19 @@ impl Signed for f32 {\n impl Round for f32 {\n     /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n-    fn floor(&self) -> f32 { floor(*self) }\n+    fn floor(&self) -> f32 { unsafe{intrinsics::floorf32(*self)} }\n \n     /// Round half-way cases toward `INFINITY`\n     #[inline]\n-    fn ceil(&self) -> f32 { ceil(*self) }\n+    fn ceil(&self) -> f32 { unsafe{intrinsics::ceilf32(*self)} }\n \n     /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn round(&self) -> f32 { round(*self) }\n+    fn round(&self) -> f32 { unsafe{intrinsics::roundf32(*self)} }\n \n     /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn trunc(&self) -> f32 { trunc(*self) }\n+    fn trunc(&self) -> f32 { unsafe{intrinsics::truncf32(*self)} }\n \n     /// The fractional part of the number, satisfying:\n     ///\n@@ -338,6 +277,8 @@ impl Bounded for f32 {\n impl Primitive for f32 {}\n \n impl Float for f32 {\n+    fn powi(&self, n: i32) -> f32 { unsafe{intrinsics::powif32(*self, n)} }\n+\n     #[inline]\n     fn max(self, other: f32) -> f32 {\n         unsafe { cmath::fmaxf(self, other) }\n@@ -421,44 +362,40 @@ impl Float for f32 {\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n-    fn ldexp(x: f32, exp: int) -> f32 {\n-        ldexp(x, exp as c_int)\n-    }\n+    fn ldexp(x: f32, exp: int) -> f32 { unsafe{cmath::ldexpf(x, exp as c_int)} }\n \n     /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n     fn frexp(&self) -> (f32, int) {\n-        let mut exp = 0;\n-        let x = frexp(*self, &mut exp);\n-        (x, exp as int)\n+        unsafe {\n+            let mut exp = 0;\n+            let x = cmath::frexpf(*self, &mut exp);\n+            (x, exp as int)\n+        }\n     }\n \n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     #[inline]\n-    fn exp_m1(&self) -> f32 { exp_m1(*self) }\n+    fn exp_m1(&self) -> f32 { unsafe{cmath::expm1f(*self)} }\n \n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     #[inline]\n-    fn ln_1p(&self) -> f32 { ln_1p(*self) }\n+    fn ln_1p(&self) -> f32 { unsafe{cmath::log1pf(*self)} }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     #[inline]\n-    fn mul_add(&self, a: f32, b: f32) -> f32 {\n-        mul_add(*self, a, b)\n-    }\n+    fn mul_add(&self, a: f32, b: f32) -> f32 { unsafe{intrinsics::fmaf32(*self, a, b)} }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n     #[inline]\n-    fn next_after(&self, other: f32) -> f32 {\n-        next_after(*self, other)\n-    }\n+    fn next_after(&self, other: f32) -> f32 { unsafe{cmath::nextafterf(*self, other)} }\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(&self) -> (u64, i16, i8) {\n@@ -550,40 +487,40 @@ impl Float for f32 {\n     fn recip(&self) -> f32 { 1.0 / *self }\n \n     #[inline]\n-    fn powf(&self, n: &f32) -> f32 { pow(*self, *n) }\n+    fn powf(&self, n: &f32) -> f32 { unsafe{intrinsics::powf32(*self, *n)} }\n \n     #[inline]\n-    fn sqrt(&self) -> f32 { sqrt(*self) }\n+    fn sqrt(&self) -> f32 { unsafe{intrinsics::sqrtf32(*self)} }\n \n     #[inline]\n     fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n \n     #[inline]\n-    fn cbrt(&self) -> f32 { cbrt(*self) }\n+    fn cbrt(&self) -> f32 { unsafe{cmath::cbrtf(*self)} }\n \n     #[inline]\n-    fn hypot(&self, other: &f32) -> f32 { hypot(*self, *other) }\n+    fn hypot(&self, other: &f32) -> f32 { unsafe{cmath::hypotf(*self, *other)} }\n \n     #[inline]\n-    fn sin(&self) -> f32 { sin(*self) }\n+    fn sin(&self) -> f32 { unsafe{intrinsics::sinf32(*self)} }\n \n     #[inline]\n-    fn cos(&self) -> f32 { cos(*self) }\n+    fn cos(&self) -> f32 { unsafe{intrinsics::cosf32(*self)} }\n \n     #[inline]\n-    fn tan(&self) -> f32 { tan(*self) }\n+    fn tan(&self) -> f32 { unsafe{cmath::tanf(*self)} }\n \n     #[inline]\n-    fn asin(&self) -> f32 { asin(*self) }\n+    fn asin(&self) -> f32 { unsafe{cmath::asinf(*self)} }\n \n     #[inline]\n-    fn acos(&self) -> f32 { acos(*self) }\n+    fn acos(&self) -> f32 { unsafe{cmath::acosf(*self)} }\n \n     #[inline]\n-    fn atan(&self) -> f32 { atan(*self) }\n+    fn atan(&self) -> f32 { unsafe{cmath::atanf(*self)} }\n \n     #[inline]\n-    fn atan2(&self, other: &f32) -> f32 { atan2(*self, *other) }\n+    fn atan2(&self, other: &f32) -> f32 { unsafe{cmath::atan2f(*self, *other)} }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline]\n@@ -593,36 +530,36 @@ impl Float for f32 {\n \n     /// Returns the exponential of the number\n     #[inline]\n-    fn exp(&self) -> f32 { exp(*self) }\n+    fn exp(&self) -> f32 { unsafe{intrinsics::expf32(*self)} }\n \n     /// Returns 2 raised to the power of the number\n     #[inline]\n-    fn exp2(&self) -> f32 { exp2(*self) }\n+    fn exp2(&self) -> f32 { unsafe{intrinsics::exp2f32(*self)} }\n \n     /// Returns the natural logarithm of the number\n     #[inline]\n-    fn ln(&self) -> f32 { ln(*self) }\n+    fn ln(&self) -> f32 { unsafe{intrinsics::logf32(*self)} }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline]\n     fn log(&self, base: &f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline]\n-    fn log2(&self) -> f32 { log2(*self) }\n+    fn log2(&self) -> f32 { unsafe{intrinsics::log2f32(*self)} }\n \n     /// Returns the base 10 logarithm of the number\n     #[inline]\n-    fn log10(&self) -> f32 { log10(*self) }\n+    fn log10(&self) -> f32 { unsafe{intrinsics::log10f32(*self)} }\n \n     #[inline]\n-    fn sinh(&self) -> f32 { sinh(*self) }\n+    fn sinh(&self) -> f32 { unsafe{cmath::sinhf(*self)} }\n \n     #[inline]\n-    fn cosh(&self) -> f32 { cosh(*self) }\n+    fn cosh(&self) -> f32 { unsafe{cmath::coshf(*self)} }\n \n     #[inline]\n-    fn tanh(&self) -> f32 { tanh(*self) }\n+    fn tanh(&self) -> f32 { unsafe{cmath::tanhf(*self)} }\n \n     /// Inverse hyperbolic sine\n     ///"}, {"sha": "69328a5ecdc111f6d9417f55db533514eb609379", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 40, "deletions": 103, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/60d3c082e8c8d065022988e764e8b44057478ec0/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d3c082e8c8d065022988e764e8b44057478ec0/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=60d3c082e8c8d065022988e764e8b44057478ec0", "patch": "@@ -16,7 +16,7 @@ use prelude::*;\n \n use default::Default;\n use from_str::FromStr;\n-use libc::{c_double, c_int};\n+use libc::{c_int};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use num::{Zero, One, Bounded, strconv};\n use num;\n@@ -71,68 +71,6 @@ mod cmath {\n     }\n }\n \n-\n-macro_rules! delegate(\n-    (\n-        $(\n-            fn $name:ident(\n-                $(\n-                    $arg:ident : $arg_ty:ty\n-                ),*\n-            ) -> $rv:ty = $bound_name:path\n-        ),*\n-    ) => (\n-        $(\n-            #[inline]\n-            pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n-                unsafe {\n-                    $bound_name($( $arg ),*)\n-                }\n-            }\n-        )*\n-    )\n-)\n-\n-delegate!(\n-    // intrinsics\n-    fn sqrt(n: f64) -> f64 = intrinsics::sqrtf64,\n-    fn powi(n: f64, e: i32) -> f64 = intrinsics::powif64,\n-    fn sin(n: f64) -> f64 = intrinsics::sinf64,\n-    fn cos(n: f64) -> f64 = intrinsics::cosf64,\n-    fn pow(n: f64, e: f64) -> f64 = intrinsics::powf64,\n-    fn exp(n: f64) -> f64 = intrinsics::expf64,\n-    fn exp2(n: f64) -> f64 = intrinsics::exp2f64,\n-    fn ln(n: f64) -> f64 = intrinsics::logf64,\n-    fn log10(n: f64) -> f64 = intrinsics::log10f64,\n-    fn log2(n: f64) -> f64 = intrinsics::log2f64,\n-    fn mul_add(a: f64, b: f64, c: f64) -> f64 = intrinsics::fmaf64,\n-    fn abs(n: f64) -> f64 = intrinsics::fabsf64,\n-    fn copysign(x: f64, y: f64) -> f64 = intrinsics::copysignf64,\n-    fn floor(x: f64) -> f64 = intrinsics::floorf64,\n-    fn ceil(n: f64) -> f64 = intrinsics::ceilf64,\n-    fn trunc(n: f64) -> f64 = intrinsics::truncf64,\n-    fn rint(n: f64) -> f64 = intrinsics::rintf64,\n-    fn nearbyint(n: f64) -> f64 = intrinsics::nearbyintf64,\n-    fn round(n: f64) -> f64 = intrinsics::roundf64,\n-\n-    fn acos(n: c_double) -> c_double = cmath::acos,\n-    fn asin(n: c_double) -> c_double = cmath::asin,\n-    fn atan(n: c_double) -> c_double = cmath::atan,\n-    fn atan2(a: c_double, b: c_double) -> c_double = cmath::atan2,\n-    fn cbrt(n: c_double) -> c_double = cmath::cbrt,\n-    fn cosh(n: c_double) -> c_double = cmath::cosh,\n-    fn exp_m1(n: c_double) -> c_double = cmath::expm1,\n-    fn abs_sub(a: c_double, b: c_double) -> c_double = cmath::fdim,\n-    fn next_after(x: c_double, y: c_double) -> c_double = cmath::nextafter,\n-    fn frexp(n: c_double, value: &mut c_int) -> c_double = cmath::frexp,\n-    fn hypot(x: c_double, y: c_double) -> c_double = cmath::hypot,\n-    fn ldexp(x: c_double, n: c_int) -> c_double = cmath::ldexp,\n-    fn ln_1p(n: c_double) -> c_double = cmath::log1p,\n-    fn sinh(n: c_double) -> c_double = cmath::sinh,\n-    fn tan(n: c_double) -> c_double = cmath::tan,\n-    fn tanh(n: c_double) -> c_double = cmath::tanh\n-)\n-\n // FIXME (#1433): obtain these in a different way\n \n // FIXME(#11621): These constants should be deprecated once CTFE is implemented\n@@ -283,12 +221,12 @@ impl Neg<f64> for f64 {\n impl Signed for f64 {\n     /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n     #[inline]\n-    fn abs(&self) -> f64 { abs(*self) }\n+    fn abs(&self) -> f64 { unsafe{intrinsics::fabsf64(*self)} }\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     #[inline]\n-    fn abs_sub(&self, other: &f64) -> f64 { abs_sub(*self, *other) }\n+    fn abs_sub(&self, other: &f64) -> f64 { unsafe{cmath::fdim(*self, *other)} }\n \n     /// # Returns\n     ///\n@@ -297,7 +235,7 @@ impl Signed for f64 {\n     /// - `NAN` if the number is NaN\n     #[inline]\n     fn signum(&self) -> f64 {\n-        if self.is_nan() { NAN } else { copysign(1.0, *self) }\n+        if self.is_nan() { NAN } else { unsafe{intrinsics::copysignf64(1.0, *self)} }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n@@ -312,19 +250,19 @@ impl Signed for f64 {\n impl Round for f64 {\n     /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n-    fn floor(&self) -> f64 { floor(*self) }\n+    fn floor(&self) -> f64 { unsafe{intrinsics::floorf64(*self)} }\n \n     /// Round half-way cases toward `INFINITY`\n     #[inline]\n-    fn ceil(&self) -> f64 { ceil(*self) }\n+    fn ceil(&self) -> f64 { unsafe{intrinsics::ceilf64(*self)} }\n \n     /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn round(&self) -> f64 { round(*self) }\n+    fn round(&self) -> f64 { unsafe{intrinsics::roundf64(*self)} }\n \n     /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn trunc(&self) -> f64 { trunc(*self) }\n+    fn trunc(&self) -> f64 { unsafe{intrinsics::truncf64(*self)} }\n \n     /// The fractional part of the number, satisfying:\n     ///\n@@ -430,44 +368,40 @@ impl Float for f64 {\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n-    fn ldexp(x: f64, exp: int) -> f64 {\n-        ldexp(x, exp as c_int)\n-    }\n+    fn ldexp(x: f64, exp: int) -> f64 { unsafe{cmath::ldexp(x, exp as c_int)} }\n \n     /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n     fn frexp(&self) -> (f64, int) {\n-        let mut exp = 0;\n-        let x = frexp(*self, &mut exp);\n-        (x, exp as int)\n+        unsafe {\n+            let mut exp = 0;\n+            let x = cmath::frexp(*self, &mut exp);\n+            (x, exp as int)\n+        }\n     }\n \n     /// Returns the exponential of the number, minus `1`, in a way that is accurate\n     /// even if the number is close to zero\n     #[inline]\n-    fn exp_m1(&self) -> f64 { exp_m1(*self) }\n+    fn exp_m1(&self) -> f64 { unsafe{cmath::expm1(*self)} }\n \n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n     /// than if the operations were performed separately\n     #[inline]\n-    fn ln_1p(&self) -> f64 { ln_1p(*self) }\n+    fn ln_1p(&self) -> f64 { unsafe{cmath::log1p(*self)} }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n     /// operation followed by an add.\n     #[inline]\n-    fn mul_add(&self, a: f64, b: f64) -> f64 {\n-        mul_add(*self, a, b)\n-    }\n+    fn mul_add(&self, a: f64, b: f64) -> f64 { unsafe{intrinsics::fmaf64(*self, a, b)} }\n \n     /// Returns the next representable floating-point value in the direction of `other`\n     #[inline]\n-    fn next_after(&self, other: f64) -> f64 {\n-        next_after(*self, other)\n-    }\n+    fn next_after(&self, other: f64) -> f64 { unsafe{cmath::nextafter(*self, other)} }\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(&self) -> (u64, i16, i8) {\n@@ -559,40 +493,43 @@ impl Float for f64 {\n     fn recip(&self) -> f64 { 1.0 / *self }\n \n     #[inline]\n-    fn powf(&self, n: &f64) -> f64 { pow(*self, *n) }\n+    fn powf(&self, n: &f64) -> f64 { unsafe{intrinsics::powf64(*self, *n)} }\n+\n+    #[inline]\n+    fn powi(&self, n: i32) -> f64 { unsafe{intrinsics::powif64(*self, n)} }\n \n     #[inline]\n-    fn sqrt(&self) -> f64 { sqrt(*self) }\n+    fn sqrt(&self) -> f64 { unsafe{intrinsics::sqrtf64(*self)} }\n \n     #[inline]\n     fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n \n     #[inline]\n-    fn cbrt(&self) -> f64 { cbrt(*self) }\n+    fn cbrt(&self) -> f64 { unsafe{cmath::cbrt(*self)} }\n \n     #[inline]\n-    fn hypot(&self, other: &f64) -> f64 { hypot(*self, *other) }\n+    fn hypot(&self, other: &f64) -> f64 { unsafe{cmath::hypot(*self, *other)} }\n \n     #[inline]\n-    fn sin(&self) -> f64 { sin(*self) }\n+    fn sin(&self) -> f64 { unsafe{intrinsics::sinf64(*self)} }\n \n     #[inline]\n-    fn cos(&self) -> f64 { cos(*self) }\n+    fn cos(&self) -> f64 { unsafe{intrinsics::cosf64(*self)} }\n \n     #[inline]\n-    fn tan(&self) -> f64 { tan(*self) }\n+    fn tan(&self) -> f64 { unsafe{cmath::tan(*self)} }\n \n     #[inline]\n-    fn asin(&self) -> f64 { asin(*self) }\n+    fn asin(&self) -> f64 { unsafe{cmath::asin(*self)} }\n \n     #[inline]\n-    fn acos(&self) -> f64 { acos(*self) }\n+    fn acos(&self) -> f64 { unsafe{cmath::acos(*self)} }\n \n     #[inline]\n-    fn atan(&self) -> f64 { atan(*self) }\n+    fn atan(&self) -> f64 { unsafe{cmath::atan(*self)} }\n \n     #[inline]\n-    fn atan2(&self, other: &f64) -> f64 { atan2(*self, *other) }\n+    fn atan2(&self, other: &f64) -> f64 { unsafe{cmath::atan2(*self, *other)} }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline]\n@@ -602,36 +539,36 @@ impl Float for f64 {\n \n     /// Returns the exponential of the number\n     #[inline]\n-    fn exp(&self) -> f64 { exp(*self) }\n+    fn exp(&self) -> f64 { unsafe{intrinsics::expf64(*self)} }\n \n     /// Returns 2 raised to the power of the number\n     #[inline]\n-    fn exp2(&self) -> f64 { exp2(*self) }\n+    fn exp2(&self) -> f64 { unsafe{intrinsics::exp2f64(*self)} }\n \n     /// Returns the natural logarithm of the number\n     #[inline]\n-    fn ln(&self) -> f64 { ln(*self) }\n+    fn ln(&self) -> f64 { unsafe{intrinsics::logf64(*self)} }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline]\n     fn log(&self, base: &f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline]\n-    fn log2(&self) -> f64 { log2(*self) }\n+    fn log2(&self) -> f64 { unsafe{intrinsics::log2f64(*self)} }\n \n     /// Returns the base 10 logarithm of the number\n     #[inline]\n-    fn log10(&self) -> f64 { log10(*self) }\n+    fn log10(&self) -> f64 { unsafe{intrinsics::log10f64(*self)} }\n \n     #[inline]\n-    fn sinh(&self) -> f64 { sinh(*self) }\n+    fn sinh(&self) -> f64 { unsafe{cmath::sinh(*self)} }\n \n     #[inline]\n-    fn cosh(&self) -> f64 { cosh(*self) }\n+    fn cosh(&self) -> f64 { unsafe{cmath::cosh(*self)} }\n \n     #[inline]\n-    fn tanh(&self) -> f64 { tanh(*self) }\n+    fn tanh(&self) -> f64 { unsafe{cmath::tanh(*self)} }\n \n     /// Inverse hyperbolic sine\n     ///"}, {"sha": "9d0b53f945fae4424b49ca9b20d79d7da52cde0b", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/60d3c082e8c8d065022988e764e8b44057478ec0/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d3c082e8c8d065022988e764e8b44057478ec0/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=60d3c082e8c8d065022988e764e8b44057478ec0", "patch": "@@ -486,6 +486,11 @@ pub trait Float: Signed + Round + Primitive {\n     /// Raise a number to a power.\n     fn powf(&self, n: &Self) -> Self;\n \n+    /// Raise a number to an integer power.\n+    ///\n+    /// Using this function is generally faster than using `powf`\n+    fn powi(&self, n: i32) -> Self;\n+\n     /// Take the square root of a number.\n     fn sqrt(&self) -> Self;\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`."}]}