{"sha": "9347bf498a9456ab14ec9d9efee25451e80a8642", "node_id": "C_kwDOAAsO6NoAKDkzNDdiZjQ5OGE5NDU2YWIxNGVjOWQ5ZWZlZTI1NDUxZTgwYTg2NDI", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-12-13T23:01:26Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:28Z"}, "message": "Additional cleanup\n\nThis cleans up the refactoring from the previous patch and cleans things\nup a bit. Each module has a clear entry point and everything else is\nprivate.", "tree": {"sha": "b6b88df501c6865bf221ade0431ac075ea272cde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6b88df501c6865bf221ade0431ac075ea272cde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9347bf498a9456ab14ec9d9efee25451e80a8642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9347bf498a9456ab14ec9d9efee25451e80a8642", "html_url": "https://github.com/rust-lang/rust/commit/9347bf498a9456ab14ec9d9efee25451e80a8642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9347bf498a9456ab14ec9d9efee25451e80a8642/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5f98d7ee43ae591afffffc34fc2efab48eef785", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f98d7ee43ae591afffffc34fc2efab48eef785", "html_url": "https://github.com/rust-lang/rust/commit/f5f98d7ee43ae591afffffc34fc2efab48eef785"}], "stats": {"total": 281, "additions": 151, "deletions": 130}, "files": [{"sha": "b200320b8d3b728b8c09d96c34d8d88569f41c86", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 9, "deletions": 85, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9347bf498a9456ab14ec9d9efee25451e80a8642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9347bf498a9456ab14ec9d9efee25451e80a8642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=9347bf498a9456ab14ec9d9efee25451e80a8642", "patch": "@@ -12,39 +12,33 @@\n //! The end result is a data structure that maps the post-order index of each node in the HIR tree\n //! to a set of values that are known to be dropped at that location.\n \n-use self::cfg_build::DropRangeVisitor;\n-use self::record_consumed_borrow::ExprUseDelegate;\n+use self::cfg_build::build_control_flow_graph;\n+use self::record_consumed_borrow::find_consumed_and_borrowed;\n use crate::check::FnCtxt;\n use hir::def_id::DefId;\n-use hir::{Body, HirId, HirIdMap, Node, intravisit};\n+use hir::{Body, HirId, HirIdMap, Node};\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::hir::map::Map;\n use std::collections::BTreeMap;\n use std::fmt::Debug;\n-use std::mem::swap;\n \n mod cfg_build;\n-mod record_consumed_borrow;\n mod cfg_propagate;\n mod cfg_visualize;\n+mod record_consumed_borrow;\n \n pub fn compute_drop_ranges<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     def_id: DefId,\n     body: &'tcx Body<'tcx>,\n ) -> DropRanges {\n-    let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx.hir());\n-    expr_use_visitor.consume_body(fcx, def_id, body);\n+    let consumed_borrowed_places = find_consumed_and_borrowed(fcx, def_id, body);\n \n-    let mut drop_range_visitor = DropRangeVisitor::from_uses(\n-        expr_use_visitor,\n-        fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0),\n-    );\n-    intravisit::walk_body(&mut drop_range_visitor, body);\n+    let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n+    let mut drop_ranges =\n+        build_control_flow_graph(fcx.tcx.hir(), consumed_borrowed_places, body, num_exprs);\n \n-    let mut drop_ranges = drop_range_visitor.into_drop_ranges();\n     drop_ranges.propagate_to_fixpoint();\n \n     drop_ranges\n@@ -105,31 +99,6 @@ impl Debug for DropRanges {\n /// (hir_id, post_order_id) -> bool, where a true value indicates that the value is definitely\n /// dropped at the point of the node identified by post_order_id.\n impl DropRanges {\n-    pub fn new(hir_ids: impl Iterator<Item = HirId>, hir: &Map<'_>, num_exprs: usize) -> Self {\n-        let mut hir_id_map = HirIdMap::<HirIdIndex>::default();\n-        let mut next = <_>::from(0u32);\n-        for hir_id in hir_ids {\n-            for_each_consumable(hir_id, hir.find(hir_id), |hir_id| {\n-                if !hir_id_map.contains_key(&hir_id) {\n-                    hir_id_map.insert(hir_id, next);\n-                    next = <_>::from(next.index() + 1);\n-                }\n-            });\n-        }\n-        debug!(\"hir_id_map: {:?}\", hir_id_map);\n-        let num_values = hir_id_map.len();\n-        Self {\n-            hir_id_map,\n-            nodes: IndexVec::from_fn_n(|_| NodeInfo::new(num_values), num_exprs + 1),\n-            deferred_edges: <_>::default(),\n-            post_order_map: <_>::default(),\n-        }\n-    }\n-\n-    fn hidx(&self, hir_id: HirId) -> HirIdIndex {\n-        *self.hir_id_map.get(&hir_id).unwrap()\n-    }\n-\n     pub fn is_dropped_at(&mut self, hir_id: HirId, location: usize) -> bool {\n         self.hir_id_map\n             .get(&hir_id)\n@@ -142,13 +111,6 @@ impl DropRanges {\n         self.hir_id_map.len()\n     }\n \n-    /// Adds an entry in the mapping from HirIds to PostOrderIds\n-    ///\n-    /// Needed so that `add_control_edge_hir_id` can work.\n-    pub fn add_node_mapping(&mut self, hir_id: HirId, post_order_id: usize) {\n-        self.post_order_map.insert(hir_id, post_order_id);\n-    }\n-\n     /// Returns a reference to the NodeInfo for a node, panicking if it does not exist\n     fn expect_node(&self, id: PostOrderId) -> &NodeInfo {\n         &self.nodes[id]\n@@ -160,48 +122,10 @@ impl DropRanges {\n         &mut self.nodes[id]\n     }\n \n-    pub fn add_control_edge(&mut self, from: usize, to: usize) {\n+    fn add_control_edge(&mut self, from: usize, to: usize) {\n         trace!(\"adding control edge from {} to {}\", from, to);\n         self.node_mut(from.into()).successors.push(to.into());\n     }\n-\n-    /// Like add_control_edge, but uses a hir_id as the target.\n-    ///\n-    /// This can be used for branches where we do not know the PostOrderId of the target yet,\n-    /// such as when handling `break` or `continue`.\n-    pub fn add_control_edge_hir_id(&mut self, from: usize, to: HirId) {\n-        self.deferred_edges.push((from, to));\n-    }\n-\n-    /// Looks up PostOrderId for any control edges added by HirId and adds a proper edge for them.\n-    ///\n-    /// Should be called after visiting the HIR but before solving the control flow, otherwise some\n-    /// edges will be missed.\n-    fn process_deferred_edges(&mut self) {\n-        let mut edges = vec![];\n-        swap(&mut edges, &mut self.deferred_edges);\n-        edges.into_iter().for_each(|(from, to)| {\n-            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n-            trace!(\"Adding deferred edge from {} to {}\", from, to);\n-            self.add_control_edge(from, to)\n-        });\n-    }\n-\n-    pub fn drop_at(&mut self, value: HirId, location: usize) {\n-        let value = self.hidx(value);\n-        self.node_mut(location.into()).drops.push(value);\n-    }\n-\n-    pub fn reinit_at(&mut self, value: HirId, location: usize) {\n-        let value = match self.hir_id_map.get(&value) {\n-            Some(value) => *value,\n-            // If there's no value, this is never consumed and therefore is never dropped. We can\n-            // ignore this.\n-            None => return,\n-        };\n-        self.node_mut(location.into()).reinits.push(value);\n-    }\n-\n }\n \n #[derive(Debug)]"}, {"sha": "e1f1b44283bbe8168ab818cabdccc5209b013399", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 89, "deletions": 25, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/9347bf498a9456ab14ec9d9efee25451e80a8642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9347bf498a9456ab14ec9d9efee25451e80a8642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=9347bf498a9456ab14ec9d9efee25451e80a8642", "patch": "@@ -1,51 +1,57 @@\n-use super::{for_each_consumable, record_consumed_borrow::ExprUseDelegate, DropRanges};\n+use super::{\n+    for_each_consumable, record_consumed_borrow::ConsumedAndBorrowedPlaces, DropRanges, HirIdIndex,\n+    NodeInfo,\n+};\n use hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n-    Expr, ExprKind, Guard, HirId, HirIdMap, HirIdSet,\n+    Body, Expr, ExprKind, Guard, HirId, HirIdMap,\n };\n use rustc_hir as hir;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n \n+/// Traverses the body to find the control flow graph and locations for the\n+/// relevant places are dropped or reinitialized.\n+///\n+/// The resulting structure still needs to be iterated to a fixed point, which\n+/// can be done with propagate_to_fixpoint in cfg_propagate.\n+pub fn build_control_flow_graph<'tcx>(\n+    hir: Map<'tcx>,\n+    consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n+    body: &'tcx Body<'tcx>,\n+    num_exprs: usize,\n+) -> DropRanges {\n+    let mut drop_range_visitor = DropRangeVisitor::new(hir, consumed_borrowed_places, num_exprs);\n+    intravisit::walk_body(&mut drop_range_visitor, body);\n+    drop_range_visitor.drop_ranges\n+}\n+\n /// This struct is used to gather the information for `DropRanges` to determine the regions of the\n /// HIR tree for which a value is dropped.\n ///\n /// We are interested in points where a variables is dropped or initialized, and the control flow\n /// of the code. We identify locations in code by their post-order traversal index, so it is\n /// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n-pub struct DropRangeVisitor<'tcx> {\n+struct DropRangeVisitor<'tcx> {\n     hir: Map<'tcx>,\n-    /// Maps a HirId to a set of HirIds that are dropped by that node.\n-    ///\n-    /// See also the more detailed comment on `ExprUseDelegate.consumed_places`.\n-    consumed_places: HirIdMap<HirIdSet>,\n-    borrowed_places: HirIdSet,\n+    places: ConsumedAndBorrowedPlaces,\n     drop_ranges: DropRanges,\n     expr_count: usize,\n }\n \n impl<'tcx> DropRangeVisitor<'tcx> {\n-    pub fn from_uses(uses: ExprUseDelegate<'tcx>, num_exprs: usize) -> Self {\n-        debug!(\"consumed_places: {:?}\", uses.consumed_places);\n+    fn new(hir: Map<'tcx>, places: ConsumedAndBorrowedPlaces, num_exprs: usize) -> Self {\n+        debug!(\"consumed_places: {:?}\", places.consumed);\n         let drop_ranges = DropRanges::new(\n-            uses.consumed_places.iter().flat_map(|(_, places)| places.iter().copied()),\n-            &uses.hir,\n+            places.consumed.iter().flat_map(|(_, places)| places.iter().copied()),\n+            hir,\n             num_exprs,\n         );\n-        Self {\n-            hir: uses.hir,\n-            consumed_places: uses.consumed_places,\n-            borrowed_places: uses.borrowed_places,\n-            drop_ranges,\n-            expr_count: 0,\n-        }\n-    }\n-\n-    pub fn into_drop_ranges(self) -> DropRanges {\n-        self.drop_ranges\n+        Self { hir, places, drop_ranges, expr_count: 0 }\n     }\n \n     fn record_drop(&mut self, hir_id: HirId) {\n-        if self.borrowed_places.contains(&hir_id) {\n+        if self.places.borrowed.contains(&hir_id) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n         } else {\n             debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n@@ -59,7 +65,8 @@ impl<'tcx> DropRangeVisitor<'tcx> {\n     fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n         debug!(\"consuming expr {:?}, count={}\", expr.hir_id, self.expr_count);\n         let places = self\n-            .consumed_places\n+            .places\n+            .consumed\n             .get(&expr.hir_id)\n             .map_or(vec![], |places| places.iter().cloned().collect());\n         for place in places {\n@@ -167,3 +174,60 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n         self.expr_count += 1;\n     }\n }\n+\n+impl DropRanges {\n+    fn new(hir_ids: impl Iterator<Item = HirId>, hir: Map<'_>, num_exprs: usize) -> Self {\n+        let mut hir_id_map = HirIdMap::<HirIdIndex>::default();\n+        let mut next = <_>::from(0u32);\n+        for hir_id in hir_ids {\n+            for_each_consumable(hir_id, hir.find(hir_id), |hir_id| {\n+                if !hir_id_map.contains_key(&hir_id) {\n+                    hir_id_map.insert(hir_id, next);\n+                    next = <_>::from(next.index() + 1);\n+                }\n+            });\n+        }\n+        debug!(\"hir_id_map: {:?}\", hir_id_map);\n+        let num_values = hir_id_map.len();\n+        Self {\n+            hir_id_map,\n+            nodes: IndexVec::from_fn_n(|_| NodeInfo::new(num_values), num_exprs + 1),\n+            deferred_edges: <_>::default(),\n+            post_order_map: <_>::default(),\n+        }\n+    }\n+\n+    fn hidx(&self, hir_id: HirId) -> HirIdIndex {\n+        *self.hir_id_map.get(&hir_id).unwrap()\n+    }\n+\n+    /// Adds an entry in the mapping from HirIds to PostOrderIds\n+    ///\n+    /// Needed so that `add_control_edge_hir_id` can work.\n+    fn add_node_mapping(&mut self, hir_id: HirId, post_order_id: usize) {\n+        self.post_order_map.insert(hir_id, post_order_id);\n+    }\n+\n+    /// Like add_control_edge, but uses a hir_id as the target.\n+    ///\n+    /// This can be used for branches where we do not know the PostOrderId of the target yet,\n+    /// such as when handling `break` or `continue`.\n+    fn add_control_edge_hir_id(&mut self, from: usize, to: HirId) {\n+        self.deferred_edges.push((from, to));\n+    }\n+\n+    fn drop_at(&mut self, value: HirId, location: usize) {\n+        let value = self.hidx(value);\n+        self.node_mut(location.into()).drops.push(value);\n+    }\n+\n+    fn reinit_at(&mut self, value: HirId, location: usize) {\n+        let value = match self.hir_id_map.get(&value) {\n+            Some(value) => *value,\n+            // If there's no value, this is never consumed and therefore is never dropped. We can\n+            // ignore this.\n+            None => return,\n+        };\n+        self.node_mut(location.into()).reinits.push(value);\n+    }\n+}"}, {"sha": "74ce762864e0f953adbf797f27b100f2114da7ee", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_propagate.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9347bf498a9456ab14ec9d9efee25451e80a8642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9347bf498a9456ab14ec9d9efee25451e80a8642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=9347bf498a9456ab14ec9d9efee25451e80a8642", "patch": "@@ -1,8 +1,7 @@\n-use std::collections::BTreeMap;\n-\n-use rustc_index::{bit_set::BitSet, vec::IndexVec};\n-\n use super::{DropRanges, PostOrderId};\n+use rustc_index::{bit_set::BitSet, vec::IndexVec};\n+use std::collections::BTreeMap;\n+use std::mem::swap;\n \n impl DropRanges {\n     pub fn propagate_to_fixpoint(&mut self) {\n@@ -64,4 +63,18 @@ impl DropRanges {\n         }\n         preds\n     }\n+\n+    /// Looks up PostOrderId for any control edges added by HirId and adds a proper edge for them.\n+    ///\n+    /// Should be called after visiting the HIR but before solving the control flow, otherwise some\n+    /// edges will be missed.\n+    fn process_deferred_edges(&mut self) {\n+        let mut edges = vec![];\n+        swap(&mut edges, &mut self.deferred_edges);\n+        edges.into_iter().for_each(|(from, to)| {\n+            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n+            trace!(\"Adding deferred edge from {} to {}\", from, to);\n+            self.add_control_edge(from, to)\n+        });\n+    }\n }"}, {"sha": "e8cee21168ab3a91c3bf7b769ed0408ea7db39dc", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9347bf498a9456ab14ec9d9efee25451e80a8642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9347bf498a9456ab14ec9d9efee25451e80a8642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=9347bf498a9456ab14ec9d9efee25451e80a8642", "patch": "@@ -2,38 +2,58 @@ use crate::{\n     check::FnCtxt,\n     expr_use_visitor::{self, ExprUseVisitor},\n };\n-use hir::{HirId, HirIdMap, HirIdSet, Body, def_id::DefId};\n+use hir::{def_id::DefId, Body, HirId, HirIdMap, HirIdSet};\n use rustc_hir as hir;\n use rustc_middle::hir::{\n     map::Map,\n     place::{Place, PlaceBase},\n };\n use rustc_middle::ty;\n \n-/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n-///\n-/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n-/// record the parent expression, which is the point where the drop actually takes place.\n-pub struct ExprUseDelegate<'tcx> {\n-    pub(super) hir: Map<'tcx>,\n+pub fn find_consumed_and_borrowed<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    def_id: DefId,\n+    body: &'tcx Body<'tcx>,\n+) -> ConsumedAndBorrowedPlaces {\n+    let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx.hir());\n+    expr_use_visitor.consume_body(fcx, def_id, body);\n+    expr_use_visitor.places\n+}\n+\n+pub struct ConsumedAndBorrowedPlaces {\n     /// Records the variables/expressions that are dropped by a given expression.\n     ///\n     /// The key is the hir-id of the expression, and the value is a set or hir-ids for variables\n     /// or values that are consumed by that expression.\n     ///\n     /// Note that this set excludes \"partial drops\" -- for example, a statement like `drop(x.y)` is\n     /// not considered a drop of `x`, although it would be a drop of `x.y`.\n-    pub(super) consumed_places: HirIdMap<HirIdSet>,\n+    pub consumed: HirIdMap<HirIdSet>,\n     /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n-    pub(super) borrowed_places: HirIdSet,\n+    pub borrowed: HirIdSet,\n+}\n+\n+/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n+///\n+/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n+/// record the parent expression, which is the point where the drop actually takes place.\n+struct ExprUseDelegate<'tcx> {\n+    hir: Map<'tcx>,\n+    places: ConsumedAndBorrowedPlaces,\n }\n \n impl<'tcx> ExprUseDelegate<'tcx> {\n-    pub fn new(hir: Map<'tcx>) -> Self {\n-        Self { hir, consumed_places: <_>::default(), borrowed_places: <_>::default() }\n+    fn new(hir: Map<'tcx>) -> Self {\n+        Self {\n+            hir,\n+            places: ConsumedAndBorrowedPlaces {\n+                consumed: <_>::default(),\n+                borrowed: <_>::default(),\n+            },\n+        }\n     }\n \n-    pub fn consume_body(\n+    fn consume_body(\n         &mut self,\n         fcx: &'_ FnCtxt<'_, 'tcx>,\n         def_id: DefId,\n@@ -51,10 +71,10 @@ impl<'tcx> ExprUseDelegate<'tcx> {\n     }\n \n     fn mark_consumed(&mut self, consumer: HirId, target: HirId) {\n-        if !self.consumed_places.contains_key(&consumer) {\n-            self.consumed_places.insert(consumer, <_>::default());\n+        if !self.places.consumed.contains_key(&consumer) {\n+            self.places.consumed.insert(consumer, <_>::default());\n         }\n-        self.consumed_places.get_mut(&consumer).map(|places| places.insert(target));\n+        self.places.consumed.get_mut(&consumer).map(|places| places.insert(target));\n     }\n }\n \n@@ -82,7 +102,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         _diag_expr_id: HirId,\n         _bk: rustc_middle::ty::BorrowKind,\n     ) {\n-        place_hir_id(&place_with_id.place).map(|place| self.borrowed_places.insert(place));\n+        place_hir_id(&place_with_id.place).map(|place| self.places.borrowed.insert(place));\n     }\n \n     fn mutate("}]}