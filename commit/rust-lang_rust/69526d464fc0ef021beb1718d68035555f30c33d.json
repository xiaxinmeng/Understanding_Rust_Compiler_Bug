{"sha": "69526d464fc0ef021beb1718d68035555f30c33d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NTI2ZDQ2NGZjMGVmMDIxYmViMTcxOGQ2ODAzNTU1NWYzMGMzM2Q=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-30T12:37:20Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-30T12:37:20Z"}, "message": "Implement some float simd intrinsics", "tree": {"sha": "e886a91fd757ce64b1ca4cd9989c1b714bcdb2f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e886a91fd757ce64b1ca4cd9989c1b714bcdb2f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69526d464fc0ef021beb1718d68035555f30c33d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69526d464fc0ef021beb1718d68035555f30c33d", "html_url": "https://github.com/rust-lang/rust/commit/69526d464fc0ef021beb1718d68035555f30c33d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69526d464fc0ef021beb1718d68035555f30c33d/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8691b8b8b6d88a51ee4783a8c704f052db479738", "url": "https://api.github.com/repos/rust-lang/rust/commits/8691b8b8b6d88a51ee4783a8c704f052db479738", "html_url": "https://github.com/rust-lang/rust/commit/8691b8b8b6d88a51ee4783a8c704f052db479738"}], "stats": {"total": 251, "additions": 187, "deletions": 64}, "files": [{"sha": "33523a12871aad94e06410d26a16f14696ec4c54", "filename": "example/std_example.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/69526d464fc0ef021beb1718d68035555f30c33d/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69526d464fc0ef021beb1718d68035555f30c33d/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=69526d464fc0ef021beb1718d68035555f30c33d", "patch": "@@ -1,5 +1,6 @@\n #![feature(core_intrinsics)]\n \n+use std::arch::x86_64::*;\n use std::io::Write;\n use std::intrinsics;\n \n@@ -52,8 +53,6 @@ fn main() {\n \n #[target_feature(enable = \"sse2\")]\n unsafe fn test_simd() {\n-    use std::arch::x86_64::*;\n-\n     let x = _mm_setzero_si128();\n     let y = _mm_set1_epi16(7);\n     let or = _mm_or_si128(x, y);\n@@ -67,15 +66,15 @@ unsafe fn test_simd() {\n     test_mm_slli_si128();\n     test_mm_movemask_epi8();\n     test_mm256_movemask_epi8();\n+    test_mm_add_epi8();\n+    test_mm_add_pd();\n \n     let mask1 = _mm_movemask_epi8(dbg!(_mm_setr_epi8(255u8 as i8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n     assert_eq!(mask1, 1);\n }\n \n #[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_slli_si128() {\n-    use std::arch::x86_64::*;\n-\n     #[rustfmt::skip]\n     let a = _mm_setr_epi8(\n         1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n@@ -116,8 +115,6 @@ unsafe fn test_mm_slli_si128() {\n \n #[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_movemask_epi8() {\n-    use std::arch::x86_64::*;\n-\n     #[rustfmt::skip]\n     let a = _mm_setr_epi8(\n         0b1000_0000u8 as i8, 0b0, 0b1000_0000u8 as i8, 0b01,\n@@ -131,20 +128,48 @@ unsafe fn test_mm_movemask_epi8() {\n \n #[target_feature(enable = \"avx2\")]\n unsafe fn test_mm256_movemask_epi8() {\n-    use std::arch::x86_64::*;\n-\n     let a = _mm256_set1_epi8(-1);\n     let r = _mm256_movemask_epi8(a);\n     let e = -1;\n     assert_eq!(r, e);\n }\n \n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_add_epi8() {\n+    let a = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+    #[rustfmt::skip]\n+    let b = _mm_setr_epi8(\n+        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+    );\n+    let r = _mm_add_epi8(a, b);\n+    #[rustfmt::skip]\n+    let e = _mm_setr_epi8(\n+        16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,\n+    );\n+    assert_eq_m128i(r, e);\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_add_pd() {\n+    let a = _mm_setr_pd(1.0, 2.0);\n+    let b = _mm_setr_pd(5.0, 10.0);\n+    let r = _mm_add_pd(a, b);\n+    assert_eq_m128d(r, _mm_setr_pd(6.0, 12.0));\n+}\n+\n fn assert_eq_m128i(x: std::arch::x86_64::__m128i, y: std::arch::x86_64::__m128i) {\n     unsafe {\n         assert_eq!(std::mem::transmute::<_, [u8; 16]>(x), std::mem::transmute::<_, [u8; 16]>(x));\n     }\n }\n \n+#[target_feature(enable = \"sse2\")]\n+pub unsafe fn assert_eq_m128d(a: __m128d, b: __m128d) {\n+    if _mm_movemask_pd(_mm_cmpeq_pd(a, b)) != 0b11 {\n+        panic!(\"{:?} != {:?}\", a, b);\n+    }\n+}\n+\n #[derive(PartialEq)]\n enum LoopState {\n     Continue(()),"}, {"sha": "c8fb2767f9a32618234a6baf648b655d064bd81c", "filename": "src/constant.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/69526d464fc0ef021beb1718d68035555f30c33d/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69526d464fc0ef021beb1718d68035555f30c33d/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=69526d464fc0ef021beb1718d68035555f30c33d", "patch": "@@ -88,7 +88,7 @@ pub fn trans_constant<'a, 'tcx: 'a>(\n }\n \n pub fn force_eval_const<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    fx: &FunctionCx<'a, 'tcx, impl Backend>,\n     const_: &'tcx Const,\n ) -> &'tcx Const<'tcx> {\n     match const_.val {\n@@ -422,3 +422,32 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for TransPlaceInterpreter {\n         Ok(())\n     }\n }\n+\n+pub fn mir_operand_get_const_val<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Backend>,\n+    operand: &Operand<'tcx>,\n+) -> Result<&'tcx Const<'tcx>, String> {\n+    let place = match operand {\n+        Operand::Copy(place) => place,\n+        Operand::Constant(const_) => return Ok(force_eval_const(fx, const_.literal)),\n+        _ => return Err(format!(\"{:?}\", operand)),\n+    };\n+\n+    assert!(place.projection.is_none());\n+    let static_ = match &place.base {\n+        PlaceBase::Static(static_) => {\n+            static_\n+        }\n+        PlaceBase::Local(_) => return Err(\"local\".to_string()),\n+    };\n+\n+    Ok(match &static_.kind {\n+        StaticKind::Static(_) => unimplemented!(),\n+        StaticKind::Promoted(promoted) => {\n+            fx.tcx.const_eval(ParamEnv::reveal_all().and(GlobalId {\n+                instance: fx.instance,\n+                promoted: Some(*promoted),\n+            })).unwrap()\n+        }\n+    })\n+}"}, {"sha": "a456cac1d747bf605545146971284a0a99e9802f", "filename": "src/intrinsics.rs", "status": "modified", "additions": 75, "deletions": 48, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/69526d464fc0ef021beb1718d68035555f30c33d/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69526d464fc0ef021beb1718d68035555f30c33d/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=69526d464fc0ef021beb1718d68035555f30c33d", "patch": "@@ -144,7 +144,7 @@ pub fn lane_type_and_count<'tcx>(\n     (lane_layout, lane_count)\n }\n \n-fn simd_for_each_lane<'tcx, B: Backend>(\n+pub fn simd_for_each_lane<'tcx, B: Backend>(\n     fx: &mut FunctionCx<'_, 'tcx, B>,\n     intrinsic: &str,\n     x: CValue<'tcx>,\n@@ -170,23 +170,37 @@ fn simd_for_each_lane<'tcx, B: Backend>(\n     }\n }\n \n-fn bool_to_zero_or_max_uint<'tcx>(\n+pub fn bool_to_zero_or_max_uint<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     layout: TyLayout<'tcx>,\n     val: Value,\n ) -> CValue<'tcx> {\n     let ty = fx.clif_type(layout.ty).unwrap();\n \n-    let zero = fx.bcx.ins().iconst(ty, 0);\n-    let max = fx.bcx.ins().iconst(ty, (u64::max_value() >> (64 - ty.bits())) as i64);\n-    let res = crate::common::codegen_select(&mut fx.bcx, val, max, zero);\n+    let int_ty = match ty {\n+        types::F32 => types::I32,\n+        types::F64 => types::I64,\n+        ty => ty,\n+    };\n+\n+    let zero = fx.bcx.ins().iconst(int_ty, 0);\n+    let max = fx.bcx.ins().iconst(int_ty, (u64::max_value() >> (64 - int_ty.bits())) as i64);\n+    let mut res = crate::common::codegen_select(&mut fx.bcx, val, max, zero);\n+\n+    if ty.is_float() {\n+        res = fx.bcx.ins().bitcast(ty, res);\n+    }\n+\n     CValue::by_val(res, layout)\n }\n \n macro_rules! simd_cmp {\n     ($fx:expr, $intrinsic:expr, $cc:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, _lane_layout, res_lane_layout, x_lane, y_lane| {\n-            let res_lane = fx.bcx.ins().icmp(IntCC::$cc, x_lane, y_lane);\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc, x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n             bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n         });\n     };\n@@ -203,10 +217,13 @@ macro_rules! simd_cmp {\n \n }\n \n-macro_rules! simd_binop {\n+macro_rules! simd_int_binop {\n     ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, _lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = fx.bcx.ins().$op(x_lane, y_lane);\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n             CValue::by_val(res_lane, ret_lane_layout)\n         });\n     };\n@@ -222,6 +239,42 @@ macro_rules! simd_binop {\n     };\n }\n \n+macro_rules! simd_int_flt_binop {\n+    ($fx:expr, $intrinsic:expr, $op:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    };\n+    ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n+                ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n+                ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    };\n+}\n+\n+macro_rules! simd_flt_binop {\n+    ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    }\n+}\n+\n pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     def_id: DefId,\n@@ -840,30 +893,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n \n             let indexes = {\n                 use rustc::mir::interpret::*;\n-                let idx_place = match idx {\n-                    Operand::Copy(idx_place) => {\n-                        idx_place\n-                    }\n-                    _ => panic!(\"simd_shuffle* idx is not Operand::Copy, but {:?}\", idx),\n-                };\n-\n-                assert!(idx_place.projection.is_none());\n-                let static_ = match &idx_place.base {\n-                    PlaceBase::Static(static_) => {\n-                        static_\n-                    }\n-                    PlaceBase::Local(_) => panic!(\"simd_shuffle* idx is not constant, but a local\"),\n-                };\n-\n-                let idx_const = match &static_.kind {\n-                    StaticKind::Static(_) => unimplemented!(),\n-                    StaticKind::Promoted(promoted) => {\n-                        fx.tcx.const_eval(ParamEnv::reveal_all().and(GlobalId {\n-                            instance: fx.instance,\n-                            promoted: Some(*promoted),\n-                        })).unwrap()\n-                    }\n-                };\n+                let idx_const = crate::constant::mir_operand_get_const_val(fx, idx).expect(\"simd_shuffle* idx not const\");\n \n                 let idx_bytes = match idx_const.val {\n                     ConstValue::ByRef { align: _, offset, alloc } => {\n@@ -900,41 +930,38 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n \n         simd_add, (c x, c y) {\n-            simd_binop!(fx, intrinsic, iadd(x, y) -> ret);\n+            simd_int_flt_binop!(fx, intrinsic, iadd|fadd(x, y) -> ret);\n         };\n         simd_sub, (c x, c y) {\n-            simd_binop!(fx, intrinsic, isub(x, y) -> ret);\n+            simd_int_flt_binop!(fx, intrinsic, isub|fsub(x, y) -> ret);\n         };\n         simd_mul, (c x, c y) {\n-            simd_binop!(fx, intrinsic, imul(x, y) -> ret);\n+            simd_int_flt_binop!(fx, intrinsic, imul|fmul(x, y) -> ret);\n         };\n         simd_div, (c x, c y) {\n-            simd_binop!(fx, intrinsic, udiv|sdiv(x, y) -> ret);\n-        };\n-        simd_rem, (c x, c y) {\n-            simd_binop!(fx, intrinsic, urem|srem(x, y) -> ret);\n+            simd_int_flt_binop!(fx, intrinsic, udiv|sdiv|fdiv(x, y) -> ret);\n         };\n         simd_shl, (c x, c y) {\n-            simd_binop!(fx, intrinsic, ishl(x, y) -> ret);\n+            simd_int_binop!(fx, intrinsic, ishl(x, y) -> ret);\n         };\n         simd_shr, (c x, c y) {\n-            simd_binop!(fx, intrinsic, ushr|sshr(x, y) -> ret);\n+            simd_int_binop!(fx, intrinsic, ushr|sshr(x, y) -> ret);\n         };\n         simd_and, (c x, c y) {\n-            simd_binop!(fx, intrinsic, band(x, y) -> ret);\n+            simd_int_binop!(fx, intrinsic, band(x, y) -> ret);\n         };\n         simd_or, (c x, c y) {\n-            simd_binop!(fx, intrinsic, bor(x, y) -> ret);\n+            simd_int_binop!(fx, intrinsic, bor(x, y) -> ret);\n         };\n         simd_xor, (c x, c y) {\n-            simd_binop!(fx, intrinsic, bxor(x, y) -> ret);\n+            simd_int_binop!(fx, intrinsic, bxor(x, y) -> ret);\n         };\n \n         simd_fmin, (c x, c y) {\n-            simd_binop!(fx, intrinsic, fmin(x, y) -> ret);\n+            simd_flt_binop!(fx, intrinsic, fmin(x, y) -> ret);\n         };\n         simd_fmax, (c x, c y) {\n-            simd_binop!(fx, intrinsic, fmax(x, y) -> ret);\n+            simd_flt_binop!(fx, intrinsic, fmax(x, y) -> ret);\n         };\n     }\n "}, {"sha": "284bdee52b8cefc9c75b3cec01c9685ff5736f83", "filename": "src/llvm_intrinsics.rs", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/69526d464fc0ef021beb1718d68035555f30c33d/src%2Fllvm_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69526d464fc0ef021beb1718d68035555f30c33d/src%2Fllvm_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm_intrinsics.rs?ref=69526d464fc0ef021beb1718d68035555f30c33d", "patch": "@@ -1,4 +1,5 @@\n use crate::prelude::*;\n+use crate::intrinsics::*;\n \n use rustc::ty::subst::SubstsRef;\n \n@@ -26,32 +27,73 @@ pub fn codegen_llvm_intrinsic_call<'a, 'tcx: 'a>(\n         }\n     };\n \n-    crate::intrinsics::intrinsic_match! {\n+    intrinsic_match! {\n         fx, intrinsic, substs, args,\n         _ => {\n             fx.tcx.sess.warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n         };\n \n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n-        llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb, (c a) {\n-            let (lane_layout, lane_count) = crate::intrinsics::lane_type_and_count(fx, a.layout(), intrinsic);\n-            assert_eq!(lane_layout.ty.sty, fx.tcx.types.i8.sty);\n-            assert!(lane_count == 16 || lane_count == 32);\n+        llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n+            let (lane_layout, lane_count) = lane_type_and_count(fx, a.layout(), intrinsic);\n+            let lane_ty = fx.clif_type(lane_layout.ty).unwrap();\n+            assert!(lane_count <= 32);\n \n             let mut res = fx.bcx.ins().iconst(types::I32, 0);\n \n             for lane in (0..lane_count).rev() {\n                 let a_lane = a.value_field(fx, mir::Field::new(lane.try_into().unwrap())).load_scalar(fx);\n-                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, 7); // extract sign bit of 8bit int\n-                let a_lane_sign = fx.bcx.ins().uextend(types::I32, a_lane_sign);\n+\n+                // cast float to int\n+                let a_lane = match lane_ty {\n+                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n+                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n+                    _ => a_lane,\n+                };\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, types::I32, false);\n                 res = fx.bcx.ins().ishl_imm(res, 1);\n                 res = fx.bcx.ins().bor(res, a_lane_sign);\n             }\n \n             let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n             ret.write_cvalue(fx, res);\n         };\n+        llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n+            let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n+            let flt_cc = match kind_const.val.try_to_bits(Size::from_bytes(1)).expect(&format!(\"kind not scalar: {:?}\", kind_const)) {\n+                0 => FloatCC::Equal,\n+                1 => FloatCC::LessThan,\n+                2 => FloatCC::LessThanOrEqual,\n+                7 => {\n+                    unimplemented!(\"Compares corresponding elements in `a` and `b` to see if neither is `NaN`.\");\n+                }\n+                3 => {\n+                    unimplemented!(\"Compares corresponding elements in `a` and `b` to see if either is `NaN`.\");\n+                }\n+                4 => FloatCC::NotEqual,\n+                5 => {\n+                    unimplemented!(\"not less than\");\n+                }\n+                6 => {\n+                    unimplemented!(\"not less than or equal\");\n+                }\n+                kind => unreachable!(\"kind {:?}\", kind),\n+            };\n+\n+            simd_for_each_lane(fx, intrinsic, x, y, ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+            });\n+        };\n     }\n \n     if let Some((_, dest)) = destination {"}]}