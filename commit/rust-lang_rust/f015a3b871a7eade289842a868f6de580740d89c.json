{"sha": "f015a3b871a7eade289842a868f6de580740d89c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMTVhM2I4NzFhN2VhZGUyODk4NDJhODY4ZjZkZTU4MDc0MGQ4OWM=", "commit": {"author": {"name": "Oliver 'ker' Schneider", "email": "rust19446194516@oli-obk.de", "date": "2015-01-10T09:14:19Z"}, "committer": {"name": "Oliver Schneider", "email": "git1984941651981@oli-obk.de", "date": "2015-01-19T13:22:15Z"}, "message": "json-encoder: report error when hash map key is not string or numeric", "tree": {"sha": "78f6c7ab1152bfd8e4ad893f3500732cfe39b301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78f6c7ab1152bfd8e4ad893f3500732cfe39b301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f015a3b871a7eade289842a868f6de580740d89c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f015a3b871a7eade289842a868f6de580740d89c", "html_url": "https://github.com/rust-lang/rust/commit/f015a3b871a7eade289842a868f6de580740d89c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f015a3b871a7eade289842a868f6de580740d89c/comments", "author": null, "committer": null, "parents": [{"sha": "bd8a43c668ba93d29e9671c0c8dc6b67428bf492", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd8a43c668ba93d29e9671c0c8dc6b67428bf492", "html_url": "https://github.com/rust-lang/rust/commit/bd8a43c668ba93d29e9671c0c8dc6b67428bf492"}], "stats": {"total": 232, "additions": 154, "deletions": 78}, "files": [{"sha": "bfc0143c6891b46ada4dcf975067e1e22f320c19", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 154, "deletions": 78, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/f015a3b871a7eade289842a868f6de580740d89c/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f015a3b871a7eade289842a868f6de580740d89c/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=f015a3b871a7eade289842a868f6de580740d89c", "patch": "@@ -202,7 +202,7 @@ use self::InternalStackElement::*;\n use std;\n use std::collections::{HashMap, BTreeMap};\n use std::{char, f64, fmt, io, num, str};\n-use std::mem::{swap, transmute};\n+use std::mem::{swap};\n use std::num::{Float, Int};\n use std::num::FpCategory as Fp;\n use std::str::FromStr;\n@@ -275,6 +275,12 @@ pub enum DecoderError {\n     ApplicationError(string::String)\n }\n \n+#[derive(Copy, Show)]\n+pub enum EncoderError {\n+    FmtError(fmt::Error),\n+    BadHashmapKey,\n+}\n+\n /// Returns a readable error string for a given error code.\n pub fn error_str(error: ErrorCode) -> &'static str {\n     match error {\n@@ -334,10 +340,19 @@ impl std::error::Error for DecoderError {\n     fn detail(&self) -> Option<std::string::String> { Some(format!(\"{:?}\", self)) }\n }\n \n-pub type EncodeResult = fmt::Result;\n+impl std::error::Error for EncoderError {\n+    fn description(&self) -> &str { \"encoder error\" }\n+    fn detail(&self) -> Option<std::string::String> { Some(format!(\"{:?}\", self)) }\n+}\n+\n+impl std::error::FromError<fmt::Error> for EncoderError {\n+    fn from_error(err: fmt::Error) -> EncoderError { EncoderError::FmtError(err) }\n+}\n+\n+pub type EncodeResult = Result<(), EncoderError>;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n-fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n+fn escape_str(wr: &mut fmt::Writer, v: &str) -> EncodeResult {\n     try!(wr.write_str(\"\\\"\"));\n \n     let mut start = 0;\n@@ -395,17 +410,18 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n         try!(wr.write_str(&v[start..]));\n     }\n \n-    wr.write_str(\"\\\"\")\n+    try!(wr.write_str(\"\\\"\"));\n+    Ok(())\n }\n \n-fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n+fn escape_char(writer: &mut fmt::Writer, v: char) -> EncodeResult {\n     let mut buf = [0; 4];\n     let n = v.encode_utf8(&mut buf).unwrap();\n     let buf = unsafe { str::from_utf8_unchecked(&buf[..n]) };\n     escape_str(writer, buf)\n }\n \n-fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n+fn spaces(wr: &mut fmt::Writer, mut n: uint) -> EncodeResult {\n     const BUF: &'static str = \"                \";\n \n     while n >= BUF.len() {\n@@ -414,10 +430,9 @@ fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n     }\n \n     if n > 0 {\n-        wr.write_str(&BUF[..n])\n-    } else {\n-        Ok(())\n+        try!(wr.write_str(&BUF[..n]));\n     }\n+    Ok(())\n }\n \n fn fmt_number_or_null(v: f64) -> string::String {\n@@ -431,43 +446,62 @@ fn fmt_number_or_null(v: f64) -> string::String {\n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n     writer: &'a mut (fmt::Writer+'a),\n+    is_emitting_map_key: bool,\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n     pub fn new(writer: &'a mut fmt::Writer) -> Encoder<'a> {\n-        Encoder { writer: writer }\n+        Encoder { writer: writer, is_emitting_map_key: false, }\n+    }\n+}\n+\n+macro_rules! emit_enquoted_if_mapkey {\n+    ($enc:ident,$e:expr) => {\n+        if $enc.is_emitting_map_key {\n+            try!(write!($enc.writer, \"\\\"{}\\\"\", $e));\n+            Ok(())\n+        } else {\n+            try!(write!($enc.writer, \"{}\", $e));\n+            Ok(())\n+        }\n     }\n }\n \n impl<'a> ::Encoder for Encoder<'a> {\n-    type Error = fmt::Error;\n+    type Error = EncoderError;\n \n-    fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n+    fn emit_nil(&mut self) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n+        try!(write!(self.writer, \"null\"));\n+        Ok(())\n+    }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if v {\n-            write!(self.writer, \"true\")\n+            try!(write!(self.writer, \"true\"));\n         } else {\n-            write!(self.writer, \"false\")\n+            try!(write!(self.writer, \"false\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.writer, \"{}\", fmt_number_or_null(v))\n+        emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n         self.emit_f64(v as f64)\n@@ -483,6 +517,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n@@ -496,20 +531,23 @@ impl<'a> ::Encoder for Encoder<'a> {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n             try!(write!(self.writer, \"{{\\\"variant\\\":\"));\n             try!(escape_str(self.writer, name));\n             try!(write!(self.writer, \",\\\"fields\\\":[\"));\n             try!(f(self));\n-            write!(self.writer, \"]}}\")\n+            try!(write!(self.writer, \"]}}\"));\n+            Ok(())\n         }\n     }\n \n     fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n             try!(write!(self.writer, \",\"));\n         }\n@@ -523,6 +561,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n                                    f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n@@ -532,20 +571,24 @@ impl<'a> ::Encoder for Encoder<'a> {\n                                          f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n     fn emit_struct<F>(&mut self, _: &str, _: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n-        write!(self.writer, \"}}\")\n+        try!(write!(self.writer, \"}}\"));\n+        Ok(())\n     }\n \n     fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 { try!(write!(self.writer, \",\")); }\n         try!(escape_str(self.writer, name));\n         try!(write!(self.writer, \":\"));\n@@ -555,48 +598,60 @@ impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct<F>(&mut self, _name: &str, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n-    fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n+    fn emit_option_none(&mut self) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n+        self.emit_nil()\n+    }\n     fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n     fn emit_seq<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \"[\"));\n         try!(f(self));\n-        write!(self.writer, \"]\")\n+        try!(write!(self.writer, \"]\"));\n+        Ok(())\n     }\n \n     fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n             try!(write!(self.writer, \",\"));\n         }\n@@ -606,34 +661,28 @@ impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_map<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n-        write!(self.writer, \"}}\")\n+        try!(write!(self.writer, \"}}\"));\n+        Ok(())\n     }\n \n     fn emit_map_elt_key<F>(&mut self, idx: uint, mut f: F) -> EncodeResult where\n         F: FnMut(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 { try!(write!(self.writer, \",\")) }\n-        // ref #12967, make sure to wrap a key in double quotes,\n-        // in the event that its of a type that omits them (eg numbers)\n-        let mut buf = Vec::new();\n-        // FIXME(14302) remove the transmute and unsafe block.\n-        unsafe {\n-            let mut check_encoder = Encoder::new(&mut buf);\n-            try!(f(transmute(&mut check_encoder)));\n-        }\n-        let out = str::from_utf8(&buf[]).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n+        self.is_emitting_map_key = true;\n         try!(f(self));\n-        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n+        self.is_emitting_map_key = false;\n         Ok(())\n     }\n \n     fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \":\"));\n         f(self)\n     }\n@@ -645,12 +694,18 @@ pub struct PrettyEncoder<'a> {\n     writer: &'a mut (fmt::Writer+'a),\n     curr_indent: uint,\n     indent: uint,\n+    is_emitting_map_key: bool,\n }\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n     pub fn new(writer: &'a mut fmt::Writer) -> PrettyEncoder<'a> {\n-        PrettyEncoder { writer: writer, curr_indent: 0, indent: 2, }\n+        PrettyEncoder {\n+            writer: writer,\n+            curr_indent: 0,\n+            indent: 2,\n+            is_emitting_map_key: false,\n+        }\n     }\n \n     /// Set the number of spaces to indent for each level.\n@@ -664,32 +719,38 @@ impl<'a> PrettyEncoder<'a> {\n }\n \n impl<'a> ::Encoder for PrettyEncoder<'a> {\n-    type Error = fmt::Error;\n+    type Error = EncoderError;\n \n-    fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n+    fn emit_nil(&mut self) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n+        try!(write!(self.writer, \"null\"));\n+        Ok(())\n+    }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if v {\n-            write!(self.writer, \"true\")\n+            try!(write!(self.writer, \"true\"));\n         } else {\n-            write!(self.writer, \"false\")\n+            try!(write!(self.writer, \"false\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.writer, \"{}\", fmt_number_or_null(v))\n+        emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n         self.emit_f64(v as f64)\n@@ -705,6 +766,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n@@ -716,6 +778,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n                             -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n@@ -735,13 +798,15 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"]\\n\"));\n             try!(spaces(self.writer, self.curr_indent));\n-            write!(self.writer, \"}}\")\n+            try!(write!(self.writer, \"}}\"));\n+            Ok(())\n         }\n     }\n \n     fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n             try!(write!(self.writer, \",\\n\"));\n         }\n@@ -756,6 +821,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n                                    f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n@@ -765,29 +831,33 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n                                          f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n     fn emit_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            write!(self.writer, \"{{}}\")\n+            try!(write!(self.writer, \"{{}}\"));\n         } else {\n             try!(write!(self.writer, \"{{\"));\n             self.curr_indent += self.indent;\n             try!(f(self));\n             self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n             try!(spaces(self.writer, self.curr_indent));\n-            write!(self.writer, \"}}\")\n+            try!(write!(self.writer, \"}}\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -802,56 +872,68 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n-    fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n+    fn emit_option_none(&mut self) -> EncodeResult {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n+        self.emit_nil()\n+    }\n     fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         f(self)\n     }\n \n     fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            write!(self.writer, \"[]\")\n+            try!(write!(self.writer, \"[]\"));\n         } else {\n             try!(write!(self.writer, \"[\"));\n             self.curr_indent += self.indent;\n             try!(f(self));\n             self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n             try!(spaces(self.writer, self.curr_indent));\n-            write!(self.writer, \"]\")\n+            try!(write!(self.writer, \"]\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -864,47 +946,41 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            write!(self.writer, \"{{}}\")\n+            try!(write!(self.writer, \"{{}}\"));\n         } else {\n             try!(write!(self.writer, \"{{\"));\n             self.curr_indent += self.indent;\n             try!(f(self));\n             self.curr_indent -= self.indent;\n             try!(write!(self.writer, \"\\n\"));\n             try!(spaces(self.writer, self.curr_indent));\n-            write!(self.writer, \"}}\")\n+            try!(write!(self.writer, \"}}\"));\n         }\n+        Ok(())\n     }\n \n     fn emit_map_elt_key<F>(&mut self, idx: uint, mut f: F) -> EncodeResult where\n         F: FnMut(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n         try!(spaces(self.writer, self.curr_indent));\n-        // ref #12967, make sure to wrap a key in double quotes,\n-        // in the event that its of a type that omits them (eg numbers)\n-        let mut buf = Vec::new();\n-        // FIXME(14302) remove the transmute and unsafe block.\n-        unsafe {\n-            let mut check_encoder = PrettyEncoder::new(&mut buf);\n-            try!(f(transmute(&mut check_encoder)));\n-        }\n-        let out = str::from_utf8(&buf[]).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n+        self.is_emitting_map_key = true;\n         try!(f(self));\n-        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n+        self.is_emitting_map_key = false;\n         Ok(())\n     }\n \n     fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n+        if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         try!(write!(self.writer, \": \"));\n         f(self)\n     }"}]}