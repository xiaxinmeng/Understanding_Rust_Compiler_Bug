{"sha": "ee79bfa18affe95959a5f9a036c17bbd77979e21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNzliZmExOGFmZmU5NTk1OWE1ZjlhMDM2YzE3YmJkNzc5NzllMjE=", "commit": {"author": {"name": "Brian Campbell", "email": "lambda@continuation.org", "date": "2016-01-31T23:30:32Z"}, "committer": {"name": "Brian Campbell", "email": "lambda@continuation.org", "date": "2016-02-06T01:41:18Z"}, "message": "Abort on stack overflow instead of re-raising SIGSEGV\n\nWe use guard pages that cause the process to abort to protect against\nundefined behavior in the event of stack overflow.  We have a handler\nthat catches segfaults, prints out an error message if the segfault was\ndue to a stack overflow, then unregisters itself and returns to allow\nthe signal to be re-raised and kill the process.\n\nThis caused some confusion, as it was unexpected that safe code would be\nable to cause a segfault, while it's easy to overflow the stack in safe\ncode.  To avoid this confusion, when we detect a segfault in the guard\npage, abort instead of the previous behavior of re-raising the SIGSEGV.\n\nTo test this, we need to adapt the tests for segfault to actually check\nthe exit status.  Doing so revealed that the existing test for segfault\nbehavior was actually invalid; LLVM optimizes the explicit null pointer\nreference down to an illegal instruction, so the program aborts with\nSIGILL instead of SIGSEGV and the test didn't actually trigger the\nsignal handler at all.  Use a C helper function to get a null pointer\nthat LLVM can't optimize away, so we get our segfault instead.\n\nThis is a [breaking-change] if anyone is relying on the exact signal\nraised to kill a process on stack overflow.\n\nCloses #31273", "tree": {"sha": "3a34c04d7cddb6a79afad023a91050e250e1f565", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a34c04d7cddb6a79afad023a91050e250e1f565"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee79bfa18affe95959a5f9a036c17bbd77979e21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee79bfa18affe95959a5f9a036c17bbd77979e21", "html_url": "https://github.com/rust-lang/rust/commit/ee79bfa18affe95959a5f9a036c17bbd77979e21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee79bfa18affe95959a5f9a036c17bbd77979e21/comments", "author": {"login": "lambda", "id": 37398, "node_id": "MDQ6VXNlcjM3Mzk4", "avatar_url": "https://avatars.githubusercontent.com/u/37398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lambda", "html_url": "https://github.com/lambda", "followers_url": "https://api.github.com/users/lambda/followers", "following_url": "https://api.github.com/users/lambda/following{/other_user}", "gists_url": "https://api.github.com/users/lambda/gists{/gist_id}", "starred_url": "https://api.github.com/users/lambda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lambda/subscriptions", "organizations_url": "https://api.github.com/users/lambda/orgs", "repos_url": "https://api.github.com/users/lambda/repos", "events_url": "https://api.github.com/users/lambda/events{/privacy}", "received_events_url": "https://api.github.com/users/lambda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lambda", "id": 37398, "node_id": "MDQ6VXNlcjM3Mzk4", "avatar_url": "https://avatars.githubusercontent.com/u/37398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lambda", "html_url": "https://github.com/lambda", "followers_url": "https://api.github.com/users/lambda/followers", "following_url": "https://api.github.com/users/lambda/following{/other_user}", "gists_url": "https://api.github.com/users/lambda/gists{/gist_id}", "starred_url": "https://api.github.com/users/lambda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lambda/subscriptions", "organizations_url": "https://api.github.com/users/lambda/orgs", "repos_url": "https://api.github.com/users/lambda/repos", "events_url": "https://api.github.com/users/lambda/events{/privacy}", "received_events_url": "https://api.github.com/users/lambda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303892ee156e5c31222b10786e661abb24dcf241", "url": "https://api.github.com/repos/rust-lang/rust/commits/303892ee156e5c31222b10786e661abb24dcf241", "html_url": "https://github.com/rust-lang/rust/commit/303892ee156e5c31222b10786e661abb24dcf241"}], "stats": {"total": 94, "additions": 74, "deletions": 20}, "files": [{"sha": "510c4df4e2eb21ee0329f8aafd6c798532dfc391", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ee79bfa18affe95959a5f9a036c17bbd77979e21/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee79bfa18affe95959a5f9a036c17bbd77979e21/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=ee79bfa18affe95959a5f9a036c17bbd77979e21", "patch": "@@ -83,16 +83,19 @@ mod imp {\n     // were originally supposed to do.\n     //\n     // This handler currently exists purely to print an informative message\n-    // whenever a thread overflows its stack. When run the handler always\n-    // un-registers itself after running and then returns (to allow the original\n-    // signal to be delivered again). By returning we're ensuring that segfaults\n-    // do indeed look like segfaults.\n+    // whenever a thread overflows its stack. We then abort to exit and\n+    // indicate a crash, but to avoid a misleading SIGSEGV that might lead\n+    // users to believe that unsafe code has accessed an invalid pointer; the\n+    // SIGSEGV encountered when overflowing the stack is expected and\n+    // well-defined.\n     //\n-    // Returning from this kind of signal handler is technically not defined to\n-    // work when reading the POSIX spec strictly, but in practice it turns out\n-    // many large systems and all implementations allow returning from a signal\n-    // handler to work. For a more detailed explanation see the comments on\n-    // #26458.\n+    // If this is not a stack overflow, the handler un-registers itself and\n+    // then returns (to allow the original signal to be delivered again).\n+    // Returning from this kind of signal handler is technically not defined\n+    // to work when reading the POSIX spec strictly, but in practice it turns\n+    // out many large systems and all implementations allow returning from a\n+    // signal handler to work. For a more detailed explanation see the\n+    // comments on #26458.\n     unsafe extern fn signal_handler(signum: libc::c_int,\n                                     info: *mut libc::siginfo_t,\n                                     _data: *mut libc::c_void) {\n@@ -102,17 +105,18 @@ mod imp {\n         let addr = siginfo_si_addr(info);\n \n         // If the faulting address is within the guard page, then we print a\n-        // message saying so.\n+        // message saying so and abort.\n         if guard != 0 && guard - PAGE_SIZE <= addr && addr < guard {\n             report_overflow();\n+            rtabort!(\"stack overflow\");\n+        } else {\n+            // Unregister ourselves by reverting back to the default behavior.\n+            let mut action: sigaction = mem::zeroed();\n+            action.sa_sigaction = SIG_DFL;\n+            sigaction(signum, &action, ptr::null_mut());\n+\n+            // See comment above for why this function returns.\n         }\n-\n-        // Unregister ourselves by reverting back to the default behavior.\n-        let mut action: sigaction = mem::zeroed();\n-        action.sa_sigaction = SIG_DFL;\n-        sigaction(signum, &action, ptr::null_mut());\n-\n-        // See comment above for why this function returns.\n     }\n \n     static mut MAIN_ALTSTACK: *mut libc::c_void = ptr::null_mut();"}, {"sha": "00bfa63e6fea8204714719ea3b318a580416eeab", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee79bfa18affe95959a5f9a036c17bbd77979e21/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/ee79bfa18affe95959a5f9a036c17bbd77979e21/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=ee79bfa18affe95959a5f9a036c17bbd77979e21", "patch": "@@ -158,6 +158,11 @@ rust_get_test_int() {\n   return 1;\n }\n \n+char *\n+rust_get_null_ptr() {\n+    return 0;\n+}\n+\n /* Debug helpers strictly to verify ABI conformance.\n  *\n  * FIXME (#2665): move these into a testcase when the testsuite"}, {"sha": "4401861a1631c8a239d46ca98e74d0c1dd2199b2", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ee79bfa18affe95959a5f9a036c17bbd77979e21/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee79bfa18affe95959a5f9a036c17bbd77979e21/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=ee79bfa18affe95959a5f9a036c17bbd77979e21", "patch": "@@ -12,6 +12,10 @@\n // ignore-musl\n \n #![feature(asm)]\n+#![feature(libc)]\n+\n+#[cfg(unix)]\n+extern crate libc;\n \n use std::env;\n use std::process::Command;\n@@ -35,6 +39,24 @@ fn loud_recurse() {\n     black_box(()); // don't optimize this into a tail call. please.\n }\n \n+#[cfg(unix)]\n+fn check_status(status: std::process::ExitStatus)\n+{\n+    use libc;\n+    use std::os::unix::process::ExitStatusExt;\n+\n+    assert!(!status.success());\n+    assert!(status.signal() != Some(libc::SIGSEGV)\n+            && status.signal() != Some(libc::SIGBUS));\n+}\n+\n+#[cfg(not(unix))]\n+fn check_status(status: std::process::ExitStatus)\n+{\n+    assert!(!status.success());\n+}\n+\n+\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() > 1 && args[1] == \"silent\" {\n@@ -62,7 +84,9 @@ fn main() {\n             println!(\"testing: {}\", mode);\n \n             let silent = Command::new(&args[0]).arg(mode).output().unwrap();\n-            assert!(!silent.status.success());\n+\n+            check_status(silent.status);\n+\n             let error = String::from_utf8_lossy(&silent.stderr);\n             assert!(error.contains(\"has overflowed its stack\"),\n                     \"missing overflow message: {}\", error);"}, {"sha": "0158c4282dae77e808f6204fa97a90c5f198f31f", "filename": "src/test/run-pass/segfault-no-out-of-stack.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ee79bfa18affe95959a5f9a036c17bbd77979e21/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee79bfa18affe95959a5f9a036c17bbd77979e21/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs?ref=ee79bfa18affe95959a5f9a036c17bbd77979e21", "patch": "@@ -15,18 +15,39 @@ extern crate libc;\n use std::process::{Command, ExitStatus};\n use std::env;\n \n+#[link(name = \"rust_test_helpers\")]\n+extern {\n+    fn rust_get_null_ptr() -> *mut ::libc::c_char;\n+}\n+\n+#[cfg(unix)]\n+fn check_status(status: std::process::ExitStatus)\n+{\n+    use libc;\n+    use std::os::unix::process::ExitStatusExt;\n+\n+    assert!(status.signal() == Some(libc::SIGSEGV)\n+            || status.signal() == Some(libc::SIGBUS));\n+}\n+\n+#[cfg(not(unix))]\n+fn check_status(status: std::process::ExitStatus)\n+{\n+    assert!(!status.success());\n+}\n+\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() > 1 && args[1] == \"segfault\" {\n-        unsafe { *(0 as *mut isize) = 1 }; // trigger a segfault\n+        unsafe { *rust_get_null_ptr() = 1; }; // trigger a segfault\n     } else {\n         let segfault = Command::new(&args[0]).arg(\"segfault\").output().unwrap();\n         let stderr = String::from_utf8_lossy(&segfault.stderr);\n         let stdout = String::from_utf8_lossy(&segfault.stdout);\n         println!(\"stdout: {}\", stdout);\n         println!(\"stderr: {}\", stderr);\n         println!(\"status: {}\", segfault.status);\n-        assert!(!segfault.status.success());\n+        check_status(segfault.status);\n         assert!(!stderr.contains(\"has overflowed its stack\"));\n     }\n }"}]}