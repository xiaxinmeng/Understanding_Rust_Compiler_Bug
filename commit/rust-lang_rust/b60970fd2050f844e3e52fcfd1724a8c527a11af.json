{"sha": "b60970fd2050f844e3e52fcfd1724a8c527a11af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MDk3MGZkMjA1MGY4NDRlM2U1MmZjZmQxNzI0YThjNTI3YTExYWY=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-05-08T15:59:58Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-05-08T16:28:01Z"}, "message": "Handle break somewhat better\n\nStill no break-with-value or labels, but at least we know that `loop { break; }`\ndoesn't diverge.", "tree": {"sha": "ecbb000787870a660e37f880633054e45eccc5ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecbb000787870a660e37f880633054e45eccc5ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b60970fd2050f844e3e52fcfd1724a8c527a11af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b60970fd2050f844e3e52fcfd1724a8c527a11af", "html_url": "https://github.com/rust-lang/rust/commit/b60970fd2050f844e3e52fcfd1724a8c527a11af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b60970fd2050f844e3e52fcfd1724a8c527a11af/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe7bf993aa8d64668707e348f2ea69918cfda9a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7bf993aa8d64668707e348f2ea69918cfda9a4", "html_url": "https://github.com/rust-lang/rust/commit/fe7bf993aa8d64668707e348f2ea69918cfda9a4"}], "stats": {"total": 108, "additions": 105, "deletions": 3}, "files": [{"sha": "413904518b144d176f75116b01ae78de4e6f13ad", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b60970fd2050f844e3e52fcfd1724a8c527a11af/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60970fd2050f844e3e52fcfd1724a8c527a11af/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=b60970fd2050f844e3e52fcfd1724a8c527a11af", "patch": "@@ -211,6 +211,12 @@ struct InferenceContext<'a> {\n     /// so it doesn't make sense.\n     return_ty: Ty,\n     diverges: Diverges,\n+    breakables: Vec<BreakableContext>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct BreakableContext {\n+    pub may_break: bool,\n }\n \n impl<'a> InferenceContext<'a> {\n@@ -226,6 +232,7 @@ impl<'a> InferenceContext<'a> {\n             body: db.body(owner),\n             resolver,\n             diverges: Diverges::Maybe,\n+            breakables: Vec::new(),\n         }\n     }\n "}, {"sha": "9cac0c787c70db3cedad05a25981ce37c5ca38b6", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b60970fd2050f844e3e52fcfd1724a8c527a11af/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60970fd2050f844e3e52fcfd1724a8c527a11af/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=b60970fd2050f844e3e52fcfd1724a8c527a11af", "patch": "@@ -21,7 +21,10 @@ use crate::{\n     Ty, TypeCtor, Uncertain,\n };\n \n-use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch, Diverges};\n+use super::{\n+    BindingMode, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,\n+    TypeMismatch,\n+};\n \n impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n@@ -90,24 +93,43 @@ impl<'a> InferenceContext<'a> {\n                 Ty::Unknown\n             }\n             Expr::Loop { body } => {\n+                self.breakables.push(BreakableContext { may_break: false });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+\n+                let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                if ctxt.may_break {\n+                    self.diverges = Diverges::Maybe;\n+                }\n                 // FIXME handle break with value\n-                Ty::simple(TypeCtor::Never)\n+                if ctxt.may_break {\n+                    Ty::unit()\n+                } else {\n+                    Ty::simple(TypeCtor::Never)\n+                }\n             }\n             Expr::While { condition, body } => {\n+                self.breakables.push(BreakableContext { may_break: false });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                // the body may not run, so it diverging doesn't mean we diverge\n+                self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n+                self.breakables.push(BreakableContext { may_break: false });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n+\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                // the body may not run, so it diverging doesn't mean we diverge\n+                self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n             Expr::Lambda { body, args, ret_type, arg_types } => {\n@@ -211,6 +233,9 @@ impl<'a> InferenceContext<'a> {\n                     // FIXME handle break with value\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n+                if let Some(ctxt) = self.breakables.last_mut() {\n+                    ctxt.may_break = true;\n+                }\n                 Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {"}, {"sha": "082c472088488f0db3c29a17e777c617457abe65", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b60970fd2050f844e3e52fcfd1724a8c527a11af/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60970fd2050f844e3e52fcfd1724a8c527a11af/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=b60970fd2050f844e3e52fcfd1724a8c527a11af", "patch": "@@ -361,8 +361,78 @@ fn test1() {\n     // should give type mismatch\n     let x: u32 = { loop { break; } };\n }\n+fn test2() {\n+    // should give type mismatch\n+    let x: u32 = { for a in b { break; }; };\n+    // should give type mismatch as well\n+    let x: u32 = { for a in b {}; };\n+    // should give type mismatch as well\n+    let x: u32 = { for a in b { return; }; };\n+}\n+fn test3() {\n+    // should give type mismatch\n+    let x: u32 = { while true { break; }; };\n+    // should give type mismatch as well -- there's an implicit break, even if it's never hit\n+    let x: u32 = { while true {}; };\n+    // should give type mismatch as well\n+    let x: u32 = { while true { return; }; };\n+}\n \"#,\n         true,\n     );\n-    assert_snapshot!(t, @r###\"\"###);\n+    assert_snapshot!(t, @r###\"\n+    25..99 '{     ...} }; }': ()\n+    68..69 'x': u32\n+    77..96 '{ loop...k; } }': ()\n+    79..94 'loop { break; }': ()\n+    84..94 '{ break; }': ()\n+    86..91 'break': !\n+    77..96: expected u32, got ()\n+    79..94: expected u32, got ()\n+    111..357 '{     ...; }; }': ()\n+    154..155 'x': u32\n+    163..189 '{ for ...; }; }': ()\n+    165..186 'for a ...eak; }': ()\n+    169..170 'a': {unknown}\n+    174..175 'b': {unknown}\n+    176..186 '{ break; }': ()\n+    178..183 'break': !\n+    240..241 'x': u32\n+    249..267 '{ for ... {}; }': ()\n+    251..264 'for a in b {}': ()\n+    255..256 'a': {unknown}\n+    260..261 'b': {unknown}\n+    262..264 '{}': ()\n+    318..319 'x': u32\n+    327..354 '{ for ...; }; }': ()\n+    329..351 'for a ...urn; }': ()\n+    333..334 'a': {unknown}\n+    338..339 'b': {unknown}\n+    340..351 '{ return; }': ()\n+    342..348 'return': !\n+    163..189: expected u32, got ()\n+    249..267: expected u32, got ()\n+    327..354: expected u32, got ()\n+    369..668 '{     ...; }; }': ()\n+    412..413 'x': u32\n+    421..447 '{ whil...; }; }': ()\n+    423..444 'while ...eak; }': ()\n+    429..433 'true': bool\n+    434..444 '{ break; }': ()\n+    436..441 'break': !\n+    551..552 'x': u32\n+    560..578 '{ whil... {}; }': ()\n+    562..575 'while true {}': ()\n+    568..572 'true': bool\n+    573..575 '{}': ()\n+    629..630 'x': u32\n+    638..665 '{ whil...; }; }': ()\n+    640..662 'while ...urn; }': ()\n+    646..650 'true': bool\n+    651..662 '{ return; }': ()\n+    653..659 'return': !\n+    421..447: expected u32, got ()\n+    560..578: expected u32, got ()\n+    638..665: expected u32, got ()\n+    \"###);\n }"}]}