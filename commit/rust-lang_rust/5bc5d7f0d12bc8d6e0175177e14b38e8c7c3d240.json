{"sha": "5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYzVkN2YwZDEyYmM4ZDZlMDE3NTE3N2UxNGIzOGU4YzdjM2QyNDA=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-10-28T20:27:15Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-12-14T05:00:02Z"}, "message": "Add comparison ops", "tree": {"sha": "ae039ea1339abcb01eac6cdd766ba8dead5ca0d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae039ea1339abcb01eac6cdd766ba8dead5ca0d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "html_url": "https://github.com/rust-lang/rust/commit/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cebc2ca7072b8b33a397adf4f3380099ea25fb19", "url": "https://api.github.com/repos/rust-lang/rust/commits/cebc2ca7072b8b33a397adf4f3380099ea25fb19", "html_url": "https://github.com/rust-lang/rust/commit/cebc2ca7072b8b33a397adf4f3380099ea25fb19"}], "stats": {"total": 497, "additions": 414, "deletions": 83}, "files": [{"sha": "3dfc77136f2dbda085d473581ce010819e8ccac0", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "patch": "@@ -45,4 +45,11 @@ extern \"platform-intrinsic\" {\n \n     // ceil\n     pub(crate) fn simd_ceil<T>(x: T) -> T;\n+\n+    pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_le<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_gt<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;\n }"}, {"sha": "3c581ad659be06be8590c12dafe61d4a51c97514", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "patch": "@@ -11,6 +11,7 @@ mod intrinsics;\n mod ops;\n \n pub mod masks;\n+pub use masks::opaque::*;\n \n mod vectors_u8;\n pub use vectors_u8::*;"}, {"sha": "75584f58b7842f58e77c9e6e930d22459a1d057b", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "patch": "@@ -336,6 +336,24 @@ macro_rules! define_mask_vector {\n             call_repeat! { $lanes => define_mask_vector [$impl_type] splat $type | }\n             call_counting_args! { $lanes => define_mask_vector => new $type | }\n             call_counting_args! { $lanes => define_mask_vector => new_from_bool $type | }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                self[lane].test()\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                self[lane] = value.into();\n+            }\n         }\n \n         base_vector_traits! { $name => [$type; $lanes] }"}, {"sha": "6688db290e25a53d3704820b1d850938652e09b8", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 180, "deletions": 83, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "patch": "@@ -2,7 +2,10 @@\n \n pub mod wide;\n \n-trait MaskImpl {\n+mod ops;\n+pub use ops::*;\n+\n+pub(crate) trait MaskImpl {\n     type Mask;\n }\n \n@@ -93,123 +96,217 @@ macro_rules! define_opaque_mask {\n     } => {\n         $(#[$attr])*\n         #[allow(non_camel_case_types)]\n-        pub struct $name(<[$width; $lanes] as MaskImpl>::Mask);\n+        pub struct $name(<[$width; $lanes] as crate::masks::MaskImpl>::Mask);\n \n         impl $name {\n+            pub(crate) fn new_from_inner(inner: <[$width; $lanes] as crate::masks::MaskImpl>::Mask) -> Self {\n+                Self(inner)\n+            }\n+\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n-                Self(<[$width; $lanes] as MaskImpl>::Mask::splat(value.into()))\n+                Self(<[$width; $lanes] as crate::masks::MaskImpl>::Mask::splat(value.into()))\n             }\n \n             call_counting_args! { $lanes => define_opaque_mask => new [$width; $lanes] }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                self.0.test(lane)\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                self.0.set(lane, value);\n+            }\n+        }\n+\n+        impl Copy for $name {}\n+\n+        impl Clone for $name {\n+            #[inline]\n+            fn clone(&self) -> Self {\n+                *self\n+            }\n+        }\n+\n+        impl Default for $name {\n+            #[inline]\n+            fn default() -> Self {\n+                Self::splat(false)\n+            }\n+        }\n+\n+        impl PartialEq for $name {\n+            #[inline]\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl PartialOrd for $name {\n+            #[inline]\n+            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+                self.0.partial_cmp(&other.0)\n+            }\n         }\n     };\n     { new [$width:ty; $lanes:tt] $($var:ident)* } => {\n         /// Construct a vector by setting each lane to the given values.\n         #[allow(clippy::too_many_arguments)]\n         #[inline]\n         pub const fn new($($var: bool),*) -> Self {\n-            Self(<[$width; $lanes] as MaskImpl>::Mask::new_from_bool($($var),*))\n+            Self(<[$width; $lanes] as crate::masks::MaskImpl>::Mask::new_from_bool($($var),*))\n         }\n     }\n }\n \n-define_opaque_mask! {\n-    /// Mask for 8 8-bit lanes\n-    struct mask8x8([u8; 8]);\n-}\n+pub(crate) mod opaque {\n+    define_opaque_mask! {\n+        /// Mask for 8 8-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask8x8([u8; 8]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 16 8-bit lanes\n-    struct mask8x16([u8; 16]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 16 8-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask8x16([u8; 16]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 32 8-bit lanes\n-    struct mask8x32([u8; 32]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 32 8-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask8x32([u8; 32]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 64 8-bit lanes\n-    struct mask8x64([u8; 64]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 64 8-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask8x64([u8; 64]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 4 16-bit lanes\n-    struct mask16x4([u16; 4]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 4 16-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask16x4([u16; 4]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 8 16-bit lanes\n-    struct mask16x8([u16; 8]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 8 16-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask16x8([u16; 8]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 16 16-bit lanes\n-    struct mask16x16([u16; 16]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 16 16-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask16x16([u16; 16]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 32 16-bit lanes\n-    struct mask16x32([u16; 32]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 32 16-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask16x32([u16; 32]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 2 32-bit lanes\n-    struct mask32x2([u32; 2]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 2 32-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask32x2([u32; 2]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 4 32-bit lanes\n-    struct mask32x4([u32; 4]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 4 32-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask32x4([u32; 4]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 8 32-bit lanes\n-    struct mask32x8([u32; 8]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 8 32-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask32x8([u32; 8]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 16 32-bit lanes\n-    struct mask32x16([u32; 16]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 16 32-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask32x16([u32; 16]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 2 64-bit lanes\n-    struct mask64x2([u64; 2]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 2 64-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask64x2([u64; 2]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 4 64-bit lanes\n-    struct mask64x4([u64; 4]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 4 64-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask64x4([u64; 4]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 8 64-bit lanes\n-    struct mask64x8([u64; 8]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 8 64-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask64x8([u64; 8]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 2 128-bit lanes\n-    struct mask128x2([u128; 2]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 2 128-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask128x2([u128; 2]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 4 128-bit lanes\n-    struct mask128x4([u128; 4]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 4 128-bit lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct mask128x4([u128; 4]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 2 `isize`-wide lanes\n-    struct masksizex2([usize; 2]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 2 `isize`-wide lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct masksizex2([usize; 2]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 4 `isize`-wide lanes\n-    struct masksizex4([usize; 4]);\n-}\n+    define_opaque_mask! {\n+        /// Mask for 4 `isize`-wide lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct masksizex4([usize; 4]);\n+    }\n \n-define_opaque_mask! {\n-    /// Mask for 8 `isize`-wide lanes\n-    struct masksizex8([usize; 8]);\n+    define_opaque_mask! {\n+        /// Mask for 8 `isize`-wide lanes.\n+        ///\n+        /// The layout of this type is unspecified.\n+        struct masksizex8([usize; 8]);\n+    }\n }"}, {"sha": "85ce955459a2fd4a39c0059e75d432fe84700a61", "filename": "crates/core_simd/src/masks/ops.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fops.rs?ref=5bc5d7f0d12bc8d6e0175177e14b38e8c7c3d240", "patch": "@@ -0,0 +1,208 @@\n+/// Mask-related operations using a particular mask layout.\n+pub trait MaskExt<Mask> {\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    fn lanes_eq(self, other: Self) -> Mask;\n+\n+    /// Test if each lane is not equal to the corresponding lane in `other`.\n+    fn lanes_ne(self, other: Self) -> Mask;\n+\n+    /// Test if each lane is less than the corresponding lane in `other`.\n+    fn lanes_lt(self, other: Self) -> Mask;\n+\n+    /// Test if each lane is greater than the corresponding lane in `other`.\n+    fn lanes_gt(self, other: Self) -> Mask;\n+\n+    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+    fn lanes_le(self, other: Self) -> Mask;\n+\n+    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+    fn lanes_ge(self, other: Self) -> Mask;\n+}\n+\n+macro_rules! implement_mask_ext {\n+    { $($vector:ty => $($mask:ty),*;)* } => {\n+        $( // vector\n+            $( // mask\n+                impl MaskExt<$mask> for $vector {\n+                    #[inline]\n+                    fn lanes_eq(self, other: Self) -> $mask {\n+                        unsafe { crate::intrinsics::simd_eq(self, other) }\n+                    }\n+\n+                    #[inline]\n+                    fn lanes_ne(self, other: Self) -> $mask {\n+                        unsafe { crate::intrinsics::simd_ne(self, other) }\n+                    }\n+\n+                    #[inline]\n+                    fn lanes_lt(self, other: Self) -> $mask {\n+                        unsafe { crate::intrinsics::simd_lt(self, other) }\n+                    }\n+\n+                    #[inline]\n+                    fn lanes_gt(self, other: Self) -> $mask {\n+                        unsafe { crate::intrinsics::simd_gt(self, other) }\n+                    }\n+\n+                    #[inline]\n+                    fn lanes_le(self, other: Self) -> $mask {\n+                        unsafe { crate::intrinsics::simd_le(self, other) }\n+                    }\n+\n+                    #[inline]\n+                    fn lanes_ge(self, other: Self) -> $mask {\n+                        unsafe { crate::intrinsics::simd_ge(self, other) }\n+                    }\n+                }\n+            )*\n+        )*\n+    }\n+}\n+\n+implement_mask_ext! {\n+    crate::u8x8 => crate::masks::wide::m8x8;\n+    crate::u8x16 => crate::masks::wide::m8x16;\n+    crate::u8x32 => crate::masks::wide::m8x32;\n+    crate::u8x64 => crate::masks::wide::m8x64;\n+    crate::u16x4 => crate::masks::wide::m16x4;\n+    crate::u16x8 => crate::masks::wide::m16x8;\n+    crate::u16x16 => crate::masks::wide::m16x16;\n+    crate::u16x32 => crate::masks::wide::m16x32;\n+    crate::u32x2 => crate::masks::wide::m32x2;\n+    crate::u32x4 => crate::masks::wide::m32x4;\n+    crate::u32x8 => crate::masks::wide::m32x8;\n+    crate::u32x16 => crate::masks::wide::m32x16;\n+    crate::u64x2 => crate::masks::wide::m64x2;\n+    crate::u64x4 => crate::masks::wide::m64x4;\n+    crate::u64x8 => crate::masks::wide::m64x8;\n+    crate::u128x2 => crate::masks::wide::m128x2;\n+    crate::u128x4 => crate::masks::wide::m128x4;\n+    crate::usizex2 => crate::masks::wide::msizex2;\n+    crate::usizex4 => crate::masks::wide::msizex4;\n+    crate::usizex8 => crate::masks::wide::msizex8;\n+\n+    crate::i8x8 => crate::masks::wide::m8x8;\n+    crate::i8x16 => crate::masks::wide::m8x16;\n+    crate::i8x32 => crate::masks::wide::m8x32;\n+    crate::i8x64 => crate::masks::wide::m8x64;\n+    crate::i16x4 => crate::masks::wide::m16x4;\n+    crate::i16x8 => crate::masks::wide::m16x8;\n+    crate::i16x16 => crate::masks::wide::m16x16;\n+    crate::i16x32 => crate::masks::wide::m16x32;\n+    crate::i32x2 => crate::masks::wide::m32x2;\n+    crate::i32x4 => crate::masks::wide::m32x4;\n+    crate::i32x8 => crate::masks::wide::m32x8;\n+    crate::i32x16 => crate::masks::wide::m32x16;\n+    crate::i64x2 => crate::masks::wide::m64x2;\n+    crate::i64x4 => crate::masks::wide::m64x4;\n+    crate::i64x8 => crate::masks::wide::m64x8;\n+    crate::i128x2 => crate::masks::wide::m128x2;\n+    crate::i128x4 => crate::masks::wide::m128x4;\n+    crate::isizex2 => crate::masks::wide::msizex2;\n+    crate::isizex4 => crate::masks::wide::msizex4;\n+    crate::isizex8 => crate::masks::wide::msizex8;\n+\n+    crate::f32x2 => crate::masks::wide::m32x2;\n+    crate::f32x4 => crate::masks::wide::m32x4;\n+    crate::f32x8 => crate::masks::wide::m32x8;\n+    crate::f32x16 => crate::masks::wide::m32x16;\n+    crate::f64x2 => crate::masks::wide::m64x2;\n+    crate::f64x4 => crate::masks::wide::m64x4;\n+    crate::f64x8 => crate::masks::wide::m64x8;\n+}\n+\n+macro_rules! implement_mask_ops {\n+    { $($vector:ty => $mask:ty,)* } => {\n+        $( // vector\n+            impl $vector {\n+                /// Test if each lane is equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_eq(self, other: Self) -> $mask {\n+                    <$mask>::new_from_inner(MaskExt::lanes_eq(self, other))\n+                }\n+\n+                /// Test if each lane is not equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ne(self, other: Self) -> $mask {\n+                    <$mask>::new_from_inner(MaskExt::lanes_ne(self, other))\n+                }\n+\n+                /// Test if each lane is less than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_lt(self, other: Self) -> $mask {\n+                    <$mask>::new_from_inner(MaskExt::lanes_lt(self, other))\n+                }\n+\n+                /// Test if each lane is greater than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_gt(self, other: Self) -> $mask {\n+                    <$mask>::new_from_inner(MaskExt::lanes_gt(self, other))\n+                }\n+\n+                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_le(self, other: Self) -> $mask {\n+                    <$mask>::new_from_inner(MaskExt::lanes_le(self, other))\n+                }\n+\n+                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ge(self, other: Self) -> $mask {\n+                    <$mask>::new_from_inner(MaskExt::lanes_ge(self, other))\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+implement_mask_ops! {\n+    crate::u8x8 => crate::mask8x8,\n+    crate::u8x16 => crate::mask8x16,\n+    crate::u8x32 => crate::mask8x32,\n+    crate::u8x64 => crate::mask8x64,\n+    crate::u16x4 => crate::mask16x4,\n+    crate::u16x8 => crate::mask16x8,\n+    crate::u16x16 => crate::mask16x16,\n+    crate::u16x32 => crate::mask16x32,\n+    crate::u32x2 => crate::mask32x2,\n+    crate::u32x4 => crate::mask32x4,\n+    crate::u32x8 => crate::mask32x8,\n+    crate::u32x16 => crate::mask32x16,\n+    crate::u64x2 => crate::mask64x2,\n+    crate::u64x4 => crate::mask64x4,\n+    crate::u64x8 => crate::mask64x8,\n+    crate::u128x2 => crate::mask128x2,\n+    crate::u128x4 => crate::mask128x4,\n+    crate::usizex2 => crate::masksizex2,\n+    crate::usizex4 => crate::masksizex4,\n+    crate::usizex8 => crate::masksizex8,\n+\n+    crate::i8x8 => crate::mask8x8,\n+    crate::i8x16 => crate::mask8x16,\n+    crate::i8x32 => crate::mask8x32,\n+    crate::i8x64 => crate::mask8x64,\n+    crate::i16x4 => crate::mask16x4,\n+    crate::i16x8 => crate::mask16x8,\n+    crate::i16x16 => crate::mask16x16,\n+    crate::i16x32 => crate::mask16x32,\n+    crate::i32x2 => crate::mask32x2,\n+    crate::i32x4 => crate::mask32x4,\n+    crate::i32x8 => crate::mask32x8,\n+    crate::i32x16 => crate::mask32x16,\n+    crate::i64x2 => crate::mask64x2,\n+    crate::i64x4 => crate::mask64x4,\n+    crate::i64x8 => crate::mask64x8,\n+    crate::i128x2 => crate::mask128x2,\n+    crate::i128x4 => crate::mask128x4,\n+    crate::isizex2 => crate::masksizex2,\n+    crate::isizex4 => crate::masksizex4,\n+    crate::isizex8 => crate::masksizex8,\n+\n+    crate::f32x2 => crate::mask32x2,\n+    crate::f32x4 => crate::mask32x4,\n+    crate::f32x8 => crate::mask32x8,\n+    crate::f32x16 => crate::mask32x16,\n+    crate::f64x2 => crate::mask64x2,\n+    crate::f64x4 => crate::mask64x4,\n+    crate::f64x8 => crate::mask64x8,\n+}"}]}