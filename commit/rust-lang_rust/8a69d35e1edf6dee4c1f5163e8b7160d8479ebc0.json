{"sha": "8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNjlkMzVlMWVkZjZkZWU0YzFmNTE2M2U4YjcxNjBkODQ3OWViYzA=", "commit": {"author": {"name": "Tom Jakubowski", "email": "tom@crystae.net", "date": "2015-01-11T07:50:46Z"}, "committer": {"name": "Tom Jakubowski", "email": "tom@crystae.net", "date": "2015-01-12T17:25:07Z"}, "message": "rustdoc: Fix where clauses on re-exports\n\nProjection predicates on re-exports, for the time being, are rendered as\nequality predicates because that's easier. It would be nice to fix this\nin the future.\n\nSome gymnastics were needed to remove redundant bounds from the `types`\nand `lifetimes` fields, remove implicit `Sized` bounds, and re-create\n`?Sized` bounds.\n\nFix #20203, fix #20924, fix #20911, fix #20534", "tree": {"sha": "13f20094786697381d2dd24417ff3a39f603048c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13f20094786697381d2dd24417ff3a39f603048c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0", "html_url": "https://github.com/rust-lang/rust/commit/8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0/comments", "author": {"login": "tomjakubowski", "id": 667901, "node_id": "MDQ6VXNlcjY2NzkwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/667901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomjakubowski", "html_url": "https://github.com/tomjakubowski", "followers_url": "https://api.github.com/users/tomjakubowski/followers", "following_url": "https://api.github.com/users/tomjakubowski/following{/other_user}", "gists_url": "https://api.github.com/users/tomjakubowski/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomjakubowski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomjakubowski/subscriptions", "organizations_url": "https://api.github.com/users/tomjakubowski/orgs", "repos_url": "https://api.github.com/users/tomjakubowski/repos", "events_url": "https://api.github.com/users/tomjakubowski/events{/privacy}", "received_events_url": "https://api.github.com/users/tomjakubowski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tomjakubowski", "id": 667901, "node_id": "MDQ6VXNlcjY2NzkwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/667901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomjakubowski", "html_url": "https://github.com/tomjakubowski", "followers_url": "https://api.github.com/users/tomjakubowski/followers", "following_url": "https://api.github.com/users/tomjakubowski/following{/other_user}", "gists_url": "https://api.github.com/users/tomjakubowski/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomjakubowski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomjakubowski/subscriptions", "organizations_url": "https://api.github.com/users/tomjakubowski/orgs", "repos_url": "https://api.github.com/users/tomjakubowski/repos", "events_url": "https://api.github.com/users/tomjakubowski/events{/privacy}", "received_events_url": "https://api.github.com/users/tomjakubowski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "099b411e080d302ec0dc5f3aebe53d76c50acfc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/099b411e080d302ec0dc5f3aebe53d76c50acfc7", "html_url": "https://github.com/rust-lang/rust/commit/099b411e080d302ec0dc5f3aebe53d76c50acfc7"}], "stats": {"total": 175, "additions": 160, "deletions": 15}, "files": [{"sha": "80494e3811090d9a3111072572ad094baf946c62", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 158, "deletions": 13, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0", "patch": "@@ -104,6 +104,12 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     }\n }\n \n+impl<T, U> Clean<U> for ty::Binder<T> where T: Clean<U> {\n+    fn clean(&self, cx: &DocContext) -> U {\n+        self.0.clean(cx)\n+    }\n+}\n+\n impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n     fn clean(&self, cx: &DocContext) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n@@ -603,12 +609,6 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n     }\n }\n \n-impl<'tcx> Clean<TyParamBound> for ty::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> TyParamBound {\n-        self.0.clean(cx)\n-    }\n-}\n-\n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         let tcx = match cx.tcx_opt() {\n@@ -730,8 +730,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<TyParamBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<Lifetime>},\n-    // FIXME (#20041)\n-    EqPredicate\n+    EqPredicate { lhs: Type, rhs: Type }\n }\n \n impl Clean<WherePredicate> for ast::WherePredicate {\n@@ -752,12 +751,89 @@ impl Clean<WherePredicate> for ast::WherePredicate {\n             }\n \n             ast::WherePredicate::EqPredicate(_) => {\n-                WherePredicate::EqPredicate\n+                unimplemented!() // FIXME(#20041)\n             }\n         }\n     }\n }\n \n+impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        use rustc::middle::ty::Predicate;\n+\n+        match *self {\n+            Predicate::Trait(ref pred) => pred.clean(cx),\n+            Predicate::Equate(ref pred) => pred.clean(cx),\n+            Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n+            Predicate::TypeOutlives(ref pred) => pred.clean(cx),\n+            Predicate::Projection(ref pred) => pred.clean(cx)\n+        }\n+    }\n+}\n+\n+impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        WherePredicate::BoundPredicate {\n+            ty: self.trait_ref.substs.self_ty().clean(cx).unwrap(),\n+            bounds: vec![self.trait_ref.clean(cx)]\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<WherePredicate> for ty::EquatePredicate<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        let ty::EquatePredicate(ref lhs, ref rhs) = *self;\n+        WherePredicate::EqPredicate {\n+            lhs: lhs.clean(cx),\n+            rhs: rhs.clean(cx)\n+        }\n+    }\n+}\n+\n+impl Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region, ty::Region> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        let ty::OutlivesPredicate(ref a, ref b) = *self;\n+        WherePredicate::RegionPredicate {\n+            lifetime: a.clean(cx).unwrap(),\n+            bounds: vec![b.clean(cx).unwrap()]\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, ty::Region> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n+\n+        WherePredicate::BoundPredicate {\n+            ty: ty.clean(cx),\n+            bounds: vec![TyParamBound::RegionBound(lt.clean(cx).unwrap())]\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        WherePredicate::EqPredicate {\n+            lhs: self.projection_ty.clean(cx),\n+            rhs: self.ty.clean(cx)\n+        }\n+    }\n+}\n+\n+impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Type {\n+        let trait_ = match self.trait_ref.clean(cx) {\n+            TyParamBound::TraitBound(t, _) => t.trait_,\n+            TyParamBound::RegionBound(_) => panic!(\"cleaning a trait got a region??\"),\n+        };\n+        Type::QPath {\n+            name: self.item_name.clean(cx),\n+            self_type: box self.trait_ref.self_ty().clean(cx),\n+            trait_: box trait_\n+        }\n+    }\n+}\n+\n // maybe use a Generic enum and use ~[Generic]?\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub struct Generics {\n@@ -778,11 +854,80 @@ impl Clean<Generics> for ast::Generics {\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n-        let (me, space) = *self;\n+        use std::collections::HashSet;\n+        use syntax::ast::TraitBoundModifier as TBM;\n+        use self::WherePredicate as WP;\n+\n+        fn has_sized_bound(bounds: &[TyParamBound], cx: &DocContext) -> bool {\n+            if let Some(tcx) = cx.tcx_opt() {\n+                let sized_did = match tcx.lang_items.sized_trait() {\n+                    Some(did) => did,\n+                    None => return false\n+                };\n+                for bound in bounds.iter() {\n+                    if let TyParamBound::TraitBound(PolyTrait {\n+                        trait_: Type::ResolvedPath { did, .. }, ..\n+                    }, TBM::None) = *bound {\n+                        if did == sized_did {\n+                            return true\n+                        }\n+                    }\n+                }\n+            }\n+            false\n+        }\n+\n+        let (gens, space) = *self;\n+        // Bounds in the type_params and lifetimes fields are repeated in the predicates\n+        // field (see rustc_typeck::collect::ty_generics), so remove them.\n+        let stripped_typarams = gens.types.get_slice(space).iter().map(|tp| {\n+            let mut stp = tp.clone();\n+            stp.bounds = ty::ParamBounds::empty();\n+            stp.clean(cx)\n+        }).collect::<Vec<_>>();\n+        let stripped_lifetimes = gens.regions.get_slice(space).iter().map(|rp| {\n+            let mut srp = rp.clone();\n+            srp.bounds = Vec::new();\n+            srp.clean(cx)\n+        }).collect::<Vec<_>>();\n+\n+        let where_predicates = gens.predicates.get_slice(space).to_vec().clean(cx);\n+        // Type parameters have a Sized bound by default unless removed with ?Sized.\n+        // Scan through the predicates and mark any type parameter with a Sized\n+        // bound, removing the bounds as we find them.\n+        let mut sized_params = HashSet::new();\n+        let mut where_predicates = where_predicates.into_iter().filter_map(|pred| {\n+            if let WP::BoundPredicate { ty: Type::Generic(ref g), ref bounds } = pred {\n+                if has_sized_bound(&**bounds, cx) {\n+                    sized_params.insert(g.clone());\n+                    return None\n+                }\n+            }\n+            Some(pred)\n+        }).collect::<Vec<_>>();\n+        // Finally, run through the type parameters again and insert a ?Sized unbound for\n+        // any we didn't find to be Sized.\n+        for tp in stripped_typarams.iter() {\n+            if !sized_params.contains(&tp.name) {\n+                let mut sized_bound = ty::BuiltinBound::BoundSized.clean(cx);\n+                if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n+                    *tbm = TBM::Maybe\n+                };\n+                where_predicates.push(WP::BoundPredicate {\n+                    ty: Type::Generic(tp.name.clone()),\n+                    bounds: vec![sized_bound]\n+                })\n+            }\n+        }\n+\n+        // It would be nice to collect all of the bounds on a type and recombine\n+        // them if possible, to avoid e.g. `where T: Foo, T: Bar, T: Sized, T: 'a`\n+        // and instead see `where T: Foo + Bar + Sized + 'a`\n+\n         Generics {\n-            type_params: me.types.get_slice(space).to_vec().clean(cx),\n-            lifetimes: me.regions.get_slice(space).to_vec().clean(cx),\n-            where_predicates: vec![]\n+            type_params: stripped_typarams,\n+            lifetimes: stripped_lifetimes,\n+            where_predicates: where_predicates\n         }\n     }\n }"}, {"sha": "4bfde9e5d7d973af08fa06ae94ec18bbc80b320e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8a69d35e1edf6dee4c1f5163e8b7160d8479ebc0", "patch": "@@ -153,8 +153,8 @@ impl<'a> fmt::String for WhereClause<'a> {\n                         try!(write!(f, \"{}\", lifetime));\n                     }\n                 }\n-                &clean::WherePredicate::EqPredicate => {\n-                    unimplemented!()\n+                &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n+                    try!(write!(f, \"{} == {}\", lhs, rhs));\n                 }\n             }\n         }"}]}