{"sha": "16e22e143d878bc614c03401e9d576a14a40c4bf", "node_id": "C_kwDOAAsO6NoAKDE2ZTIyZTE0M2Q4NzhiYzYxNGMwMzQwMWU5ZDU3NmExNGE0MGM0YmY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-15T14:33:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-15T15:16:32Z"}, "message": "Mark derived StructuralEq as automatically derived.", "tree": {"sha": "a9c9560f5606b3dfd19bf5868072c0d437a16b1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9c9560f5606b3dfd19bf5868072c0d437a16b1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e22e143d878bc614c03401e9d576a14a40c4bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e22e143d878bc614c03401e9d576a14a40c4bf", "html_url": "https://github.com/rust-lang/rust/commit/16e22e143d878bc614c03401e9d576a14a40c4bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e22e143d878bc614c03401e9d576a14a40c4bf/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b0a099dfc9a97ecd10adb319396c731c4b2d169", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b0a099dfc9a97ecd10adb319396c731c4b2d169", "html_url": "https://github.com/rust-lang/rust/commit/9b0a099dfc9a97ecd10adb319396c731c4b2d169"}], "stats": {"total": 99, "additions": 70, "deletions": 29}, "files": [{"sha": "ee346047a0bc0c2fb54b7ef50bedd1f9e8ac2a01", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16e22e143d878bc614c03401e9d576a14a40c4bf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e22e143d878bc614c03401e9d576a14a40c4bf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=16e22e143d878bc614c03401e9d576a14a40c4bf", "patch": "@@ -131,23 +131,27 @@ fn inject_impl_of_structural_trait(\n     // Create generics param list for where clauses and impl headers\n     let mut generics = generics.clone();\n \n+    let ctxt = span.ctxt();\n+\n     // Create the type of `self`.\n     //\n     // in addition, remove defaults from generic params (impls cannot have them).\n     let self_params: Vec<_> = generics\n         .params\n         .iter_mut()\n         .map(|param| match &mut param.kind {\n-            ast::GenericParamKind::Lifetime => {\n-                ast::GenericArg::Lifetime(cx.lifetime(span, param.ident))\n-            }\n+            ast::GenericParamKind::Lifetime => ast::GenericArg::Lifetime(\n+                cx.lifetime(param.ident.span.with_ctxt(ctxt), param.ident),\n+            ),\n             ast::GenericParamKind::Type { default } => {\n                 *default = None;\n-                ast::GenericArg::Type(cx.ty_ident(span, param.ident))\n+                ast::GenericArg::Type(cx.ty_ident(param.ident.span.with_ctxt(ctxt), param.ident))\n             }\n             ast::GenericParamKind::Const { ty: _, kw_span: _, default } => {\n                 *default = None;\n-                ast::GenericArg::Const(cx.const_ident(span, param.ident))\n+                ast::GenericArg::Const(\n+                    cx.const_ident(param.ident.span.with_ctxt(ctxt), param.ident),\n+                )\n             }\n         })\n         .collect();\n@@ -174,6 +178,8 @@ fn inject_impl_of_structural_trait(\n             })\n             .cloned(),\n     );\n+    // Mark as `automatically_derived` to avoid some silly lints.\n+    attrs.push(cx.attribute(cx.meta_word(span, sym::automatically_derived)));\n \n     let newitem = cx.item(\n         span,"}, {"sha": "258ef8ba91dffed8c70ed88d69b77c2e80478571", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/16e22e143d878bc614c03401e9d576a14a40c4bf/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/16e22e143d878bc614c03401e9d576a14a40c4bf/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=16e22e143d878bc614c03401e9d576a14a40c4bf", "patch": "@@ -46,13 +46,15 @@ impl ::core::default::Default for Empty {\n impl ::core::hash::Hash for Empty {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n-impl ::core::marker::StructuralPartialEq for Empty {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Empty { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Empty {\n     #[inline]\n     fn eq(&self, other: &Empty) -> bool { true }\n }\n-impl ::core::marker::StructuralEq for Empty {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Empty { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Empty {\n     #[inline]\n@@ -115,15 +117,17 @@ impl ::core::hash::Hash for Point {\n         ::core::hash::Hash::hash(&self.y, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Point {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Point { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Point {\n     #[inline]\n     fn eq(&self, other: &Point) -> bool {\n         self.x == other.x && self.y == other.y\n     }\n }\n-impl ::core::marker::StructuralEq for Point {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Point { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Point {\n     #[inline]\n@@ -225,7 +229,8 @@ impl ::core::hash::Hash for Big {\n         ::core::hash::Hash::hash(&self.b8, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Big {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Big { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Big {\n     #[inline]\n@@ -236,7 +241,8 @@ impl ::core::cmp::PartialEq for Big {\n             self.b8 == other.b8\n     }\n }\n-impl ::core::marker::StructuralEq for Big {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Big { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Big {\n     #[inline]\n@@ -345,13 +351,15 @@ impl ::core::hash::Hash for Unsized {\n         ::core::hash::Hash::hash(&self.0, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Unsized {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Unsized { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Unsized {\n     #[inline]\n     fn eq(&self, other: &Unsized) -> bool { self.0 == other.0 }\n }\n-impl ::core::marker::StructuralEq for Unsized {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Unsized { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Unsized {\n     #[inline]\n@@ -410,13 +418,15 @@ impl ::core::hash::Hash for PackedCopy {\n         ::core::hash::Hash::hash(&{ self.0 }, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for PackedCopy {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for PackedCopy { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for PackedCopy {\n     #[inline]\n     fn eq(&self, other: &PackedCopy) -> bool { { self.0 } == { other.0 } }\n }\n-impl ::core::marker::StructuralEq for PackedCopy {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for PackedCopy { }\n #[automatically_derived]\n impl ::core::cmp::Eq for PackedCopy {\n     #[inline]\n@@ -479,7 +489,8 @@ impl ::core::hash::Hash for PackedNonCopy {\n         ::core::hash::Hash::hash(__self_0_0, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for PackedNonCopy {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for PackedNonCopy { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for PackedNonCopy {\n     #[inline]\n@@ -489,7 +500,8 @@ impl ::core::cmp::PartialEq for PackedNonCopy {\n         *__self_0_0 == *__self_1_0\n     }\n }\n-impl ::core::marker::StructuralEq for PackedNonCopy {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for PackedNonCopy { }\n #[automatically_derived]\n impl ::core::cmp::Eq for PackedNonCopy {\n     #[inline]\n@@ -540,15 +552,17 @@ impl ::core::hash::Hash for Enum0 {\n         unsafe { ::core::intrinsics::unreachable() }\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Enum0 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Enum0 { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Enum0 {\n     #[inline]\n     fn eq(&self, other: &Enum0) -> bool {\n         unsafe { ::core::intrinsics::unreachable() }\n     }\n }\n-impl ::core::marker::StructuralEq for Enum0 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Enum0 { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Enum0 {\n     #[inline]\n@@ -607,7 +621,8 @@ impl ::core::hash::Hash for Enum1 {\n         }\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Enum1 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Enum1 { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Enum1 {\n     #[inline]\n@@ -618,7 +633,8 @@ impl ::core::cmp::PartialEq for Enum1 {\n         }\n     }\n }\n-impl ::core::marker::StructuralEq for Enum1 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Enum1 { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Enum1 {\n     #[inline]\n@@ -676,13 +692,15 @@ impl ::core::default::Default for Fieldless1 {\n impl ::core::hash::Hash for Fieldless1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n-impl ::core::marker::StructuralPartialEq for Fieldless1 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Fieldless1 { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Fieldless1 {\n     #[inline]\n     fn eq(&self, other: &Fieldless1) -> bool { true }\n }\n-impl ::core::marker::StructuralEq for Fieldless1 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Fieldless1 { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Fieldless1 {\n     #[inline]\n@@ -743,7 +761,8 @@ impl ::core::hash::Hash for Fieldless {\n         ::core::hash::Hash::hash(&__self_tag, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Fieldless {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Fieldless { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Fieldless {\n     #[inline]\n@@ -753,7 +772,8 @@ impl ::core::cmp::PartialEq for Fieldless {\n         __self_tag == __arg1_tag\n     }\n }\n-impl ::core::marker::StructuralEq for Fieldless {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Fieldless { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Fieldless {\n     #[inline]\n@@ -838,7 +858,8 @@ impl ::core::hash::Hash for Mixed {\n         }\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Mixed {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Mixed { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Mixed {\n     #[inline]\n@@ -856,7 +877,8 @@ impl ::core::cmp::PartialEq for Mixed {\n             }\n     }\n }\n-impl ::core::marker::StructuralEq for Mixed {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Mixed { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Mixed {\n     #[inline]\n@@ -963,7 +985,8 @@ impl ::core::hash::Hash for Fielded {\n         }\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Fielded {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Fielded { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Fielded {\n     #[inline]\n@@ -982,7 +1005,8 @@ impl ::core::cmp::PartialEq for Fielded {\n             }\n     }\n }\n-impl ::core::marker::StructuralEq for Fielded {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Fielded { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Fielded {\n     #[inline]"}, {"sha": "e5bdfc55dd670d318928ee4a7768d9b188455b81", "filename": "src/test/ui/single-use-lifetime/derive-eq.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16e22e143d878bc614c03401e9d576a14a40c4bf/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fderive-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e22e143d878bc614c03401e9d576a14a40c4bf/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fderive-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fderive-eq.rs?ref=16e22e143d878bc614c03401e9d576a14a40c4bf", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![deny(single_use_lifetimes)]\n+\n+#[derive(PartialEq, Eq)]\n+struct Foo<'a, T> {\n+    /// a reference to the underlying secret data that will be derefed\n+    pub data: &'a mut T,\n+}\n+\n+fn main() {}"}]}