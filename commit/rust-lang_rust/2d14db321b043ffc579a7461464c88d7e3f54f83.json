{"sha": "2d14db321b043ffc579a7461464c88d7e3f54f83", "node_id": "C_kwDOAAsO6NoAKDJkMTRkYjMyMWIwNDNmZmM1NzlhNzQ2MTQ2NGM4OGQ3ZTNmNTRmODM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T16:14:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T16:14:10Z"}, "message": "Auto merge of #108006 - cjgillot:def-impl, r=oli-obk\n\nAvoid accessing HIR when it can be avoided\n\nExperiment to see if it helps some incremental cases.\n\nWill be rebased once https://github.com/rust-lang/rust/pull/107942 gets merged.\n\nr? `@ghost`", "tree": {"sha": "90bf861bcf5e24d0de4c73b3a05791e41e25e658", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90bf861bcf5e24d0de4c73b3a05791e41e25e658"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d14db321b043ffc579a7461464c88d7e3f54f83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d14db321b043ffc579a7461464c88d7e3f54f83", "html_url": "https://github.com/rust-lang/rust/commit/2d14db321b043ffc579a7461464c88d7e3f54f83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d14db321b043ffc579a7461464c88d7e3f54f83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "999ac5f7770bff68bd65f490990d32c3ec1faaa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/999ac5f7770bff68bd65f490990d32c3ec1faaa6", "html_url": "https://github.com/rust-lang/rust/commit/999ac5f7770bff68bd65f490990d32c3ec1faaa6"}, {"sha": "065f0b222d4e23ae3d4215061c5df7d248855717", "url": "https://api.github.com/repos/rust-lang/rust/commits/065f0b222d4e23ae3d4215061c5df7d248855717", "html_url": "https://github.com/rust-lang/rust/commit/065f0b222d4e23ae3d4215061c5df7d248855717"}], "stats": {"total": 1085, "additions": 312, "deletions": 773}, "files": [{"sha": "a89643fcfd4844176fcd7cd9a6eb8c6a3c50f332", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -1182,13 +1182,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n                     let parent_did = tcx.parent(method_did);\n-                    let parent_self_ty = (tcx.def_kind(parent_did)\n-                        == rustc_hir::def::DefKind::Impl)\n-                        .then_some(parent_did)\n-                        .and_then(|did| match tcx.type_of(did).kind() {\n-                            ty::Adt(def, ..) => Some(def.did()),\n-                            _ => None,\n-                        });\n+                    let parent_self_ty =\n+                        matches!(tcx.def_kind(parent_did), rustc_hir::def::DefKind::Impl { .. })\n+                            .then_some(parent_did)\n+                            .and_then(|did| match tcx.type_of(did).kind() {\n+                                ty::Adt(def, ..) => Some(def.did()),\n+                                _ => None,\n+                            });\n                     let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n                         matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                     });"}, {"sha": "a82e695d649053346b9b8637be59aea84f574659", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -852,9 +852,9 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n         let region_parent = tcx.parent(region.def_id);\n-        if tcx.def_kind(region_parent) != DefKind::Impl {\n+        let DefKind::Impl { .. } = tcx.def_kind(region_parent) else {\n             return None;\n-        }\n+        };\n \n         let found = tcx\n             .any_free_region_meets(&tcx.type_of(region_parent), |r| *r == ty::ReEarlyBound(region));"}, {"sha": "11bd47a8f0c7929d865cd9867a5e8003b8e4c512", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -2,17 +2,16 @@ use std::collections::hash_map::Entry::*;\n \n use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportInfo, SymbolExportKind, SymbolExportLevel,\n };\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, SymbolName, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, SymbolName, TyCtxt};\n use rustc_session::config::{CrateType, OomStrategy};\n use rustc_target::spec::SanitizerSet;\n \n@@ -74,32 +73,34 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get_by_def_id(def_id) {\n-                Node::ForeignItem(..) => {\n-                    tcx.native_library(def_id).map_or(false, |library| library.kind.is_statically_included()).then_some(def_id)\n-                }\n+            if let Some(parent_id) = tcx.opt_local_parent(def_id)\n+                && let DefKind::ForeignMod = tcx.def_kind(parent_id)\n+            {\n+                let library = tcx.native_library(def_id)?;\n+                return library.kind.is_statically_included().then_some(def_id);\n+            }\n \n-                // Only consider nodes that actually have exported symbols.\n-                Node::Item(&hir::Item {\n-                    kind: hir::ItemKind::Static(..) | hir::ItemKind::Fn(..),\n-                    ..\n-                })\n-                | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n-                    let generics = tcx.generics_of(def_id);\n-                    if !generics.requires_monomorphization(tcx)\n-                        // Functions marked with #[inline] are codegened with \"internal\"\n-                        // linkage and are not exported unless marked with an extern\n-                        // indicator\n-                        && (!Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n-                            || tcx.codegen_fn_attrs(def_id.to_def_id()).contains_extern_indicator())\n-                    {\n-                        Some(def_id)\n-                    } else {\n-                        None\n-                    }\n-                }\n+            // Only consider nodes that actually have exported symbols.\n+            match tcx.def_kind(def_id) {\n+                DefKind::Fn | DefKind::Static(_) => {}\n+                DefKind::AssocFn if tcx.impl_of_method(def_id.to_def_id()).is_some() => {}\n+                _ => return None,\n+            };\n \n-                _ => None,\n+            let generics = tcx.generics_of(def_id);\n+            if generics.requires_monomorphization(tcx) {\n+                return None;\n+            }\n+\n+            // Functions marked with #[inline] are codegened with \"internal\"\n+            // linkage and are not exported unless marked with an extern\n+            // indicator\n+            if !Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n+                || tcx.codegen_fn_attrs(def_id.to_def_id()).contains_extern_indicator()\n+            {\n+                Some(def_id)\n+            } else {\n+                None\n             }\n         })\n         .map(|def_id| {\n@@ -118,7 +119,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                 tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())),\n                 export_level\n             );\n-            (def_id.to_def_id(), SymbolExportInfo {\n+            let info = SymbolExportInfo {\n                 level: export_level,\n                 kind: if tcx.is_static(def_id.to_def_id()) {\n                     if codegen_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n@@ -130,8 +131,10 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                     SymbolExportKind::Text\n                 },\n                 used: codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n-                    || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER) || used,\n-            })\n+                    || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n+                    || used,\n+            };\n+            (def_id.to_def_id(), info)\n         })\n         .collect();\n \n@@ -457,9 +460,7 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         let target = &tcx.sess.target.llvm_target;\n         // WebAssembly cannot export data symbols, so reduce their export level\n         if target.contains(\"emscripten\") {\n-            if let Some(Node::Item(&hir::Item { kind: hir::ItemKind::Static(..), .. })) =\n-                tcx.hir().get_if_local(sym_def_id)\n-            {\n+            if let DefKind::Static(_) = tcx.def_kind(sym_def_id) {\n                 return SymbolExportLevel::Rust;\n             }\n         }"}, {"sha": "a6afbad5b2402062e9a236c5cfdfca39e803f567", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -3,12 +3,12 @@ use rustc_attr::InstructionSetAttr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n@@ -440,12 +440,9 @@ fn asm_target_features(tcx: TyCtxt<'_>, did: DefId) -> &FxHashSet<Symbol> {\n /// Checks the function annotated with `#[target_feature]` is not a safe\n /// trait method implementation, reporting an error if it is.\n pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n-    let node = tcx.hir().get(hir_id);\n-    if let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n-        let parent_id = tcx.hir().get_parent_item(hir_id);\n-        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n+    if let DefKind::AssocFn = tcx.def_kind(id) {\n+        let parent_id = tcx.local_parent(id);\n+        if let DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n             tcx.sess\n                 .struct_span_err(\n                     attr_span,"}, {"sha": "9eaab1f47a7ea940d99073a76567f3b3895c3d45", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -17,7 +17,8 @@ pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n \n pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     let parent_id = tcx.local_parent(def_id);\n-    tcx.def_kind(parent_id) == DefKind::Impl && tcx.constness(parent_id) == hir::Constness::Const\n+    matches!(tcx.def_kind(parent_id), DefKind::Impl { .. })\n+        && tcx.constness(parent_id) == hir::Constness::Const\n }\n \n /// Checks whether an item is considered to be `const`. If it is a constructor, it is const. If"}, {"sha": "0599ae04a90abdfa6a8d1487d6a98867a8c12152", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -116,7 +116,9 @@ pub enum DefKind {\n     LifetimeParam,\n     /// A use of `global_asm!`.\n     GlobalAsm,\n-    Impl,\n+    Impl {\n+        of_trait: bool,\n+    },\n     Closure,\n     Generator,\n }\n@@ -155,7 +157,7 @@ impl DefKind {\n             DefKind::AnonConst => \"constant expression\",\n             DefKind::InlineConst => \"inline constant\",\n             DefKind::Field => \"field\",\n-            DefKind::Impl => \"implementation\",\n+            DefKind::Impl { .. } => \"implementation\",\n             DefKind::Closure => \"closure\",\n             DefKind::Generator => \"generator\",\n             DefKind::ExternCrate => \"extern crate\",\n@@ -171,7 +173,7 @@ impl DefKind {\n             | DefKind::AssocFn\n             | DefKind::Enum\n             | DefKind::OpaqueTy\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::Use\n             | DefKind::InlineConst\n             | DefKind::ExternCrate => \"an\",\n@@ -216,7 +218,7 @@ impl DefKind {\n             | DefKind::Use\n             | DefKind::ForeignMod\n             | DefKind::GlobalAsm\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::ImplTraitPlaceholder => None,\n         }\n     }\n@@ -255,7 +257,7 @@ impl DefKind {\n             | DefKind::ForeignMod\n             | DefKind::OpaqueTy\n             | DefKind::ImplTraitPlaceholder\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::Field\n             | DefKind::TyParam\n             | DefKind::ConstParam"}, {"sha": "961deac544a8843d03cd4e7917737e85f0b09bf7", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -116,7 +116,7 @@ impl Target {\n             DefKind::Union => Target::Union,\n             DefKind::Trait => Target::Trait,\n             DefKind::TraitAlias => Target::TraitAlias,\n-            DefKind::Impl => Target::Impl,\n+            DefKind::Impl { .. } => Target::Impl,\n             _ => panic!(\"impossible case reached\"),\n         }\n     }"}, {"sha": "49ad09800a5a05eba56c45f5a48f0f3791320672", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 40, "deletions": 69, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -21,7 +21,9 @@ use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, AdtDef, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, AdtDef, DefIdTree, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n+};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n@@ -174,16 +176,8 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         Ok(l) => l,\n         // Foreign statics that overflow their allowed size should emit an error\n         Err(LayoutError::SizeOverflow(_))\n-            if {\n-                let node = tcx.hir().get_by_def_id(def_id);\n-                matches!(\n-                    node,\n-                    hir::Node::ForeignItem(hir::ForeignItem {\n-                        kind: hir::ForeignItemKind::Static(..),\n-                        ..\n-                    })\n-                )\n-            } =>\n+            if matches!(tcx.def_kind(def_id), DefKind::Static(_)\n+                if tcx.def_kind(tcx.local_parent(def_id)) == DefKind::ForeignMod) =>\n         {\n             tcx.sess\n                 .struct_span_err(span, \"extern static is too large for the current architecture\")\n@@ -215,7 +209,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n fn check_opaque(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     let item = tcx.hir().item(id);\n     let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item.kind else {\n-        tcx.sess.delay_span_bug(tcx.hir().span(id.hir_id()), \"expected opaque item\");\n+        tcx.sess.delay_span_bug(item.span, \"expected opaque item\");\n         return;\n     };\n \n@@ -529,45 +523,34 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             check_enum(tcx, id.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n-        DefKind::Impl => {\n-            let it = tcx.hir().item(id);\n-            let hir::ItemKind::Impl(impl_) = it.kind else { return };\n-            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n+        DefKind::Impl { of_trait } => {\n+            if of_trait && let Some(impl_trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n-                    it.span,\n-                    it.owner_id.def_id,\n+                    id.owner_id.def_id,\n                     impl_trait_ref.subst_identity(),\n-                    &impl_.items,\n                 );\n-                check_on_unimplemented(tcx, it);\n+                check_on_unimplemented(tcx, id);\n             }\n         }\n         DefKind::Trait => {\n-            let it = tcx.hir().item(id);\n-            let hir::ItemKind::Trait(_, _, _, _, items) = it.kind else {\n-                return;\n-            };\n-            check_on_unimplemented(tcx, it);\n-\n-            for item in items.iter() {\n-                let item = tcx.hir().trait_item(item.id);\n-                match &item.kind {\n-                    hir::TraitItemKind::Fn(sig, _) => {\n-                        let abi = sig.header.abi;\n-                        fn_maybe_err(tcx, item.ident.span, abi);\n+            let assoc_items = tcx.associated_items(id.owner_id);\n+            check_on_unimplemented(tcx, id);\n+\n+            for assoc_item in assoc_items.in_definition_order() {\n+                match assoc_item.kind {\n+                    ty::AssocKind::Fn => {\n+                        let abi = tcx.fn_sig(assoc_item.def_id).skip_binder().abi();\n+                        fn_maybe_err(tcx, assoc_item.ident(tcx).span, abi);\n                     }\n-                    hir::TraitItemKind::Type(.., Some(default)) => {\n-                        let assoc_item = tcx.associated_item(item.owner_id);\n+                    ty::AssocKind::Type if assoc_item.defaultness(tcx).has_value() => {\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, it.owner_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, id.owner_id.to_def_id());\n                         let _: Result<_, rustc_errors::ErrorGuaranteed> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n                             assoc_item,\n-                            default.span,\n-                            tcx.mk_trait_ref(it.owner_id.to_def_id(), trait_substs),\n+                            tcx.mk_trait_ref(id.owner_id.to_def_id(), trait_substs),\n                         );\n                     }\n                     _ => {}\n@@ -679,7 +662,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     }\n }\n \n-pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n+pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: hir::ItemId) {\n     // an error would be reported if this fails.\n     let _ = OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n@@ -689,7 +672,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n     trait_def: &ty::TraitDef,\n     trait_item: &ty::AssocItem,\n     impl_id: DefId,\n-    impl_item: &hir::ImplItemRef,\n+    impl_item: DefId,\n ) {\n     let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) else { return };\n     let mut ancestor_impls = ancestors.skip(1).filter_map(|parent| {\n@@ -735,10 +718,8 @@ pub(super) fn check_specialization_validity<'tcx>(\n \n fn check_impl_items_against_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    full_impl_span: Span,\n     impl_id: LocalDefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item_refs: &[hir::ImplItemRef],\n ) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -747,12 +728,14 @@ fn check_impl_items_against_trait<'tcx>(\n         return;\n     }\n \n+    let impl_item_refs = tcx.associated_item_def_ids(impl_id);\n+\n     // Negative impls are not expected to have any items\n     match tcx.impl_polarity(impl_id) {\n         ty::ImplPolarity::Reservation | ty::ImplPolarity::Positive => {}\n         ty::ImplPolarity::Negative => {\n             if let [first_item_ref, ..] = impl_item_refs {\n-                let first_item_span = tcx.hir().impl_item(first_item_ref.id).span;\n+                let first_item_span = tcx.def_span(first_item_ref);\n                 struct_span_err!(\n                     tcx.sess,\n                     first_item_span,\n@@ -767,43 +750,27 @@ fn check_impl_items_against_trait<'tcx>(\n \n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n \n-    for impl_item in impl_item_refs {\n-        let ty_impl_item = tcx.associated_item(impl_item.id.owner_id);\n+    for &impl_item in impl_item_refs {\n+        let ty_impl_item = tcx.associated_item(impl_item);\n         let ty_trait_item = if let Some(trait_item_id) = ty_impl_item.trait_item_def_id {\n             tcx.associated_item(trait_item_id)\n         } else {\n             // Checked in `associated_item`.\n-            tcx.sess.delay_span_bug(impl_item.span, \"missing associated item in trait\");\n+            tcx.sess.delay_span_bug(tcx.def_span(impl_item), \"missing associated item in trait\");\n             continue;\n         };\n-        let impl_item_full = tcx.hir().impl_item(impl_item.id);\n-        match impl_item_full.kind {\n-            hir::ImplItemKind::Const(..) => {\n+        match ty_impl_item.kind {\n+            ty::AssocKind::Const => {\n                 let _ = tcx.compare_impl_const((\n-                    impl_item.id.owner_id.def_id,\n+                    impl_item.expect_local(),\n                     ty_impl_item.trait_item_def_id.unwrap(),\n                 ));\n             }\n-            hir::ImplItemKind::Fn(..) => {\n-                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                compare_impl_method(\n-                    tcx,\n-                    &ty_impl_item,\n-                    &ty_trait_item,\n-                    impl_trait_ref,\n-                    opt_trait_span,\n-                );\n+            ty::AssocKind::Fn => {\n+                compare_impl_method(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n             }\n-            hir::ImplItemKind::Type(impl_ty) => {\n-                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                compare_impl_ty(\n-                    tcx,\n-                    &ty_impl_item,\n-                    impl_ty.span,\n-                    &ty_trait_item,\n-                    impl_trait_ref,\n-                    opt_trait_span,\n-                );\n+            ty::AssocKind::Type => {\n+                compare_impl_ty(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n             }\n         }\n \n@@ -838,6 +805,8 @@ fn check_impl_items_against_trait<'tcx>(\n                 .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n \n             if !is_implemented_here {\n+                let full_impl_span =\n+                    tcx.hir().span_with_body(tcx.hir().local_def_id_to_hir_id(impl_id));\n                 match tcx.eval_default_body_stability(trait_item_id, full_impl_span) {\n                     EvalResult::Deny { feature, reason, issue, .. } => default_body_is_unstable(\n                         tcx,\n@@ -864,6 +833,8 @@ fn check_impl_items_against_trait<'tcx>(\n         }\n \n         if !missing_items.is_empty() {\n+            let full_impl_span =\n+                tcx.hir().span_with_body(tcx.hir().local_def_id_to_hir_id(impl_id));\n             missing_items_err(tcx, tcx.def_span(impl_id), &missing_items, full_impl_span);\n         }\n "}, {"sha": "50f9bbc022e7cf91317d0920ab7bf5485ab17f30", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -33,31 +33,26 @@ use std::iter;\n /// # Parameters\n ///\n /// - `impl_m`: type of the method we are checking\n-/// - `impl_m_span`: span to use for reporting errors\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n pub(super) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    trait_item_span: Option<Span>,\n ) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let impl_m_span = tcx.def_span(impl_m.def_id);\n-\n     let _: Result<_, ErrorGuaranteed> = try {\n-        compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)?;\n-        compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false)?;\n+        compare_self_type(tcx, impl_m, trait_m, impl_trait_ref)?;\n+        compare_number_of_generics(tcx, impl_m, trait_m, false)?;\n         compare_generic_param_kinds(tcx, impl_m, trait_m, false)?;\n-        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_number_of_method_arguments(tcx, impl_m, trait_m)?;\n         compare_synthetic_generics(tcx, impl_m, trait_m)?;\n-        compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_asyncness(tcx, impl_m, trait_m)?;\n         compare_method_predicate_entailment(\n             tcx,\n             impl_m,\n-            impl_m_span,\n             trait_m,\n             impl_trait_ref,\n             CheckImpliedWfMode::Check,\n@@ -131,11 +126,10 @@ pub(super) fn compare_impl_method<'tcx>(\n ///\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n-#[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n+#[instrument(level = \"debug\", skip(tcx, impl_trait_ref))]\n fn compare_method_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     check_implied_wf: CheckImpliedWfMode,\n@@ -148,6 +142,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     // FIXME(@lcnr): remove that after removing `cause.body_id` from\n     // obligations.\n     let impl_m_def_id = impl_m.def_id.expect_local();\n+    let impl_m_span = tcx.def_span(impl_m_def_id);\n     let cause = ObligationCause::new(\n         impl_m_span,\n         impl_m_def_id,\n@@ -315,7 +310,6 @@ fn compare_method_predicate_entailment<'tcx>(\n                 return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n-                    impl_m_span,\n                     trait_m,\n                     impl_trait_ref,\n                     CheckImpliedWfMode::Skip,\n@@ -353,7 +347,6 @@ fn compare_method_predicate_entailment<'tcx>(\n                 return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n-                    impl_m_span,\n                     trait_m,\n                     impl_trait_ref,\n                     CheckImpliedWfMode::Skip,\n@@ -535,9 +528,7 @@ enum CheckImpliedWfMode {\n fn compare_asyncness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n-    trait_item_span: Option<Span>,\n ) -> Result<(), ErrorGuaranteed> {\n     if tcx.asyncness(trait_m.def_id) == hir::IsAsync::Async {\n         match tcx.fn_sig(impl_m.def_id).skip_binder().skip_binder().output().kind() {\n@@ -549,9 +540,9 @@ fn compare_asyncness<'tcx>(\n             }\n             _ => {\n                 return Err(tcx.sess.emit_err(crate::errors::AsyncTraitImplShouldBeAsync {\n-                    span: impl_m_span,\n+                    span: tcx.def_span(impl_m.def_id),\n                     method_name: trait_m.name,\n-                    trait_item_span,\n+                    trait_item_span: tcx.hir().span_if_local(trait_m.def_id),\n                 }));\n             }\n         };\n@@ -606,7 +597,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n \n     // First, check a few of the same things as `compare_impl_method`,\n     // just so we don't ICE during substitution later.\n-    compare_number_of_generics(tcx, impl_m, trait_m, tcx.hir().span_if_local(impl_m.def_id), true)?;\n+    compare_number_of_generics(tcx, impl_m, trait_m, true)?;\n     compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n     check_region_bounds_on_impl_item(tcx, impl_m, trait_m, true)?;\n \n@@ -1094,7 +1085,6 @@ fn extract_spans_for_error_reporting<'tcx>(\n fn compare_self_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -1130,6 +1120,7 @@ fn compare_self_type<'tcx>(\n \n         (false, true) => {\n             let self_descr = self_string(impl_m);\n+            let impl_m_span = tcx.def_span(impl_m.def_id);\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 impl_m_span,\n@@ -1149,6 +1140,7 @@ fn compare_self_type<'tcx>(\n \n         (true, false) => {\n             let self_descr = self_string(trait_m);\n+            let impl_m_span = tcx.def_span(impl_m.def_id);\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 impl_m_span,\n@@ -1196,7 +1188,6 @@ fn compare_number_of_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_: &ty::AssocItem,\n     trait_: &ty::AssocItem,\n-    trait_span: Option<Span>,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n@@ -1256,6 +1247,7 @@ fn compare_number_of_generics<'tcx>(\n                     .collect();\n                 (Some(arg_spans), impl_trait_spans)\n             } else {\n+                let trait_span = tcx.hir().span_if_local(trait_.def_id);\n                 (trait_span.map(|s| vec![s]), vec![])\n             };\n \n@@ -1338,9 +1330,7 @@ fn compare_number_of_generics<'tcx>(\n fn compare_number_of_method_arguments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n-    trait_item_span: Option<Span>,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n@@ -1362,7 +1352,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                     }\n                 })\n             })\n-            .or(trait_item_span);\n+            .or_else(|| tcx.hir().span_if_local(trait_m.def_id));\n \n         let (impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         let pos = impl_number_args.saturating_sub(1);\n@@ -1377,7 +1367,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                     arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n                 }\n             })\n-            .unwrap_or(impl_m_span);\n+            .unwrap_or_else(|| tcx.def_span(impl_m.def_id));\n \n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -1747,22 +1737,16 @@ pub(super) fn compare_impl_const_raw(\n pub(super) fn compare_impl_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     trait_ty: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    trait_item_span: Option<Span>,\n ) {\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let _: Result<(), ErrorGuaranteed> = try {\n-        compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n-\n+        compare_number_of_generics(tcx, impl_ty, trait_ty, false)?;\n         compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n-\n-        let sp = tcx.def_span(impl_ty.def_id);\n-        compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;\n-\n-        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)?;\n+        compare_type_predicate_entailment(tcx, impl_ty, trait_ty, impl_trait_ref)?;\n+        check_type_bounds(tcx, trait_ty, impl_ty, impl_trait_ref)?;\n     };\n }\n \n@@ -1771,7 +1755,6 @@ pub(super) fn compare_impl_ty<'tcx>(\n fn compare_type_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     trait_ty: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -1808,6 +1791,7 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     debug!(\"compare_type_predicate_entailment: bounds={:?}\", hybrid_preds);\n \n+    let impl_ty_span = tcx.def_span(impl_ty_def_id);\n     let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_def_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n@@ -1873,7 +1857,6 @@ pub(super) fn check_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ty: &ty::AssocItem,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Given\n@@ -2009,8 +1992,15 @@ pub(super) fn check_type_bounds<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(&infcx);\n \n-    let assumed_wf_types =\n-        ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n+    let impl_ty_span = match tcx.hir().get_by_def_id(impl_ty_def_id) {\n+        hir::Node::TraitItem(hir::TraitItem {\n+            kind: hir::TraitItemKind::Type(_, Some(ty)),\n+            ..\n+        }) => ty.span,\n+        hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Type(ty), .. }) => ty.span,\n+        _ => bug!(),\n+    };\n+    let assumed_wf_types = ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty_def_id);\n \n     let normalize_cause = ObligationCause::new(\n         impl_ty_span,"}, {"sha": "56ac18c492792ac0206ad56b88d0c63963e13eab", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -414,15 +414,15 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                 // Check that sym actually points to a function. Later passes\n                 // depend on this.\n                 hir::InlineAsmOperand::SymFn { anon_const } => {\n-                    let ty = self.tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n+                    let ty = self.tcx.type_of(anon_const.def_id);\n                     match ty.kind() {\n                         ty::Never | ty::Error(_) => {}\n                         ty::FnDef(..) => {}\n                         _ => {\n                             let mut err =\n                                 self.tcx.sess.struct_span_err(*op_sp, \"invalid `sym` operand\");\n                             err.span_label(\n-                                self.tcx.hir().span(anon_const.body.hir_id),\n+                                self.tcx.def_span(anon_const.def_id),\n                                 &format!(\"is {} `{}`\", ty.kind().article(), ty),\n                             );\n                             err.help(\"`sym` operands must refer to either a function or a static\");"}, {"sha": "7b013cabc3ab58bd7e4f3eeeb0206088458e03e4", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -75,7 +75,6 @@ pub use check::check_abi;\n use check::check_mod_item_types;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder};\n-use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_index::bit_set::BitSet;\n@@ -169,27 +168,24 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId) {\n     }\n }\n \n-fn report_forbidden_specialization(\n-    tcx: TyCtxt<'_>,\n-    impl_item: &hir::ImplItemRef,\n-    parent_impl: DefId,\n-) {\n+fn report_forbidden_specialization(tcx: TyCtxt<'_>, impl_item: DefId, parent_impl: DefId) {\n+    let span = tcx.def_span(impl_item);\n+    let ident = tcx.item_name(impl_item);\n     let mut err = struct_span_err!(\n         tcx.sess,\n-        impl_item.span,\n+        span,\n         E0520,\n-        \"`{}` specializes an item from a parent `impl`, but \\\n-         that item is not marked `default`\",\n-        impl_item.ident\n+        \"`{}` specializes an item from a parent `impl`, but that item is not marked `default`\",\n+        ident,\n     );\n-    err.span_label(impl_item.span, format!(\"cannot specialize default item `{}`\", impl_item.ident));\n+    err.span_label(span, format!(\"cannot specialize default item `{}`\", ident));\n \n     match tcx.span_of_impl(parent_impl) {\n         Ok(span) => {\n             err.span_label(span, \"parent `impl` is here\");\n             err.note(&format!(\n                 \"to specialize, `{}` in the parent `impl` must be marked `default`\",\n-                impl_item.ident\n+                ident\n             ));\n         }\n         Err(cname) => {"}, {"sha": "c0ba385987d77b60eeb34d4e7e449ceebc8bdc4b", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -202,8 +202,7 @@ fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'_>, impl_did: LocalDefId)\n fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-    let span = tcx.hir().span(impl_hir_id);\n+    let span = tcx.def_span(impl_did);\n \n     let dispatch_from_dyn_trait = tcx.require_lang_item(LangItem::DispatchFromDyn, Some(span));\n "}, {"sha": "f0b6ab03ad69324b3619e9a04a3cdafd894d67c2", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 37, "deletions": 57, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -14,7 +14,6 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n-use rustc_span::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls(tcx: TyCtxt<'_>, (): ()) -> CrateInherentImpls {\n@@ -57,99 +56,90 @@ const ADD_ATTR: &str =\n     \"alternatively add `#[rustc_allow_incoherent_impl]` to the relevant impl items\";\n \n impl<'tcx> InherentCollect<'tcx> {\n-    fn check_def_id(&mut self, item: &hir::Item<'_>, self_ty: Ty<'tcx>, def_id: DefId, span: Span) {\n-        let impl_def_id = item.owner_id;\n-        if let Some(def_id) = def_id.as_local() {\n+    fn check_def_id(&mut self, impl_def_id: LocalDefId, self_ty: Ty<'tcx>, ty_def_id: DefId) {\n+        if let Some(ty_def_id) = ty_def_id.as_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n+            let vec = self.impls_map.inherent_impls.entry(ty_def_id).or_default();\n             vec.push(impl_def_id.to_def_id());\n             return;\n         }\n \n         if self.tcx.features().rustc_attrs {\n-            let hir::ItemKind::Impl(&hir::Impl { items, .. }) = item.kind else {\n-                bug!(\"expected `impl` item: {:?}\", item);\n-            };\n+            let items = self.tcx.associated_item_def_ids(impl_def_id);\n \n-            if !self.tcx.has_attr(def_id, sym::rustc_has_incoherent_inherent_impls) {\n+            if !self.tcx.has_attr(ty_def_id, sym::rustc_has_incoherent_inherent_impls) {\n+                let impl_span = self.tcx.def_span(impl_def_id);\n                 struct_span_err!(\n                     self.tcx.sess,\n-                    span,\n+                    impl_span,\n                     E0390,\n                     \"cannot define inherent `impl` for a type outside of the crate where the type is defined\",\n                 )\n                 .help(INTO_DEFINING_CRATE)\n-                .span_help(span, ADD_ATTR_TO_TY)\n+                .span_help(impl_span, ADD_ATTR_TO_TY)\n                 .emit();\n                 return;\n             }\n \n-            for impl_item in items {\n-                if !self\n-                    .tcx\n-                    .has_attr(impl_item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n-                {\n+            for &impl_item in items {\n+                if !self.tcx.has_attr(impl_item, sym::rustc_allow_incoherent_impl) {\n+                    let impl_span = self.tcx.def_span(impl_def_id);\n                     struct_span_err!(\n                         self.tcx.sess,\n-                        span,\n+                        impl_span,\n                         E0390,\n                         \"cannot define inherent `impl` for a type outside of the crate where the type is defined\",\n                     )\n                     .help(INTO_DEFINING_CRATE)\n-                    .span_help(self.tcx.hir().span(impl_item.id.hir_id()), ADD_ATTR)\n+                    .span_help(self.tcx.def_span(impl_item), ADD_ATTR)\n                     .emit();\n                     return;\n                 }\n             }\n \n             if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) {\n-                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id.def_id);\n+                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n             }\n         } else {\n+            let impl_span = self.tcx.def_span(impl_def_id);\n             struct_span_err!(\n                 self.tcx.sess,\n-                span,\n+                impl_span,\n                 E0116,\n                 \"cannot define inherent `impl` for a type outside of the crate \\\n                               where the type is defined\"\n             )\n-            .span_label(span, \"impl for type defined outside of crate.\")\n+            .span_label(impl_span, \"impl for type defined outside of crate.\")\n             .note(\"define and implement a trait or new type instead\")\n             .emit();\n         }\n     }\n \n-    fn check_primitive_impl(\n-        &mut self,\n-        impl_def_id: LocalDefId,\n-        ty: Ty<'tcx>,\n-        items: &[hir::ImplItemRef],\n-        span: Span,\n-    ) {\n+    fn check_primitive_impl(&mut self, impl_def_id: LocalDefId, ty: Ty<'tcx>) {\n+        let items = self.tcx.associated_item_def_ids(impl_def_id);\n         if !self.tcx.hir().rustc_coherence_is_core() {\n             if self.tcx.features().rustc_attrs {\n-                for item in items {\n-                    if !self\n-                        .tcx\n-                        .has_attr(item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n-                    {\n+                for &impl_item in items {\n+                    if !self.tcx.has_attr(impl_item, sym::rustc_allow_incoherent_impl) {\n+                        let span = self.tcx.def_span(impl_def_id);\n                         struct_span_err!(\n                             self.tcx.sess,\n                             span,\n                             E0390,\n                             \"cannot define inherent `impl` for primitive types outside of `core`\",\n                         )\n                         .help(INTO_CORE)\n-                        .span_help(item.span, ADD_ATTR)\n+                        .span_help(self.tcx.def_span(impl_item), ADD_ATTR)\n                         .emit();\n                         return;\n                     }\n                 }\n             } else {\n+                let span = self.tcx.def_span(impl_def_id);\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     span,\n@@ -177,35 +167,27 @@ impl<'tcx> InherentCollect<'tcx> {\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {\n-        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::Impl) {\n+        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::Impl { of_trait: false }) {\n             return;\n         }\n \n-        let item = self.tcx.hir().item(id);\n-        let impl_span = self.tcx.hir().span(id.hir_id());\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, items, .. }) = item.kind else {\n-            return;\n-        };\n-\n-        let self_ty = self.tcx.type_of(item.owner_id);\n+        let id = id.owner_id.def_id;\n+        let item_span = self.tcx.def_span(id);\n+        let self_ty = self.tcx.type_of(id);\n         match *self_ty.kind() {\n-            ty::Adt(def, _) => {\n-                self.check_def_id(item, self_ty, def.did(), impl_span);\n-            }\n-            ty::Foreign(did) => {\n-                self.check_def_id(item, self_ty, did, impl_span);\n-            }\n+            ty::Adt(def, _) => self.check_def_id(id, self_ty, def.did()),\n+            ty::Foreign(did) => self.check_def_id(id, self_ty, did),\n             ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n-                self.check_def_id(item, self_ty, data.principal_def_id().unwrap(), impl_span);\n+                self.check_def_id(id, self_ty, data.principal_def_id().unwrap());\n             }\n             ty::Dynamic(..) => {\n                 struct_span_err!(\n                     self.tcx.sess,\n-                    impl_span,\n+                    item_span,\n                     E0785,\n                     \"cannot define inherent `impl` for a dyn auto trait\"\n                 )\n-                .span_label(impl_span, \"impl requires at least one non-auto trait\")\n+                .span_label(item_span, \"impl requires at least one non-auto trait\")\n                 .note(\"define and implement a new trait or type instead\")\n                 .emit();\n             }\n@@ -221,18 +203,16 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Ref(..)\n             | ty::Never\n             | ty::FnPtr(_)\n-            | ty::Tuple(..) => {\n-                self.check_primitive_impl(item.owner_id.def_id, self_ty, items, impl_span)\n-            }\n+            | ty::Tuple(..) => self.check_primitive_impl(id, self_ty),\n             ty::Alias(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n-                    impl_span,\n+                    item_span,\n                     E0118,\n                     \"no nominal type found for inherent implementation\"\n                 );\n \n-                err.span_label(impl_span, \"impl requires a nominal type\")\n+                err.span_label(item_span, \"impl requires a nominal type\")\n                     .note(\"either implement a trait on it or create a newtype to wrap it instead\");\n \n                 err.emit();\n@@ -245,7 +225,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Bound(..)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => {\n-                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.owner_id, self_ty);\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", id, self_ty);\n             }\n             ty::Error(_) => {}\n         }"}, {"sha": "f0a0e7e3e929354e66d81f0e6d9f75abdfcc7270", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -39,25 +39,27 @@ fn do_orphan_check_impl<'tcx>(\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_def_id = trait_ref.def_id;\n \n-    let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(impl_) = item.kind else {\n-        bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n-    };\n-    let sp = tcx.def_span(def_id);\n-    let tr = impl_.of_trait.as_ref().unwrap();\n-\n-    match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n+    match traits::orphan_check(tcx, def_id.to_def_id()) {\n         Ok(()) => {}\n-        Err(err) => emit_orphan_check_error(\n-            tcx,\n-            sp,\n-            item.span,\n-            tr.path.span,\n-            trait_ref,\n-            impl_.self_ty.span,\n-            &impl_.generics,\n-            err,\n-        )?,\n+        Err(err) => {\n+            let item = tcx.hir().expect_item(def_id);\n+            let hir::ItemKind::Impl(impl_) = item.kind else {\n+                bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n+            };\n+            let tr = impl_.of_trait.as_ref().unwrap();\n+            let sp = tcx.def_span(def_id);\n+\n+            emit_orphan_check_error(\n+                tcx,\n+                sp,\n+                item.span,\n+                tr.path.span,\n+                trait_ref,\n+                impl_.self_ty.span,\n+                &impl_.generics,\n+                err,\n+            )?\n+        }\n     }\n \n     // In addition to the above rules, we restrict impls of auto traits\n@@ -235,7 +237,10 @@ fn do_orphan_check_impl<'tcx>(\n             | ty::GeneratorWitnessMIR(..)\n             | ty::Bound(..)\n             | ty::Placeholder(..)\n-            | ty::Infer(..) => span_bug!(sp, \"weird self type for autotrait impl\"),\n+            | ty::Infer(..) => {\n+                let sp = tcx.def_span(def_id);\n+                span_bug!(sp, \"weird self type for autotrait impl\")\n+            }\n \n             ty::Error(..) => (LocalImpl::Allow, NonlocalImpl::Allow),\n         };\n@@ -254,6 +259,7 @@ fn do_orphan_check_impl<'tcx>(\n                                 is one of the trait object's trait bounds\",\n                         trait = tcx.def_path_str(trait_def_id),\n                     );\n+                    let sp = tcx.def_span(def_id);\n                     let reported =\n                         struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).note(label).emit();\n                     return Err(reported);\n@@ -282,6 +288,7 @@ fn do_orphan_check_impl<'tcx>(\n                             non-struct/enum type\",\n                 )),\n             } {\n+                let sp = tcx.def_span(def_id);\n                 let reported =\n                     struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n                 return Err(reported);"}, {"sha": "d8606f759b24b30b1c9964917e0ff66205e0cfe8", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -1563,7 +1563,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // See issue #83753. If someone writes an associated type on a non-trait, just treat it as\n             // there being no supertrait HRTBs.\n             match tcx.def_kind(def_id) {\n-                DefKind::Trait | DefKind::TraitAlias | DefKind::Impl => {}\n+                DefKind::Trait | DefKind::TraitAlias | DefKind::Impl { .. } => {}\n                 _ => break None,\n             }\n "}, {"sha": "4f30318412d7e860c7aa719a971a0268b9e25dec", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -55,7 +55,7 @@ fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let min_specialization = tcx.features().min_specialization;\n     let module = tcx.hir_module_items(module_def_id);\n     for id in module.items() {\n-        if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Impl { .. }) {\n             enforce_impl_params_are_constrained(tcx, id.owner_id.def_id);\n             if min_specialization {\n                 check_min_specialization(tcx, id.owner_id.def_id);"}, {"sha": "2b5a19914a327112047f0a743a56441e268d7b25", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -1061,7 +1061,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                 };\n \n                 let parent_def_id = generics.parent.unwrap();\n-                if tcx.def_kind(parent_def_id) == DefKind::Impl {\n+                if let DefKind::Impl { .. } = tcx.def_kind(parent_def_id) {\n                     let parent_ty = tcx.bound_type_of(parent_def_id).subst(tcx, substs);\n                     match (parent_ty.kind(), &ty.kind) {\n                         ("}, {"sha": "43047051f0f65578020c7129ae0f990b729ab32e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -838,7 +838,7 @@ fn should_encode_visibility(def_kind: DefKind) -> bool {\n         | DefKind::ForeignMod\n         | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::Field => true,\n         DefKind::TyParam\n         | DefKind::ConstParam\n@@ -873,7 +873,7 @@ fn should_encode_stability(def_kind: DefKind) -> bool {\n         | DefKind::ImplTraitPlaceholder\n         | DefKind::Enum\n         | DefKind::Union\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::Trait\n         | DefKind::TraitAlias\n         | DefKind::Macro(..)\n@@ -951,7 +951,7 @@ fn should_encode_variances(def_kind: DefKind) -> bool {\n         | DefKind::Const\n         | DefKind::ForeignMod\n         | DefKind::TyAlias\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::Trait\n         | DefKind::TraitAlias\n         | DefKind::Macro(..)\n@@ -988,7 +988,7 @@ fn should_encode_generics(def_kind: DefKind) -> bool {\n         | DefKind::InlineConst\n         | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::Field\n         | DefKind::TyParam\n         | DefKind::Closure\n@@ -1018,7 +1018,7 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n         | DefKind::TyAlias\n         | DefKind::OpaqueTy\n         | DefKind::ForeignTy\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::AssocFn\n         | DefKind::AssocConst\n         | DefKind::Closure\n@@ -1081,7 +1081,7 @@ fn should_encode_const(def_kind: DefKind) -> bool {\n         | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n         | DefKind::ForeignTy\n-        | DefKind::Impl\n+        | DefKind::Impl { .. }\n         | DefKind::AssocFn\n         | DefKind::Closure\n         | DefKind::Generator\n@@ -1860,7 +1860,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             FxHashMap::default();\n \n         for id in tcx.hir().items() {\n-            if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+            if matches!(tcx.def_kind(id.owner_id), DefKind::Impl { .. }) {\n                 if let Some(trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n                     let trait_ref = trait_ref.subst_identity();\n \n@@ -2261,7 +2261,7 @@ pub fn provide(providers: &mut Providers) {\n \n             let mut trait_impls = Vec::new();\n             for id in tcx.hir().items() {\n-                if matches!(tcx.def_kind(id.owner_id), DefKind::Impl)\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Impl { .. })\n                     && tcx.impl_trait_ref(id.owner_id).is_some()\n                 {\n                     trait_impls.push(id.owner_id.to_def_id())"}, {"sha": "b89d48ec15ae9265ec0d80b8d5228dfcf2bb7e94", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -136,7 +136,8 @@ fixed_size_enum! {\n         ( Field                                    )\n         ( LifetimeParam                            )\n         ( GlobalAsm                                )\n-        ( Impl                                     )\n+        ( Impl { of_trait: false }                 )\n+        ( Impl { of_trait: true }                  )\n         ( Closure                                  )\n         ( Generator                                )\n         ( Static(ast::Mutability::Not)             )"}, {"sha": "ba93330d5812030449f8a7500f6a1192c3d0339f", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -203,7 +203,7 @@ impl<'hir> Map<'hir> {\n                 ItemKind::Use(..) => DefKind::Use,\n                 ItemKind::ForeignMod { .. } => DefKind::ForeignMod,\n                 ItemKind::GlobalAsm(..) => DefKind::GlobalAsm,\n-                ItemKind::Impl { .. } => DefKind::Impl,\n+                ItemKind::Impl(impl_) => DefKind::Impl { of_trait: impl_.of_trait.is_some() },\n             },\n             Node::ForeignItem(item) => match item.kind {\n                 ForeignItemKind::Fn(..) => DefKind::Fn,"}, {"sha": "7d9396ecd65717248033bd89d490874c50a370d0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -2429,7 +2429,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if let DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy = self.def_kind(def_id) {\n             let parent = self.parent(def_id);\n-            if let DefKind::Impl = self.def_kind(parent) {\n+            if let DefKind::Impl { .. } = self.def_kind(parent) {\n                 return Some(parent);\n             }\n         }"}, {"sha": "35831ff8706428e71b0ac02694a7792aa2c54052", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -167,7 +167,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 | DefKind::Fn\n                 | DefKind::AssocFn\n                 | DefKind::AssocConst\n-                | DefKind::Impl,\n+                | DefKind::Impl { .. },\n                 def_id,\n             ) => Some(def_id),\n             Res::Err => None,"}, {"sha": "bbe4e67977c9449e5871a412ad19c0b837f0c914", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 43, "deletions": 73, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -1191,28 +1191,14 @@ impl<'v> RootCollector<'_, 'v> {\n     fn process_item(&mut self, id: hir::ItemId) {\n         match self.tcx.def_kind(id.owner_id) {\n             DefKind::Enum | DefKind::Struct | DefKind::Union => {\n-                let item = self.tcx.hir().item(id);\n-                match item.kind {\n-                    hir::ItemKind::Enum(_, ref generics)\n-                    | hir::ItemKind::Struct(_, ref generics)\n-                    | hir::ItemKind::Union(_, ref generics) => {\n-                        if generics.params.is_empty() {\n-                            if self.mode == MonoItemCollectionMode::Eager {\n-                                debug!(\n-                                    \"RootCollector: ADT drop-glue for {}\",\n-                                    self.tcx.def_path_str(item.owner_id.to_def_id())\n-                                );\n-\n-                                let ty = Instance::new(\n-                                    item.owner_id.to_def_id(),\n-                                    InternalSubsts::empty(),\n-                                )\n-                                .ty(self.tcx, ty::ParamEnv::reveal_all());\n-                                visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n-                            }\n-                        }\n-                    }\n-                    _ => bug!(),\n+                if self.mode == MonoItemCollectionMode::Eager\n+                    && self.tcx.generics_of(id.owner_id).count() == 0\n+                {\n+                    debug!(\"RootCollector: ADT drop-glue for `{id:?}`\",);\n+\n+                    let ty =\n+                        self.tcx.bound_type_of(id.owner_id.to_def_id()).no_bound_vars().unwrap();\n+                    visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                 }\n             }\n             DefKind::GlobalAsm => {\n@@ -1238,10 +1224,9 @@ impl<'v> RootCollector<'_, 'v> {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n-            DefKind::Impl => {\n+            DefKind::Impl { .. } => {\n                 if self.mode == MonoItemCollectionMode::Eager {\n-                    let item = self.tcx.hir().item(id);\n-                    create_mono_items_for_default_impls(self.tcx, item, self.output);\n+                    create_mono_items_for_default_impls(self.tcx, id, self.output);\n                 }\n             }\n             DefKind::Fn => {\n@@ -1326,66 +1311,51 @@ fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     generics.requires_monomorphization(tcx)\n }\n \n+#[instrument(level = \"debug\", skip(tcx, output))]\n fn create_mono_items_for_default_impls<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &'tcx hir::Item<'tcx>,\n+    item: hir::ItemId,\n     output: &mut MonoItems<'tcx>,\n ) {\n-    match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => {\n-            if matches!(impl_.polarity, hir::ImplPolarity::Negative(_)) {\n-                return;\n-            }\n+    let polarity = tcx.impl_polarity(item.owner_id);\n+    if matches!(polarity, ty::ImplPolarity::Negative) {\n+        return;\n+    }\n \n-            for param in impl_.generics.params {\n-                match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => {}\n-                    hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => {\n-                        return;\n-                    }\n-                }\n-            }\n+    if tcx.generics_of(item.owner_id).own_requires_monomorphization() {\n+        return;\n+    }\n \n-            debug!(\n-                \"create_mono_items_for_default_impls(item={})\",\n-                tcx.def_path_str(item.owner_id.to_def_id())\n-            );\n+    let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) else {\n+        return;\n+    };\n \n-            if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n-                let trait_ref = trait_ref.subst_identity();\n+    let trait_ref = trait_ref.subst_identity();\n \n-                let param_env = ty::ParamEnv::reveal_all();\n-                let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n-                let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n-                for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains_key(&method.def_id) {\n-                        continue;\n-                    }\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n+    let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n+    for method in tcx.provided_trait_methods(trait_ref.def_id) {\n+        if overridden_methods.contains_key(&method.def_id) {\n+            continue;\n+        }\n \n-                    if tcx.generics_of(method.def_id).own_requires_monomorphization() {\n-                        continue;\n-                    }\n+        if tcx.generics_of(method.def_id).own_requires_monomorphization() {\n+            continue;\n+        }\n \n-                    let substs =\n-                        InternalSubsts::for_item(tcx, method.def_id, |param, _| match param.kind {\n-                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                            GenericParamDefKind::Type { .. }\n-                            | GenericParamDefKind::Const { .. } => {\n-                                trait_ref.substs[param.index as usize]\n-                            }\n-                        });\n-                    let instance =\n-                        ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n-\n-                    let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);\n-                    if mono_item.node.is_instantiable(tcx) && should_codegen_locally(tcx, &instance)\n-                    {\n-                        output.push(mono_item);\n-                    }\n-                }\n+        let substs = InternalSubsts::for_item(tcx, method.def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                trait_ref.substs[param.index as usize]\n             }\n+        });\n+        let instance = ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n+\n+        let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);\n+        if mono_item.node.is_instantiable(tcx) && should_codegen_locally(tcx, &instance) {\n+            output.push(mono_item);\n         }\n-        _ => bug!(),\n     }\n }\n "}, {"sha": "207ad332c22c23fe2cd58c863f22ba8585cb1ad2", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -172,7 +172,7 @@ fn mark_used_by_default_parameters<'tcx>(\n         | DefKind::Field\n         | DefKind::LifetimeParam\n         | DefKind::GlobalAsm\n-        | DefKind::Impl => {\n+        | DefKind::Impl { .. } => {\n             for param in &generics.params {\n                 debug!(?param, \"(other)\");\n                 if let ty::GenericParamDefKind::Lifetime = param.kind {"}, {"sha": "fe0cb71d2c18d012db71e71f16ebcc16ea46c060", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -526,10 +526,8 @@ fn check_item<'tcx>(\n                 }\n             }\n         }\n-        DefKind::Impl => {\n-            let of_trait = tcx.impl_trait_ref(id.owner_id);\n-\n-            if of_trait.is_some() {\n+        DefKind::Impl { of_trait } => {\n+            if of_trait {\n                 worklist.push(id.owner_id.def_id);\n             }\n \n@@ -541,7 +539,7 @@ fn check_item<'tcx>(\n \n             // And we access the Map here to get HirId from LocalDefId\n             for id in local_def_ids {\n-                if of_trait.is_some() || has_allow_dead_code_or_lang_attr(tcx, id) {\n+                if of_trait || has_allow_dead_code_or_lang_attr(tcx, id) {\n                     worklist.push(id);\n                 }\n             }"}, {"sha": "678f1815d012cd17fc1d20b82e17bd88b9348fa4", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -145,7 +145,7 @@ fn check_liveness(tcx: TyCtxt<'_>, def_id: DefId) {\n \n     // Don't run unused pass for #[derive()]\n     let parent = tcx.local_parent(local_def_id);\n-    if let DefKind::Impl = tcx.def_kind(parent)\n+    if let DefKind::Impl { .. } = tcx.def_kind(parent)\n         && tcx.has_attr(parent.to_def_id(), sym::automatically_derived)\n     {\n         return;"}, {"sha": "051100c56f81311b6fc47f5a2600b12c2dde2461", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -320,31 +320,28 @@ fn check_item<'tcx>(\n         worklist.push(id.owner_id.def_id);\n     }\n \n-    if !matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+    if !matches!(tcx.def_kind(id.owner_id), DefKind::Impl { of_trait: true }) {\n         return;\n     }\n \n     // We need only trait impls here, not inherent impls, and only non-exported ones\n-    let item = tcx.hir().item(id);\n-    if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n-        item.kind\n-    {\n-        if !effective_visibilities.is_reachable(item.owner_id.def_id) {\n-            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.owner_id.def_id));\n+    if effective_visibilities.is_reachable(id.owner_id.def_id) {\n+        return;\n+    }\n \n-            let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n-                unreachable!();\n-            };\n+    let items = tcx.associated_item_def_ids(id.owner_id);\n+    worklist.extend(items.iter().map(|ii_ref| ii_ref.expect_local()));\n \n-            if !trait_def_id.is_local() {\n-                return;\n-            }\n+    let Some(trait_def_id) = tcx.trait_id_of_impl(id.owner_id.to_def_id()) else {\n+        unreachable!();\n+    };\n \n-            worklist.extend(\n-                tcx.provided_trait_methods(trait_def_id).map(|assoc| assoc.def_id.expect_local()),\n-            );\n-        }\n+    if !trait_def_id.is_local() {\n+        return;\n     }\n+\n+    worklist\n+        .extend(tcx.provided_trait_methods(trait_def_id).map(|assoc| assoc.def_id.expect_local()));\n }\n \n fn has_custom_linkage(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {"}, {"sha": "4675bd79c46297c1c3194b16d626b01c7856719f", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -593,7 +593,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             | DefKind::InlineConst\n             | DefKind::Field\n             | DefKind::GlobalAsm\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::Closure\n             | DefKind::Generator => (),\n         }\n@@ -1997,7 +1997,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            DefKind::Impl => {\n+            DefKind::Impl { .. } => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Impl(ref impl_) = item.kind {\n                     let impl_vis ="}, {"sha": "5dc651638f79de2ba5a58ab0356bf7f4b14a0346", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -987,7 +987,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 | DefKind::LifetimeParam\n                 | DefKind::GlobalAsm\n                 | DefKind::Closure\n-                | DefKind::Impl\n+                | DefKind::Impl { .. }\n                 | DefKind::Generator,\n                 _,\n             )"}, {"sha": "ad151bc2e1bf5f3b4174dde79fe5b54408a355ed", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -733,7 +733,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 | HirDefKind::Use\n                 | HirDefKind::Field\n                 | HirDefKind::GlobalAsm\n-                | HirDefKind::Impl\n+                | HirDefKind::Impl { .. }\n                 | HirDefKind::Closure\n                 | HirDefKind::Generator,\n                 _,"}, {"sha": "2fe9d135fa562f23824b1e379f447a98a1f58b02", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -21,7 +21,7 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n             assumed_wf_types.extend(liberated_sig.inputs_and_output);\n             tcx.intern_type_list(&assumed_wf_types)\n         }\n-        DefKind::Impl => {\n+        DefKind::Impl { .. } => {\n             match tcx.impl_trait_ref(def_id) {\n                 Some(trait_ref) => {\n                     let types: Vec<_> = trait_ref.skip_binder().substs.types().collect();"}, {"sha": "452e14918faf7a2fe0696d990381f7b697833c81", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -140,7 +140,7 @@ impl From<DefKind> for ItemType {\n             | DefKind::Field\n             | DefKind::LifetimeParam\n             | DefKind::GlobalAsm\n-            | DefKind::Impl\n+            | DefKind::Impl { .. }\n             | DefKind::Closure\n             | DefKind::Generator => Self::ForeignType,\n         }"}, {"sha": "b2208da9060dcd0c0db38207c3203718d1f19ec1", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -359,7 +359,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 _ => def_id,\n             })\n             .and_then(|self_id| match tcx.def_kind(self_id) {\n-                DefKind::Impl => self.def_id_to_res(self_id),\n+                DefKind::Impl { .. } => self.def_id_to_res(self_id),\n                 DefKind::Use => None,\n                 def_kind => Some(Res::Def(def_kind, self_id)),\n             })\n@@ -1761,7 +1761,7 @@ fn resolution_failure(\n                             }\n                             Trait | TyAlias | ForeignTy | OpaqueTy | ImplTraitPlaceholder\n                             | TraitAlias | TyParam | Static(_) => \"associated item\",\n-                            Impl | GlobalAsm => unreachable!(\"not a path\"),\n+                            Impl { .. } | GlobalAsm => unreachable!(\"not a path\"),\n                         }\n                     } else {\n                         \"associated item\""}, {"sha": "a37e2772d35584b52f2a7e18b29c37a1e00e241c", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n         for id in cx.tcx.hir().items() {\n-            if matches!(cx.tcx.def_kind(id.owner_id), DefKind::Impl)\n+            if matches!(cx.tcx.def_kind(id.owner_id), DefKind::Impl { .. })\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n                   items,"}, {"sha": "3b8713e2b108cabb356f84dcae45de26d85f2ad9", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -552,7 +552,7 @@ fn non_local_item_children_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: Symbol)\n             .filter(|item| item.ident.name == name)\n             .map(|child| child.res.expect_non_local())\n             .collect(),\n-        DefKind::Impl => tcx\n+        DefKind::Impl { .. } => tcx\n             .associated_item_def_ids(def_id)\n             .iter()\n             .copied()"}, {"sha": "9f36e5315ecc2dad431ebc5d898e5c457b0c3262", "filename": "tests/rustdoc-ui/issue-105742.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Frustdoc-ui%2Fissue-105742.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Frustdoc-ui%2Fissue-105742.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-105742.rs?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -3,38 +3,17 @@\n use std::ops::Index;\n \n pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n     let _ = s;\n }\n \n pub trait SVec: Index<\n     <Self as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n     Output = <Index<<Self as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n     Output = <Self as SVec>::Item> as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n-//~^^^^^ ERROR\n-//~^^^^^^ ERROR\n-//~^^^^^^^ ERROR\n-//~^^^^^^^^ ERROR\n > {\n     type Item<'a, T>;\n \n     fn len(&self) -> <Self as SVec>::Item;\n     //~^ ERROR\n     //~^^ ERROR\n-    //~^^^ ERROR\n-    //~^^^^ ERROR\n }"}, {"sha": "4d2ee9726891797487dc818b7102baf9d919dcba", "filename": "tests/rustdoc-ui/issue-105742.stderr", "status": "modified", "additions": 6, "deletions": 356, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Frustdoc-ui%2Fissue-105742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Frustdoc-ui%2Fissue-105742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-105742.stderr?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -1,360 +1,11 @@\n error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     <Self as SVec>::Item<'a>,\n-   |                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     <Self as SVec>::Item<T>,\n-   |                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<'a>,\n-   |                                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<T>,\n-   |                                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item<'a>> as SVec>::Item,\n-   |                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item<T>> as SVec>::Item,\n-   |                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<'a>,\n-   |                                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<T>,\n-   |                                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:5:40\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                                        ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item<'_> = T, Output = T>) {\n-   |                                            ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:5:40\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                                        ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item<T> = T, Output = T>) {\n-   |                                            +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     <Self as SVec>::Item<'a>,\n-   |                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     <Self as SVec>::Item<T>,\n-   |                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<'a>,\n-   |                                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<T>,\n-   |                                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item<'a>> as SVec>::Item,\n-   |                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item<T>> as SVec>::Item,\n-   |                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<'a>,\n-   |                                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<T>,\n-   |                                                  +++\n-\n-error[E0038]: the trait `SVec` cannot be made into an object\n-  --> $DIR/issue-105742.rs:5:31\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SVec` cannot be made into an object\n-   |\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-105742.rs:12:17\n-   |\n-LL |    pub trait SVec: Index<\n-   |  ____________----__^\n-   | |            |\n-   | |            this trait cannot be made into an object...\n-LL | |      <Self as SVec>::Item,\n-LL | |\n-LL | |\n-...  |\n-LL | |/     Output = <Index<<Self as SVec>::Item,\n-LL | ||\n-LL | ||\n-LL | ||\n-LL | ||\n-LL | ||     Output = <Self as SVec>::Item> as SVec>::Item,\n-   | ||_________________________________________________^ ...because it uses `Self` as a type parameter\n-...  |\n-LL | |\n-LL | |  > {\n-   | |__^ ...because it uses `Self` as a type parameter\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item;\n-   |                                      ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item<'_>;\n-   |                                          ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item;\n-   |                                      ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item<T>;\n-   |                                          +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n+  --> $DIR/issue-105742.rs:16:38\n    |\n LL |     fn len(&self) -> <Self as SVec>::Item;\n    |                                      ^^^^ expected 1 lifetime argument\n    |\n note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n+  --> $DIR/issue-105742.rs:14:10\n    |\n LL |     type Item<'a, T>;\n    |          ^^^^ --\n@@ -364,13 +15,13 @@ LL |     fn len(&self) -> <Self as SVec>::Item<'_>;\n    |                                          ++++\n \n error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n+  --> $DIR/issue-105742.rs:16:38\n    |\n LL |     fn len(&self) -> <Self as SVec>::Item;\n    |                                      ^^^^ expected 1 generic argument\n    |\n note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n+  --> $DIR/issue-105742.rs:14:10\n    |\n LL |     type Item<'a, T>;\n    |          ^^^^     -\n@@ -379,7 +30,6 @@ help: add missing generic argument\n LL |     fn len(&self) -> <Self as SVec>::Item<T>;\n    |                                          +++\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0038, E0107.\n-For more information about an error, try `rustc --explain E0038`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "06658a49b83aaf7684e3c4eec57bb9cddedbce1e", "filename": "tests/ui/error-codes/E0520.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Ferror-codes%2FE0520.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Ferror-codes%2FE0520.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0520.stderr?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -15,7 +15,7 @@ LL | impl<T: Clone> SpaceLlama for T {\n    | ------------------------------- parent `impl` is here\n ...\n LL |     default fn fly(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `fly`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `fly`\n    |\n    = note: to specialize, `fly` in the parent `impl` must be marked `default`\n "}, {"sha": "f9e62a99baee8e5b0db9e0ad3b32173bf088a772", "filename": "tests/ui/specialization/defaultimpl/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn foo(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn bar(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `bar`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `bar`\n    |\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Bar for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     type T = ();\n-   |     ^^^^^^^^^^^^ cannot specialize default item `T`\n+   |     ^^^^^^ cannot specialize default item `T`\n    |\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T: Clone> Baz for T {\n    | ------------------------ parent `impl` is here\n ...\n LL |     fn baz(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `baz`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `baz`\n    |\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T: Clone> Redundant for T {\n    | ------------------------------ parent `impl` is here\n ...\n LL |     fn redundant(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n+   |     ^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n    |\n    = note: to specialize, `redundant` in the parent `impl` must be marked `default`\n "}, {"sha": "3fc29fff230a33289f0c8c120489f8e2a914806a", "filename": "tests/ui/specialization/issue-50452-fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -12,7 +12,7 @@ error[E0520]: `foo` specializes an item from a parent `impl`, but that item is n\n   --> $DIR/issue-50452-fail.rs:10:5\n    |\n LL |     fn foo() {}\n-   |     ^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^ cannot specialize default item `foo`\n ...\n LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here"}, {"sha": "9d62a353da728a497f1ce96b5d2f5b452ab83bee", "filename": "tests/ui/specialization/non-defaulted-item-fail.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     type Ty = Vec<()>;\n-   |     ^^^^^^^^^^^^^^^^^^ cannot specialize default item `Ty`\n+   |     ^^^^^^^ cannot specialize default item `Ty`\n    |\n    = note: to specialize, `Ty` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     const CONST: u8 = 42;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n+   |     ^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n    |\n    = note: to specialize, `CONST` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     fn foo(&self) -> bool { true }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     type Ty = Vec<()>;\n-   |     ^^^^^^^^^^^^^^^^^^ cannot specialize default item `Ty`\n+   |     ^^^^^^^ cannot specialize default item `Ty`\n    |\n    = note: to specialize, `Ty` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     const CONST: u8 = 42;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n+   |     ^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n    |\n    = note: to specialize, `CONST` in the parent `impl` must be marked `default`\n \n@@ -70,7 +70,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     fn foo(&self) -> bool { true }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n "}, {"sha": "695a3f6cc45d10c25a5d0a541140c3449889380c", "filename": "tests/ui/specialization/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn foo(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn bar(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `bar`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `bar`\n    |\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Bar for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     type T = ();\n-   |     ^^^^^^^^^^^^ cannot specialize default item `T`\n+   |     ^^^^^^ cannot specialize default item `T`\n    |\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T: Clone> Baz for T {\n    | ------------------------ parent `impl` is here\n ...\n LL |     fn baz(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `baz`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `baz`\n    |\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T: Clone> Redundant for T {\n    | ------------------------------ parent `impl` is here\n ...\n LL |     default fn redundant(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n    |\n    = note: to specialize, `redundant` in the parent `impl` must be marked `default`\n "}, {"sha": "040d9d14503f0f4dd332138db61d79e9bc21c326", "filename": "tests/ui/traits/negative-impls/no-items.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d14db321b043ffc579a7461464c88d7e3f54f83/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr?ref=2d14db321b043ffc579a7461464c88d7e3f54f83", "patch": "@@ -2,7 +2,7 @@ error[E0749]: negative impls cannot have any items\n   --> $DIR/no-items.rs:8:5\n    |\n LL |     type Foo = i32;\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}]}