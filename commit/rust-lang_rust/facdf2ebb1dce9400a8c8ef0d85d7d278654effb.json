{"sha": "facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhY2RmMmViYjFkY2U5NDAwYThjOGVmMGQ4NWQ3ZDI3ODY1NGVmZmI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-07-31T07:04:06Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-02T22:02:36Z"}, "message": "Add an intital HIR and lowering step", "tree": {"sha": "3ba46bd98df35b4b5d1bc5f1ba491d14adb6f373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ba46bd98df35b4b5d1bc5f1ba491d14adb6f373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "html_url": "https://github.com/rust-lang/rust/commit/facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfd76b364cd01695517467299618ef63f1c0cc07", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfd76b364cd01695517467299618ef63f1c0cc07", "html_url": "https://github.com/rust-lang/rust/commit/cfd76b364cd01695517467299618ef63f1c0cc07"}], "stats": {"total": 18370, "additions": 13918, "deletions": 4452}, "files": [{"sha": "4c761cd5afab7049560a2404e7a5522566daae13", "filename": "mk/crates.mk", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -56,7 +56,7 @@ TARGET_CRATES := libc std flate arena term \\\n \t\t alloc_system\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n-                rustc_data_structures rustc_platform_intrinsics\n+                rustc_data_structures rustc_front rustc_platform_intrinsics\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n TOOLS := compiletest rustdoc rustc rustbook error-index-generator\n \n@@ -71,23 +71,24 @@ DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc rustc_bitflags\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_resolve log syntax serialize rustc_llvm \\\n-\t\t     rustc_trans rustc_privacy rustc_lint\n+\t\t             rustc_trans rustc_privacy rustc_lint rustc_front\n \n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n-\t                log syntax serialize rustc_llvm rustc_platform_intrinsics\n-DEPS_rustc_typeck := rustc syntax rustc_platform_intrinsics\n-DEPS_rustc_borrowck := rustc log graphviz syntax\n-DEPS_rustc_resolve := rustc log syntax\n-DEPS_rustc_privacy := rustc log syntax\n+\t                log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n+DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n+DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n+DEPS_rustc_resolve := rustc rustc_front log syntax\n+DEPS_rustc_privacy := rustc rustc_front log syntax\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n-DEPS_rustc_back := std syntax rustc_llvm flate log libc\n+DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n+DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n-                test rustc_lint\n+                test rustc_lint rustc_front\n DEPS_rustc_bitflags := core\n DEPS_flate := std native:miniz\n DEPS_arena := std"}, {"sha": "12f560be45621524cc830294de53e83536bde88a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -268,7 +268,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_owned(),\n                             \"-Zunstable-options\".to_owned(),\n-                            \"--pretty\".to_owned(),\n+                            \"--unpretty\".to_owned(),\n                             pretty_type,\n                             format!(\"--target={}\", config.target),\n                             \"-L\".to_owned(),"}, {"sha": "4e16d9e5670895678a4b3857d712a8c98cae44f7", "filename": "src/librustc/front/map/blocks.rs", "status": "renamed", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -23,12 +23,13 @@\n \n pub use self::Code::*;\n \n-use ast_map::{self, Node};\n+use front::map::{self, Node};\n use syntax::abi;\n-use syntax::ast::{Block, FnDecl, NodeId};\n-use syntax::ast;\n+use rustc_front::hir::{Block, FnDecl};\n+use syntax::ast::{NodeId, Ident};\n+use rustc_front::hir as ast;\n use syntax::codemap::Span;\n-use syntax::visit::FnKind;\n+use rustc_front::visit::FnKind;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl\n /// and a body (as well as a NodeId, a span, etc).\n@@ -40,7 +41,7 @@ use syntax::visit::FnKind;\n ///\n /// To construct one, use the `Code::from_node` function.\n #[derive(Copy, Clone)]\n-pub struct FnLikeNode<'a> { node: ast_map::Node<'a> }\n+pub struct FnLikeNode<'a> { node: map::Node<'a> }\n \n /// MaybeFnLike wraps a method that indicates if an object\n /// corresponds to some FnLikeNode.\n@@ -86,7 +87,7 @@ pub enum Code<'a> {\n }\n \n impl<'a> Code<'a> {\n-    pub fn id(&self) -> ast::NodeId {\n+    pub fn id(&self) -> NodeId {\n         match *self {\n             FnLikeCode(node) => node.id(),\n             BlockCode(block) => block.id,\n@@ -95,7 +96,7 @@ impl<'a> Code<'a> {\n \n     /// Attempts to construct a Code from presumed FnLike or Block node input.\n     pub fn from_node(node: Node) -> Option<Code> {\n-        if let ast_map::NodeBlock(block) = node {\n+        if let map::NodeBlock(block) = node {\n             Some(BlockCode(block))\n         } else {\n             FnLikeNode::from_node(node).map(|fn_like| FnLikeCode(fn_like))\n@@ -106,15 +107,15 @@ impl<'a> Code<'a> {\n /// These are all the components one can extract from a fn item for\n /// use when implementing FnLikeNode operations.\n struct ItemFnParts<'a> {\n-    ident:    ast::Ident,\n+    ident:    Ident,\n     decl:     &'a ast::FnDecl,\n     unsafety: ast::Unsafety,\n     constness: ast::Constness,\n     abi:      abi::Abi,\n     vis:      ast::Visibility,\n     generics: &'a ast::Generics,\n     body:     &'a Block,\n-    id:       ast::NodeId,\n+    id:       NodeId,\n     span:     Span\n }\n \n@@ -137,10 +138,10 @@ impl<'a> FnLikeNode<'a> {\n     /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n     pub fn from_node(node: Node) -> Option<FnLikeNode> {\n         let fn_like = match node {\n-            ast_map::NodeItem(item) => item.is_fn_like(),\n-            ast_map::NodeTraitItem(tm) => tm.is_fn_like(),\n-            ast_map::NodeImplItem(_) => true,\n-            ast_map::NodeExpr(e) => e.is_fn_like(),\n+            map::NodeItem(item) => item.is_fn_like(),\n+            map::NodeTraitItem(tm) => tm.is_fn_like(),\n+            map::NodeImplItem(_) => true,\n+            map::NodeExpr(e) => e.is_fn_like(),\n             _ => false\n         };\n         if fn_like {\n@@ -202,7 +203,7 @@ impl<'a> FnLikeNode<'a> {\n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n         M: FnOnce(NodeId,\n-                  ast::Ident,\n+                  Ident,\n                   &'a ast::MethodSig,\n                   Option<ast::Visibility>,\n                   &'a ast::Block,\n@@ -211,7 +212,7 @@ impl<'a> FnLikeNode<'a> {\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n-            ast_map::NodeItem(i) => match i.node {\n+            map::NodeItem(i) => match i.node {\n                 ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, ref block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n@@ -227,13 +228,13 @@ impl<'a> FnLikeNode<'a> {\n                     }),\n                 _ => panic!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeTraitItem(ti) => match ti.node {\n+            map::NodeTraitItem(ti) => match ti.node {\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n                     method(ti.id, ti.ident, sig, None, body, ti.span)\n                 }\n                 _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeImplItem(ii) => {\n+            map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::MethodImplItem(ref sig, ref body) => {\n                         method(ii.id, ii.ident, sig, Some(ii.vis), body, ii.span)\n@@ -243,7 +244,7 @@ impl<'a> FnLikeNode<'a> {\n                     }\n                 }\n             }\n-            ast_map::NodeExpr(e) => match e.node {\n+            map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, ref decl, ref block) =>\n                     closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 _ => panic!(\"expr FnLikeNode that is not fn-like\"),", "previous_filename": "src/librustc/ast_map/blocks.rs"}, {"sha": "764f54ce0f0c1599be263eeae8fa54d33411b116", "filename": "src/librustc/front/map/mod.rs", "status": "renamed", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,14 +15,17 @@ use self::MapEntry::*;\n use metadata::inline::InlinedItem;\n use metadata::inline::InlinedItem as II;\n use middle::def_id::DefId;\n+\n use syntax::abi;\n-use syntax::ast::*;\n-use syntax::ast_util;\n-use syntax::codemap::{DUMMY_SP, Span, Spanned};\n-use syntax::fold::Folder;\n+use syntax::ast::{Name, NodeId, Ident, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::codemap::{Span, Spanned};\n use syntax::parse::token;\n-use syntax::print::pprust;\n-use syntax::visit::{self, Visitor};\n+\n+use rustc_front::hir::*;\n+use rustc_front::fold::Folder;\n+use rustc_front::visit::{self, Visitor};\n+use rustc_front::util;\n+use rustc_front::print::pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n@@ -159,7 +162,7 @@ impl<'ast> Clone for MapEntry<'ast> {\n }\n \n #[derive(Debug)]\n-struct InlinedParent {\n+pub struct InlinedParent {\n     path: Vec<PathElem>,\n     ii: InlinedItem\n }\n@@ -227,7 +230,7 @@ impl<'ast> MapEntry<'ast> {\n \n /// Stores a crate and any number of inlined items from other crates.\n pub struct Forest {\n-    krate: Crate,\n+    pub krate: Crate,\n     inlined_items: TypedArena<InlinedParent>\n }\n \n@@ -246,9 +249,10 @@ impl Forest {\n \n /// Represents a mapping from Node IDs to AST elements and their parent\n /// Node IDs\n+#[derive(Clone)]\n pub struct Map<'ast> {\n     /// The backing storage for all the AST nodes.\n-    forest: &'ast Forest,\n+    pub forest: &'ast Forest,\n \n     /// NodeIds are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n@@ -870,7 +874,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        let id = ast_util::stmt_id(stmt);\n+        let id = util::stmt_id(stmt);\n         self.insert(id, NodeStmt(stmt));\n         let parent_node = self.parent_node;\n         self.parent_node = id;\n@@ -917,20 +921,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n }\n \n-pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map<'ast> {\n-    // Replace the crate with an empty one to take it out.\n-    let krate = mem::replace(&mut forest.krate, Crate {\n-        module: Mod {\n-            inner: DUMMY_SP,\n-            items: vec![],\n-        },\n-        attrs: vec![],\n-        config: vec![],\n-        exported_macros: vec![],\n-        span: DUMMY_SP\n-    });\n-    forest.krate = IdAndSpanUpdater { fold_ops: fold_ops }.fold_crate(krate);\n-\n+pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n     let mut collector = NodeCollector {\n         map: vec![],\n         parent_node: CRATE_NODE_ID,\n@@ -974,11 +965,11 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n         II::Item(i) => II::Item(fld.fold_item(i).expect_one(\"expected one item\")),\n         II::TraitItem(d, ti) => {\n             II::TraitItem(fld.fold_ops.new_def_id(d),\n-                          fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n+                        fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n         }\n         II::ImplItem(d, ii) => {\n             II::ImplItem(fld.fold_ops.new_def_id(d),\n-                         fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n+                       fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n         }\n         II::Foreign(i) => II::Foreign(fld.fold_foreign_item(i))\n     };\n@@ -1064,7 +1055,6 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 ItemTrait(..) => \"trait\",\n                 ItemImpl(..) => \"impl\",\n                 ItemDefaultImpl(..) => \"default impl\",\n-                ItemMac(..) => \"macro\"\n             };\n             format!(\"{} {}{}\", item_str, path_str, id_str)\n         }\n@@ -1091,10 +1081,6 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                             map.path_to_string(id),\n                             id_str)\n                 }\n-                MacImplItem(ref mac) => {\n-                    format!(\"method macro {}{}\",\n-                            pprust::mac_to_string(mac), id_str)\n-                }\n             }\n         }\n         Some(NodeTraitItem(ti)) => {", "previous_filename": "src/librustc/ast_map/mod.rs"}, {"sha": "f6a877bafce7227c64dc261729f8cb115aaba54d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -73,6 +73,7 @@ extern crate graphviz;\n extern crate libc;\n extern crate rustc_llvm;\n extern crate rustc_back;\n+extern crate rustc_front;\n extern crate rustc_data_structures;\n extern crate serialize;\n extern crate rbml;\n@@ -101,7 +102,9 @@ pub mod back {\n     pub use rustc_back::svh;\n }\n \n-pub mod ast_map;\n+pub mod front {\n+    pub mod map;\n+}\n \n pub mod middle {\n     pub mod astconv_util;"}, {"sha": "f8a06bab3dd336745c8f06d2deb405318de72e83", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -283,6 +283,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n \n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n /// attributes. Writing this as an iterator is an enormous mess.\n+// See also the hir version just below.\n pub fn gather_attrs(attrs: &[ast::Attribute])\n                     -> Vec<Result<(InternedString, Level, Span), Span>> {\n     let mut out = vec!();\n@@ -312,6 +313,40 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n     }\n     out\n }\n+// Copy-pasted from the above function :-(\n+pub fn gather_attrs_from_hir(attrs: &[::rustc_front::hir::Attribute])\n+                             -> Vec<Result<(InternedString, Level, Span), Span>> {\n+    use ::rustc_front::attr::AttrMetaMethods;\n+\n+    let mut out = vec!();\n+    for attr in attrs {\n+        let level = match Level::from_str(&attr.name()) {\n+            None => continue,\n+            Some(lvl) => lvl,\n+        };\n+\n+        ::rustc_front::attr::mark_used(attr);\n+\n+        let meta = &attr.node.value;\n+        let metas = match meta.node {\n+            ::rustc_front::hir::MetaList(_, ref metas) => metas,\n+            _ => {\n+                out.push(Err(meta.span));\n+                continue;\n+            }\n+        };\n+\n+        for meta in metas {\n+            out.push(match meta.node {\n+                ::rustc_front::hir::MetaWord(ref lint_name) => {\n+                    Ok((lint_name.clone(), level, meta.span))\n+                }\n+                _ => Err(meta.span),\n+            });\n+        }\n+    }\n+    out\n+}\n \n /// Emit a lint as a warning or an error (or not at all)\n /// according to `level`.\n@@ -696,9 +731,9 @@ impl LintPass for GatherNodeLevels {\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate(tcx: &ty::ctxt,\n+                   krate: &ast::Crate,\n                    exported_items: &ExportedItems) {\n \n-    let krate = tcx.map.krate();\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate."}, {"sha": "54b7aa81af3a69cfa0bc890a04aae8317665a28a", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -38,7 +38,7 @@ use syntax::visit::FnKind;\n use syntax::ast;\n \n pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs,\n-                        GatherNodeLevels};\n+                        gather_attrs_from_hir, GatherNodeLevels};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "d758b2534411fb67bad2a0ded09127702d421bc2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -21,6 +21,7 @@ use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n use util::nodemap::FnvHashMap;\n+use front::map as hir_map;\n \n use std::cell::{RefCell, Cell};\n use std::path::PathBuf;\n@@ -29,20 +30,22 @@ use std::fs;\n \n use syntax::ast;\n use syntax::abi;\n-use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, mk_sp, Pos};\n use syntax::parse;\n+use syntax::attr;\n use syntax::parse::token::InternedString;\n-use syntax::visit;\n use syntax::util::small_vector::SmallVector;\n-use ast_map;\n+use rustc_front::visit;\n+use rustc_front::hir;\n+use rustc_front::attr as attr_front;\n+use rustc_front::attr::AttrMetaMethods;\n+use rustc_front::lowering::unlower_attribute;\n use log;\n \n pub struct LocalCrateReader<'a, 'b:'a> {\n     sess: &'a Session,\n     creader: CrateReader<'a>,\n-    ast_map: &'a ast_map::Map<'b>,\n+    ast_map: &'a hir_map::Map<'b>,\n }\n \n pub struct CrateReader<'a> {\n@@ -52,7 +55,7 @@ pub struct CrateReader<'a> {\n }\n \n impl<'a, 'b, 'v> visit::Visitor<'v> for LocalCrateReader<'a, 'b> {\n-    fn visit_item(&mut self, a: &ast::Item) {\n+    fn visit_item(&mut self, a: &hir::Item) {\n         self.process_item(a);\n         visit::walk_item(self, a);\n     }\n@@ -77,6 +80,11 @@ fn should_link(i: &ast::Item) -> bool {\n     !attr::contains_name(&i.attrs, \"no_link\")\n }\n \n+// Dup for the hir\n+fn should_link_hir(i: &hir::Item) -> bool {\n+    !attr_front::contains_name(&i.attrs, \"no_link\")\n+}\n+\n struct CrateInfo {\n     ident: String,\n     name: String,\n@@ -188,6 +196,31 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n+    // Dup of the above, but for the hir\n+    fn extract_crate_info_hir(&self, i: &hir::Item) -> Option<CrateInfo> {\n+        match i.node {\n+            hir::ItemExternCrate(ref path_opt) => {\n+                debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n+                       i.ident, path_opt);\n+                let name = match *path_opt {\n+                    Some(name) => {\n+                        validate_crate_name(Some(self.sess), &name.as_str(),\n+                                            Some(i.span));\n+                        name.to_string()\n+                    }\n+                    None => i.ident.to_string(),\n+                };\n+                Some(CrateInfo {\n+                    ident: i.ident.to_string(),\n+                    name: name,\n+                    id: i.id,\n+                    should_link: should_link_hir(i),\n+                })\n+            }\n+            _ => None\n+        }\n+    }\n+\n     fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<ast::CrateNum> {\n         let mut ret = None;\n@@ -295,7 +328,7 @@ impl<'a> CrateReader<'a> {\n         let attrs = decoder::get_crate_attributes(data);\n         for attr in &attrs {\n             if &attr.name()[..] == \"staged_api\" {\n-                match attr.node.value.node { ast::MetaWord(_) => return true, _ => (/*pass*/) }\n+                match attr.node.value.node { hir::MetaWord(_) => return true, _ => (/*pass*/) }\n             }\n         }\n \n@@ -425,11 +458,11 @@ impl<'a> CrateReader<'a> {\n     }\n \n     /// Read exported macros.\n-    pub fn read_exported_macros(&mut self, krate: &ast::Item) -> Vec<ast::MacroDef> {\n-        let ci = self.extract_crate_info(krate).unwrap();\n-        let ekrate = self.read_extension_crate(krate.span, &ci);\n+    pub fn read_exported_macros(&mut self, item: &ast::Item) -> Vec<ast::MacroDef> {\n+        let ci = self.extract_crate_info(item).unwrap();\n+        let ekrate = self.read_extension_crate(item.span, &ci);\n \n-        let source_name = format!(\"<{} macros>\", krate.ident);\n+        let source_name = format!(\"<{} macros>\", item.ident);\n         let mut macros = vec![];\n         decoder::each_exported_macro(ekrate.metadata.as_slice(),\n                                      &*self.sess.cstore.intr,\n@@ -449,10 +482,10 @@ impl<'a> CrateReader<'a> {\n                 p.abort_if_errors();\n                 macros.push(ast::MacroDef {\n                     ident: name.ident(),\n-                    attrs: attrs,\n+                    attrs: attrs.iter().map(|a| unlower_attribute(a)).collect(),\n                     id: ast::DUMMY_NODE_ID,\n                     span: span,\n-                    imported_from: Some(krate.ident),\n+                    imported_from: Some(item.ident),\n                     // overridden in plugin/load.rs\n                     export: false,\n                     use_locally: false,\n@@ -639,7 +672,7 @@ impl<'a> CrateReader<'a> {\n }\n \n impl<'a, 'b> LocalCrateReader<'a, 'b> {\n-    pub fn new(sess: &'a Session, map: &'a ast_map::Map<'b>) -> LocalCrateReader<'a, 'b> {\n+    pub fn new(sess: &'a Session, map: &'a hir_map::Map<'b>) -> LocalCrateReader<'a, 'b> {\n         LocalCrateReader {\n             sess: sess,\n             creader: CrateReader::new(sess),\n@@ -650,7 +683,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n     // Traverses an AST, reading all the information about use'd crates and\n     // extern libraries necessary for later resolving, typechecking, linking,\n     // etc.\n-    pub fn read_crates(&mut self, krate: &ast::Crate) {\n+    pub fn read_crates(&mut self, krate: &hir::Crate) {\n         self.process_crate(krate);\n         visit::walk_crate(self, krate);\n         self.creader.inject_allocator_crate();\n@@ -665,7 +698,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         self.creader.register_statically_included_foreign_items();\n     }\n \n-    fn process_crate(&self, c: &ast::Crate) {\n+    fn process_crate(&self, c: &hir::Crate) {\n         for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n             match a.value_str() {\n                 Some(ref linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n@@ -674,14 +707,14 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         }\n     }\n \n-    fn process_item(&mut self, i: &ast::Item) {\n+    fn process_item(&mut self, i: &hir::Item) {\n         match i.node {\n-            ast::ItemExternCrate(_) => {\n-                if !should_link(i) {\n+            hir::ItemExternCrate(_) => {\n+                if !should_link_hir(i) {\n                     return;\n                 }\n \n-                match self.creader.extract_crate_info(i) {\n+                match self.creader.extract_crate_info_hir(i) {\n                     Some(info) => {\n                         let (cnum, cmeta, _) = self.creader.resolve_crate(&None,\n                                                               &info.ident,\n@@ -698,12 +731,12 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                     None => ()\n                 }\n             }\n-            ast::ItemForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n+            hir::ItemForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n             _ => { }\n         }\n     }\n \n-    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n+    fn process_foreign_mod(&mut self, i: &hir::Item, fm: &hir::ForeignMod) {\n         if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic || fm.abi == abi::PlatformIntrinsic {\n             return;\n         }"}, {"sha": "91c7ac4891857a40afcdf12f94f9c687c3aa8e4b", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -10,7 +10,7 @@\n \n // Searching for information from the cstore\n \n-use ast_map;\n+use front::map as ast_map;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n@@ -23,7 +23,8 @@ use rbml;\n use rbml::reader;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::attr;\n+use rustc_front::attr;\n+use rustc_front::hir;\n use syntax::diagnostic::expect;\n \n use std::collections::hash_map::HashMap;\n@@ -32,7 +33,7 @@ use std::collections::hash_map::HashMap;\n pub struct MethodInfo {\n     pub name: ast::Name,\n     pub def_id: DefId,\n-    pub vis: ast::Visibility,\n+    pub vis: hir::Visibility,\n }\n \n pub fn get_symbol(cstore: &cstore::CStore, def: DefId) -> String {\n@@ -55,7 +56,7 @@ pub fn each_lang_item<F>(cstore: &cstore::CStore,\n pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n                              def_id: DefId,\n                              callback: F) where\n-    F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n+    F: FnMut(decoder::DefLike, ast::Name, hir::Visibility),\n {\n     let crate_data = cstore.get_crate_data(def_id.krate);\n     let get_crate_data = |cnum| {\n@@ -72,7 +73,7 @@ pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n                                        cnum: ast::CrateNum,\n                                        callback: F) where\n-    F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n+    F: FnMut(decoder::DefLike, ast::Name, hir::Visibility),\n {\n     let crate_data = cstore.get_crate_data(cnum);\n     let get_crate_data = |cnum| {\n@@ -190,7 +191,7 @@ pub fn get_methods_if_impl(cstore: &cstore::CStore,\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: DefId)\n-                      -> Vec<ast::Attribute> {\n+                      -> Vec<hir::Attribute> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node)\n }\n@@ -201,7 +202,7 @@ pub fn get_struct_field_names(cstore: &cstore::CStore, def: DefId) -> Vec<ast::N\n }\n \n pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId) -> HashMap<ast::NodeId,\n-        Vec<ast::Attribute>> {\n+        Vec<hir::Attribute>> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_field_attrs(&*cdata)\n }\n@@ -269,7 +270,7 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: DefId,\n \n pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                def: DefId)\n-                               -> Option<ast::ImplPolarity>\n+                               -> Option<hir::ImplPolarity>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);"}, {"sha": "838f78163f0184df134490251426ede721d7ac90", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -27,12 +27,12 @@ use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n use syntax::ast;\n-use syntax::attr;\n+use rustc_front::attr;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::parse::token::IdentInterner;\n use syntax::util::small_vector::SmallVector;\n-use ast_map;\n+use front::map as ast_map;\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external"}, {"sha": "5991b79896b746a721632c03ce7d797d2970dfa7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -15,7 +15,10 @@\n pub use self::DefLike::*;\n use self::Family::*;\n \n-use ast_map;\n+use front::map as ast_map;\n+use rustc_front::print::pprust;\n+use rustc_front::hir;\n+\n use back::svh::Svh;\n use metadata::cstore::crate_metadata;\n use metadata::common::*;\n@@ -45,15 +48,15 @@ use std::str;\n use rbml::reader;\n use rbml;\n use serialize::Decodable;\n-use syntax::abi;\n-use syntax::attr;\n+use rustc_front::attr;\n use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n-use syntax::print::pprust;\n use syntax::ast;\n+use syntax::abi;\n use syntax::codemap;\n use syntax::ptr::P;\n \n+\n pub type Cmd<'a> = &'a crate_metadata;\n \n // A function that takes a def_id relative to the crate being searched and\n@@ -158,26 +161,26 @@ fn item_family(item: rbml::Doc) -> Family {\n     }\n }\n \n-fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n+fn item_visibility(item: rbml::Doc) -> hir::Visibility {\n     match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n-        None => ast::Public,\n+        None => hir::Public,\n         Some(visibility_doc) => {\n             match reader::doc_as_u8(visibility_doc) as char {\n-                'y' => ast::Public,\n-                'i' => ast::Inherited,\n+                'y' => hir::Public,\n+                'i' => hir::Inherited,\n                 _ => panic!(\"unknown visibility character\")\n             }\n         }\n     }\n }\n \n-fn fn_constness(item: rbml::Doc) -> ast::Constness {\n+fn fn_constness(item: rbml::Doc) -> hir::Constness {\n     match reader::maybe_get_doc(item, tag_items_data_item_constness) {\n-        None => ast::Constness::NotConst,\n+        None => hir::Constness::NotConst,\n         Some(constness_doc) => {\n             match reader::doc_as_u8(constness_doc) as char {\n-                'c' => ast::Constness::Const,\n-                'n' => ast::Constness::NotConst,\n+                'c' => hir::Constness::Const,\n+                'n' => hir::Constness::NotConst,\n                 _ => panic!(\"unknown constness character\")\n             }\n         }\n@@ -343,12 +346,12 @@ fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: DefId) -> DefLike {\n     }\n }\n \n-fn parse_unsafety(item_doc: rbml::Doc) -> ast::Unsafety {\n+fn parse_unsafety(item_doc: rbml::Doc) -> hir::Unsafety {\n     let unsafety_doc = reader::get_doc(item_doc, tag_unsafety);\n     if reader::doc_as_u8(unsafety_doc) != 0 {\n-        ast::Unsafety::Unsafe\n+        hir::Unsafety::Unsafe\n     } else {\n-        ast::Unsafety::Normal\n+        hir::Unsafety::Normal\n     }\n }\n \n@@ -357,12 +360,12 @@ fn parse_paren_sugar(item_doc: rbml::Doc) -> bool {\n     reader::doc_as_u8(paren_sugar_doc) != 0\n }\n \n-fn parse_polarity(item_doc: rbml::Doc) -> ast::ImplPolarity {\n+fn parse_polarity(item_doc: rbml::Doc) -> hir::ImplPolarity {\n     let polarity_doc = reader::get_doc(item_doc, tag_polarity);\n     if reader::doc_as_u8(polarity_doc) != 0 {\n-        ast::ImplPolarity::Negative\n+        hir::ImplPolarity::Negative\n     } else {\n-        ast::ImplPolarity::Positive\n+        hir::ImplPolarity::Positive\n     }\n }\n \n@@ -560,7 +563,7 @@ pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n \n pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n                                id: ast::NodeId)\n-                               -> Option<ast::ImplPolarity>\n+                               -> Option<hir::ImplPolarity>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let fam = item_family(item_doc);\n@@ -633,7 +636,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                                      item_doc: rbml::Doc,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n-    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+    F: FnMut(DefLike, ast::Name, hir::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Iterate over all children.\n@@ -722,7 +725,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n             // a public re-export.\n-            callback(def_like, token::intern(name), ast::Public);\n+            callback(def_like, token::intern(name), hir::Public);\n         }\n     }\n }\n@@ -733,7 +736,7 @@ pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                id: ast::NodeId,\n                                get_crate_data: G,\n                                callback: F) where\n-    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+    F: FnMut(DefLike, ast::Name, hir::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Find the item.\n@@ -756,7 +759,7 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                           cdata: Cmd,\n                                           get_crate_data: G,\n                                           callback: F) where\n-    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+    F: FnMut(DefLike, ast::Name, hir::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n@@ -810,10 +813,10 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n }\n \n fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n-    fn get_mutability(ch: u8) -> ast::Mutability {\n+    fn get_mutability(ch: u8) -> hir::Mutability {\n         match ch as char {\n-            'i' => ast::MutImmutable,\n-            'm' => ast::MutMutable,\n+            'i' => hir::MutImmutable,\n+            'm' => hir::MutMutable,\n             _ => panic!(\"unknown mutability character: `{}`\", ch as char),\n         }\n     }\n@@ -1074,7 +1077,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n \n pub fn get_item_attrs(cdata: Cmd,\n                       orig_node_id: ast::NodeId)\n-                      -> Vec<ast::Attribute> {\n+                      -> Vec<hir::Attribute> {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n@@ -1084,7 +1087,7 @@ pub fn get_item_attrs(cdata: Cmd,\n     get_attributes(item)\n }\n \n-pub fn get_struct_field_attrs(cdata: Cmd) -> HashMap<ast::NodeId, Vec<ast::Attribute>> {\n+pub fn get_struct_field_attrs(cdata: Cmd) -> HashMap<ast::NodeId, Vec<hir::Attribute>> {\n     let data = rbml::Doc::new(cdata.data());\n     let fields = reader::get_doc(data, tag_struct_fields);\n     reader::tagged_docs(fields, tag_struct_field).map(|field| {\n@@ -1094,10 +1097,10 @@ pub fn get_struct_field_attrs(cdata: Cmd) -> HashMap<ast::NodeId, Vec<ast::Attri\n     }).collect()\n }\n \n-fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n+fn struct_field_family_to_visibility(family: Family) -> hir::Visibility {\n     match family {\n-      PublicField => ast::Public,\n-      InheritedField => ast::Inherited,\n+      PublicField => hir::Public,\n+      InheritedField => hir::Inherited,\n       _ => panic!()\n     }\n }\n@@ -1113,7 +1116,7 @@ pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId)\n     })).collect()\n }\n \n-fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n+fn get_meta_items(md: rbml::Doc) -> Vec<P<hir::MetaItem>> {\n     reader::tagged_docs(md, tag_meta_item_word).map(|meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n@@ -1134,7 +1137,7 @@ fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n     })).collect()\n }\n \n-fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n+fn get_attributes(md: rbml::Doc) -> Vec<hir::Attribute> {\n     match reader::maybe_get_doc(md, tag_attributes) {\n         Some(attrs_d) => {\n             reader::tagged_docs(attrs_d, tag_attribute).map(|attr_doc| {\n@@ -1147,9 +1150,9 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n                 assert_eq!(meta_items.len(), 1);\n                 let meta_item = meta_items.into_iter().nth(0).unwrap();\n                 codemap::Spanned {\n-                    node: ast::Attribute_ {\n+                    node: hir::Attribute_ {\n                         id: attr::mk_attr_id(),\n-                        style: ast::AttrOuter,\n+                        style: hir::AttrOuter,\n                         value: meta_item,\n                         is_sugared_doc: is_sugared_doc,\n                     },\n@@ -1173,7 +1176,7 @@ fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n     write!(out, \"\\n\\n\")\n }\n \n-pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n+pub fn get_crate_attributes(data: &[u8]) -> Vec<hir::Attribute> {\n     get_attributes(rbml::Doc::new(data))\n }\n \n@@ -1371,7 +1374,7 @@ pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n }\n \n pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n-    F: FnMut(ast::Name, Vec<ast::Attribute>, String) -> bool,\n+    F: FnMut(ast::Name, Vec<hir::Attribute>, String) -> bool,\n {\n     let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n     for macro_doc in reader::tagged_docs(macros, tag_macro_def) {\n@@ -1453,8 +1456,8 @@ pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n pub fn is_const_fn(cdata: Cmd, id: ast::NodeId) -> bool {\n     let item_doc = lookup_item(id, cdata.data());\n     match fn_constness(item_doc) {\n-        ast::Constness::Const => true,\n-        ast::Constness::NotConst => false,\n+        hir::Constness::Const => true,\n+        hir::Constness::NotConst => false,\n     }\n }\n "}, {"sha": "8085c643f1935094d0e4f00b045fb966fee0e019", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -13,7 +13,6 @@\n #![allow(unused_must_use)] // everything is just a MemWriter, can't fail\n #![allow(non_camel_case_types)]\n \n-use ast_map::{self, LinkedPath, PathElem, PathElems};\n use back::svh::Svh;\n use session::config;\n use metadata::common::*;\n@@ -35,17 +34,20 @@ use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ast::{self, NodeId};\n-use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::ast::{NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n-use syntax::print::pprust;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n use syntax;\n use rbml::writer::Encoder;\n \n+use rustc_front::hir as ast;\n+use rustc_front::visit::Visitor;\n+use rustc_front::visit;\n+use rustc_front::attr;\n+use rustc_front::attr::AttrMetaMethods;\n+use front::map::{LinkedPath, PathElem, PathElems};\n+use front::map as ast_map;\n+\n pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n \n@@ -72,11 +74,11 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub reachable: &'a NodeSet,\n }\n \n-fn encode_name(rbml_w: &mut Encoder, name: ast::Name) {\n+fn encode_name(rbml_w: &mut Encoder, name: Name) {\n     rbml_w.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }\n \n-fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Name) {\n+fn encode_impl_type_basename(rbml_w: &mut Encoder, name: Name) {\n     rbml_w.wr_tagged_str(tag_item_impl_type_basename, &name.as_str());\n }\n \n@@ -130,7 +132,7 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              ecx: &EncodeContext<'a, 'tcx>,\n-                                             id: ast::NodeId) {\n+                                             id: NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n                            &ecx.tcx.lookup_item_type(DefId::local(id)),\n@@ -343,7 +345,7 @@ fn encode_path<PI: Iterator<Item=PathElem>>(rbml_w: &mut Encoder, path: PI) {\n fn encode_reexported_static_method(rbml_w: &mut Encoder,\n                                    exp: &def::Export,\n                                    method_def_id: DefId,\n-                                   method_name: ast::Name) {\n+                                   method_name: Name) {\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, method_name);\n     rbml_w.start_tag(tag_items_data_item_reexport);\n@@ -500,7 +502,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        attrs: &[ast::Attribute],\n                        id: NodeId,\n                        path: PathElems,\n-                       name: ast::Name,\n+                       name: Name,\n                        vis: ast::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, DefId::local(id));\n@@ -655,7 +657,7 @@ fn encode_info_for_struct<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                rbml_w: &mut Encoder,\n-                               name: ast::Name,\n+                               name: Name,\n                                ctor_id: NodeId,\n                                index: &mut Vec<entry<i64>>,\n                                struct_id: NodeId) {\n@@ -1475,7 +1477,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n         }\n       }\n-      ast::ItemExternCrate(_) | ast::ItemUse(_) |ast::ItemMac(..) => {\n+      ast::ItemExternCrate(_) | ast::ItemUse(_) => {\n         // these are encoded separately\n       }\n     }\n@@ -1588,14 +1590,14 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     let mut index = Vec::new();\n     rbml_w.start_tag(tag_items_data);\n     index.push(entry {\n-        val: ast::CRATE_NODE_ID as i64,\n+        val: CRATE_NODE_ID as i64,\n         pos: rbml_w.mark_stable_position(),\n     });\n     encode_info_for_mod(ecx,\n                         rbml_w,\n                         &krate.module,\n                         &[],\n-                        ast::CRATE_NODE_ID,\n+                        CRATE_NODE_ID,\n                         [].iter().cloned().chain(LinkedPath::empty()),\n                         syntax::parse::token::special_idents::invalid.name,\n                         ast::Public);\n@@ -1727,7 +1729,7 @@ fn encode_defaulted(rbml_w: &mut Encoder, is_defaulted: bool) {\n     rbml_w.wr_tagged_u8(tag_defaulted_trait, byte);\n }\n \n-fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n+fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[Name]) {\n     rbml_w.start_tag(tag_associated_type_names);\n     for &name in names {\n         rbml_w.wr_tagged_str(tag_associated_type_name, &name.as_str());\n@@ -1745,7 +1747,7 @@ fn encode_polarity(rbml_w: &mut Encoder, polarity: ast::ImplPolarity) {\n \n fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore)\n-                        -> Vec<(ast::CrateNum, Rc<cstore::crate_metadata>)> {\n+                        -> Vec<(CrateNum, Rc<cstore::crate_metadata>)> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n         cstore.iter_crate_data(|cnum, val| {\n@@ -1856,7 +1858,7 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         encode_attributes(rbml_w, &def.attrs);\n \n         rbml_w.wr_tagged_str(tag_macro_def_body,\n-                             &pprust::tts_to_string(&def.body));\n+                             &::syntax::print::pprust::tts_to_string(&def.body));\n \n         rbml_w.end_tag();\n     }"}, {"sha": "a5ca68e4350ebb7193f48325ad45ff57f8e7b0f5", "filename": "src/librustc/metadata/inline.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Finline.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -9,30 +9,30 @@\n // except according to those terms.\n \n use middle::def_id::DefId;\n-use syntax::ast;\n-use syntax::ast_util::{IdRange, IdRangeComputingVisitor,\n-                       IdVisitor, IdVisitingOperation};\n+use rustc_front::hir;\n+use rustc_front::util::IdVisitor;\n+use syntax::ast_util::{IdRange, IdRangeComputingVisitor, IdVisitingOperation};\n use syntax::ptr::P;\n-use syntax::visit::Visitor;\n+use rustc_front::visit::Visitor;\n use self::InlinedItem::*;\n \n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum InlinedItem {\n-    Item(P<ast::Item>),\n-    TraitItem(DefId /* impl id */, P<ast::TraitItem>),\n-    ImplItem(DefId /* impl id */, P<ast::ImplItem>),\n-    Foreign(P<ast::ForeignItem>),\n+    Item(P<hir::Item>),\n+    TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n+    ImplItem(DefId /* impl id */, P<hir::ImplItem>),\n+    Foreign(P<hir::ForeignItem>),\n }\n \n-/// A borrowed version of `ast::InlinedItem`.\n+/// A borrowed version of `hir::InlinedItem`.\n pub enum InlinedItemRef<'a> {\n-    Item(&'a ast::Item),\n-    TraitItem(DefId, &'a ast::TraitItem),\n-    ImplItem(DefId, &'a ast::ImplItem),\n-    Foreign(&'a ast::ForeignItem)\n+    Item(&'a hir::Item),\n+    TraitItem(DefId, &'a hir::TraitItem),\n+    ImplItem(DefId, &'a hir::ImplItem),\n+    Foreign(&'a hir::ForeignItem)\n }\n \n impl InlinedItem {\n@@ -62,4 +62,3 @@ impl InlinedItem {\n         visitor.result()\n     }\n }\n-"}, {"sha": "527f5919e2ddcd48fbe6058759e6979c0bf427a2", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -14,13 +14,14 @@ use session::Session;\n use metadata::creader::CrateReader;\n \n use std::collections::{HashSet, HashMap};\n-use syntax::ast;\n-use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::ast;\n+use syntax::attr;\n use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::attr::AttrMetaMethods;\n+use rustc_front::attr::AttrMetaMethods as FrontAttrMetaMethods;\n \n struct MacroLoader<'a> {\n     sess: &'a Session,"}, {"sha": "643cf132de25eb2fbae4c6aeeb50bfc79187023c", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -18,6 +18,8 @@\n \n pub use self::DefIdSource::*;\n \n+use rustc_front::hir;\n+\n use middle::def_id::DefId;\n use middle::region;\n use middle::subst;\n@@ -467,10 +469,10 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    fn parse_mutability(&mut self) -> ast::Mutability {\n+    fn parse_mutability(&mut self) -> hir::Mutability {\n         match self.peek() {\n-            'm' => { self.next(); ast::MutMutable }\n-            _ => { ast::MutImmutable }\n+            'm' => { self.next(); hir::MutMutable }\n+            _ => { hir::MutImmutable }\n         }\n     }\n \n@@ -742,10 +744,10 @@ fn parse_defid(buf: &[u8]) -> DefId {\n     DefId { krate: crate_num, node: def_num }\n }\n \n-fn parse_unsafety(c: char) -> ast::Unsafety {\n+fn parse_unsafety(c: char) -> hir::Unsafety {\n     match c {\n-        'u' => ast::Unsafety::Unsafe,\n-        'n' => ast::Unsafety::Normal,\n+        'u' => hir::Unsafety::Unsafe,\n+        'n' => hir::Unsafety::Normal,\n         _ => panic!(\"parse_unsafety: bad unsafety {}\", c)\n     }\n }"}, {"sha": "d7554c4cf750186b1aa619f037d1252f58ad328c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -24,8 +24,9 @@ use middle::ty::ParamTy;\n use middle::ty::{self, Ty};\n use util::nodemap::FnvHashMap;\n \n+use rustc_front::hir;\n+\n use syntax::abi::Abi;\n-use syntax::ast;\n use syntax::diagnostic::SpanHandler;\n \n use rbml::writer::Encoder;\n@@ -64,26 +65,26 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         ty::TyChar => mywrite!(w, \"c\"),\n         ty::TyInt(t) => {\n             match t {\n-                ast::TyIs => mywrite!(w, \"is\"),\n-                ast::TyI8 => mywrite!(w, \"MB\"),\n-                ast::TyI16 => mywrite!(w, \"MW\"),\n-                ast::TyI32 => mywrite!(w, \"ML\"),\n-                ast::TyI64 => mywrite!(w, \"MD\")\n+                hir::TyIs => mywrite!(w, \"is\"),\n+                hir::TyI8 => mywrite!(w, \"MB\"),\n+                hir::TyI16 => mywrite!(w, \"MW\"),\n+                hir::TyI32 => mywrite!(w, \"ML\"),\n+                hir::TyI64 => mywrite!(w, \"MD\")\n             }\n         }\n         ty::TyUint(t) => {\n             match t {\n-                ast::TyUs => mywrite!(w, \"us\"),\n-                ast::TyU8 => mywrite!(w, \"Mb\"),\n-                ast::TyU16 => mywrite!(w, \"Mw\"),\n-                ast::TyU32 => mywrite!(w, \"Ml\"),\n-                ast::TyU64 => mywrite!(w, \"Md\")\n+                hir::TyUs => mywrite!(w, \"us\"),\n+                hir::TyU8 => mywrite!(w, \"Mb\"),\n+                hir::TyU16 => mywrite!(w, \"Mw\"),\n+                hir::TyU32 => mywrite!(w, \"Ml\"),\n+                hir::TyU64 => mywrite!(w, \"Md\")\n             }\n         }\n         ty::TyFloat(t) => {\n             match t {\n-                ast::TyF32 => mywrite!(w, \"Mf\"),\n-                ast::TyF64 => mywrite!(w, \"MF\"),\n+                hir::TyF32 => mywrite!(w, \"Mf\"),\n+                hir::TyF64 => mywrite!(w, \"MF\"),\n             }\n         }\n         ty::TyEnum(def, substs) => {\n@@ -179,10 +180,10 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     }\n }\n \n-fn enc_mutability(w: &mut Encoder, mt: ast::Mutability) {\n+fn enc_mutability(w: &mut Encoder, mt: hir::Mutability) {\n     match mt {\n-        ast::MutImmutable => (),\n-        ast::MutMutable => mywrite!(w, \"m\"),\n+        hir::MutImmutable => (),\n+        hir::MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n@@ -314,10 +315,10 @@ pub fn enc_trait_ref<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n     enc_substs(w, cx, s.substs);\n }\n \n-fn enc_unsafety(w: &mut Encoder, p: ast::Unsafety) {\n+fn enc_unsafety(w: &mut Encoder, p: hir::Unsafety) {\n     match p {\n-        ast::Unsafety::Normal => mywrite!(w, \"n\"),\n-        ast::Unsafety::Unsafe => mywrite!(w, \"u\"),\n+        hir::Unsafety::Normal => mywrite!(w, \"n\"),\n+        hir::Unsafety::Unsafe => mywrite!(w, \"u\"),\n     }\n }\n "}, {"sha": "1700efe23e98e09e1b798daa119857a1a4a4a699", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -16,7 +16,7 @@\n \n use middle::def;\n use middle::ty::{self, Ty};\n-use syntax::ast;\n+use rustc_front::hir as ast;\n \n pub const NO_REGIONS: usize = 1;\n pub const NO_TPS: usize = 2;"}, {"sha": "4d921c007c68f6d3ee66ee92b11fff8165cd8dae", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -12,7 +12,11 @@\n // FIXME: remove this after snapshot, and Results are handled\n #![allow(unused_must_use)]\n \n-use ast_map;\n+use front::map as ast_map;\n+use rustc_front::hir;\n+use rustc_front::fold;\n+use rustc_front::fold::Folder;\n+\n use metadata::common as c;\n use metadata::cstore as cstore;\n use session::Session;\n@@ -33,11 +37,9 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n \n-use syntax::{ast, ast_util, codemap, fold};\n+use syntax::{ast, ast_util, codemap};\n use syntax::codemap::Span;\n-use syntax::fold::Folder;\n use syntax::ptr::P;\n-use syntax;\n \n use std::cell::Cell;\n use std::io::SeekFrom;\n@@ -53,7 +55,8 @@ use serialize::EncoderHelpers;\n \n #[cfg(test)] use std::io::Cursor;\n #[cfg(test)] use syntax::parse;\n-#[cfg(test)] use syntax::print::pprust;\n+#[cfg(test)] use rustc_front::print::pprust;\n+#[cfg(test)] use rustc_front::lowering::lower_item;\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -166,7 +169,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         match *ii {\n           InlinedItem::Item(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_string(&**i));\n+                   ::rustc_front::print::pprust::item_to_string(&**i));\n           }\n           _ => { }\n         }\n@@ -360,26 +363,25 @@ fn encode_ast(rbml_w: &mut Encoder, item: &InlinedItem) {\n struct NestedItemsDropper;\n \n impl Folder for NestedItemsDropper {\n-    fn fold_block(&mut self, blk: P<ast::Block>) -> P<ast::Block> {\n-        blk.and_then(|ast::Block {id, stmts, expr, rules, span, ..}| {\n+    fn fold_block(&mut self, blk: P<hir::Block>) -> P<hir::Block> {\n+        blk.and_then(|hir::Block {id, stmts, expr, rules, span, ..}| {\n             let stmts_sans_items = stmts.into_iter().filter_map(|stmt| {\n                 let use_stmt = match stmt.node {\n-                    ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => true,\n-                    ast::StmtDecl(ref decl, _) => {\n+                    hir::StmtExpr(_, _) | hir::StmtSemi(_, _) => true,\n+                    hir::StmtDecl(ref decl, _) => {\n                         match decl.node {\n-                            ast::DeclLocal(_) => true,\n-                            ast::DeclItem(_) => false,\n+                            hir::DeclLocal(_) => true,\n+                            hir::DeclItem(_) => false,\n                         }\n                     }\n-                    ast::StmtMac(..) => panic!(\"unexpanded macro in astencode\")\n                 };\n                 if use_stmt {\n                     Some(stmt)\n                 } else {\n                     None\n                 }\n             }).collect();\n-            let blk_sans_items = P(ast::Block {\n+            let blk_sans_items = P(hir::Block {\n                 stmts: stmts_sans_items,\n                 expr: expr,\n                 id: id,\n@@ -488,7 +490,7 @@ fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &ty::Freevar) {\n trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n                           -> ty::Freevar;\n-    fn read_capture_mode(&mut self) -> ast::CaptureClause;\n+    fn read_capture_mode(&mut self) -> hir::CaptureClause;\n }\n \n impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n@@ -498,8 +500,8 @@ impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n         fv.tr(dcx)\n     }\n \n-    fn read_capture_mode(&mut self) -> ast::CaptureClause {\n-        let cm: ast::CaptureClause = Decodable::decode(self).unwrap();\n+    fn read_capture_mode(&mut self) -> hir::CaptureClause {\n+        let cm: hir::CaptureClause = Decodable::decode(self).unwrap();\n         cm\n     }\n }\n@@ -1304,15 +1306,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                             this.read_enum_variant_arg(0, |this| {\n                                 Ok(this.read_region(dcx))\n                             }).unwrap();\n-                        let m: ast::Mutability =\n+                        let m: hir::Mutability =\n                             this.read_enum_variant_arg(1, |this| {\n                                 Decodable::decode(this)\n                             }).unwrap();\n \n                         ty::AutoPtr(dcx.tcx.mk_region(r), m)\n                     }\n                     1 => {\n-                        let m: ast::Mutability =\n+                        let m: hir::Mutability =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n                         ty::AutoUnsafe(m)\n@@ -1506,14 +1508,14 @@ fn decode_side_tables(dcx: &DecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(rbml_w: &mut Encoder, item: &ast::Item) {\n+fn encode_item_ast(rbml_w: &mut Encoder, item: &hir::Item) {\n     rbml_w.start_tag(c::tag_tree as usize);\n     (*item).encode(rbml_w);\n     rbml_w.end_tag();\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: rbml::Doc) -> ast::Item {\n+fn decode_item_ast(par_doc: rbml::Doc) -> hir::Item {\n     let chi_doc = par_doc.get(c::tag_tree as usize);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n@@ -1553,8 +1555,7 @@ fn mk_ctxt() -> parse::ParseSess {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: Option<P<ast::Item>>) {\n-    let in_item = in_item.unwrap();\n+fn roundtrip(in_item: P<hir::Item>) {\n     let mut wr = Cursor::new(Vec::new());\n     encode_item_ast(&mut Encoder::new(&mut wr), &*in_item);\n     let rbml_doc = rbml::Doc::new(wr.get_ref());\n@@ -1566,28 +1567,28 @@ fn roundtrip(in_item: Option<P<ast::Item>>) {\n #[test]\n fn test_basic() {\n     let cx = mk_ctxt();\n-    roundtrip(quote_item!(&cx,\n+    roundtrip(lower_item(&quote_item!(&cx,\n         fn foo() {}\n-    ));\n+    ).unwrap()));\n }\n \n #[test]\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n-    roundtrip(quote_item!(&cx,\n+    roundtrip(lower_item(&quote_item!(&cx,\n         fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n-    ));\n+    ).unwrap()));\n }\n \n #[test]\n fn test_more() {\n     let cx = mk_ctxt();\n-    roundtrip(quote_item!(&cx,\n+    roundtrip(lower_item(&quote_item!(&cx,\n         fn foo(x: usize, y: usize) -> usize {\n             let z = x + y;\n             return z;\n         }\n-    ));\n+    ).unwrap()));\n }\n \n #[test]\n@@ -1599,13 +1600,14 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n-    let item_in = InlinedItemRef::Item(&*item);\n+    let hir_item = lower_item(&item);\n+    let item_in = InlinedItemRef::Item(&hir_item);\n     let item_out = simplify_ast(item_in);\n-    let item_exp = InlinedItem::Item(quote_item!(&cx,\n+    let item_exp = InlinedItem::Item(lower_item(&quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<isize, B> {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n-    ).unwrap());\n+    ).unwrap()));\n     match (item_out, item_exp) {\n       (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n         assert!(pprust::item_to_string(&*item_out) =="}, {"sha": "8cb4f941a2264eb8fc84a2e98c2022f6a6c76f97", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -13,7 +13,7 @@\n \n use middle::ty::{self, Ty};\n \n-use syntax::ast;\n+use rustc_front::hir as ast;\n \n /// Types that are represented as ints.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "4d79867e5d2648ca5f1ce42079b7e78881059246", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 76, "deletions": 96, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -14,9 +14,10 @@ use middle::def;\n use middle::pat_util;\n use middle::ty;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::ptr::P;\n \n+use rustc_front::hir;\n+\n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     graph: CFGGraph,\n@@ -32,7 +33,7 @@ struct LoopScope {\n }\n \n pub fn construct(tcx: &ty::ctxt,\n-                 blk: &ast::Block) -> CFG {\n+                 blk: &hir::Block) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n \n@@ -58,7 +59,7 @@ pub fn construct(tcx: &ty::ctxt,\n }\n \n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n-    fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n+    fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n         for stmt in &blk.stmts {\n             stmts_exit = self.stmt(&**stmt, stmts_exit);\n@@ -69,95 +70,87 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.add_ast_node(blk.id, &[expr_exit])\n     }\n \n-    fn stmt(&mut self, stmt: &ast::Stmt, pred: CFGIndex) -> CFGIndex {\n+    fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n-            ast::StmtDecl(ref decl, id) => {\n+            hir::StmtDecl(ref decl, id) => {\n                 let exit = self.decl(&**decl, pred);\n                 self.add_ast_node(id, &[exit])\n             }\n \n-            ast::StmtExpr(ref expr, id) | ast::StmtSemi(ref expr, id) => {\n+            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) => {\n                 let exit = self.expr(&**expr, pred);\n                 self.add_ast_node(id, &[exit])\n             }\n-\n-            ast::StmtMac(..) => {\n-                self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n-            }\n         }\n     }\n \n-    fn decl(&mut self, decl: &ast::Decl, pred: CFGIndex) -> CFGIndex {\n+    fn decl(&mut self, decl: &hir::Decl, pred: CFGIndex) -> CFGIndex {\n         match decl.node {\n-            ast::DeclLocal(ref local) => {\n+            hir::DeclLocal(ref local) => {\n                 let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&*local.pat, init_exit)\n             }\n \n-            ast::DeclItem(_) => {\n+            hir::DeclItem(_) => {\n                 pred\n             }\n         }\n     }\n \n-    fn pat(&mut self, pat: &ast::Pat, pred: CFGIndex) -> CFGIndex {\n+    fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n-            ast::PatIdent(_, _, None) |\n-            ast::PatEnum(_, None) |\n-            ast::PatQPath(..) |\n-            ast::PatLit(..) |\n-            ast::PatRange(..) |\n-            ast::PatWild(_) => {\n+            hir::PatIdent(_, _, None) |\n+            hir::PatEnum(_, None) |\n+            hir::PatQPath(..) |\n+            hir::PatLit(..) |\n+            hir::PatRange(..) |\n+            hir::PatWild(_) => {\n                 self.add_ast_node(pat.id, &[pred])\n             }\n \n-            ast::PatBox(ref subpat) |\n-            ast::PatRegion(ref subpat, _) |\n-            ast::PatIdent(_, _, Some(ref subpat)) => {\n+            hir::PatBox(ref subpat) |\n+            hir::PatRegion(ref subpat, _) |\n+            hir::PatIdent(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&**subpat, pred);\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n-            ast::PatEnum(_, Some(ref subpats)) |\n-            ast::PatTup(ref subpats) => {\n+            hir::PatEnum(_, Some(ref subpats)) |\n+            hir::PatTup(ref subpats) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n-            ast::PatStruct(_, ref subpats, _) => {\n+            hir::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n-            ast::PatVec(ref pre, ref vec, ref post) => {\n+            hir::PatVec(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n                 self.add_ast_node(pat.id, &[post_exit])\n             }\n-\n-            ast::PatMac(_) => {\n-                self.tcx.sess.span_bug(pat.span, \"unexpanded macro\");\n-            }\n         }\n     }\n \n-    fn pats_all<'b, I: Iterator<Item=&'b P<ast::Pat>>>(&mut self,\n+    fn pats_all<'b, I: Iterator<Item=&'b P<hir::Pat>>>(&mut self,\n                                           pats: I,\n                                           pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n         pats.fold(pred, |pred, pat| self.pat(&**pat, pred))\n     }\n \n-    fn expr(&mut self, expr: &ast::Expr, pred: CFGIndex) -> CFGIndex {\n+    fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n-            ast::ExprBlock(ref blk) => {\n+            hir::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&**blk, pred);\n                 self.add_ast_node(expr.id, &[blk_exit])\n             }\n \n-            ast::ExprIf(ref cond, ref then, None) => {\n+            hir::ExprIf(ref cond, ref then, None) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -177,7 +170,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n             }\n \n-            ast::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n+            hir::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -198,11 +191,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n             }\n \n-            ast::ExprIfLet(..) => {\n-                self.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n-            }\n-\n-            ast::ExprWhile(ref cond, ref body, _) => {\n+            hir::ExprWhile(ref cond, ref body, _) => {\n                 //\n                 //         [pred]\n                 //           |\n@@ -235,15 +224,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            ast::ExprWhileLet(..) => {\n-                self.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n-            }\n-\n-            ast::ExprForLoop(..) => {\n-                self.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n-            }\n-\n-            ast::ExprLoop(ref body, _) => {\n+            hir::ExprLoop(ref body, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -271,11 +252,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            ast::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprMatch(ref discr, ref arms, _) => {\n                 self.match_(expr.id, &discr, &arms, pred)\n             }\n \n-            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n+            hir::ExprBinary(op, ref l, ref r) if ::rustc_front::util::lazy_binop(op.node) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -295,91 +276,91 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n             }\n \n-            ast::ExprRet(ref v) => {\n+            hir::ExprRet(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n                 let b = self.add_ast_node(expr.id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_unreachable_node()\n             }\n \n-            ast::ExprBreak(label) => {\n+            hir::ExprBreak(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n                 let b = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n             }\n \n-            ast::ExprAgain(label) => {\n+            hir::ExprAgain(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n                 let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n                 self.add_unreachable_node()\n             }\n \n-            ast::ExprVec(ref elems) => {\n+            hir::ExprVec(ref elems) => {\n                 self.straightline(expr, pred, elems.iter().map(|e| &**e))\n             }\n \n-            ast::ExprCall(ref func, ref args) => {\n+            hir::ExprCall(ref func, ref args) => {\n                 self.call(expr, pred, &**func, args.iter().map(|e| &**e))\n             }\n \n-            ast::ExprMethodCall(_, _, ref args) => {\n+            hir::ExprMethodCall(_, _, ref args) => {\n                 self.call(expr, pred, &*args[0], args[1..].iter().map(|e| &**e))\n             }\n \n-            ast::ExprIndex(ref l, ref r) |\n-            ast::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n+            hir::ExprIndex(ref l, ref r) |\n+            hir::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n                 self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n-            ast::ExprRange(ref start, ref end) => {\n+            hir::ExprRange(ref start, ref end) => {\n                 let fields = start.as_ref().map(|e| &**e).into_iter()\n                     .chain(end.as_ref().map(|e| &**e));\n                 self.straightline(expr, pred, fields)\n             }\n \n-            ast::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n-                self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n+            hir::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n+                self.call(expr, pred, &**e, None::<hir::Expr>.iter())\n             }\n \n-            ast::ExprTup(ref exprs) => {\n+            hir::ExprTup(ref exprs) => {\n                 self.straightline(expr, pred, exprs.iter().map(|e| &**e))\n             }\n \n-            ast::ExprStruct(_, ref fields, ref base) => {\n+            hir::ExprStruct(_, ref fields, ref base) => {\n                 let field_cfg = self.straightline(expr, pred, fields.iter().map(|f| &*f.expr));\n                 self.opt_expr(base, field_cfg)\n             }\n \n-            ast::ExprRepeat(ref elem, ref count) => {\n+            hir::ExprRepeat(ref elem, ref count) => {\n                 self.straightline(expr, pred, [elem, count].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprAssign(ref l, ref r) |\n-            ast::ExprAssignOp(_, ref l, ref r) => {\n+            hir::ExprAssign(ref l, ref r) |\n+            hir::ExprAssignOp(_, ref l, ref r) => {\n                 self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprBox(Some(ref l), ref r) |\n-            ast::ExprIndex(ref l, ref r) |\n-            ast::ExprBinary(_, ref l, ref r) => { // NB: && and || handled earlier\n+            hir::ExprBox(Some(ref l), ref r) |\n+            hir::ExprIndex(ref l, ref r) |\n+            hir::ExprBinary(_, ref l, ref r) => { // NB: && and || handled earlier\n                 self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprBox(None, ref e) |\n-            ast::ExprAddrOf(_, ref e) |\n-            ast::ExprCast(ref e, _) |\n-            ast::ExprUnary(_, ref e) |\n-            ast::ExprParen(ref e) |\n-            ast::ExprField(ref e, _) |\n-            ast::ExprTupField(ref e, _) => {\n+            hir::ExprBox(None, ref e) |\n+            hir::ExprAddrOf(_, ref e) |\n+            hir::ExprCast(ref e, _) |\n+            hir::ExprUnary(_, ref e) |\n+            hir::ExprParen(ref e) |\n+            hir::ExprField(ref e, _) |\n+            hir::ExprTupField(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n \n-            ast::ExprInlineAsm(ref inline_asm) => {\n+            hir::ExprInlineAsm(ref inline_asm) => {\n                 let inputs = inline_asm.inputs.iter();\n                 let outputs = inline_asm.outputs.iter();\n                 let post_inputs = self.exprs(inputs.map(|a| {\n@@ -395,19 +376,18 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.id, &[post_outputs])\n             }\n \n-            ast::ExprMac(..) |\n-            ast::ExprClosure(..) |\n-            ast::ExprLit(..) |\n-            ast::ExprPath(..) => {\n-                self.straightline(expr, pred, None::<ast::Expr>.iter())\n+            hir::ExprClosure(..) |\n+            hir::ExprLit(..) |\n+            hir::ExprPath(..) => {\n+                self.straightline(expr, pred, None::<hir::Expr>.iter())\n             }\n         }\n     }\n \n-    fn call<'b, I: Iterator<Item=&'b ast::Expr>>(&mut self,\n-            call_expr: &ast::Expr,\n+    fn call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n+            call_expr: &hir::Expr,\n             pred: CFGIndex,\n-            func_or_rcvr: &ast::Expr,\n+            func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n         let fn_ty = match self.tcx.tables.borrow().method_map.get(&method_call) {\n@@ -424,22 +404,22 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn exprs<'b, I: Iterator<Item=&'b ast::Expr>>(&mut self,\n+    fn exprs<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n                                              exprs: I,\n                                              pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n         exprs.fold(pred, |p, e| self.expr(e, p))\n     }\n \n     fn opt_expr(&mut self,\n-                opt_expr: &Option<P<ast::Expr>>,\n+                opt_expr: &Option<P<hir::Expr>>,\n                 pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `opt_expr` evaluated, if Some\n         opt_expr.iter().fold(pred, |p, e| self.expr(&**e, p))\n     }\n \n-    fn straightline<'b, I: Iterator<Item=&'b ast::Expr>>(&mut self,\n-                    expr: &ast::Expr,\n+    fn straightline<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n+                    expr: &hir::Expr,\n                     pred: CFGIndex,\n                     subexprs: I) -> CFGIndex {\n         //! Handles case of an expression that evaluates `subexprs` in order\n@@ -448,8 +428,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.add_ast_node(expr.id, &[subexprs_exit])\n     }\n \n-    fn match_(&mut self, id: ast::NodeId, discr: &ast::Expr,\n-              arms: &[ast::Arm], pred: CFGIndex) -> CFGIndex {\n+    fn match_(&mut self, id: ast::NodeId, discr: &hir::Expr,\n+              arms: &[hir::Arm], pred: CFGIndex) -> CFGIndex {\n         // The CFG for match expression is quite complex, so no ASCII\n         // art for it (yet).\n         //\n@@ -579,7 +559,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn add_exiting_edge(&mut self,\n-                        from_expr: &ast::Expr,\n+                        from_expr: &hir::Expr,\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n@@ -594,7 +574,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn add_returning_edge(&mut self,\n-                          _from_expr: &ast::Expr,\n+                          _from_expr: &hir::Expr,\n                           from_index: CFGIndex) {\n         let mut data = CFGEdgeData {\n             exiting_scopes: vec!(),\n@@ -606,7 +586,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn find_scope(&self,\n-                  expr: &ast::Expr,\n+                  expr: &hir::Expr,\n                   label: Option<ast::Ident>) -> LoopScope {\n         if label.is_none() {\n             return *self.loop_scopes.last().unwrap();"}, {"sha": "8fa2dac2da14020b7a90a2d55c8cc90e2f3b78ef", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -18,7 +18,7 @@ use graphviz as dot;\n \n use syntax::ast;\n \n-use ast_map;\n+use front::map as ast_map;\n use middle::cfg;\n \n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);"}, {"sha": "ac84d3dec94e21548811c0b0caf2b9f362835bdc", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -14,6 +14,7 @@\n use rustc_data_structures::graph;\n use middle::ty;\n use syntax::ast;\n+use rustc_front::hir;\n \n mod construct;\n pub mod graphviz;\n@@ -58,7 +59,7 @@ pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n     pub fn new(tcx: &ty::ctxt,\n-               blk: &ast::Block) -> CFG {\n+               blk: &hir::Block) -> CFG {\n         construct::construct(tcx, blk)\n     }\n "}, {"sha": "ad9cbfcf4c055d617aa05dd950b85488834d5c3f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 88, "deletions": 95, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -36,9 +36,10 @@ use middle::traits;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n \n+use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::visit::{self, FnKind, Visitor};\n+use rustc_front::visit::{self, FnKind, Visitor};\n \n use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n@@ -96,7 +97,7 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     mode: Mode,\n     qualif: ConstQualif,\n-    rvalue_borrows: NodeMap<ast::Mutability>\n+    rvalue_borrows: NodeMap<hir::Mutability>\n }\n \n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n@@ -125,7 +126,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         f(&mut euv::ExprUseVisitor::new(self, &infcx))\n     }\n \n-    fn global_expr(&mut self, mode: Mode, expr: &ast::Expr) -> ConstQualif {\n+    fn global_expr(&mut self, mode: Mode, expr: &hir::Expr) -> ConstQualif {\n         assert!(mode != Mode::Var);\n         match self.tcx.const_qualif_map.borrow_mut().entry(expr.id) {\n             Entry::Occupied(entry) => return *entry.get(),\n@@ -143,8 +144,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn fn_like(&mut self,\n                fk: FnKind,\n-               fd: &ast::FnDecl,\n-               b: &ast::Block,\n+               fd: &hir::FnDecl,\n+               b: &hir::Block,\n                s: Span,\n                fn_id: ast::NodeId)\n                -> ConstQualif {\n@@ -157,11 +158,11 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         }\n \n         let mode = match fk {\n-            FnKind::ItemFn(_, _, _, ast::Constness::Const, _, _) => {\n+            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _) => {\n                 Mode::ConstFn\n             }\n             FnKind::Method(_, m, _) => {\n-                if m.constness == ast::Constness::Const {\n+                if m.constness == hir::Constness::Const {\n                     Mode::ConstFn\n                 } else {\n                     Mode::Var\n@@ -174,7 +175,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         if mode == Mode::ConstFn {\n             for arg in &fd.inputs {\n                 match arg.pat.node {\n-                    ast::PatIdent(ast::BindByValue(ast::MutImmutable), _, None) => {}\n+                    hir::PatIdent(hir::BindByValue(hir::MutImmutable), _, None) => {}\n                     _ => {\n                         span_err!(self.tcx.sess, arg.pat.span, E0022,\n                                   \"arguments of constant functions can only \\\n@@ -204,7 +205,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     /// Returns true if the call is to a const fn or method.\n     fn handle_const_fn_call(&mut self,\n-                            expr: &ast::Expr,\n+                            expr: &hir::Expr,\n                             def_id: DefId,\n                             ret_ty: Ty<'tcx>)\n                             -> bool {\n@@ -246,12 +247,12 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn record_borrow(&mut self, id: ast::NodeId, mutbl: ast::Mutability) {\n+    fn record_borrow(&mut self, id: ast::NodeId, mutbl: hir::Mutability) {\n         match self.rvalue_borrows.entry(id) {\n             Entry::Occupied(mut entry) => {\n                 // Merge the two borrows, taking the most demanding\n                 // one, mutability-wise.\n-                if mutbl == ast::MutMutable {\n+                if mutbl == hir::MutMutable {\n                     entry.insert(mutbl);\n                 }\n             }\n@@ -270,7 +271,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_static_mut_type(&self, e: &ast::Expr) {\n+    fn check_static_mut_type(&self, e: &hir::Expr) {\n         let node_ty = self.tcx.node_id_to_type(e.id);\n         let tcontents = node_ty.type_contents(self.tcx);\n \n@@ -286,7 +287,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                  \"mutable statics are not allowed to have {}\", suffix);\n     }\n \n-    fn check_static_type(&self, e: &ast::Expr) {\n+    fn check_static_type(&self, e: &hir::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n@@ -302,21 +303,21 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n+    fn visit_item(&mut self, i: &hir::Item) {\n         debug!(\"visit_item(item={})\", self.tcx.map.node_to_string(i.id));\n         match i.node {\n-            ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n+            hir::ItemStatic(_, hir::MutImmutable, ref expr) => {\n                 self.check_static_type(&**expr);\n                 self.global_expr(Mode::Static, &**expr);\n             }\n-            ast::ItemStatic(_, ast::MutMutable, ref expr) => {\n+            hir::ItemStatic(_, hir::MutMutable, ref expr) => {\n                 self.check_static_mut_type(&**expr);\n                 self.global_expr(Mode::StaticMut, &**expr);\n             }\n-            ast::ItemConst(_, ref expr) => {\n+            hir::ItemConst(_, ref expr) => {\n                 self.global_expr(Mode::Const, &**expr);\n             }\n-            ast::ItemEnum(ref enum_definition, _) => {\n+            hir::ItemEnum(ref enum_definition, _) => {\n                 for var in &enum_definition.variants {\n                     if let Some(ref ex) = var.node.disr_expr {\n                         self.global_expr(Mode::Const, &**ex);\n@@ -329,9 +330,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n+    fn visit_trait_item(&mut self, t: &'v hir::TraitItem) {\n         match t.node {\n-            ast::ConstTraitItem(_, ref default) => {\n+            hir::ConstTraitItem(_, ref default) => {\n                 if let Some(ref expr) = *default {\n                     self.global_expr(Mode::Const, &*expr);\n                 } else {\n@@ -342,9 +343,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_impl_item(&mut self, i: &'v ast::ImplItem) {\n+    fn visit_impl_item(&mut self, i: &'v hir::ImplItem) {\n         match i.node {\n-            ast::ConstImplItem(_, ref expr) => {\n+            hir::ConstImplItem(_, ref expr) => {\n                 self.global_expr(Mode::Const, &*expr);\n             }\n             _ => self.with_mode(Mode::Var, |v| visit::walk_impl_item(v, i)),\n@@ -353,19 +354,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_fn(&mut self,\n                 fk: FnKind<'v>,\n-                fd: &'v ast::FnDecl,\n-                b: &'v ast::Block,\n+                fd: &'v hir::FnDecl,\n+                b: &'v hir::Block,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         self.fn_like(fk, fd, b, s, fn_id);\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &hir::Pat) {\n         match p.node {\n-            ast::PatLit(ref lit) => {\n+            hir::PatLit(ref lit) => {\n                 self.global_expr(Mode::Const, &**lit);\n             }\n-            ast::PatRange(ref start, ref end) => {\n+            hir::PatRange(ref start, ref end) => {\n                 self.global_expr(Mode::Const, &**start);\n                 self.global_expr(Mode::Const, &**end);\n \n@@ -386,24 +387,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_block(&mut self, block: &ast::Block) {\n+    fn visit_block(&mut self, block: &hir::Block) {\n         // Check all statements in the block\n         for stmt in &block.stmts {\n             let span = match stmt.node {\n-                ast::StmtDecl(ref decl, _) => {\n+                hir::StmtDecl(ref decl, _) => {\n                     match decl.node {\n-                        ast::DeclLocal(_) => decl.span,\n+                        hir::DeclLocal(_) => decl.span,\n \n                         // Item statements are allowed\n-                        ast::DeclItem(_) => continue\n+                        hir::DeclItem(_) => continue\n                     }\n                 }\n-                ast::StmtExpr(ref expr, _) => expr.span,\n-                ast::StmtSemi(ref semi, _) => semi.span,\n-                ast::StmtMac(..) => {\n-                    self.tcx.sess.span_bug(stmt.span, \"unexpanded statement \\\n-                                                       macro in const?!\")\n-                }\n+                hir::StmtExpr(ref expr, _) => expr.span,\n+                hir::StmtSemi(ref semi, _) => semi.span,\n             };\n             self.add_qualif(ConstQualif::NOT_CONST);\n             if self.mode != Mode::Var {\n@@ -415,7 +412,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         visit::walk_block(self, block);\n     }\n \n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n+    fn visit_expr(&mut self, ex: &hir::Expr) {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n \n@@ -425,7 +422,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n         // Special-case some expressions to avoid certain flags bubbling up.\n         match ex.node {\n-            ast::ExprCall(ref callee, ref args) => {\n+            hir::ExprCall(ref callee, ref args) => {\n                 for arg in args {\n                     self.visit_expr(&**arg)\n                 }\n@@ -436,7 +433,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 let added = self.qualif - inner;\n                 self.qualif = inner | (added - ConstQualif::NON_ZERO_SIZED);\n             }\n-            ast::ExprRepeat(ref element, _) => {\n+            hir::ExprRepeat(ref element, _) => {\n                 self.visit_expr(&**element);\n                 // The count is checked elsewhere (typeck).\n                 let count = match node_ty.sty {\n@@ -448,14 +445,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     self.qualif.remove(ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n                 }\n             }\n-            ast::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprMatch(ref discr, ref arms, _) => {\n                 // Compute the most demanding borrow from all the arms'\n                 // patterns and set that on the discriminator.\n                 let mut borrow = None;\n                 for pat in arms.iter().flat_map(|arm| &arm.pats) {\n                     let pat_borrow = self.rvalue_borrows.remove(&pat.id);\n                     match (borrow, pat_borrow) {\n-                        (None, _) | (_, Some(ast::MutMutable)) => {\n+                        (None, _) | (_, Some(hir::MutMutable)) => {\n                             borrow = pat_borrow;\n                         }\n                         _ => {}\n@@ -467,9 +464,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 visit::walk_expr(self, ex);\n             }\n             // Division by zero and overflow checking.\n-            ast::ExprBinary(op, _, _) => {\n+            hir::ExprBinary(op, _, _) => {\n                 visit::walk_expr(self, ex);\n-                let div_or_rem = op.node == ast::BiDiv || op.node == ast::BiRem;\n+                let div_or_rem = op.node == hir::BiDiv || op.node == hir::BiRem;\n                 match node_ty.sty {\n                     ty::TyUint(_) | ty::TyInt(_) if div_or_rem => {\n                         if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n@@ -492,7 +489,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n         match self.rvalue_borrows.remove(&ex.id) {\n-            Some(ast::MutImmutable) => {\n+            Some(hir::MutImmutable) => {\n                 // Constants cannot be borrowed if they contain interior mutability as\n                 // it means that our \"silent insertion of statics\" could change\n                 // initializer values (very bad).\n@@ -514,7 +511,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n                 }\n             }\n-            Some(ast::MutMutable) => {\n+            Some(hir::MutMutable) => {\n                 // `&mut expr` means expr could be mutated, unless it's zero-sized.\n                 if self.qualif.intersects(ConstQualif::NON_ZERO_SIZED) {\n                     if self.mode == Mode::Var {\n@@ -545,7 +542,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n /// of a const/static item, it is qualified for promotion\n /// instead of producing errors.\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n-                        e: &ast::Expr, node_ty: Ty<'tcx>) {\n+                        e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyStruct(def, _) |\n         ty::TyEnum(def, _) if def.has_dtor() => {\n@@ -561,27 +558,27 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n \n     let method_call = ty::MethodCall::expr(e.id);\n     match e.node {\n-        ast::ExprUnary(..) |\n-        ast::ExprBinary(..) |\n-        ast::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n+        hir::ExprUnary(..) |\n+        hir::ExprBinary(..) |\n+        hir::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0011,\n                             \"user-defined operators are not allowed in {}s\", v.msg());\n             }\n         }\n-        ast::ExprBox(..) |\n-        ast::ExprUnary(ast::UnUniq, _) => {\n+        hir::ExprBox(..) |\n+        hir::ExprUnary(hir::UnUniq, _) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0010,\n                           \"allocations are not allowed in {}s\", v.msg());\n             }\n         }\n-        ast::ExprUnary(op, ref inner) => {\n+        hir::ExprUnary(op, ref inner) => {\n             match v.tcx.node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n-                    assert!(op == ast::UnDeref);\n+                    assert!(op == hir::UnDeref);\n \n                     v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n@@ -592,12 +589,12 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 _ => {}\n             }\n         }\n-        ast::ExprBinary(op, ref lhs, _) => {\n+        hir::ExprBinary(op, ref lhs, _) => {\n             match v.tcx.node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n-                    assert!(op.node == ast::BiEq || op.node == ast::BiNe ||\n-                            op.node == ast::BiLe || op.node == ast::BiLt ||\n-                            op.node == ast::BiGe || op.node == ast::BiGt);\n+                    assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n+                            op.node == hir::BiLe || op.node == hir::BiLt ||\n+                            op.node == hir::BiGe || op.node == hir::BiGt);\n \n                     v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n@@ -608,7 +605,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 _ => {}\n             }\n         }\n-        ast::ExprCast(ref from, _) => {\n+        hir::ExprCast(ref from, _) => {\n             debug!(\"Checking const cast(id={})\", from.id);\n             match v.tcx.cast_kinds.borrow().get(&from.id) {\n                 None => v.tcx.sess.span_bug(e.span, \"no kind for cast\"),\n@@ -622,7 +619,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 _ => {}\n             }\n         }\n-        ast::ExprPath(..) => {\n+        hir::ExprPath(..) => {\n             let def = v.tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n             match def {\n                 Some(def::DefVariant(_, _, _)) => {\n@@ -677,12 +674,12 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n             }\n         }\n-        ast::ExprCall(ref callee, _) => {\n+        hir::ExprCall(ref callee, _) => {\n             let mut callee = &**callee;\n             loop {\n                 callee = match callee.node {\n-                    ast::ExprParen(ref inner) => &**inner,\n-                    ast::ExprBlock(ref block) => match block.expr {\n+                    hir::ExprParen(ref inner) => &**inner,\n+                    hir::ExprBlock(ref block) => match block.expr {\n                         Some(ref tail) => &**tail,\n                         None => break\n                     },\n@@ -720,7 +717,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n             }\n         }\n-        ast::ExprMethodCall(..) => {\n+        hir::ExprMethodCall(..) => {\n             let method = v.tcx.tables.borrow().method_map[&method_call];\n             let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n@@ -735,23 +732,23 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n             }\n         }\n-        ast::ExprStruct(..) => {\n+        hir::ExprStruct(..) => {\n             let did = v.tcx.def_map.borrow().get(&e.id).map(|def| def.def_id());\n             if did == v.tcx.lang_items.unsafe_cell_type() {\n                 v.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n         }\n \n-        ast::ExprLit(_) |\n-        ast::ExprAddrOf(..) => {\n+        hir::ExprLit(_) |\n+        hir::ExprAddrOf(..) => {\n             v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n         }\n \n-        ast::ExprRepeat(..) => {\n+        hir::ExprRepeat(..) => {\n             v.add_qualif(ConstQualif::PREFER_IN_PLACE);\n         }\n \n-        ast::ExprClosure(..) => {\n+        hir::ExprClosure(..) => {\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n@@ -761,38 +758,34 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n \n-        ast::ExprBlock(_) |\n-        ast::ExprIndex(..) |\n-        ast::ExprField(..) |\n-        ast::ExprTupField(..) |\n-        ast::ExprVec(_) |\n-        ast::ExprParen(..) |\n-        ast::ExprTup(..) => {}\n+        hir::ExprBlock(_) |\n+        hir::ExprIndex(..) |\n+        hir::ExprField(..) |\n+        hir::ExprTupField(..) |\n+        hir::ExprVec(_) |\n+        hir::ExprParen(..) |\n+        hir::ExprTup(..) => {}\n \n         // Conditional control flow (possible to implement).\n-        ast::ExprMatch(..) |\n-        ast::ExprIf(..) |\n-        ast::ExprIfLet(..) |\n+        hir::ExprMatch(..) |\n+        hir::ExprIf(..) |\n \n         // Loops (not very meaningful in constants).\n-        ast::ExprWhile(..) |\n-        ast::ExprWhileLet(..) |\n-        ast::ExprForLoop(..) |\n-        ast::ExprLoop(..) |\n+        hir::ExprWhile(..) |\n+        hir::ExprLoop(..) |\n \n         // More control flow (also not very meaningful).\n-        ast::ExprBreak(_) |\n-        ast::ExprAgain(_) |\n-        ast::ExprRet(_) |\n+        hir::ExprBreak(_) |\n+        hir::ExprAgain(_) |\n+        hir::ExprRet(_) |\n \n         // Miscellaneous expressions that could be implemented.\n-        ast::ExprRange(..) |\n+        hir::ExprRange(..) |\n \n         // Expressions with side-effects.\n-        ast::ExprAssign(..) |\n-        ast::ExprAssignOp(..) |\n-        ast::ExprInlineAsm(_) |\n-        ast::ExprMac(_) => {\n+        hir::ExprAssign(..) |\n+        hir::ExprAssignOp(..) |\n+        hir::ExprInlineAsm(_) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0019,\n@@ -803,7 +796,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n }\n \n /// Check the adjustments of an expression\n-fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &ast::Expr) {\n+fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n     match v.tcx.tables.borrow().adjustments.get(&e.id) {\n         None | Some(&ty::AdjustReifyFnPointer) | Some(&ty::AdjustUnsafeFnPointer) => {}\n         Some(&ty::AdjustDerefRef(ty::AutoDerefRef { autoderefs, .. })) => {\n@@ -891,7 +884,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                         break;\n                     }\n                     let mutbl = bk.to_mutbl_lossy();\n-                    if mutbl == ast::MutMutable && self.mode == Mode::StaticMut {\n+                    if mutbl == hir::MutMutable && self.mode == Mode::StaticMut {\n                         // Mutable slices are the only `&mut` allowed in\n                         // globals, but only in `static mut`, nowhere else.\n                         // FIXME: This exception is really weird... there isn't\n@@ -940,12 +933,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n               _mode: euv::MutateMode) {}\n \n     fn matched_pat(&mut self,\n-                   _: &ast::Pat,\n+                   _: &hir::Pat,\n                    _: mc::cmt,\n                    _: euv::MatchMode) {}\n \n     fn consume_pat(&mut self,\n-                   _consume_pat: &ast::Pat,\n+                   _consume_pat: &hir::Pat,\n                    _cmt: mc::cmt,\n                    _mode: euv::ConsumeMode) {}\n }"}, {"sha": "1e85190ef38fa50a800f43843c5610aaa3ddce30", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -11,10 +11,10 @@ use self::Context::*;\n \n use session::Session;\n \n-use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use rustc_front::visit::Visitor;\n+use rustc_front::visit;\n+use rustc_front::hir;\n \n #[derive(Clone, Copy, PartialEq)]\n enum Context {\n@@ -27,29 +27,29 @@ struct CheckLoopVisitor<'a> {\n     cx: Context\n }\n \n-pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n+pub fn check_crate(sess: &Session, krate: &hir::Crate) {\n     visit::walk_crate(&mut CheckLoopVisitor { sess: sess, cx: Normal }, krate)\n }\n \n impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n+    fn visit_item(&mut self, i: &hir::Item) {\n         self.with_context(Normal, |v| visit::walk_item(v, i));\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+    fn visit_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n-            ast::ExprWhile(ref e, ref b, _) => {\n+            hir::ExprWhile(ref e, ref b, _) => {\n                 self.visit_expr(&**e);\n                 self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n-            ast::ExprLoop(ref b, _) => {\n+            hir::ExprLoop(ref b, _) => {\n                 self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n-            ast::ExprClosure(_, _, ref b) => {\n+            hir::ExprClosure(_, _, ref b) => {\n                 self.with_context(Closure, |v| v.visit_block(&**b));\n             }\n-            ast::ExprBreak(_) => self.require_loop(\"break\", e.span),\n-            ast::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n+            hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n+            hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n             _ => visit::walk_expr(self, e)\n         }\n     }"}, {"sha": "d0111860b44066f3893a2415133edf69a7fd7263", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 83, "deletions": 85, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -31,18 +31,23 @@ use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{range_inclusive, FromIterator, IntoIterator, repeat};\n use std::slice;\n-use syntax::ast::{self, DUMMY_NODE_ID, NodeId, Pat};\n+\n+use rustc_front::hir;\n+use rustc_front::hir::Pat;\n+use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::util as front_util;\n+\n+use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n use syntax::ast_util;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n-use syntax::fold::{Folder, noop_fold_pat};\n-use syntax::print::pprust::pat_to_string;\n+use rustc_front::fold::{Folder, noop_fold_pat};\n+use rustc_front::print::pprust::pat_to_string;\n use syntax::ptr::P;\n-use syntax::visit::{self, Visitor, FnKind};\n use util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n-    node: ast::PatWild(ast::PatWildSingle),\n+    node: hir::PatWild(hir::PatWildSingle),\n     span: DUMMY_SP\n };\n \n@@ -137,14 +142,14 @@ enum WitnessPreference {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n+    fn visit_expr(&mut self, ex: &hir::Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &ast::Local) {\n+    fn visit_local(&mut self, l: &hir::Local) {\n         check_local(self, l);\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n }\n@@ -157,10 +162,10 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n+fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n-        ast::ExprMatch(ref scrut, ref arms, source) => {\n+        hir::ExprMatch(ref scrut, ref arms, source) => {\n             for arm in arms {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n@@ -180,7 +185,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 (arm.pats.iter().map(|pat| {\n                     static_inliner.fold_pat((*pat).clone())\n                 }).collect(), arm.guard.as_ref().map(|e| &**e))\n-            }).collect::<Vec<(Vec<P<Pat>>, Option<&ast::Expr>)>>();\n+            }).collect::<Vec<(Vec<P<Pat>>, Option<&hir::Expr>)>>();\n \n             // Bail out early if inlining failed.\n             if static_inliner.failed {\n@@ -231,9 +236,9 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n }\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n-    ast_util::walk_pat(pat, |p| {\n+    front_util::walk_pat(pat, |p| {\n         match p.node {\n-            ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n+            hir::PatIdent(hir::BindByValue(hir::MutImmutable), ident, None) => {\n                 let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n@@ -262,8 +267,8 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n \n // Check that we do not match against a static NaN (#6804)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n-    ast_util::walk_pat(pat, |p| {\n-        if let ast::PatLit(ref expr) = p.node {\n+    front_util::walk_pat(pat, |p| {\n+        if let hir::PatLit(ref expr) = p.node {\n             match eval_const_expr_partial(cx.tcx, &**expr, ExprTypeChecked) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n@@ -290,8 +295,8 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n \n // Check for unreachable patterns\n fn check_arms(cx: &MatchCheckCtxt,\n-              arms: &[(Vec<P<Pat>>, Option<&ast::Expr>)],\n-              source: ast::MatchSource) {\n+              arms: &[(Vec<P<Pat>>, Option<&hir::Expr>)],\n+              source: hir::MatchSource) {\n     let mut seen = Matrix(vec![]);\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms {\n@@ -301,7 +306,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n             match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n-                        ast::MatchSource::IfLetDesugar { .. } => {\n+                        hir::MatchSource::IfLetDesugar { .. } => {\n                             if printed_if_let_err {\n                                 // we already printed an irrefutable if-let pattern error.\n                                 // We don't want two, that's just confusing.\n@@ -315,23 +320,23 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             }\n                         },\n \n-                        ast::MatchSource::WhileLetDesugar => {\n+                        hir::MatchSource::WhileLetDesugar => {\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = &first_arm_pats[0];\n                             let span = first_pat.span;\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n \n-                        ast::MatchSource::ForLoopDesugar => {\n+                        hir::MatchSource::ForLoopDesugar => {\n                             // this is a bug, because on `match iter.next()` we cover\n                             // `Some(<head>)` and `None`. It's impossible to have an unreachable\n                             // pattern\n                             // (see libsyntax/ext/expand.rs for the full expansion of a for loop)\n                             cx.tcx.sess.span_bug(pat.span, \"unreachable for-loop pattern\")\n                         },\n \n-                        ast::MatchSource::Normal => {\n+                        hir::MatchSource::Normal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n                     }\n@@ -350,12 +355,12 @@ fn check_arms(cx: &MatchCheckCtxt,\n \n fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     match p.node {\n-        ast::PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n+        hir::PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n         _ => p\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast::MatchSource) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir::MatchSource) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witness = match &pats[..] {\n@@ -364,10 +369,10 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast:\n                 _ => unreachable!()\n             };\n             match source {\n-                ast::MatchSource::ForLoopDesugar => {\n+                hir::MatchSource::ForLoopDesugar => {\n                     // `witness` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witness.node {\n-                        ast::PatEnum(_, Some(ref pats)) => match &pats[..] {\n+                        hir::PatEnum(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => unreachable!(),\n                         },\n@@ -394,14 +399,14 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast:\n     }\n }\n \n-fn const_val_to_expr(value: &ConstVal) -> P<ast::Expr> {\n+fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     let node = match value {\n-        &ConstVal::Bool(b) => ast::LitBool(b),\n+        &ConstVal::Bool(b) => hir::LitBool(b),\n         _ => unreachable!()\n     };\n-    P(ast::Expr {\n+    P(hir::Expr {\n         id: 0,\n-        node: ast::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n+        node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP\n     })\n }\n@@ -440,7 +445,7 @@ impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            ast::PatIdent(..) | ast::PatEnum(..) | ast::PatQPath(..) => {\n+            hir::PatIdent(..) | hir::PatEnum(..) | hir::PatQPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(DefAssociatedConst(did)) |\n@@ -469,16 +474,16 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n             _ => noop_fold_pat(pat, self)\n         };\n \n-        fn record_renamings(const_expr: &ast::Expr,\n-                            substituted_pat: &ast::Pat,\n+        fn record_renamings(const_expr: &hir::Expr,\n+                            substituted_pat: &hir::Pat,\n                             renaming_map: &mut FnvHashMap<(NodeId, Span), NodeId>) {\n             let mut renaming_recorder = RenamingRecorder {\n                 substituted_node_id: substituted_pat.id,\n                 origin_span: substituted_pat.span,\n                 renaming_map: renaming_map,\n             };\n \n-            let mut id_visitor = ast_util::IdVisitor {\n+            let mut id_visitor = front_util::IdVisitor {\n                 operation: &mut renaming_recorder,\n                 pass_through_items: true,\n                 visited_outermost: false,\n@@ -507,26 +512,26 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match left_ty.sty {\n-        ty::TyTuple(_) => ast::PatTup(pats.collect()),\n+        ty::TyTuple(_) => hir::PatTup(pats.collect()),\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = adt.variant_of_ctor(ctor);\n             if let VariantKind::Dict = v.kind() {\n                 let field_pats: Vec<_> = v.fields.iter()\n                     .zip(pats)\n-                    .filter(|&(_, ref pat)| pat.node != ast::PatWild(ast::PatWildSingle))\n+                    .filter(|&(_, ref pat)| pat.node != hir::PatWild(hir::PatWildSingle))\n                     .map(|(field, pat)| Spanned {\n                         span: DUMMY_SP,\n-                        node: ast::FieldPat {\n+                        node: hir::FieldPat {\n                             ident: ast::Ident::new(field.name),\n                             pat: pat,\n                             is_shorthand: false,\n                         }\n                     }).collect();\n                 let has_more_fields = field_pats.len() < pats_len;\n-                ast::PatStruct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                hir::PatStruct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n             } else {\n-                ast::PatEnum(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n+                hir::PatEnum(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n             }\n         }\n \n@@ -535,40 +540,40 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                ty::TyArray(_, n) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n-                        ast::PatVec(pats.collect(), None, vec!())\n+                        hir::PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::TySlice(_) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n-                        ast::PatVec(pats.collect(), None, vec!())\n+                        hir::PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n-                ty::TyStr => ast::PatWild(ast::PatWildSingle),\n+                ty::TyStr => hir::PatWild(hir::PatWildSingle),\n \n                 _ => {\n                     assert_eq!(pats_len, 1);\n-                    ast::PatRegion(pats.nth(0).unwrap(), mutbl)\n+                    hir::PatRegion(pats.nth(0).unwrap(), mutbl)\n                 }\n             }\n         }\n \n         ty::TyArray(_, len) => {\n             assert_eq!(pats_len, len);\n-            ast::PatVec(pats.collect(), None, vec![])\n+            hir::PatVec(pats.collect(), None, vec![])\n         }\n \n         _ => {\n             match *ctor {\n-                ConstantValue(ref v) => ast::PatLit(const_val_to_expr(v)),\n-                _ => ast::PatWild(ast::PatWildSingle),\n+                ConstantValue(ref v) => hir::PatLit(const_val_to_expr(v)),\n+                _ => hir::PatWild(hir::PatWildSingle),\n             }\n         }\n     };\n \n-    P(ast::Pat {\n+    P(hir::Pat {\n         id: 0,\n         node: pat,\n         span: DUMMY_SP\n@@ -658,15 +663,15 @@ fn is_useful(cx: &MatchCheckCtxt,\n         let left_ty = cx.tcx.pat_ty(&*real_pat);\n \n         match real_pat.node {\n-            ast::PatIdent(ast::BindByRef(..), _, _) => {\n+            hir::PatIdent(hir::BindByRef(..), _, _) => {\n                 left_ty.builtin_deref(false).unwrap().ty\n             }\n             _ => left_ty,\n         }\n     };\n \n     let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n-        ast::PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n+        hir::PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n \n@@ -747,7 +752,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        ast::PatIdent(..) =>\n+        hir::PatIdent(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n@@ -756,30 +761,30 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n-        ast::PatEnum(..) =>\n+        hir::PatEnum(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        ast::PatQPath(..) =>\n+        hir::PatQPath(..) =>\n             cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                             been rewritten\"),\n-        ast::PatStruct(..) =>\n+        hir::PatStruct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        ast::PatLit(ref expr) =>\n+        hir::PatLit(ref expr) =>\n             vec!(ConstantValue(eval_const_expr(cx.tcx, &**expr))),\n-        ast::PatRange(ref lo, ref hi) =>\n+        hir::PatRange(ref lo, ref hi) =>\n             vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n-        ast::PatVec(ref before, ref slice, ref after) =>\n+        hir::PatVec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n                 ty::TyArray(_, _) => vec!(Single),\n                 _                      => if slice.is_some() {\n@@ -790,12 +795,10 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     vec!(Slice(before.len() + after.len()))\n                 }\n             },\n-        ast::PatBox(_) | ast::PatTup(_) | ast::PatRegion(..) =>\n+        hir::PatBox(_) | hir::PatTup(_) | hir::PatRegion(..) =>\n             vec!(Single),\n-        ast::PatWild(_) =>\n+        hir::PatWild(_) =>\n             vec!(),\n-        ast::PatMac(_) =>\n-            cx.tcx.sess.bug(\"unexpanded macro\")\n     }\n }\n \n@@ -857,10 +860,10 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n-        ast::PatWild(_) =>\n+        hir::PatWild(_) =>\n             Some(vec![DUMMY_WILD_PAT; arity]),\n \n-        ast::PatIdent(_, _, _) => {\n+        hir::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n             match opt_def {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n@@ -875,7 +878,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        ast::PatEnum(_, ref args) => {\n+        hir::PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 DefConst(..) | DefAssociatedConst(..) =>\n@@ -892,12 +895,12 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        ast::PatQPath(_, _) => {\n+        hir::PatQPath(_, _) => {\n             cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                             been rewritten\")\n         }\n \n-        ast::PatStruct(_, ref pattern_fields, _) => {\n+        hir::PatStruct(_, ref pattern_fields, _) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n             let variant = adt.variant_of_ctor(constructor);\n@@ -914,13 +917,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        ast::PatTup(ref args) =>\n+        hir::PatTup(ref args) =>\n             Some(args.iter().map(|p| &**p).collect()),\n \n-        ast::PatBox(ref inner) | ast::PatRegion(ref inner, _) =>\n+        hir::PatBox(ref inner) | hir::PatRegion(ref inner, _) =>\n             Some(vec![&**inner]),\n \n-        ast::PatLit(ref expr) => {\n+        hir::PatLit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &**expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec![]),\n@@ -932,7 +935,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        ast::PatRange(ref from, ref to) => {\n+        hir::PatRange(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &**from);\n             let to_value = eval_const_expr(cx.tcx, &**to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n@@ -945,7 +948,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        ast::PatVec(ref before, ref slice, ref after) => {\n+        hir::PatVec(ref before, ref slice, ref after) => {\n             match *constructor {\n                 // Fixed-length vectors.\n                 Single => {\n@@ -976,11 +979,6 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 _ => None\n             }\n         }\n-\n-        ast::PatMac(_) => {\n-            span_err!(cx.tcx.sess, pat_span, E0300, \"unexpanded macro\");\n-            None\n-        }\n     };\n     head.map(|mut head| {\n         head.push_all(&r[..col]);\n@@ -989,7 +987,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     })\n }\n \n-fn check_local(cx: &mut MatchCheckCtxt, loc: &ast::Local) {\n+fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n     visit::walk_local(cx, loc);\n \n     let pat = StaticInliner::new(cx.tcx, None).fold_pat(loc.pat.clone());\n@@ -1002,8 +1000,8 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &ast::Local) {\n \n fn check_fn(cx: &mut MatchCheckCtxt,\n             kind: FnKind,\n-            decl: &ast::FnDecl,\n-            body: &ast::Block,\n+            decl: &hir::FnDecl,\n+            body: &hir::Block,\n             sp: Span,\n             fn_id: NodeId) {\n     match kind {\n@@ -1060,10 +1058,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     for pat in pats {\n         pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n             match bm {\n-                ast::BindByRef(_) => {\n+                hir::BindByRef(_) => {\n                     by_ref_span = Some(span);\n                 }\n-                ast::BindByValue(_) => {\n+                hir::BindByValue(_) => {\n                 }\n             }\n         })\n@@ -1085,10 +1083,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     for pat in pats {\n-        ast_util::walk_pat(&**pat, |p| {\n+        front_util::walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n-                    ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n+                    hir::PatIdent(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);\n                         //FIXME: (@jroesch) this code should be floated up as well\n                         let infcx = infer::new_infer_ctxt(cx.tcx,\n@@ -1099,7 +1097,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n-                    ast::PatIdent(ast::BindByRef(_), _, _) => {\n+                    hir::PatIdent(hir::BindByRef(_), _, _) => {\n                     }\n                     _ => {\n                         cx.tcx.sess.span_bug(\n@@ -1119,7 +1117,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n /// Ensures that a pattern guard doesn't borrow by mutable reference or\n /// assign.\n fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n-                                         guard: &ast::Expr) {\n+                                         guard: &hir::Expr) {\n     let mut checker = MutationChecker {\n         cx: cx,\n     };\n@@ -1188,7 +1186,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n         }\n \n         match pat.node {\n-            ast::PatIdent(_, _, Some(_)) => {\n+            hir::PatIdent(_, _, Some(_)) => {\n                 let bindings_were_allowed = self.bindings_allowed;\n                 self.bindings_allowed = false;\n                 visit::walk_pat(self, pat);"}, {"sha": "5659a18e500d9c18ec22d508af27122a718ed8c2", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -18,11 +18,12 @@ use middle::ty::ParameterEnvironment;\n use middle::ty;\n \n use syntax::ast;\n+use rustc_front::hir;\n use syntax::codemap::Span;\n-use syntax::visit;\n+use rustc_front::visit;\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &ast::Crate) {\n+                   krate: &hir::Crate) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n     visit::walk_crate(&mut rvcx, krate);\n }\n@@ -34,8 +35,8 @@ struct RvalueContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: visit::FnKind<'v>,\n-                fd: &'v ast::FnDecl,\n-                b: &'v ast::Block,\n+                fd: &'v hir::FnDecl,\n+                b: &'v hir::Block,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         {\n@@ -73,12 +74,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n     }\n \n     fn matched_pat(&mut self,\n-                   _matched_pat: &ast::Pat,\n+                   _matched_pat: &hir::Pat,\n                    _cmt: mc::cmt,\n                    _mode: euv::MatchMode) {}\n \n     fn consume_pat(&mut self,\n-                   _consume_pat: &ast::Pat,\n+                   _consume_pat: &hir::Pat,\n                    _cmt: mc::cmt,\n                    _mode: euv::ConsumeMode) {\n     }"}, {"sha": "84ea6902ca54a7f718e612114a25b745163b09a8", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -11,16 +11,17 @@\n // This compiler pass detects constants that refer to themselves\n // recursively.\n \n-use ast_map;\n+use front::map as ast_map;\n use session::Session;\n use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefVariant, DefMap};\n use util::nodemap::NodeMap;\n \n use syntax::{ast};\n use syntax::codemap::Span;\n use syntax::feature_gate::emit_feature_err;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use rustc_front::visit::Visitor;\n+use rustc_front::visit;\n+use rustc_front::hir;\n \n use std::cell::RefCell;\n \n@@ -32,19 +33,19 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n     // variant definitions with the discriminant expression that applies to\n     // each one. If the variant uses the default values (starting from `0`),\n     // then `None` is stored.\n-    discriminant_map: RefCell<NodeMap<Option<&'ast ast::Expr>>>,\n+    discriminant_map: RefCell<NodeMap<Option<&'ast hir::Expr>>>,\n }\n \n impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, it: &'ast ast::Item) {\n+    fn visit_item(&mut self, it: &'ast hir::Item) {\n         match it.node {\n-            ast::ItemStatic(..) |\n-            ast::ItemConst(..) => {\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) => {\n                 let mut recursion_visitor =\n                     CheckItemRecursionVisitor::new(self, &it.span);\n                 recursion_visitor.visit_item(it);\n             },\n-            ast::ItemEnum(ref enum_def, ref generics) => {\n+            hir::ItemEnum(ref enum_def, ref generics) => {\n                 // We could process the whole enum, but handling the variants\n                 // with discriminant expressions one by one gives more specific,\n                 // less redundant output.\n@@ -62,9 +63,9 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n         visit::walk_item(self, it)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'ast ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n         match ti.node {\n-            ast::ConstTraitItem(_, ref default) => {\n+            hir::ConstTraitItem(_, ref default) => {\n                 if let Some(_) = *default {\n                     let mut recursion_visitor =\n                         CheckItemRecursionVisitor::new(self, &ti.span);\n@@ -76,9 +77,9 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n         visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'ast ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n         match ii.node {\n-            ast::ConstImplItem(..) => {\n+            hir::ConstImplItem(..) => {\n                 let mut recursion_visitor =\n                     CheckItemRecursionVisitor::new(self, &ii.span);\n                 recursion_visitor.visit_impl_item(ii);\n@@ -90,7 +91,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n }\n \n pub fn check_crate<'ast>(sess: &Session,\n-                         krate: &'ast ast::Crate,\n+                         krate: &'ast hir::Crate,\n                          def_map: &DefMap,\n                          ast_map: &ast_map::Map<'ast>) {\n     let mut visitor = CheckCrateVisitor {\n@@ -108,7 +109,7 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a DefMap,\n-    discriminant_map: &'a RefCell<NodeMap<Option<&'ast ast::Expr>>>,\n+    discriminant_map: &'a RefCell<NodeMap<Option<&'ast hir::Expr>>>,\n     idstack: Vec<ast::NodeId>,\n }\n \n@@ -129,7 +130,7 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n         if self.idstack.iter().any(|&x| x == id) {\n             let any_static = self.idstack.iter().any(|&x| {\n                 if let ast_map::NodeItem(item) = self.ast_map.get(x) {\n-                    if let ast::ItemStatic(..) = item.node {\n+                    if let hir::ItemStatic(..) = item.node {\n                         true\n                     } else {\n                         false\n@@ -161,7 +162,7 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n     // So for every variant, we need to track whether there is an expression\n     // somewhere in the enum definition that controls its discriminant. We do\n     // this by starting from the end and searching backward.\n-    fn populate_enum_discriminants(&self, enum_definition: &'ast ast::EnumDef) {\n+    fn populate_enum_discriminants(&self, enum_definition: &'ast hir::EnumDef) {\n         // Get the map, and return if we already processed this enum or if it\n         // has no variants.\n         let mut discriminant_map = self.discriminant_map.borrow_mut();\n@@ -195,18 +196,18 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n }\n \n impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, it: &'ast ast::Item) {\n+    fn visit_item(&mut self, it: &'ast hir::Item) {\n         self.with_item_id_pushed(it.id, |v| visit::walk_item(v, it));\n     }\n \n-    fn visit_enum_def(&mut self, enum_definition: &'ast ast::EnumDef,\n-                      generics: &'ast ast::Generics) {\n+    fn visit_enum_def(&mut self, enum_definition: &'ast hir::EnumDef,\n+                      generics: &'ast hir::Generics) {\n         self.populate_enum_discriminants(enum_definition);\n         visit::walk_enum_def(self, enum_definition, generics);\n     }\n \n-    fn visit_variant(&mut self, variant: &'ast ast::Variant,\n-                     _: &'ast ast::Generics) {\n+    fn visit_variant(&mut self, variant: &'ast hir::Variant,\n+                     _: &'ast hir::Generics) {\n         let variant_id = variant.node.id;\n         let maybe_expr;\n         if let Some(get_expr) = self.discriminant_map.borrow().get(&variant_id) {\n@@ -225,17 +226,17 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'ast ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n         self.with_item_id_pushed(ti.id, |v| visit::walk_trait_item(v, ti));\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'ast ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n         self.with_item_id_pushed(ii.id, |v| visit::walk_impl_item(v, ii));\n     }\n \n-    fn visit_expr(&mut self, e: &'ast ast::Expr) {\n+    fn visit_expr(&mut self, e: &'ast hir::Expr) {\n         match e.node {\n-            ast::ExprPath(..) => {\n+            hir::ExprPath(..) => {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n                     Some(DefAssociatedConst(def_id)) |\n@@ -261,7 +262,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n                     Some(DefVariant(enum_id, variant_id, false)) if enum_id.is_local() => {\n-                        if let ast::ItemEnum(ref enum_def, ref generics) =\n+                        if let hir::ItemEnum(ref enum_def, ref generics) =\n                                self.ast_map.expect_item(enum_id.local_id()).node {\n                             self.populate_enum_discriminants(enum_def);\n                             let variant = self.ast_map.expect_variant(variant_id.local_id());"}, {"sha": "039a9e55523f647f18872ef1dca5631d75c39ab0", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 157, "deletions": 154, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -14,8 +14,8 @@ use self::ConstVal::*;\n use self::ErrKind::*;\n use self::EvalHint::*;\n \n-use ast_map;\n-use ast_map::blocks::FnLikeNode;\n+use front::map as ast_map;\n+use front::map::blocks::FnLikeNode;\n use metadata::csearch;\n use metadata::inline::InlinedItem;\n use middle::{astencode, def, infer, subst, traits};\n@@ -25,11 +25,14 @@ use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n \n-use syntax::ast::{self, Expr};\n-use syntax::codemap::{self, Span};\n+use syntax::ast;\n+use rustc_front::hir::Expr;\n+use rustc_front::hir;\n+use rustc_front::visit::FnKind;\n+use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n-use syntax::visit::FnKind;\n+use syntax::codemap;\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n@@ -56,7 +59,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                             enum_def: DefId,\n                             variant_def: DefId)\n                             -> Option<&'a Expr> {\n-    fn variant_expr<'a>(variants: &'a [P<ast::Variant>], id: ast::NodeId)\n+    fn variant_expr<'a>(variants: &'a [P<hir::Variant>], id: ast::NodeId)\n                         -> Option<&'a Expr> {\n         for variant in variants {\n             if variant.node.id == id {\n@@ -70,7 +73,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         match tcx.map.find(enum_def.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n+                hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n                     variant_expr(&variants[..], variant_def.node)\n                 }\n                 _ => None\n@@ -88,7 +91,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n             csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n-                ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n+                hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n@@ -112,13 +115,13 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                ast::ItemConst(_, ref const_expr) => {\n+                hir::ItemConst(_, ref const_expr) => {\n                     Some(&*const_expr)\n                 }\n                 _ => None\n             },\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n-                ast::ConstTraitItem(_, _) => {\n+                hir::ConstTraitItem(_, _) => {\n                     match maybe_ref_id {\n                         // If we have a trait item, and we know the expression\n                         // that's the source of the obligation to resolve it,\n@@ -144,7 +147,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                 _ => None\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                ast::ConstImplItem(_, ref expr) => {\n+                hir::ConstImplItem(_, ref expr) => {\n                     Some(&*expr)\n                 }\n                 _ => None\n@@ -163,11 +166,11 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n             csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n-                ast::ItemConst(_, ref const_expr) => Some(const_expr.id),\n+                hir::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n             csearch::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n-                ast::ConstTraitItem(_, _) => {\n+                hir::ConstTraitItem(_, _) => {\n                     used_ref_id = true;\n                     match maybe_ref_id {\n                         // As mentioned in the comments above for in-crate\n@@ -186,7 +189,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                 _ => None\n             },\n             csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n-                ast::ConstImplItem(_, ref expr) => Some(expr.id),\n+                hir::ConstImplItem(_, ref expr) => Some(expr.id),\n                 _ => None\n             },\n             _ => None\n@@ -246,11 +249,11 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId)\n     };\n \n     match fn_like.kind() {\n-        FnKind::ItemFn(_, _, _, ast::Constness::Const, _, _) => {\n+        FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _) => {\n             Some(fn_like)\n         }\n         FnKind::Method(_, m, _) => {\n-            if m.constness == ast::Constness::Const {\n+            if m.constness == hir::Constness::Const {\n                 Some(fn_like)\n             } else {\n                 None\n@@ -288,12 +291,12 @@ impl ConstVal {\n     }\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n     let pat = match expr.node {\n-        ast::ExprTup(ref exprs) =>\n-            ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n+        hir::ExprTup(ref exprs) =>\n+            hir::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n \n-        ast::ExprCall(ref callee, ref args) => {\n+        hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n@@ -304,33 +307,33 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n                 _ => unreachable!()\n             };\n             let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n-            ast::PatEnum(path, Some(pats))\n+            hir::PatEnum(path, Some(pats))\n         }\n \n-        ast::ExprStruct(ref path, ref fields, None) => {\n+        hir::ExprStruct(ref path, ref fields, None) => {\n             let field_pats = fields.iter().map(|field| codemap::Spanned {\n                 span: codemap::DUMMY_SP,\n-                node: ast::FieldPat {\n+                node: hir::FieldPat {\n                     ident: field.ident.node,\n                     pat: const_expr_to_pat(tcx, &*field.expr, span),\n                     is_shorthand: false,\n                 },\n             }).collect();\n-            ast::PatStruct(path.clone(), field_pats, false)\n+            hir::PatStruct(path.clone(), field_pats, false)\n         }\n \n-        ast::ExprVec(ref exprs) => {\n+        hir::ExprVec(ref exprs) => {\n             let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n-            ast::PatVec(pats, None, vec![])\n+            hir::PatVec(pats, None, vec![])\n         }\n \n-        ast::ExprPath(_, ref path) => {\n+        hir::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n-                    ast::PatStruct(path.clone(), vec![], false),\n+                    hir::PatStruct(path.clone(), vec![], false),\n                 Some(def::DefVariant(..)) =>\n-                    ast::PatEnum(path.clone(), None),\n+                    hir::PatEnum(path.clone(), None),\n                 _ => {\n                     match lookup_const(tcx, expr) {\n                         Some(actual) => return const_expr_to_pat(tcx, actual, span),\n@@ -340,9 +343,9 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             }\n         }\n \n-        _ => ast::PatLit(P(expr.clone()))\n+        _ => hir::PatLit(P(expr.clone()))\n     };\n-    P(ast::Pat { id: expr.id, node: pat, span: span })\n+    P(hir::Pat { id: expr.id, node: pat, span: span })\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> ConstVal {\n@@ -363,10 +366,10 @@ pub struct ConstEvalErr {\n pub enum ErrKind {\n     CannotCast,\n     CannotCastTo(&'static str),\n-    InvalidOpForBools(ast::BinOp_),\n-    InvalidOpForFloats(ast::BinOp_),\n-    InvalidOpForIntUint(ast::BinOp_),\n-    InvalidOpForUintInt(ast::BinOp_),\n+    InvalidOpForBools(hir::BinOp_),\n+    InvalidOpForFloats(hir::BinOp_),\n+    InvalidOpForIntUint(hir::BinOp_),\n+    InvalidOpForUintInt(hir::BinOp_),\n     NegateOn(ConstVal),\n     NotOn(ConstVal),\n \n@@ -463,35 +466,35 @@ pub enum IntTy { I8, I16, I32, I64 }\n pub enum UintTy { U8, U16, U32, U64 }\n \n impl IntTy {\n-    pub fn from(tcx: &ty::ctxt, t: ast::IntTy) -> IntTy {\n-        let t = if let ast::TyIs = t {\n+    pub fn from(tcx: &ty::ctxt, t: hir::IntTy) -> IntTy {\n+        let t = if let hir::TyIs = t {\n             tcx.sess.target.int_type\n         } else {\n             t\n         };\n         match t {\n-            ast::TyIs => unreachable!(),\n-            ast::TyI8  => IntTy::I8,\n-            ast::TyI16 => IntTy::I16,\n-            ast::TyI32 => IntTy::I32,\n-            ast::TyI64 => IntTy::I64,\n+            hir::TyIs => unreachable!(),\n+            hir::TyI8  => IntTy::I8,\n+            hir::TyI16 => IntTy::I16,\n+            hir::TyI32 => IntTy::I32,\n+            hir::TyI64 => IntTy::I64,\n         }\n     }\n }\n \n impl UintTy {\n-    pub fn from(tcx: &ty::ctxt, t: ast::UintTy) -> UintTy {\n-        let t = if let ast::TyUs = t {\n+    pub fn from(tcx: &ty::ctxt, t: hir::UintTy) -> UintTy {\n+        let t = if let hir::TyUs = t {\n             tcx.sess.target.uint_type\n         } else {\n             t\n         };\n         match t {\n-            ast::TyUs => unreachable!(),\n-            ast::TyU8  => UintTy::U8,\n-            ast::TyU16 => UintTy::U16,\n-            ast::TyU32 => UintTy::U32,\n-            ast::TyU64 => UintTy::U64,\n+            hir::TyUs => unreachable!(),\n+            hir::TyU8  => UintTy::U8,\n+            hir::TyU16 => UintTy::U16,\n+            hir::TyU32 => UintTy::U32,\n+            hir::TyU64 => UintTy::U64,\n         }\n     }\n }\n@@ -769,7 +772,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n     });\n \n     let result = match e.node {\n-      ast::ExprUnary(ast::UnNeg, ref inner) => {\n+      hir::ExprUnary(hir::UnNeg, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &**inner, ty_hint)) {\n           Float(f) => Float(-f),\n           Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n@@ -779,17 +782,17 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n-      ast::ExprUnary(ast::UnNot, ref inner) => {\n+      hir::ExprUnary(hir::UnNot, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &**inner, ty_hint)) {\n           Int(i) => Int(!i),\n           Uint(i) => const_uint_not(i, expr_uint_type),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n         }\n       }\n-      ast::ExprBinary(op, ref a, ref b) => {\n+      hir::ExprBinary(op, ref a, ref b) => {\n         let b_ty = match op.node {\n-            ast::BiShl | ast::BiShr => {\n+            hir::BiShl | hir::BiShr => {\n                 if let ExprTypeChecked = ty_hint {\n                     ExprTypeChecked\n                 } else {\n@@ -802,92 +805,92 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                try!(eval_const_expr_partial(tcx, &**b, b_ty))) {\n           (Float(a), Float(b)) => {\n             match op.node {\n-              ast::BiAdd => Float(a + b),\n-              ast::BiSub => Float(a - b),\n-              ast::BiMul => Float(a * b),\n-              ast::BiDiv => Float(a / b),\n-              ast::BiRem => Float(a % b),\n-              ast::BiEq => fromb(a == b),\n-              ast::BiLt => fromb(a < b),\n-              ast::BiLe => fromb(a <= b),\n-              ast::BiNe => fromb(a != b),\n-              ast::BiGe => fromb(a >= b),\n-              ast::BiGt => fromb(a > b),\n+              hir::BiAdd => Float(a + b),\n+              hir::BiSub => Float(a - b),\n+              hir::BiMul => Float(a * b),\n+              hir::BiDiv => Float(a / b),\n+              hir::BiRem => Float(a % b),\n+              hir::BiEq => fromb(a == b),\n+              hir::BiLt => fromb(a < b),\n+              hir::BiLe => fromb(a <= b),\n+              hir::BiNe => fromb(a != b),\n+              hir::BiGe => fromb(a >= b),\n+              hir::BiGt => fromb(a > b),\n               _ => signal!(e, InvalidOpForFloats(op.node))\n             }\n           }\n           (Int(a), Int(b)) => {\n             match op.node {\n-              ast::BiAdd => try!(const_int_checked_add(a,b,e,expr_int_type)),\n-              ast::BiSub => try!(const_int_checked_sub(a,b,e,expr_int_type)),\n-              ast::BiMul => try!(const_int_checked_mul(a,b,e,expr_int_type)),\n-              ast::BiDiv => try!(const_int_checked_div(a,b,e,expr_int_type)),\n-              ast::BiRem => try!(const_int_checked_rem(a,b,e,expr_int_type)),\n-              ast::BiAnd | ast::BiBitAnd => Int(a & b),\n-              ast::BiOr | ast::BiBitOr => Int(a | b),\n-              ast::BiBitXor => Int(a ^ b),\n-              ast::BiShl => try!(const_int_checked_shl(a,b,e,expr_int_type)),\n-              ast::BiShr => try!(const_int_checked_shr(a,b,e,expr_int_type)),\n-              ast::BiEq => fromb(a == b),\n-              ast::BiLt => fromb(a < b),\n-              ast::BiLe => fromb(a <= b),\n-              ast::BiNe => fromb(a != b),\n-              ast::BiGe => fromb(a >= b),\n-              ast::BiGt => fromb(a > b)\n+              hir::BiAdd => try!(const_int_checked_add(a,b,e,expr_int_type)),\n+              hir::BiSub => try!(const_int_checked_sub(a,b,e,expr_int_type)),\n+              hir::BiMul => try!(const_int_checked_mul(a,b,e,expr_int_type)),\n+              hir::BiDiv => try!(const_int_checked_div(a,b,e,expr_int_type)),\n+              hir::BiRem => try!(const_int_checked_rem(a,b,e,expr_int_type)),\n+              hir::BiAnd | hir::BiBitAnd => Int(a & b),\n+              hir::BiOr | hir::BiBitOr => Int(a | b),\n+              hir::BiBitXor => Int(a ^ b),\n+              hir::BiShl => try!(const_int_checked_shl(a,b,e,expr_int_type)),\n+              hir::BiShr => try!(const_int_checked_shr(a,b,e,expr_int_type)),\n+              hir::BiEq => fromb(a == b),\n+              hir::BiLt => fromb(a < b),\n+              hir::BiLe => fromb(a <= b),\n+              hir::BiNe => fromb(a != b),\n+              hir::BiGe => fromb(a >= b),\n+              hir::BiGt => fromb(a > b)\n             }\n           }\n           (Uint(a), Uint(b)) => {\n             match op.node {\n-              ast::BiAdd => try!(const_uint_checked_add(a,b,e,expr_uint_type)),\n-              ast::BiSub => try!(const_uint_checked_sub(a,b,e,expr_uint_type)),\n-              ast::BiMul => try!(const_uint_checked_mul(a,b,e,expr_uint_type)),\n-              ast::BiDiv => try!(const_uint_checked_div(a,b,e,expr_uint_type)),\n-              ast::BiRem => try!(const_uint_checked_rem(a,b,e,expr_uint_type)),\n-              ast::BiAnd | ast::BiBitAnd => Uint(a & b),\n-              ast::BiOr | ast::BiBitOr => Uint(a | b),\n-              ast::BiBitXor => Uint(a ^ b),\n-              ast::BiShl => try!(const_uint_checked_shl(a,b,e,expr_uint_type)),\n-              ast::BiShr => try!(const_uint_checked_shr(a,b,e,expr_uint_type)),\n-              ast::BiEq => fromb(a == b),\n-              ast::BiLt => fromb(a < b),\n-              ast::BiLe => fromb(a <= b),\n-              ast::BiNe => fromb(a != b),\n-              ast::BiGe => fromb(a >= b),\n-              ast::BiGt => fromb(a > b),\n+              hir::BiAdd => try!(const_uint_checked_add(a,b,e,expr_uint_type)),\n+              hir::BiSub => try!(const_uint_checked_sub(a,b,e,expr_uint_type)),\n+              hir::BiMul => try!(const_uint_checked_mul(a,b,e,expr_uint_type)),\n+              hir::BiDiv => try!(const_uint_checked_div(a,b,e,expr_uint_type)),\n+              hir::BiRem => try!(const_uint_checked_rem(a,b,e,expr_uint_type)),\n+              hir::BiAnd | hir::BiBitAnd => Uint(a & b),\n+              hir::BiOr | hir::BiBitOr => Uint(a | b),\n+              hir::BiBitXor => Uint(a ^ b),\n+              hir::BiShl => try!(const_uint_checked_shl(a,b,e,expr_uint_type)),\n+              hir::BiShr => try!(const_uint_checked_shr(a,b,e,expr_uint_type)),\n+              hir::BiEq => fromb(a == b),\n+              hir::BiLt => fromb(a < b),\n+              hir::BiLe => fromb(a <= b),\n+              hir::BiNe => fromb(a != b),\n+              hir::BiGe => fromb(a >= b),\n+              hir::BiGt => fromb(a > b),\n             }\n           }\n           // shifts can have any integral type as their rhs\n           (Int(a), Uint(b)) => {\n             match op.node {\n-              ast::BiShl => try!(const_int_checked_shl_via_uint(a,b,e,expr_int_type)),\n-              ast::BiShr => try!(const_int_checked_shr_via_uint(a,b,e,expr_int_type)),\n+              hir::BiShl => try!(const_int_checked_shl_via_uint(a,b,e,expr_int_type)),\n+              hir::BiShr => try!(const_int_checked_shr_via_uint(a,b,e,expr_int_type)),\n               _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n           (Uint(a), Int(b)) => {\n             match op.node {\n-              ast::BiShl => try!(const_uint_checked_shl_via_int(a,b,e,expr_uint_type)),\n-              ast::BiShr => try!(const_uint_checked_shr_via_int(a,b,e,expr_uint_type)),\n+              hir::BiShl => try!(const_uint_checked_shl_via_int(a,b,e,expr_uint_type)),\n+              hir::BiShr => try!(const_uint_checked_shr_via_int(a,b,e,expr_uint_type)),\n               _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n           (Bool(a), Bool(b)) => {\n             Bool(match op.node {\n-              ast::BiAnd => a && b,\n-              ast::BiOr => a || b,\n-              ast::BiBitXor => a ^ b,\n-              ast::BiBitAnd => a & b,\n-              ast::BiBitOr => a | b,\n-              ast::BiEq => a == b,\n-              ast::BiNe => a != b,\n+              hir::BiAnd => a && b,\n+              hir::BiOr => a || b,\n+              hir::BiBitXor => a ^ b,\n+              hir::BiBitAnd => a & b,\n+              hir::BiBitOr => a | b,\n+              hir::BiEq => a == b,\n+              hir::BiNe => a != b,\n               _ => signal!(e, InvalidOpForBools(op.node)),\n              })\n           }\n \n           _ => signal!(e, MiscBinaryOp),\n         }\n       }\n-      ast::ExprCast(ref base, ref target_ty) => {\n+      hir::ExprCast(ref base, ref target_ty) => {\n         let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n@@ -912,14 +915,14 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n       }\n-      ast::ExprPath(..) => {\n+      hir::ExprPath(..) => {\n           let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n           let (const_expr, const_ty) = match opt_def {\n               Some(def::DefConst(def_id)) => {\n                   if def_id.is_local() {\n                       match tcx.map.find(def_id.node) {\n                           Some(ast_map::NodeItem(it)) => match it.node {\n-                              ast::ItemConst(ref ty, ref expr) => {\n+                              hir::ItemConst(ref ty, ref expr) => {\n                                   (Some(&**expr), Some(&**ty))\n                               }\n                               _ => (None, None)\n@@ -935,7 +938,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       match tcx.impl_or_trait_item(def_id).container() {\n                           ty::TraitContainer(trait_id) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n-                                  ast::ConstTraitItem(ref ty, _) => {\n+                                  hir::ConstTraitItem(ref ty, _) => {\n                                       if let ExprTypeChecked = ty_hint {\n                                           let substs = tcx.node_id_item_substs(e.id).substs;\n                                           (resolve_trait_associated_const(tcx,\n@@ -953,7 +956,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           },\n                           ty::ImplContainer(_) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                                  ast::ConstImplItem(ref ty, ref expr) => {\n+                                  hir::ConstImplItem(ref ty, ref expr) => {\n                                       (Some(&**expr), Some(&**ty))\n                                   }\n                                   _ => (None, None)\n@@ -990,27 +993,27 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           };\n           try!(eval_const_expr_partial(tcx, const_expr, item_hint))\n       }\n-      ast::ExprLit(ref lit) => {\n+      hir::ExprLit(ref lit) => {\n           lit_to_const(&**lit, ety)\n       }\n-      ast::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ty_hint)),\n-      ast::ExprBlock(ref block) => {\n+      hir::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ty_hint)),\n+      hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint)),\n             None => Int(0)\n         }\n       }\n-      ast::ExprTup(_) => Tuple(e.id),\n-      ast::ExprStruct(..) => Struct(e.id),\n-      ast::ExprTupField(ref base, index) => {\n+      hir::ExprTup(_) => Tuple(e.id),\n+      hir::ExprStruct(..) => Struct(e.id),\n+      hir::ExprTupField(ref base, index) => {\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n             UncheckedExprNoHint\n         };\n         if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint) {\n             if let Tuple(tup_id) = c {\n-                if let ast::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n+                if let hir::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                     if index.node < fields.len() {\n                         return eval_const_expr_partial(tcx, &fields[index.node], base_hint)\n                     } else {\n@@ -1026,7 +1029,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             signal!(base, NonConstPath)\n         }\n       }\n-      ast::ExprField(ref base, field_name) => {\n+      hir::ExprField(ref base, field_name) => {\n         // Get the base expression if it is a struct and it is constant\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n@@ -1035,7 +1038,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         };\n         if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint) {\n             if let Struct(struct_id) = c {\n-                if let ast::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n+                if let hir::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                     // Check that the given field exists and evaluate it\n                     // if the idents are compared run-pass/issue-19244 fails\n                     if let Some(f) = fields.iter().find(|f| f.ident.node.name\n@@ -1061,7 +1064,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n-                                                ti: &'tcx ast::TraitItem,\n+                                                ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n                                                 rcvr_substs: subst::Substs<'tcx>)\n                                                 -> Option<&'tcx Expr>\n@@ -1110,7 +1113,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                      .iter().find(|ic| ic.name == ti.ident.name) {\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {\n-                    ast::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),\n+                    hir::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),\n                     _ => None,\n                 },\n             }\n@@ -1138,60 +1141,60 @@ fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: ConstVal, ty: Ty) -> CastResult {\n \n     // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n     match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n-        (&ty::TyInt(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, Int, i64),\n-        (&ty::TyInt(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, Int, i64),\n-        (&ty::TyInt(ast::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n+        (&ty::TyInt(hir::TyIs), hir::TyI32, _) => return convert_val!(i32, Int, i64),\n+        (&ty::TyInt(hir::TyIs), hir::TyI64, _) => return convert_val!(i64, Int, i64),\n+        (&ty::TyInt(hir::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n \n-        (&ty::TyUint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, Uint, u64),\n-        (&ty::TyUint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, Uint, u64),\n-        (&ty::TyUint(ast::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n+        (&ty::TyUint(hir::TyUs), _, hir::TyU32) => return convert_val!(u32, Uint, u64),\n+        (&ty::TyUint(hir::TyUs), _, hir::TyU64) => return convert_val!(u64, Uint, u64),\n+        (&ty::TyUint(hir::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n \n         _ => {}\n     }\n \n     match ty.sty {\n-        ty::TyInt(ast::TyIs) => unreachable!(),\n-        ty::TyUint(ast::TyUs) => unreachable!(),\n+        ty::TyInt(hir::TyIs) => unreachable!(),\n+        ty::TyUint(hir::TyUs) => unreachable!(),\n \n-        ty::TyInt(ast::TyI8) => convert_val!(i8, Int, i64),\n-        ty::TyInt(ast::TyI16) => convert_val!(i16, Int, i64),\n-        ty::TyInt(ast::TyI32) => convert_val!(i32, Int, i64),\n-        ty::TyInt(ast::TyI64) => convert_val!(i64, Int, i64),\n+        ty::TyInt(hir::TyI8) => convert_val!(i8, Int, i64),\n+        ty::TyInt(hir::TyI16) => convert_val!(i16, Int, i64),\n+        ty::TyInt(hir::TyI32) => convert_val!(i32, Int, i64),\n+        ty::TyInt(hir::TyI64) => convert_val!(i64, Int, i64),\n \n-        ty::TyUint(ast::TyU8) => convert_val!(u8, Uint, u64),\n-        ty::TyUint(ast::TyU16) => convert_val!(u16, Uint, u64),\n-        ty::TyUint(ast::TyU32) => convert_val!(u32, Uint, u64),\n-        ty::TyUint(ast::TyU64) => convert_val!(u64, Uint, u64),\n+        ty::TyUint(hir::TyU8) => convert_val!(u8, Uint, u64),\n+        ty::TyUint(hir::TyU16) => convert_val!(u16, Uint, u64),\n+        ty::TyUint(hir::TyU32) => convert_val!(u32, Uint, u64),\n+        ty::TyUint(hir::TyU64) => convert_val!(u64, Uint, u64),\n \n-        ty::TyFloat(ast::TyF32) => convert_val!(f32, Float, f64),\n-        ty::TyFloat(ast::TyF64) => convert_val!(f64, Float, f64),\n+        ty::TyFloat(hir::TyF32) => convert_val!(f32, Float, f64),\n+        ty::TyFloat(hir::TyF64) => convert_val!(f64, Float, f64),\n         _ => Err(ErrKind::CannotCast),\n     }\n }\n \n-fn lit_to_const(lit: &ast::Lit, ty_hint: Option<Ty>) -> ConstVal {\n+fn lit_to_const(lit: &hir::Lit, ty_hint: Option<Ty>) -> ConstVal {\n     match lit.node {\n-        ast::LitStr(ref s, _) => Str((*s).clone()),\n-        ast::LitBinary(ref data) => {\n+        hir::LitStr(ref s, _) => Str((*s).clone()),\n+        hir::LitBinary(ref data) => {\n             Binary(data.clone())\n         }\n-        ast::LitByte(n) => Uint(n as u64),\n-        ast::LitChar(n) => Uint(n as u64),\n-        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) => Int(n as i64),\n-        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => {\n+        hir::LitByte(n) => Uint(n as u64),\n+        hir::LitChar(n) => Uint(n as u64),\n+        hir::LitInt(n, hir::SignedIntLit(_, hir::Plus)) => Int(n as i64),\n+        hir::LitInt(n, hir::UnsuffixedIntLit(hir::Plus)) => {\n             match ty_hint.map(|ty| &ty.sty) {\n                 Some(&ty::TyUint(_)) => Uint(n),\n                 _ => Int(n as i64)\n             }\n         }\n-        ast::LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n-        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => Int(-(n as i64)),\n-        ast::LitInt(n, ast::UnsignedIntLit(_)) => Uint(n),\n-        ast::LitFloat(ref n, _) |\n-        ast::LitFloatUnsuffixed(ref n) => {\n+        hir::LitInt(n, hir::SignedIntLit(_, hir::Minus)) |\n+        hir::LitInt(n, hir::UnsuffixedIntLit(hir::Minus)) => Int(-(n as i64)),\n+        hir::LitInt(n, hir::UnsignedIntLit(_)) => Uint(n),\n+        hir::LitFloat(ref n, _) |\n+        hir::LitFloatUnsuffixed(ref n) => {\n             Float(n.parse::<f64>().unwrap() as f64)\n         }\n-        ast::LitBool(b) => Bool(b)\n+        hir::LitBool(b) => Bool(b)\n     }\n }\n "}, {"sha": "14ba241f62b0f1bfabdb6dd0a94a68eaef0fa1c0", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -23,9 +23,12 @@ use std::io;\n use std::usize;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n-use syntax::visit;\n-use syntax::print::{pp, pprust};\n+use syntax::print::pp;\n use util::nodemap::NodeMap;\n+use rustc_front::hir;\n+use rustc_front::visit;\n+use rustc_front::print::pprust;\n+\n \n #[derive(Copy, Clone, Debug)]\n pub enum EntryOrExit {\n@@ -158,7 +161,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n     }\n }\n \n-fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n+fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n                          cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n     let mut index = NodeMap();\n \n@@ -181,7 +184,7 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n     return index;\n \n     fn add_entries_from_fn_decl(index: &mut NodeMap<Vec<CFGIndex>>,\n-                                decl: &ast::FnDecl,\n+                                decl: &hir::FnDecl,\n                                 entry: CFGIndex) {\n         //! add mappings from the ast nodes for the formal bindings to\n         //! the entry-node in the graph.\n@@ -192,7 +195,7 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n         let mut formals = Formals { entry: entry, index: index };\n         visit::walk_fn_decl(&mut formals, decl);\n         impl<'a, 'v> visit::Visitor<'v> for Formals<'a> {\n-            fn visit_pat(&mut self, p: &ast::Pat) {\n+            fn visit_pat(&mut self, p: &hir::Pat) {\n                 self.index.entry(p.id).or_insert(vec![]).push(self.entry);\n                 visit::walk_pat(self, p)\n             }\n@@ -222,7 +225,7 @@ pub enum KillFrom {\n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     pub fn new(tcx: &'a ty::ctxt<'tcx>,\n                analysis_name: &'static str,\n-               decl: Option<&ast::FnDecl>,\n+               decl: Option<&hir::FnDecl>,\n                cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n@@ -495,7 +498,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n //                                ^^^^^^^^^^^^^ only needed for pretty printing\n-    pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &ast::Block) {\n+    pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &hir::Block) {\n         //! Performs the data flow analysis.\n \n         if self.bits_per_id == 0 {\n@@ -528,7 +531,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n     }\n \n     fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n-                           blk: &ast::Block) -> io::Result<()> {\n+                           blk: &hir::Block) -> io::Result<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self);\n         try!(ps.cbox(pprust::indent_unit));\n         try!(ps.ibox(0));"}, {"sha": "ed9ca48b39ca2b209cce82a105e0130fae0a3060", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -12,16 +12,18 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n-use ast_map;\n+use front::map as ast_map;\n+use rustc_front::hir;\n+use rustc_front::visit::{self, Visitor};\n+use rustc_front::attr::{self, AttrMetaMethods};\n+\n use middle::{def, pat_util, privacy, ty};\n use middle::def_id::{DefId};\n use lint;\n use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n use syntax::{ast, codemap};\n-use syntax::attr::{self, AttrMetaMethods};\n-use syntax::visit::{self, Visitor};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live NodeItem that is a\n@@ -109,30 +111,30 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.check_def_id(method.def_id);\n     }\n \n-    fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n+    fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n         if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n             self.live_symbols.insert(def.struct_variant().field_named(name).did.node);\n         } else {\n             self.tcx.sess.span_bug(lhs.span, \"named field access on non-struct\")\n         }\n     }\n \n-    fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n+    fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n         if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n             self.live_symbols.insert(def.struct_variant().fields[idx].did.node);\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &ast::Pat,\n-                                  pats: &[codemap::Spanned<ast::FieldPat>]) {\n+    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n+                                  pats: &[codemap::Spanned<hir::FieldPat>]) {\n         let def = self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def();\n         let pat_ty = self.tcx.node_id_to_type(lhs.id);\n         let variant = match pat_ty.sty {\n             ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => adt.variant_of_def(def),\n             _ => self.tcx.sess.span_bug(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n-            if let ast::PatWild(ast::PatWildSingle) = pat.node.pat.node {\n+            if let hir::PatWild(hir::PatWildSingle) = pat.node.pat.node {\n                 continue;\n             }\n             self.live_symbols.insert(variant.field_named(pat.node.ident.name).did.node);\n@@ -166,22 +168,22 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    ast::ItemStruct(..) => {\n+                    hir::ItemStruct(..) => {\n                         self.struct_has_extern_repr = item.attrs.iter().any(|attr| {\n                             attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n                                 .contains(&attr::ReprExtern)\n                         });\n \n                         visit::walk_item(self, &*item);\n                     }\n-                    ast::ItemEnum(..) => {\n-                        self.inherited_pub_visibility = item.vis == ast::Public;\n+                    hir::ItemEnum(..) => {\n+                        self.inherited_pub_visibility = item.vis == hir::Public;\n                         visit::walk_item(self, &*item);\n                     }\n-                    ast::ItemFn(..)\n-                    | ast::ItemTy(..)\n-                    | ast::ItemStatic(..)\n-                    | ast::ItemConst(..) => {\n+                    hir::ItemFn(..)\n+                    | hir::ItemTy(..)\n+                    | hir::ItemStatic(..)\n+                    | hir::ItemConst(..) => {\n                         visit::walk_item(self, &*item);\n                     }\n                     _ => ()\n@@ -205,13 +207,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n-    fn visit_struct_def(&mut self, def: &ast::StructDef, _: ast::Ident,\n-                        _: &ast::Generics, _: ast::NodeId) {\n+    fn visit_struct_def(&mut self, def: &hir::StructDef, _: ast::Ident,\n+                        _: &hir::Generics, _: ast::NodeId) {\n         let has_extern_repr = self.struct_has_extern_repr;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n         let live_fields = def.fields.iter().filter(|f| {\n             has_extern_repr || inherited_pub_visibility || match f.node.kind {\n-                ast::NamedField(_, ast::Public) => true,\n+                hir::NamedField(_, hir::Public) => true,\n                 _ => false\n             }\n         });\n@@ -220,15 +222,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         visit::walk_struct_def(self, def);\n     }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            ast::ExprMethodCall(..) => {\n+            hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id);\n             }\n-            ast::ExprField(ref lhs, ref ident) => {\n+            hir::ExprField(ref lhs, ref ident) => {\n                 self.handle_field_access(&**lhs, ident.node.name);\n             }\n-            ast::ExprTupField(ref lhs, idx) => {\n+            hir::ExprTupField(ref lhs, idx) => {\n                 self.handle_tup_field_access(&**lhs, idx.node);\n             }\n             _ => ()\n@@ -237,7 +239,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         visit::walk_expr(self, expr);\n     }\n \n-    fn visit_arm(&mut self, arm: &ast::Arm) {\n+    fn visit_arm(&mut self, arm: &hir::Arm) {\n         if arm.pats.len() == 1 {\n             let pat = &*arm.pats[0];\n             let variants = pat_util::necessary_variants(&self.tcx.def_map, pat);\n@@ -254,10 +256,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_pat(&mut self, pat: &ast::Pat) {\n+    fn visit_pat(&mut self, pat: &hir::Pat) {\n         let def_map = &self.tcx.def_map;\n         match pat.node {\n-            ast::PatStruct(_, ref fields, _) => {\n+            hir::PatStruct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields);\n             }\n             _ if pat_util::pat_is_const(def_map, pat) => {\n@@ -272,24 +274,24 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         self.ignore_non_const_paths = false;\n     }\n \n-    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         self.lookup_and_handle_definition(&id);\n         visit::walk_path(self, path);\n     }\n \n-    fn visit_item(&mut self, _: &ast::Item) {\n+    fn visit_item(&mut self, _: &hir::Item) {\n         // Do not recurse into items. These items will be added to the\n         // worklist and recursed into manually if necessary.\n     }\n }\n \n-fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n+fn has_allow_dead_code_or_lang_attr(attrs: &[hir::Attribute]) -> bool {\n     if attr::contains_name(attrs, \"lang\") {\n         return true;\n     }\n \n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n-    for attr in lint::gather_attrs(attrs) {\n+    for attr in lint::gather_attrs_from_hir(attrs) {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n                 if &name[..] == dead_code => return true,\n@@ -317,20 +319,20 @@ struct LifeSeeder {\n }\n \n impl<'v> Visitor<'v> for LifeSeeder {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(&item.attrs);\n         if allow_dead_code {\n             self.worklist.push(item.id);\n         }\n         match item.node {\n-            ast::ItemEnum(ref enum_def, _) if allow_dead_code => {\n+            hir::ItemEnum(ref enum_def, _) if allow_dead_code => {\n                 self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n             }\n-            ast::ItemTrait(_, _, _, ref trait_items) => {\n+            hir::ItemTrait(_, _, _, ref trait_items) => {\n                 for trait_item in trait_items {\n                     match trait_item.node {\n-                        ast::ConstTraitItem(_, Some(_)) |\n-                        ast::MethodTraitItem(_, Some(_)) => {\n+                        hir::ConstTraitItem(_, Some(_)) |\n+                        hir::MethodTraitItem(_, Some(_)) => {\n                             if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n                                 self.worklist.push(trait_item.id);\n                             }\n@@ -339,18 +341,17 @@ impl<'v> Visitor<'v> for LifeSeeder {\n                     }\n                 }\n             }\n-            ast::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n+            hir::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     match impl_item.node {\n-                        ast::ConstImplItem(..) |\n-                        ast::MethodImplItem(..) => {\n+                        hir::ConstImplItem(..) |\n+                        hir::MethodImplItem(..) => {\n                             if opt_trait.is_some() ||\n                                     has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n                                 self.worklist.push(impl_item.id);\n                             }\n                         }\n-                        ast::TypeImplItem(_) => {}\n-                        ast::MacImplItem(_) => panic!(\"unexpanded macro\")\n+                        hir::TypeImplItem(_) => {}\n                     }\n                 }\n             }\n@@ -363,7 +364,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n fn create_and_seed_worklist(tcx: &ty::ctxt,\n                             exported_items: &privacy::ExportedItems,\n                             reachable_symbols: &NodeSet,\n-                            krate: &ast::Crate) -> Vec<ast::NodeId> {\n+                            krate: &hir::Crate) -> Vec<ast::NodeId> {\n     let mut worklist = Vec::new();\n \n     // Preferably, we would only need to seed the worklist with reachable\n@@ -401,7 +402,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n fn find_live(tcx: &ty::ctxt,\n              exported_items: &privacy::ExportedItems,\n              reachable_symbols: &NodeSet,\n-             krate: &ast::Crate)\n+             krate: &hir::Crate)\n              -> Box<HashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, exported_items,\n                                             reachable_symbols, krate);\n@@ -410,9 +411,9 @@ fn find_live(tcx: &ty::ctxt,\n     symbol_visitor.live_symbols\n }\n \n-fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n+fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n     match item.node {\n-        ast::ItemStruct(ref struct_def, _) => struct_def.ctor_id,\n+        hir::ItemStruct(ref struct_def, _) => struct_def.ctor_id,\n         _ => None\n     }\n }\n@@ -423,20 +424,20 @@ struct DeadVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n-    fn should_warn_about_item(&mut self, item: &ast::Item) -> bool {\n+    fn should_warn_about_item(&mut self, item: &hir::Item) -> bool {\n         let should_warn = match item.node {\n-            ast::ItemStatic(..)\n-            | ast::ItemConst(..)\n-            | ast::ItemFn(..)\n-            | ast::ItemEnum(..)\n-            | ast::ItemStruct(..) => true,\n+            hir::ItemStatic(..)\n+            | hir::ItemConst(..)\n+            | hir::ItemFn(..)\n+            | hir::ItemEnum(..)\n+            | hir::ItemStruct(..) => true,\n             _ => false\n         };\n         let ctor_id = get_struct_ctor_id(item);\n         should_warn && !self.symbol_is_live(item.id, ctor_id)\n     }\n \n-    fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n+    fn should_warn_about_field(&mut self, node: &hir::StructField_) -> bool {\n         let is_named = node.ident().is_some();\n         let field_type = self.tcx.node_id_to_type(node.id);\n         let is_marker_field = match field_type.ty_to_def_id() {\n@@ -449,7 +450,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             && !has_allow_dead_code_or_lang_attr(&node.attrs)\n     }\n \n-    fn should_warn_about_variant(&mut self, variant: &ast::Variant_) -> bool {\n+    fn should_warn_about_variant(&mut self, variant: &hir::Variant_) -> bool {\n         !self.symbol_is_live(variant.id, None)\n             && !has_allow_dead_code_or_lang_attr(&variant.attrs)\n     }\n@@ -509,7 +510,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         if self.should_warn_about_item(item) {\n             self.warn_dead_code(\n                 item.id,\n@@ -519,7 +520,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             );\n         } else {\n             match item.node {\n-                ast::ItemEnum(ref enum_def, _) => {\n+                hir::ItemEnum(ref enum_def, _) => {\n                     for variant in &enum_def.variants {\n                         if self.should_warn_about_variant(&variant.node) {\n                             self.warn_dead_code(variant.node.id, variant.span,\n@@ -533,14 +534,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         visit::walk_item(self, item);\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, fi.ident.name, fi.node.descriptive_variant());\n         }\n         visit::walk_foreign_item(self, fi);\n     }\n \n-    fn visit_struct_field(&mut self, field: &ast::StructField) {\n+    fn visit_struct_field(&mut self, field: &hir::StructField) {\n         if self.should_warn_about_field(&field.node) {\n             self.warn_dead_code(field.node.id, field.span,\n                                 field.node.ident().unwrap().name, \"struct field\");\n@@ -549,39 +550,38 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         visit::walk_struct_field(self, field);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         match impl_item.node {\n-            ast::ConstImplItem(_, ref expr) => {\n+            hir::ConstImplItem(_, ref expr) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.ident.name, \"associated const\");\n                 }\n                 visit::walk_expr(self, expr)\n             }\n-            ast::MethodImplItem(_, ref body) => {\n+            hir::MethodImplItem(_, ref body) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.ident.name, \"method\");\n                 }\n                 visit::walk_block(self, body)\n             }\n-            ast::TypeImplItem(..) |\n-            ast::MacImplItem(..) => {}\n+            hir::TypeImplItem(..) => {}\n         }\n     }\n \n     // Overwrite so that we don't warn the trait item itself.\n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         match trait_item.node {\n-            ast::ConstTraitItem(_, Some(ref expr)) => {\n+            hir::ConstTraitItem(_, Some(ref expr)) => {\n                 visit::walk_expr(self, expr)\n             }\n-            ast::MethodTraitItem(_, Some(ref body)) => {\n+            hir::MethodTraitItem(_, Some(ref body)) => {\n                 visit::walk_block(self, body)\n             }\n-            ast::ConstTraitItem(_, None) |\n-            ast::MethodTraitItem(_, None) |\n-            ast::TypeTraitItem(..) => {}\n+            hir::ConstTraitItem(_, None) |\n+            hir::MethodTraitItem(_, None) |\n+            hir::TypeTraitItem(..) => {}\n         }\n     }\n }"}, {"sha": "2930dd67f45bab8c08f12789798e590c2783a14d", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -15,6 +15,7 @@ use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n use util::nodemap::NodeMap;\n use syntax::ast;\n+use rustc_front::hir;\n \n use std::cell::RefCell;\n \n@@ -33,7 +34,7 @@ pub enum Def {\n     DefTy(DefId, bool /* is_enum */),\n     DefAssociatedTy(DefId /* trait */, DefId),\n     DefTrait(DefId),\n-    DefPrimTy(ast::PrimTy),\n+    DefPrimTy(hir::PrimTy),\n     DefTyParam(ParamSpace, u32, DefId, ast::Name),\n     DefUse(DefId),\n     DefUpvar(ast::NodeId,  // id of closed over local"}, {"sha": "d1e1434dad8ad94da9c95a7e2de1adcdc60e37b6", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -18,8 +18,9 @@ use middle::ty::MethodCall;\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::visit;\n-use syntax::visit::{FnKind, Visitor};\n+use rustc_front::hir;\n+use rustc_front::visit;\n+use rustc_front::visit::{FnKind, Visitor};\n \n #[derive(Copy, Clone)]\n struct UnsafeContext {\n@@ -42,7 +43,7 @@ enum RootUnsafeContext {\n \n fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyBareFn(_, ref f) => f.unsafety == ast::Unsafety::Unsafe,\n+        ty::TyBareFn(_, ref f) => f.unsafety == hir::Unsafety::Unsafe,\n         _ => false,\n     }\n }\n@@ -75,14 +76,14 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n-    fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v ast::FnDecl,\n-                block: &'v ast::Block, span: Span, _: ast::NodeId) {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n+                block: &'v hir::Block, span: Span, _: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, _, _, _) =>\n-                (true, unsafety == ast::Unsafety::Unsafe),\n+                (true, unsafety == hir::Unsafety::Unsafe),\n             FnKind::Method(_, sig, _) =>\n-                (true, sig.unsafety == ast::Unsafety::Unsafe),\n+                (true, sig.unsafety == hir::Unsafety::Unsafe),\n             _ => (false, false),\n         };\n \n@@ -98,11 +99,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_block(&mut self, block: &ast::Block) {\n+    fn visit_block(&mut self, block: &hir::Block) {\n         let old_unsafe_context = self.unsafe_context;\n         match block.rules {\n-            ast::DefaultBlock => {}\n-            ast::UnsafeBlock(source) => {\n+            hir::DefaultBlock => {}\n+            hir::UnsafeBlock(source) => {\n                 // By default only the outermost `unsafe` block is\n                 // \"used\" and so nested unsafe blocks are pointless\n                 // (the inner ones are unnecessary and we actually\n@@ -118,15 +119,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 // external blocks (e.g. `unsafe { println(\"\") }`,\n                 // expands to `unsafe { ... unsafe { ... } }` where\n                 // the inner one is compiler generated).\n-                if self.unsafe_context.root == SafeContext || source == ast::CompilerGenerated {\n+                if self.unsafe_context.root == SafeContext || source == hir::CompilerGenerated {\n                     self.unsafe_context.root = UnsafeBlock(block.id)\n                 }\n             }\n-            ast::PushUnsafeBlock(..) => {\n+            hir::PushUnsafeBlock(..) => {\n                 self.unsafe_context.push_unsafe_count =\n                     self.unsafe_context.push_unsafe_count.checked_add(1).unwrap();\n             }\n-            ast::PopUnsafeBlock(..) => {\n+            hir::PopUnsafeBlock(..) => {\n                 self.unsafe_context.push_unsafe_count =\n                     self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n             }\n@@ -137,9 +138,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            ast::ExprMethodCall(_, _, _) => {\n+            hir::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n                 let base_type = self.tcx.tables.borrow().method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n@@ -149,26 +150,26 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                                         \"invocation of unsafe method\")\n                 }\n             }\n-            ast::ExprCall(ref base, _) => {\n+            hir::ExprCall(ref base, _) => {\n                 let base_type = self.tcx.node_id_to_type(base.id);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n-            ast::ExprUnary(ast::UnDeref, ref base) => {\n+            hir::ExprUnary(hir::UnDeref, ref base) => {\n                 let base_type = self.tcx.node_id_to_type(base.id);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n                     self.require_unsafe(expr.span, \"dereference of raw pointer\")\n                 }\n             }\n-            ast::ExprInlineAsm(..) => {\n+            hir::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n-            ast::ExprPath(..) => {\n+            hir::ExprPath(..) => {\n                 if let def::DefStatic(_, true) = self.tcx.resolve_expr(expr) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }"}, {"sha": "e32a9b280f3d517af2a38a6815d39e7c030903da", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n \n-use ast_map;\n+use front::map as ast_map;\n use session::{config, Session};\n-use syntax;\n-use syntax::ast::{NodeId, Item};\n-use syntax::attr;\n+use syntax::ast::NodeId;\n+use rustc_front::hir::{Item, ItemFn};\n+use rustc_front::attr;\n use syntax::codemap::Span;\n use syntax::entry::EntryPointType;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n+use rustc_front::visit;\n+use rustc_front::visit::Visitor;\n \n struct EntryContext<'a> {\n     session: &'a Session,\n@@ -76,8 +76,33 @@ pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n     configure_main(&mut ctxt);\n }\n \n+// Beware, this is duplicated in libsyntax/entry.rs, make sure to keep\n+// them in sync.\n+fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n+    match item.node {\n+        ItemFn(..) => {\n+            if attr::contains_name(&item.attrs, \"start\") {\n+                EntryPointType::Start\n+            } else if attr::contains_name(&item.attrs, \"main\") {\n+                EntryPointType::MainAttr\n+            } else if item.ident.name == \"main\" {\n+                if depth == 1 {\n+                    // This is a top-level function so can be 'main'\n+                    EntryPointType::MainNamed\n+                } else {\n+                    EntryPointType::OtherMain\n+                }\n+            } else {\n+                EntryPointType::None\n+            }\n+        }\n+        _ => EntryPointType::None,\n+    }\n+}\n+\n+\n fn find_item(item: &Item, ctxt: &mut EntryContext) {\n-    match syntax::entry::entry_point_type(item, ctxt.depth) {\n+    match entry_point_type(item, ctxt.depth) {\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {\n                 ctxt.main_fn = Some((item.id, item.span));"}, {"sha": "15f37d434d297b8220d458c6b07d467fbf3b1c08", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 90, "deletions": 108, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -26,7 +26,9 @@ use middle::infer;\n use middle::mem_categorization as mc;\n use middle::ty;\n \n-use syntax::{ast, ast_util};\n+use rustc_front::hir;\n+\n+use syntax::ast;\n use syntax::ptr::P;\n use syntax::codemap::Span;\n \n@@ -57,14 +59,14 @@ pub trait Delegate<'tcx> {\n     // same input pattern structure (though of `consume_pat` can be\n     // called on a subpart of an input passed to `matched_pat).\n     fn matched_pat(&mut self,\n-                   matched_pat: &ast::Pat,\n+                   matched_pat: &hir::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: MatchMode);\n \n     // The value found at `cmt` is either copied or moved via the\n     // pattern binding `consume_pat`, depending on mode.\n     fn consume_pat(&mut self,\n-                   consume_pat: &ast::Pat,\n+                   consume_pat: &hir::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: ConsumeMode);\n \n@@ -277,23 +279,25 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                typer: &'t infer::InferCtxt<'a, 'tcx>)\n                -> ExprUseVisitor<'d,'t,'a,'tcx>\n     {\n-        ExprUseVisitor {\n+        let result = ExprUseVisitor {\n             typer: typer,\n             mc: mc::MemCategorizationContext::new(typer),\n             delegate: delegate,\n-        }\n+        };\n+\n+        result\n     }\n \n     pub fn walk_fn(&mut self,\n-                   decl: &ast::FnDecl,\n-                   body: &ast::Block) {\n+                   decl: &hir::FnDecl,\n+                   body: &hir::Block) {\n         self.walk_arg_patterns(decl, body);\n         self.walk_block(body);\n     }\n \n     fn walk_arg_patterns(&mut self,\n-                         decl: &ast::FnDecl,\n-                         body: &ast::Block) {\n+                         decl: &hir::FnDecl,\n+                         body: &hir::Block) {\n         for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n \n@@ -323,13 +327,13 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &Vec<P<ast::Expr>>) {\n+    fn consume_exprs(&mut self, exprs: &Vec<P<hir::Expr>>) {\n         for expr in exprs {\n             self.consume_expr(&**expr);\n         }\n     }\n \n-    pub fn consume_expr(&mut self, expr: &ast::Expr) {\n+    pub fn consume_expr(&mut self, expr: &hir::Expr) {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n@@ -338,16 +342,16 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     }\n \n     fn mutate_expr(&mut self,\n-                   assignment_expr: &ast::Expr,\n-                   expr: &ast::Expr,\n+                   assignment_expr: &hir::Expr,\n+                   expr: &hir::Expr,\n                    mode: MutateMode) {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.mutate(assignment_expr.id, assignment_expr.span, cmt, mode);\n         self.walk_expr(expr);\n     }\n \n     fn borrow_expr(&mut self,\n-                   expr: &ast::Expr,\n+                   expr: &hir::Expr,\n                    r: ty::Region,\n                    bk: ty::BorrowKind,\n                    cause: LoanCause) {\n@@ -363,37 +367,37 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.walk_expr(expr)\n     }\n \n-    fn select_from_expr(&mut self, expr: &ast::Expr) {\n+    fn select_from_expr(&mut self, expr: &hir::Expr) {\n         self.walk_expr(expr)\n     }\n \n-    pub fn walk_expr(&mut self, expr: &ast::Expr) {\n+    pub fn walk_expr(&mut self, expr: &hir::Expr) {\n         debug!(\"walk_expr(expr={:?})\", expr);\n \n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            ast::ExprParen(ref subexpr) => {\n+            hir::ExprParen(ref subexpr) => {\n                 self.walk_expr(&**subexpr)\n             }\n \n-            ast::ExprPath(..) => { }\n+            hir::ExprPath(..) => { }\n \n-            ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n+            hir::ExprUnary(hir::UnDeref, ref base) => {      // *base\n                 if !self.walk_overloaded_operator(expr, &**base, Vec::new(), PassArgs::ByRef) {\n                     self.select_from_expr(&**base);\n                 }\n             }\n \n-            ast::ExprField(ref base, _) => {         // base.f\n+            hir::ExprField(ref base, _) => {         // base.f\n                 self.select_from_expr(&**base);\n             }\n \n-            ast::ExprTupField(ref base, _) => {         // base.<n>\n+            hir::ExprTupField(ref base, _) => {         // base.<n>\n                 self.select_from_expr(&**base);\n             }\n \n-            ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n+            hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n                 if !self.walk_overloaded_operator(expr,\n                                                   &**lhs,\n                                                   vec![&**rhs],\n@@ -403,41 +407,37 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             }\n \n-            ast::ExprRange(ref start, ref end) => {\n+            hir::ExprRange(ref start, ref end) => {\n                 start.as_ref().map(|e| self.consume_expr(&**e));\n                 end.as_ref().map(|e| self.consume_expr(&**e));\n             }\n \n-            ast::ExprCall(ref callee, ref args) => {    // callee(args)\n+            hir::ExprCall(ref callee, ref args) => {    // callee(args)\n                 self.walk_callee(expr, &**callee);\n                 self.consume_exprs(args);\n             }\n \n-            ast::ExprMethodCall(_, _, ref args) => { // callee.m(args)\n+            hir::ExprMethodCall(_, _, ref args) => { // callee.m(args)\n                 self.consume_exprs(args);\n             }\n \n-            ast::ExprStruct(_, ref fields, ref opt_with) => {\n+            hir::ExprStruct(_, ref fields, ref opt_with) => {\n                 self.walk_struct_expr(expr, fields, opt_with);\n             }\n \n-            ast::ExprTup(ref exprs) => {\n+            hir::ExprTup(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n-            ast::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n+            hir::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n                 self.consume_expr(&**cond_expr);\n                 self.walk_block(&**then_blk);\n                 if let Some(ref else_expr) = *opt_else_expr {\n                     self.consume_expr(&**else_expr);\n                 }\n             }\n \n-            ast::ExprIfLet(..) => {\n-                self.tcx().sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n-            }\n-\n-            ast::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprMatch(ref discr, ref arms, _) => {\n                 let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n                 self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n@@ -449,11 +449,11 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             }\n \n-            ast::ExprVec(ref exprs) => {\n+            hir::ExprVec(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n-            ast::ExprAddrOf(m, ref base) => {   // &base\n+            hir::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n@@ -463,7 +463,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             }\n \n-            ast::ExprInlineAsm(ref ia) => {\n+            hir::ExprInlineAsm(ref ia) => {\n                 for &(_, ref input) in &ia.inputs {\n                     self.consume_expr(&**input);\n                 }\n@@ -474,29 +474,21 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             }\n \n-            ast::ExprBreak(..) |\n-            ast::ExprAgain(..) |\n-            ast::ExprLit(..) => {}\n+            hir::ExprBreak(..) |\n+            hir::ExprAgain(..) |\n+            hir::ExprLit(..) => {}\n \n-            ast::ExprLoop(ref blk, _) => {\n+            hir::ExprLoop(ref blk, _) => {\n                 self.walk_block(&**blk);\n             }\n \n-            ast::ExprWhile(ref cond_expr, ref blk, _) => {\n+            hir::ExprWhile(ref cond_expr, ref blk, _) => {\n                 self.consume_expr(&**cond_expr);\n                 self.walk_block(&**blk);\n             }\n \n-            ast::ExprWhileLet(..) => {\n-                self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n-            }\n-\n-            ast::ExprForLoop(..) => {\n-                self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n-            }\n-\n-            ast::ExprUnary(op, ref lhs) => {\n-                let pass_args = if ast_util::is_by_value_unop(op) {\n+            hir::ExprUnary(op, ref lhs) => {\n+                let pass_args = if ::rustc_front::util::is_by_value_unop(op) {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef\n@@ -507,8 +499,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             }\n \n-            ast::ExprBinary(op, ref lhs, ref rhs) => {\n-                let pass_args = if ast_util::is_by_value_binop(op.node) {\n+            hir::ExprBinary(op, ref lhs, ref rhs) => {\n+                let pass_args = if ::rustc_front::util::is_by_value_binop(op.node) {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef\n@@ -520,42 +512,42 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             }\n \n-            ast::ExprBlock(ref blk) => {\n+            hir::ExprBlock(ref blk) => {\n                 self.walk_block(&**blk);\n             }\n \n-            ast::ExprRet(ref opt_expr) => {\n+            hir::ExprRet(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n                     self.consume_expr(&**expr);\n                 }\n             }\n \n-            ast::ExprAssign(ref lhs, ref rhs) => {\n+            hir::ExprAssign(ref lhs, ref rhs) => {\n                 self.mutate_expr(expr, &**lhs, JustWrite);\n                 self.consume_expr(&**rhs);\n             }\n \n-            ast::ExprCast(ref base, _) => {\n+            hir::ExprCast(ref base, _) => {\n                 self.consume_expr(&**base);\n             }\n \n-            ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n+            hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n                 // This will have to change if/when we support\n                 // overloaded operators for `+=` and so forth.\n                 self.mutate_expr(expr, &**lhs, WriteAndRead);\n                 self.consume_expr(&**rhs);\n             }\n \n-            ast::ExprRepeat(ref base, ref count) => {\n+            hir::ExprRepeat(ref base, ref count) => {\n                 self.consume_expr(&**base);\n                 self.consume_expr(&**count);\n             }\n \n-            ast::ExprClosure(..) => {\n+            hir::ExprClosure(..) => {\n                 self.walk_captures(expr)\n             }\n \n-            ast::ExprBox(ref place, ref base) => {\n+            hir::ExprBox(ref place, ref base) => {\n                 match *place {\n                     Some(ref place) => self.consume_expr(&**place),\n                     None => {}\n@@ -567,16 +559,10 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         \"box with explicit place remains after expansion\");\n                 }\n             }\n-\n-            ast::ExprMac(..) => {\n-                self.tcx().sess.span_bug(\n-                    expr.span,\n-                    \"macro expression remains after expansion\");\n-            }\n         }\n     }\n \n-    fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n+    fn walk_callee(&mut self, call: &hir::Expr, callee: &hir::Expr) {\n         let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n@@ -617,33 +603,29 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         }\n     }\n \n-    fn walk_stmt(&mut self, stmt: &ast::Stmt) {\n+    fn walk_stmt(&mut self, stmt: &hir::Stmt) {\n         match stmt.node {\n-            ast::StmtDecl(ref decl, _) => {\n+            hir::StmtDecl(ref decl, _) => {\n                 match decl.node {\n-                    ast::DeclLocal(ref local) => {\n+                    hir::DeclLocal(ref local) => {\n                         self.walk_local(&**local);\n                     }\n \n-                    ast::DeclItem(_) => {\n+                    hir::DeclItem(_) => {\n                         // we don't visit nested items in this visitor,\n                         // only the fn body we were given.\n                     }\n                 }\n             }\n \n-            ast::StmtExpr(ref expr, _) |\n-            ast::StmtSemi(ref expr, _) => {\n+            hir::StmtExpr(ref expr, _) |\n+            hir::StmtSemi(ref expr, _) => {\n                 self.consume_expr(&**expr);\n             }\n-\n-            ast::StmtMac(..) => {\n-                self.tcx().sess.span_bug(stmt.span, \"unexpanded stmt macro\");\n-            }\n         }\n     }\n \n-    fn walk_local(&mut self, local: &ast::Local) {\n+    fn walk_local(&mut self, local: &hir::Local) {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n@@ -667,7 +649,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     /// Indicates that the value of `blk` will be consumed, meaning either copied or moved\n     /// depending on its type.\n-    fn walk_block(&mut self, blk: &ast::Block) {\n+    fn walk_block(&mut self, blk: &hir::Block) {\n         debug!(\"walk_block(blk.id={})\", blk.id);\n \n         for stmt in &blk.stmts {\n@@ -680,9 +662,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     }\n \n     fn walk_struct_expr(&mut self,\n-                        _expr: &ast::Expr,\n-                        fields: &Vec<ast::Field>,\n-                        opt_with: &Option<P<ast::Expr>>) {\n+                        _expr: &hir::Expr,\n+                        fields: &Vec<hir::Field>,\n+                        opt_with: &Option<P<hir::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n             self.consume_expr(&*field.expr);\n@@ -727,7 +709,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.walk_expr(with_expr);\n \n         fn contains_field_named(field: ty::FieldDef,\n-                                fields: &Vec<ast::Field>)\n+                                fields: &Vec<hir::Field>)\n                                 -> bool\n         {\n             fields.iter().any(\n@@ -738,7 +720,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     // Invoke the appropriate delegate calls for anything that gets\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n-    fn walk_adjustment(&mut self, expr: &ast::Expr) {\n+    fn walk_adjustment(&mut self, expr: &hir::Expr) {\n         let typer = self.typer;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n         let adj = typer.adjustments().get(&expr.id).map(|x| x.clone());\n@@ -764,7 +746,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     /// `(*x)` where `x` is of type `Rc<T>`, then this in fact is equivalent to `x.deref()`. Since\n     /// `deref()` is declared with `&self`, this is an autoref of `x`.\n     fn walk_autoderefs(&mut self,\n-                       expr: &ast::Expr,\n+                       expr: &hir::Expr,\n                        autoderefs: usize) {\n         debug!(\"walk_autoderefs expr={:?} autoderefs={}\", expr, autoderefs);\n \n@@ -795,7 +777,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     }\n \n     fn walk_autoderefref(&mut self,\n-                         expr: &ast::Expr,\n+                         expr: &hir::Expr,\n                          adj: &ty::AutoDerefRef<'tcx>) {\n         debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n                expr,\n@@ -825,7 +807,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     /// `cmt` for the rvalue that will be produced by introduced an\n     /// autoref.\n     fn walk_autoref(&mut self,\n-                    expr: &ast::Expr,\n+                    expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n                     opt_autoref: Option<ty::AutoRef<'tcx>>)\n                     -> mc::cmt<'tcx>\n@@ -890,9 +872,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     // recursively processing the input arguments, and thus the caller\n     // should not do so.\n     fn walk_overloaded_operator(&mut self,\n-                                expr: &ast::Expr,\n-                                receiver: &ast::Expr,\n-                                rhs: Vec<&ast::Expr>,\n+                                expr: &hir::Expr,\n+                                receiver: &hir::Expr,\n+                                rhs: Vec<&hir::Expr>,\n                                 pass_args: PassArgs)\n                                 -> bool\n     {\n@@ -927,15 +909,15 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         return true;\n     }\n \n-    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode {\n+    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {\n         let mut mode = Unknown;\n         for pat in &arm.pats {\n             self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n         }\n         mode\n     }\n \n-    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm, mode: MatchMode) {\n+    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm, mode: MatchMode) {\n         for pat in &arm.pats {\n             self.walk_pat(discr_cmt.clone(), &**pat, mode);\n         }\n@@ -949,7 +931,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     /// Walks an pat that occurs in isolation (i.e. top-level of fn\n     /// arg or let binding.  *Not* a match arm or nested pat.)\n-    fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &ast::Pat) {\n+    fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n         let mut mode = Unknown;\n         self.determine_pat_move_mode(cmt_discr.clone(), pat, &mut mode);\n         let mode = mode.match_mode();\n@@ -961,7 +943,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     /// copy, or borrow.\n     fn determine_pat_move_mode(&mut self,\n                                cmt_discr: mc::cmt<'tcx>,\n-                               pat: &ast::Pat,\n+                               pat: &hir::Pat,\n                                mode: &mut TrackMatchMode) {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n@@ -970,9 +952,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             let def_map = &self.tcx().def_map;\n             if pat_util::pat_is_binding(def_map, pat) {\n                 match pat.node {\n-                    ast::PatIdent(ast::BindByRef(_), _, _) =>\n+                    hir::PatIdent(hir::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n-                    ast::PatIdent(ast::BindByValue(_), _, _) => {\n+                    hir::PatIdent(hir::BindByValue(_), _, _) => {\n                         match copy_or_move(self.typer, &cmt_pat, PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n@@ -993,7 +975,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     /// also `walk_irrefutable_pat` for patterns that stand alone).\n     fn walk_pat(&mut self,\n                 cmt_discr: mc::cmt<'tcx>,\n-                pat: &ast::Pat,\n+                pat: &hir::Pat,\n                 match_mode: MatchMode) {\n         debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n@@ -1026,14 +1008,14 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n-                    ast::PatIdent(ast::BindByRef(m), _, _) => {\n+                    hir::PatIdent(hir::BindByRef(m), _, _) => {\n                         if let ty::TyRef(&r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, cmt_pat,\n                                             r, bk, RefBinding);\n                         }\n                     }\n-                    ast::PatIdent(ast::BindByValue(_), _, _) => {\n+                    hir::PatIdent(hir::BindByValue(_), _, _) => {\n                         let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n@@ -1046,7 +1028,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             } else {\n                 match pat.node {\n-                    ast::PatVec(_, Some(ref slice_pat), _) => {\n+                    hir::PatVec(_, Some(ref slice_pat), _) => {\n                         // The `slice_pat` here creates a slice into\n                         // the original vector.  This is effectively a\n                         // borrow of the elements of the vector being\n@@ -1094,8 +1076,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             let tcx = typer.tcx;\n \n             match pat.node {\n-                ast::PatEnum(_, _) | ast::PatQPath(..) |\n-                ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n+                hir::PatEnum(_, _) | hir::PatQPath(..) |\n+                hir::PatIdent(_, _, None) | hir::PatStruct(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a\n@@ -1169,15 +1151,15 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     }\n                 }\n \n-                ast::PatIdent(_, _, Some(_)) => {\n+                hir::PatIdent(_, _, Some(_)) => {\n                     // Do nothing; this is a binding (not a enum\n                     // variant or struct), and the cat_pattern call\n                     // will visit the substructure recursively.\n                 }\n \n-                ast::PatWild(_) | ast::PatTup(..) | ast::PatBox(..) |\n-                ast::PatRegion(..) | ast::PatLit(..) | ast::PatRange(..) |\n-                ast::PatVec(..) | ast::PatMac(..) => {\n+                hir::PatWild(_) | hir::PatTup(..) | hir::PatBox(..) |\n+                hir::PatRegion(..) | hir::PatLit(..) | hir::PatRange(..) |\n+                hir::PatVec(..) => {\n                     // Similarly, each of these cases does not\n                     // correspond to a enum variant or struct, so we\n                     // do not do any `matched_pat` calls for these\n@@ -1187,7 +1169,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         }));\n     }\n \n-    fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n+    fn walk_captures(&mut self, closure_expr: &hir::Expr) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {"}, {"sha": "2b81be19182e2d525e568e97d678c402481f448b", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -10,7 +10,7 @@\n \n use middle::def_id::DefId;\n use middle::ty::{self, Ty};\n-use syntax::ast;\n+use rustc_front::hir;\n \n use self::SimplifiedType::*;\n \n@@ -19,9 +19,9 @@ use self::SimplifiedType::*;\n pub enum SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,\n-    IntSimplifiedType(ast::IntTy),\n-    UintSimplifiedType(ast::UintTy),\n-    FloatSimplifiedType(ast::FloatTy),\n+    IntSimplifiedType(hir::IntTy),\n+    UintSimplifiedType(hir::UintTy),\n+    FloatSimplifiedType(hir::FloatTy),\n     EnumSimplifiedType(DefId),\n     StrSimplifiedType,\n     VecSimplifiedType,"}, {"sha": "00edd054aa5b6330af351aa9010d9d4dd8f0a082", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -48,8 +48,8 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::ty_relate::{self, Relate, RelateResult, TypeRelation};\n \n-use syntax::ast;\n use syntax::codemap::Span;\n+use rustc_front::hir;\n \n #[derive(Clone)]\n pub struct CombineFields<'a, 'tcx: 'a> {\n@@ -138,7 +138,7 @@ fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                  vid_is_expected: bool,\n                                  vid: ty::FloatVid,\n-                                 val: ast::FloatTy)\n+                                 val: hir::FloatTy)\n                                  -> RelateResult<'tcx, Ty<'tcx>>\n {\n     try!(infcx\n@@ -388,7 +388,7 @@ fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::Int\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n-                                 v: (ast::FloatTy, ast::FloatTy))\n+                                 v: (hir::FloatTy, hir::FloatTy))\n                                  -> ty::TypeError<'tcx>\n {\n     let (a, b) = v;"}, {"sha": "8197ccf4be7d3dcc4f43a59adfaa834a01f7c562", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 131, "deletions": 125, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -72,7 +72,11 @@ use super::region_inference::ProcessedErrors;\n use super::region_inference::SameRegions;\n \n use std::collections::HashSet;\n-use ast_map;\n+\n+use front::map as ast_map;\n+use rustc_front::hir;\n+use rustc_front::print::pprust;\n+\n use middle::def;\n use middle::infer;\n use middle::region;\n@@ -84,25 +88,23 @@ use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::ast_util::name_to_dummy_lifetime;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::codemap::{Pos, Span};\n+use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n-use syntax::print::pprust;\n use syntax::ptr::P;\n \n impl<'tcx> ty::ctxt<'tcx> {\n     pub fn note_and_explain_region(&self,\n                                    prefix: &str,\n                                    region: ty::Region,\n                                    suffix: &str) {\n-        fn item_scope_tag(item: &ast::Item) -> &'static str {\n+        fn item_scope_tag(item: &hir::Item) -> &'static str {\n             match item.node {\n-                ast::ItemImpl(..) => \"impl\",\n-                ast::ItemStruct(..) => \"struct\",\n-                ast::ItemEnum(..) => \"enum\",\n-                ast::ItemTrait(..) => \"trait\",\n-                ast::ItemFn(..) => \"function body\",\n+                hir::ItemImpl(..) => \"impl\",\n+                hir::ItemStruct(..) => \"struct\",\n+                hir::ItemEnum(..) => \"enum\",\n+                hir::ItemTrait(..) => \"trait\",\n+                hir::ItemFn(..) => \"function body\",\n                 _ => \"item\"\n             }\n         }\n@@ -128,12 +130,12 @@ impl<'tcx> ty::ctxt<'tcx> {\n                 let tag = match self.map.find(scope.node_id(&self.region_maps)) {\n                     Some(ast_map::NodeBlock(_)) => \"block\",\n                     Some(ast_map::NodeExpr(expr)) => match expr.node {\n-                        ast::ExprCall(..) => \"call\",\n-                        ast::ExprMethodCall(..) => \"method call\",\n-                        ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n-                        ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n-                        ast::ExprMatch(..) => \"match\",\n+                        hir::ExprCall(..) => \"call\",\n+                        hir::ExprMethodCall(..) => \"method call\",\n+                        hir::ExprMatch(_, _, hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                        hir::ExprMatch(_, _, hir::MatchSource::WhileLetDesugar) =>  \"while let\",\n+                        hir::ExprMatch(_, _, hir::MatchSource::ForLoopDesugar) =>  \"for\",\n+                        hir::ExprMatch(..) => \"match\",\n                         _ => \"expression\",\n                     },\n                     Some(ast_map::NodeStmt(_)) => \"statement\",\n@@ -275,12 +277,12 @@ trait ErrorReportingHelpers<'tcx> {\n                           origin: &SubregionOrigin<'tcx>);\n \n     fn give_expl_lifetime_param(&self,\n-                                decl: &ast::FnDecl,\n-                                unsafety: ast::Unsafety,\n-                                constness: ast::Constness,\n+                                decl: &hir::FnDecl,\n+                                unsafety: hir::Unsafety,\n+                                constness: hir::Constness,\n                                 ident: ast::Ident,\n-                                opt_explicit_self: Option<&ast::ExplicitSelf_>,\n-                                generics: &ast::Generics,\n+                                opt_explicit_self: Option<&hir::ExplicitSelf_>,\n+                                generics: &hir::Generics,\n                                 span: Span);\n }\n \n@@ -432,7 +434,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             match parent_node {\n                 Some(node) => match node {\n                     ast_map::NodeItem(item) => match item.node {\n-                        ast::ItemFn(..) => {\n+                        hir::ItemFn(..) => {\n                             Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n                         },\n                         _ => None\n@@ -944,7 +946,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n-                        ast::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n+                        hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n                             Some((fn_decl, gen, unsafety, constness,\n                                   item.ident, None, item.span))\n                         },\n@@ -953,7 +955,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n                 ast_map::NodeImplItem(item) => {\n                     match item.node {\n-                        ast::MethodImplItem(ref sig, _) => {\n+                        hir::MethodImplItem(ref sig, _) => {\n                             Some((&sig.decl,\n                                   &sig.generics,\n                                   sig.unsafety,\n@@ -962,13 +964,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n-                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\"),\n                         _ => None,\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n                     match item.node {\n-                        ast::MethodTraitItem(ref sig, Some(_)) => {\n+                        hir::MethodTraitItem(ref sig, Some(_)) => {\n                             Some((&sig.decl,\n                                   &sig.generics,\n                                   sig.unsafety,\n@@ -995,7 +996,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n }\n \n struct RebuildPathInfo<'a> {\n-    path: &'a ast::Path,\n+    path: &'a hir::Path,\n     // indexes to insert lifetime on path.lifetimes\n     indexes: Vec<u32>,\n     // number of lifetimes we expect to see on the type referred by `path`\n@@ -1007,9 +1008,9 @@ struct RebuildPathInfo<'a> {\n \n struct Rebuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    fn_decl: &'a ast::FnDecl,\n-    expl_self_opt: Option<&'a ast::ExplicitSelf_>,\n-    generics: &'a ast::Generics,\n+    fn_decl: &'a hir::FnDecl,\n+    expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n+    generics: &'a hir::Generics,\n     same_regions: &'a [SameRegions],\n     life_giver: &'a LifeGiver,\n     cur_anon: Cell<u32>,\n@@ -1023,9 +1024,9 @@ enum FreshOrKept {\n \n impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n-           fn_decl: &'a ast::FnDecl,\n-           expl_self_opt: Option<&'a ast::ExplicitSelf_>,\n-           generics: &'a ast::Generics,\n+           fn_decl: &'a hir::FnDecl,\n+           expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n+           generics: &'a hir::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n            -> Rebuilder<'a, 'tcx> {\n@@ -1042,7 +1043,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild(&self)\n-               -> (ast::FnDecl, Option<ast::ExplicitSelf_>, ast::Generics) {\n+               -> (hir::FnDecl, Option<hir::ExplicitSelf_>, hir::Generics) {\n         let mut expl_self_opt = self.expl_self_opt.cloned();\n         let mut inputs = self.fn_decl.inputs.clone();\n         let mut output = self.fn_decl.output.clone();\n@@ -1075,7 +1076,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                              &all_region_names,\n                                              ty_params,\n                                              where_clause);\n-        let new_fn_decl = ast::FnDecl {\n+        let new_fn_decl = hir::FnDecl {\n             inputs: inputs,\n             output: output,\n             variadic: self.fn_decl.variadic\n@@ -1085,7 +1086,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn pick_lifetime(&self,\n                      region_names: &HashSet<ast::Name>)\n-                     -> (ast::Lifetime, FreshOrKept) {\n+                     -> (hir::Lifetime, FreshOrKept) {\n         if !region_names.is_empty() {\n             // It's not necessary to convert the set of region names to a\n             // vector of string and then sort them. However, it makes the\n@@ -1158,15 +1159,15 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_ty_params(&self,\n-                         ty_params: OwnedSlice<ast::TyParam>,\n-                         lifetime: ast::Lifetime,\n+                         ty_params: OwnedSlice<hir::TyParam>,\n+                         lifetime: hir::Lifetime,\n                          region_names: &HashSet<ast::Name>)\n-                         -> OwnedSlice<ast::TyParam> {\n+                         -> OwnedSlice<hir::TyParam> {\n         ty_params.map(|ty_param| {\n             let bounds = self.rebuild_ty_param_bounds(ty_param.bounds.clone(),\n                                                       lifetime,\n                                                       region_names);\n-            ast::TyParam {\n+            hir::TyParam {\n                 ident: ty_param.ident,\n                 id: ty_param.id,\n                 bounds: bounds,\n@@ -1177,19 +1178,19 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_ty_param_bounds(&self,\n-                               ty_param_bounds: OwnedSlice<ast::TyParamBound>,\n-                               lifetime: ast::Lifetime,\n+                               ty_param_bounds: OwnedSlice<hir::TyParamBound>,\n+                               lifetime: hir::Lifetime,\n                                region_names: &HashSet<ast::Name>)\n-                               -> OwnedSlice<ast::TyParamBound> {\n+                               -> OwnedSlice<hir::TyParamBound> {\n         ty_param_bounds.map(|tpb| {\n             match tpb {\n-                &ast::RegionTyParamBound(lt) => {\n+                &hir::RegionTyParamBound(lt) => {\n                     // FIXME -- it's unclear whether I'm supposed to\n                     // substitute lifetime here. I suspect we need to\n                     // be passing down a map.\n-                    ast::RegionTyParamBound(lt)\n+                    hir::RegionTyParamBound(lt)\n                 }\n-                &ast::TraitTyParamBound(ref poly_tr, modifier) => {\n+                &hir::TraitTyParamBound(ref poly_tr, modifier) => {\n                     let tr = &poly_tr.trait_ref;\n                     let last_seg = tr.path.segments.last().unwrap();\n                     let mut insert = Vec::new();\n@@ -1207,9 +1208,9 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         region_names: region_names\n                     };\n                     let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                    ast::TraitTyParamBound(ast::PolyTraitRef {\n+                    hir::TraitTyParamBound(hir::PolyTraitRef {\n                         bound_lifetimes: poly_tr.bound_lifetimes.clone(),\n-                        trait_ref: ast::TraitRef {\n+                        trait_ref: hir::TraitRef {\n                             path: new_path,\n                             ref_id: tr.ref_id,\n                         },\n@@ -1221,23 +1222,23 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_expl_self(&self,\n-                         expl_self_opt: Option<ast::ExplicitSelf_>,\n-                         lifetime: ast::Lifetime,\n+                         expl_self_opt: Option<hir::ExplicitSelf_>,\n+                         lifetime: hir::Lifetime,\n                          anon_nums: &HashSet<u32>,\n                          region_names: &HashSet<ast::Name>)\n-                         -> Option<ast::ExplicitSelf_> {\n+                         -> Option<hir::ExplicitSelf_> {\n         match expl_self_opt {\n             Some(ref expl_self) => match *expl_self {\n-                ast::SelfRegion(lt_opt, muta, id) => match lt_opt {\n+                hir::SelfRegion(lt_opt, muta, id) => match lt_opt {\n                     Some(lt) => if region_names.contains(&lt.name) {\n-                        return Some(ast::SelfRegion(Some(lifetime), muta, id));\n+                        return Some(hir::SelfRegion(Some(lifetime), muta, id));\n                     },\n                     None => {\n                         let anon = self.cur_anon.get();\n                         self.inc_and_offset_cur_anon(1);\n                         if anon_nums.contains(&anon) {\n                             self.track_anon(anon);\n-                            return Some(ast::SelfRegion(Some(lifetime), muta, id));\n+                            return Some(hir::SelfRegion(Some(lifetime), muta, id));\n                         }\n                     }\n                 },\n@@ -1249,16 +1250,16 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_generics(&self,\n-                        generics: &ast::Generics,\n-                        add: &Vec<ast::Lifetime>,\n+                        generics: &hir::Generics,\n+                        add: &Vec<hir::Lifetime>,\n                         keep: &HashSet<ast::Name>,\n                         remove: &HashSet<ast::Name>,\n-                        ty_params: OwnedSlice<ast::TyParam>,\n-                        where_clause: ast::WhereClause)\n-                        -> ast::Generics {\n+                        ty_params: OwnedSlice<hir::TyParam>,\n+                        where_clause: hir::WhereClause)\n+                        -> hir::Generics {\n         let mut lifetimes = Vec::new();\n         for lt in add {\n-            lifetimes.push(ast::LifetimeDef { lifetime: *lt,\n+            lifetimes.push(hir::LifetimeDef { lifetime: *lt,\n                                               bounds: Vec::new() });\n         }\n         for lt in &generics.lifetimes {\n@@ -1267,24 +1268,24 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 lifetimes.push((*lt).clone());\n             }\n         }\n-        ast::Generics {\n+        hir::Generics {\n             lifetimes: lifetimes,\n             ty_params: ty_params,\n             where_clause: where_clause,\n         }\n     }\n \n     fn rebuild_args_ty(&self,\n-                       inputs: &[ast::Arg],\n-                       lifetime: ast::Lifetime,\n+                       inputs: &[hir::Arg],\n+                       lifetime: hir::Lifetime,\n                        anon_nums: &HashSet<u32>,\n                        region_names: &HashSet<ast::Name>)\n-                       -> Vec<ast::Arg> {\n+                       -> Vec<hir::Arg> {\n         let mut new_inputs = Vec::new();\n         for arg in inputs {\n             let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n                                                        anon_nums, region_names);\n-            let possibly_new_arg = ast::Arg {\n+            let possibly_new_arg = hir::Arg {\n                 ty: new_ty,\n                 pat: arg.pat.clone(),\n                 id: arg.id\n@@ -1294,31 +1295,31 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         new_inputs\n     }\n \n-    fn rebuild_output(&self, ty: &ast::FunctionRetTy,\n-                      lifetime: ast::Lifetime,\n+    fn rebuild_output(&self, ty: &hir::FunctionRetTy,\n+                      lifetime: hir::Lifetime,\n                       anon_nums: &HashSet<u32>,\n-                      region_names: &HashSet<ast::Name>) -> ast::FunctionRetTy {\n+                      region_names: &HashSet<ast::Name>) -> hir::FunctionRetTy {\n         match *ty {\n-            ast::Return(ref ret_ty) => ast::Return(\n+            hir::Return(ref ret_ty) => hir::Return(\n                 self.rebuild_arg_ty_or_output(&**ret_ty, lifetime, anon_nums, region_names)\n             ),\n-            ast::DefaultReturn(span) => ast::DefaultReturn(span),\n-            ast::NoReturn(span) => ast::NoReturn(span)\n+            hir::DefaultReturn(span) => hir::DefaultReturn(span),\n+            hir::NoReturn(span) => hir::NoReturn(span)\n         }\n     }\n \n     fn rebuild_arg_ty_or_output(&self,\n-                                ty: &ast::Ty,\n-                                lifetime: ast::Lifetime,\n+                                ty: &hir::Ty,\n+                                lifetime: hir::Lifetime,\n                                 anon_nums: &HashSet<u32>,\n                                 region_names: &HashSet<ast::Name>)\n-                                -> P<ast::Ty> {\n+                                -> P<hir::Ty> {\n         let mut new_ty = P(ty.clone());\n         let mut ty_queue = vec!(ty);\n         while !ty_queue.is_empty() {\n             let cur_ty = ty_queue.remove(0);\n             match cur_ty.node {\n-                ast::TyRptr(lt_opt, ref mut_ty) => {\n+                hir::TyRptr(lt_opt, ref mut_ty) => {\n                     let rebuild = match lt_opt {\n                         Some(lt) => region_names.contains(&lt.name),\n                         None => {\n@@ -1332,16 +1333,16 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         }\n                     };\n                     if rebuild {\n-                        let to = ast::Ty {\n+                        let to = hir::Ty {\n                             id: cur_ty.id,\n-                            node: ast::TyRptr(Some(lifetime), mut_ty.clone()),\n+                            node: hir::TyRptr(Some(lifetime), mut_ty.clone()),\n                             span: cur_ty.span\n                         };\n                         new_ty = self.rebuild_ty(new_ty, P(to));\n                     }\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n-                ast::TyPath(ref maybe_qself, ref path) => {\n+                hir::TyPath(ref maybe_qself, ref path) => {\n                     let a_def = match self.tcx.def_map.borrow().get(&cur_ty.id) {\n                         None => {\n                             self.tcx\n@@ -1386,15 +1387,15 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             };\n                             let new_path = self.rebuild_path(rebuild_info, lifetime);\n                             let qself = maybe_qself.as_ref().map(|qself| {\n-                                ast::QSelf {\n+                                hir::QSelf {\n                                     ty: self.rebuild_arg_ty_or_output(&qself.ty, lifetime,\n                                                                       anon_nums, region_names),\n                                     position: qself.position\n                                 }\n                             });\n-                            let to = ast::Ty {\n+                            let to = hir::Ty {\n                                 id: cur_ty.id,\n-                                node: ast::TyPath(qself, new_path),\n+                                node: hir::TyPath(qself, new_path),\n                                 span: cur_ty.span\n                             };\n                             new_ty = self.rebuild_ty(new_ty, P(to));\n@@ -1404,56 +1405,56 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n                 }\n \n-                ast::TyPtr(ref mut_ty) => {\n+                hir::TyPtr(ref mut_ty) => {\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n-                ast::TyVec(ref ty) |\n-                ast::TyFixedLengthVec(ref ty, _) => {\n+                hir::TyVec(ref ty) |\n+                hir::TyFixedLengthVec(ref ty, _) => {\n                     ty_queue.push(&**ty);\n                 }\n-                ast::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n+                hir::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n                 _ => {}\n             }\n         }\n         new_ty\n     }\n \n     fn rebuild_ty(&self,\n-                  from: P<ast::Ty>,\n-                  to: P<ast::Ty>)\n-                  -> P<ast::Ty> {\n+                  from: P<hir::Ty>,\n+                  to: P<hir::Ty>)\n+                  -> P<hir::Ty> {\n \n-        fn build_to(from: P<ast::Ty>,\n-                    to: &mut Option<P<ast::Ty>>)\n-                    -> P<ast::Ty> {\n+        fn build_to(from: P<hir::Ty>,\n+                    to: &mut Option<P<hir::Ty>>)\n+                    -> P<hir::Ty> {\n             if Some(from.id) == to.as_ref().map(|ty| ty.id) {\n                 return to.take().expect(\"`to` type found more than once during rebuild\");\n             }\n-            from.map(|ast::Ty {id, node, span}| {\n+            from.map(|hir::Ty {id, node, span}| {\n                 let new_node = match node {\n-                    ast::TyRptr(lifetime, mut_ty) => {\n-                        ast::TyRptr(lifetime, ast::MutTy {\n+                    hir::TyRptr(lifetime, mut_ty) => {\n+                        hir::TyRptr(lifetime, hir::MutTy {\n                             mutbl: mut_ty.mutbl,\n                             ty: build_to(mut_ty.ty, to),\n                         })\n                     }\n-                    ast::TyPtr(mut_ty) => {\n-                        ast::TyPtr(ast::MutTy {\n+                    hir::TyPtr(mut_ty) => {\n+                        hir::TyPtr(hir::MutTy {\n                             mutbl: mut_ty.mutbl,\n                             ty: build_to(mut_ty.ty, to),\n                         })\n                     }\n-                    ast::TyVec(ty) => ast::TyVec(build_to(ty, to)),\n-                    ast::TyFixedLengthVec(ty, e) => {\n-                        ast::TyFixedLengthVec(build_to(ty, to), e)\n+                    hir::TyVec(ty) => hir::TyVec(build_to(ty, to)),\n+                    hir::TyFixedLengthVec(ty, e) => {\n+                        hir::TyFixedLengthVec(build_to(ty, to), e)\n                     }\n-                    ast::TyTup(tys) => {\n-                        ast::TyTup(tys.into_iter().map(|ty| build_to(ty, to)).collect())\n+                    hir::TyTup(tys) => {\n+                        hir::TyTup(tys.into_iter().map(|ty| build_to(ty, to)).collect())\n                     }\n-                    ast::TyParen(typ) => ast::TyParen(build_to(typ, to)),\n+                    hir::TyParen(typ) => hir::TyParen(build_to(typ, to)),\n                     other => other\n                 };\n-                ast::Ty { id: id, node: new_node, span: span }\n+                hir::Ty { id: id, node: new_node, span: span }\n             })\n         }\n \n@@ -1462,8 +1463,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn rebuild_path(&self,\n                     rebuild_info: RebuildPathInfo,\n-                    lifetime: ast::Lifetime)\n-                    -> ast::Path\n+                    lifetime: hir::Lifetime)\n+                    -> hir::Path\n     {\n         let RebuildPathInfo {\n             path,\n@@ -1475,11 +1476,11 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n         let last_seg = path.segments.last().unwrap();\n         let new_parameters = match last_seg.parameters {\n-            ast::ParenthesizedParameters(..) => {\n+            hir::ParenthesizedParameters(..) => {\n                 last_seg.parameters.clone()\n             }\n \n-            ast::AngleBracketedParameters(ref data) => {\n+            hir::AngleBracketedParameters(ref data) => {\n                 let mut new_lts = Vec::new();\n                 if data.lifetimes.is_empty() {\n                     // traverse once to see if there's a need to insert lifetime\n@@ -1508,7 +1509,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n                 });\n                 let new_bindings = data.bindings.map(|b| {\n-                    P(ast::TypeBinding {\n+                    P(hir::TypeBinding {\n                         id: b.id,\n                         ident: b.ident,\n                         ty: self.rebuild_arg_ty_or_output(&*b.ty,\n@@ -1518,21 +1519,21 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         span: b.span\n                     })\n                 });\n-                ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n                     lifetimes: new_lts,\n                     types: new_types,\n                     bindings: new_bindings,\n                })\n             }\n         };\n-        let new_seg = ast::PathSegment {\n+        let new_seg = hir::PathSegment {\n             identifier: last_seg.identifier,\n             parameters: new_parameters\n         };\n         let mut new_segs = Vec::new();\n         new_segs.push_all(path.segments.split_last().unwrap().1);\n         new_segs.push(new_seg);\n-        ast::Path {\n+        hir::Path {\n             span: path.span,\n             global: path.global,\n             segments: new_segs\n@@ -1542,12 +1543,12 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n-                                decl: &ast::FnDecl,\n-                                unsafety: ast::Unsafety,\n-                                constness: ast::Constness,\n+                                decl: &hir::FnDecl,\n+                                unsafety: hir::Unsafety,\n+                                constness: hir::Constness,\n                                 ident: ast::Ident,\n-                                opt_explicit_self: Option<&ast::ExplicitSelf_>,\n-                                generics: &ast::Generics,\n+                                opt_explicit_self: Option<&hir::ExplicitSelf_>,\n+                                generics: &hir::Generics,\n                                 span: Span) {\n         let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, ident,\n                                                  opt_explicit_self, generics);\n@@ -1832,25 +1833,24 @@ impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n \n fn lifetimes_in_scope(tcx: &ty::ctxt,\n                       scope_id: ast::NodeId)\n-                      -> Vec<ast::LifetimeDef> {\n+                      -> Vec<hir::LifetimeDef> {\n     let mut taken = Vec::new();\n     let parent = tcx.map.get_parent(scope_id);\n     let method_id_opt = match tcx.map.find(parent) {\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n-                ast::ItemFn(_, _, _, _, ref gen, _) => {\n+                hir::ItemFn(_, _, _, _, ref gen, _) => {\n                     taken.push_all(&gen.lifetimes);\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match ii.node {\n-                    ast::MethodImplItem(ref sig, _) => {\n+                    hir::MethodImplItem(ref sig, _) => {\n                         taken.push_all(&sig.generics.lifetimes);\n                         Some(ii.id)\n                     }\n-                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\"),\n                     _ => None,\n                 }\n             }\n@@ -1864,7 +1864,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         match tcx.map.find(parent) {\n             Some(node) => match node {\n                 ast_map::NodeItem(item) => match item.node {\n-                    ast::ItemImpl(_, _, ref gen, _, _, _) => {\n+                    hir::ItemImpl(_, _, ref gen, _, _, _) => {\n                         taken.push_all(&gen.lifetimes);\n                     }\n                     _ => ()\n@@ -1881,11 +1881,11 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n struct LifeGiver {\n     taken: HashSet<String>,\n     counter: Cell<usize>,\n-    generated: RefCell<Vec<ast::Lifetime>>,\n+    generated: RefCell<Vec<hir::Lifetime>>,\n }\n \n impl LifeGiver {\n-    fn with_taken(taken: &[ast::LifetimeDef]) -> LifeGiver {\n+    fn with_taken(taken: &[hir::LifetimeDef]) -> LifeGiver {\n         let mut taken_ = HashSet::new();\n         for lt in taken {\n             let lt_name = lt.lifetime.name.to_string();\n@@ -1903,7 +1903,7 @@ impl LifeGiver {\n         self.counter.set(c+1);\n     }\n \n-    fn give_lifetime(&self) -> ast::Lifetime {\n+    fn give_lifetime(&self) -> hir::Lifetime {\n         let lifetime;\n         loop {\n             let mut s = String::from(\"'\");\n@@ -1931,7 +1931,13 @@ impl LifeGiver {\n         }\n     }\n \n-    fn get_generated_lifetimes(&self) -> Vec<ast::Lifetime> {\n+    fn get_generated_lifetimes(&self) -> Vec<hir::Lifetime> {\n         self.generated.borrow().clone()\n     }\n }\n+\n+fn name_to_dummy_lifetime(name: ast::Name) -> hir::Lifetime {\n+    hir::Lifetime { id: ast::DUMMY_NODE_ID,\n+                    span: codemap::DUMMY_SP,\n+                    name: name }\n+}"}, {"sha": "4ef96c0f3b45024bf2071790cb409ab3a2815593", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -20,6 +20,7 @@ pub use self::freshen::TypeFreshener;\n pub use self::region_inference::{GenericKind, VerifyBound};\n \n use middle::def_id::DefId;\n+use rustc_front::hir;\n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n@@ -1147,7 +1148,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Apply `adjustment` to the type of `expr`\n     pub fn adjust_expr_ty(&self,\n-                          expr: &ast::Expr,\n+                          expr: &hir::Expr,\n                           adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n                           -> Ty<'tcx>\n     {\n@@ -1179,7 +1180,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty(&self, ex: &hir::Expr) -> Ty<'tcx> {\n         match self.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n@@ -1446,7 +1447,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n-    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n         let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n         self.resolve_type_vars_or_error(&ty)\n     }"}, {"sha": "6bb46ac787073d6cc19858efabfd87c081b83846", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -10,7 +10,7 @@\n \n use middle::ty::{self, IntVarValue, Ty};\n use rustc_data_structures::unify::UnifyKey;\n-use syntax::ast;\n+use rustc_front::hir as ast;\n \n pub trait ToType<'tcx> {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;"}, {"sha": "c042aea829b98ce92618eec9a29dfb4bf7fb71d8", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -19,8 +19,8 @@ use std::fmt;\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::visit::{FnKind, Visitor};\n-use syntax::visit;\n+use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::hir;\n \n pub fn check_crate(tcx: &ctxt) {\n     let mut visitor = IntrinsicCheckingVisitor {\n@@ -216,8 +216,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n@@ -232,8 +232,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n \n     }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n-        if let ast::ExprPath(..) = expr.node {\n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n+        if let hir::ExprPath(..) = expr.node {\n             match self.tcx.resolve_expr(expr) {\n                 DefFn(did, _) if self.def_id_is_transmute(did) => {\n                     let typ = self.tcx.node_id_to_type(expr.id);"}, {"sha": "a34571e4acac77097210f33670bdd6fc427b4a8d", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -28,12 +28,12 @@ use middle::ty;\n use middle::weak_lang_items;\n use util::nodemap::FnvHashMap;\n \n-use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n+use rustc_front::attr::AttrMetaMethods;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use rustc_front::visit::Visitor;\n+use rustc_front::visit;\n+use rustc_front::hir;\n \n use std::iter::Enumerate;\n use std::slice;\n@@ -152,7 +152,7 @@ struct LanguageItemCollector<'a> {\n }\n \n impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         if let Some(value) = extract(&item.attrs) {\n             let item_index = self.item_refs.get(&value[..]).cloned();\n \n@@ -195,7 +195,7 @@ impl<'a> LanguageItemCollector<'a> {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {\n+    pub fn collect_local_language_items(&mut self, krate: &hir::Crate) {\n         visit::walk_crate(self, krate);\n     }\n \n@@ -210,13 +210,13 @@ impl<'a> LanguageItemCollector<'a> {\n         })\n     }\n \n-    pub fn collect(&mut self, krate: &ast::Crate) {\n+    pub fn collect(&mut self, krate: &hir::Crate) {\n         self.collect_local_language_items(krate);\n         self.collect_external_language_items();\n     }\n }\n \n-pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+pub fn extract(attrs: &[hir::Attribute]) -> Option<InternedString> {\n     for attribute in attrs {\n         match attribute.value_str() {\n             Some(ref value) if attribute.check_name(\"lang\") => {\n@@ -229,7 +229,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     return None;\n }\n \n-pub fn collect_language_items(krate: &ast::Crate,\n+pub fn collect_language_items(krate: &hir::Crate,\n                               session: &Session) -> LanguageItems {\n     let mut collector = LanguageItemCollector::new(session);\n     collector.collect(krate);"}, {"sha": "476df77e45b9c884395b1744a76dc86b44edeab0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 104, "deletions": 140, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -119,13 +119,15 @@ use std::{fmt, usize};\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n-use syntax::ast::{self, NodeId, Expr};\n+use syntax::ast::{self, NodeId};\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::special_idents;\n-use syntax::print::pprust::{expr_to_string, block_to_string};\n use syntax::ptr::P;\n-use syntax::ast_util;\n-use syntax::visit::{self, Visitor, FnKind};\n+\n+use rustc_front::hir::Expr;\n+use rustc_front::hir;\n+use rustc_front::print::pprust::{expr_to_string, block_to_string};\n+use rustc_front::visit::{self, Visitor, FnKind};\n \n /// For use with `propagate_through_loop`.\n enum LoopKind<'a> {\n@@ -180,13 +182,13 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n-    fn visit_local(&mut self, l: &ast::Local) { visit_local(self, l); }\n+    fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }\n     fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n-    fn visit_arm(&mut self, a: &ast::Arm) { visit_arm(self, a); }\n+    fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n@@ -348,25 +350,25 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &ast::Local) {\n+    fn visit_local(&mut self, l: &hir::Local) {\n         check_local(self, l);\n     }\n     fn visit_expr(&mut self, ex: &Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &ast::Arm) {\n+    fn visit_arm(&mut self, a: &hir::Arm) {\n         check_arm(self, a);\n     }\n }\n \n fn visit_fn(ir: &mut IrMaps,\n             fk: FnKind,\n-            decl: &ast::FnDecl,\n-            body: &ast::Block,\n+            decl: &hir::FnDecl,\n+            body: &hir::Block,\n             sp: Span,\n             id: ast::NodeId) {\n     debug!(\"visit_fn\");\n@@ -411,7 +413,7 @@ fn visit_fn(ir: &mut IrMaps,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n+fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n     pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node.name;\n@@ -424,7 +426,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n     visit::walk_local(ir, local);\n }\n \n-fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n+fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     for pat in &arm.pats {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n@@ -443,15 +445,15 @@ fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      ast::ExprPath(..) => {\n+      hir::ExprPath(..) => {\n         let def = ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def();\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         visit::walk_expr(ir, expr);\n       }\n-      ast::ExprClosure(..) => {\n+      hir::ExprClosure(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -476,34 +478,25 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n \n       // live nodes required for interesting control flow:\n-      ast::ExprIf(..) | ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) => {\n+      hir::ExprIf(..) | hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n-      ast::ExprIfLet(..) => {\n-          ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n-      }\n-      ast::ExprWhileLet(..) => {\n-          ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n-      }\n-      ast::ExprForLoop(..) => {\n-          ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n-      }\n-      ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op.node) => {\n+      hir::ExprBinary(op, _, _) if ::rustc_front::util::lazy_binop(op.node) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n \n       // otherwise, live nodes are not required:\n-      ast::ExprIndex(..) | ast::ExprField(..) | ast::ExprTupField(..) |\n-      ast::ExprVec(..) | ast::ExprCall(..) | ast::ExprMethodCall(..) |\n-      ast::ExprTup(..) | ast::ExprBinary(..) | ast::ExprAddrOf(..) |\n-      ast::ExprCast(..) | ast::ExprUnary(..) | ast::ExprBreak(_) |\n-      ast::ExprAgain(_) | ast::ExprLit(_) | ast::ExprRet(..) |\n-      ast::ExprBlock(..) | ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n-      ast::ExprMac(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n-      ast::ExprParen(..) | ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n-      ast::ExprRange(..) => {\n+      hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n+      hir::ExprVec(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n+      hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n+      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(_) |\n+      hir::ExprAgain(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n+      hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n+      hir::ExprStruct(..) | hir::ExprRepeat(..) |\n+      hir::ExprParen(..) | hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n+      hir::ExprRange(..) => {\n           visit::walk_expr(ir, expr);\n       }\n     }\n@@ -592,7 +585,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.ir.variable(node_id, span)\n     }\n \n-    fn pat_bindings<F>(&mut self, pat: &ast::Pat, mut f: F) where\n+    fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n     {\n         pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n@@ -602,7 +595,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         })\n     }\n \n-    fn arm_pats_bindings<F>(&mut self, pat: Option<&ast::Pat>, f: F) where\n+    fn arm_pats_bindings<F>(&mut self, pat: Option<&hir::Pat>, f: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n     {\n         match pat {\n@@ -613,12 +606,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: &ast::Pat, succ: LiveNode)\n+    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, succ: LiveNode)\n                               -> LiveNode {\n         self.define_bindings_in_arm_pats(Some(pat), succ)\n     }\n \n-    fn define_bindings_in_arm_pats(&mut self, pat: Option<&ast::Pat>, succ: LiveNode)\n+    fn define_bindings_in_arm_pats(&mut self, pat: Option<&hir::Pat>, succ: LiveNode)\n                                    -> LiveNode {\n         let mut succ = succ;\n         self.arm_pats_bindings(pat, |this, ln, var, _sp, _id| {\n@@ -830,7 +823,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // _______________________________________________________________________\n \n-    fn compute(&mut self, decl: &ast::FnDecl, body: &ast::Block) -> LiveNode {\n+    fn compute(&mut self, decl: &hir::FnDecl, body: &hir::Block) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -855,7 +848,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&mut self, _: &ast::FnDecl, blk: &ast::Block)\n+    fn propagate_through_fn_block(&mut self, _: &hir::FnDecl, blk: &hir::Block)\n                                   -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -869,42 +862,38 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.propagate_through_block(blk, s.fallthrough_ln)\n     }\n \n-    fn propagate_through_block(&mut self, blk: &ast::Block, succ: LiveNode)\n+    fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(&**stmt, succ)\n         })\n     }\n \n-    fn propagate_through_stmt(&mut self, stmt: &ast::Stmt, succ: LiveNode)\n+    fn propagate_through_stmt(&mut self, stmt: &hir::Stmt, succ: LiveNode)\n                               -> LiveNode {\n         match stmt.node {\n-            ast::StmtDecl(ref decl, _) => {\n+            hir::StmtDecl(ref decl, _) => {\n                 self.propagate_through_decl(&**decl, succ)\n             }\n \n-            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n+            hir::StmtExpr(ref expr, _) | hir::StmtSemi(ref expr, _) => {\n                 self.propagate_through_expr(&**expr, succ)\n             }\n-\n-            ast::StmtMac(..) => {\n-                self.ir.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n-            }\n         }\n     }\n \n-    fn propagate_through_decl(&mut self, decl: &ast::Decl, succ: LiveNode)\n+    fn propagate_through_decl(&mut self, decl: &hir::Decl, succ: LiveNode)\n                               -> LiveNode {\n         match decl.node {\n-            ast::DeclLocal(ref local) => {\n+            hir::DeclLocal(ref local) => {\n                 self.propagate_through_local(&**local, succ)\n             }\n-            ast::DeclItem(_) => succ,\n+            hir::DeclItem(_) => succ,\n         }\n     }\n \n-    fn propagate_through_local(&mut self, local: &ast::Local, succ: LiveNode)\n+    fn propagate_through_local(&mut self, local: &hir::Local, succ: LiveNode)\n                                -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n@@ -945,19 +934,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          ast::ExprPath(..) => {\n+          hir::ExprPath(..) => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          ast::ExprField(ref e, _) => {\n+          hir::ExprField(ref e, _) => {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ast::ExprTupField(ref e, _) => {\n+          hir::ExprTupField(ref e, _) => {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ast::ExprClosure(_, _, ref blk) => {\n+          hir::ExprClosure(_, _, ref blk) => {\n               debug!(\"{} is an ExprClosure\",\n                      expr_to_string(expr));\n \n@@ -985,7 +974,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               })\n           }\n \n-          ast::ExprIf(ref cond, ref then, ref els) => {\n+          hir::ExprIf(ref cond, ref then, ref els) => {\n             //\n             //     (cond)\n             //       |\n@@ -1007,29 +996,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**cond, ln)\n           }\n \n-          ast::ExprIfLet(..) => {\n-              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n-          }\n-\n-          ast::ExprWhile(ref cond, ref blk, _) => {\n+          hir::ExprWhile(ref cond, ref blk, _) => {\n             self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n           }\n \n-          ast::ExprWhileLet(..) => {\n-              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n-          }\n-\n-          ast::ExprForLoop(..) => {\n-              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n-          }\n-\n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          ast::ExprLoop(ref blk, _) => {\n+          hir::ExprLoop(ref blk, _) => {\n             self.propagate_through_loop(expr, LoopLoop, &**blk, succ)\n           }\n \n-          ast::ExprMatch(ref e, ref arms, _) => {\n+          hir::ExprMatch(ref e, ref arms, _) => {\n             //\n             //      (e)\n             //       |\n@@ -1064,13 +1041,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**e, ln)\n           }\n \n-          ast::ExprRet(ref o_e) => {\n+          hir::ExprRet(ref o_e) => {\n             // ignore succ and subst exit_ln:\n             let exit_ln = self.s.exit_ln;\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          ast::ExprBreak(opt_label) => {\n+          hir::ExprBreak(opt_label) => {\n               // Find which label this break jumps to\n               let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n@@ -1084,7 +1061,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          ast::ExprAgain(opt_label) => {\n+          hir::ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n               let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n@@ -1098,15 +1075,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          ast::ExprAssign(ref l, ref r) => {\n+          hir::ExprAssign(ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(&**l, succ, ACC_WRITE);\n             let succ = self.propagate_through_lvalue_components(&**l, succ);\n             self.propagate_through_expr(&**r, succ)\n           }\n \n-          ast::ExprAssignOp(_, ref l, ref r) => {\n+          hir::ExprAssignOp(_, ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(&**l, succ, ACC_WRITE|ACC_READ);\n@@ -1116,23 +1093,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          ast::ExprVec(ref exprs) => {\n+          hir::ExprVec(ref exprs) => {\n             self.propagate_through_exprs(&exprs[..], succ)\n           }\n \n-          ast::ExprRepeat(ref element, ref count) => {\n+          hir::ExprRepeat(ref element, ref count) => {\n             let succ = self.propagate_through_expr(&**count, succ);\n             self.propagate_through_expr(&**element, succ)\n           }\n \n-          ast::ExprStruct(_, ref fields, ref with_expr) => {\n+          hir::ExprStruct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n                 self.propagate_through_expr(&*field.expr, succ)\n             })\n           }\n \n-          ast::ExprCall(ref f, ref args) => {\n+          hir::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n                 self.ir.tcx.expr_ty_adjusted(&**f).fn_ret().diverges();\n             let succ = if diverges {\n@@ -1144,7 +1121,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**f, succ)\n           }\n \n-          ast::ExprMethodCall(_, _, ref args) => {\n+          hir::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n             let succ = if method_ty.fn_ret().diverges() {\n@@ -1155,11 +1132,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(&args[..], succ)\n           }\n \n-          ast::ExprTup(ref exprs) => {\n+          hir::ExprTup(ref exprs) => {\n             self.propagate_through_exprs(&exprs[..], succ)\n           }\n \n-          ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n+          hir::ExprBinary(op, ref l, ref r) if ::rustc_front::util::lazy_binop(op.node) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n@@ -1169,27 +1146,27 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**l, ln)\n           }\n \n-          ast::ExprIndex(ref l, ref r) |\n-          ast::ExprBinary(_, ref l, ref r) |\n-          ast::ExprBox(Some(ref l), ref r) => {\n+          hir::ExprIndex(ref l, ref r) |\n+          hir::ExprBinary(_, ref l, ref r) |\n+          hir::ExprBox(Some(ref l), ref r) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n             self.propagate_through_expr(&**l, r_succ)\n           }\n \n-          ast::ExprRange(ref e1, ref e2) => {\n+          hir::ExprRange(ref e1, ref e2) => {\n             let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n             e1.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ))\n           }\n \n-          ast::ExprBox(None, ref e) |\n-          ast::ExprAddrOf(_, ref e) |\n-          ast::ExprCast(ref e, _) |\n-          ast::ExprUnary(_, ref e) |\n-          ast::ExprParen(ref e) => {\n+          hir::ExprBox(None, ref e) |\n+          hir::ExprAddrOf(_, ref e) |\n+          hir::ExprCast(ref e, _) |\n+          hir::ExprUnary(_, ref e) |\n+          hir::ExprParen(ref e) => {\n             self.propagate_through_expr(&**e, succ)\n           }\n \n-          ast::ExprInlineAsm(ref ia) => {\n+          hir::ExprInlineAsm(ref ia) => {\n \n             let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, ref expr, _)| {\n                 // see comment on lvalues\n@@ -1203,17 +1180,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             })\n           }\n \n-          ast::ExprLit(..) => {\n+          hir::ExprLit(..) => {\n             succ\n           }\n \n-          ast::ExprBlock(ref blk) => {\n+          hir::ExprBlock(ref blk) => {\n             self.propagate_through_block(&**blk, succ)\n           }\n-\n-          ast::ExprMac(..) => {\n-            self.ir.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n-          }\n         }\n     }\n \n@@ -1271,9 +1244,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            ast::ExprPath(..) => succ,\n-            ast::ExprField(ref e, _) => self.propagate_through_expr(&**e, succ),\n-            ast::ExprTupField(ref e, _) => self.propagate_through_expr(&**e, succ),\n+            hir::ExprPath(..) => succ,\n+            hir::ExprField(ref e, _) => self.propagate_through_expr(&**e, succ),\n+            hir::ExprTupField(ref e, _) => self.propagate_through_expr(&**e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1282,7 +1255,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n-          ast::ExprPath(..) => {\n+          hir::ExprPath(..) => {\n               self.access_path(expr, succ, acc)\n           }\n \n@@ -1313,7 +1286,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_loop(&mut self,\n                               expr: &Expr,\n                               kind: LoopKind,\n-                              body: &ast::Block,\n+                              body: &hir::Block,\n                               succ: LiveNode)\n                               -> LiveNode {\n \n@@ -1400,7 +1373,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(this: &mut Liveness, local: &ast::Local) {\n+fn check_local(this: &mut Liveness, local: &hir::Local) {\n     match local.init {\n         Some(_) => {\n             this.warn_about_unused_or_dead_vars_in_pat(&*local.pat);\n@@ -1415,7 +1388,7 @@ fn check_local(this: &mut Liveness, local: &ast::Local) {\n     visit::walk_local(this, local);\n }\n \n-fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n+fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n@@ -1427,20 +1400,20 @@ fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n \n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n-      ast::ExprAssign(ref l, ref r) => {\n+      hir::ExprAssign(ref l, ref r) => {\n         this.check_lvalue(&**l);\n         this.visit_expr(&**r);\n \n         visit::walk_expr(this, expr);\n       }\n \n-      ast::ExprAssignOp(_, ref l, _) => {\n+      hir::ExprAssignOp(_, ref l, _) => {\n         this.check_lvalue(&**l);\n \n         visit::walk_expr(this, expr);\n       }\n \n-      ast::ExprInlineAsm(ref ia) => {\n+      hir::ExprInlineAsm(ref ia) => {\n         for &(_, ref input) in &ia.inputs {\n           this.visit_expr(&**input);\n         }\n@@ -1455,34 +1428,25 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       // no correctness conditions related to liveness\n-      ast::ExprCall(..) | ast::ExprMethodCall(..) | ast::ExprIf(..) |\n-      ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) |\n-      ast::ExprIndex(..) | ast::ExprField(..) | ast::ExprTupField(..) |\n-      ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprBinary(..) |\n-      ast::ExprCast(..) | ast::ExprUnary(..) | ast::ExprRet(..) |\n-      ast::ExprBreak(..) | ast::ExprAgain(..) | ast::ExprLit(_) |\n-      ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n-      ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n-      ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) |\n-      ast::ExprRange(..) => {\n+      hir::ExprCall(..) | hir::ExprMethodCall(..) | hir::ExprIf(..) |\n+      hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) |\n+      hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n+      hir::ExprVec(..) | hir::ExprTup(..) | hir::ExprBinary(..) |\n+      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n+      hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n+      hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n+      hir::ExprStruct(..) | hir::ExprRepeat(..) | hir::ExprParen(..) |\n+      hir::ExprClosure(..) | hir::ExprPath(..) | hir::ExprBox(..) |\n+      hir::ExprRange(..) => {\n         visit::walk_expr(this, expr);\n       }\n-      ast::ExprIfLet(..) => {\n-        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n-      }\n-      ast::ExprWhileLet(..) => {\n-        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n-      }\n-      ast::ExprForLoop(..) => {\n-        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n-      }\n     }\n }\n \n fn check_fn(_v: &Liveness,\n             _fk: FnKind,\n-            _decl: &ast::FnDecl,\n-            _body: &ast::Block,\n+            _decl: &hir::FnDecl,\n+            _body: &hir::Block,\n             _sp: Span,\n             _id: NodeId) {\n     // do not check contents of nested fns\n@@ -1503,7 +1467,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &ast::Block)\n+                 body: &hir::Block)\n     {\n         // within the fn body, late-bound regions are liberated:\n         let fn_ret =\n@@ -1521,7 +1485,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     let ends_with_stmt = match body.expr {\n                         None if !body.stmts.is_empty() =>\n                             match body.stmts.first().unwrap().node {\n-                                ast::StmtSemi(ref e, _) => {\n+                                hir::StmtSemi(ref e, _) => {\n                                     self.ir.tcx.expr_ty(&**e) == t_ret\n                                 },\n                                 _ => false\n@@ -1555,7 +1519,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-            ast::ExprPath(..) => {\n+            hir::ExprPath(..) => {\n                 if let DefLocal(nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n                                                                    .unwrap()\n                                                                    .full_def() {\n@@ -1585,7 +1549,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_args(&self, decl: &ast::FnDecl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n         for arg in &decl.inputs {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    &*arg.pat,\n@@ -1600,7 +1564,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &ast::Pat) {\n+    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &hir::Pat) {\n         self.pat_bindings(pat, |this, ln, var, sp, id| {\n             if !this.warn_about_unused(sp, id, ln, var) {\n                 this.warn_about_dead_assign(sp, id, ln, var);"}, {"sha": "a8c80d52209e463277f2aa5beb588f3d00f4e0a4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 53, "deletions": 66, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -72,14 +72,15 @@ pub use self::categorization::*;\n \n use self::Aliasability::*;\n \n-use ast_map;\n use middle::def_id::DefId;\n+use front::map as ast_map;\n use middle::infer;\n use middle::check_const;\n use middle::def;\n use middle::ty::{self, Ty};\n \n-use syntax::ast::{MutImmutable, MutMutable};\n+use rustc_front::hir::{MutImmutable, MutMutable};\n+use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -116,7 +117,7 @@ pub enum PointerKind {\n     BorrowedPtr(ty::BorrowKind, ty::Region),\n \n     /// `*T`\n-    UnsafePtr(ast::Mutability),\n+    UnsafePtr(hir::Mutability),\n \n     /// Implicit deref of the `&T` that results from an overloaded index `[]`.\n     Implicit(ty::BorrowKind, ty::Region),\n@@ -244,12 +245,12 @@ pub trait ast_node {\n     fn span(&self) -> Span;\n }\n \n-impl ast_node for ast::Expr {\n+impl ast_node for hir::Expr {\n     fn id(&self) -> ast::NodeId { self.id }\n     fn span(&self) -> Span { self.span }\n }\n \n-impl ast_node for ast::Pat {\n+impl ast_node for hir::Pat {\n     fn id(&self) -> ast::NodeId { self.id }\n     fn span(&self) -> Span { self.span }\n }\n@@ -262,7 +263,7 @@ pub struct MemCategorizationContext<'t, 'a: 't, 'tcx : 'a> {\n pub type McResult<T> = Result<T, ()>;\n \n impl MutabilityCategory {\n-    pub fn from_mutbl(m: ast::Mutability) -> MutabilityCategory {\n+    pub fn from_mutbl(m: hir::Mutability) -> MutabilityCategory {\n         let ret = match m {\n             MutImmutable => McImmutable,\n             MutMutable => McDeclared\n@@ -304,8 +305,8 @@ impl MutabilityCategory {\n     fn from_local(tcx: &ty::ctxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) | ast_map::NodeArg(p) => match p.node {\n-                ast::PatIdent(bind_mode, _, _) => {\n-                    if bind_mode == ast::BindByValue(ast::MutMutable) {\n+                hir::PatIdent(bind_mode, _, _) => {\n+                    if bind_mode == hir::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n                         McImmutable\n@@ -366,7 +367,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         self.typer.tcx\n     }\n \n-    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+    fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n         match self.typer.node_ty(expr.id) {\n             Ok(t) => Ok(t),\n             Err(()) => {\n@@ -376,7 +377,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         }\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+    fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n         let unadjusted_ty = try!(self.expr_ty(expr));\n         Ok(unadjusted_ty.adjust(\n             self.tcx(), expr.span, expr.id,\n@@ -388,14 +389,14 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n+    fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n         let base_ty = try!(self.typer.node_ty(pat.id));\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n-            ast::PatIdent(ast::BindByRef(_), _, _) => {\n+            hir::PatIdent(hir::BindByRef(_), _, _) => {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n@@ -411,7 +412,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n         match self.typer.adjustments().get(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -443,7 +444,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     }\n \n     pub fn cat_expr_autoderefd(&self,\n-                               expr: &ast::Expr,\n+                               expr: &hir::Expr,\n                                autoderefs: usize)\n                                -> McResult<cmt<'tcx>> {\n         let mut cmt = try!(self.cat_expr_unadjusted(expr));\n@@ -456,17 +457,17 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n \n         let expr_ty = try!(self.expr_ty(expr));\n         match expr.node {\n-          ast::ExprUnary(ast::UnDeref, ref e_base) => {\n+          hir::ExprUnary(hir::UnDeref, ref e_base) => {\n             let base_cmt = try!(self.cat_expr(&**e_base));\n             self.cat_deref(expr, base_cmt, 0, None)\n           }\n \n-          ast::ExprField(ref base, f_name) => {\n+          hir::ExprField(ref base, f_name) => {\n             let base_cmt = try!(self.cat_expr(&**base));\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n@@ -475,12 +476,12 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n           }\n \n-          ast::ExprTupField(ref base, idx) => {\n+          hir::ExprTupField(ref base, idx) => {\n             let base_cmt = try!(self.cat_expr(&**base));\n             Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }\n \n-          ast::ExprIndex(ref base, _) => {\n+          hir::ExprIndex(ref base, _) => {\n             let method_call = ty::MethodCall::expr(expr.id());\n             let context = InteriorOffsetKind::Index;\n             match self.typer.node_method_ty(method_call) {\n@@ -512,38 +513,28 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          ast::ExprPath(..) => {\n+          hir::ExprPath(..) => {\n             let def = self.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n-          ast::ExprParen(ref e) => {\n+          hir::ExprParen(ref e) => {\n             self.cat_expr(&**e)\n           }\n \n-          ast::ExprAddrOf(..) | ast::ExprCall(..) |\n-          ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n-          ast::ExprClosure(..) | ast::ExprRet(..) |\n-          ast::ExprUnary(..) | ast::ExprRange(..) |\n-          ast::ExprMethodCall(..) | ast::ExprCast(..) |\n-          ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n-          ast::ExprBinary(..) | ast::ExprWhile(..) |\n-          ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n-          ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n-          ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n-          ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n+          hir::ExprAddrOf(..) | hir::ExprCall(..) |\n+          hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n+          hir::ExprClosure(..) | hir::ExprRet(..) |\n+          hir::ExprUnary(..) | hir::ExprRange(..) |\n+          hir::ExprMethodCall(..) | hir::ExprCast(..) |\n+          hir::ExprVec(..) | hir::ExprTup(..) | hir::ExprIf(..) |\n+          hir::ExprBinary(..) | hir::ExprWhile(..) |\n+          hir::ExprBlock(..) | hir::ExprLoop(..) | hir::ExprMatch(..) |\n+          hir::ExprLit(..) | hir::ExprBreak(..) |\n+          hir::ExprAgain(..) | hir::ExprStruct(..) | hir::ExprRepeat(..) |\n+          hir::ExprInlineAsm(..) | hir::ExprBox(..) => {\n             Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n-\n-          ast::ExprIfLet(..) => {\n-            self.tcx().sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n-          }\n-          ast::ExprWhileLet(..) => {\n-            self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n-          }\n-          ast::ExprForLoop(..) => {\n-            self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n-          }\n         }\n     }\n \n@@ -738,7 +729,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                ast::ExprClosure(_, _, ref body) => body.id,\n+                hir::ExprClosure(_, _, ref body) => body.id,\n                 _ => unreachable!()\n             }\n         };\n@@ -1078,8 +1069,8 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     /// These last two bits of info happen to be things that borrowck needs.\n     pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt<'tcx>,\n-                             slice_pat: &ast::Pat)\n-                             -> McResult<(cmt<'tcx>, ast::Mutability, ty::Region)> {\n+                             slice_pat: &hir::Pat)\n+                             -> McResult<(cmt<'tcx>, hir::Mutability, ty::Region)> {\n         let slice_ty = try!(self.node_ty(slice_pat.id));\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n@@ -1093,9 +1084,9 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n         /// have to recurse through rptrs.\n         fn vec_slice_info(tcx: &ty::ctxt,\n-                          pat: &ast::Pat,\n+                          pat: &hir::Pat,\n                           slice_ty: Ty)\n-                          -> (ast::Mutability, ty::Region) {\n+                          -> (hir::Mutability, ty::Region) {\n             match slice_ty.sty {\n                 ty::TyRef(r, ref mt) => match mt.ty.sty {\n                     ty::TySlice(_) => (mt.mutbl, *r),\n@@ -1146,16 +1137,16 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         ret\n     }\n \n-    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &ast::Pat),\n+    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n+        where F: FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &hir::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F)\n+    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F)\n                        -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &ast::Pat),\n+        where F : FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &hir::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1223,14 +1214,14 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         };\n \n         match pat.node {\n-          ast::PatWild(_) => {\n+          hir::PatWild(_) => {\n             // _\n           }\n \n-          ast::PatEnum(_, None) => {\n+          hir::PatEnum(_, None) => {\n             // variant(..)\n           }\n-          ast::PatEnum(_, Some(ref subpats)) => {\n+          hir::PatEnum(_, Some(ref subpats)) => {\n             match opt_def {\n                 Some(def::DefVariant(..)) => {\n                     // variant(x, y, z)\n@@ -1268,19 +1259,19 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          ast::PatQPath(..) => {\n+          hir::PatQPath(..) => {\n               // Lone constant: ignore\n           }\n \n-          ast::PatIdent(_, _, Some(ref subpat)) => {\n+          hir::PatIdent(_, _, Some(ref subpat)) => {\n               try!(self.cat_pattern_(cmt, &**subpat, op));\n           }\n \n-          ast::PatIdent(_, _, None) => {\n+          hir::PatIdent(_, _, None) => {\n               // nullary variant or identifier: ignore\n           }\n \n-          ast::PatStruct(_, ref field_pats, _) => {\n+          hir::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats {\n                 let field_ty = try!(self.pat_ty(&*fp.node.pat)); // see (*2)\n@@ -1289,7 +1280,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          ast::PatTup(ref subpats) => {\n+          hir::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n                 let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n@@ -1301,15 +1292,15 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          ast::PatBox(ref subpat) | ast::PatRegion(ref subpat, _) => {\n+          hir::PatBox(ref subpat) | hir::PatRegion(ref subpat, _) => {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatRegion since that information is already contained\n             // in the type.\n             let subcmt = try!(self.cat_deref(pat, cmt, 0, None));\n               try!(self.cat_pattern_(subcmt, &**subpat, op));\n           }\n \n-          ast::PatVec(ref before, ref slice, ref after) => {\n+          hir::PatVec(ref before, ref slice, ref after) => {\n               let context = InteriorOffsetKind::Pattern;\n               let vec_cmt = try!(self.deref_vec(pat, cmt, context));\n               let elt_cmt = try!(self.cat_index(pat, vec_cmt, context));\n@@ -1326,13 +1317,9 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               }\n           }\n \n-          ast::PatLit(_) | ast::PatRange(_, _) => {\n+          hir::PatLit(_) | hir::PatRange(_, _) => {\n               /*always ok*/\n           }\n-\n-          ast::PatMac(_) => {\n-              self.tcx().sess.span_bug(pat.span, \"unexpanded macro\");\n-          }\n         }\n \n         Ok(())"}, {"sha": "3c483f70a4efb53d8cabcbd156f1f04a06672ed5", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -14,42 +14,43 @@ use middle::ty;\n use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n-use syntax::ast_util::walk_pat;\n+use rustc_front::hir;\n+use rustc_front::util::walk_pat;\n use syntax::codemap::{Span, DUMMY_SP};\n \n pub type PatIdMap = FnvHashMap<ast::Ident, ast::NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: &DefMap, pat: &ast::Pat) -> PatIdMap {\n+pub fn pat_id_map(dm: &DefMap, pat: &hir::Pat) -> PatIdMap {\n     let mut map = FnvHashMap();\n     pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });\n     map\n }\n \n-pub fn pat_is_refutable(dm: &DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        ast::PatLit(_) | ast::PatRange(_, _) | ast::PatQPath(..) => true,\n-        ast::PatEnum(_, _) |\n-        ast::PatIdent(_, _, None) |\n-        ast::PatStruct(..) => {\n+        hir::PatLit(_) | hir::PatRange(_, _) | hir::PatQPath(..) => true,\n+        hir::PatEnum(_, _) |\n+        hir::PatIdent(_, _, None) |\n+        hir::PatStruct(..) => {\n             match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefVariant(..)) => true,\n                 _ => false\n             }\n         }\n-        ast::PatVec(_, _, _) => true,\n+        hir::PatVec(_, _, _) => true,\n         _ => false\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        ast::PatEnum(_, _) |\n-        ast::PatIdent(_, _, None) |\n-        ast::PatStruct(..) => {\n+        hir::PatEnum(_, _) |\n+        hir::PatIdent(_, _, None) |\n+        hir::PatStruct(..) => {\n             match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefVariant(..)) | Some(DefStruct(..)) => true,\n                 _ => false\n@@ -59,9 +60,9 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        ast::PatIdent(_, _, None) | ast::PatEnum(..) | ast::PatQPath(..) => {\n+        hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n             match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n                 _ => false\n@@ -73,9 +74,9 @@ pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n \n // Same as above, except that partially-resolved defs cause `false` to be\n // returned instead of a panic.\n-pub fn pat_is_resolved_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        ast::PatIdent(_, _, None) | ast::PatEnum(..) | ast::PatQPath(..) => {\n+        hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n             match dm.borrow().get(&pat.id)\n                     .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n                                   else { None } ) {\n@@ -87,32 +88,32 @@ pub fn pat_is_resolved_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: &DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        ast::PatIdent(..) => {\n+        hir::PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n             !pat_is_const(dm, pat)\n         }\n         _ => false\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        ast::PatIdent(..) => pat_is_binding(dm, pat),\n-        ast::PatWild(_) => true,\n+        hir::PatIdent(..) => pat_is_binding(dm, pat),\n+        hir::PatWild(_) => true,\n         _ => false\n     }\n }\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<I>(dm: &DefMap, pat: &ast::Pat, mut it: I) where\n-    I: FnMut(ast::BindingMode, ast::NodeId, Span, &ast::SpannedIdent),\n+pub fn pat_bindings<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n+    I: FnMut(hir::BindingMode, ast::NodeId, Span, &hir::SpannedIdent),\n {\n     walk_pat(pat, |p| {\n         match p.node {\n-          ast::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n+          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}\n@@ -123,7 +124,7 @@ pub fn pat_bindings<I>(dm: &DefMap, pat: &ast::Pat, mut it: I) where\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {\n@@ -138,37 +139,37 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n \n /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n /// and if yes wether its containing mutable ones or just immutables ones.\n-pub fn pat_contains_ref_binding(dm: &DefMap, pat: &ast::Pat) -> Option<ast::Mutability> {\n+pub fn pat_contains_ref_binding(dm: &DefMap, pat: &hir::Pat) -> Option<hir::Mutability> {\n     let mut result = None;\n     pat_bindings(dm, pat, |mode, _, _, _| {\n         match mode {\n-            ast::BindingMode::BindByRef(m) => {\n+            hir::BindingMode::BindByRef(m) => {\n                 // Pick Mutable as maximum\n                 match result {\n-                    None | Some(ast::MutImmutable) => result = Some(m),\n+                    None | Some(hir::MutImmutable) => result = Some(m),\n                     _ => (),\n                 }\n             }\n-            ast::BindingMode::BindByValue(_) => { }\n+            hir::BindingMode::BindByValue(_) => { }\n         }\n     });\n     result\n }\n \n /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n /// bindings, and if yes wether its containing mutable ones or just immutables ones.\n-pub fn arm_contains_ref_binding(dm: &DefMap, arm: &ast::Arm) -> Option<ast::Mutability> {\n+pub fn arm_contains_ref_binding(dm: &DefMap, arm: &hir::Arm) -> Option<hir::Mutability> {\n     arm.pats.iter()\n             .filter_map(|pat| pat_contains_ref_binding(dm, pat))\n             .max_by(|m| match *m {\n-                ast::MutMutable => 1,\n-                ast::MutImmutable => 0,\n+                hir::MutMutable => 1,\n+                hir::MutImmutable => 0,\n             })\n }\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {\n+pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding_or_wild(dm, p) {\n@@ -181,9 +182,9 @@ pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {\n     contains_bindings\n }\n \n-pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n+pub fn simple_identifier<'a>(pat: &'a hir::Pat) -> Option<&'a ast::Ident> {\n     match pat.node {\n-        ast::PatIdent(ast::BindByValue(_), ref path1, None) => {\n+        hir::PatIdent(hir::BindByValue(_), ref path1, None) => {\n             Some(&path1.node)\n         }\n         _ => {\n@@ -192,25 +193,25 @@ pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n     }\n }\n \n-pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> ast::Path {\n-    tcx.with_path(id, |path| ast::Path {\n+pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> hir::Path {\n+    tcx.with_path(id, |path| hir::Path {\n         global: false,\n-        segments: path.last().map(|elem| ast::PathSegment {\n+        segments: path.last().map(|elem| hir::PathSegment {\n             identifier: ast::Ident::new(elem.name()),\n-            parameters: ast::PathParameters::none(),\n+            parameters: hir::PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,\n     })\n }\n \n /// Return variants that are necessary to exist for the pattern to match.\n-pub fn necessary_variants(dm: &DefMap, pat: &ast::Pat) -> Vec<ast::NodeId> {\n+pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<ast::NodeId> {\n     let mut variants = vec![];\n     walk_pat(pat, |p| {\n         match p.node {\n-            ast::PatEnum(_, _) |\n-            ast::PatIdent(_, _, None) |\n-            ast::PatStruct(..) => {\n+            hir::PatEnum(_, _) |\n+            hir::PatIdent(_, _, None) |\n+            hir::PatStruct(..) => {\n                 match dm.borrow().get(&p.id) {\n                     Some(&PathResolution { base_def: DefVariant(_, id, _), .. }) => {\n                         variants.push(id.node);"}, {"sha": "e53d00736681a420caefc31054161a7d6be00fea", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -15,7 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use ast_map;\n+use front::map as ast_map;\n use middle::def;\n use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::ty;\n@@ -26,35 +26,36 @@ use util::nodemap::NodeSet;\n use std::collections::HashSet;\n use syntax::abi;\n use syntax::ast;\n-use syntax::attr;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use rustc_front::hir;\n+use rustc_front::attr;\n+use rustc_front::visit::Visitor;\n+use rustc_front::visit;\n \n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n-fn generics_require_inlining(generics: &ast::Generics) -> bool {\n+fn generics_require_inlining(generics: &hir::Generics) -> bool {\n     !generics.ty_params.is_empty()\n }\n \n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: &ast::Item) -> bool {\n+fn item_might_be_inlined(item: &hir::Item) -> bool {\n     if attr::requests_inline(&item.attrs) {\n         return true\n     }\n \n     match item.node {\n-        ast::ItemImpl(_, _, ref generics, _, _, _) |\n-        ast::ItemFn(_, _, _, _, ref generics, _) => {\n+        hir::ItemImpl(_, _, ref generics, _, _, _) |\n+        hir::ItemFn(_, _, _, _, ref generics, _) => {\n             generics_require_inlining(generics)\n         }\n         _ => false,\n     }\n }\n \n-fn method_might_be_inlined(tcx: &ty::ctxt, sig: &ast::MethodSig,\n-                           impl_item: &ast::ImplItem,\n+fn method_might_be_inlined(tcx: &ty::ctxt, sig: &hir::MethodSig,\n+                           impl_item: &hir::ImplItem,\n                            impl_src: DefId) -> bool {\n     if attr::requests_inline(&impl_item.attrs) ||\n         generics_require_inlining(&sig.generics) {\n@@ -92,10 +93,10 @@ struct ReachableContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n \n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n \n         match expr.node {\n-            ast::ExprPath(..) => {\n+            hir::ExprPath(..) => {\n                 let def = match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(d) => d.full_def(),\n                     None => {\n@@ -126,7 +127,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprMethodCall(..) => {\n+            hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n                 match self.tcx.impl_or_trait_item(def_id).container() {\n@@ -147,7 +148,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n         visit::walk_expr(self, expr)\n     }\n \n-    fn visit_item(&mut self, _item: &ast::Item) {\n+    fn visit_item(&mut self, _item: &hir::Item) {\n         // Do not recurse into items. These items will be added to the worklist\n         // and recursed into manually if necessary.\n     }\n@@ -178,21 +179,21 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    ast::ItemFn(..) => item_might_be_inlined(&*item),\n+                    hir::ItemFn(..) => item_might_be_inlined(&*item),\n                     _ => false,\n                 }\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n                 match trait_method.node {\n-                    ast::ConstTraitItem(_, ref default) => default.is_some(),\n-                    ast::MethodTraitItem(_, ref body) => body.is_some(),\n-                    ast::TypeTraitItem(..) => false,\n+                    hir::ConstTraitItem(_, ref default) => default.is_some(),\n+                    hir::MethodTraitItem(_, ref body) => body.is_some(),\n+                    hir::TypeTraitItem(..) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n                 match impl_item.node {\n-                    ast::ConstImplItem(..) => true,\n-                    ast::MethodImplItem(ref sig, _) => {\n+                    hir::ConstImplItem(..) => true,\n+                    hir::MethodImplItem(ref sig, _) => {\n                         if generics_require_inlining(&sig.generics) ||\n                                 attr::requests_inline(&impl_item.attrs) {\n                             true\n@@ -208,15 +209,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                                       .map\n                                       .expect_item(impl_did.node)\n                                       .node {\n-                                ast::ItemImpl(_, _, ref generics, _, _, _) => {\n+                                hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                                     generics_require_inlining(generics)\n                                 }\n                                 _ => false\n                             }\n                         }\n                     }\n-                    ast::TypeImplItem(_) => false,\n-                    ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n+                    hir::TypeImplItem(_) => false,\n                 }\n             }\n             Some(_) => false,\n@@ -257,7 +257,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // but all other rust-only interfaces can be private (they will not\n             // participate in linkage after this product is produced)\n             if let ast_map::NodeItem(item) = *node {\n-                if let ast::ItemFn(_, _, _, abi, _, _) = item.node {\n+                if let hir::ItemFn(_, _, _, abi, _, _) = item.node {\n                     if abi != abi::Rust {\n                         self.reachable_symbols.insert(search_item);\n                     }\n@@ -274,7 +274,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    ast::ItemFn(_, _, _, _, _, ref search_block) => {\n+                    hir::ItemFn(_, _, _, _, _, ref search_block) => {\n                         if item_might_be_inlined(&*item) {\n                             visit::walk_block(self, &**search_block)\n                         }\n@@ -283,55 +283,48 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // Reachable constants will be inlined into other crates\n                     // unconditionally, so we need to make sure that their\n                     // contents are also reachable.\n-                    ast::ItemConst(_, ref init) => {\n+                    hir::ItemConst(_, ref init) => {\n                         self.visit_expr(&**init);\n                     }\n \n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    ast::ItemExternCrate(_) | ast::ItemUse(_) |\n-                    ast::ItemTy(..) | ast::ItemStatic(_, _, _) |\n-                    ast::ItemMod(..) | ast::ItemForeignMod(..) |\n-                    ast::ItemImpl(..) | ast::ItemTrait(..) |\n-                    ast::ItemStruct(..) | ast::ItemEnum(..) |\n-                    ast::ItemDefaultImpl(..) => {}\n-\n-                    _ => {\n-                        self.tcx.sess.span_bug(item.span,\n-                                               \"found non-function item \\\n-                                                in worklist?!\")\n-                    }\n+                    hir::ItemExternCrate(_) | hir::ItemUse(_) |\n+                    hir::ItemTy(..) | hir::ItemStatic(_, _, _) |\n+                    hir::ItemMod(..) | hir::ItemForeignMod(..) |\n+                    hir::ItemImpl(..) | hir::ItemTrait(..) |\n+                    hir::ItemStruct(..) | hir::ItemEnum(..) |\n+                    hir::ItemDefaultImpl(..) => {}\n                 }\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n                 match trait_method.node {\n-                    ast::ConstTraitItem(_, None) |\n-                    ast::MethodTraitItem(_, None) => {\n+                    hir::ConstTraitItem(_, None) |\n+                    hir::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    ast::ConstTraitItem(_, Some(ref expr)) => {\n+                    hir::ConstTraitItem(_, Some(ref expr)) => {\n                         self.visit_expr(&*expr);\n                     }\n-                    ast::MethodTraitItem(_, Some(ref body)) => {\n+                    hir::MethodTraitItem(_, Some(ref body)) => {\n                         visit::walk_block(self, body);\n                     }\n-                    ast::TypeTraitItem(..) => {}\n+                    hir::TypeTraitItem(..) => {}\n                 }\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n-                    ast::ConstImplItem(_, ref expr) => {\n+                    hir::ConstImplItem(_, ref expr) => {\n                         self.visit_expr(&*expr);\n                     }\n-                    ast::MethodImplItem(ref sig, ref body) => {\n+                    hir::MethodImplItem(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n                             visit::walk_block(self, body)\n                         }\n                     }\n-                    ast::TypeImplItem(_) => {}\n-                    ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n+                    hir::TypeImplItem(_) => {}\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "38167fd058e9f6f150d3a1118a826f25fde47292", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -16,20 +16,22 @@\n //! Most of the documentation on regions can be found in\n //! `middle/typeck/infer/region_inference.rs`\n \n-use ast_map;\n use metadata::inline::InlinedItem;\n-use middle::ty::{self, Ty};\n+use front::map as ast_map;\n use session::Session;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use middle::ty::{self, Ty};\n \n use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::mem;\n use syntax::codemap::{self, Span};\n-use syntax::{ast, visit};\n-use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n-use syntax::ast_util::stmt_id;\n-use syntax::visit::{Visitor, FnKind};\n+use syntax::ast::{self, NodeId};\n+\n+use rustc_front::hir;\n+use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::hir::{Block, Item, FnDecl, Arm, Pat, Stmt, Expr, Local};\n+use rustc_front::util::stmt_id;\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n            RustcDecodable, Debug, Copy)]\n@@ -632,7 +634,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n     }\n }\n \n-fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n+fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n@@ -676,7 +678,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n         // index information.)\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n-            if let ast::StmtDecl(..) = statement.node {\n+            if let hir::StmtDecl(..) = statement.node {\n                 // Each StmtDecl introduces a subscope for bindings\n                 // introduced by the declaration; this subscope covers\n                 // a suffix of the block . Each subscope in a block\n@@ -703,7 +705,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n+fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.id);\n \n     if let Some(ref expr) = arm.guard {\n@@ -713,13 +715,13 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n     visit::walk_arm(visitor, arm);\n }\n \n-fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n+fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n     visitor.new_node_extent(pat.id);\n \n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n     match pat.node {\n-        ast::PatIdent(..) => {\n+        hir::PatIdent(..) => {\n             record_var_lifetime(visitor, pat.id, pat.span);\n         }\n         _ => { }\n@@ -728,7 +730,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n     visit::walk_pat(visitor, pat);\n }\n \n-fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n+fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n     let stmt_id = stmt_id(stmt);\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -746,7 +748,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n+fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n@@ -763,38 +765,38 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n \n-            ast::ExprBinary(codemap::Spanned { node: ast::BiAnd, .. }, _, ref r) |\n-            ast::ExprBinary(codemap::Spanned { node: ast::BiOr, .. }, _, ref r) => {\n+            hir::ExprBinary(codemap::Spanned { node: hir::BiAnd, .. }, _, ref r) |\n+            hir::ExprBinary(codemap::Spanned { node: hir::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n                 terminating(r.id);\n             }\n \n-            ast::ExprIf(_, ref then, Some(ref otherwise)) => {\n+            hir::ExprIf(_, ref then, Some(ref otherwise)) => {\n                 terminating(then.id);\n                 terminating(otherwise.id);\n             }\n \n-            ast::ExprIf(ref expr, ref then, None) => {\n+            hir::ExprIf(ref expr, ref then, None) => {\n                 terminating(expr.id);\n                 terminating(then.id);\n             }\n \n-            ast::ExprLoop(ref body, _) => {\n+            hir::ExprLoop(ref body, _) => {\n                 terminating(body.id);\n             }\n \n-            ast::ExprWhile(ref expr, ref body, _) => {\n+            hir::ExprWhile(ref expr, ref body, _) => {\n                 terminating(expr.id);\n                 terminating(body.id);\n             }\n \n-            ast::ExprMatch(..) => {\n+            hir::ExprMatch(..) => {\n                 visitor.cx.var_parent = expr_extent;\n             }\n \n-            ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n-            ast::ExprUnary(..) | ast::ExprCall(..) | ast::ExprMethodCall(..) => {\n+            hir::ExprAssignOp(..) | hir::ExprIndex(..) |\n+            hir::ExprUnary(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) => {\n                 // FIXME(#6268) Nested method calls\n                 //\n                 // The lifetimes for a call or method call look as follows:\n@@ -823,7 +825,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n+fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n@@ -920,26 +922,26 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     ///        | [ ..., P&, ... ]\n     ///        | ( ..., P&, ... )\n     ///        | box P&\n-    fn is_binding_pat(pat: &ast::Pat) -> bool {\n+    fn is_binding_pat(pat: &hir::Pat) -> bool {\n         match pat.node {\n-            ast::PatIdent(ast::BindByRef(_), _, _) => true,\n+            hir::PatIdent(hir::BindByRef(_), _, _) => true,\n \n-            ast::PatStruct(_, ref field_pats, _) => {\n+            hir::PatStruct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&*fp.node.pat))\n             }\n \n-            ast::PatVec(ref pats1, ref pats2, ref pats3) => {\n+            hir::PatVec(ref pats1, ref pats2, ref pats3) => {\n                 pats1.iter().any(|p| is_binding_pat(&**p)) ||\n                 pats2.iter().any(|p| is_binding_pat(&**p)) ||\n                 pats3.iter().any(|p| is_binding_pat(&**p))\n             }\n \n-            ast::PatEnum(_, Some(ref subpats)) |\n-            ast::PatTup(ref subpats) => {\n+            hir::PatEnum(_, Some(ref subpats)) |\n+            hir::PatTup(ref subpats) => {\n                 subpats.iter().any(|p| is_binding_pat(&**p))\n             }\n \n-            ast::PatBox(ref subpat) => {\n+            hir::PatBox(ref subpat) => {\n                 is_binding_pat(&**subpat)\n             }\n \n@@ -948,9 +950,9 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     }\n \n     /// True if `ty` is a borrowed pointer type like `&int` or `&[...]`.\n-    fn is_borrowed_ty(ty: &ast::Ty) -> bool {\n+    fn is_borrowed_ty(ty: &hir::Ty) -> bool {\n         match ty.node {\n-            ast::TyRptr(..) => true,\n+            hir::TyRptr(..) => true,\n             _ => false\n         }\n     }\n@@ -966,34 +968,34 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     ///        | E& as ...\n     ///        | ( E& )\n     fn record_rvalue_scope_if_borrow_expr(visitor: &mut RegionResolutionVisitor,\n-                                          expr: &ast::Expr,\n+                                          expr: &hir::Expr,\n                                           blk_id: CodeExtent) {\n         match expr.node {\n-            ast::ExprAddrOf(_, ref subexpr) => {\n+            hir::ExprAddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n                 record_rvalue_scope(visitor, &**subexpr, blk_id);\n             }\n-            ast::ExprStruct(_, ref fields, _) => {\n+            hir::ExprStruct(_, ref fields, _) => {\n                 for field in fields {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &*field.expr, blk_id);\n                 }\n             }\n-            ast::ExprVec(ref subexprs) |\n-            ast::ExprTup(ref subexprs) => {\n+            hir::ExprVec(ref subexprs) |\n+            hir::ExprTup(ref subexprs) => {\n                 for subexpr in subexprs {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &**subexpr, blk_id);\n                 }\n             }\n-            ast::ExprUnary(ast::UnUniq, ref subexpr) => {\n+            hir::ExprUnary(hir::UnUniq, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n             }\n-            ast::ExprCast(ref subexpr, _) |\n-            ast::ExprParen(ref subexpr) => {\n+            hir::ExprCast(ref subexpr, _) |\n+            hir::ExprParen(ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id)\n             }\n-            ast::ExprBlock(ref block) => {\n+            hir::ExprBlock(ref block) => {\n                 match block.expr {\n                     Some(ref subexpr) => {\n                         record_rvalue_scope_if_borrow_expr(\n@@ -1023,7 +1025,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     ///\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n     fn record_rvalue_scope<'a>(visitor: &mut RegionResolutionVisitor,\n-                               expr: &'a ast::Expr,\n+                               expr: &'a hir::Expr,\n                                blk_scope: CodeExtent) {\n         let mut expr = expr;\n         loop {\n@@ -1035,12 +1037,12 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n             visitor.region_maps.record_rvalue_scope(expr.id, blk_scope);\n \n             match expr.node {\n-                ast::ExprAddrOf(_, ref subexpr) |\n-                ast::ExprUnary(ast::UnDeref, ref subexpr) |\n-                ast::ExprField(ref subexpr, _) |\n-                ast::ExprTupField(ref subexpr, _) |\n-                ast::ExprIndex(ref subexpr, _) |\n-                ast::ExprParen(ref subexpr) => {\n+                hir::ExprAddrOf(_, ref subexpr) |\n+                hir::ExprUnary(hir::UnDeref, ref subexpr) |\n+                hir::ExprField(ref subexpr, _) |\n+                hir::ExprTupField(ref subexpr, _) |\n+                hir::ExprIndex(ref subexpr, _) |\n+                hir::ExprParen(ref subexpr) => {\n                     expr = &**subexpr;\n                 }\n                 _ => {\n@@ -1051,7 +1053,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     }\n }\n \n-fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n+fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n     let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n@@ -1068,8 +1070,8 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n \n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               _: FnKind,\n-              decl: &ast::FnDecl,\n-              body: &ast::Block,\n+              decl: &hir::FnDecl,\n+              body: &hir::Block,\n               sp: Span,\n               id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n@@ -1159,12 +1161,12 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n         resolve_item(self, i);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n         visit::walk_impl_item(self, ii);\n         self.create_item_scope_if_needed(ii.id);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n         visit::walk_trait_item(self, ti);\n         self.create_item_scope_if_needed(ti.id);\n     }\n@@ -1190,7 +1192,7 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n     }\n }\n \n-pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n+pub fn resolve_crate(sess: &Session, krate: &hir::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n         code_extents: RefCell::new(vec![]),\n         code_extent_interner: RefCell::new(FnvHashMap()),"}, {"sha": "73b3b32f648714068d050aa096694f85c8a594bd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 66, "deletions": 68, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -28,11 +28,12 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n-use syntax::print::pprust::lifetime_to_string;\n-use syntax::visit;\n-use syntax::visit::{FnKind, Visitor};\n use util::nodemap::NodeMap;\n \n+use rustc_front::hir;\n+use rustc_front::print::pprust::lifetime_to_string;\n+use rustc_front::visit::{self, Visitor, FnKind};\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum DefRegion {\n     DefStaticRegion,\n@@ -78,10 +79,10 @@ struct LifetimeContext<'a> {\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n-    EarlyScope(subst::ParamSpace, &'a Vec<ast::LifetimeDef>, Scope<'a>),\n+    EarlyScope(subst::ParamSpace, &'a Vec<hir::LifetimeDef>, Scope<'a>),\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n-    LateScope(&'a Vec<ast::LifetimeDef>, Scope<'a>),\n+    LateScope(&'a Vec<hir::LifetimeDef>, Scope<'a>),\n     /// lifetimes introduced by items within a code block are scoped\n     /// to that block.\n     BlockScope(region::DestructionScopeData, Scope<'a>),\n@@ -92,7 +93,7 @@ type Scope<'a> = &'a ScopeChain<'a>;\n \n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n-pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegionMap {\n+pub fn krate(sess: &Session, krate: &hir::Crate, def_map: &DefMap) -> NamedRegionMap {\n     let mut named_region_map = NodeMap();\n     visit::walk_crate(&mut LifetimeContext {\n         sess: sess,\n@@ -107,34 +108,33 @@ pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegio\n }\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         // Items save/restore the set of labels. This way inner items\n         // can freely reuse names, be they loop labels or lifetimes.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n \n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n-                ast::ItemFn(..) => {\n+                hir::ItemFn(..) => {\n                     // Fn lifetimes get added in visit_fn below:\n                     visit::walk_item(this, item);\n                 }\n-                ast::ItemExternCrate(_) |\n-                ast::ItemUse(_) |\n-                ast::ItemMod(..) |\n-                ast::ItemMac(..) |\n-                ast::ItemDefaultImpl(..) |\n-                ast::ItemForeignMod(..) |\n-                ast::ItemStatic(..) |\n-                ast::ItemConst(..) => {\n+                hir::ItemExternCrate(_) |\n+                hir::ItemUse(_) |\n+                hir::ItemMod(..) |\n+                hir::ItemDefaultImpl(..) |\n+                hir::ItemForeignMod(..) |\n+                hir::ItemStatic(..) |\n+                hir::ItemConst(..) => {\n                     // These sorts of items have no lifetime parameters at all.\n                     visit::walk_item(this, item);\n                 }\n-                ast::ItemTy(_, ref generics) |\n-                ast::ItemEnum(_, ref generics) |\n-                ast::ItemStruct(_, ref generics) |\n-                ast::ItemTrait(_, ref generics, _, _) |\n-                ast::ItemImpl(_, _, ref generics, _, _, _) => {\n+                hir::ItemTy(_, ref generics) |\n+                hir::ItemEnum(_, ref generics) |\n+                hir::ItemStruct(_, ref generics) |\n+                hir::ItemTrait(_, ref generics, _, _) |\n+                hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n                     let early_scope = EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE);\n@@ -150,20 +150,20 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n         // Items save/restore the set of labels. This way inner items\n         // can freely reuse names, be they loop labels or lifetimes.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n \n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n-                ast::ForeignItemFn(_, ref generics) => {\n+                hir::ForeignItemFn(_, ref generics) => {\n                     this.visit_early_late(subst::FnSpace, generics, |this| {\n                         visit::walk_foreign_item(this, item);\n                     })\n                 }\n-                ast::ForeignItemStatic(..) => {\n+                hir::ForeignItemStatic(..) => {\n                     visit::walk_foreign_item(this, item);\n                 }\n             }\n@@ -173,8 +173,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, _: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, _: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n@@ -192,9 +192,9 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &ast::Ty) {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n-            ast::TyBareFn(ref c) => {\n+            hir::TyBareFn(ref c) => {\n                 visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n                 self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -203,7 +203,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     visit::walk_ty(this, ty);\n                 });\n             }\n-            ast::TyPath(None, ref path) => {\n+            hir::TyPath(None, ref path) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.borrow().get(&ty.id).map(|d| (d.base_def, d.depth)) {\n@@ -223,12 +223,12 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         // We reset the labels on every trait item, so that different\n         // methods in an impl can reuse label names.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n \n-        if let ast::MethodTraitItem(ref sig, None) = trait_item.node {\n+        if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n                 subst::FnSpace, &sig.generics,\n                 |this| visit::walk_trait_item(this, trait_item))\n@@ -239,21 +239,21 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block) {\n+    fn visit_block(&mut self, b: &hir::Block) {\n         self.with(BlockScope(region::DestructionScopeData::new(b.id),\n                              self.scope),\n                   |_, this| visit::walk_block(this, b));\n     }\n \n-    fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n+    fn visit_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n         if lifetime_ref.name == special_idents::static_lifetime.name {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n-    fn visit_generics(&mut self, generics: &ast::Generics) {\n+    fn visit_generics(&mut self, generics: &hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             visit::walk_ty_param_bounds_helper(self, &ty_param.bounds);\n             match ty_param.default {\n@@ -263,7 +263,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ ref bounded_ty,\n+                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ ref bounded_ty,\n                                                                                ref bounds,\n                                                                                ref bound_lifetimes,\n                                                                                .. }) => {\n@@ -282,7 +282,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                         visit::walk_ty_param_bounds_helper(self, bounds);\n                     }\n                 }\n-                &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n                                                                                 ref bounds,\n                                                                                 .. }) => {\n \n@@ -291,7 +291,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                         self.visit_lifetime_ref(bound);\n                     }\n                 }\n-                &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ id,\n+                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ id,\n                                                                          ref path,\n                                                                          ref ty,\n                                                                          .. }) => {\n@@ -303,8 +303,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_poly_trait_ref(&mut self,\n-                            trait_ref: &ast::PolyTraitRef,\n-                            _modifier: &ast::TraitBoundModifier) {\n+                            trait_ref: &hir::PolyTraitRef,\n+                            _modifier: &hir::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n@@ -337,10 +337,10 @@ fn original_label(span: Span) -> Original {\n fn shadower_label(span: Span) -> Shadower {\n     Shadower { kind: ShadowKind::Label, span: span }\n }\n-fn original_lifetime(l: &ast::Lifetime) -> Original {\n+fn original_lifetime(l: &hir::Lifetime) -> Original {\n     Original { kind: ShadowKind::Lifetime, span: l.span }\n }\n-fn shadower_lifetime(l: &ast::Lifetime) -> Shadower {\n+fn shadower_lifetime(l: &hir::Lifetime) -> Shadower {\n     Shadower { kind: ShadowKind::Lifetime, span: l.span }\n }\n \n@@ -376,7 +376,7 @@ fn signal_shadowing_problem(\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v ast::Block) {\n+fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n \n     struct GatherLabels<'a> {\n         sess: &'a Session,\n@@ -393,11 +393,11 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v ast::Block) {\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n-        fn visit_expr(&mut self, ex: &'v ast::Expr) {\n+        fn visit_expr(&mut self, ex: &'v hir::Expr) {\n             // do not recurse into closures defined in the block\n             // since they are treated as separate fns from the POV of\n             // labels_in_fn\n-            if let ast::ExprClosure(..) = ex.node {\n+            if let hir::ExprClosure(..) = ex.node {\n                 return\n             }\n             if let Some(label) = expression_label(ex) {\n@@ -421,17 +421,15 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v ast::Block) {\n             visit::walk_expr(self, ex)\n         }\n \n-        fn visit_item(&mut self, _: &ast::Item) {\n+        fn visit_item(&mut self, _: &hir::Item) {\n             // do not recurse into items defined in the block\n         }\n     }\n \n-    fn expression_label(ex: &ast::Expr) -> Option<ast::Ident> {\n+    fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n         match ex.node {\n-            ast::ExprWhile(_, _, Some(label))       |\n-            ast::ExprWhileLet(_, _, _, Some(label)) |\n-            ast::ExprForLoop(_, _, _, Some(label))  |\n-            ast::ExprLoop(_, Some(label))          => Some(label),\n+            hir::ExprWhile(_, _, Some(label)) |\n+            hir::ExprLoop(_, Some(label)) => Some(label),\n             _ => None,\n         }\n     }\n@@ -471,8 +469,8 @@ impl<'a> LifetimeContext<'a> {\n     // the function body itself.\n     fn walk_fn<'b>(&mut self,\n                    fk: FnKind,\n-                   fd: &ast::FnDecl,\n-                   fb: &'b ast::Block,\n+                   fd: &hir::FnDecl,\n+                   fb: &'b hir::Block,\n                    _span: Span) {\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _) => {\n@@ -533,7 +531,7 @@ impl<'a> LifetimeContext<'a> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            early_space: subst::ParamSpace,\n-                           generics: &ast::Generics,\n+                           generics: &hir::Generics,\n                            walk: F) where\n         F: FnOnce(&mut LifetimeContext),\n     {\n@@ -553,7 +551,7 @@ impl<'a> LifetimeContext<'a> {\n         });\n     }\n \n-    fn resolve_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n+    fn resolve_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n         // given name or we run out of scopes. If we encounter a code\n@@ -610,7 +608,7 @@ impl<'a> LifetimeContext<'a> {\n \n     fn resolve_free_lifetime_ref(&mut self,\n                                  scope_data: region::DestructionScopeData,\n-                                 lifetime_ref: &ast::Lifetime,\n+                                 lifetime_ref: &hir::Lifetime,\n                                  scope: Scope) {\n         debug!(\"resolve_free_lifetime_ref \\\n                 scope_data: {:?} lifetime_ref: {:?} scope: {:?}\",\n@@ -660,13 +658,13 @@ impl<'a> LifetimeContext<'a> {\n \n     }\n \n-    fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n+    fn unresolved_lifetime_ref(&self, lifetime_ref: &hir::Lifetime) {\n         span_err!(self.sess, lifetime_ref.span, E0261,\n             \"use of undeclared lifetime name `{}`\",\n                     lifetime_ref.name);\n     }\n \n-    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n+    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<hir::LifetimeDef>) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n@@ -701,7 +699,7 @@ impl<'a> LifetimeContext<'a> {\n \n     fn check_lifetime_def_for_shadowing(&self,\n                                         mut old_scope: Scope,\n-                                        lifetime: &ast::Lifetime)\n+                                        lifetime: &hir::Lifetime)\n     {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n@@ -742,7 +740,7 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn insert_lifetime(&mut self,\n-                       lifetime_ref: &ast::Lifetime,\n+                       lifetime_ref: &hir::Lifetime,\n                        def: DefRegion) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n             self.sess.span_bug(lifetime_ref.span,\n@@ -758,9 +756,9 @@ impl<'a> LifetimeContext<'a> {\n     }\n }\n \n-fn search_lifetimes<'a>(lifetimes: &'a Vec<ast::LifetimeDef>,\n-                    lifetime_ref: &ast::Lifetime)\n-                    -> Option<(u32, &'a ast::Lifetime)> {\n+fn search_lifetimes<'a>(lifetimes: &'a Vec<hir::LifetimeDef>,\n+                    lifetime_ref: &hir::Lifetime)\n+                    -> Option<(u32, &'a hir::Lifetime)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n         if lifetime_decl.lifetime.name == lifetime_ref.name {\n             return Some((i as u32, &lifetime_decl.lifetime));\n@@ -771,7 +769,7 @@ fn search_lifetimes<'a>(lifetimes: &'a Vec<ast::LifetimeDef>,\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn early_bound_lifetimes<'a>(generics: &'a ast::Generics) -> Vec<ast::LifetimeDef> {\n+pub fn early_bound_lifetimes<'a>(generics: &'a hir::Generics) -> Vec<hir::LifetimeDef> {\n     let referenced_idents = early_bound_lifetime_names(generics);\n     if referenced_idents.is_empty() {\n         return Vec::new();\n@@ -785,7 +783,7 @@ pub fn early_bound_lifetimes<'a>(generics: &'a ast::Generics) -> Vec<ast::Lifeti\n \n /// Given a set of generic declarations, returns a list of names containing all early bound\n /// lifetime names for those generics. (In fact, this list may also contain other names.)\n-fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n+fn early_bound_lifetime_names(generics: &hir::Generics) -> Vec<ast::Name> {\n     // Create two lists, dividing the lifetimes into early/late bound.\n     // Initially, all of them are considered late, but we will move\n     // things from late into early as we go if we find references to\n@@ -805,13 +803,13 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounds,\n+                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bounds,\n                                                                               ref bounded_ty,\n                                                                               ..}) => {\n                     collector.visit_ty(&**bounded_ty);\n                     visit::walk_ty_param_bounds_helper(&mut collector, bounds);\n                 }\n-                &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n                                                                                 ref bounds,\n                                                                                 ..}) => {\n                     collector.visit_lifetime_ref(lifetime);\n@@ -820,7 +818,7 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n                         collector.visit_lifetime_ref(bound);\n                     }\n                 }\n-                &ast::WherePredicate::EqPredicate(_) => unimplemented!()\n+                &hir::WherePredicate::EqPredicate(_) => unimplemented!()\n             }\n         }\n     }\n@@ -845,7 +843,7 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n     }\n \n     impl<'a, 'v> Visitor<'v> for FreeLifetimeCollector<'a> {\n-        fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n+        fn visit_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n             shuffle(self.early_bound, self.late_bound,\n                     lifetime_ref.name);\n         }"}, {"sha": "08f8eb5685e8267df05d9598b0aa4377e2544da4", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -20,15 +20,16 @@ use middle::privacy::PublicItems;\n use metadata::csearch;\n use syntax::parse::token::InternedString;\n use syntax::codemap::{Span, DUMMY_SP};\n-use syntax::{attr, visit};\n use syntax::ast;\n-use syntax::ast::{Attribute, Block, Crate, FnDecl, NodeId, Variant};\n-use syntax::ast::{Item, Generics, StructField};\n-use syntax::attr::{Stability, AttrMetaMethods};\n-use syntax::visit::{FnKind, Visitor};\n+use syntax::ast::NodeId;\n use syntax::feature_gate::emit_feature_err;\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n+use rustc_front::hir;\n+use rustc_front::hir::{FnDecl, Attribute, Block, Crate, Item, Generics, StructField, Variant};\n+use rustc_front::attr::{self, Stability, AttrMetaMethods};\n+use rustc_front::visit::{self, FnKind, Visitor};\n+\n use std::mem::replace;\n use std::cmp::Ordering;\n \n@@ -166,21 +167,21 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         // stability of the trait. This is WRONG, but expedient to get\n         // libstd stabilized for the 1.0 release.\n         let use_parent = match i.node {\n-            ast::ItemImpl(_, _, _, Some(_), _, _) => false,\n+            hir::ItemImpl(_, _, _, Some(_), _, _) => false,\n             _ => true,\n         };\n \n         // In case of a `pub use <mod>;`, we should not error since the stability\n         // is inherited from the module itself\n         let required = match i.node {\n-            ast::ItemUse(_) => i.vis != ast::Public,\n+            hir::ItemUse(_) => i.vis != hir::Public,\n             _ => true\n         };\n \n         self.annotate(i.id, use_parent, &i.attrs, i.span,\n                       |v| visit::walk_item(v, i), required);\n \n-        if let ast::ItemStruct(ref sd, _) = i.node {\n+        if let hir::ItemStruct(ref sd, _) = i.node {\n             sd.ctor_id.map(|id| {\n                 self.annotate(id, true, &i.attrs, i.span, |_| {}, true)\n             });\n@@ -193,12 +194,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         // a stability attribute, so we don't recurse.\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n         self.annotate(ti.id, true, &ti.attrs, ti.span,\n                       |v| visit::walk_trait_item(v, ti), true);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n         self.annotate(ii.id, true, &ii.attrs, ii.span,\n                       |v| visit::walk_impl_item(v, ii), true);\n     }\n@@ -213,7 +214,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n                       |v| visit::walk_struct_field(v, s), true);\n     }\n \n-    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         self.annotate(i.id, true, &i.attrs, i.span, |_| {}, true);\n     }\n }\n@@ -236,7 +237,7 @@ impl<'tcx> Index<'tcx> {\n         for attr in &krate.attrs {\n             if &attr.name()[..] == \"staged_api\" {\n                 match attr.node.value.node {\n-                    ast::MetaWord(_) => {\n+                    hir::MetaWord(_) => {\n                         attr::mark_used(attr);\n                         is_staged_api = true;\n                     }\n@@ -335,7 +336,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n@@ -346,30 +347,30 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         visit::walk_item(self, item);\n     }\n \n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n+    fn visit_expr(&mut self, ex: &hir::Expr) {\n         check_expr(self.tcx, ex,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_expr(self, ex);\n     }\n \n-    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         check_path(self.tcx, path, id,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_path(self, path)\n     }\n \n-    fn visit_pat(&mut self, pat: &ast::Pat) {\n+    fn visit_pat(&mut self, pat: &hir::Pat) {\n         check_pat(self.tcx, pat,\n                   &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_pat(self, pat)\n     }\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n+pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     match item.node {\n-        ast::ItemExternCrate(_) => {\n+        hir::ItemExternCrate(_) => {\n             // compiler-generated `extern crate` items have a dummy span.\n             if item.span == DUMMY_SP { return }\n \n@@ -384,7 +385,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n         // For implementations of traits, check the stability of each item\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n-        ast::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n+        hir::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n             let trait_did = tcx.def_map.borrow().get(&t.ref_id).unwrap().def_id();\n             let trait_items = tcx.trait_items(trait_did);\n \n@@ -403,24 +404,24 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n+pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     let span;\n     let id = match e.node {\n-        ast::ExprMethodCall(i, _, _) => {\n+        hir::ExprMethodCall(i, _, _) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n             tcx.tables.borrow().method_map[&method_call].def_id\n         }\n-        ast::ExprField(ref base_e, ref field) => {\n+        hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n                 ty::TyStruct(def, _) => def.struct_variant().field_named(field.node.name).did,\n                 _ => tcx.sess.span_bug(e.span,\n                                        \"stability::check_expr: named field access on non-struct\")\n             }\n         }\n-        ast::ExprTupField(ref base_e, ref field) => {\n+        hir::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n                 ty::TyStruct(def, _) => def.struct_variant().fields[field.node].did,\n@@ -430,7 +431,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                                         something other than a tuple or struct\")\n             }\n         }\n-        ast::ExprStruct(_, ref expr_fields, _) => {\n+        hir::ExprStruct(_, ref expr_fields, _) => {\n             let type_ = tcx.expr_ty(e);\n             match type_.sty {\n                 ty::TyStruct(def, _) => {\n@@ -464,7 +465,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n     maybe_do_stability_check(tcx, id, span, cb);\n }\n \n-pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n+pub fn check_path(tcx: &ty::ctxt, path: &hir::Path, id: ast::NodeId,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(def::DefPrimTy(..)) => {}\n@@ -476,7 +477,7 @@ pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n \n }\n \n-pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n+pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n@@ -487,18 +488,18 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     };\n     match pat.node {\n         // Foo(a, b, c)\n-        ast::PatEnum(_, Some(ref pat_fields)) => {\n+        hir::PatEnum(_, Some(ref pat_fields)) => {\n             for (field, struct_field) in pat_fields.iter().zip(&v.fields) {\n                 // a .. pattern is fine, but anything positional is\n                 // not.\n-                if let ast::PatWild(ast::PatWildMulti) = field.node {\n+                if let hir::PatWild(hir::PatWildMulti) = field.node {\n                     continue\n                 }\n                 maybe_do_stability_check(tcx, struct_field.did, field.span, cb)\n             }\n         }\n         // Foo { a, b, c }\n-        ast::PatStruct(_, ref pat_fields, _) => {\n+        hir::PatStruct(_, ref pat_fields, _) => {\n             for field in pat_fields {\n                 let did = v.field_named(field.node.ident.name).did;\n                 maybe_do_stability_check(tcx, did, field.span, cb);"}, {"sha": "a3a903c33933e616f5df27281447eb98c5cd9595", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -31,7 +31,7 @@ use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use std::fmt;\n use syntax::codemap::Span;\n-use syntax::attr::{AttributeMethods, AttrMetaMethods};\n+use rustc_front::attr::{AttributeMethods, AttrMetaMethods};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {"}, {"sha": "544e23c5ffbd50e17034990e08599aebf3c562eb", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -51,7 +51,8 @@ use middle::wf;\n use std::cell::RefCell;\n use std::fmt;\n use std::rc::Rc;\n-use syntax::{abi, ast};\n+use syntax::abi;\n+use rustc_front::hir;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashMap;\n \n@@ -793,7 +794,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match candidate {\n             ImplCandidate(def_id) => {\n                 match self.tcx().trait_impl_polarity(def_id) {\n-                    Some(ast::ImplPolarity::Negative) => return Err(Unimplemented),\n+                    Some(hir::ImplPolarity::Negative) => return Err(Unimplemented),\n                     _ => {}\n                 }\n             }\n@@ -1217,7 +1218,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // provide an impl, but only for suitable `fn` pointers\n             ty::TyBareFn(_, &ty::BareFnTy {\n-                unsafety: ast::Unsafety::Normal,\n+                unsafety: hir::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: _,\n@@ -1676,10 +1677,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match mutbl {\n                             // &mut T is affine and hence never `Copy`\n-                            ast::MutMutable => Err(Unimplemented),\n+                            hir::MutMutable => Err(Unimplemented),\n \n                             // &T is always copyable\n-                            ast::MutImmutable => ok_if(Vec::new()),\n+                            hir::MutImmutable => ok_if(Vec::new()),\n                         }\n                     }\n "}, {"sha": "541bc8896aa3ece4133c0daf30ba9eea878ae3ea", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 256, "deletions": 258, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -35,10 +35,11 @@ pub use self::BuiltinBound::Sized as BoundSized;\n pub use self::BuiltinBound::Copy as BoundCopy;\n pub use self::BuiltinBound::Sync as BoundSync;\n \n-use ast_map::{self, LinkedPath};\n use back::svh::Svh;\n use session::Session;\n use lint;\n+use front::map as ast_map;\n+use front::map::LinkedPath;\n use metadata::csearch;\n use middle;\n use middle::cast;\n@@ -85,12 +86,14 @@ use core::nonzero::NonZero;\n use std::collections::{HashMap, HashSet};\n use rustc_data_structures::ivar;\n use syntax::abi;\n-use syntax::ast::{CrateNum, ItemImpl, ItemTrait};\n-use syntax::ast::{MutImmutable, MutMutable, Name, NodeId, Visibility};\n-use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n+use syntax::ast::{self, CrateNum, Name, NodeId};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n-use syntax::ast;\n+\n+use rustc_front::hir;\n+use rustc_front::hir::{ItemImpl, ItemTrait};\n+use rustc_front::hir::{MutImmutable, MutMutable, Visibility};\n+use rustc_front::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n \n pub type Disr = u64;\n \n@@ -109,6 +112,7 @@ pub struct CrateAnalysis {\n     pub glob_map: Option<GlobMap>,\n }\n \n+\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,\n@@ -143,48 +147,48 @@ pub trait IntTypeExt {\n impl IntTypeExt for attr::IntType {\n     fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            SignedInt(ast::TyI8)      => cx.types.i8,\n-            SignedInt(ast::TyI16)     => cx.types.i16,\n-            SignedInt(ast::TyI32)     => cx.types.i32,\n-            SignedInt(ast::TyI64)     => cx.types.i64,\n-            SignedInt(ast::TyIs)   => cx.types.isize,\n-            UnsignedInt(ast::TyU8)    => cx.types.u8,\n-            UnsignedInt(ast::TyU16)   => cx.types.u16,\n-            UnsignedInt(ast::TyU32)   => cx.types.u32,\n-            UnsignedInt(ast::TyU64)   => cx.types.u64,\n-            UnsignedInt(ast::TyUs) => cx.types.usize,\n+            SignedInt(hir::TyI8)      => cx.types.i8,\n+            SignedInt(hir::TyI16)     => cx.types.i16,\n+            SignedInt(hir::TyI32)     => cx.types.i32,\n+            SignedInt(hir::TyI64)     => cx.types.i64,\n+            SignedInt(hir::TyIs)   => cx.types.isize,\n+            UnsignedInt(hir::TyU8)    => cx.types.u8,\n+            UnsignedInt(hir::TyU16)   => cx.types.u16,\n+            UnsignedInt(hir::TyU32)   => cx.types.u32,\n+            UnsignedInt(hir::TyU64)   => cx.types.u64,\n+            UnsignedInt(hir::TyUs) => cx.types.usize,\n         }\n     }\n \n     fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n         match *self {\n-            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n \n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n         }\n     }\n \n     fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n         match *self {\n-            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n \n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n         }\n     }\n \n@@ -196,18 +200,18 @@ impl IntTypeExt for attr::IntType {\n             // SignedInt repr means we *want* to reinterpret the bits\n             // treating the highest bit of Disr as a sign-bit, so\n             // cast to i64 before range-checking.\n-            SignedInt(ast::TyI8)    => add1!((val as i64).to_i8()),\n-            SignedInt(ast::TyI16)   => add1!((val as i64).to_i16()),\n-            SignedInt(ast::TyI32)   => add1!((val as i64).to_i32()),\n-            SignedInt(ast::TyI64)   => add1!(Some(val as i64)),\n+            SignedInt(hir::TyI8)    => add1!((val as i64).to_i8()),\n+            SignedInt(hir::TyI16)   => add1!((val as i64).to_i16()),\n+            SignedInt(hir::TyI32)   => add1!((val as i64).to_i32()),\n+            SignedInt(hir::TyI64)   => add1!(Some(val as i64)),\n \n-            UnsignedInt(ast::TyU8)  => add1!(val.to_u8()),\n-            UnsignedInt(ast::TyU16) => add1!(val.to_u16()),\n-            UnsignedInt(ast::TyU32) => add1!(val.to_u32()),\n-            UnsignedInt(ast::TyU64) => add1!(Some(val)),\n+            UnsignedInt(hir::TyU8)  => add1!(val.to_u8()),\n+            UnsignedInt(hir::TyU16) => add1!(val.to_u16()),\n+            UnsignedInt(hir::TyU32) => add1!(val.to_u32()),\n+            UnsignedInt(hir::TyU64) => add1!(Some(val)),\n \n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n         }\n     }\n \n@@ -216,17 +220,17 @@ impl IntTypeExt for attr::IntType {\n     // full range from `i64::MIN` through `u64::MAX`.\n     fn disr_string(&self, val: Disr) -> String {\n         match *self {\n-            SignedInt(ast::TyI8)    => format!(\"{}\", val as i8 ),\n-            SignedInt(ast::TyI16)   => format!(\"{}\", val as i16),\n-            SignedInt(ast::TyI32)   => format!(\"{}\", val as i32),\n-            SignedInt(ast::TyI64)   => format!(\"{}\", val as i64),\n-            UnsignedInt(ast::TyU8)  => format!(\"{}\", val as u8 ),\n-            UnsignedInt(ast::TyU16) => format!(\"{}\", val as u16),\n-            UnsignedInt(ast::TyU32) => format!(\"{}\", val as u32),\n-            UnsignedInt(ast::TyU64) => format!(\"{}\", val as u64),\n+            SignedInt(hir::TyI8)    => format!(\"{}\", val as i8 ),\n+            SignedInt(hir::TyI16)   => format!(\"{}\", val as i16),\n+            SignedInt(hir::TyI32)   => format!(\"{}\", val as i32),\n+            SignedInt(hir::TyI64)   => format!(\"{}\", val as i64),\n+            UnsignedInt(hir::TyU8)  => format!(\"{}\", val as u8 ),\n+            UnsignedInt(hir::TyU16) => format!(\"{}\", val as u16),\n+            UnsignedInt(hir::TyU32) => format!(\"{}\", val as u32),\n+            UnsignedInt(hir::TyU64) => format!(\"{}\", val as u64),\n \n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n         }\n     }\n \n@@ -236,17 +240,17 @@ impl IntTypeExt for attr::IntType {\n         }\n         let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n         match *self {\n-            SignedInt(ast::TyI8)    => add1!(val as i8 ),\n-            SignedInt(ast::TyI16)   => add1!(val as i16),\n-            SignedInt(ast::TyI32)   => add1!(val as i32),\n-            SignedInt(ast::TyI64)   => add1!(val as i64),\n-            UnsignedInt(ast::TyU8)  => add1!(val as u8 ),\n-            UnsignedInt(ast::TyU16) => add1!(val as u16),\n-            UnsignedInt(ast::TyU32) => add1!(val as u32),\n-            UnsignedInt(ast::TyU64) => add1!(val as u64),\n+            SignedInt(hir::TyI8)    => add1!(val as i8 ),\n+            SignedInt(hir::TyI16)   => add1!(val as i16),\n+            SignedInt(hir::TyI32)   => add1!(val as i32),\n+            SignedInt(hir::TyI64)   => add1!(val as i64),\n+            UnsignedInt(hir::TyU8)  => add1!(val as u8 ),\n+            UnsignedInt(hir::TyU16) => add1!(val as u16),\n+            UnsignedInt(hir::TyU32) => add1!(val as u32),\n+            UnsignedInt(hir::TyU64) => add1!(val as u64),\n \n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n         }\n     }\n }\n@@ -294,15 +298,15 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n         }\n     }\n \n-    pub fn name(&self) -> ast::Name {\n+    pub fn name(&self) -> Name {\n         match *self {\n             ConstTraitItem(ref associated_const) => associated_const.name,\n             MethodTraitItem(ref method) => method.name,\n             TypeTraitItem(ref associated_type) => associated_type.name,\n         }\n     }\n \n-    pub fn vis(&self) -> ast::Visibility {\n+    pub fn vis(&self) -> hir::Visibility {\n         match *self {\n             ConstTraitItem(ref associated_const) => associated_const.vis,\n             MethodTraitItem(ref method) => method.vis,\n@@ -345,12 +349,12 @@ impl ImplOrTraitItemId {\n \n #[derive(Clone, Debug)]\n pub struct Method<'tcx> {\n-    pub name: ast::Name,\n+    pub name: Name,\n     pub generics: Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n     pub fty: BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n-    pub vis: ast::Visibility,\n+    pub vis: hir::Visibility,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n \n@@ -359,12 +363,12 @@ pub struct Method<'tcx> {\n }\n \n impl<'tcx> Method<'tcx> {\n-    pub fn new(name: ast::Name,\n+    pub fn new(name: Name,\n                generics: ty::Generics<'tcx>,\n                predicates: GenericPredicates<'tcx>,\n                fty: BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n-               vis: ast::Visibility,\n+               vis: hir::Visibility,\n                def_id: DefId,\n                container: ImplOrTraitItemContainer,\n                provided_source: Option<DefId>)\n@@ -392,29 +396,30 @@ impl<'tcx> Method<'tcx> {\n \n #[derive(Clone, Copy, Debug)]\n pub struct AssociatedConst<'tcx> {\n-    pub name: ast::Name,\n+    pub name: Name,\n     pub ty: Ty<'tcx>,\n-    pub vis: ast::Visibility,\n+    pub vis: hir::Visibility,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n     pub default: Option<DefId>,\n }\n \n #[derive(Clone, Copy, Debug)]\n pub struct AssociatedType<'tcx> {\n-    pub name: ast::Name,\n+    pub name: Name,\n     pub ty: Option<Ty<'tcx>>,\n-    pub vis: ast::Visibility,\n+    pub vis: hir::Visibility,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n-    pub mutbl: ast::Mutability,\n+    pub mutbl: hir::Mutability,\n }\n \n+\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n@@ -526,11 +531,11 @@ pub struct AutoDerefRef<'tcx> {\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum AutoRef<'tcx> {\n     /// Convert from T to &T.\n-    AutoPtr(&'tcx Region, ast::Mutability),\n+    AutoPtr(&'tcx Region, hir::Mutability),\n \n     /// Convert from T to *T.\n     /// Value to thin pointer.\n-    AutoUnsafe(ast::Mutability),\n+    AutoUnsafe(hir::Mutability),\n }\n \n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n@@ -561,19 +566,19 @@ pub struct MethodCallee<'tcx> {\n /// our key.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct MethodCall {\n-    pub expr_id: ast::NodeId,\n+    pub expr_id: NodeId,\n     pub autoderef: u32\n }\n \n impl MethodCall {\n-    pub fn expr(id: ast::NodeId) -> MethodCall {\n+    pub fn expr(id: NodeId) -> MethodCall {\n         MethodCall {\n             expr_id: id,\n             autoderef: 0\n         }\n     }\n \n-    pub fn autoderef(expr_id: ast::NodeId, autoderef: u32) -> MethodCall {\n+    pub fn autoderef(expr_id: NodeId, autoderef: u32) -> MethodCall {\n         MethodCall {\n             expr_id: expr_id,\n             autoderef: 1 + autoderef\n@@ -622,7 +627,7 @@ pub struct TransmuteRestriction<'tcx> {\n     pub substituted_to: Ty<'tcx>,\n \n     /// NodeId of the transmute intrinsic.\n-    pub id: ast::NodeId,\n+    pub id: NodeId,\n }\n \n /// Internal storage\n@@ -828,11 +833,11 @@ pub struct ctxt<'tcx> {\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n     /// These caches are used by const_eval when decoding external constants.\n-    pub extern_const_statics: RefCell<DefIdMap<ast::NodeId>>,\n-    pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n-    pub extern_const_fns: RefCell<DefIdMap<ast::NodeId>>,\n+    pub extern_const_statics: RefCell<DefIdMap<NodeId>>,\n+    pub extern_const_variants: RefCell<DefIdMap<NodeId>>,\n+    pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n \n-    pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n+    pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n \n     /// The types that must be asserted to be the same size for `transmute`\n@@ -1367,14 +1372,14 @@ impl<'tcx> Borrow<TypeVariants<'tcx>> for InternedTy<'tcx> {\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct BareFnTy<'tcx> {\n-    pub unsafety: ast::Unsafety,\n+    pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n     pub sig: PolyFnSig<'tcx>,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct ClosureTy<'tcx> {\n-    pub unsafety: ast::Unsafety,\n+    pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n     pub sig: PolyFnSig<'tcx>,\n }\n@@ -1447,7 +1452,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n     pub idx: u32,\n-    pub name: ast::Name,\n+    pub name: Name,\n }\n \n /// A [De Bruijn index][dbi] is a standard means of representing\n@@ -1595,19 +1600,19 @@ pub enum Region {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n-    pub param_id: ast::NodeId,\n+    pub param_id: NodeId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n-    pub name: ast::Name,\n+    pub name: Name,\n }\n \n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct UpvarId {\n-    pub var_id: ast::NodeId,\n-    pub closure_expr_id: ast::NodeId,\n+    pub var_id: NodeId,\n+    pub closure_expr_id: NodeId,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n@@ -1742,7 +1747,7 @@ pub enum BoundRegion {\n     ///\n     /// The def-id is needed to distinguish free regions in\n     /// the event of shadowing.\n-    BrNamed(DefId, ast::Name),\n+    BrNamed(DefId, Name),\n \n     /// Fresh bound identifiers created during GLB computations.\n     BrFresh(u32),\n@@ -1764,21 +1769,21 @@ pub enum TypeVariants<'tcx> {\n     TyChar,\n \n     /// A primitive signed integer type. For example, `i32`.\n-    TyInt(ast::IntTy),\n+    TyInt(hir::IntTy),\n \n     /// A primitive unsigned integer type. For example, `u32`.\n-    TyUint(ast::UintTy),\n+    TyUint(hir::UintTy),\n \n     /// A primitive floating-point type. For example, `f64`.\n-    TyFloat(ast::FloatTy),\n+    TyFloat(hir::FloatTy),\n \n     /// An enumerated type, defined with `enum`.\n     ///\n     /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n     /// That is, even after substitution it is possible that there are type\n     /// variables. This happens when the `TyEnum` corresponds to an enum\n     /// definition and not a concrete use of it. To get the correct `TyEnum`\n-    /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n+    /// from the tcx, use the `NodeId` from the `hir::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n     /// well.\n     TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n@@ -2084,8 +2089,8 @@ impl<T> Binder<T> {\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum IntVarValue {\n-    IntType(ast::IntTy),\n-    UintType(ast::UintTy),\n+    IntType(hir::IntTy),\n+    UintType(hir::UintTy),\n }\n \n #[derive(Clone, Copy, Debug)]\n@@ -2098,7 +2103,7 @@ pub struct ExpectedFound<T> {\n #[derive(Clone, Debug)]\n pub enum TypeError<'tcx> {\n     Mismatch,\n-    UnsafetyMismatch(ExpectedFound<ast::Unsafety>),\n+    UnsafetyMismatch(ExpectedFound<hir::Unsafety>),\n     AbiMismatch(ExpectedFound<abi::Abi>),\n     Mutability,\n     BoxMutability,\n@@ -2117,13 +2122,13 @@ pub enum TypeError<'tcx> {\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntegerAsChar,\n     IntMismatch(ExpectedFound<IntVarValue>),\n-    FloatMismatch(ExpectedFound<ast::FloatTy>),\n+    FloatMismatch(ExpectedFound<hir::FloatTy>),\n     Traits(ExpectedFound<DefId>),\n     BuiltinBoundsMismatch(ExpectedFound<BuiltinBounds>),\n     VariadicMismatch(ExpectedFound<bool>),\n     CyclicTy,\n     ConvergenceMismatch(ExpectedFound<bool>),\n-    ProjectionNameMismatched(ExpectedFound<ast::Name>),\n+    ProjectionNameMismatched(ExpectedFound<Name>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>)\n }\n@@ -2316,7 +2321,7 @@ pub enum ObjectLifetimeDefault {\n \n #[derive(Clone)]\n pub struct TypeParameterDef<'tcx> {\n-    pub name: ast::Name,\n+    pub name: Name,\n     pub def_id: DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n@@ -2327,7 +2332,7 @@ pub struct TypeParameterDef<'tcx> {\n \n #[derive(Clone)]\n pub struct RegionParameterDef {\n-    pub name: ast::Name,\n+    pub name: Name,\n     pub def_id: DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n@@ -2349,7 +2354,7 @@ impl RegionParameterDef {\n }\n \n /// Information about the formal type/lifetime parameters associated\n-/// with an item or method. Analogous to ast::Generics.\n+/// with an item or method. Analogous to hir::Generics.\n #[derive(Clone, Debug)]\n pub struct Generics<'tcx> {\n     pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n@@ -2583,11 +2588,11 @@ pub struct ProjectionPredicate<'tcx> {\n pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n-    pub fn item_name(&self) -> ast::Name {\n+    pub fn item_name(&self) -> Name {\n         self.0.projection_ty.item_name // safe to skip the binder to access a name\n     }\n \n-    pub fn sort_key(&self) -> (DefId, ast::Name) {\n+    pub fn sort_key(&self) -> (DefId, Name) {\n         self.0.projection_ty.sort_key()\n     }\n }\n@@ -2600,11 +2605,11 @@ pub struct ProjectionTy<'tcx> {\n     pub trait_ref: ty::TraitRef<'tcx>,\n \n     /// The name `N` of the associated type.\n-    pub item_name: ast::Name,\n+    pub item_name: Name,\n }\n \n impl<'tcx> ProjectionTy<'tcx> {\n-    pub fn sort_key(&self) -> (DefId, ast::Name) {\n+    pub fn sort_key(&self) -> (DefId, Name) {\n         (self.trait_ref.def_id, self.item_name)\n     }\n }\n@@ -2873,7 +2878,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n-                    ast::TypeImplItem(_) => {\n+                    hir::TypeImplItem(_) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n                         let impl_id = cx.map.get_parent(id);\n@@ -2885,7 +2890,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            &predicates,\n                                                            id)\n                     }\n-                    ast::ConstImplItem(_, _) => {\n+                    hir::ConstImplItem(_, _) => {\n                         let def_id = DefId::local(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n@@ -2894,7 +2899,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            &predicates,\n                                                            id)\n                     }\n-                    ast::MethodImplItem(_, ref body) => {\n+                    hir::MethodImplItem(_, ref body) => {\n                         let method_def_id = DefId::local(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n@@ -2913,12 +2918,11 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    ast::MacImplItem(_) => cx.sess.bug(\"unexpanded macro\")\n                 }\n             }\n             Some(ast_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n-                    ast::TypeTraitItem(..) => {\n+                    hir::TypeTraitItem(..) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n                         let trait_id = cx.map.get_parent(id);\n@@ -2930,7 +2934,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            &predicates,\n                                                            id)\n                     }\n-                    ast::ConstTraitItem(..) => {\n+                    hir::ConstTraitItem(..) => {\n                         let def_id = DefId::local(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n@@ -2939,12 +2943,13 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            &predicates,\n                                                            id)\n                     }\n-                    ast::MethodTraitItem(_, ref body) => {\n+                    hir::MethodTraitItem(_, ref body) => {\n                         // for the body-id, use the id of the body\n                         // block, unless this is a trait method with\n                         // no default, then fallback to the method id.\n                         let body_id = body.as_ref().map(|b| b.id).unwrap_or(id);\n                         let method_def_id = DefId::local(id);\n+\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n@@ -2967,7 +2972,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             }\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    ast::ItemFn(_, _, _, _, _, ref body) => {\n+                    hir::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n                         let fn_def_id = DefId::local(id);\n                         let fn_scheme = cx.lookup_item_type(fn_def_id);\n@@ -2978,11 +2983,11 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            &fn_predicates,\n                                                            body.id)\n                     }\n-                    ast::ItemEnum(..) |\n-                    ast::ItemStruct(..) |\n-                    ast::ItemImpl(..) |\n-                    ast::ItemConst(..) |\n-                    ast::ItemStatic(..) => {\n+                    hir::ItemEnum(..) |\n+                    hir::ItemStruct(..) |\n+                    hir::ItemImpl(..) |\n+                    hir::ItemConst(..) |\n+                    hir::ItemStatic(..) => {\n                         let def_id = DefId::local(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n@@ -2991,7 +2996,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            &predicates,\n                                                            id)\n                     }\n-                    ast::ItemTrait(..) => {\n+                    hir::ItemTrait(..) => {\n                         let def_id = DefId::local(id);\n                         let trait_def = cx.lookup_trait_def(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n@@ -3061,8 +3066,8 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n \n #[derive(Copy, Clone)]\n pub enum CopyImplementationError {\n-    FieldDoesNotImplementCopy(ast::Name),\n-    VariantDoesNotImplementCopy(ast::Name),\n+    FieldDoesNotImplementCopy(Name),\n+    VariantDoesNotImplementCopy(Name),\n     TypeIsStructural,\n     TypeHasDestructor,\n }\n@@ -3104,7 +3109,7 @@ bitflags! {\n \n /// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n-    pub unsafety: ast::Unsafety,\n+    pub unsafety: hir::Unsafety,\n \n     /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n     /// attribute, indicating that it should be used with `Foo()`\n@@ -3123,7 +3128,7 @@ pub struct TraitDef<'tcx> {\n \n     /// A list of the associated types defined in this trait. Useful\n     /// for resolving `X::Foo` type markers.\n-    pub associated_type_names: Vec<ast::Name>,\n+    pub associated_type_names: Vec<Name>,\n \n     // Impls of this trait. To allow for quicker lookup, the impls are indexed\n     // by a simplified version of their Self type: impls with a simplifiable\n@@ -3283,7 +3288,7 @@ pub struct FieldDefData<'tcx, 'container: 'tcx> {\n     /// special_idents::unnamed_field.name\n     /// if this is a tuple-like field\n     pub name: Name,\n-    pub vis: ast::Visibility,\n+    pub vis: hir::Visibility,\n     /// TyIVar is used here to allow for variance (see the doc at\n     /// AdtDefData).\n     ty: TyIVar<'tcx, 'container>\n@@ -3532,7 +3537,7 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n-               vis: ast::Visibility) -> Self {\n+               vis: hir::Visibility) -> Self {\n         FieldDefData {\n             did: did,\n             name: name,\n@@ -3613,18 +3618,18 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n             err: mk(TyError),\n-            isize: mk(TyInt(ast::TyIs)),\n-            i8: mk(TyInt(ast::TyI8)),\n-            i16: mk(TyInt(ast::TyI16)),\n-            i32: mk(TyInt(ast::TyI32)),\n-            i64: mk(TyInt(ast::TyI64)),\n-            usize: mk(TyUint(ast::TyUs)),\n-            u8: mk(TyUint(ast::TyU8)),\n-            u16: mk(TyUint(ast::TyU16)),\n-            u32: mk(TyUint(ast::TyU32)),\n-            u64: mk(TyUint(ast::TyU64)),\n-            f32: mk(TyFloat(ast::TyF32)),\n-            f64: mk(TyFloat(ast::TyF64)),\n+            isize: mk(TyInt(hir::TyIs)),\n+            i8: mk(TyInt(hir::TyI8)),\n+            i16: mk(TyInt(hir::TyI16)),\n+            i32: mk(TyInt(hir::TyI32)),\n+            i64: mk(TyInt(hir::TyI64)),\n+            usize: mk(TyUint(hir::TyUs)),\n+            u8: mk(TyUint(hir::TyU8)),\n+            u16: mk(TyUint(hir::TyU16)),\n+            u32: mk(TyUint(hir::TyU32)),\n+            u64: mk(TyUint(hir::TyU64)),\n+            f32: mk(TyFloat(hir::TyF32)),\n+            f64: mk(TyFloat(hir::TyF64)),\n         }\n     }\n }\n@@ -3913,9 +3918,9 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(&self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n-        assert_eq!(bare_fn.unsafety, ast::Unsafety::Normal);\n+        assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n         let unsafe_fn_ty_a = self.mk_bare_fn(ty::BareFnTy {\n-            unsafety: ast::Unsafety::Unsafe,\n+            unsafety: hir::Unsafety::Unsafe,\n             abi: bare_fn.abi,\n             sig: bare_fn.sig.clone()\n         });\n@@ -3955,17 +3960,17 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn type_parameter_def(&self,\n-                              node_id: ast::NodeId)\n+                              node_id: NodeId)\n                               -> TypeParameterDef<'tcx>\n     {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn pat_contains_ref_binding(&self, pat: &ast::Pat) -> Option<ast::Mutability> {\n+    pub fn pat_contains_ref_binding(&self, pat: &hir::Pat) -> Option<hir::Mutability> {\n         pat_util::pat_contains_ref_binding(&self.def_map, pat)\n     }\n \n-    pub fn arm_contains_ref_binding(&self, arm: &ast::Arm) -> Option<ast::Mutability> {\n+    pub fn arm_contains_ref_binding(&self, arm: &hir::Arm) -> Option<hir::Mutability> {\n         pat_util::arm_contains_ref_binding(&self.def_map, arm)\n     }\n \n@@ -4003,30 +4008,30 @@ impl<'tcx> ctxt<'tcx> {\n         ctxt::intern_ty(&self.arenas.type_, &self.interner, st)\n     }\n \n-    pub fn mk_mach_int(&self, tm: ast::IntTy) -> Ty<'tcx> {\n+    pub fn mk_mach_int(&self, tm: hir::IntTy) -> Ty<'tcx> {\n         match tm {\n-            ast::TyIs   => self.types.isize,\n-            ast::TyI8   => self.types.i8,\n-            ast::TyI16  => self.types.i16,\n-            ast::TyI32  => self.types.i32,\n-            ast::TyI64  => self.types.i64,\n+            hir::TyIs   => self.types.isize,\n+            hir::TyI8   => self.types.i8,\n+            hir::TyI16  => self.types.i16,\n+            hir::TyI32  => self.types.i32,\n+            hir::TyI64  => self.types.i64,\n         }\n     }\n \n-    pub fn mk_mach_uint(&self, tm: ast::UintTy) -> Ty<'tcx> {\n+    pub fn mk_mach_uint(&self, tm: hir::UintTy) -> Ty<'tcx> {\n         match tm {\n-            ast::TyUs   => self.types.usize,\n-            ast::TyU8   => self.types.u8,\n-            ast::TyU16  => self.types.u16,\n-            ast::TyU32  => self.types.u32,\n-            ast::TyU64  => self.types.u64,\n+            hir::TyUs   => self.types.usize,\n+            hir::TyU8   => self.types.u8,\n+            hir::TyU16  => self.types.u16,\n+            hir::TyU32  => self.types.u32,\n+            hir::TyU64  => self.types.u64,\n         }\n     }\n \n-    pub fn mk_mach_float(&self, tm: ast::FloatTy) -> Ty<'tcx> {\n+    pub fn mk_mach_float(&self, tm: hir::FloatTy) -> Ty<'tcx> {\n         match tm {\n-            ast::TyF32  => self.types.f32,\n-            ast::TyF64  => self.types.f64,\n+            hir::TyF32  => self.types.f32,\n+            hir::TyF64  => self.types.f64,\n         }\n     }\n \n@@ -4056,19 +4061,19 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn mk_mut_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: ast::MutMutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n     pub fn mk_imm_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: ast::MutImmutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n     pub fn mk_mut_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: ast::MutMutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n     pub fn mk_imm_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: ast::MutImmutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n     pub fn mk_nil_ptr(&self) -> Ty<'tcx> {\n@@ -4107,7 +4112,7 @@ impl<'tcx> ctxt<'tcx> {\n                       output: Ty<'tcx>) -> Ty<'tcx> {\n         let input_args = input_tys.iter().cloned().collect();\n         self.mk_fn(Some(def_id), self.mk_bare_fn(BareFnTy {\n-            unsafety: ast::Unsafety::Normal,\n+            unsafety: hir::Unsafety::Normal,\n             abi: abi::Rust,\n             sig: ty::Binder(FnSig {\n                 inputs: input_args,\n@@ -4133,7 +4138,7 @@ impl<'tcx> ctxt<'tcx> {\n \n     pub fn mk_projection(&self,\n                          trait_ref: TraitRef<'tcx>,\n-                         item_name: ast::Name)\n+                         item_name: Name)\n                          -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n@@ -4182,7 +4187,7 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn mk_param(&self,\n                     space: subst::ParamSpace,\n                     index: u32,\n-                    name: ast::Name) -> Ty<'tcx> {\n+                    name: Name) -> Ty<'tcx> {\n         self.mk_ty(TyParam(ParamTy { space: space, idx: index, name: name }))\n     }\n \n@@ -4304,7 +4309,7 @@ impl<'tcx> TyS<'tcx> {\n impl ParamTy {\n     pub fn new(space: subst::ParamSpace,\n                index: u32,\n-               name: ast::Name)\n+               name: Name)\n                -> ParamTy {\n         ParamTy { space: space, idx: index, name: name }\n     }\n@@ -4398,7 +4403,7 @@ impl<'tcx> TyS<'tcx> {\n     pub fn sequence_element_type(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n-            TyStr => cx.mk_mach_uint(ast::TyU8),\n+            TyStr => cx.mk_mach_uint(hir::TyU8),\n             _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n                                       self)),\n         }\n@@ -4646,7 +4651,7 @@ impl<'tcx> TyS<'tcx> {\n \n             let result = match ty.sty {\n                 // usize and isize are ffi-unsafe\n-                TyUint(ast::TyUs) | TyInt(ast::TyIs) => {\n+                TyUint(hir::TyUs) | TyInt(hir::TyIs) => {\n                     TC::None\n                 }\n \n@@ -4761,11 +4766,11 @@ impl<'tcx> TyS<'tcx> {\n         let result = match self.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyRawPtr(..) | TyBareFn(..) | TyRef(_, TypeAndMut {\n-                mutbl: ast::MutImmutable, ..\n+                mutbl: hir::MutImmutable, ..\n             }) => Some(false),\n \n             TyStr | TyBox(..) | TyRef(_, TypeAndMut {\n-                mutbl: ast::MutMutable, ..\n+                mutbl: hir::MutMutable, ..\n             }) => Some(true),\n \n             TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n@@ -5012,7 +5017,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_uint(&self) -> bool {\n         match self.sty {\n-            TyInfer(IntVar(_)) | TyUint(ast::TyUs) => true,\n+            TyInfer(IntVar(_)) | TyUint(hir::TyUs) => true,\n             _ => false\n         }\n     }\n@@ -5058,7 +5063,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n-            TyInt(ast::TyIs) | TyUint(ast::TyUs) => false,\n+            TyInt(hir::TyIs) | TyUint(hir::TyUs) => false,\n             TyInt(..) | TyUint(..) | TyFloat(..) => true,\n             _ => false\n         }\n@@ -5073,7 +5078,7 @@ impl<'tcx> TyS<'tcx> {\n             TyBox(ty) => {\n                 Some(TypeAndMut {\n                     ty: ty,\n-                    mutbl: ast::MutImmutable,\n+                    mutbl: hir::MutImmutable,\n                 })\n             },\n             TyRef(_, mt) => Some(mt),\n@@ -5124,7 +5129,7 @@ impl<'tcx> TyS<'tcx> {\n     /// See `expr_ty_adjusted`\n     pub fn adjust<F>(&'tcx self, cx: &ctxt<'tcx>,\n                      span: Span,\n-                     expr_id: ast::NodeId,\n+                     expr_id: NodeId,\n                      adjustment: Option<&AutoAdjustment<'tcx>>,\n                      mut method_type: F)\n                      -> Ty<'tcx> where\n@@ -5423,26 +5428,26 @@ fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n }\n \n impl BorrowKind {\n-    pub fn from_mutbl(m: ast::Mutability) -> BorrowKind {\n+    pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {\n-            ast::MutMutable => MutBorrow,\n-            ast::MutImmutable => ImmBorrow,\n+            hir::MutMutable => MutBorrow,\n+            hir::MutImmutable => ImmBorrow,\n         }\n     }\n \n     /// Returns a mutability `m` such that an `&m T` pointer could be used to obtain this borrow\n     /// kind. Because borrow kinds are richer than mutabilities, we sometimes have to pick a\n     /// mutability that is stronger than necessary so that it at least *would permit* the borrow in\n     /// question.\n-    pub fn to_mutbl_lossy(self) -> ast::Mutability {\n+    pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            MutBorrow => ast::MutMutable,\n-            ImmBorrow => ast::MutImmutable,\n+            MutBorrow => hir::MutMutable,\n+            ImmBorrow => hir::MutImmutable,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            UniqueImmBorrow => ast::MutMutable,\n+            UniqueImmBorrow => hir::MutMutable,\n         }\n     }\n \n@@ -5482,7 +5487,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// For an enum `t`, `variant` must be some def id.\n     pub fn named_element_ty(&self,\n                             ty: Ty<'tcx>,\n-                            n: ast::Name,\n+                            n: Name,\n                             variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n             (&TyStruct(def, substs), None) => {\n@@ -5495,7 +5500,7 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn node_id_to_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n            Some(ty) => ty,\n            None => self.sess.bug(\n@@ -5504,11 +5509,11 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn node_id_to_type_opt(&self, id: ast::NodeId) -> Option<Ty<'tcx>> {\n+    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n         self.tables.borrow().node_types.get(&id).cloned()\n     }\n \n-    pub fn node_id_item_substs(&self, id: ast::NodeId) -> ItemSubsts<'tcx> {\n+    pub fn node_id_item_substs(&self, id: NodeId) -> ItemSubsts<'tcx> {\n         match self.tables.borrow().item_substs.get(&id) {\n             None => ItemSubsts::empty(),\n             Some(ts) => ts.clone(),\n@@ -5517,10 +5522,10 @@ impl<'tcx> ctxt<'tcx> {\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(&self, pat: &ast::Pat) -> Ty<'tcx> {\n+    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n         self.node_id_to_type(pat.id)\n     }\n-    pub fn pat_ty_opt(&self, pat: &ast::Pat) -> Option<Ty<'tcx>> {\n+    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n         self.node_id_to_type_opt(pat.id)\n     }\n \n@@ -5534,11 +5539,11 @@ impl<'tcx> ctxt<'tcx> {\n     // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n         self.node_id_to_type(expr.id)\n     }\n \n-    pub fn expr_ty_opt(&self, expr: &ast::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n         self.node_id_to_type_opt(expr.id)\n     }\n \n@@ -5551,7 +5556,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// hard to do, I just hate that code so much I didn't want to touch it\n     /// unless it was to fix it properly, which seemed a distraction from the\n     /// thread at hand! -nmatsakis\n-    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n         self.expr_ty(expr)\n             .adjust(self, expr.span, expr.id,\n                     self.tables.borrow().adjustments.get(&expr.id),\n@@ -5580,7 +5585,7 @@ impl<'tcx> ctxt<'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    ast::PatIdent(_, ref path1, _) => path1.node.name.as_str(),\n+                    hir::PatIdent(_, ref path1, _) => path1.node.name.as_str(),\n                     _ => {\n                         self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\", id, pat));\n                     },\n@@ -5590,7 +5595,7 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn resolve_expr(&self, expr: &ast::Expr) -> def::Def {\n+    pub fn resolve_expr(&self, expr: &hir::Expr) -> def::Def {\n         match self.def_map.borrow().get(&expr.id) {\n             Some(def) => def.full_def(),\n             None => {\n@@ -5600,9 +5605,9 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn expr_is_lval(&self, expr: &ast::Expr) -> bool {\n+    pub fn expr_is_lval(&self, expr: &hir::Expr) -> bool {\n          match expr.node {\n-            ast::ExprPath(..) => {\n+            hir::ExprPath(..) => {\n                 // We can't use resolve_expr here, as this needs to run on broken\n                 // programs. We don't need to through - associated items are all\n                 // rvalues.\n@@ -5624,51 +5629,42 @@ impl<'tcx> ctxt<'tcx> {\n                 }\n             }\n \n-            ast::ExprUnary(ast::UnDeref, _) |\n-            ast::ExprField(..) |\n-            ast::ExprTupField(..) |\n-            ast::ExprIndex(..) => {\n+            hir::ExprUnary(hir::UnDeref, _) |\n+            hir::ExprField(..) |\n+            hir::ExprTupField(..) |\n+            hir::ExprIndex(..) => {\n                 true\n             }\n \n-            ast::ExprCall(..) |\n-            ast::ExprMethodCall(..) |\n-            ast::ExprStruct(..) |\n-            ast::ExprRange(..) |\n-            ast::ExprTup(..) |\n-            ast::ExprIf(..) |\n-            ast::ExprMatch(..) |\n-            ast::ExprClosure(..) |\n-            ast::ExprBlock(..) |\n-            ast::ExprRepeat(..) |\n-            ast::ExprVec(..) |\n-            ast::ExprBreak(..) |\n-            ast::ExprAgain(..) |\n-            ast::ExprRet(..) |\n-            ast::ExprWhile(..) |\n-            ast::ExprLoop(..) |\n-            ast::ExprAssign(..) |\n-            ast::ExprInlineAsm(..) |\n-            ast::ExprAssignOp(..) |\n-            ast::ExprLit(_) |\n-            ast::ExprUnary(..) |\n-            ast::ExprBox(..) |\n-            ast::ExprAddrOf(..) |\n-            ast::ExprBinary(..) |\n-            ast::ExprCast(..) => {\n+            hir::ExprCall(..) |\n+            hir::ExprMethodCall(..) |\n+            hir::ExprStruct(..) |\n+            hir::ExprRange(..) |\n+            hir::ExprTup(..) |\n+            hir::ExprIf(..) |\n+            hir::ExprMatch(..) |\n+            hir::ExprClosure(..) |\n+            hir::ExprBlock(..) |\n+            hir::ExprRepeat(..) |\n+            hir::ExprVec(..) |\n+            hir::ExprBreak(..) |\n+            hir::ExprAgain(..) |\n+            hir::ExprRet(..) |\n+            hir::ExprWhile(..) |\n+            hir::ExprLoop(..) |\n+            hir::ExprAssign(..) |\n+            hir::ExprInlineAsm(..) |\n+            hir::ExprAssignOp(..) |\n+            hir::ExprLit(_) |\n+            hir::ExprUnary(..) |\n+            hir::ExprBox(..) |\n+            hir::ExprAddrOf(..) |\n+            hir::ExprBinary(..) |\n+            hir::ExprCast(..) => {\n                 false\n             }\n \n-            ast::ExprParen(ref e) => self.expr_is_lval(e),\n-\n-            ast::ExprIfLet(..) |\n-            ast::ExprWhileLet(..) |\n-            ast::ExprForLoop(..) |\n-            ast::ExprMac(..) => {\n-                self.sess.span_bug(\n-                    expr.span,\n-                    \"macro expression remains after expansion\");\n-            }\n+            hir::ExprParen(ref e) => self.expr_is_lval(e),\n         }\n     }\n \n@@ -5768,7 +5764,7 @@ impl<'tcx> ctxt<'tcx> {\n         if id.is_local() {\n             if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id.node).node {\n                 ms.iter().filter_map(|ti| {\n-                    if let ast::MethodTraitItem(_, Some(_)) = ti.node {\n+                    if let hir::MethodTraitItem(_, Some(_)) = ti.node {\n                         match self.impl_or_trait_item(DefId::local(ti.id)) {\n                             MethodTraitItem(m) => Some(m),\n                             _ => {\n@@ -5794,7 +5790,7 @@ impl<'tcx> ctxt<'tcx> {\n             match self.map.expect_item(id.node).node {\n                 ItemTrait(_, _, _, ref tis) => {\n                     tis.iter().filter_map(|ti| {\n-                        if let ast::ConstTraitItem(_, _) = ti.node {\n+                        if let hir::ConstTraitItem(_, _) = ti.node {\n                             match self.impl_or_trait_item(DefId::local(ti.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n@@ -5810,7 +5806,7 @@ impl<'tcx> ctxt<'tcx> {\n                 }\n                 ItemImpl(_, _, _, _, _, ref iis) => {\n                     iis.iter().filter_map(|ii| {\n-                        if let ast::ConstImplItem(_, _) = ii.node {\n+                        if let hir::ConstImplItem(_, _) = ii.node {\n                             match self.impl_or_trait_item(DefId::local(ii.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n@@ -5850,12 +5846,12 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_impl_polarity(&self, id: DefId) -> Option<ast::ImplPolarity> {\n+    pub fn trait_impl_polarity(&self, id: DefId) -> Option<hir::ImplPolarity> {\n         if id.is_local() {\n             match self.map.find(id.node) {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n-                        ast::ItemImpl(_, polarity, _, _, _, _) => Some(polarity),\n+                        hir::ItemImpl(_, polarity, _, _, _, _) => Some(polarity),\n                         _ => None\n                     }\n                 }\n@@ -5909,7 +5905,7 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn is_impl(&self, id: DefId) -> bool {\n         if id.is_local() {\n             if let Some(ast_map::NodeItem(\n-                &ast::Item { node: ast::ItemImpl(..), .. })) = self.map.find(id.node) {\n+                &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id.node) {\n                 true\n             } else {\n                 false\n@@ -5919,7 +5915,7 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_ref_to_def_id(&self, tr: &ast::TraitRef) -> DefId {\n+    pub fn trait_ref_to_def_id(&self, tr: &hir::TraitRef) -> DefId {\n         self.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n     }\n \n@@ -5974,21 +5970,22 @@ impl<'tcx> ctxt<'tcx> {\n             //\n             // NB. Historically `fn enum_variants` generate i64 here, while\n             // rustc_typeck::check would generate isize.\n-            _ => SignedInt(ast::TyIs),\n+            _ => SignedInt(hir::TyIs),\n         };\n \n         let repr_type_ty = repr_type.to_ty(self);\n         let repr_type = match repr_type {\n-            SignedInt(ast::TyIs) =>\n+            SignedInt(hir::TyIs) =>\n                 SignedInt(self.sess.target.int_type),\n-            UnsignedInt(ast::TyUs) =>\n+            UnsignedInt(hir::TyUs) =>\n                 UnsignedInt(self.sess.target.uint_type),\n             other => other\n         };\n \n         (repr_type, repr_type_ty)\n     }\n \n+\n     // Register a given item type\n     pub fn register_item_type(&self, did: DefId, ty: TypeScheme<'tcx>) {\n         self.tcache.borrow_mut().insert(did, ty);\n@@ -6047,7 +6044,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     /// Get the attributes of a definition.\n-    pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n+    pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [hir::Attribute]> {\n         if did.is_local() {\n             Cow::Borrowed(self.map.attrs(did.node))\n         } else {\n@@ -6084,6 +6081,7 @@ impl<'tcx> ctxt<'tcx> {\n         })\n     }\n \n+\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n@@ -6122,7 +6120,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     // Returns the repeat count for a repeating vector expression.\n-    pub fn eval_repeat_count(&self, count_expr: &ast::Expr) -> usize {\n+    pub fn eval_repeat_count(&self, count_expr: &hir::Expr) -> usize {\n         let hint = UncheckedExprHint(self.types.usize);\n         match const_eval::eval_const_expr_partial(self, count_expr, hint) {\n             Ok(val) => {\n@@ -6137,7 +6135,7 @@ impl<'tcx> ctxt<'tcx> {\n             }\n             Err(err) => {\n                 let err_msg = match count_expr.node {\n-                    ast::ExprPath(None, ast::Path {\n+                    hir::ExprPath(None, hir::Path {\n                         global: false,\n                         ref segments,\n                         ..\n@@ -6580,7 +6578,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n     pub fn construct_free_substs(&self, generics: &Generics<'tcx>,\n-                                 free_id: ast::NodeId) -> Substs<'tcx> {\n+                                 free_id: NodeId) -> Substs<'tcx> {\n         // map T => T\n         let mut types = VecPerParamSpace::empty();\n         for def in generics.types.as_slice() {\n@@ -6612,7 +6610,7 @@ impl<'tcx> ctxt<'tcx> {\n                                                span: Span,\n                                                generics: &ty::Generics<'tcx>,\n                                                generic_predicates: &ty::GenericPredicates<'tcx>,\n-                                               free_id: ast::NodeId)\n+                                               free_id: NodeId)\n                                                -> ParameterEnvironment<'a, 'tcx>\n     {\n         //\n@@ -6662,11 +6660,11 @@ impl<'tcx> ctxt<'tcx> {\n         traits::normalize_param_env_or_error(unnormalized_env, cause)\n     }\n \n-    pub fn is_method_call(&self, expr_id: ast::NodeId) -> bool {\n+    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n         self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n \n-    pub fn is_overloaded_autoderef(&self, expr_id: ast::NodeId, autoderefs: u32) -> bool {\n+    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n         self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n                                                                             autoderefs))\n     }\n@@ -6762,7 +6760,7 @@ impl<'tcx> ctxt<'tcx> {\n pub enum ExplicitSelfCategory {\n     StaticExplicitSelfCategory,\n     ByValueExplicitSelfCategory,\n-    ByReferenceExplicitSelfCategory(Region, ast::Mutability),\n+    ByReferenceExplicitSelfCategory(Region, hir::Mutability),\n     ByBoxExplicitSelfCategory,\n }\n \n@@ -6778,7 +6776,7 @@ pub struct Freevar {\n \n pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n-pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n+pub type CaptureModeMap = NodeMap<hir::CaptureClause>;\n \n // Trait method resolution\n pub type TraitMap = NodeMap<Vec<DefId>>;\n@@ -6804,7 +6802,7 @@ impl<'tcx> AutoDerefRef<'tcx> {\n }\n \n impl<'tcx> ctxt<'tcx> {\n-    pub fn with_freevars<T, F>(&self, fid: ast::NodeId, f: F) -> T where\n+    pub fn with_freevars<T, F>(&self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[Freevar]) -> T,\n     {\n         match self.freevars.borrow().get(&fid) {\n@@ -7226,7 +7224,7 @@ impl HasTypeFlags for abi::Abi {\n     }\n }\n \n-impl HasTypeFlags for ast::Unsafety {\n+impl HasTypeFlags for hir::Unsafety {\n     fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n         false\n     }"}, {"sha": "c6d213583af20173cd367bee82715a715bad4a82", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -42,7 +42,7 @@ use middle::traits;\n use std::fmt;\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ast;\n+use rustc_front::hir;\n use syntax::owned_slice::OwnedSlice;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n@@ -165,7 +165,7 @@ macro_rules! CopyImpls {\n     }\n }\n \n-CopyImpls! { (), ast::Unsafety, abi::Abi }\n+CopyImpls! { (), hir::Unsafety, abi::Abi }\n \n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {"}, {"sha": "d2d612ece6f80e3b3113c309f8e76839e6027d34", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -19,7 +19,7 @@ use middle::ty::{self, HasTypeFlags, Ty, TypeError};\n use middle::ty_fold::TypeFoldable;\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ast;\n+use rustc_front::hir as ast;\n \n pub type RelateResult<'tcx, T> = Result<T, ty::TypeError<'tcx>>;\n "}, {"sha": "43b7943fd2096f88bf999fa5d5583574a01269b6", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -15,11 +15,11 @@ use session::Session;\n use metadata::csearch;\n use middle::lang_items;\n \n-use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use rustc_front::visit::Visitor;\n+use rustc_front::visit;\n+use rustc_front::hir;\n \n use std::collections::HashSet;\n \n@@ -33,7 +33,7 @@ struct Context<'a> {\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n-pub fn check_crate(krate: &ast::Crate,\n+pub fn check_crate(krate: &hir::Crate,\n                    sess: &Session,\n                    items: &mut lang_items::LanguageItems) {\n     // These are never called by user code, they're generated by the compiler.\n@@ -54,7 +54,7 @@ pub fn check_crate(krate: &ast::Crate,\n     verify(sess, items);\n }\n \n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+pub fn link_name(attrs: &[hir::Attribute]) -> Option<InternedString> {\n     lang_items::extract(attrs).and_then(|name| {\n         $(if &name[..] == stringify!($name) {\n             Some(InternedString::new(stringify!($sym)))\n@@ -108,7 +108,7 @@ impl<'a> Context<'a> {\n }\n \n impl<'a, 'v> Visitor<'v> for Context<'a> {\n-    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         match lang_items::extract(&i.attrs) {\n             None => {}\n             Some(lang_item) => self.register(&lang_item, i.span),"}, {"sha": "55fd63b7534721a4943d16c6572c24e314ae85f5", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -11,19 +11,20 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n use syntax::ast;\n-use syntax::attr;\n use syntax::codemap::Span;\n use syntax::diagnostic;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n+use rustc_front::visit;\n+use rustc_front::visit::Visitor;\n+use rustc_front::hir;\n+use rustc_front::attr;\n \n struct RegistrarFinder {\n     registrars: Vec<(ast::NodeId, Span)> ,\n }\n \n impl<'v> Visitor<'v> for RegistrarFinder {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        if let ast::ItemFn(..) = item.node {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        if let hir::ItemFn(..) = item.node {\n             if attr::contains_name(&item.attrs,\n                                    \"plugin_registrar\") {\n                 self.registrars.push((item.id, item.span));\n@@ -36,7 +37,8 @@ impl<'v> Visitor<'v> for RegistrarFinder {\n \n /// Find the function marked with `#[plugin_registrar]`, if any.\n pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n-                             krate: &ast::Crate) -> Option<ast::NodeId> {\n+                             krate: &hir::Crate)\n+                             -> Option<ast::NodeId> {\n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n     visit::walk_crate(&mut finder, krate);\n "}, {"sha": "af9f17f3c6fcc97383795cd372f9157c74c206dd", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -26,9 +26,10 @@ use lint;\n use metadata::cstore;\n \n use syntax::ast;\n-use syntax::ast::{IntTy, UintTy};\n+use rustc_front::hir::{IntTy, UintTy};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n+use rustc_front::hir;\n use syntax::diagnostic::{ColorConfig, Auto, Always, Never, SpanHandler};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n@@ -664,8 +665,8 @@ pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n     };\n \n     let (int_type, uint_type) = match &target.target_pointer_width[..] {\n-        \"32\" => (ast::TyI32, ast::TyU32),\n-        \"64\" => (ast::TyI64, ast::TyU64),\n+        \"32\" => (hir::TyI32, hir::TyU32),\n+        \"64\" => (hir::TyI64, hir::TyU64),\n         w    => sp.handler().fatal(&format!(\"target specification was invalid: unrecognized \\\n                                              target-pointer-width {}\", w))\n     };\n@@ -824,15 +825,16 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n         opt::flagopt_u(\"\", \"pretty\",\n                    \"Pretty-print the input instead of compiling;\n                    valid types are: `normal` (un-annotated source),\n-                   `expanded` (crates expanded),\n-                   `typed` (crates expanded, with type annotations), or\n+                   `expanded` (crates expanded), or\n                    `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n                  \"TYPE\"),\n         opt::flagopt_u(\"\", \"unpretty\",\n                      \"Present the input source, unstable (and less-pretty) variants;\n                       valid types are any of the types for `--pretty`, as well as:\n-                      `flowgraph=<nodeid>` (graphviz formatted flowgraph for node), or\n-                      `everybody_loops` (all function bodies replaced with `loop {}`).\",\n+                      `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n+                      `everybody_loops` (all function bodies replaced with `loop {}`),\n+                      `hir` (the HIR), `hir,identified`, or\n+                      `hir,typed` (HIR with types for each node).\",\n                      \"TYPE\"),\n         opt::opt_u(\"\", \"show-span\", \"Show spans for compiler debugging\", \"expr|pat|ty\"),\n     ]);"}, {"sha": "a6ca6a45f956819223d62763c27ca9bdb7a02718", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -20,9 +20,9 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::Duration;\n \n-use syntax::ast;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n+use rustc_front::hir;\n+use rustc_front::visit;\n+use rustc_front::visit::Visitor;\n \n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n@@ -152,26 +152,26 @@ pub fn indenter() -> Indenter {\n     Indenter { _cannot_construct_outside_of_this_module: () }\n }\n \n-struct LoopQueryVisitor<P> where P: FnMut(&ast::Expr_) -> bool {\n+struct LoopQueryVisitor<P> where P: FnMut(&hir::Expr_) -> bool {\n     p: P,\n     flag: bool,\n }\n \n-impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&ast::Expr_) -> bool {\n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&hir::Expr_) -> bool {\n+    fn visit_expr(&mut self, e: &hir::Expr) {\n         self.flag |= (self.p)(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n-          ast::ExprLoop(..) | ast::ExprWhile(..) => {}\n+          hir::ExprLoop(..) | hir::ExprWhile(..) => {}\n           _ => visit::walk_expr(self, e)\n         }\n     }\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr_) -> bool {\n+pub fn loop_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr_) -> bool {\n     let mut v = LoopQueryVisitor {\n         p: p,\n         flag: false,\n@@ -180,21 +180,21 @@ pub fn loop_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr_) -\n     return v.flag;\n }\n \n-struct BlockQueryVisitor<P> where P: FnMut(&ast::Expr) -> bool {\n+struct BlockQueryVisitor<P> where P: FnMut(&hir::Expr) -> bool {\n     p: P,\n     flag: bool,\n }\n \n-impl<'v, P> Visitor<'v> for BlockQueryVisitor<P> where P: FnMut(&ast::Expr) -> bool {\n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+impl<'v, P> Visitor<'v> for BlockQueryVisitor<P> where P: FnMut(&hir::Expr) -> bool {\n+    fn visit_expr(&mut self, e: &hir::Expr) {\n         self.flag |= (self.p)(e);\n         visit::walk_expr(self, e)\n     }\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -> bool {\n+pub fn block_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,"}, {"sha": "a0701d852bc04ba2e6874f02778d49dd6257e748", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -26,7 +26,8 @@ use middle::ty_fold::{self, TypeFoldable};\n use std::fmt;\n use syntax::abi;\n use syntax::parse::token;\n-use syntax::{ast, ast_util};\n+use syntax::ast::DUMMY_NODE_ID;\n+use rustc_front::hir as ast;\n \n pub fn verbose() -> bool {\n     ty::tls::with(|tcx| tcx.sess.verbose())\n@@ -230,7 +231,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrEnv => {\n                 let name = token::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(DefId::local(ast::DUMMY_NODE_ID), name)\n+                ty::BrNamed(DefId::local(DUMMY_NODE_ID), name)\n             }\n         })\n     }).0;\n@@ -623,14 +624,55 @@ impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     }\n }\n \n+pub fn int_ty_to_string(t: ast::IntTy, val: Option<i64>) -> String {\n+    let s = match t {\n+        ast::TyIs => \"isize\",\n+        ast::TyI8 => \"i8\",\n+        ast::TyI16 => \"i16\",\n+        ast::TyI32 => \"i32\",\n+        ast::TyI64 => \"i64\"\n+    };\n+\n+    match val {\n+        // cast to a u64 so we can correctly print INT64_MIN. All integral types\n+        // are parsed as u64, so we wouldn't want to print an extra negative\n+        // sign.\n+        Some(n) => format!(\"{}{}\", n as u64, s),\n+        None => s.to_string()\n+    }\n+}\n+\n+pub fn uint_ty_to_string(t: ast::UintTy, val: Option<u64>) -> String {\n+    let s = match t {\n+        ast::TyUs => \"usize\",\n+        ast::TyU8 => \"u8\",\n+        ast::TyU16 => \"u16\",\n+        ast::TyU32 => \"u32\",\n+        ast::TyU64 => \"u64\"\n+    };\n+\n+    match val {\n+        Some(n) => format!(\"{}{}\", n, s),\n+        None => s.to_string()\n+    }\n+}\n+\n+\n+pub fn float_ty_to_string(t: ast::FloatTy) -> String {\n+    match t {\n+        ast::TyF32 => \"f32\".to_string(),\n+        ast::TyF64 => \"f64\".to_string(),\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             TyBool => write!(f, \"bool\"),\n             TyChar => write!(f, \"char\"),\n-            TyInt(t) => write!(f, \"{}\", ast_util::int_ty_to_string(t, None)),\n-            TyUint(t) => write!(f, \"{}\", ast_util::uint_ty_to_string(t, None)),\n-            TyFloat(t) => write!(f, \"{}\", ast_util::float_ty_to_string(t)),\n+            TyInt(t) => write!(f, \"{}\", int_ty_to_string(t, None)),\n+            TyUint(t) => write!(f, \"{}\", uint_ty_to_string(t, None)),\n+            TyFloat(t) => write!(f, \"{}\", float_ty_to_string(t)),\n             TyBox(typ) => write!(f, \"Box<{}>\",  typ),\n             TyRawPtr(ref tm) => {\n                 write!(f, \"*{} {}\", match tm.mutbl {"}, {"sha": "4a6646bca1b64f623deda604382a57a472537115", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -48,6 +48,7 @@ extern crate syntax;\n extern crate libc;\n extern crate serialize;\n extern crate rustc_llvm;\n+extern crate rustc_front;\n #[macro_use] extern crate log;\n \n pub mod abi;"}, {"sha": "9f527341bcd8aeb3376b091daf06b49c17da0179", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 14, "deletions": 61, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -48,8 +48,8 @@\n \n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n-use syntax::ast;\n-use syntax::visit;\n+use rustc_front::hir;\n+use rustc_front::visit;\n \n #[derive(Clone, PartialEq, Debug)]\n pub struct Svh {\n@@ -66,7 +66,7 @@ impl Svh {\n         &self.hash\n     }\n \n-    pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n+    pub fn calculate(metadata: &Vec<String>, krate: &hir::Crate) -> Svh {\n         // FIXME (#14132): This is better than it used to be, but it still not\n         // ideal. We now attempt to hash only the relevant portions of the\n         // Crate AST as well as the top-level crate attributes. (However,\n@@ -131,13 +131,13 @@ mod svh_visitor {\n     pub use self::SawExprComponent::*;\n     pub use self::SawStmtComponent::*;\n     use self::SawAbiComponent::*;\n-    use syntax::ast;\n-    use syntax::ast::*;\n+    use syntax::ast::{self, NodeId, Ident};\n     use syntax::codemap::Span;\n     use syntax::parse::token;\n-    use syntax::print::pprust;\n-    use syntax::visit;\n-    use syntax::visit::{Visitor, FnKind};\n+    use rustc_front::visit;\n+    use rustc_front::visit::{Visitor, FnKind};\n+    use rustc_front::hir::*;\n+    use rustc_front::hir;\n \n     use std::hash::{Hash, SipHasher};\n \n@@ -230,23 +230,23 @@ mod svh_visitor {\n         SawExprCall,\n         SawExprMethodCall,\n         SawExprTup,\n-        SawExprBinary(ast::BinOp_),\n-        SawExprUnary(ast::UnOp),\n-        SawExprLit(ast::Lit_),\n+        SawExprBinary(hir::BinOp_),\n+        SawExprUnary(hir::UnOp),\n+        SawExprLit(hir::Lit_),\n         SawExprCast,\n         SawExprIf,\n         SawExprWhile,\n         SawExprMatch,\n         SawExprClosure,\n         SawExprBlock,\n         SawExprAssign,\n-        SawExprAssignOp(ast::BinOp_),\n+        SawExprAssignOp(hir::BinOp_),\n         SawExprIndex,\n         SawExprRange,\n         SawExprPath(Option<usize>),\n-        SawExprAddrOf(ast::Mutability),\n+        SawExprAddrOf(hir::Mutability),\n         SawExprRet,\n-        SawExprInlineAsm(&'a ast::InlineAsm),\n+        SawExprInlineAsm(&'a hir::InlineAsm),\n         SawExprStruct,\n         SawExprRepeat,\n         SawExprParen,\n@@ -284,12 +284,6 @@ mod svh_visitor {\n             ExprStruct(..)           => SawExprStruct,\n             ExprRepeat(..)           => SawExprRepeat,\n             ExprParen(..)            => SawExprParen,\n-\n-            // just syntactic artifacts, expanded away by time of SVH.\n-            ExprForLoop(..)          => unreachable!(),\n-            ExprIfLet(..)            => unreachable!(),\n-            ExprWhileLet(..)         => unreachable!(),\n-            ExprMac(..)              => unreachable!(),\n         }\n     }\n \n@@ -306,51 +300,10 @@ mod svh_visitor {\n             StmtDecl(..) => SawStmtDecl,\n             StmtExpr(..) => SawStmtExpr,\n             StmtSemi(..) => SawStmtSemi,\n-            StmtMac(..)  => unreachable!(),\n         }\n     }\n \n     impl<'a, 'v> Visitor<'v> for StrictVersionHashVisitor<'a> {\n-\n-        fn visit_mac(&mut self, mac: &Mac) {\n-            // macro invocations, namely macro_rules definitions,\n-            // *can* appear as items, even in the expanded crate AST.\n-\n-            if &macro_name(mac)[..] == \"macro_rules\" {\n-                // Pretty-printing definition to a string strips out\n-                // surface artifacts (currently), such as the span\n-                // information, yielding a content-based hash.\n-\n-                // FIXME (#14132): building temporary string is\n-                // expensive; a direct content-based hash on token\n-                // trees might be faster. Implementing this is far\n-                // easier in short term.\n-                let macro_defn_as_string = pprust::to_string(|pp_state| {\n-                    pp_state.print_mac(mac, token::Paren)\n-                });\n-                macro_defn_as_string.hash(self.st);\n-            } else {\n-                // It is not possible to observe any kind of macro\n-                // invocation at this stage except `macro_rules!`.\n-                panic!(\"reached macro somehow: {}\",\n-                      pprust::to_string(|pp_state| {\n-                          pp_state.print_mac(mac, token::Paren)\n-                      }));\n-            }\n-\n-            visit::walk_mac(self, mac);\n-\n-            fn macro_name(mac: &Mac) -> token::InternedString {\n-                match &mac.node {\n-                    &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = &path.segments;\n-                        assert_eq!(s.len(), 1);\n-                        s[0].identifier.name.as_str()\n-                    }\n-                }\n-            }\n-        }\n-\n         fn visit_struct_def(&mut self, s: &StructDef, ident: Ident,\n                             g: &Generics, _: NodeId) {\n             SawStructDef(ident.name.as_str()).hash(self.st);"}, {"sha": "eed8f82b5d853f1a3c13604df0d17c5c85123b00", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -27,6 +27,7 @@ use rustc::middle::region;\n use rustc::middle::ty;\n use syntax::ast;\n use syntax::codemap::Span;\n+use rustc_front::hir;\n \n use std::rc::Rc;\n \n@@ -104,12 +105,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn matched_pat(&mut self,\n-                   _matched_pat: &ast::Pat,\n+                   _matched_pat: &hir::Pat,\n                    _cmt: mc::cmt,\n                    _mode: euv::MatchMode) { }\n \n     fn consume_pat(&mut self,\n-                   consume_pat: &ast::Pat,\n+                   consume_pat: &hir::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n@@ -194,8 +195,8 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n-                                     decl: &ast::FnDecl,\n-                                     body: &ast::Block) {\n+                                     decl: &hir::FnDecl,\n+                                     body: &hir::Block) {\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);"}, {"sha": "86b6314b57cc114da522b3995b6dcdf629321aeb", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -27,8 +27,8 @@ use rustc::middle::mem_categorization as mc;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n+use rustc_front::attr::AttrMetaMethods;\n \n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n enum Fragment {"}, {"sha": "3515b53b00d31f6a1928f496c3c707b101a1afdd", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::ty;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n+use rustc_front::hir;\n \n struct GatherMoveInfo<'tcx> {\n     id: ast::NodeId,\n@@ -62,7 +63,7 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_data: &MoveData<'tcx>,\n                                       _move_error_collector: &MoveErrorCollector<'tcx>,\n-                                      move_pat: &ast::Pat,\n+                                      move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>,\n                                       mode: euv::MatchMode) {\n     let tcx = bccx.tcx;\n@@ -93,10 +94,10 @@ pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_data: &MoveData<'tcx>,\n                                       move_error_collector: &MoveErrorCollector<'tcx>,\n-                                      move_pat: &ast::Pat,\n+                                      move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n-        ast::PatIdent(_, ref path1, _) => {\n+        hir::PatIdent(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n                                  ident: path1.node})\n         },"}, {"sha": "505c66593f5eb404d5674c1f4b4cc8ef96d4cc7d", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -26,9 +26,11 @@ use rustc::middle::ty;\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-use syntax::ast::{Expr, FnDecl, Block, NodeId, Pat};\n+use syntax::ast::NodeId;\n+use rustc_front::hir;\n+use rustc_front::hir::{Expr, FnDecl, Block, Pat};\n+use rustc_front::visit;\n+use rustc_front::visit::Visitor;\n \n mod lifetime;\n mod restrictions;\n@@ -37,8 +39,8 @@ mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     fn_id: NodeId,\n-                                    decl: &ast::FnDecl,\n-                                    body: &ast::Block)\n+                                    decl: &hir::FnDecl,\n+                                    body: &hir::Block)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n     let mut glcx = GatherLoanCtxt {\n@@ -91,7 +93,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn matched_pat(&mut self,\n-                   matched_pat: &ast::Pat,\n+                   matched_pat: &hir::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::MatchMode) {\n         debug!(\"matched_pat(matched_pat={:?}, cmt={:?}, mode={:?})\",\n@@ -107,7 +109,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn consume_pat(&mut self,\n-                   consume_pat: &ast::Pat,\n+                   consume_pat: &hir::Pat,\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n@@ -527,7 +529,7 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n-        if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n+        if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n             let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None, false);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&**base).unwrap();\n@@ -544,7 +546,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::Expr) {\n+pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &hir::Expr) {\n \n     debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n "}, {"sha": "c39b1a9da07ea9547858d2a9047cbeed5f2c8c95", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -15,7 +15,8 @@ use rustc::middle::ty;\n use std::cell::RefCell;\n use syntax::ast;\n use syntax::codemap;\n-use syntax::print::pprust;\n+use rustc_front::print::pprust;\n+use rustc_front::hir;\n \n pub struct MoveErrorCollector<'tcx> {\n     errors: RefCell<Vec<MoveError<'tcx>>>\n@@ -125,7 +126,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n             let expr = bccx.tcx.map.expect_expr(move_from.id);\n-            if let ast::ExprIndex(..) = expr.node {\n+            if let hir::ExprIndex(..) = expr.node {\n                 bccx.span_err(move_from.span,\n                               &format!(\"cannot move out of type `{}`, \\\n                                         a non-copy fixed-size array\","}, {"sha": "57e578d10c668d073bfc6bae350d27ad665f76a0", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -20,8 +20,8 @@ pub use self::MovedValueUseKind::*;\n \n use self::InteriorKind::*;\n \n-use rustc::ast_map;\n-use rustc::ast_map::blocks::{FnLikeNode, FnParts};\n+use rustc::front::map as hir_map;\n+use rustc::front::map::blocks::{FnLikeNode, FnParts};\n use rustc::middle::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n@@ -37,12 +37,14 @@ use rustc::middle::ty::{self, Ty};\n use std::fmt;\n use std::mem;\n use std::rc::Rc;\n-use syntax::ast;\n-use syntax::ast_util;\n+use syntax::ast::{self, NodeId};\n use syntax::codemap::Span;\n-use syntax::visit;\n-use syntax::visit::{Visitor, FnKind};\n-use syntax::ast::{FnDecl, Block, NodeId};\n+\n+use rustc_front::hir;\n+use rustc_front::hir::{FnDecl, Block};\n+use rustc_front::visit;\n+use rustc_front::visit::{Visitor, FnKind};\n+use rustc_front::util as hir_util;\n \n pub mod check_loans;\n \n@@ -74,19 +76,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         borrowck_item(self, item);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n-        if let ast::ConstTraitItem(_, Some(ref expr)) = ti.node {\n+    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+        if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n             gather_loans::gather_loans_in_static_initializer(self, &*expr);\n         }\n         visit::walk_trait_item(self, ti);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n-        if let ast::ConstImplItem(_, ref expr) = ii.node {\n+    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+        if let hir::ConstImplItem(_, ref expr) = ii.node {\n             gather_loans::gather_loans_in_static_initializer(self, &*expr);\n         }\n         visit::walk_impl_item(self, ii);\n@@ -126,14 +128,14 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     }\n }\n \n-fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n+fn borrowck_item(this: &mut BorrowckCtxt, item: &hir::Item) {\n     // Gather loans for items. Note that we don't need\n     // to check loans for single expressions. The check\n     // loan step is intended for things that have a data\n     // flow dependent conditions.\n     match item.node {\n-        ast::ItemStatic(_, _, ref ex) |\n-        ast::ItemConst(_, ref ex) => {\n+        hir::ItemStatic(_, _, ref ex) |\n+        hir::ItemConst(_, ref ex) => {\n             gather_loans::gather_loans_in_static_initializer(this, &**ex);\n         }\n         _ => { }\n@@ -151,8 +153,8 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n \n fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: FnKind,\n-               decl: &ast::FnDecl,\n-               body: &ast::Block,\n+               decl: &hir::FnDecl,\n+               body: &hir::Block,\n                sp: Span,\n                id: ast::NodeId) {\n     debug!(\"borrowck_fn(id={})\", id);\n@@ -183,16 +185,16 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           fk: FnKind,\n-                                          decl: &ast::FnDecl,\n+                                          decl: &hir::FnDecl,\n                                           cfg: &cfg::CFG,\n-                                          body: &ast::Block,\n+                                          body: &hir::Block,\n                                           sp: Span,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n+    let id_range = hir_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, id, decl, body);\n \n@@ -398,8 +400,8 @@ pub enum LoanPathElem {\n pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n-        ast_map::NodeExpr(expr) => match expr.node {\n-            ast::ExprClosure(_, _, ref block) => {\n+        hir_map::NodeExpr(expr) => match expr.node {\n+            hir::ExprClosure(_, _, ref block) => {\n                 block.id\n             }\n             _ => {\n@@ -667,7 +669,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let (expr_ty, expr_span) = match self.tcx\n                                                      .map\n                                                      .find(the_move.id) {\n-                    Some(ast_map::NodeExpr(expr)) => {\n+                    Some(hir_map::NodeExpr(expr)) => {\n                         (self.tcx.expr_ty_adjusted(&*expr), expr.span)\n                     }\n                     r => {\n@@ -729,7 +731,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let (expr_ty, expr_span) = match self.tcx\n                                                      .map\n                                                      .find(the_move.id) {\n-                    Some(ast_map::NodeExpr(expr)) => {\n+                    Some(hir_map::NodeExpr(expr)) => {\n                         (self.tcx.expr_ty_adjusted(&*expr), expr.span)\n                     }\n                     r => {\n@@ -1138,7 +1140,7 @@ fn statement_scope_span(tcx: &ty::ctxt, region: ty::Region) -> Option<Span> {\n     match region {\n         ty::ReScope(scope) => {\n             match tcx.map.find(scope.node_id(&tcx.region_maps)) {\n-                Some(ast_map::NodeStmt(stmt)) => Some(stmt.span),\n+                Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),\n                 _ => None\n             }\n         }"}, {"sha": "3ac6e7c5d69eb9988229858461bc5378ed888d53", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -29,6 +29,7 @@ use std::usize;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n+use rustc_front::hir;\n \n #[path=\"fragments.rs\"]\n pub mod fragments;\n@@ -601,8 +602,8 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                tcx: &'a ty::ctxt<'tcx>,\n                cfg: &cfg::CFG,\n                id_range: ast_util::IdRange,\n-               decl: &ast::FnDecl,\n-               body: &ast::Block)\n+               decl: &hir::FnDecl,\n+               body: &hir::Block)\n                -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,"}, {"sha": "d7e1bab46da693d04c5212de2f82436b6e34c03f", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -34,6 +34,7 @@\n // refers to the borrowck-specific graphviz adapter traits.\n extern crate graphviz as dot;\n extern crate rustc;\n+extern crate rustc_front;\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;"}, {"sha": "d12a189e6b1644f7f3ed351a4baedbd384f80641", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::front;\n+use rustc::front::map as hir_map;\n use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames};\n use rustc::session::search_paths::PathKind;\n-use rustc::ast_map;\n use rustc::lint;\n use rustc::metadata;\n use rustc::metadata::creader::LocalCrateReader;\n@@ -28,6 +29,8 @@ use rustc_trans::back::write;\n use rustc_trans::trans;\n use rustc_typeck as typeck;\n use rustc_privacy;\n+use rustc_front::hir;\n+use rustc_front::lowering::lower_crate;\n use super::Compilation;\n \n use serialize::json;\n@@ -41,6 +44,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::diagnostics;\n+use syntax::fold::Folder;\n use syntax::parse;\n use syntax::parse::token;\n use syntax;\n@@ -104,9 +108,13 @@ pub fn compile_input(sess: Session,\n                                                                  &expanded_crate,\n                                                                  &id[..]));\n \n-        let mut forest = ast_map::Forest::new(expanded_crate);\n+        let expanded_crate = assign_node_ids(&sess, expanded_crate);\n+        // Lower ast -> hir.\n+        let mut hir_forest = time(sess.time_passes(),\n+                                  \"lowering ast -> hir\",\n+                                  || hir_map::Forest::new(lower_crate(&expanded_crate)));\n         let arenas = ty::CtxtArenas::new();\n-        let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n+        let ast_map = make_map(&sess, &mut hir_forest);\n \n         write_out_deps(&sess, input, &outputs, &id[..]);\n \n@@ -116,11 +124,14 @@ pub fn compile_input(sess: Session,\n                                                                      &sess,\n                                                                      outdir,\n                                                                      &ast_map,\n+                                                                     &expanded_crate,\n                                                                      &ast_map.krate(),\n                                                                      &id[..]));\n \n+\n         phase_3_run_analysis_passes(sess,\n                                     ast_map,\n+                                    &expanded_crate,\n                                     &arenas,\n                                     id,\n                                     control.make_glob_map,\n@@ -130,6 +141,7 @@ pub fn compile_input(sess: Session,\n                 let state = CompileState::state_after_analysis(input,\n                                                                &tcx.sess,\n                                                                outdir,\n+                                                               &expanded_crate,\n                                                                tcx.map.krate(),\n                                                                &analysis,\n                                                                tcx);\n@@ -254,7 +266,8 @@ pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n     pub output_filenames: Option<&'a OutputFilenames>,\n     pub out_dir: Option<&'a Path>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n-    pub ast_map: Option<&'a ast_map::Map<'ast>>,\n+    pub hir_crate: Option<&'a hir::Crate>,\n+    pub ast_map: Option<&'a hir_map::Map<'ast>>,\n     pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<&'a ty::ctxt<'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n@@ -274,6 +287,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n             crate_name: None,\n             output_filenames: None,\n             expanded_crate: None,\n+            hir_crate: None,\n             ast_map: None,\n             analysis: None,\n             tcx: None,\n@@ -308,29 +322,33 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n     fn state_after_write_deps(input: &'a Input,\n                               session: &'a Session,\n                               out_dir: &'a Option<PathBuf>,\n-                              ast_map: &'a ast_map::Map<'ast>,\n-                              expanded_crate: &'a ast::Crate,\n+                              ast_map: &'a hir_map::Map<'ast>,\n+                              krate: &'a ast::Crate,\n+                              hir_crate: &'a hir::Crate,\n                               crate_name: &'a str)\n                               -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n             ast_map: Some(ast_map),\n-            expanded_crate: Some(expanded_crate),\n+            krate: Some(krate),\n+            hir_crate: Some(hir_crate),\n             .. CompileState::empty(input, session, out_dir)\n         }\n     }\n \n     fn state_after_analysis(input: &'a Input,\n                             session: &'a Session,\n                             out_dir: &'a Option<PathBuf>,\n-                            expanded_crate: &'a ast::Crate,\n+                            krate: &'a ast::Crate,\n+                            hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis,\n                             tcx: &'a ty::ctxt<'tcx>)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n             tcx: Some(tcx),\n-            expanded_crate: Some(expanded_crate),\n+            krate: Some(krate),\n+            hir_crate: Some(hir_crate),\n             .. CompileState::empty(input, session, out_dir)\n         }\n     }\n@@ -582,42 +600,54 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     Some(krate)\n }\n \n-pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n-                                     forest: &'ast mut ast_map::Forest)\n-                                     -> ast_map::Map<'ast> {\n+pub fn assign_node_ids(sess: &Session,\n+                       krate: ast::Crate) -> ast::Crate {\n     struct NodeIdAssigner<'a> {\n         sess: &'a Session\n     }\n \n-    impl<'a> ast_map::FoldOps for NodeIdAssigner<'a> {\n-        fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n+    impl<'a> Folder for NodeIdAssigner<'a> {\n+        fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n             assert_eq!(old_id, ast::DUMMY_NODE_ID);\n             self.sess.next_node_id()\n         }\n     }\n \n-    let map = time(sess.time_passes(), \"assigning node ids and indexing ast\", move ||\n-                   ast_map::map_crate(forest, NodeIdAssigner { sess: sess }));\n+    let krate = time(sess.time_passes(),\n+                     \"assigning node ids\",\n+                     || NodeIdAssigner { sess: sess }.fold_crate(krate));\n \n     if sess.opts.debugging_opts.ast_json {\n-        println!(\"{}\", json::as_json(map.krate()));\n+        println!(\"{}\", json::as_json(&krate));\n     }\n \n+    krate\n+}\n+\n+pub fn make_map<'ast>(sess: &Session,\n+                      forest: &'ast mut front::map::Forest)\n+                      -> front::map::Map<'ast> {\n+    // Construct the 'ast'-map\n+    let map = time(sess.time_passes(),\n+                   \"indexing hir\",\n+                   move || front::map::map_crate(forest));\n+\n     map\n }\n \n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n-                                               ast_map: ast_map::Map<'tcx>,\n+                                               ast_map: front::map::Map<'tcx>,\n+                                               ast_crate: &ast::Crate,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: String,\n                                                make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n                                                -> (Session, R)\n                                                where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>,\n-                                                               ty::CrateAnalysis) -> R\n+                                                                       ty::CrateAnalysis) -> R\n {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n@@ -731,7 +761,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n                 &tcx.sess, lib_features_used));\n \n         time(time_passes, \"lint checking\", ||\n-            lint::check_crate(tcx, &exported_items));\n+            lint::check_crate(tcx, ast_crate, &exported_items));\n \n         // The above three passes generate errors w/o aborting\n         tcx.sess.abort_if_errors();"}, {"sha": "bd2b536f907aeffc059e8c53b533c16ec113ebd1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -42,6 +42,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n+extern crate rustc_front;\n extern crate rustc_lint;\n extern crate rustc_privacy;\n extern crate rustc_resolve;\n@@ -389,6 +390,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 time(state.session.time_passes(),\n                      \"save analysis\",\n                      || save::process_crate(state.tcx.unwrap(),\n+                                            state.krate.unwrap(),\n                                             state.analysis.unwrap(),\n                                             state.out_dir));\n             };"}, {"sha": "53beb6d312d896233abb2edcb1dc97ae7e4eba83", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 204, "deletions": 68, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -19,7 +19,6 @@ use rustc_trans::back::link;\n \n use driver;\n \n-use rustc::ast_map::{self, blocks, NodePrinter};\n use rustc::middle::ty;\n use rustc::middle::cfg;\n use rustc::middle::cfg::graphviz::LabelledCFG;\n@@ -44,18 +43,23 @@ use std::option;\n use std::path::PathBuf;\n use std::str::FromStr;\n \n+use rustc::front::map as hir_map;\n+use rustc::front::map::{blocks, NodePrinter};\n+use rustc_front::hir;\n+use rustc_front::lowering::lower_crate;\n+use rustc_front::print::pprust as pprust_hir;\n+\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n     PpmNormal,\n     PpmEveryBodyLoops,\n     PpmExpanded,\n-    PpmTyped,\n     PpmIdentified,\n     PpmExpandedIdentified,\n     PpmExpandedHygiene,\n+    PpmTyped,\n }\n \n-\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpFlowGraphMode {\n     Default,\n@@ -68,6 +72,7 @@ pub enum PpFlowGraphMode {\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpMode {\n     PpmSource(PpSourceMode),\n+    PpmHir(PpSourceMode),\n     PpmFlowGraph(PpFlowGraphMode),\n }\n \n@@ -79,25 +84,27 @@ pub fn parse_pretty(sess: &Session,\n     let opt_second = split.next();\n     let first = match (first, extended) {\n         (\"normal\", _)       => PpmSource(PpmNormal),\n+        (\"identified\", _)   => PpmSource(PpmIdentified),\n         (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n         (\"expanded\", _)     => PpmSource(PpmExpanded),\n-        (\"typed\", _)        => PpmSource(PpmTyped),\n         (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n         (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n-        (\"identified\", _)   => PpmSource(PpmIdentified),\n+        (\"hir\", true)       => PpmHir(PpmNormal),\n+        (\"hir,identified\", true) => PpmHir(PpmExpandedIdentified),\n+        (\"hir,typed\", true)        => PpmHir(PpmTyped),\n         (\"flowgraph\", true)    => PpmFlowGraph(PpFlowGraphMode::Default),\n         (\"flowgraph,unlabelled\", true)    => PpmFlowGraph(PpFlowGraphMode::UnlabelledEdges),\n         _ => {\n             if extended {\n                 sess.fatal(&format!(\n                     \"argument to `unpretty` must be one of `normal`, \\\n-                     `expanded`, `flowgraph[,unlabelled]=<nodeid>`, `typed`, `identified`, \\\n-                     `expanded,identified`, or `everybody_loops`; got {}\", name));\n+                     `expanded`, `flowgraph[,unlabelled]=<nodeid>`, `identified`, \\\n+                     `expanded,identified`, `everybody_loops`, `hir`, \\\n+                     `hir,identified`, or `hir,typed`; got {}\", name));\n             } else {\n                 sess.fatal(&format!(\n-                    \"argument to `pretty` must be one of `normal`, \\\n-                     `expanded`, `typed`, `identified`, \\\n-                     or `expanded,identified`; got {}\", name));\n+                    \"argument to `pretty` must be one of `normal`, `expanded`, \\\n+                     `identified`, or `expanded,identified`; got {}\", name));\n             }\n         }\n     };\n@@ -124,9 +131,7 @@ impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, B, F>(&self,\n                                            sess: Session,\n-                                           ast_map: Option<ast_map::Map<'tcx>>,\n-                                           arenas: &'tcx ty::CtxtArenas<'tcx>,\n-                                           id: String,\n+                                           ast_map: Option<hir_map::Map<'tcx>>,\n                                            payload: B,\n                                            f: F) -> A where\n         F: FnOnce(&PrinterSupport, B) -> A,\n@@ -145,18 +150,45 @@ impl PpSourceMode {\n                 let annotation = HygieneAnnotation { sess: sess, ast_map: ast_map };\n                 f(&annotation, payload)\n             }\n+            _ => panic!(\"Should use call_with_pp_support_hir\"),\n+        }\n+    }\n+    fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n+                                               sess: Session,\n+                                               ast_map: &hir_map::Map<'tcx>,\n+                                               ast_crate: &ast::Crate,\n+                                               arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                               id: String,\n+                                               payload: B,\n+                                               f: F) -> A where\n+        F: FnOnce(&HirPrinterSupport, B, &hir::Crate) -> A,\n+    {\n+        match *self {\n+            PpmNormal => {\n+                let annotation = NoAnn { sess: sess, ast_map: Some(ast_map.clone()) };\n+                f(&annotation, payload, &ast_map.forest.krate)\n+            }\n+\n+            PpmIdentified => {\n+                let annotation = IdentifiedAnnotation {\n+                    sess: sess,\n+                    ast_map: Some(ast_map.clone())\n+                };\n+                f(&annotation, payload, &ast_map.forest.krate)\n+            }\n             PpmTyped => {\n-                let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n                 driver::phase_3_run_analysis_passes(sess,\n-                                                    ast_map,\n+                                                    ast_map.clone(),\n+                                                    ast_crate,\n                                                     arenas,\n                                                     id,\n                                                     resolve::MakeGlobMap::No,\n                                                     |tcx, _| {\n                     let annotation = TypedAnnotation { tcx: tcx };\n-                    f(&annotation, payload)\n+                    f(&annotation, payload, &ast_map.forest.krate)\n                 }).1\n             }\n+            _ => panic!(\"Should use call_with_pp_support\"),\n         }\n     }\n }\n@@ -167,8 +199,8 @@ trait PrinterSupport<'ast>: pprust::PpAnn {\n     fn sess<'a>(&'a self) -> &'a Session;\n \n     /// Provides a uniform interface for re-extracting a reference to an\n-    /// `ast_map::Map` from a value that now owns it.\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>>;\n+    /// `hir_map::Map` from a value that now owns it.\n+    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>>;\n \n     /// Produces the pretty-print annotation object.\n     ///\n@@ -177,32 +209,59 @@ trait PrinterSupport<'ast>: pprust::PpAnn {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n }\n \n+trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n+    /// Provides a uniform interface for re-extracting a reference to a\n+    /// `Session` from a value that now owns it.\n+    fn sess<'a>(&'a self) -> &'a Session;\n+\n+    /// Provides a uniform interface for re-extracting a reference to an\n+    /// `hir_map::Map` from a value that now owns it.\n+    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>>;\n+\n+    /// Produces the pretty-print annotation object.\n+    ///\n+    /// (Rust does not yet support upcasting from a trait object to\n+    /// an object for one of its super-traits.)\n+    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn;\n+}\n+\n struct NoAnn<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map<'ast>>\n+    ast_map: Option<hir_map::Map<'ast>>\n }\n \n impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n+impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+\n+    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n+        self.ast_map.as_ref()\n+    }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n+}\n+\n impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n+impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {}\n \n struct IdentifiedAnnotation<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map<'ast>>,\n+    ast_map: Option<hir_map::Map<'ast>>,\n }\n \n impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n \n@@ -249,15 +308,65 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     }\n }\n \n+impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+\n+    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n+        self.ast_map.as_ref()\n+    }\n+\n+    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n+}\n+\n+impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n+    fn pre(&self,\n+           s: &mut pprust_hir::State,\n+           node: pprust_hir::AnnNode) -> io::Result<()> {\n+        match node {\n+            pprust_hir::NodeExpr(_) => s.popen(),\n+            _ => Ok(())\n+        }\n+    }\n+    fn post(&self,\n+            s: &mut pprust_hir::State,\n+            node: pprust_hir::AnnNode) -> io::Result<()> {\n+        match node {\n+            pprust_hir::NodeIdent(_) | pprust_hir::NodeName(_) => Ok(()),\n+\n+            pprust_hir::NodeItem(item) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(item.id.to_string())\n+            }\n+            pprust_hir::NodeSubItem(id) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(id.to_string())\n+            }\n+            pprust_hir::NodeBlock(blk) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(format!(\"block {}\", blk.id))\n+            }\n+            pprust_hir::NodeExpr(expr) => {\n+                try!(pp::space(&mut s.s));\n+                try!(s.synth_comment(expr.id.to_string()));\n+                s.pclose()\n+            }\n+            pprust_hir::NodePat(pat) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(format!(\"pat {}\", pat.id))\n+            }\n+        }\n+    }\n+}\n+\n struct HygieneAnnotation<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map<'ast>>,\n+    ast_map: Option<hir_map::Map<'ast>>,\n }\n \n impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n \n@@ -289,30 +398,30 @@ struct TypedAnnotation<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n }\n \n-impl<'b, 'tcx> PrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n+impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.tcx.sess }\n \n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'tcx>> {\n         Some(&self.tcx.map)\n     }\n \n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n }\n \n-impl<'a, 'tcx> pprust::PpAnn for TypedAnnotation<'a, 'tcx> {\n+impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     fn pre(&self,\n-           s: &mut pprust::State,\n-           node: pprust::AnnNode) -> io::Result<()> {\n+           s: &mut pprust_hir::State,\n+           node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeExpr(_) => s.popen(),\n+            pprust_hir::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n     fn post(&self,\n-            s: &mut pprust::State,\n-            node: pprust::AnnNode) -> io::Result<()> {\n+            s: &mut pprust_hir::State,\n+            node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeExpr(expr) => {\n+            pprust_hir::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n@@ -360,7 +469,7 @@ impl FromStr for UserIdentifiedItem {\n \n enum NodesMatchingUII<'a, 'ast: 'a> {\n     NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast>),\n+    NodesMatchingSuffix(hir_map::NodesMatchingSuffix<'a, 'ast>),\n }\n \n impl<'a, 'ast> Iterator for NodesMatchingUII<'a, 'ast> {\n@@ -382,7 +491,7 @@ impl UserIdentifiedItem {\n         }\n     }\n \n-    fn all_matching_node_ids<'a, 'ast>(&'a self, map: &'a ast_map::Map<'ast>)\n+    fn all_matching_node_ids<'a, 'ast>(&'a self, map: &'a hir_map::Map<'ast>)\n                                        -> NodesMatchingUII<'a, 'ast> {\n         match *self {\n             ItemViaNode(node_id) =>\n@@ -392,7 +501,7 @@ impl UserIdentifiedItem {\n         }\n     }\n \n-    fn to_one_node_id(self, user_option: &str, sess: &Session, map: &ast_map::Map) -> ast::NodeId {\n+    fn to_one_node_id(self, user_option: &str, sess: &Session, map: &hir_map::Map) -> ast::NodeId {\n         let fail_because = |is_wrong_because| -> ast::NodeId {\n             let message =\n                 format!(\"{} needs NodeId (int) or unique \\\n@@ -430,8 +539,9 @@ fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n         PpmSource(PpmExpanded) |\n         PpmSource(PpmExpandedIdentified) |\n         PpmSource(PpmExpandedHygiene) |\n-        PpmSource(PpmTyped) |\n-        PpmFlowGraph(_) => true\n+        PpmHir(_) |\n+        PpmFlowGraph(_) => true,\n+        PpmSource(PpmTyped) => panic!(\"invalid state\"),\n     }\n }\n \n@@ -444,8 +554,9 @@ fn needs_expansion(ppm: &PpMode) -> bool {\n         PpmSource(PpmExpanded) |\n         PpmSource(PpmExpandedIdentified) |\n         PpmSource(PpmExpandedHygiene) |\n-        PpmSource(PpmTyped) |\n-        PpmFlowGraph(_) => true\n+        PpmHir(_) |\n+        PpmFlowGraph(_) => true,\n+        PpmSource(PpmTyped) => panic!(\"invalid state\"),\n     }\n }\n \n@@ -552,20 +663,22 @@ pub fn pretty_print_input(sess: Session,\n     let krate = if compute_ast_map {\n         match driver::phase_2_configure_and_expand(&sess, krate, &id[..], None) {\n             None => return,\n-            Some(k) => k\n+            Some(k) => driver::assign_node_ids(&sess, k)\n         }\n     } else {\n         krate\n     };\n \n-    let mut forest = ast_map::Forest::new(krate);\n+    // There is some twisted, god-forsaken tangle of lifetimes here which makes\n+    // the ordering of stuff super-finicky.\n+    let mut hir_forest;\n     let arenas = ty::CtxtArenas::new();\n-\n-    let (krate, ast_map) = if compute_ast_map {\n-        let map = driver::assign_node_ids_and_map(&sess, &mut forest);\n-        (map.krate(), Some(map))\n+    let ast_map = if compute_ast_map {\n+        hir_forest = hir_map::Forest::new(lower_crate(&krate));\n+        let map = driver::make_map(&sess, &mut hir_forest);\n+        Some(map)\n     } else {\n-        (forest.krate(), None)\n+        None\n     };\n \n     let src_name = driver::source_name(input);\n@@ -580,15 +693,16 @@ pub fn pretty_print_input(sess: Session,\n     let mut out = Vec::new();\n \n     match (ppm, opt_uii) {\n-        (PpmSource(s), None) => {\n+        (PpmSource(s), _) => {\n+            // Silently ignores an identified node.\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support(\n-                sess, ast_map, &arenas, id, box out, |annotation, out| {\n+                sess, ast_map, box out, |annotation, out| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n                                         sess.diagnostic(),\n-                                        krate,\n+                                        &krate,\n                                         src_name.to_string(),\n                                         &mut rdr,\n                                         out,\n@@ -597,31 +711,52 @@ pub fn pretty_print_input(sess: Session,\n             })\n         }\n \n-        (PpmSource(s), Some(uii)) => {\n+        (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support(\n-                sess, ast_map, &arenas, id, (out,uii), |annotation, (out,uii)| {\n+            s.call_with_pp_support_hir(\n+                sess, &ast_map.unwrap(), &krate, &arenas, id, box out, |annotation, out, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n-                    let ast_map = annotation.ast_map()\n-                        .expect(\"--pretty missing ast_map\");\n-                    let mut pp_state =\n-                        pprust::State::new_from_input(sess.codemap(),\n+                    pprust_hir::print_crate(sess.codemap(),\n+                                            sess.diagnostic(),\n+                                            krate,\n+                                            src_name.to_string(),\n+                                            &mut rdr,\n+                                            out,\n+                                            annotation.pp_ann(),\n+                                            is_expanded)\n+            })\n+        }\n+\n+        (PpmHir(s), Some(uii)) => {\n+            let out: &mut Write = &mut out;\n+            s.call_with_pp_support_hir(sess,\n+                                       &ast_map.unwrap(),\n+                                       &krate,\n+                                       &arenas,\n+                                       id,\n+                                       (out,uii),\n+                                       |annotation, (out,uii), _| {\n+                debug!(\"pretty printing source code {:?}\", s);\n+                let sess = annotation.sess();\n+                let ast_map = annotation.ast_map().expect(\"--pretty missing ast_map\");\n+                let mut pp_state =\n+                    pprust_hir::State::new_from_input(sess.codemap(),\n                                                       sess.diagnostic(),\n                                                       src_name.to_string(),\n                                                       &mut rdr,\n                                                       box out,\n                                                       annotation.pp_ann(),\n-                                                      is_expanded);\n-                    for node_id in uii.all_matching_node_ids(ast_map) {\n-                        let node = ast_map.get(node_id);\n-                        try!(pp_state.print_node(&node));\n-                        try!(pp::space(&mut pp_state.s));\n-                        try!(pp_state.synth_comment(ast_map.path_to_string(node_id)));\n-                        try!(pp::hardbreak(&mut pp_state.s));\n-                    }\n-                    pp::eof(&mut pp_state.s)\n-                })\n+                                                      true);\n+                for node_id in uii.all_matching_node_ids(ast_map) {\n+                    let node = ast_map.get(node_id);\n+                    try!(pp_state.print_node(&node));\n+                    try!(pp::space(&mut pp_state.s));\n+                    try!(pp_state.synth_comment(ast_map.path_to_string(node_id)));\n+                    try!(pp::hardbreak(&mut pp_state.s));\n+                }\n+                pp::eof(&mut pp_state.s)\n+            })\n         }\n \n         (PpmFlowGraph(mode), opt_uii) => {\n@@ -646,6 +781,7 @@ pub fn pretty_print_input(sess: Session,\n                     let variants = gather_flowgraph_variants(&sess);\n                     driver::phase_3_run_analysis_passes(sess,\n                                                         ast_map,\n+                                                        &krate,\n                                                         &arenas,\n                                                         id,\n                                                         resolve::MakeGlobMap::No,"}, {"sha": "c96495fcfc986969a13371bbef580acbe60235a7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -29,7 +29,7 @@ use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n use rustc_typeck::middle::infer::sub::Sub;\n-use rustc::ast_map;\n+use rustc::front::map as hir_map;\n use rustc::session::{self,config};\n use syntax::{abi, ast};\n use syntax::codemap;\n@@ -38,6 +38,9 @@ use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, He\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n \n+use rustc_front::lowering::lower_crate;\n+use rustc_front::hir;\n+\n struct Env<'a, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'tcx>,\n }\n@@ -120,9 +123,10 @@ fn test_env<F>(source_string: &str,\n     let krate = driver::phase_2_configure_and_expand(&sess, krate, \"test\", None)\n                     .expect(\"phase 2 aborted\");\n \n-    let mut forest = ast_map::Forest::new(krate);\n+    let krate = driver::assign_node_ids(&sess, krate);\n+    let mut hir_forest = hir_map::Forest::new(lower_crate(&krate));\n     let arenas = ty::CtxtArenas::new();\n-    let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n+    let ast_map = driver::make_map(&sess, &mut hir_forest);\n     let krate = ast_map.krate();\n \n     // run just enough stuff to build a tcx:\n@@ -185,7 +189,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         };\n \n         fn search_mod(this: &Env,\n-                      m: &ast::Mod,\n+                      m: &hir::Mod,\n                       idx: usize,\n                       names: &[String])\n                       -> Option<ast::NodeId> {\n@@ -199,7 +203,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         }\n \n         fn search(this: &Env,\n-                  it: &ast::Item,\n+                  it: &hir::Item,\n                   idx: usize,\n                   names: &[String])\n                   -> Option<ast::NodeId> {\n@@ -208,19 +212,19 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             }\n \n             return match it.node {\n-                ast::ItemUse(..) | ast::ItemExternCrate(..) |\n-                ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemFn(..) |\n-                ast::ItemForeignMod(..) | ast::ItemTy(..) => {\n+                hir::ItemUse(..) | hir::ItemExternCrate(..) |\n+                hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n+                hir::ItemForeignMod(..) | hir::ItemTy(..) => {\n                     None\n                 }\n \n-                ast::ItemEnum(..) | ast::ItemStruct(..) |\n-                ast::ItemTrait(..) | ast::ItemImpl(..) |\n-                ast::ItemMac(..) | ast::ItemDefaultImpl(..) => {\n+                hir::ItemEnum(..) | hir::ItemStruct(..) |\n+                hir::ItemTrait(..) | hir::ItemImpl(..) |\n+                hir::ItemDefaultImpl(..) => {\n                     None\n                 }\n \n-                ast::ItemMod(ref m) => {\n+                hir::ItemMod(ref m) => {\n                     search_mod(this, m, idx, names)\n                 }\n             };\n@@ -260,7 +264,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         let input_args = input_tys.iter().cloned().collect();\n         self.infcx.tcx.mk_fn(None,\n             self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n-                unsafety: ast::Unsafety::Normal,\n+                unsafety: hir::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: input_args,"}, {"sha": "8609fd9b9d965b939b50ce06e109a92435ed021a", "filename": "src/librustc_front/attr.rs", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fattr.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -0,0 +1,628 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Functions dealing with attributes and meta items\n+\n+pub use self::StabilityLevel::*;\n+pub use self::ReprAttr::*;\n+pub use self::IntType::*;\n+\n+use hir;\n+use hir::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n+use lowering::{lower_attr_style, unlower_attribute};\n+use syntax::codemap::{Span, Spanned, spanned, dummy_spanned};\n+use syntax::codemap::BytePos;\n+use syntax::diagnostic::SpanHandler;\n+use syntax::attr as syntax_attr;\n+use syntax::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use syntax::parse::token::{InternedString, intern_and_get_ident};\n+use syntax::parse::token;\n+use syntax::ptr::P;\n+\n+use std::cell::Cell;\n+use std::collections::HashSet;\n+use std::fmt;\n+\n+pub fn mark_used(attr: &Attribute) {\n+    syntax_attr::mark_used(&unlower_attribute(attr))\n+}\n+\n+pub trait AttrMetaMethods {\n+    fn check_name(&self, name: &str) -> bool {\n+        name == &self.name()[..]\n+    }\n+\n+    /// Retrieve the name of the meta item, e.g. `foo` in `#[foo]`,\n+    /// `#[foo=\"bar\"]` and `#[foo(bar)]`\n+    fn name(&self) -> InternedString;\n+\n+    /// Gets the string value if self is a MetaNameValue variant\n+    /// containing a string, otherwise None.\n+    fn value_str(&self) -> Option<InternedString>;\n+    /// Gets a list of inner meta items from a list MetaItem type.\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]>;\n+\n+    fn span(&self) -> Span;\n+}\n+\n+impl AttrMetaMethods for Attribute {\n+    fn check_name(&self, name: &str) -> bool {\n+        let matches = name == &self.name()[..];\n+        if matches {\n+            syntax_attr::mark_used(&unlower_attribute(self));\n+        }\n+        matches\n+    }\n+    fn name(&self) -> InternedString { self.meta().name() }\n+    fn value_str(&self) -> Option<InternedString> {\n+        self.meta().value_str()\n+    }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n+        self.node.value.meta_item_list()\n+    }\n+    fn span(&self) -> Span { self.meta().span }\n+}\n+\n+impl AttrMetaMethods for MetaItem {\n+    fn name(&self) -> InternedString {\n+        match self.node {\n+            MetaWord(ref n) => (*n).clone(),\n+            MetaNameValue(ref n, _) => (*n).clone(),\n+            MetaList(ref n, _) => (*n).clone(),\n+        }\n+    }\n+\n+    fn value_str(&self) -> Option<InternedString> {\n+        match self.node {\n+            MetaNameValue(_, ref v) => {\n+                match v.node {\n+                    hir::LitStr(ref s, _) => Some((*s).clone()),\n+                    _ => None,\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n+        match self.node {\n+            MetaList(_, ref l) => Some(&l[..]),\n+            _ => None\n+        }\n+    }\n+    fn span(&self) -> Span { self.span }\n+}\n+\n+// Annoying, but required to get test_cfg to work\n+impl AttrMetaMethods for P<MetaItem> {\n+    fn name(&self) -> InternedString { (**self).name() }\n+    fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n+        (**self).meta_item_list()\n+    }\n+    fn span(&self) -> Span { (**self).span() }\n+}\n+\n+\n+pub trait AttributeMethods {\n+    fn meta<'a>(&'a self) -> &'a MetaItem;\n+    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n+        F: FnOnce(&Attribute) -> T;\n+}\n+\n+impl AttributeMethods for Attribute {\n+    /// Extract the MetaItem from inside this Attribute.\n+    fn meta<'a>(&'a self) -> &'a MetaItem {\n+        &*self.node.value\n+    }\n+\n+    /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n+    /// comment like `///` or `/** */`. (Returns self unchanged for\n+    /// non-sugared doc attributes.)\n+    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n+        F: FnOnce(&Attribute) -> T,\n+    {\n+        if self.node.is_sugared_doc {\n+            let comment = self.value_str().unwrap();\n+            let meta = mk_name_value_item_str(\n+                InternedString::new(\"doc\"),\n+                token::intern_and_get_ident(&strip_doc_comment_decoration(\n+                        &comment)));\n+            if self.node.style == hir::AttrOuter {\n+                f(&mk_attr_outer(self.node.id, meta))\n+            } else {\n+                f(&mk_attr_inner(self.node.id, meta))\n+            }\n+        } else {\n+            f(self)\n+        }\n+    }\n+}\n+\n+/* Constructors */\n+\n+pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n+                              -> P<MetaItem> {\n+    let value_lit = dummy_spanned(hir::LitStr(value, hir::CookedStr));\n+    mk_name_value_item(name, value_lit)\n+}\n+\n+pub fn mk_name_value_item(name: InternedString, value: hir::Lit)\n+                          -> P<MetaItem> {\n+    P(dummy_spanned(MetaNameValue(name, value)))\n+}\n+\n+pub fn mk_list_item(name: InternedString, items: Vec<P<MetaItem>>) -> P<MetaItem> {\n+    P(dummy_spanned(MetaList(name, items)))\n+}\n+\n+pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n+    P(dummy_spanned(MetaWord(name)))\n+}\n+\n+thread_local! { static NEXT_ATTR_ID: Cell<usize> = Cell::new(0) }\n+\n+pub fn mk_attr_id() -> AttrId {\n+    let id = NEXT_ATTR_ID.with(|slot| {\n+        let r = slot.get();\n+        slot.set(r + 1);\n+        r\n+    });\n+    AttrId(id)\n+}\n+\n+/// Returns an inner attribute with the given value.\n+pub fn mk_attr_inner(id: AttrId, item: P<MetaItem>) -> Attribute {\n+    dummy_spanned(Attribute_ {\n+        id: id,\n+        style: hir::AttrInner,\n+        value: item,\n+        is_sugared_doc: false,\n+    })\n+}\n+\n+/// Returns an outer attribute with the given value.\n+pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n+    dummy_spanned(Attribute_ {\n+        id: id,\n+        style: hir::AttrOuter,\n+        value: item,\n+        is_sugared_doc: false,\n+    })\n+}\n+\n+pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n+                           hi: BytePos)\n+                           -> Attribute {\n+    let style = lower_attr_style(doc_comment_style(&text));\n+    let lit = spanned(lo, hi, hir::LitStr(text, hir::CookedStr));\n+    let attr = Attribute_ {\n+        id: id,\n+        style: style,\n+        value: P(spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n+                                               lit))),\n+        is_sugared_doc: true\n+    };\n+    spanned(lo, hi, attr)\n+}\n+\n+/* Searching */\n+/// Check if `needle` occurs in `haystack` by a structural\n+/// comparison. This is slightly subtle, and relies on ignoring the\n+/// span included in the `==` comparison a plain MetaItem.\n+pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n+    debug!(\"attr::contains (name={})\", needle.name());\n+    haystack.iter().any(|item| {\n+        debug!(\"  testing: {}\", item.name());\n+        item.node == needle.node\n+    })\n+}\n+\n+pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n+    debug!(\"attr::contains_name (name={})\", name);\n+    metas.iter().any(|item| {\n+        debug!(\"  testing: {}\", item.name());\n+        item.check_name(name)\n+    })\n+}\n+\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n+                                 -> Option<InternedString> {\n+    attrs.iter()\n+        .find(|at| at.check_name(name))\n+        .and_then(|at| at.value_str())\n+}\n+\n+pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n+                                     -> Option<InternedString> {\n+    items.iter()\n+         .rev()\n+         .find(|mi| mi.check_name(name))\n+         .and_then(|i| i.value_str())\n+}\n+\n+/* Higher-level applications */\n+\n+pub fn sort_meta_items(items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n+    // This is sort of stupid here, but we need to sort by\n+    // human-readable strings.\n+    let mut v = items.into_iter()\n+        .map(|mi| (mi.name(), mi))\n+        .collect::<Vec<(InternedString, P<MetaItem>)>>();\n+\n+    v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n+\n+    // There doesn't seem to be a more optimal way to do this\n+    v.into_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n+        Spanned {\n+            node: match node {\n+                MetaList(n, mis) => MetaList(n, sort_meta_items(mis)),\n+                _ => node\n+            },\n+            span: span\n+        }\n+    })).collect()\n+}\n+\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n+    first_attr_value_str_by_name(attrs, \"crate_name\")\n+}\n+\n+/// Find the value of #[export_name=*] attribute and check its validity.\n+pub fn find_export_name_attr(diag: &SpanHandler, attrs: &[Attribute]) -> Option<InternedString> {\n+    attrs.iter().fold(None, |ia,attr| {\n+        if attr.check_name(\"export_name\") {\n+            if let s@Some(_) = attr.value_str() {\n+                s\n+            } else {\n+                diag.span_err(attr.span, \"export_name attribute has invalid format\");\n+                diag.handler.help(\"use #[export_name=\\\"*\\\"]\");\n+                None\n+            }\n+        } else {\n+            ia\n+        }\n+    })\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum InlineAttr {\n+    None,\n+    Hint,\n+    Always,\n+    Never,\n+}\n+\n+/// Determine what `#[inline]` attribute is present in `attrs`, if any.\n+pub fn find_inline_attr(diagnostic: Option<&SpanHandler>, attrs: &[Attribute]) -> InlineAttr {\n+    // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n+    attrs.iter().fold(InlineAttr::None, |ia,attr| {\n+        match attr.node.value.node {\n+            MetaWord(ref n) if *n == \"inline\" => {\n+                syntax_attr::mark_used(&unlower_attribute(attr));\n+                InlineAttr::Hint\n+            }\n+            MetaList(ref n, ref items) if *n == \"inline\" => {\n+                syntax_attr::mark_used(&unlower_attribute(attr));\n+                if items.len() != 1 {\n+                    diagnostic.map(|d|{ d.span_err(attr.span, \"expected one argument\"); });\n+                    InlineAttr::None\n+                } else if contains_name(&items[..], \"always\") {\n+                    InlineAttr::Always\n+                } else if contains_name(&items[..], \"never\") {\n+                    InlineAttr::Never\n+                } else {\n+                    diagnostic.map(|d|{ d.span_err((*items[0]).span, \"invalid argument\"); });\n+                    InlineAttr::None\n+                }\n+            }\n+            _ => ia\n+        }\n+    })\n+}\n+\n+/// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n+pub fn requests_inline(attrs: &[Attribute]) -> bool {\n+    match find_inline_attr(None, attrs) {\n+        InlineAttr::Hint | InlineAttr::Always => true,\n+        InlineAttr::None | InlineAttr::Never => false,\n+    }\n+}\n+\n+/// Represents the #[deprecated] and friends attributes.\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Stability {\n+    pub level: StabilityLevel,\n+    pub feature: InternedString,\n+    pub since: Option<InternedString>,\n+    pub deprecated_since: Option<InternedString>,\n+    // The reason for the current stability level. If deprecated, the\n+    // reason for deprecation.\n+    pub reason: Option<InternedString>,\n+    // The relevant rust-lang issue\n+    pub issue: Option<u32>\n+}\n+\n+/// The available stability levels.\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Copy, Eq, Hash)]\n+pub enum StabilityLevel {\n+    Unstable,\n+    Stable,\n+}\n+\n+impl fmt::Display for StabilityLevel {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self, f)\n+    }\n+}\n+\n+fn find_stability_generic<'a,\n+                              AM: AttrMetaMethods,\n+                              I: Iterator<Item=&'a AM>>\n+                             (diagnostic: &SpanHandler, attrs: I, item_sp: Span)\n+                             -> (Option<Stability>, Vec<&'a AM>) {\n+\n+    let mut stab: Option<Stability> = None;\n+    let mut deprecated: Option<(Option<InternedString>, Option<InternedString>)> = None;\n+    let mut used_attrs: Vec<&'a AM> = vec![];\n+\n+    'outer: for attr in attrs {\n+        let tag = attr.name();\n+        let tag = &tag[..];\n+        if tag != \"deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n+            continue // not a stability level\n+        }\n+\n+        used_attrs.push(attr);\n+\n+        let (feature, since, reason, issue) = match attr.meta_item_list() {\n+            Some(metas) => {\n+                let mut feature = None;\n+                let mut since = None;\n+                let mut reason = None;\n+                let mut issue = None;\n+                for meta in metas {\n+                    match &*meta.name() {\n+                        \"feature\" => {\n+                            match meta.value_str() {\n+                                Some(v) => feature = Some(v),\n+                                None => {\n+                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                                    continue 'outer;\n+                                }\n+                            }\n+                        }\n+                        \"since\" => {\n+                            match meta.value_str() {\n+                                Some(v) => since = Some(v),\n+                                None => {\n+                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                                    continue 'outer;\n+                                }\n+                            }\n+                        }\n+                        \"reason\" => {\n+                            match meta.value_str() {\n+                                Some(v) => reason = Some(v),\n+                                None => {\n+                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                                    continue 'outer;\n+                                }\n+                            }\n+                        }\n+                        \"issue\" => {\n+                            match meta.value_str().and_then(|s| s.parse().ok()) {\n+                                Some(v) => issue = Some(v),\n+                                None => {\n+                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                                    continue 'outer;\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                (feature, since, reason, issue)\n+            }\n+            None => {\n+                diagnostic.span_err(attr.span(), \"incorrect stability attribute type\");\n+                continue\n+            }\n+        };\n+\n+        // Deprecated tags don't require feature names\n+        if feature == None && tag != \"deprecated\" {\n+            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+        }\n+\n+        // Unstable tags don't require a version\n+        if since == None && tag != \"unstable\" {\n+            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+        }\n+\n+        if tag == \"unstable\" || tag == \"stable\" {\n+            if stab.is_some() {\n+                diagnostic.span_err(item_sp, \"multiple stability levels\");\n+            }\n+\n+            let level = match tag {\n+                \"unstable\" => Unstable,\n+                \"stable\" => Stable,\n+                _ => unreachable!()\n+            };\n+\n+            stab = Some(Stability {\n+                level: level,\n+                feature: feature.unwrap_or(intern_and_get_ident(\"bogus\")),\n+                since: since,\n+                deprecated_since: None,\n+                reason: reason,\n+                issue: issue,\n+            });\n+        } else { // \"deprecated\"\n+            if deprecated.is_some() {\n+                diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n+            }\n+\n+            deprecated = Some((since, reason));\n+        }\n+    }\n+\n+    // Merge the deprecation info into the stability info\n+    if deprecated.is_some() {\n+        match stab {\n+            Some(ref mut s) => {\n+                let (since, reason) = deprecated.unwrap();\n+                s.deprecated_since = since;\n+                s.reason = reason;\n+            }\n+            None => {\n+                diagnostic.span_err(item_sp, \"deprecated attribute must be paired with \\\n+                                              either stable or unstable attribute\");\n+            }\n+        }\n+    } else if stab.as_ref().map_or(false, |s| s.level == Unstable && s.issue.is_none()) {\n+        // non-deprecated unstable items need to point to issues.\n+        diagnostic.span_err(item_sp,\n+                            \"non-deprecated unstable items need to point \\\n+                             to an issue with `issue = \\\"NNN\\\"`\");\n+    }\n+\n+    (stab, used_attrs)\n+}\n+\n+/// Find the first stability attribute. `None` if none exists.\n+pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n+                      item_sp: Span) -> Option<Stability> {\n+    let (s, used) = find_stability_generic(diagnostic, attrs.iter(), item_sp);\n+    for used in used { syntax_attr::mark_used(&unlower_attribute(used)) }\n+    return s;\n+}\n+\n+pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n+    let mut set = HashSet::new();\n+    for meta in metas {\n+        let name = meta.name();\n+\n+        if !set.insert(name.clone()) {\n+            panic!(diagnostic.span_fatal(meta.span,\n+                                  &format!(\"duplicate meta item `{}`\", name)));\n+        }\n+    }\n+}\n+\n+\n+/// Parse #[repr(...)] forms.\n+///\n+/// Valid repr contents: any of the primitive integral type names (see\n+/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n+/// the same discriminant size that the corresponding C enum would or C\n+/// structure layout, and `packed` to remove padding.\n+pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAttr> {\n+    let mut acc = Vec::new();\n+    match attr.node.value.node {\n+        hir::MetaList(ref s, ref items) if *s == \"repr\" => {\n+            syntax_attr::mark_used(&unlower_attribute(attr));\n+            for item in items {\n+                match item.node {\n+                    hir::MetaWord(ref word) => {\n+                        let hint = match &word[..] {\n+                            // Can't use \"extern\" because it's not a lexical identifier.\n+                            \"C\" => Some(ReprExtern),\n+                            \"packed\" => Some(ReprPacked),\n+                            \"simd\" => Some(ReprSimd),\n+                            _ => match int_type_of_word(&word) {\n+                                Some(ity) => Some(ReprInt(item.span, ity)),\n+                                None => {\n+                                    // Not a word we recognize\n+                                    diagnostic.span_err(item.span,\n+                                                        \"unrecognized representation hint\");\n+                                    None\n+                                }\n+                            }\n+                        };\n+\n+                        match hint {\n+                            Some(h) => acc.push(h),\n+                            None => { }\n+                        }\n+                    }\n+                    // Not a word:\n+                    _ => diagnostic.span_err(item.span, \"unrecognized enum representation hint\")\n+                }\n+            }\n+        }\n+        // Not a \"repr\" hint: ignore.\n+        _ => { }\n+    }\n+    acc\n+}\n+\n+fn int_type_of_word(s: &str) -> Option<IntType> {\n+    match s {\n+        \"i8\" => Some(SignedInt(hir::TyI8)),\n+        \"u8\" => Some(UnsignedInt(hir::TyU8)),\n+        \"i16\" => Some(SignedInt(hir::TyI16)),\n+        \"u16\" => Some(UnsignedInt(hir::TyU16)),\n+        \"i32\" => Some(SignedInt(hir::TyI32)),\n+        \"u32\" => Some(UnsignedInt(hir::TyU32)),\n+        \"i64\" => Some(SignedInt(hir::TyI64)),\n+        \"u64\" => Some(UnsignedInt(hir::TyU64)),\n+        \"isize\" => Some(SignedInt(hir::TyIs)),\n+        \"usize\" => Some(UnsignedInt(hir::TyUs)),\n+        _ => None\n+    }\n+}\n+\n+#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+pub enum ReprAttr {\n+    ReprAny,\n+    ReprInt(Span, IntType),\n+    ReprExtern,\n+    ReprPacked,\n+    ReprSimd,\n+}\n+\n+impl ReprAttr {\n+    pub fn is_ffi_safe(&self) -> bool {\n+        match *self {\n+            ReprAny => false,\n+            ReprInt(_sp, ity) => ity.is_ffi_safe(),\n+            ReprExtern => true,\n+            ReprPacked => false,\n+            ReprSimd => true,\n+        }\n+    }\n+}\n+\n+#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+pub enum IntType {\n+    SignedInt(hir::IntTy),\n+    UnsignedInt(hir::UintTy)\n+}\n+\n+impl IntType {\n+    #[inline]\n+    pub fn is_signed(self) -> bool {\n+        match self {\n+            SignedInt(..) => true,\n+            UnsignedInt(..) => false\n+        }\n+    }\n+    fn is_ffi_safe(self) -> bool {\n+        match self {\n+            SignedInt(hir::TyI8) | UnsignedInt(hir::TyU8) |\n+            SignedInt(hir::TyI16) | UnsignedInt(hir::TyU16) |\n+            SignedInt(hir::TyI32) | UnsignedInt(hir::TyU32) |\n+            SignedInt(hir::TyI64) | UnsignedInt(hir::TyU64) => true,\n+            SignedInt(hir::TyIs) | UnsignedInt(hir::TyUs) => false\n+        }\n+    }\n+}"}, {"sha": "c663ebbf945a713582dd97e273ea5ba550d89833", "filename": "src/librustc_front/fold.rs", "status": "added", "additions": 1192, "deletions": 0, "changes": 1192, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -0,0 +1,1192 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A Folder represents an HIR->HIR fold; it accepts a HIR piece,\n+//! and returns a piece of the same type.\n+\n+use hir::*;\n+use syntax::ast::{Ident, NodeId, DUMMY_NODE_ID};\n+use hir;\n+use syntax::codemap::{respan, Span, Spanned};\n+use syntax::owned_slice::OwnedSlice;\n+use syntax::ptr::P;\n+use syntax::parse::token;\n+use std::ptr;\n+use syntax::util::small_vector::SmallVector;\n+\n+\n+// This could have a better place to live.\n+pub trait MoveMap<T> {\n+    fn move_map<F>(self, f: F) -> Self where F: FnMut(T) -> T;\n+}\n+\n+impl<T> MoveMap<T> for Vec<T> {\n+    fn move_map<F>(mut self, mut f: F) -> Vec<T> where F: FnMut(T) -> T {\n+        for p in &mut self {\n+            unsafe {\n+                // FIXME(#5016) this shouldn't need to zero to be safe.\n+                ptr::write(p, f(ptr::read_and_drop(p)));\n+            }\n+        }\n+        self\n+    }\n+}\n+\n+impl<T> MoveMap<T> for OwnedSlice<T> {\n+    fn move_map<F>(self, f: F) -> OwnedSlice<T> where F: FnMut(T) -> T {\n+        OwnedSlice::from_vec(self.into_vec().move_map(f))\n+    }\n+}\n+\n+pub trait Folder : Sized {\n+    // Any additions to this trait should happen in form\n+    // of a call to a public `noop_*` function that only calls\n+    // out to the folder again, not other `noop_*` functions.\n+    //\n+    // This is a necessary API workaround to the problem of not\n+    // being able to call out to the super default method\n+    // in an overridden default method.\n+\n+    fn fold_crate(&mut self, c: Crate) -> Crate {\n+        noop_fold_crate(c, self)\n+    }\n+\n+    fn fold_meta_items(&mut self, meta_items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n+        noop_fold_meta_items(meta_items, self)\n+    }\n+\n+    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n+        noop_fold_meta_item(meta_item, self)\n+    }\n+\n+    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> {\n+        noop_fold_view_path(view_path, self)\n+    }\n+\n+    fn fold_foreign_item(&mut self, ni: P<ForeignItem>) -> P<ForeignItem> {\n+        noop_fold_foreign_item(ni, self)\n+    }\n+\n+    fn fold_item(&mut self, i: P<Item>) -> SmallVector<P<Item>> {\n+        noop_fold_item(i, self)\n+    }\n+\n+    fn fold_item_simple(&mut self, i: Item) -> Item {\n+        noop_fold_item_simple(i, self)\n+    }\n+\n+    fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n+        noop_fold_struct_field(sf, self)\n+    }\n+\n+    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n+        noop_fold_item_underscore(i, self)\n+    }\n+\n+    fn fold_trait_item(&mut self, i: P<TraitItem>) -> SmallVector<P<TraitItem>> {\n+        noop_fold_trait_item(i, self)\n+    }\n+\n+    fn fold_impl_item(&mut self, i: P<ImplItem>) -> SmallVector<P<ImplItem>> {\n+        noop_fold_impl_item(i, self)\n+    }\n+\n+    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n+        noop_fold_fn_decl(d, self)\n+    }\n+\n+    fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n+        noop_fold_block(b, self)\n+    }\n+\n+    fn fold_stmt(&mut self, s: P<Stmt>) -> SmallVector<P<Stmt>> {\n+        s.and_then(|s| noop_fold_stmt(s, self))\n+    }\n+\n+    fn fold_arm(&mut self, a: Arm) -> Arm {\n+        noop_fold_arm(a, self)\n+    }\n+\n+    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n+        noop_fold_pat(p, self)\n+    }\n+\n+    fn fold_decl(&mut self, d: P<Decl>) -> SmallVector<P<Decl>> {\n+        noop_fold_decl(d, self)\n+    }\n+\n+    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n+        e.map(|e| noop_fold_expr(e, self))\n+    }\n+\n+    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n+        noop_fold_ty(t, self)\n+    }\n+\n+    fn fold_ty_binding(&mut self, t: P<TypeBinding>) -> P<TypeBinding> {\n+        noop_fold_ty_binding(t, self)\n+    }\n+\n+    fn fold_mod(&mut self, m: Mod) -> Mod {\n+        noop_fold_mod(m, self)\n+    }\n+\n+    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod {\n+        noop_fold_foreign_mod(nm, self)\n+    }\n+\n+    fn fold_variant(&mut self, v: P<Variant>) -> P<Variant> {\n+        noop_fold_variant(v, self)\n+    }\n+\n+    fn fold_ident(&mut self, i: Ident) -> Ident {\n+        noop_fold_ident(i, self)\n+    }\n+\n+    fn fold_usize(&mut self, i: usize) -> usize {\n+        noop_fold_usize(i, self)\n+    }\n+\n+    fn fold_path(&mut self, p: Path) -> Path {\n+        noop_fold_path(p, self)\n+    }\n+\n+    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n+        noop_fold_path_parameters(p, self)\n+    }\n+\n+    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedParameterData)\n+                                           -> AngleBracketedParameterData\n+    {\n+        noop_fold_angle_bracketed_parameter_data(p, self)\n+    }\n+\n+    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedParameterData)\n+                                         -> ParenthesizedParameterData\n+    {\n+        noop_fold_parenthesized_parameter_data(p, self)\n+    }\n+\n+    fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n+        noop_fold_local(l, self)\n+    }\n+\n+    fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n+        noop_fold_explicit_self(es, self)\n+    }\n+\n+    fn fold_explicit_self_underscore(&mut self, es: ExplicitSelf_) -> ExplicitSelf_ {\n+        noop_fold_explicit_self_underscore(es, self)\n+    }\n+\n+    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n+        noop_fold_lifetime(l, self)\n+    }\n+\n+    fn fold_lifetime_def(&mut self, l: LifetimeDef) -> LifetimeDef {\n+        noop_fold_lifetime_def(l, self)\n+    }\n+\n+    fn fold_attribute(&mut self, at: Attribute) -> Option<Attribute> {\n+        noop_fold_attribute(at, self)\n+    }\n+\n+    fn fold_arg(&mut self, a: Arg) -> Arg {\n+        noop_fold_arg(a, self)\n+    }\n+\n+    fn fold_generics(&mut self, generics: Generics) -> Generics {\n+        noop_fold_generics(generics, self)\n+    }\n+\n+    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef {\n+        noop_fold_trait_ref(p, self)\n+    }\n+\n+    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef {\n+        noop_fold_poly_trait_ref(p, self)\n+    }\n+\n+    fn fold_struct_def(&mut self, struct_def: P<StructDef>) -> P<StructDef> {\n+        noop_fold_struct_def(struct_def, self)\n+    }\n+\n+    fn fold_lifetimes(&mut self, lts: Vec<Lifetime>) -> Vec<Lifetime> {\n+        noop_fold_lifetimes(lts, self)\n+    }\n+\n+    fn fold_lifetime_defs(&mut self, lts: Vec<LifetimeDef>) -> Vec<LifetimeDef> {\n+        noop_fold_lifetime_defs(lts, self)\n+    }\n+\n+    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n+        noop_fold_ty_param(tp, self)\n+    }\n+\n+    fn fold_ty_params(&mut self, tps: OwnedSlice<TyParam>) -> OwnedSlice<TyParam> {\n+        noop_fold_ty_params(tps, self)\n+    }\n+\n+    fn fold_opt_lifetime(&mut self, o_lt: Option<Lifetime>) -> Option<Lifetime> {\n+        noop_fold_opt_lifetime(o_lt, self)\n+    }\n+\n+    fn fold_variant_arg(&mut self, va: VariantArg) -> VariantArg {\n+        noop_fold_variant_arg(va, self)\n+    }\n+\n+    fn fold_opt_bounds(&mut self, b: Option<OwnedSlice<TyParamBound>>)\n+                       -> Option<OwnedSlice<TyParamBound>> {\n+        noop_fold_opt_bounds(b, self)\n+    }\n+\n+    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>)\n+                       -> OwnedSlice<TyParamBound> {\n+        noop_fold_bounds(b, self)\n+    }\n+\n+    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound {\n+        noop_fold_ty_param_bound(tpb, self)\n+    }\n+\n+    fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n+        noop_fold_mt(mt, self)\n+    }\n+\n+    fn fold_field(&mut self, field: Field) -> Field {\n+        noop_fold_field(field, self)\n+    }\n+\n+    fn fold_where_clause(&mut self, where_clause: WhereClause)\n+                         -> WhereClause {\n+        noop_fold_where_clause(where_clause, self)\n+    }\n+\n+    fn fold_where_predicate(&mut self, where_predicate: WherePredicate)\n+                            -> WherePredicate {\n+        noop_fold_where_predicate(where_predicate, self)\n+    }\n+\n+    fn new_id(&mut self, i: NodeId) -> NodeId {\n+        i\n+    }\n+\n+    fn new_span(&mut self, sp: Span) -> Span {\n+        sp\n+    }\n+}\n+\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T)\n+                                       -> Vec<P<MetaItem>> {\n+    meta_items.move_map(|x| fld.fold_meta_item(x))\n+}\n+\n+pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n+    view_path.map(|Spanned {node, span}| Spanned {\n+        node: match node {\n+            ViewPathSimple(ident, path) => {\n+                ViewPathSimple(ident, fld.fold_path(path))\n+            }\n+            ViewPathGlob(path) => {\n+                ViewPathGlob(fld.fold_path(path))\n+            }\n+            ViewPathList(path, path_list_idents) => {\n+                ViewPathList(fld.fold_path(path),\n+                             path_list_idents.move_map(|path_list_ident| {\n+                                Spanned {\n+                                    node: match path_list_ident.node {\n+                                        PathListIdent { id, name, rename } =>\n+                                            PathListIdent {\n+                                                id: fld.new_id(id),\n+                                                name: name,\n+                                                rename: rename,\n+                                            },\n+                                        PathListMod { id, rename } =>\n+                                            PathListMod {\n+                                                id: fld.new_id(id),\n+                                                rename: rename,\n+                                            }\n+                                    },\n+                                    span: fld.new_span(path_list_ident.span)\n+                                }\n+                             }))\n+            }\n+        },\n+        span: fld.new_span(span)\n+    })\n+}\n+\n+pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n+    attrs.into_iter().flat_map(|x| fld.fold_attribute(x)).collect()\n+}\n+\n+pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n+    Arm {\n+        attrs: fold_attrs(attrs, fld),\n+        pats: pats.move_map(|x| fld.fold_pat(x)),\n+        guard: guard.map(|x| fld.fold_expr(x)),\n+        body: fld.fold_expr(body),\n+    }\n+}\n+\n+pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n+    d.and_then(|Spanned {node, span}| match node {\n+        DeclLocal(l) => SmallVector::one(P(Spanned {\n+            node: DeclLocal(fld.fold_local(l)),\n+            span: fld.new_span(span)\n+        })),\n+        DeclItem(it) => fld.fold_item(it).into_iter().map(|i| P(Spanned {\n+            node: DeclItem(i),\n+            span: fld.new_span(span)\n+        })).collect()\n+    })\n+}\n+\n+pub fn noop_fold_ty_binding<T: Folder>(b: P<TypeBinding>, fld: &mut T) -> P<TypeBinding> {\n+    b.map(|TypeBinding { id, ident, ty, span }| TypeBinding {\n+        id: fld.new_id(id),\n+        ident: ident,\n+        ty: fld.fold_ty(ty),\n+        span: fld.new_span(span),\n+    })\n+}\n+\n+pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n+    t.map(|Ty {id, node, span}| Ty {\n+        id: fld.new_id(id),\n+        node: match node {\n+            TyInfer => node,\n+            TyVec(ty) => TyVec(fld.fold_ty(ty)),\n+            TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n+            TyRptr(region, mt) => {\n+                TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n+            }\n+            TyBareFn(f) => {\n+                TyBareFn(f.map(|BareFnTy {lifetimes, unsafety, abi, decl}| BareFnTy {\n+                    lifetimes: fld.fold_lifetime_defs(lifetimes),\n+                    unsafety: unsafety,\n+                    abi: abi,\n+                    decl: fld.fold_fn_decl(decl)\n+                }))\n+            }\n+            TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n+            TyParen(ty) => TyParen(fld.fold_ty(ty)),\n+            TyPath(qself, path) => {\n+                let qself = qself.map(|QSelf { ty, position }| {\n+                    QSelf {\n+                        ty: fld.fold_ty(ty),\n+                        position: position\n+                    }\n+                });\n+                TyPath(qself, fld.fold_path(path))\n+            }\n+            TyObjectSum(ty, bounds) => {\n+                TyObjectSum(fld.fold_ty(ty),\n+                            fld.fold_bounds(bounds))\n+            }\n+            TyFixedLengthVec(ty, e) => {\n+                TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n+            }\n+            TyTypeof(expr) => {\n+                TyTypeof(fld.fold_expr(expr))\n+            }\n+            TyPolyTraitRef(bounds) => {\n+                TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+            }\n+        },\n+        span: fld.new_span(span)\n+    })\n+}\n+\n+pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n+                                        fld: &mut T) -> ForeignMod {\n+    ForeignMod {\n+        abi: abi,\n+        items: items.move_map(|x| fld.fold_foreign_item(x)),\n+    }\n+}\n+\n+pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n+    v.map(|Spanned {node: Variant_ {id, name, attrs, kind, disr_expr, vis}, span}| Spanned {\n+        node: Variant_ {\n+            id: fld.new_id(id),\n+            name: name,\n+            attrs: fold_attrs(attrs, fld),\n+            kind: match kind {\n+                TupleVariantKind(variant_args) => {\n+                    TupleVariantKind(variant_args.move_map(|x|\n+                        fld.fold_variant_arg(x)))\n+                }\n+                StructVariantKind(struct_def) => {\n+                    StructVariantKind(fld.fold_struct_def(struct_def))\n+                }\n+            },\n+            disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n+            vis: vis,\n+        },\n+        span: fld.new_span(span),\n+    })\n+}\n+\n+pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n+    i\n+}\n+\n+pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n+    i\n+}\n+\n+pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut T) -> Path {\n+    Path {\n+        global: global,\n+        segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n+            identifier: fld.fold_ident(identifier),\n+            parameters: fld.fold_path_parameters(parameters),\n+        }),\n+        span: fld.new_span(span)\n+    }\n+}\n+\n+pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld: &mut T)\n+                                            -> PathParameters\n+{\n+    match path_parameters {\n+        AngleBracketedParameters(data) =>\n+            AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n+        ParenthesizedParameters(data) =>\n+            ParenthesizedParameters(fld.fold_parenthesized_parameter_data(data)),\n+    }\n+}\n+\n+pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n+                                                           fld: &mut T)\n+                                                           -> AngleBracketedParameterData\n+{\n+    let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n+    AngleBracketedParameterData { lifetimes: fld.fold_lifetimes(lifetimes),\n+                                  types: types.move_map(|ty| fld.fold_ty(ty)),\n+                                  bindings: bindings.move_map(|b| fld.fold_ty_binding(b)) }\n+}\n+\n+pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n+                                                         fld: &mut T)\n+                                                         -> ParenthesizedParameterData\n+{\n+    let ParenthesizedParameterData { inputs, output, span } = data;\n+    ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n+                                 output: output.map(|ty| fld.fold_ty(ty)),\n+                                 span: fld.new_span(span) }\n+}\n+\n+pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n+    l.map(|Local {id, pat, ty, init, span}| Local {\n+        id: fld.new_id(id),\n+        ty: ty.map(|t| fld.fold_ty(t)),\n+        pat: fld.fold_pat(pat),\n+        init: init.map(|e| fld.fold_expr(e)),\n+        span: fld.new_span(span)\n+    })\n+}\n+\n+pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n+    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n+    Some(Spanned {\n+        node: Attribute_ {\n+            id: id,\n+            style: style,\n+            value: fld.fold_meta_item(value),\n+            is_sugared_doc: is_sugared_doc\n+        },\n+        span: fld.new_span(span)\n+    })\n+}\n+\n+pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mut T)\n+                                                     -> ExplicitSelf_ {\n+    match es {\n+        SelfStatic | SelfValue(_) => es,\n+        SelfRegion(lifetime, m, ident) => {\n+            SelfRegion(fld.fold_opt_lifetime(lifetime), m, ident)\n+        }\n+        SelfExplicit(typ, ident) => {\n+            SelfExplicit(fld.fold_ty(typ), ident)\n+        }\n+    }\n+}\n+\n+pub fn noop_fold_explicit_self<T: Folder>(Spanned {span, node}: ExplicitSelf, fld: &mut T)\n+                                          -> ExplicitSelf {\n+    Spanned {\n+        node: fld.fold_explicit_self_underscore(node),\n+        span: fld.new_span(span)\n+    }\n+}\n+\n+pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n+    mi.map(|Spanned {node, span}| Spanned {\n+        node: match node {\n+            MetaWord(id) => MetaWord(id),\n+            MetaList(id, mis) => {\n+                MetaList(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+            }\n+            MetaNameValue(id, s) => MetaNameValue(id, s)\n+        },\n+        span: fld.new_span(span)\n+    })\n+}\n+\n+pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n+    Arg {\n+        id: fld.new_id(id),\n+        pat: fld.fold_pat(pat),\n+        ty: fld.fold_ty(ty)\n+    }\n+}\n+\n+pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n+    decl.map(|FnDecl {inputs, output, variadic}| FnDecl {\n+        inputs: inputs.move_map(|x| fld.fold_arg(x)),\n+        output: match output {\n+            Return(ty) => Return(fld.fold_ty(ty)),\n+            DefaultReturn(span) => DefaultReturn(span),\n+            NoReturn(span) => NoReturn(span)\n+        },\n+        variadic: variadic\n+    })\n+}\n+\n+pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n+                                   -> TyParamBound\n+                                   where T: Folder {\n+    match tpb {\n+        TraitTyParamBound(ty, modifier) => TraitTyParamBound(fld.fold_poly_trait_ref(ty), modifier),\n+        RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n+    }\n+}\n+\n+pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n+    let TyParam {id, ident, bounds, default, span} = tp;\n+    TyParam {\n+        id: fld.new_id(id),\n+        ident: ident,\n+        bounds: fld.fold_bounds(bounds),\n+        default: default.map(|x| fld.fold_ty(x)),\n+        span: span\n+    }\n+}\n+\n+pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>, fld: &mut T)\n+                                      -> OwnedSlice<TyParam> {\n+    tps.move_map(|tp| fld.fold_ty_param(tp))\n+}\n+\n+pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n+    Lifetime {\n+        id: fld.new_id(l.id),\n+        name: l.name,\n+        span: fld.new_span(l.span)\n+    }\n+}\n+\n+pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T)\n+                                         -> LifetimeDef {\n+    LifetimeDef {\n+        lifetime: fld.fold_lifetime(l.lifetime),\n+        bounds: fld.fold_lifetimes(l.bounds),\n+    }\n+}\n+\n+pub fn noop_fold_lifetimes<T: Folder>(lts: Vec<Lifetime>, fld: &mut T) -> Vec<Lifetime> {\n+    lts.move_map(|l| fld.fold_lifetime(l))\n+}\n+\n+pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T)\n+                                          -> Vec<LifetimeDef> {\n+    lts.move_map(|l| fld.fold_lifetime_def(l))\n+}\n+\n+pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T)\n+                                         -> Option<Lifetime> {\n+    o_lt.map(|lt| fld.fold_lifetime(lt))\n+}\n+\n+pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause}: Generics,\n+                                     fld: &mut T) -> Generics {\n+    Generics {\n+        ty_params: fld.fold_ty_params(ty_params),\n+        lifetimes: fld.fold_lifetime_defs(lifetimes),\n+        where_clause: fld.fold_where_clause(where_clause),\n+    }\n+}\n+\n+pub fn noop_fold_where_clause<T: Folder>(\n+                              WhereClause {id, predicates}: WhereClause,\n+                              fld: &mut T)\n+                              -> WhereClause {\n+    WhereClause {\n+        id: fld.new_id(id),\n+        predicates: predicates.move_map(|predicate| {\n+            fld.fold_where_predicate(predicate)\n+        })\n+    }\n+}\n+\n+pub fn noop_fold_where_predicate<T: Folder>(\n+                                 pred: WherePredicate,\n+                                 fld: &mut T)\n+                                 -> WherePredicate {\n+    match pred {\n+        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{bound_lifetimes,\n+                                                                     bounded_ty,\n+                                                                     bounds,\n+                                                                     span}) => {\n+            hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n+                bounded_ty: fld.fold_ty(bounded_ty),\n+                bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n+                span: fld.new_span(span)\n+            })\n+        }\n+        hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{lifetime,\n+                                                                       bounds,\n+                                                                       span}) => {\n+            hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                span: fld.new_span(span),\n+                lifetime: fld.fold_lifetime(lifetime),\n+                bounds: bounds.move_map(|bound| fld.fold_lifetime(bound))\n+            })\n+        }\n+        hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{id,\n+                                                               path,\n+                                                               ty,\n+                                                               span}) => {\n+            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{\n+                id: fld.new_id(id),\n+                path: fld.fold_path(path),\n+                ty:fld.fold_ty(ty),\n+                span: fld.new_span(span)\n+            })\n+        }\n+    }\n+}\n+\n+pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n+    struct_def.map(|StructDef { fields, ctor_id }| StructDef {\n+        fields: fields.move_map(|f| fld.fold_struct_field(f)),\n+        ctor_id: ctor_id.map(|cid| fld.new_id(cid)),\n+    })\n+}\n+\n+pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n+    let id = fld.new_id(p.ref_id);\n+    let TraitRef {\n+        path,\n+        ref_id: _,\n+    } = p;\n+    hir::TraitRef {\n+        path: fld.fold_path(path),\n+        ref_id: id,\n+    }\n+}\n+\n+pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n+    hir::PolyTraitRef {\n+        bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n+        trait_ref: fld.fold_trait_ref(p.trait_ref),\n+        span: fld.new_span(p.span),\n+    }\n+}\n+\n+pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField {\n+    let StructField {node: StructField_ {id, kind, ty, attrs}, span} = f;\n+    Spanned {\n+        node: StructField_ {\n+            id: fld.new_id(id),\n+            kind: kind,\n+            ty: fld.fold_ty(ty),\n+            attrs: fold_attrs(attrs, fld),\n+        },\n+        span: fld.new_span(span)\n+    }\n+}\n+\n+pub fn noop_fold_field<T: Folder>(Field {ident, expr, span}: Field, folder: &mut T) -> Field {\n+    Field {\n+        ident: respan(ident.span, folder.fold_ident(ident.node)),\n+        expr: folder.fold_expr(expr),\n+        span: folder.new_span(span)\n+    }\n+}\n+\n+pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutTy {\n+    MutTy {\n+        ty: folder.fold_ty(ty),\n+        mutbl: mutbl,\n+    }\n+}\n+\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n+                                       -> Option<OwnedSlice<TyParamBound>> {\n+    b.map(|bounds| folder.fold_bounds(bounds))\n+}\n+\n+fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n+                          -> TyParamBounds {\n+    bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n+}\n+\n+fn noop_fold_variant_arg<T: Folder>(VariantArg {id, ty}: VariantArg, folder: &mut T)\n+                                    -> VariantArg {\n+    VariantArg {\n+        id: folder.new_id(id),\n+        ty: folder.fold_ty(ty)\n+    }\n+}\n+\n+pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n+    b.map(|Block {id, stmts, expr, rules, span}| Block {\n+        id: folder.new_id(id),\n+        stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n+        expr: expr.map(|x| folder.fold_expr(x)),\n+        rules: rules,\n+        span: folder.new_span(span),\n+    })\n+}\n+\n+pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n+    match i {\n+        ItemExternCrate(string) => ItemExternCrate(string),\n+        ItemUse(view_path) => {\n+            ItemUse(folder.fold_view_path(view_path))\n+        }\n+        ItemStatic(t, m, e) => {\n+            ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n+        }\n+        ItemConst(t, e) => {\n+            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n+        }\n+        ItemFn(decl, unsafety, constness, abi, generics, body) => {\n+            ItemFn(\n+                folder.fold_fn_decl(decl),\n+                unsafety,\n+                constness,\n+                abi,\n+                folder.fold_generics(generics),\n+                folder.fold_block(body)\n+            )\n+        }\n+        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n+        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n+        ItemTy(t, generics) => {\n+            ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n+        }\n+        ItemEnum(enum_definition, generics) => {\n+            ItemEnum(\n+                hir::EnumDef {\n+                    variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n+                },\n+                folder.fold_generics(generics))\n+        }\n+        ItemStruct(struct_def, generics) => {\n+            let struct_def = folder.fold_struct_def(struct_def);\n+            ItemStruct(struct_def, folder.fold_generics(generics))\n+        }\n+        ItemDefaultImpl(unsafety, ref trait_ref) => {\n+            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n+        }\n+        ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n+            let new_impl_items = impl_items.into_iter().flat_map(|item| {\n+                folder.fold_impl_item(item).into_iter()\n+            }).collect();\n+            let ifce = match ifce {\n+                None => None,\n+                Some(ref trait_ref) => {\n+                    Some(folder.fold_trait_ref((*trait_ref).clone()))\n+                }\n+            };\n+            ItemImpl(unsafety,\n+                     polarity,\n+                     folder.fold_generics(generics),\n+                     ifce,\n+                     folder.fold_ty(ty),\n+                     new_impl_items)\n+        }\n+        ItemTrait(unsafety, generics, bounds, items) => {\n+            let bounds = folder.fold_bounds(bounds);\n+            let items = items.into_iter().flat_map(|item| {\n+                folder.fold_trait_item(item).into_iter()\n+            }).collect();\n+            ItemTrait(unsafety,\n+                      folder.fold_generics(generics),\n+                      bounds,\n+                      items)\n+        }\n+    }\n+}\n+\n+pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n+                                       -> SmallVector<P<TraitItem>> {\n+    SmallVector::one(i.map(|TraitItem {id, ident, attrs, node, span}| TraitItem {\n+        id: folder.new_id(id),\n+        ident: folder.fold_ident(ident),\n+        attrs: fold_attrs(attrs, folder),\n+        node: match node {\n+            ConstTraitItem(ty, default) => {\n+                ConstTraitItem(folder.fold_ty(ty),\n+                               default.map(|x| folder.fold_expr(x)))\n+            }\n+            MethodTraitItem(sig, body) => {\n+                MethodTraitItem(noop_fold_method_sig(sig, folder),\n+                                body.map(|x| folder.fold_block(x)))\n+            }\n+            TypeTraitItem(bounds, default) => {\n+                TypeTraitItem(folder.fold_bounds(bounds),\n+                              default.map(|x| folder.fold_ty(x)))\n+            }\n+        },\n+        span: folder.new_span(span)\n+    }))\n+}\n+\n+pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n+                                      -> SmallVector<P<ImplItem>> {\n+    SmallVector::one(i.map(|ImplItem {id, ident, attrs, node, vis, span}| ImplItem {\n+        id: folder.new_id(id),\n+        ident: folder.fold_ident(ident),\n+        attrs: fold_attrs(attrs, folder),\n+        vis: vis,\n+        node: match node  {\n+            ConstImplItem(ty, expr) => {\n+                ConstImplItem(folder.fold_ty(ty), folder.fold_expr(expr))\n+            }\n+            MethodImplItem(sig, body) => {\n+                MethodImplItem(noop_fold_method_sig(sig, folder),\n+                               folder.fold_block(body))\n+            }\n+            TypeImplItem(ty) => TypeImplItem(folder.fold_ty(ty)),\n+        },\n+        span: folder.new_span(span)\n+    }))\n+}\n+\n+pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n+    Mod {\n+        inner: folder.new_span(inner),\n+        items: items.into_iter().flat_map(|x| folder.fold_item(x).into_iter()).collect(),\n+    }\n+}\n+\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, span, exported_macros}: Crate,\n+                                  folder: &mut T) -> Crate {\n+    let config = folder.fold_meta_items(config);\n+\n+    let mut items = folder.fold_item(P(hir::Item {\n+        ident: token::special_idents::invalid,\n+        attrs: attrs,\n+        id: DUMMY_NODE_ID,\n+        vis: hir::Public,\n+        span: span,\n+        node: hir::ItemMod(module),\n+    })).into_iter();\n+\n+    let (module, attrs, span) = match items.next() {\n+        Some(item) => {\n+            assert!(items.next().is_none(),\n+                    \"a crate cannot expand to more than one item\");\n+            item.and_then(|hir::Item { attrs, span, node, .. }| {\n+                match node {\n+                    hir::ItemMod(m) => (m, attrs, span),\n+                    _ => panic!(\"fold converted a module to not a module\"),\n+                }\n+            })\n+        }\n+        None => (hir::Mod {\n+            inner: span,\n+            items: vec![],\n+        }, vec![], span)\n+    };\n+\n+    Crate {\n+        module: module,\n+        attrs: attrs,\n+        config: config,\n+        span: span,\n+        exported_macros: exported_macros,\n+    }\n+}\n+\n+// fold one item into possibly many items\n+pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<Item>> {\n+    SmallVector::one(i.map(|i| folder.fold_item_simple(i)))\n+}\n+\n+// fold one item into exactly one item\n+pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n+                                        folder: &mut T) -> Item {\n+    let id = folder.new_id(id);\n+    let node = folder.fold_item_underscore(node);\n+    // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n+    // let ident = match node {\n+    //     // The node may have changed, recompute the \"pretty\" impl name.\n+    //     ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n+    //         impl_pretty_name(maybe_trait, Some(&**ty))\n+    //     }\n+    //     _ => ident\n+    // };\n+\n+    Item {\n+        id: id,\n+        ident: folder.fold_ident(ident),\n+        attrs: fold_attrs(attrs, folder),\n+        node: node,\n+        vis: vis,\n+        span: folder.new_span(span)\n+    }\n+}\n+\n+pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n+    ni.map(|ForeignItem {id, ident, attrs, node, span, vis}| ForeignItem {\n+        id: folder.new_id(id),\n+        ident: folder.fold_ident(ident),\n+        attrs: fold_attrs(attrs, folder),\n+        node: match node {\n+            ForeignItemFn(fdec, generics) => {\n+                ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n+            }\n+            ForeignItemStatic(t, m) => {\n+                ForeignItemStatic(folder.fold_ty(t), m)\n+            }\n+        },\n+        vis: vis,\n+        span: folder.new_span(span)\n+    })\n+}\n+\n+pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n+    MethodSig {\n+        generics: folder.fold_generics(sig.generics),\n+        abi: sig.abi,\n+        explicit_self: folder.fold_explicit_self(sig.explicit_self),\n+        unsafety: sig.unsafety,\n+        constness: sig.constness,\n+        decl: folder.fold_fn_decl(sig.decl)\n+    }\n+}\n+\n+pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n+    p.map(|Pat {id, node, span}| Pat {\n+        id: folder.new_id(id),\n+        node: match node {\n+            PatWild(k) => PatWild(k),\n+            PatIdent(binding_mode, pth1, sub) => {\n+                PatIdent(binding_mode,\n+                        Spanned{span: folder.new_span(pth1.span),\n+                                node: folder.fold_ident(pth1.node)},\n+                        sub.map(|x| folder.fold_pat(x)))\n+            }\n+            PatLit(e) => PatLit(folder.fold_expr(e)),\n+            PatEnum(pth, pats) => {\n+                PatEnum(folder.fold_path(pth),\n+                        pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n+            }\n+            PatQPath(qself, pth) => {\n+                let qself = QSelf {ty: folder.fold_ty(qself.ty), .. qself};\n+                PatQPath(qself, folder.fold_path(pth))\n+            }\n+            PatStruct(pth, fields, etc) => {\n+                let pth = folder.fold_path(pth);\n+                let fs = fields.move_map(|f| {\n+                    Spanned { span: folder.new_span(f.span),\n+                              node: hir::FieldPat {\n+                                  ident: f.node.ident,\n+                                  pat: folder.fold_pat(f.node.pat),\n+                                  is_shorthand: f.node.is_shorthand,\n+                              }}\n+                });\n+                PatStruct(pth, fs, etc)\n+            }\n+            PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n+            PatBox(inner) => PatBox(folder.fold_pat(inner)),\n+            PatRegion(inner, mutbl) => PatRegion(folder.fold_pat(inner), mutbl),\n+            PatRange(e1, e2) => {\n+                PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+            },\n+            PatVec(before, slice, after) => {\n+                PatVec(before.move_map(|x| folder.fold_pat(x)),\n+                       slice.map(|x| folder.fold_pat(x)),\n+                       after.move_map(|x| folder.fold_pat(x)))\n+            }\n+        },\n+        span: folder.new_span(span)\n+    })\n+}\n+\n+pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) -> Expr {\n+    Expr {\n+        id: folder.new_id(id),\n+        node: match node {\n+            ExprBox(p, e) => {\n+                ExprBox(p.map(|e|folder.fold_expr(e)), folder.fold_expr(e))\n+            }\n+            ExprVec(exprs) => {\n+                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprRepeat(expr, count) => {\n+                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n+            }\n+            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n+            ExprCall(f, args) => {\n+                ExprCall(folder.fold_expr(f),\n+                         args.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprMethodCall(i, tps, args) => {\n+                ExprMethodCall(\n+                    respan(folder.new_span(i.span), folder.fold_ident(i.node)),\n+                    tps.move_map(|x| folder.fold_ty(x)),\n+                    args.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprBinary(binop, lhs, rhs) => {\n+                ExprBinary(binop,\n+                        folder.fold_expr(lhs),\n+                        folder.fold_expr(rhs))\n+            }\n+            ExprUnary(binop, ohs) => {\n+                ExprUnary(binop, folder.fold_expr(ohs))\n+            }\n+            ExprLit(l) => ExprLit(l),\n+            ExprCast(expr, ty) => {\n+                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n+            }\n+            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n+            ExprIf(cond, tr, fl) => {\n+                ExprIf(folder.fold_expr(cond),\n+                       folder.fold_block(tr),\n+                       fl.map(|x| folder.fold_expr(x)))\n+            }\n+            ExprWhile(cond, body, opt_ident) => {\n+                ExprWhile(folder.fold_expr(cond),\n+                          folder.fold_block(body),\n+                          opt_ident.map(|i| folder.fold_ident(i)))\n+            }\n+            ExprLoop(body, opt_ident) => {\n+                ExprLoop(folder.fold_block(body),\n+                        opt_ident.map(|i| folder.fold_ident(i)))\n+            }\n+            ExprMatch(expr, arms, source) => {\n+                ExprMatch(folder.fold_expr(expr),\n+                        arms.move_map(|x| folder.fold_arm(x)),\n+                        source)\n+            }\n+            ExprClosure(capture_clause, decl, body) => {\n+                ExprClosure(capture_clause,\n+                            folder.fold_fn_decl(decl),\n+                            folder.fold_block(body))\n+            }\n+            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n+            ExprAssign(el, er) => {\n+                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n+            }\n+            ExprAssignOp(op, el, er) => {\n+                ExprAssignOp(op,\n+                            folder.fold_expr(el),\n+                            folder.fold_expr(er))\n+            }\n+            ExprField(el, ident) => {\n+                ExprField(folder.fold_expr(el),\n+                          respan(folder.new_span(ident.span),\n+                                 folder.fold_ident(ident.node)))\n+            }\n+            ExprTupField(el, ident) => {\n+                ExprTupField(folder.fold_expr(el),\n+                             respan(folder.new_span(ident.span),\n+                                    folder.fold_usize(ident.node)))\n+            }\n+            ExprIndex(el, er) => {\n+                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n+            }\n+            ExprRange(e1, e2) => {\n+                ExprRange(e1.map(|x| folder.fold_expr(x)),\n+                          e2.map(|x| folder.fold_expr(x)))\n+            }\n+            ExprPath(qself, path) => {\n+                let qself = qself.map(|QSelf { ty, position }| {\n+                    QSelf {\n+                        ty: folder.fold_ty(ty),\n+                        position: position\n+                    }\n+                });\n+                ExprPath(qself, folder.fold_path(path))\n+            }\n+            ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n+            ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),\n+            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n+            ExprInlineAsm(InlineAsm {\n+                inputs,\n+                outputs,\n+                asm,\n+                asm_str_style,\n+                clobbers,\n+                volatile,\n+                alignstack,\n+                dialect,\n+                expn_id,\n+            }) => ExprInlineAsm(InlineAsm {\n+                inputs: inputs.move_map(|(c, input)| {\n+                    (c, folder.fold_expr(input))\n+                }),\n+                outputs: outputs.move_map(|(c, out, is_rw)| {\n+                    (c, folder.fold_expr(out), is_rw)\n+                }),\n+                asm: asm,\n+                asm_str_style: asm_str_style,\n+                clobbers: clobbers,\n+                volatile: volatile,\n+                alignstack: alignstack,\n+                dialect: dialect,\n+                expn_id: expn_id,\n+            }),\n+            ExprStruct(path, fields, maybe_expr) => {\n+                ExprStruct(folder.fold_path(path),\n+                        fields.move_map(|x| folder.fold_field(x)),\n+                        maybe_expr.map(|x| folder.fold_expr(x)))\n+            },\n+            ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n+        },\n+        span: folder.new_span(span)\n+    }\n+}\n+\n+pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n+                                 -> SmallVector<P<Stmt>> {\n+    let span = folder.new_span(span);\n+    match node {\n+        StmtDecl(d, id) => {\n+            let id = folder.new_id(id);\n+            folder.fold_decl(d).into_iter().map(|d| P(Spanned {\n+                node: StmtDecl(d, id),\n+                span: span\n+            })).collect()\n+        }\n+        StmtExpr(e, id) => {\n+            let id = folder.new_id(id);\n+            SmallVector::one(P(Spanned {\n+                node: StmtExpr(folder.fold_expr(e), id),\n+                span: span\n+            }))\n+        }\n+        StmtSemi(e, id) => {\n+            let id = folder.new_id(id);\n+            SmallVector::one(P(Spanned {\n+                node: StmtSemi(folder.fold_expr(e), id),\n+                span: span\n+            }))\n+        }\n+    }\n+}"}, {"sha": "6d7bef32ff723e03855bf8f06be561237d530b7e", "filename": "src/librustc_front/hir.rs", "status": "added", "additions": 1533, "deletions": 0, "changes": 1533, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -0,0 +1,1533 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The Rust HIR.\n+\n+pub use self::AsmDialect::*;\n+pub use self::AttrStyle::*;\n+pub use self::BindingMode::*;\n+pub use self::BinOp_::*;\n+pub use self::BlockCheckMode::*;\n+pub use self::CaptureClause::*;\n+pub use self::Decl_::*;\n+pub use self::ExplicitSelf_::*;\n+pub use self::Expr_::*;\n+pub use self::FloatTy::*;\n+pub use self::FunctionRetTy::*;\n+pub use self::ForeignItem_::*;\n+pub use self::ImplItem_::*;\n+pub use self::IntTy::*;\n+pub use self::Item_::*;\n+pub use self::Lit_::*;\n+pub use self::LitIntType::*;\n+pub use self::MetaItem_::*;\n+pub use self::Mutability::*;\n+pub use self::Pat_::*;\n+pub use self::PathListItem_::*;\n+pub use self::PatWildKind::*;\n+pub use self::PrimTy::*;\n+pub use self::Sign::*;\n+pub use self::Stmt_::*;\n+pub use self::StrStyle::*;\n+pub use self::StructFieldKind::*;\n+pub use self::TraitItem_::*;\n+pub use self::Ty_::*;\n+pub use self::TyParamBound::*;\n+pub use self::UintTy::*;\n+pub use self::UnOp::*;\n+pub use self::UnsafeSource::*;\n+pub use self::VariantKind::*;\n+pub use self::ViewPath_::*;\n+pub use self::Visibility::*;\n+pub use self::PathParameters::*;\n+\n+use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n+use syntax::abi::Abi;\n+use syntax::ast::{Name, Ident, NodeId, DUMMY_NODE_ID, TokenTree};\n+use syntax::owned_slice::OwnedSlice;\n+use syntax::parse::token::InternedString;\n+use syntax::ptr::P;\n+\n+use print::pprust;\n+use util;\n+\n+use std::fmt;\n+use std::rc::Rc;\n+use serialize::{Encodable, Encoder, Decoder};\n+\n+\n+/// Function name (not all functions have names)\n+pub type FnIdent = Option<Ident>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub struct Lifetime {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub name: Name\n+}\n+\n+impl fmt::Debug for Lifetime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n+    }\n+}\n+\n+/// A lifetime definition, eg `'a: 'b+'c+'d`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct LifetimeDef {\n+    pub lifetime: Lifetime,\n+    pub bounds: Vec<Lifetime>\n+}\n+\n+/// A \"Path\" is essentially Rust's notion of a name; for instance:\n+/// std::cmp::PartialEq  .  It's represented as a sequence of identifiers,\n+/// along with a bunch of supporting information.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+pub struct Path {\n+    pub span: Span,\n+    /// A `::foo` path, is relative to the crate root rather than current\n+    /// module (like paths in an import).\n+    pub global: bool,\n+    /// The segments in the path: the things separated by `::`.\n+    pub segments: Vec<PathSegment>,\n+}\n+\n+impl fmt::Debug for Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"path({})\", pprust::path_to_string(self))\n+    }\n+}\n+\n+impl fmt::Display for Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", pprust::path_to_string(self))\n+    }\n+}\n+\n+/// A segment of a path: an identifier, an optional lifetime, and a set of\n+/// types.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct PathSegment {\n+    /// The identifier portion of this path segment.\n+    pub identifier: Ident,\n+\n+    /// Type/lifetime parameters attached to this path. They come in\n+    /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n+    /// this is more than just simple syntactic sugar; the use of\n+    /// parens affects the region binding rules, so we preserve the\n+    /// distinction.\n+    pub parameters: PathParameters,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum PathParameters {\n+    /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n+    AngleBracketedParameters(AngleBracketedParameterData),\n+    /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n+    ParenthesizedParameters(ParenthesizedParameterData),\n+}\n+\n+impl PathParameters {\n+    pub fn none() -> PathParameters {\n+        AngleBracketedParameters(AngleBracketedParameterData {\n+            lifetimes: Vec::new(),\n+            types: OwnedSlice::empty(),\n+            bindings: OwnedSlice::empty(),\n+        })\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => data.is_empty(),\n+\n+            // Even if the user supplied no types, something like\n+            // `X()` is equivalent to `X<(),()>`.\n+            ParenthesizedParameters(..) => false,\n+        }\n+    }\n+\n+    pub fn has_lifetimes(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => !data.lifetimes.is_empty(),\n+            ParenthesizedParameters(_) => false,\n+        }\n+    }\n+\n+    pub fn has_types(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => !data.types.is_empty(),\n+            ParenthesizedParameters(..) => true,\n+        }\n+    }\n+\n+    /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n+    /// parameters in the parenthesized case.\n+    pub fn types(&self) -> Vec<&P<Ty>> {\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.types.iter().collect()\n+            }\n+            ParenthesizedParameters(ref data) => {\n+                data.inputs.iter()\n+                    .chain(data.output.iter())\n+                    .collect()\n+            }\n+        }\n+    }\n+\n+    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.lifetimes.iter().collect()\n+            }\n+            ParenthesizedParameters(_) => {\n+                Vec::new()\n+            }\n+        }\n+    }\n+\n+    pub fn bindings(&self) -> Vec<&P<TypeBinding>> {\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.bindings.iter().collect()\n+            }\n+            ParenthesizedParameters(_) => {\n+                Vec::new()\n+            }\n+        }\n+    }\n+}\n+\n+/// A path like `Foo<'a, T>`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct AngleBracketedParameterData {\n+    /// The lifetime parameters for this path segment.\n+    pub lifetimes: Vec<Lifetime>,\n+    /// The type parameters for this path segment, if present.\n+    pub types: OwnedSlice<P<Ty>>,\n+    /// Bindings (equality constraints) on associated types, if present.\n+    /// E.g., `Foo<A=Bar>`.\n+    pub bindings: OwnedSlice<P<TypeBinding>>,\n+}\n+\n+impl AngleBracketedParameterData {\n+    fn is_empty(&self) -> bool {\n+        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n+    }\n+}\n+\n+/// A path like `Foo(A,B) -> C`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ParenthesizedParameterData {\n+    /// Overall span\n+    pub span: Span,\n+\n+    /// `(A,B)`\n+    pub inputs: Vec<P<Ty>>,\n+\n+    /// `C`\n+    pub output: Option<P<Ty>>,\n+}\n+\n+/// The AST represents all type param bounds as types.\n+/// typeck::collect::compute_bounds matches these against\n+/// the \"special\" built-in traits (see middle::lang_items) and\n+/// detects Copy, Send and Sync.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TyParamBound {\n+    TraitTyParamBound(PolyTraitRef, TraitBoundModifier),\n+    RegionTyParamBound(Lifetime)\n+}\n+\n+/// A modifier on a bound, currently this is only used for `?Sized`, where the\n+/// modifier is `Maybe`. Negative bounds should also be handled here.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TraitBoundModifier {\n+    None,\n+    Maybe,\n+}\n+\n+pub type TyParamBounds = OwnedSlice<TyParamBound>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct TyParam {\n+    pub ident: Ident,\n+    pub id: NodeId,\n+    pub bounds: TyParamBounds,\n+    pub default: Option<P<Ty>>,\n+    pub span: Span\n+}\n+\n+/// Represents lifetimes and type parameters attached to a declaration\n+/// of a function, enum, trait, etc.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Generics {\n+    pub lifetimes: Vec<LifetimeDef>,\n+    pub ty_params: OwnedSlice<TyParam>,\n+    pub where_clause: WhereClause,\n+}\n+\n+impl Generics {\n+    pub fn is_lt_parameterized(&self) -> bool {\n+        !self.lifetimes.is_empty()\n+    }\n+    pub fn is_type_parameterized(&self) -> bool {\n+        !self.ty_params.is_empty()\n+    }\n+    pub fn is_parameterized(&self) -> bool {\n+        self.is_lt_parameterized() || self.is_type_parameterized()\n+    }\n+}\n+\n+/// A `where` clause in a definition\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct WhereClause {\n+    pub id: NodeId,\n+    pub predicates: Vec<WherePredicate>,\n+}\n+\n+/// A single predicate in a `where` clause\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum WherePredicate {\n+    /// A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+    BoundPredicate(WhereBoundPredicate),\n+    /// A lifetime predicate, e.g. `'a: 'b+'c`\n+    RegionPredicate(WhereRegionPredicate),\n+    /// An equality predicate (unsupported)\n+    EqPredicate(WhereEqPredicate)\n+}\n+\n+/// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct WhereBoundPredicate {\n+    pub span: Span,\n+    /// Any lifetimes from a `for` binding\n+    pub bound_lifetimes: Vec<LifetimeDef>,\n+    /// The type being bounded\n+    pub bounded_ty: P<Ty>,\n+    /// Trait and lifetime bounds (`Clone+Send+'static`)\n+    pub bounds: OwnedSlice<TyParamBound>,\n+}\n+\n+/// A lifetime predicate, e.g. `'a: 'b+'c`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct WhereRegionPredicate {\n+    pub span: Span,\n+    pub lifetime: Lifetime,\n+    pub bounds: Vec<Lifetime>,\n+}\n+\n+/// An equality predicate (unsupported), e.g. `T=int`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct WhereEqPredicate {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub path: Path,\n+    pub ty: P<Ty>,\n+}\n+\n+/// The set of MetaItems that define the compilation environment of the crate,\n+/// used to drive conditional compilation\n+pub type CrateConfig = Vec<P<MetaItem>> ;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Crate {\n+    pub module: Mod,\n+    pub attrs: Vec<Attribute>,\n+    pub config: CrateConfig,\n+    pub span: Span,\n+    pub exported_macros: Vec<MacroDef>,\n+}\n+\n+/// A macro definition, in this crate or imported from another.\n+///\n+/// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct MacroDef {\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub imported_from: Option<Ident>,\n+    pub export: bool,\n+    pub use_locally: bool,\n+    pub allow_internal_unstable: bool,\n+    pub body: Vec<TokenTree>,\n+}\n+\n+pub type MetaItem = Spanned<MetaItem_>;\n+\n+#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum MetaItem_ {\n+    MetaWord(InternedString),\n+    MetaList(InternedString, Vec<P<MetaItem>>),\n+    MetaNameValue(InternedString, Lit),\n+}\n+\n+// can't be derived because the MetaList requires an unordered comparison\n+impl PartialEq for MetaItem_ {\n+    fn eq(&self, other: &MetaItem_) -> bool {\n+        match *self {\n+            MetaWord(ref ns) => match *other {\n+                MetaWord(ref no) => (*ns) == (*no),\n+                _ => false\n+            },\n+            MetaNameValue(ref ns, ref vs) => match *other {\n+                MetaNameValue(ref no, ref vo) => {\n+                    (*ns) == (*no) && vs.node == vo.node\n+                }\n+                _ => false\n+            },\n+            MetaList(ref ns, ref miss) => match *other {\n+                MetaList(ref no, ref miso) => {\n+                    ns == no &&\n+                        miss.iter().all(|mi| miso.iter().any(|x| x.node == mi.node))\n+                }\n+                _ => false\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Block {\n+    /// Statements in a block\n+    pub stmts: Vec<P<Stmt>>,\n+    /// An expression at the end of the block\n+    /// without a semicolon, if any\n+    pub expr: Option<P<Expr>>,\n+    pub id: NodeId,\n+    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n+    pub rules: BlockCheckMode,\n+    pub span: Span,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+pub struct Pat {\n+    pub id: NodeId,\n+    pub node: Pat_,\n+    pub span: Span,\n+}\n+\n+impl fmt::Debug for Pat {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"pat({}: {})\", self.id, pprust::pat_to_string(self))\n+    }\n+}\n+\n+/// A single field in a struct pattern\n+///\n+/// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n+/// are treated the same as` x: x, y: ref y, z: ref mut z`,\n+/// except is_shorthand is true\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct FieldPat {\n+    /// The identifier for the field\n+    pub ident: Ident,\n+    /// The pattern the field is destructured to\n+    pub pat: P<Pat>,\n+    pub is_shorthand: bool,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum BindingMode {\n+    BindByRef(Mutability),\n+    BindByValue(Mutability),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum PatWildKind {\n+    /// Represents the wildcard pattern `_`\n+    PatWildSingle,\n+\n+    /// Represents the wildcard pattern `..`\n+    PatWildMulti,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Pat_ {\n+    /// Represents a wildcard pattern (either `_` or `..`)\n+    PatWild(PatWildKind),\n+\n+    /// A PatIdent may either be a new bound variable,\n+    /// or a nullary enum (in which case the third field\n+    /// is None).\n+    ///\n+    /// In the nullary enum case, the parser can't determine\n+    /// which it is. The resolver determines this, and\n+    /// records this pattern's NodeId in an auxiliary\n+    /// set (of \"PatIdents that refer to nullary enums\")\n+    PatIdent(BindingMode, SpannedIdent, Option<P<Pat>>),\n+\n+    /// \"None\" means a * pattern where we don't bind the fields to names.\n+    PatEnum(Path, Option<Vec<P<Pat>>>),\n+\n+    /// An associated const named using the qualified path `<T>::CONST` or\n+    /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n+    /// referred to as simply `T::CONST`, in which case they will end up as\n+    /// PatEnum, and the resolver will have to sort that out.\n+    PatQPath(QSelf, Path),\n+\n+    /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n+    /// The `bool` is `true` in the presence of a `..`\n+    PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n+    /// A tuple pattern `(a, b)`\n+    PatTup(Vec<P<Pat>>),\n+    /// A `box` pattern\n+    PatBox(P<Pat>),\n+    /// A reference pattern, e.g. `&mut (a, b)`\n+    PatRegion(P<Pat>, Mutability),\n+    /// A literal\n+    PatLit(P<Expr>),\n+    /// A range pattern, e.g. `1...2`\n+    PatRange(P<Expr>, P<Expr>),\n+    /// [a, b, ..i, y, z] is represented as:\n+    ///     PatVec(box [a, b], Some(i), box [y, z])\n+    PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum Mutability {\n+    MutMutable,\n+    MutImmutable,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum BinOp_ {\n+    /// The `+` operator (addition)\n+    BiAdd,\n+    /// The `-` operator (subtraction)\n+    BiSub,\n+    /// The `*` operator (multiplication)\n+    BiMul,\n+    /// The `/` operator (division)\n+    BiDiv,\n+    /// The `%` operator (modulus)\n+    BiRem,\n+    /// The `&&` operator (logical and)\n+    BiAnd,\n+    /// The `||` operator (logical or)\n+    BiOr,\n+    /// The `^` operator (bitwise xor)\n+    BiBitXor,\n+    /// The `&` operator (bitwise and)\n+    BiBitAnd,\n+    /// The `|` operator (bitwise or)\n+    BiBitOr,\n+    /// The `<<` operator (shift left)\n+    BiShl,\n+    /// The `>>` operator (shift right)\n+    BiShr,\n+    /// The `==` operator (equality)\n+    BiEq,\n+    /// The `<` operator (less than)\n+    BiLt,\n+    /// The `<=` operator (less than or equal to)\n+    BiLe,\n+    /// The `!=` operator (not equal to)\n+    BiNe,\n+    /// The `>=` operator (greater than or equal to)\n+    BiGe,\n+    /// The `>` operator (greater than)\n+    BiGt,\n+}\n+\n+pub type BinOp = Spanned<BinOp_>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum UnOp {\n+    /// The `box` operator\n+    UnUniq,\n+    /// The `*` operator for dereferencing\n+    UnDeref,\n+    /// The `!` operator for logical inversion\n+    UnNot,\n+    /// The `-` operator for negation\n+    UnNeg\n+}\n+\n+/// A statement\n+pub type Stmt = Spanned<Stmt_>;\n+\n+impl fmt::Debug for Stmt_ {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // Sadness.\n+        let spanned = codemap::dummy_spanned(self.clone());\n+        write!(f, \"stmt({}: {})\",\n+               util::stmt_id(&spanned),\n+               pprust::stmt_to_string(&spanned))\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+pub enum Stmt_ {\n+    /// Could be an item or a local (let) binding:\n+    StmtDecl(P<Decl>, NodeId),\n+\n+    /// Expr without trailing semi-colon (must have unit type):\n+    StmtExpr(P<Expr>, NodeId),\n+\n+    /// Expr with trailing semi-colon (may have any type):\n+    StmtSemi(P<Expr>, NodeId),\n+}\n+\n+// FIXME (pending discussion of #1697, #2178...): local should really be\n+// a refinement on pat.\n+/// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Local {\n+    pub pat: P<Pat>,\n+    pub ty: Option<P<Ty>>,\n+    /// Initializer expression to set the value, if any\n+    pub init: Option<P<Expr>>,\n+    pub id: NodeId,\n+    pub span: Span,\n+}\n+\n+pub type Decl = Spanned<Decl_>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Decl_ {\n+    /// A local (let) binding:\n+    DeclLocal(P<Local>),\n+    /// An item binding:\n+    DeclItem(P<Item>),\n+}\n+\n+/// represents one arm of a 'match'\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Arm {\n+    pub attrs: Vec<Attribute>,\n+    pub pats: Vec<P<Pat>>,\n+    pub guard: Option<P<Expr>>,\n+    pub body: P<Expr>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Field {\n+    pub ident: SpannedIdent,\n+    pub expr: P<Expr>,\n+    pub span: Span,\n+}\n+\n+pub type SpannedIdent = Spanned<Ident>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum BlockCheckMode {\n+    DefaultBlock,\n+    UnsafeBlock(UnsafeSource),\n+    PushUnsafeBlock(UnsafeSource),\n+    PopUnsafeBlock(UnsafeSource),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum UnsafeSource {\n+    CompilerGenerated,\n+    UserProvided,\n+}\n+\n+/// An expression\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,)]\n+pub struct Expr {\n+    pub id: NodeId,\n+    pub node: Expr_,\n+    pub span: Span,\n+}\n+\n+impl fmt::Debug for Expr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"expr({}: {})\", self.id, pprust::expr_to_string(self))\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Expr_ {\n+    /// First expr is the place; second expr is the value.\n+    ExprBox(Option<P<Expr>>, P<Expr>),\n+    /// An array (`[a, b, c, d]`)\n+    ExprVec(Vec<P<Expr>>),\n+    /// A function call\n+    ///\n+    /// The first field resolves to the function itself,\n+    /// and the second field is the list of arguments\n+    ExprCall(P<Expr>, Vec<P<Expr>>),\n+    /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n+    ///\n+    /// The `SpannedIdent` is the identifier for the method name.\n+    /// The vector of `Ty`s are the ascripted type parameters for the method\n+    /// (within the angle brackets).\n+    ///\n+    /// The first element of the vector of `Expr`s is the expression that evaluates\n+    /// to the object on which the method is being called on (the receiver),\n+    /// and the remaining elements are the rest of the arguments.\n+    ///\n+    /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n+    /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n+    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    /// A tuple (`(a, b, c ,d)`)\n+    ExprTup(Vec<P<Expr>>),\n+    /// A binary operation (For example: `a + b`, `a * b`)\n+    ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    /// A unary operation (For example: `!x`, `*x`)\n+    ExprUnary(UnOp, P<Expr>),\n+    /// A literal (For example: `1u8`, `\"foo\"`)\n+    ExprLit(P<Lit>),\n+    /// A cast (`foo as f64`)\n+    ExprCast(P<Expr>, P<Ty>),\n+    /// An `if` block, with an optional else block\n+    ///\n+    /// `if expr { block } else { expr }`\n+    ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n+    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    /// A while loop, with an optional label\n+    ///\n+    /// `'label: while expr { block }`\n+    ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n+    /// Conditionless loop (can be exited with break, continue, or return)\n+    ///\n+    /// `'label: loop { block }`\n+    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    ExprLoop(P<Block>, Option<Ident>),\n+    /// A `match` block, with a source that indicates whether or not it is\n+    /// the result of a desugaring, and if so, which kind.\n+    ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n+    /// A closure (for example, `move |a, b, c| {a + b + c}`)\n+    ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n+    /// A block (`{ ... }`)\n+    ExprBlock(P<Block>),\n+\n+    /// An assignment (`a = foo()`)\n+    ExprAssign(P<Expr>, P<Expr>),\n+    /// An assignment with an operator\n+    ///\n+    /// For example, `a += 1`.\n+    ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    /// Access of a named struct field (`obj.foo`)\n+    ExprField(P<Expr>, SpannedIdent),\n+    /// Access of an unnamed field of a struct or tuple-struct\n+    ///\n+    /// For example, `foo.0`.\n+    ExprTupField(P<Expr>, Spanned<usize>),\n+    /// An indexing operation (`foo[2]`)\n+    ExprIndex(P<Expr>, P<Expr>),\n+    /// A range (`1..2`, `1..`, or `..2`)\n+    ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n+\n+    /// Variable reference, possibly containing `::` and/or type\n+    /// parameters, e.g. foo::bar::<baz>.\n+    ///\n+    /// Optionally \"qualified\",\n+    /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    ExprPath(Option<QSelf>, Path),\n+\n+    /// A referencing operation (`&a` or `&mut a`)\n+    ExprAddrOf(Mutability, P<Expr>),\n+    /// A `break`, with an optional label to break\n+    ExprBreak(Option<Ident>),\n+    /// A `continue`, with an optional label\n+    ExprAgain(Option<Ident>),\n+    /// A `return`, with an optional value to be returned\n+    ExprRet(Option<P<Expr>>),\n+\n+    /// Output of the `asm!()` macro\n+    ExprInlineAsm(InlineAsm),\n+\n+    /// A struct literal expression.\n+    ///\n+    /// For example, `Foo {x: 1, y: 2}`, or\n+    /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n+    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n+\n+    /// A vector literal constructed from one repeated element.\n+    ///\n+    /// For example, `[1u8; 5]`. The first expression is the element\n+    /// to be repeated; the second is the number of times to repeat it.\n+    ExprRepeat(P<Expr>, P<Expr>),\n+\n+    /// No-op: used solely so we can pretty-print faithfully\n+    ExprParen(P<Expr>)\n+}\n+\n+/// The explicit Self type in a \"qualified path\". The actual\n+/// path, including the trait and the associated item, is stored\n+/// separately. `position` represents the index of the associated\n+/// item qualified with this Self type.\n+///\n+///     <Vec<T> as a::b::Trait>::AssociatedItem\n+///      ^~~~~     ~~~~~~~~~~~~~~^\n+///      ty        position = 3\n+///\n+///     <Vec<T>>::AssociatedItem\n+///      ^~~~~    ^\n+///      ty       position = 0\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct QSelf {\n+    pub ty: P<Ty>,\n+    pub position: usize\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum MatchSource {\n+    Normal,\n+    IfLetDesugar { contains_else_clause: bool },\n+    WhileLetDesugar,\n+    ForLoopDesugar,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum CaptureClause {\n+    CaptureByValue,\n+    CaptureByRef,\n+}\n+\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum StrStyle {\n+    /// A regular string, like `\"foo\"`\n+    CookedStr,\n+    /// A raw string, like `r##\"foo\"##`\n+    ///\n+    /// The uint is the number of `#` symbols used\n+    RawStr(usize)\n+}\n+\n+/// A literal\n+pub type Lit = Spanned<Lit_>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum Sign {\n+    Minus,\n+    Plus\n+}\n+\n+impl Sign {\n+    pub fn new<T: IntSign>(n: T) -> Sign {\n+        n.sign()\n+    }\n+}\n+\n+pub trait IntSign {\n+    fn sign(&self) -> Sign;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl IntSign for $t {\n+        #[allow(unused_comparisons)]\n+        fn sign(&self) -> Sign {\n+            if *self < 0 {Minus} else {Plus}\n+        }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum LitIntType {\n+    SignedIntLit(IntTy, Sign),\n+    UnsignedIntLit(UintTy),\n+    UnsuffixedIntLit(Sign)\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Lit_ {\n+    /// A string literal (`\"foo\"`)\n+    LitStr(InternedString, StrStyle),\n+    /// A byte string (`b\"foo\"`)\n+    LitBinary(Rc<Vec<u8>>),\n+    /// A byte char (`b'f'`)\n+    LitByte(u8),\n+    /// A character literal (`'a'`)\n+    LitChar(char),\n+    /// An integer literal (`1u8`)\n+    LitInt(u64, LitIntType),\n+    /// A float literal (`1f64` or `1E10f64`)\n+    LitFloat(InternedString, FloatTy),\n+    /// A float literal without a suffix (`1.0 or 1.0E10`)\n+    LitFloatUnsuffixed(InternedString),\n+    /// A boolean literal\n+    LitBool(bool),\n+}\n+\n+// NB: If you change this, you'll probably want to change the corresponding\n+// type structure in middle/ty.rs as well.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct MutTy {\n+    pub ty: P<Ty>,\n+    pub mutbl: Mutability,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct TypeField {\n+    pub ident: Ident,\n+    pub mt: MutTy,\n+    pub span: Span,\n+}\n+\n+/// Represents a method's signature in a trait declaration,\n+/// or in an implementation.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct MethodSig {\n+    pub unsafety: Unsafety,\n+    pub constness: Constness,\n+    pub abi: Abi,\n+    pub decl: P<FnDecl>,\n+    pub generics: Generics,\n+    pub explicit_self: ExplicitSelf,\n+}\n+\n+/// Represents a method declaration in a trait declaration, possibly including\n+/// a default implementation A trait method is either required (meaning it\n+/// doesn't have an implementation, just a signature) or provided (meaning it\n+/// has a default implementation).\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct TraitItem {\n+    pub id: NodeId,\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub node: TraitItem_,\n+    pub span: Span,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TraitItem_ {\n+    ConstTraitItem(P<Ty>, Option<P<Expr>>),\n+    MethodTraitItem(MethodSig, Option<P<Block>>),\n+    TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ImplItem {\n+    pub id: NodeId,\n+    pub ident: Ident,\n+    pub vis: Visibility,\n+    pub attrs: Vec<Attribute>,\n+    pub node: ImplItem_,\n+    pub span: Span,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum ImplItem_ {\n+    ConstImplItem(P<Ty>, P<Expr>),\n+    MethodImplItem(MethodSig, P<Block>),\n+    TypeImplItem(P<Ty>),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub enum IntTy {\n+    TyIs,\n+    TyI8,\n+    TyI16,\n+    TyI32,\n+    TyI64,\n+}\n+\n+impl fmt::Debug for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", util::int_ty_to_string(*self, None))\n+    }\n+}\n+\n+impl IntTy {\n+    pub fn bit_width(&self) -> Option<usize> {\n+        Some(match *self {\n+            TyIs => return None,\n+            TyI8 => 8,\n+            TyI16 => 16,\n+            TyI32 => 32,\n+            TyI64 => 64,\n+        })\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub enum UintTy {\n+    TyUs,\n+    TyU8,\n+    TyU16,\n+    TyU32,\n+    TyU64,\n+}\n+\n+impl UintTy {\n+    pub fn bit_width(&self) -> Option<usize> {\n+        Some(match *self {\n+            TyUs => return None,\n+            TyU8 => 8,\n+            TyU16 => 16,\n+            TyU32 => 32,\n+            TyU64 => 64,\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", util::uint_ty_to_string(*self, None))\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub enum FloatTy {\n+    TyF32,\n+    TyF64,\n+}\n+\n+impl fmt::Debug for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", util::float_ty_to_string(*self))\n+    }\n+}\n+\n+impl FloatTy {\n+    pub fn bit_width(&self) -> usize {\n+        match *self {\n+            TyF32 => 32,\n+            TyF64 => 64,\n+        }\n+    }\n+}\n+\n+// Bind a type to an associated type: `A=Foo`.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct TypeBinding {\n+    pub id: NodeId,\n+    pub ident: Ident,\n+    pub ty: P<Ty>,\n+    pub span: Span,\n+}\n+\n+\n+// NB PartialEq method appears below.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+pub struct Ty {\n+    pub id: NodeId,\n+    pub node: Ty_,\n+    pub span: Span,\n+}\n+\n+impl fmt::Debug for Ty {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"type({})\", pprust::ty_to_string(self))\n+    }\n+}\n+\n+/// Not represented directly in the AST, referred to by name through a ty_path.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum PrimTy {\n+    TyInt(IntTy),\n+    TyUint(UintTy),\n+    TyFloat(FloatTy),\n+    TyStr,\n+    TyBool,\n+    TyChar\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct BareFnTy {\n+    pub unsafety: Unsafety,\n+    pub abi: Abi,\n+    pub lifetimes: Vec<LifetimeDef>,\n+    pub decl: P<FnDecl>\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+/// The different kinds of types recognized by the compiler\n+pub enum Ty_ {\n+    TyVec(P<Ty>),\n+    /// A fixed length array (`[T; n]`)\n+    TyFixedLengthVec(P<Ty>, P<Expr>),\n+    /// A raw pointer (`*const T` or `*mut T`)\n+    TyPtr(MutTy),\n+    /// A reference (`&'a T` or `&'a mut T`)\n+    TyRptr(Option<Lifetime>, MutTy),\n+    /// A bare function (e.g. `fn(usize) -> bool`)\n+    TyBareFn(P<BareFnTy>),\n+    /// A tuple (`(A, B, C, D,...)`)\n+    TyTup(Vec<P<Ty>> ),\n+    /// A path (`module::module::...::Type`), optionally\n+    /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    ///\n+    /// Type parameters are stored in the Path itself\n+    TyPath(Option<QSelf>, Path),\n+    /// Something like `A+B`. Note that `B` must always be a path.\n+    TyObjectSum(P<Ty>, TyParamBounds),\n+    /// A type like `for<'a> Foo<&'a Bar>`\n+    TyPolyTraitRef(TyParamBounds),\n+    /// No-op; kept solely so that we can pretty-print faithfully\n+    TyParen(P<Ty>),\n+    /// Unused for now\n+    TyTypeof(P<Expr>),\n+    /// TyInfer means the type should be inferred instead of it having been\n+    /// specified. This can appear anywhere in a type.\n+    TyInfer,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum AsmDialect {\n+    AsmAtt,\n+    AsmIntel\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct InlineAsm {\n+    pub asm: InternedString,\n+    pub asm_str_style: StrStyle,\n+    pub outputs: Vec<(InternedString, P<Expr>, bool)>,\n+    pub inputs: Vec<(InternedString, P<Expr>)>,\n+    pub clobbers: Vec<InternedString>,\n+    pub volatile: bool,\n+    pub alignstack: bool,\n+    pub dialect: AsmDialect,\n+    pub expn_id: ExpnId,\n+}\n+\n+/// represents an argument in a function header\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Arg {\n+    pub ty: P<Ty>,\n+    pub pat: P<Pat>,\n+    pub id: NodeId,\n+}\n+\n+impl Arg {\n+    pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n+        let path = Spanned{span:span,node:self_ident};\n+        Arg {\n+            // HACK(eddyb) fake type for the self argument.\n+            ty: P(Ty {\n+                id: DUMMY_NODE_ID,\n+                node: TyInfer,\n+                span: DUMMY_SP,\n+            }),\n+            pat: P(Pat {\n+                id: DUMMY_NODE_ID,\n+                node: PatIdent(BindByValue(mutability), path, None),\n+                span: span\n+            }),\n+            id: DUMMY_NODE_ID\n+        }\n+    }\n+}\n+\n+/// Represents the header (not the body) of a function declaration\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct FnDecl {\n+    pub inputs: Vec<Arg>,\n+    pub output: FunctionRetTy,\n+    pub variadic: bool\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Unsafety {\n+    Unsafe,\n+    Normal,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Constness {\n+    Const,\n+    NotConst,\n+}\n+\n+impl fmt::Display for Unsafety {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(match *self {\n+            Unsafety::Normal => \"normal\",\n+            Unsafety::Unsafe => \"unsafe\",\n+        }, f)\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+pub enum ImplPolarity {\n+    /// `impl Trait for Type`\n+    Positive,\n+    /// `impl !Trait for Type`\n+    Negative,\n+}\n+\n+impl fmt::Debug for ImplPolarity {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ImplPolarity::Positive => \"positive\".fmt(f),\n+            ImplPolarity::Negative => \"negative\".fmt(f),\n+        }\n+    }\n+}\n+\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum FunctionRetTy {\n+    /// Functions with return type `!`that always\n+    /// raise an error or exit (i.e. never return to the caller)\n+    NoReturn(Span),\n+    /// Return type is not specified.\n+    ///\n+    /// Functions default to `()` and\n+    /// closures default to inference. Span points to where return\n+    /// type would be inserted.\n+    DefaultReturn(Span),\n+    /// Everything else\n+    Return(P<Ty>),\n+}\n+\n+impl FunctionRetTy {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            NoReturn(span) => span,\n+            DefaultReturn(span) => span,\n+            Return(ref ty) => ty.span\n+        }\n+    }\n+}\n+\n+/// Represents the kind of 'self' associated with a method\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum ExplicitSelf_ {\n+    /// No self\n+    SelfStatic,\n+    /// `self`\n+    SelfValue(Ident),\n+    /// `&'lt self`, `&'lt mut self`\n+    SelfRegion(Option<Lifetime>, Mutability, Ident),\n+    /// `self: TYPE`\n+    SelfExplicit(P<Ty>, Ident),\n+}\n+\n+pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Mod {\n+    /// A span from the first token past `{` to the last token until `}`.\n+    /// For `mod foo;`, the inner span ranges from the first token\n+    /// to the last token in the external file.\n+    pub inner: Span,\n+    pub items: Vec<P<Item>>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ForeignMod {\n+    pub abi: Abi,\n+    pub items: Vec<P<ForeignItem>>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct VariantArg {\n+    pub ty: P<Ty>,\n+    pub id: NodeId,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum VariantKind {\n+    /// Tuple variant, e.g. `Foo(A, B)`\n+    TupleVariantKind(Vec<VariantArg>),\n+    /// Struct variant, e.g. `Foo {x: A, y: B}`\n+    StructVariantKind(P<StructDef>),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct EnumDef {\n+    pub variants: Vec<P<Variant>>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Variant_ {\n+    pub name: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub kind: VariantKind,\n+    pub id: NodeId,\n+    /// Explicit discriminant, eg `Foo = 1`\n+    pub disr_expr: Option<P<Expr>>,\n+    pub vis: Visibility,\n+}\n+\n+pub type Variant = Spanned<Variant_>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum PathListItem_ {\n+    PathListIdent {\n+        name: Ident,\n+        /// renamed in list, eg `use foo::{bar as baz};`\n+        rename: Option<Ident>,\n+        id: NodeId\n+    },\n+    PathListMod {\n+        /// renamed in list, eg `use foo::{self as baz};`\n+        rename: Option<Ident>,\n+        id: NodeId\n+    }\n+}\n+\n+impl PathListItem_ {\n+    pub fn id(&self) -> NodeId {\n+        match *self {\n+            PathListIdent { id, .. } | PathListMod { id, .. } => id\n+        }\n+    }\n+\n+    pub fn rename(&self) -> Option<Ident> {\n+        match *self {\n+            PathListIdent { rename, .. } | PathListMod { rename, .. } => rename\n+        }\n+    }\n+}\n+\n+pub type PathListItem = Spanned<PathListItem_>;\n+\n+pub type ViewPath = Spanned<ViewPath_>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum ViewPath_ {\n+\n+    /// `foo::bar::baz as quux`\n+    ///\n+    /// or just\n+    ///\n+    /// `foo::bar::baz` (with `as baz` implicitly on the right)\n+    ViewPathSimple(Ident, Path),\n+\n+    /// `foo::bar::*`\n+    ViewPathGlob(Path),\n+\n+    /// `foo::bar::{a,b,c}`\n+    ViewPathList(Path, Vec<PathListItem>)\n+}\n+\n+/// Meta-data associated with an item\n+pub type Attribute = Spanned<Attribute_>;\n+\n+/// Distinguishes between Attributes that decorate items and Attributes that\n+/// are contained as statements within items. These two cases need to be\n+/// distinguished for pretty-printing.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum AttrStyle {\n+    AttrOuter,\n+    AttrInner,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub struct AttrId(pub usize);\n+\n+/// Doc-comments are promoted to attributes that have is_sugared_doc = true\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Attribute_ {\n+    pub id: AttrId,\n+    pub style: AttrStyle,\n+    pub value: P<MetaItem>,\n+    pub is_sugared_doc: bool,\n+}\n+\n+/// TraitRef's appear in impls.\n+///\n+/// resolve maps each TraitRef's ref_id to its defining trait; that's all\n+/// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n+/// If this impl is an ItemImpl, the impl_id is redundant (it could be the\n+/// same as the impl's node id).\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct TraitRef {\n+    pub path: Path,\n+    pub ref_id: NodeId,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct PolyTraitRef {\n+    /// The `'a` in `<'a> Foo<&'a T>`\n+    pub bound_lifetimes: Vec<LifetimeDef>,\n+\n+    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n+    pub trait_ref: TraitRef,\n+\n+    pub span: Span,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum Visibility {\n+    Public,\n+    Inherited,\n+}\n+\n+impl Visibility {\n+    pub fn inherit_from(&self, parent_visibility: Visibility) -> Visibility {\n+        match self {\n+            &Inherited => parent_visibility,\n+            &Public => *self\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct StructField_ {\n+    pub kind: StructFieldKind,\n+    pub id: NodeId,\n+    pub ty: P<Ty>,\n+    pub attrs: Vec<Attribute>,\n+}\n+\n+impl StructField_ {\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self.kind {\n+            NamedField(ref ident, _) => Some(ident.clone()),\n+            UnnamedField(_) => None\n+        }\n+    }\n+}\n+\n+pub type StructField = Spanned<StructField_>;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum StructFieldKind {\n+    NamedField(Ident, Visibility),\n+    /// Element of a tuple-like struct\n+    UnnamedField(Visibility),\n+}\n+\n+impl StructFieldKind {\n+    pub fn is_unnamed(&self) -> bool {\n+        match *self {\n+            UnnamedField(..) => true,\n+            NamedField(..) => false,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct StructDef {\n+    /// Fields, not including ctor\n+    pub fields: Vec<StructField>,\n+    /// ID of the constructor. This is only used for tuple- or enum-like\n+    /// structs.\n+    pub ctor_id: Option<NodeId>,\n+}\n+\n+/*\n+  FIXME (#3300): Should allow items to be anonymous. Right now\n+  we just use dummy names for anon items.\n+ */\n+/// An item\n+///\n+/// The name might be a dummy name in case of anonymous items\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Item {\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub id: NodeId,\n+    pub node: Item_,\n+    pub vis: Visibility,\n+    pub span: Span,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Item_ {\n+    /// An`extern crate` item, with optional original crate name,\n+    ///\n+    /// e.g. `extern crate foo` or `extern crate foo_bar as foo`\n+    ItemExternCrate(Option<Name>),\n+    /// A `use` or `pub use` item\n+    ItemUse(P<ViewPath>),\n+\n+    /// A `static` item\n+    ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    /// A `const` item\n+    ItemConst(P<Ty>, P<Expr>),\n+    /// A function declaration\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n+    /// A module\n+    ItemMod(Mod),\n+    /// An external module\n+    ItemForeignMod(ForeignMod),\n+    /// A type alias, e.g. `type Foo = Bar<u8>`\n+    ItemTy(P<Ty>, Generics),\n+    /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n+    ItemEnum(EnumDef, Generics),\n+    /// A struct definition, e.g. `struct Foo<A> {x: A}`\n+    ItemStruct(P<StructDef>, Generics),\n+    /// Represents a Trait Declaration\n+    ItemTrait(Unsafety,\n+              Generics,\n+              TyParamBounds,\n+              Vec<P<TraitItem>>),\n+\n+    // Default trait implementations\n+    ///\n+    // `impl Trait for .. {}`\n+    ItemDefaultImpl(Unsafety, TraitRef),\n+    /// An implementation, eg `impl<A> Trait for Foo { .. }`\n+    ItemImpl(Unsafety,\n+             ImplPolarity,\n+             Generics,\n+             Option<TraitRef>, // (optional) trait this impl implements\n+             P<Ty>, // self\n+             Vec<P<ImplItem>>),\n+}\n+\n+impl Item_ {\n+    pub fn descriptive_variant(&self) -> &str {\n+        match *self {\n+            ItemExternCrate(..) => \"extern crate\",\n+            ItemUse(..) => \"use\",\n+            ItemStatic(..) => \"static item\",\n+            ItemConst(..) => \"constant item\",\n+            ItemFn(..) => \"function\",\n+            ItemMod(..) => \"module\",\n+            ItemForeignMod(..) => \"foreign module\",\n+            ItemTy(..) => \"type alias\",\n+            ItemEnum(..) => \"enum\",\n+            ItemStruct(..) => \"struct\",\n+            ItemTrait(..) => \"trait\",\n+            ItemImpl(..) |\n+            ItemDefaultImpl(..) => \"item\"\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ForeignItem {\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub node: ForeignItem_,\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub vis: Visibility,\n+}\n+\n+/// An item within an `extern` block\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum ForeignItem_ {\n+    /// A foreign function\n+    ForeignItemFn(P<FnDecl>, Generics),\n+    /// A foreign static item (`static ext: u8`), with optional mutability\n+    /// (the boolean is true when mutable)\n+    ForeignItemStatic(P<Ty>, bool),\n+}\n+\n+impl ForeignItem_ {\n+    pub fn descriptive_variant(&self) -> &str {\n+        match *self {\n+            ForeignItemFn(..) => \"foreign function\",\n+            ForeignItemStatic(..) => \"foreign static item\"\n+        }\n+    }\n+}"}, {"sha": "fae4f15725534333e423ee3b17606ef92a8fb381", "filename": "src/librustc_front/lib.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The Rust compiler.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+// Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n+#![cfg_attr(stage0, feature(custom_attribute))]\n+#![crate_name = \"rustc_front\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![staged_api]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+\n+#![feature(associated_consts)]\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(const_fn)]\n+#![feature(quote)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_private)]\n+#![feature(slice_patterns)]\n+#![feature(staged_api)]\n+#![feature(str_char)]\n+#![feature(filling_drop)]\n+#![feature(str_escape)]\n+#![cfg_attr(test, feature(test))]\n+\n+extern crate serialize;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+#[macro_use] #[no_link] extern crate rustc_bitflags;\n+\n+extern crate serialize as rustc_serialize; // used by deriving\n+\n+pub mod hir;\n+pub mod lowering;\n+pub mod fold;\n+pub mod visit;\n+pub mod attr;\n+pub mod util;\n+\n+pub mod print {\n+    pub mod pprust;\n+}"}, {"sha": "c723a027d05008196e2dd454c73720164bdbec8d", "filename": "src/librustc_front/lowering.rs", "status": "added", "additions": 1133, "deletions": 0, "changes": 1133, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -0,0 +1,1133 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Lowers the AST to the HIR\n+\n+use hir;\n+\n+use syntax::ast::*;\n+use syntax::ptr::P;\n+use syntax::codemap::Spanned;\n+use syntax::owned_slice::OwnedSlice;\n+\n+\n+pub fn lower_meta_items(meta_items: &Vec<P<MetaItem>>) -> Vec<P<hir::MetaItem>> {\n+    meta_items.iter().map(|x| lower_meta_item(x)).collect()\n+}\n+\n+pub fn lower_view_path(view_path: &ViewPath) -> P<hir::ViewPath> {\n+    P(Spanned {\n+        node: match view_path.node {\n+            ViewPathSimple(ident, ref path) => {\n+                hir::ViewPathSimple(ident, lower_path(path))\n+            }\n+            ViewPathGlob(ref path) => {\n+                hir::ViewPathGlob(lower_path(path))\n+            }\n+            ViewPathList(ref path, ref path_list_idents) => {\n+                hir::ViewPathList(lower_path(path),\n+                             path_list_idents.iter().map(|path_list_ident| {\n+                                Spanned {\n+                                    node: match path_list_ident.node {\n+                                        PathListIdent { id, name, rename } =>\n+                                            hir::PathListIdent {\n+                                                id: id,\n+                                                name: name,\n+                                                rename: rename.clone(),\n+                                            },\n+                                        PathListMod { id, rename } =>\n+                                            hir::PathListMod { id: id, rename: rename.clone() }\n+                                    },\n+                                    span: path_list_ident.span\n+                                }\n+                             }).collect())\n+            }\n+        },\n+        span: view_path.span,\n+    })\n+}\n+\n+pub fn lower_attrs(attrs: &Vec<Attribute>) -> Vec<hir::Attribute> {\n+    attrs.iter().map(|x| lower_attribute(x)).collect()\n+}\n+\n+pub fn lower_arm(arm: &Arm) -> hir::Arm {\n+    hir::Arm {\n+        attrs: lower_attrs(&arm.attrs),\n+        pats: arm.pats.iter().map(|x| lower_pat(x)).collect(),\n+        guard: arm.guard.as_ref().map(|ref x| lower_expr(x)),\n+        body: lower_expr(&arm.body),\n+    }\n+}\n+\n+pub fn lower_decl(d: &Decl) -> P<hir::Decl> {\n+    match d.node {\n+        DeclLocal(ref l) => P(Spanned {\n+            node: hir::DeclLocal(lower_local(l)),\n+            span: d.span\n+        }),\n+        DeclItem(ref it) => P(Spanned {\n+            node: hir::DeclItem(lower_item(it)),\n+            span: d.span\n+        }),\n+    }\n+}\n+\n+pub fn lower_ty_binding(b: &TypeBinding) -> P<hir::TypeBinding> {\n+    P(hir::TypeBinding { id: b.id, ident: b.ident, ty: lower_ty(&b.ty), span: b.span })\n+}\n+\n+pub fn lower_ty(t: &Ty) -> P<hir::Ty> {\n+    P(hir::Ty {\n+        id: t.id,\n+        node: match t.node {\n+            TyInfer => hir::TyInfer,\n+            TyVec(ref ty) => hir::TyVec(lower_ty(ty)),\n+            TyPtr(ref mt) => hir::TyPtr(lower_mt(mt)),\n+            TyRptr(ref region, ref mt) => {\n+                hir::TyRptr(lower_opt_lifetime(region), lower_mt(mt))\n+            }\n+            TyBareFn(ref f) => {\n+                hir::TyBareFn(P(hir::BareFnTy {\n+                    lifetimes: lower_lifetime_defs(&f.lifetimes),\n+                    unsafety: lower_unsafety(f.unsafety),\n+                    abi: f.abi,\n+                    decl: lower_fn_decl(&f.decl)\n+                }))\n+            }\n+            TyTup(ref tys) => hir::TyTup(tys.iter().map(|ty| lower_ty(ty)).collect()),\n+            TyParen(ref ty) => hir::TyParen(lower_ty(ty)),\n+            TyPath(ref qself, ref path) => {\n+                let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n+                    hir::QSelf {\n+                        ty: lower_ty(ty),\n+                        position: position\n+                    }\n+                });\n+                hir::TyPath(qself, lower_path(path))\n+            }\n+            TyObjectSum(ref ty, ref bounds) => {\n+                hir::TyObjectSum(lower_ty(ty),\n+                            lower_bounds(bounds))\n+            }\n+            TyFixedLengthVec(ref ty, ref e) => {\n+                hir::TyFixedLengthVec(lower_ty(ty), lower_expr(e))\n+            }\n+            TyTypeof(ref expr) => {\n+                hir::TyTypeof(lower_expr(expr))\n+            }\n+            TyPolyTraitRef(ref bounds) => {\n+                hir::TyPolyTraitRef(bounds.iter().map(|b| lower_ty_param_bound(b)).collect())\n+            }\n+            TyMac(_) => panic!(\"TyMac should have been expanded by now.\"),\n+        },\n+        span: t.span,\n+    })\n+}\n+\n+pub fn lower_foreign_mod(fm: &ForeignMod) -> hir::ForeignMod {\n+    hir::ForeignMod {\n+        abi: fm.abi,\n+        items: fm.items.iter().map(|x| lower_foreign_item(x)).collect(),\n+    }\n+}\n+\n+pub fn lower_variant(v: &Variant) -> P<hir::Variant> {\n+    P(Spanned {\n+        node: hir::Variant_ {\n+            id: v.node.id,\n+            name: v.node.name,\n+            attrs: lower_attrs(&v.node.attrs),\n+            kind: match v.node.kind {\n+                TupleVariantKind(ref variant_args) => {\n+                    hir::TupleVariantKind(variant_args.iter().map(|ref x|\n+                        lower_variant_arg(x)).collect())\n+                }\n+                StructVariantKind(ref struct_def) => {\n+                    hir::StructVariantKind(lower_struct_def(struct_def))\n+                }\n+            },\n+            disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(e)),\n+            vis: lower_visibility(v.node.vis),\n+        },\n+        span: v.span,\n+    })\n+}\n+\n+pub fn lower_path(p: &Path) -> hir::Path {\n+    hir::Path {\n+        global: p.global,\n+        segments: p.segments.iter().map(|&PathSegment {identifier, ref parameters}|\n+            hir::PathSegment {\n+                identifier: identifier,\n+                parameters: lower_path_parameters(parameters),\n+            }).collect(),\n+        span: p.span,\n+    }\n+}\n+\n+pub fn lower_path_parameters(path_parameters: &PathParameters) -> hir::PathParameters {\n+    match *path_parameters {\n+        AngleBracketedParameters(ref data) =>\n+            hir::AngleBracketedParameters(lower_angle_bracketed_parameter_data(data)),\n+        ParenthesizedParameters(ref data) =>\n+            hir::ParenthesizedParameters(lower_parenthesized_parameter_data(data)),\n+    }\n+}\n+\n+pub fn lower_angle_bracketed_parameter_data(data: &AngleBracketedParameterData)\n+                                            -> hir::AngleBracketedParameterData {\n+    let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings } = data;\n+    hir::AngleBracketedParameterData {\n+        lifetimes: lower_lifetimes(lifetimes),\n+        types: types.iter().map(|ty| lower_ty(ty)).collect(),\n+        bindings: bindings.iter().map(|b| lower_ty_binding(b)).collect(),\n+    }\n+}\n+\n+pub fn lower_parenthesized_parameter_data(data: &ParenthesizedParameterData)\n+                                          -> hir::ParenthesizedParameterData {\n+    let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n+    hir::ParenthesizedParameterData {\n+        inputs: inputs.iter().map(|ty| lower_ty(ty)).collect(),\n+        output: output.as_ref().map(|ty| lower_ty(ty)),\n+        span: span,\n+    }\n+}\n+\n+pub fn lower_local(l: &Local) -> P<hir::Local> {\n+    P(hir::Local {\n+            id: l.id,\n+            ty: l.ty.as_ref().map(|t| lower_ty(t)),\n+            pat: lower_pat(&l.pat),\n+            init: l.init.as_ref().map(|e| lower_expr(e)),\n+            span: l.span,\n+        })\n+}\n+\n+pub fn lower_attribute(at: &Attribute) -> hir::Attribute {\n+    Spanned {\n+        node: hir::Attribute_ {\n+            id: hir::AttrId(at.node.id.0),\n+            style: lower_attr_style(at.node.style),\n+            value: lower_meta_item(&at.node.value),\n+            is_sugared_doc: at.node.is_sugared_doc,\n+        },\n+        span: at.span,\n+    }\n+}\n+\n+// FIXME we should probably just unify hir and ast Attributes.\n+pub fn unlower_attribute(at: &hir::Attribute) -> Attribute {\n+    Spanned {\n+        node: Attribute_ {\n+            id: AttrId(at.node.id.0),\n+            style: unlower_attr_style(at.node.style),\n+            value: unlower_meta_item(&at.node.value),\n+            is_sugared_doc: at.node.is_sugared_doc,\n+        },\n+        span: at.span,\n+    }\n+}\n+\n+pub fn lower_explicit_self_underscore(es: &ExplicitSelf_) -> hir::ExplicitSelf_ {\n+    match *es {\n+        SelfStatic => hir::SelfStatic,\n+        SelfValue(v) => hir::SelfValue(v),\n+        SelfRegion(ref lifetime, m, ident) => {\n+            hir::SelfRegion(lower_opt_lifetime(lifetime), lower_mutability(m), ident)\n+        }\n+        SelfExplicit(ref typ, ident) => {\n+            hir::SelfExplicit(lower_ty(typ), ident)\n+        }\n+    }\n+}\n+\n+pub fn lower_mutability(m: Mutability) -> hir::Mutability {\n+    match m {\n+        MutMutable => hir::MutMutable,\n+        MutImmutable => hir::MutImmutable,\n+    }\n+}\n+\n+pub fn lower_explicit_self(s: &ExplicitSelf) -> hir::ExplicitSelf {\n+    Spanned { node: lower_explicit_self_underscore(&s.node), span: s.span }\n+}\n+\n+\n+pub fn lower_meta_item(mi: &MetaItem) -> P<hir::MetaItem> {\n+    P(Spanned {\n+        node: match mi.node {\n+            MetaWord(ref id) => hir::MetaWord(id.clone()),\n+            MetaList(ref id, ref mis) => {\n+                hir::MetaList(id.clone(), mis.iter().map(|mi| lower_meta_item(mi)).collect())\n+            }\n+            MetaNameValue(ref id, ref s) => hir::MetaNameValue(id.clone(), lower_lit(s))\n+        },\n+        span: mi.span,\n+    })\n+}\n+\n+pub fn unlower_meta_item(mi: &hir::MetaItem) -> P<MetaItem> {\n+    P(Spanned {\n+        node: match mi.node {\n+            hir::MetaWord(ref id) => MetaWord(id.clone()),\n+            hir::MetaList(ref id, ref mis) => {\n+                MetaList(id.clone(), mis.iter().map(|mi| unlower_meta_item(mi)).collect())\n+            }\n+            hir::MetaNameValue(ref id, ref s) => MetaNameValue(id.clone(), unlower_lit(s))\n+        },\n+        span: mi.span,\n+    })\n+}\n+\n+pub fn lower_arg(arg: &Arg) -> hir::Arg {\n+    hir::Arg { id: arg.id, pat: lower_pat(&arg.pat), ty: lower_ty(&arg.ty) }\n+}\n+\n+pub fn lower_fn_decl(decl: &FnDecl) -> P<hir::FnDecl> {\n+    P(hir::FnDecl {\n+        inputs: decl.inputs.iter().map(|x| lower_arg(x)).collect(),\n+        output: match decl.output {\n+            Return(ref ty) => hir::Return(lower_ty(ty)),\n+            DefaultReturn(span) => hir::DefaultReturn(span),\n+            NoReturn(span) => hir::NoReturn(span)\n+        },\n+        variadic: decl.variadic,\n+    })\n+}\n+\n+pub fn lower_ty_param_bound(tpb: &TyParamBound) -> hir::TyParamBound {\n+    match *tpb {\n+        TraitTyParamBound(ref ty, modifier) => {\n+            hir::TraitTyParamBound(lower_poly_trait_ref(ty), lower_trait_bound_modifier(modifier))\n+        }\n+        RegionTyParamBound(ref lifetime) => hir::RegionTyParamBound(lower_lifetime(lifetime)),\n+    }\n+}\n+\n+pub fn lower_ty_param(tp: &TyParam) -> hir::TyParam {\n+    hir::TyParam {\n+        id: tp.id,\n+        ident: tp.ident,\n+        bounds: lower_bounds(&tp.bounds),\n+        default: tp.default.as_ref().map(|x| lower_ty(x)),\n+        span: tp.span,\n+    }\n+}\n+\n+pub fn lower_ty_params(tps: &OwnedSlice<TyParam>) -> OwnedSlice<hir::TyParam> {\n+    tps.iter().map(|tp| lower_ty_param(tp)).collect()\n+}\n+\n+pub fn lower_lifetime(l: &Lifetime) -> hir::Lifetime {\n+    hir::Lifetime { id: l.id, name: l.name, span: l.span }\n+}\n+\n+pub fn lower_lifetime_def(l: &LifetimeDef) -> hir::LifetimeDef {\n+    hir::LifetimeDef { lifetime: lower_lifetime(&l.lifetime), bounds: lower_lifetimes(&l.bounds) }\n+}\n+\n+pub fn lower_lifetimes(lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n+    lts.iter().map(|l| lower_lifetime(l)).collect()\n+}\n+\n+pub fn lower_lifetime_defs(lts: &Vec<LifetimeDef>) -> Vec<hir::LifetimeDef> {\n+    lts.iter().map(|l| lower_lifetime_def(l)).collect()\n+}\n+\n+pub fn lower_opt_lifetime(o_lt: &Option<Lifetime>) -> Option<hir::Lifetime> {\n+    o_lt.as_ref().map(|lt| lower_lifetime(lt))\n+}\n+\n+pub fn lower_generics(g: &Generics) -> hir::Generics {\n+    hir::Generics {\n+        ty_params: lower_ty_params(&g.ty_params),\n+        lifetimes: lower_lifetime_defs(&g.lifetimes),\n+        where_clause: lower_where_clause(&g.where_clause),\n+    }\n+}\n+\n+pub fn lower_where_clause(wc: &WhereClause) -> hir::WhereClause {\n+    hir::WhereClause {\n+        id: wc.id,\n+        predicates: wc.predicates.iter().map(|predicate|\n+            lower_where_predicate(predicate)).collect(),\n+    }\n+}\n+\n+pub fn lower_where_predicate(pred: &WherePredicate) -> hir::WherePredicate {\n+    match *pred {\n+        WherePredicate::BoundPredicate(WhereBoundPredicate{ ref bound_lifetimes,\n+                                                            ref bounded_ty,\n+                                                            ref bounds,\n+                                                            span}) => {\n+            hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                bound_lifetimes: lower_lifetime_defs(bound_lifetimes),\n+                bounded_ty: lower_ty(bounded_ty),\n+                bounds: bounds.iter().map(|x| lower_ty_param_bound(x)).collect(),\n+                span: span\n+            })\n+        }\n+        WherePredicate::RegionPredicate(WhereRegionPredicate{ ref lifetime,\n+                                                              ref bounds,\n+                                                              span}) => {\n+            hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                span: span,\n+                lifetime: lower_lifetime(lifetime),\n+                bounds: bounds.iter().map(|bound| lower_lifetime(bound)).collect()\n+            })\n+        }\n+        WherePredicate::EqPredicate(WhereEqPredicate{ id,\n+                                                      ref path,\n+                                                      ref ty,\n+                                                      span}) => {\n+            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{\n+                id: id,\n+                path: lower_path(path),\n+                ty:lower_ty(ty),\n+                span: span\n+            })\n+        }\n+    }\n+}\n+\n+pub fn lower_struct_def(sd: &StructDef) -> P<hir::StructDef> {\n+    P(hir::StructDef {\n+        fields: sd.fields.iter().map(|f| lower_struct_field(f)).collect(),\n+        ctor_id: sd.ctor_id,\n+    })\n+}\n+\n+pub fn lower_trait_ref(p: &TraitRef) -> hir::TraitRef {\n+    hir::TraitRef { path: lower_path(&p.path), ref_id: p.ref_id }\n+}\n+\n+pub fn lower_poly_trait_ref(p: &PolyTraitRef) -> hir::PolyTraitRef {\n+    hir::PolyTraitRef {\n+        bound_lifetimes: lower_lifetime_defs(&p.bound_lifetimes),\n+        trait_ref: lower_trait_ref(&p.trait_ref),\n+        span: p.span,\n+    }\n+}\n+\n+pub fn lower_struct_field(f: &StructField) -> hir::StructField {\n+    Spanned {\n+        node: hir::StructField_ {\n+            id: f.node.id,\n+            kind: lower_struct_field_kind(&f.node.kind),\n+            ty: lower_ty(&f.node.ty),\n+            attrs: lower_attrs(&f.node.attrs),\n+        },\n+        span: f.span,\n+    }\n+}\n+\n+pub fn lower_field(f: &Field) -> hir::Field {\n+    hir::Field { ident: f.ident, expr: lower_expr(&f.expr), span: f.span }\n+}\n+\n+pub fn lower_mt(mt: &MutTy) -> hir::MutTy {\n+    hir::MutTy { ty: lower_ty(&mt.ty), mutbl: lower_mutability(mt.mutbl) }\n+}\n+\n+pub fn lower_opt_bounds(b: &Option<OwnedSlice<TyParamBound>>)\n+                        -> Option<OwnedSlice<hir::TyParamBound>> {\n+    b.as_ref().map(|ref bounds| lower_bounds(bounds))\n+}\n+\n+fn lower_bounds(bounds: &TyParamBounds) -> hir::TyParamBounds {\n+    bounds.iter().map(|bound| lower_ty_param_bound(bound)).collect()\n+}\n+\n+fn lower_variant_arg(va: &VariantArg) -> hir::VariantArg {\n+    hir::VariantArg { id: va.id, ty: lower_ty(&va.ty) }\n+}\n+\n+pub fn lower_block(b: &Block) -> P<hir::Block> {\n+    P(hir::Block {\n+        id: b.id,\n+        stmts: b.stmts.iter().map(|s| lower_stmt(s)).collect(),\n+        expr: b.expr.as_ref().map(|ref x| lower_expr(x)),\n+        rules: lower_block_check_mode(&b.rules),\n+        span: b.span,\n+    })\n+}\n+\n+pub fn lower_item_underscore(i: &Item_) -> hir::Item_ {\n+    match *i {\n+        ItemExternCrate(string) => hir::ItemExternCrate(string),\n+        ItemUse(ref view_path) => {\n+            hir::ItemUse(lower_view_path(view_path))\n+        }\n+        ItemStatic(ref t, m, ref e) => {\n+            hir::ItemStatic(lower_ty(t), lower_mutability(m), lower_expr(e))\n+        }\n+        ItemConst(ref t, ref e) => {\n+            hir::ItemConst(lower_ty(t), lower_expr(e))\n+        }\n+        ItemFn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+            hir::ItemFn(\n+                lower_fn_decl(decl),\n+                lower_unsafety(unsafety),\n+                lower_constness(constness),\n+                abi,\n+                lower_generics(generics),\n+                lower_block(body)\n+            )\n+        }\n+        ItemMod(ref m) => hir::ItemMod(lower_mod(m)),\n+        ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(nm)),\n+        ItemTy(ref t, ref generics) => {\n+            hir::ItemTy(lower_ty(t), lower_generics(generics))\n+        }\n+        ItemEnum(ref enum_definition, ref generics) => {\n+            hir::ItemEnum(\n+                hir::EnumDef {\n+                    variants: enum_definition.variants.iter().map(|x| lower_variant(x)).collect(),\n+                },\n+                lower_generics(generics))\n+        }\n+        ItemStruct(ref struct_def, ref generics) => {\n+            let struct_def = lower_struct_def(struct_def);\n+            hir::ItemStruct(struct_def, lower_generics(generics))\n+        }\n+        ItemDefaultImpl(unsafety, ref trait_ref) => {\n+            hir::ItemDefaultImpl(lower_unsafety(unsafety), lower_trait_ref(trait_ref))\n+        }\n+        ItemImpl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n+            let new_impl_items = impl_items.iter().map(|item| lower_impl_item(item)).collect();\n+            let ifce = ifce.as_ref().map(|trait_ref| lower_trait_ref(trait_ref));\n+            hir::ItemImpl(lower_unsafety(unsafety),\n+                          lower_impl_polarity(polarity),\n+                          lower_generics(generics),\n+                          ifce,\n+                          lower_ty(ty),\n+                          new_impl_items)\n+        }\n+        ItemTrait(unsafety, ref generics, ref bounds, ref items) => {\n+            let bounds = lower_bounds(bounds);\n+            let items = items.iter().map(|item| lower_trait_item(item)).collect();\n+            hir::ItemTrait(lower_unsafety(unsafety),\n+                           lower_generics(generics),\n+                           bounds,\n+                           items)\n+        }\n+        ItemMac(_) => panic!(\"Shouldn't still be around\"),\n+    }\n+}\n+\n+pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n+    P(hir::TraitItem {\n+            id: i.id,\n+            ident: i.ident,\n+            attrs: lower_attrs(&i.attrs),\n+            node: match i.node {\n+            ConstTraitItem(ref ty, ref default) => {\n+                hir::ConstTraitItem(lower_ty(ty),\n+                                    default.as_ref().map(|x| lower_expr(x)))\n+            }\n+            MethodTraitItem(ref sig, ref body) => {\n+                hir::MethodTraitItem(lower_method_sig(sig),\n+                                     body.as_ref().map(|x| lower_block(x)))\n+            }\n+            TypeTraitItem(ref bounds, ref default) => {\n+                hir::TypeTraitItem(lower_bounds(bounds),\n+                                   default.as_ref().map(|x| lower_ty(x)))\n+            }\n+        },\n+            span: i.span,\n+        })\n+}\n+\n+pub fn lower_impl_item(i: &ImplItem) -> P<hir::ImplItem> {\n+    P(hir::ImplItem {\n+            id: i.id,\n+            ident: i.ident,\n+            attrs: lower_attrs(&i.attrs),\n+            vis: lower_visibility(i.vis),\n+            node: match i.node  {\n+            ConstImplItem(ref ty, ref expr) => {\n+                hir::ConstImplItem(lower_ty(ty), lower_expr(expr))\n+            }\n+            MethodImplItem(ref sig, ref body) => {\n+                hir::MethodImplItem(lower_method_sig(sig),\n+                                    lower_block(body))\n+            }\n+            TypeImplItem(ref ty) => hir::TypeImplItem(lower_ty(ty)),\n+            MacImplItem(..) => panic!(\"Shouldn't exist any more\"),\n+        },\n+            span: i.span,\n+        })\n+}\n+\n+pub fn lower_mod(m: &Mod) -> hir::Mod {\n+    hir::Mod { inner: m.inner, items: m.items.iter().map(|x| lower_item(x)).collect() }\n+}\n+\n+pub fn lower_crate(c: &Crate) -> hir::Crate {\n+    let config = lower_meta_items(&c.config);\n+\n+    hir::Crate {\n+        module: lower_mod(&c.module),\n+        attrs: lower_attrs(&c.attrs),\n+        config: config,\n+        span: c.span,\n+        exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(m)).collect(),\n+    }\n+}\n+\n+pub fn lower_macro_def(m: &MacroDef) -> hir::MacroDef {\n+    hir::MacroDef {\n+        ident: m.ident,\n+        attrs: m.attrs.iter().map(|a| lower_attribute(a)).collect(),\n+        id: m.id,\n+        span: m.span,\n+        imported_from: m.imported_from,\n+        export: m.export,\n+        use_locally: m.use_locally,\n+        allow_internal_unstable: m.allow_internal_unstable,\n+        body: m.body.clone(),\n+    }\n+}\n+\n+// fold one item into possibly many items\n+pub fn lower_item(i: &Item) -> P<hir::Item> {\n+    P(lower_item_simple(i))\n+}\n+\n+// fold one item into exactly one item\n+pub fn lower_item_simple(i: &Item) -> hir::Item {\n+    let node = lower_item_underscore(&i.node);\n+\n+    hir::Item {\n+        id: i.id,\n+        ident: i.ident,\n+        attrs: lower_attrs(&i.attrs),\n+        node: node,\n+        vis: lower_visibility(i.vis),\n+        span: i.span,\n+    }\n+}\n+\n+pub fn lower_foreign_item(i: &ForeignItem) -> P<hir::ForeignItem> {\n+    P(hir::ForeignItem {\n+            id: i.id,\n+            ident: i.ident,\n+            attrs: lower_attrs(&i.attrs),\n+            node: match i.node {\n+            ForeignItemFn(ref fdec, ref generics) => {\n+                hir::ForeignItemFn(lower_fn_decl(fdec), lower_generics(generics))\n+            }\n+            ForeignItemStatic(ref t, m) => {\n+                hir::ForeignItemStatic(lower_ty(t), m)\n+            }\n+        },\n+            vis: lower_visibility(i.vis),\n+            span: i.span,\n+        })\n+}\n+\n+pub fn lower_method_sig(sig: &MethodSig) -> hir::MethodSig {\n+    hir::MethodSig {\n+        generics: lower_generics(&sig.generics),\n+        abi: sig.abi,\n+        explicit_self: lower_explicit_self(&sig.explicit_self),\n+        unsafety: lower_unsafety(sig.unsafety),\n+        constness: lower_constness(sig.constness),\n+        decl: lower_fn_decl(&sig.decl),\n+    }\n+}\n+\n+pub fn lower_unsafety(u: Unsafety) -> hir::Unsafety {\n+    match u {\n+        Unsafety::Unsafe => hir::Unsafety::Unsafe,\n+        Unsafety::Normal => hir::Unsafety::Normal,\n+    }\n+}\n+\n+pub fn lower_constness(c: Constness) -> hir::Constness {\n+    match c {\n+        Constness::Const => hir::Constness::Const,\n+        Constness::NotConst => hir::Constness::NotConst,\n+    }\n+}\n+\n+pub fn lower_lit(l: &Lit) -> hir::Lit {\n+    Spanned {\n+        node: match l.node {\n+            LitStr(ref i, s) => hir::LitStr(i.clone(), lower_string_style(s)),\n+            LitBinary(ref b) => hir::LitBinary(b.clone()),\n+            LitByte(u) => hir::LitByte(u),\n+            LitChar(c) => hir::LitChar(c),\n+            LitInt(u, ref t) => hir::LitInt(u, lower_lit_int_type(t)),\n+            LitFloat(ref i, t) => hir::LitFloat(i.clone(), lower_float_ty(t)),\n+            LitFloatUnsuffixed(ref i) => hir::LitFloatUnsuffixed(i.clone()),\n+            LitBool(b) => hir::LitBool(b),\n+        },\n+        span: l.span,\n+    }\n+}\n+\n+pub fn unlower_lit(l: &hir::Lit) -> Lit {\n+    Spanned {\n+        node: match l.node {\n+            hir::LitStr(ref i, s) => LitStr(i.clone(), unlower_string_style(s)),\n+            hir::LitBinary(ref b) => LitBinary(b.clone()),\n+            hir::LitByte(u) => LitByte(u),\n+            hir::LitChar(c) => LitChar(c),\n+            hir::LitInt(u, ref t) => LitInt(u, unlower_lit_int_type(t)),\n+            hir::LitFloat(ref i, t) => LitFloat(i.clone(), unlower_float_ty(t)),\n+            hir::LitFloatUnsuffixed(ref i) => LitFloatUnsuffixed(i.clone()),\n+            hir::LitBool(b) => LitBool(b),\n+        },\n+        span: l.span,\n+    }\n+}\n+pub fn lower_unop(u: UnOp) -> hir::UnOp {\n+    match u {\n+        UnUniq => hir::UnUniq,\n+        UnDeref => hir::UnDeref,\n+        UnNot => hir::UnNot,\n+        UnNeg => hir::UnNeg,\n+    }\n+}\n+\n+pub fn lower_binop(b: BinOp) -> hir::BinOp {\n+    Spanned {\n+        node: match b.node {\n+            BiAdd => hir::BiAdd,\n+            BiSub => hir::BiSub,\n+            BiMul => hir::BiMul,\n+            BiDiv => hir::BiDiv,\n+            BiRem => hir::BiRem,\n+            BiAnd => hir::BiAnd,\n+            BiOr => hir::BiOr,\n+            BiBitXor => hir::BiBitXor,\n+            BiBitAnd => hir::BiBitAnd,\n+            BiBitOr => hir::BiBitOr,\n+            BiShl => hir::BiShl,\n+            BiShr => hir::BiShr,\n+            BiEq => hir::BiEq,\n+            BiLt => hir::BiLt,\n+            BiLe => hir::BiLe,\n+            BiNe => hir::BiNe,\n+            BiGe => hir::BiGe,\n+            BiGt => hir::BiGt,\n+        },\n+        span: b.span,\n+    }\n+}\n+\n+pub fn lower_pat(p: &Pat) -> P<hir::Pat> {\n+    P(hir::Pat {\n+            id: p.id,\n+            node: match p.node {\n+            PatWild(k) => hir::PatWild(lower_pat_wild_kind(k)),\n+            PatIdent(ref binding_mode, pth1, ref sub) => {\n+                hir::PatIdent(lower_binding_mode(binding_mode),\n+                        pth1,\n+                        sub.as_ref().map(|x| lower_pat(x)))\n+            }\n+            PatLit(ref e) => hir::PatLit(lower_expr(e)),\n+            PatEnum(ref pth, ref pats) => {\n+                hir::PatEnum(lower_path(pth),\n+                        pats.as_ref().map(|pats| pats.iter().map(|x| lower_pat(x)).collect()))\n+            }\n+            PatQPath(ref qself, ref pth) => {\n+                let qself = hir::QSelf {\n+                    ty: lower_ty(&qself.ty),\n+                    position: qself.position,\n+                };\n+                hir::PatQPath(qself, lower_path(pth))\n+            }\n+            PatStruct(ref pth, ref fields, etc) => {\n+                let pth = lower_path(pth);\n+                let fs = fields.iter().map(|f| {\n+                    Spanned { span: f.span,\n+                              node: hir::FieldPat {\n+                                  ident: f.node.ident,\n+                                  pat: lower_pat(&f.node.pat),\n+                                  is_shorthand: f.node.is_shorthand,\n+                              }}\n+                }).collect();\n+                hir::PatStruct(pth, fs, etc)\n+            }\n+            PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(x)).collect()),\n+            PatBox(ref inner) => hir::PatBox(lower_pat(inner)),\n+            PatRegion(ref inner, mutbl) => hir::PatRegion(lower_pat(inner),\n+                                                          lower_mutability(mutbl)),\n+            PatRange(ref e1, ref e2) => {\n+                hir::PatRange(lower_expr(e1), lower_expr(e2))\n+            },\n+            PatVec(ref before, ref slice, ref after) => {\n+                hir::PatVec(before.iter().map(|x| lower_pat(x)).collect(),\n+                       slice.as_ref().map(|x| lower_pat(x)),\n+                       after.iter().map(|x| lower_pat(x)).collect())\n+            }\n+            PatMac(_) => panic!(\"Shouldn't exist here\"),\n+        },\n+            span: p.span,\n+        })\n+}\n+\n+pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n+    P(hir::Expr {\n+            id: e.id,\n+            node: match e.node {\n+                ExprBox(ref p, ref e) => {\n+                    hir::ExprBox(p.as_ref().map(|e| lower_expr(e)), lower_expr(e))\n+                }\n+                ExprVec(ref exprs) => {\n+                    hir::ExprVec(exprs.iter().map(|x| lower_expr(x)).collect())\n+                }\n+                ExprRepeat(ref expr, ref count) => {\n+                    hir::ExprRepeat(lower_expr(expr), lower_expr(count))\n+                }\n+                ExprTup(ref elts) => hir::ExprTup(elts.iter().map(|x| lower_expr(x)).collect()),\n+                ExprCall(ref f, ref args) => {\n+                    hir::ExprCall(lower_expr(f),\n+                             args.iter().map(|x| lower_expr(x)).collect())\n+                }\n+                ExprMethodCall(i, ref tps, ref args) => {\n+                    hir::ExprMethodCall(\n+                        i,\n+                        tps.iter().map(|x| lower_ty(x)).collect(),\n+                        args.iter().map(|x| lower_expr(x)).collect())\n+                }\n+                ExprBinary(binop, ref lhs, ref rhs) => {\n+                    hir::ExprBinary(lower_binop(binop),\n+                            lower_expr(lhs),\n+                            lower_expr(rhs))\n+                }\n+                ExprUnary(op, ref ohs) => {\n+                    hir::ExprUnary(lower_unop(op), lower_expr(ohs))\n+                }\n+                ExprLit(ref l) => hir::ExprLit(P(lower_lit(l))),\n+                ExprCast(ref expr, ref ty) => {\n+                    hir::ExprCast(lower_expr(expr), lower_ty(ty))\n+                }\n+                ExprAddrOf(m, ref ohs) => hir::ExprAddrOf(lower_mutability(m), lower_expr(ohs)),\n+                ExprIf(ref cond, ref tr, ref fl) => {\n+                    hir::ExprIf(lower_expr(cond),\n+                           lower_block(tr),\n+                           fl.as_ref().map(|x| lower_expr(x)))\n+                }\n+                ExprWhile(ref cond, ref body, opt_ident) => {\n+                    hir::ExprWhile(lower_expr(cond),\n+                              lower_block(body),\n+                              opt_ident)\n+                }\n+                ExprLoop(ref body, opt_ident) => {\n+                    hir::ExprLoop(lower_block(body),\n+                            opt_ident)\n+                }\n+                ExprMatch(ref expr, ref arms, ref source) => {\n+                    hir::ExprMatch(lower_expr(expr),\n+                            arms.iter().map(|x| lower_arm(x)).collect(),\n+                            lower_match_source(source))\n+                }\n+                ExprClosure(capture_clause, ref decl, ref body) => {\n+                    hir::ExprClosure(lower_capture_clause(capture_clause),\n+                                lower_fn_decl(decl),\n+                                lower_block(body))\n+                }\n+                ExprBlock(ref blk) => hir::ExprBlock(lower_block(blk)),\n+                ExprAssign(ref el, ref er) => {\n+                    hir::ExprAssign(lower_expr(el), lower_expr(er))\n+                }\n+                ExprAssignOp(op, ref el, ref er) => {\n+                    hir::ExprAssignOp(lower_binop(op),\n+                                lower_expr(el),\n+                                lower_expr(er))\n+                }\n+                ExprField(ref el, ident) => {\n+                    hir::ExprField(lower_expr(el), ident)\n+                }\n+                ExprTupField(ref el, ident) => {\n+                    hir::ExprTupField(lower_expr(el), ident)\n+                }\n+                ExprIndex(ref el, ref er) => {\n+                    hir::ExprIndex(lower_expr(el), lower_expr(er))\n+                }\n+                ExprRange(ref e1, ref e2) => {\n+                    hir::ExprRange(e1.as_ref().map(|x| lower_expr(x)),\n+                              e2.as_ref().map(|x| lower_expr(x)))\n+                }\n+                ExprPath(ref qself, ref path) => {\n+                    let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n+                        hir::QSelf {\n+                            ty: lower_ty(ty),\n+                            position: position\n+                        }\n+                    });\n+                    hir::ExprPath(qself, lower_path(path))\n+                }\n+                ExprBreak(opt_ident) => hir::ExprBreak(opt_ident),\n+                ExprAgain(opt_ident) => hir::ExprAgain(opt_ident),\n+                ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(x))),\n+                ExprInlineAsm(InlineAsm {\n+                    ref inputs,\n+                    ref outputs,\n+                    ref asm,\n+                    asm_str_style,\n+                    ref clobbers,\n+                    volatile,\n+                    alignstack,\n+                    dialect,\n+                    expn_id,\n+                }) => hir::ExprInlineAsm(hir::InlineAsm {\n+                    inputs: inputs.iter().map(|&(ref c, ref input)| {\n+                        (c.clone(), lower_expr(input))\n+                    }).collect(),\n+                    outputs: outputs.iter().map(|&(ref c, ref out, ref is_rw)| {\n+                        (c.clone(), lower_expr(out), *is_rw)\n+                    }).collect(),\n+                    asm: asm.clone(),\n+                    asm_str_style: lower_string_style(asm_str_style),\n+                    clobbers: clobbers.clone(),\n+                    volatile: volatile,\n+                    alignstack: alignstack,\n+                    dialect: lower_asm_dialect(dialect),\n+                    expn_id: expn_id,\n+                }),\n+                ExprStruct(ref path, ref fields, ref maybe_expr) => {\n+                    hir::ExprStruct(lower_path(path),\n+                            fields.iter().map(|x| lower_field(x)).collect(),\n+                            maybe_expr.as_ref().map(|x| lower_expr(x)))\n+                },\n+                ExprParen(ref ex) => hir::ExprParen(lower_expr(ex)),\n+                ExprIfLet(..) |\n+                ExprWhileLet(..) |\n+                ExprForLoop(..) |\n+                ExprMac(_) => panic!(\"Shouldn't exist here\"),\n+            },\n+            span: e.span,\n+        })\n+}\n+\n+pub fn lower_stmt(s: &Stmt) -> P<hir::Stmt> {\n+    match s.node {\n+        StmtDecl(ref d, id) => {\n+            P(Spanned {\n+                node: hir::StmtDecl(lower_decl(d), id),\n+                span: s.span\n+            })\n+        }\n+        StmtExpr(ref e, id) => {\n+            P(Spanned {\n+                node: hir::StmtExpr(lower_expr(e), id),\n+                span: s.span\n+            })\n+        }\n+        StmtSemi(ref e, id) => {\n+            P(Spanned {\n+                node: hir::StmtSemi(lower_expr(e), id),\n+                span: s.span\n+            })\n+        }\n+        StmtMac(..) => panic!(\"Shouldn't exist here\")\n+    }\n+}\n+\n+pub fn lower_string_style(s: StrStyle) -> hir::StrStyle {\n+    match s {\n+        CookedStr => hir::CookedStr,\n+        RawStr(u) => hir::RawStr(u),\n+    }\n+}\n+\n+pub fn unlower_string_style(s: hir::StrStyle) -> StrStyle {\n+    match s {\n+        hir::CookedStr => CookedStr,\n+        hir::RawStr(u) => RawStr(u),\n+    }\n+}\n+\n+pub fn lower_match_source(m: &MatchSource) -> hir::MatchSource {\n+    match *m {\n+        MatchSource::Normal => hir::MatchSource::Normal,\n+        MatchSource::IfLetDesugar { contains_else_clause } => {\n+            hir::MatchSource::IfLetDesugar { contains_else_clause: contains_else_clause }\n+        }\n+        MatchSource::WhileLetDesugar => hir::MatchSource::WhileLetDesugar,\n+        MatchSource::ForLoopDesugar => hir::MatchSource::ForLoopDesugar,\n+    }\n+}\n+\n+pub fn lower_capture_clause(c: CaptureClause) -> hir::CaptureClause {\n+    match c {\n+        CaptureByValue => hir::CaptureByValue,\n+        CaptureByRef => hir::CaptureByRef,\n+    }\n+}\n+\n+pub fn lower_asm_dialect(a: AsmDialect) -> hir::AsmDialect {\n+    match a {\n+        AsmAtt => hir::AsmAtt,\n+        AsmIntel => hir::AsmIntel,\n+    }\n+}\n+\n+pub fn lower_visibility(v: Visibility) -> hir::Visibility {\n+    match v {\n+        Public => hir::Public,\n+        Inherited => hir::Inherited,\n+    }\n+}\n+\n+pub fn lower_block_check_mode(b: &BlockCheckMode) -> hir::BlockCheckMode {\n+    match *b {\n+        DefaultBlock => hir::DefaultBlock,\n+        UnsafeBlock(u) => hir::UnsafeBlock(lower_unsafe_source(u)),\n+        PushUnsafeBlock(u) => hir::PushUnsafeBlock(lower_unsafe_source(u)),\n+        PopUnsafeBlock(u) => hir::PopUnsafeBlock(lower_unsafe_source(u)),\n+    }\n+}\n+\n+pub fn lower_pat_wild_kind(p: PatWildKind) -> hir::PatWildKind {\n+    match p {\n+        PatWildSingle => hir::PatWildSingle,\n+        PatWildMulti => hir::PatWildMulti,\n+    }\n+}\n+\n+pub fn lower_binding_mode(b: &BindingMode) -> hir::BindingMode {\n+    match *b {\n+        BindByRef(m) => hir::BindByRef(lower_mutability(m)),\n+        BindByValue(m) => hir::BindByValue(lower_mutability(m)),\n+    }\n+}\n+\n+pub fn lower_struct_field_kind(s: &StructFieldKind) -> hir::StructFieldKind {\n+    match *s {\n+        NamedField(ident, vis) => hir::NamedField(ident, lower_visibility(vis)),\n+        UnnamedField(vis) => hir::UnnamedField(lower_visibility(vis)),\n+    }\n+}\n+\n+pub fn lower_unsafe_source(u: UnsafeSource) -> hir::UnsafeSource {\n+    match u {\n+        CompilerGenerated => hir::CompilerGenerated,\n+        UserProvided => hir::UserProvided,\n+    }\n+}\n+\n+pub fn lower_impl_polarity(i: ImplPolarity) -> hir::ImplPolarity {\n+    match i {\n+        ImplPolarity::Positive => hir::ImplPolarity::Positive,\n+        ImplPolarity::Negative => hir::ImplPolarity::Negative,\n+    }\n+}\n+\n+pub fn lower_float_ty(f: FloatTy) -> hir::FloatTy {\n+    match f {\n+        TyF32 => hir::TyF32,\n+        TyF64 => hir::TyF64,\n+    }\n+}\n+\n+pub fn unlower_float_ty(f: hir::FloatTy) -> FloatTy {\n+    match f {\n+        hir::TyF32 => TyF32,\n+        hir::TyF64 => TyF64,\n+    }\n+}\n+\n+pub fn lower_lit_int_type(i: &LitIntType) -> hir::LitIntType {\n+    match *i {\n+        SignedIntLit(i, s) => hir::SignedIntLit(lower_int_ty(i), lower_sign(s)),\n+        UnsignedIntLit(u) => hir::UnsignedIntLit(lower_uint_ty(u)),\n+        UnsuffixedIntLit(s) => hir::UnsuffixedIntLit(lower_sign(s)),\n+    }\n+}\n+\n+pub fn unlower_lit_int_type(i: &hir::LitIntType) -> LitIntType {\n+    match *i {\n+        hir::SignedIntLit(i, s) => SignedIntLit(unlower_int_ty(i), unlower_sign(s)),\n+        hir::UnsignedIntLit(u) => UnsignedIntLit(unlower_uint_ty(u)),\n+        hir::UnsuffixedIntLit(s) => UnsuffixedIntLit(unlower_sign(s)),\n+    }\n+}\n+\n+pub fn lower_int_ty(i: IntTy) -> hir::IntTy {\n+    match i {\n+        TyIs => hir::TyIs,\n+        TyI8 => hir::TyI8,\n+        TyI16 => hir::TyI16,\n+        TyI32 => hir::TyI32,\n+        TyI64 => hir::TyI64,\n+    }\n+}\n+\n+pub fn unlower_int_ty(i: hir::IntTy) -> IntTy {\n+    match i {\n+        hir::TyIs => TyIs,\n+        hir::TyI8 => TyI8,\n+        hir::TyI16 => TyI16,\n+        hir::TyI32 => TyI32,\n+        hir::TyI64 => TyI64,\n+    }\n+}\n+\n+pub fn lower_uint_ty(u: UintTy) -> hir::UintTy {\n+    match u {\n+        TyUs => hir::TyUs,\n+        TyU8 => hir::TyU8,\n+        TyU16 => hir::TyU16,\n+        TyU32 => hir::TyU32,\n+        TyU64 => hir::TyU64,\n+    }\n+}\n+\n+pub fn unlower_uint_ty(u: hir::UintTy) -> UintTy {\n+    match u {\n+        hir::TyUs => TyUs,\n+        hir::TyU8 => TyU8,\n+        hir::TyU16 => TyU16,\n+        hir::TyU32 => TyU32,\n+        hir::TyU64 => TyU64,\n+    }\n+}\n+\n+pub fn lower_sign(f: Sign) -> hir::Sign {\n+    match f {\n+        Minus => hir::Minus,\n+        Plus => hir::Plus,\n+    }\n+}\n+\n+pub fn unlower_sign(f: hir::Sign) -> Sign {\n+    match f {\n+        hir::Minus => Minus,\n+        hir::Plus => Plus,\n+    }\n+}\n+\n+pub fn lower_trait_bound_modifier(f: TraitBoundModifier) -> hir::TraitBoundModifier {\n+    match f {\n+        TraitBoundModifier::None => hir::TraitBoundModifier::None,\n+        TraitBoundModifier::Maybe => hir::TraitBoundModifier::Maybe,\n+    }\n+}\n+\n+pub fn lower_attr_style(f: AttrStyle) -> hir::AttrStyle {\n+    match f {\n+        AttrOuter => hir::AttrOuter,\n+        AttrInner => hir::AttrInner,\n+    }\n+}\n+\n+pub fn unlower_attr_style(f: hir::AttrStyle) -> AttrStyle {\n+    match f {\n+        hir::AttrOuter => AttrOuter,\n+        hir::AttrInner => AttrInner,\n+    }\n+}"}, {"sha": "7c5a46465f513163e2954a2d75b6059835a61a14", "filename": "src/librustc_front/print/pp.rs", "status": "added", "additions": 686, "deletions": 0, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpp.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -0,0 +1,686 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pretty-printer is a direct reimplementation of Philip Karlton's\n+//! Mesa pretty-printer, as described in appendix A of\n+//!\n+//!     STAN-CS-79-770: \"Pretty Printing\", by Derek C. Oppen.\n+//!     Stanford Department of Computer Science, 1979.\n+//!\n+//! The algorithm's aim is to break a stream into as few lines as possible\n+//! while respecting the indentation-consistency requirements of the enclosing\n+//! block, and avoiding breaking at silly places on block boundaries, for\n+//! example, between \"x\" and \")\" in \"x)\".\n+//!\n+//! I am implementing this algorithm because it comes with 20 pages of\n+//! documentation explaining its theory, and because it addresses the set of\n+//! concerns I've seen other pretty-printers fall down on. Weirdly. Even though\n+//! it's 32 years old. What can I say?\n+//!\n+//! Despite some redundancies and quirks in the way it's implemented in that\n+//! paper, I've opted to keep the implementation here as similar as I can,\n+//! changing only what was blatantly wrong, a typo, or sufficiently\n+//! non-idiomatic rust that it really stuck out.\n+//!\n+//! In particular you'll see a certain amount of churn related to INTEGER vs.\n+//! CARDINAL in the Mesa implementation. Mesa apparently interconverts the two\n+//! somewhat readily? In any case, I've used usize for indices-in-buffers and\n+//! ints for character-sizes-and-indentation-offsets. This respects the need\n+//! for ints to \"go negative\" while carrying a pending-calculation balance, and\n+//! helps differentiate all the numbers flying around internally (slightly).\n+//!\n+//! I also inverted the indentation arithmetic used in the print stack, since\n+//! the Mesa implementation (somewhat randomly) stores the offset on the print\n+//! stack in terms of margin-col rather than col itself. I store col.\n+//!\n+//! I also implemented a small change in the String token, in that I store an\n+//! explicit length for the string. For most tokens this is just the length of\n+//! the accompanying string. But it's necessary to permit it to differ, for\n+//! encoding things that are supposed to \"go on their own line\" -- certain\n+//! classes of comment and blank-line -- where relying on adjacent\n+//! hardbreak-like Break tokens with long blankness indication doesn't actually\n+//! work. To see why, consider when there is a \"thing that should be on its own\n+//! line\" between two long blocks, say functions. If you put a hardbreak after\n+//! each function (or before each) and the breaking algorithm decides to break\n+//! there anyways (because the functions themselves are long) you wind up with\n+//! extra blank lines. If you don't put hardbreaks you can wind up with the\n+//! \"thing which should be on its own line\" not getting its own line in the\n+//! rare case of \"really small functions\" or such. This re-occurs with comments\n+//! and explicit blank lines. So in those cases we use a string with a payload\n+//! we want isolated to a line and an explicit length that's huge, surrounded\n+//! by two zero-length breaks. The algorithm will try its best to fit it on a\n+//! line (which it can't) and so naturally place the content on its own line to\n+//! avoid combining it with other lines and making matters even worse.\n+\n+use std::io;\n+use std::string;\n+\n+#[derive(Clone, Copy, PartialEq)]\n+pub enum Breaks {\n+    Consistent,\n+    Inconsistent,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct BreakToken {\n+    offset: isize,\n+    blank_space: isize\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct BeginToken {\n+    offset: isize,\n+    breaks: Breaks\n+}\n+\n+#[derive(Clone)]\n+pub enum Token {\n+    String(String, isize),\n+    Break(BreakToken),\n+    Begin(BeginToken),\n+    End,\n+    Eof,\n+}\n+\n+impl Token {\n+    pub fn is_eof(&self) -> bool {\n+        match *self {\n+            Token::Eof => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_hardbreak_tok(&self) -> bool {\n+        match *self {\n+            Token::Break(BreakToken {\n+                offset: 0,\n+                blank_space: bs\n+            }) if bs == SIZE_INFINITY =>\n+                true,\n+            _ =>\n+                false\n+        }\n+    }\n+}\n+\n+pub fn tok_str(token: &Token) -> String {\n+    match *token {\n+        Token::String(ref s, len) => format!(\"STR({},{})\", s, len),\n+        Token::Break(_) => \"BREAK\".to_string(),\n+        Token::Begin(_) => \"BEGIN\".to_string(),\n+        Token::End => \"END\".to_string(),\n+        Token::Eof => \"EOF\".to_string()\n+    }\n+}\n+\n+pub fn buf_str(toks: &[Token],\n+               szs: &[isize],\n+               left: usize,\n+               right: usize,\n+               lim: usize)\n+               -> String {\n+    let n = toks.len();\n+    assert_eq!(n, szs.len());\n+    let mut i = left;\n+    let mut l = lim;\n+    let mut s = string::String::from(\"[\");\n+    while i != right && l != 0 {\n+        l -= 1;\n+        if i != left {\n+            s.push_str(\", \");\n+        }\n+        s.push_str(&format!(\"{}={}\",\n+                           szs[i],\n+                           tok_str(&toks[i])));\n+        i += 1;\n+        i %= n;\n+    }\n+    s.push(']');\n+    s\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum PrintStackBreak {\n+    Fits,\n+    Broken(Breaks),\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PrintStackElem {\n+    offset: isize,\n+    pbreak: PrintStackBreak\n+}\n+\n+const SIZE_INFINITY: isize = 0xffff;\n+\n+pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n+    // Yes 3, it makes the ring buffers big enough to never\n+    // fall behind.\n+    let n: usize = 3 * linewidth;\n+    debug!(\"mk_printer {}\", linewidth);\n+    let token = vec![Token::Eof; n];\n+    let size = vec![0_isize; n];\n+    let scan_stack = vec![0_usize; n];\n+    Printer {\n+        out: out,\n+        buf_len: n,\n+        margin: linewidth as isize,\n+        space: linewidth as isize,\n+        left: 0,\n+        right: 0,\n+        token: token,\n+        size: size,\n+        left_total: 0,\n+        right_total: 0,\n+        scan_stack: scan_stack,\n+        scan_stack_empty: true,\n+        top: 0,\n+        bottom: 0,\n+        print_stack: Vec::new(),\n+        pending_indentation: 0\n+    }\n+}\n+\n+\n+/// In case you do not have the paper, here is an explanation of what's going\n+/// on.\n+///\n+/// There is a stream of input tokens flowing through this printer.\n+///\n+/// The printer buffers up to 3N tokens inside itself, where N is linewidth.\n+/// Yes, linewidth is chars and tokens are multi-char, but in the worst\n+/// case every token worth buffering is 1 char long, so it's ok.\n+///\n+/// Tokens are String, Break, and Begin/End to delimit blocks.\n+///\n+/// Begin tokens can carry an offset, saying \"how far to indent when you break\n+/// inside here\", as well as a flag indicating \"consistent\" or \"inconsistent\"\n+/// breaking. Consistent breaking means that after the first break, no attempt\n+/// will be made to flow subsequent breaks together onto lines. Inconsistent\n+/// is the opposite. Inconsistent breaking example would be, say:\n+///\n+///  foo(hello, there, good, friends)\n+///\n+/// breaking inconsistently to become\n+///\n+///  foo(hello, there\n+///      good, friends);\n+///\n+/// whereas a consistent breaking would yield:\n+///\n+///  foo(hello,\n+///      there\n+///      good,\n+///      friends);\n+///\n+/// That is, in the consistent-break blocks we value vertical alignment\n+/// more than the ability to cram stuff onto a line. But in all cases if it\n+/// can make a block a one-liner, it'll do so.\n+///\n+/// Carrying on with high-level logic:\n+///\n+/// The buffered tokens go through a ring-buffer, 'tokens'. The 'left' and\n+/// 'right' indices denote the active portion of the ring buffer as well as\n+/// describing hypothetical points-in-the-infinite-stream at most 3N tokens\n+/// apart (i.e. \"not wrapped to ring-buffer boundaries\"). The paper will switch\n+/// between using 'left' and 'right' terms to denote the wrapped-to-ring-buffer\n+/// and point-in-infinite-stream senses freely.\n+///\n+/// There is a parallel ring buffer, 'size', that holds the calculated size of\n+/// each token. Why calculated? Because for Begin/End pairs, the \"size\"\n+/// includes everything between the pair. That is, the \"size\" of Begin is\n+/// actually the sum of the sizes of everything between Begin and the paired\n+/// End that follows. Since that is arbitrarily far in the future, 'size' is\n+/// being rewritten regularly while the printer runs; in fact most of the\n+/// machinery is here to work out 'size' entries on the fly (and give up when\n+/// they're so obviously over-long that \"infinity\" is a good enough\n+/// approximation for purposes of line breaking).\n+///\n+/// The \"input side\" of the printer is managed as an abstract process called\n+/// SCAN, which uses 'scan_stack', 'scan_stack_empty', 'top' and 'bottom', to\n+/// manage calculating 'size'. SCAN is, in other words, the process of\n+/// calculating 'size' entries.\n+///\n+/// The \"output side\" of the printer is managed by an abstract process called\n+/// PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n+/// do with each token/size pair it consumes as it goes. It's trying to consume\n+/// the entire buffered window, but can't output anything until the size is >=\n+/// 0 (sizes are set to negative while they're pending calculation).\n+///\n+/// So SCAN takes input and buffers tokens and pending calculations, while\n+/// PRINT gobbles up completed calculations and tokens from the buffer. The\n+/// theory is that the two can never get more than 3N tokens apart, because\n+/// once there's \"obviously\" too much data to fit on a line, in a size\n+/// calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n+/// it.\n+///\n+/// In this implementation (following the paper, again) the SCAN process is\n+/// the method called 'pretty_print', and the 'PRINT' process is the method\n+/// called 'print'.\n+pub struct Printer<'a> {\n+    pub out: Box<io::Write+'a>,\n+    buf_len: usize,\n+    /// Width of lines we're constrained to\n+    margin: isize,\n+    /// Number of spaces left on line\n+    space: isize,\n+    /// Index of left side of input stream\n+    left: usize,\n+    /// Index of right side of input stream\n+    right: usize,\n+    /// Ring-buffer stream goes through\n+    token: Vec<Token> ,\n+    /// Ring-buffer of calculated sizes\n+    size: Vec<isize> ,\n+    /// Running size of stream \"...left\"\n+    left_total: isize,\n+    /// Running size of stream \"...right\"\n+    right_total: isize,\n+    /// Pseudo-stack, really a ring too. Holds the\n+    /// primary-ring-buffers index of the Begin that started the\n+    /// current block, possibly with the most recent Break after that\n+    /// Begin (if there is any) on top of it. Stuff is flushed off the\n+    /// bottom as it becomes irrelevant due to the primary ring-buffer\n+    /// advancing.\n+    scan_stack: Vec<usize> ,\n+    /// Top==bottom disambiguator\n+    scan_stack_empty: bool,\n+    /// Index of top of scan_stack\n+    top: usize,\n+    /// Index of bottom of scan_stack\n+    bottom: usize,\n+    /// Stack of blocks-in-progress being flushed by print\n+    print_stack: Vec<PrintStackElem> ,\n+    /// Buffered indentation to avoid writing trailing whitespace\n+    pending_indentation: isize,\n+}\n+\n+impl<'a> Printer<'a> {\n+    pub fn last_token(&mut self) -> Token {\n+        self.token[self.right].clone()\n+    }\n+    // be very careful with this!\n+    pub fn replace_last_token(&mut self, t: Token) {\n+        self.token[self.right] = t;\n+    }\n+    pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n+        debug!(\"pp Vec<{},{}>\", self.left, self.right);\n+        match token {\n+          Token::Eof => {\n+            if !self.scan_stack_empty {\n+                self.check_stack(0);\n+                try!(self.advance_left());\n+            }\n+            self.indent(0);\n+            Ok(())\n+          }\n+          Token::Begin(b) => {\n+            if self.scan_stack_empty {\n+                self.left_total = 1;\n+                self.right_total = 1;\n+                self.left = 0;\n+                self.right = 0;\n+            } else { self.advance_right(); }\n+            debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n+                   b.offset, self.left, self.right);\n+            self.token[self.right] = token;\n+            self.size[self.right] = -self.right_total;\n+            let right = self.right;\n+            self.scan_push(right);\n+            Ok(())\n+          }\n+          Token::End => {\n+            if self.scan_stack_empty {\n+                debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n+                self.print(token, 0)\n+            } else {\n+                debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n+                self.advance_right();\n+                self.token[self.right] = token;\n+                self.size[self.right] = -1;\n+                let right = self.right;\n+                self.scan_push(right);\n+                Ok(())\n+            }\n+          }\n+          Token::Break(b) => {\n+            if self.scan_stack_empty {\n+                self.left_total = 1;\n+                self.right_total = 1;\n+                self.left = 0;\n+                self.right = 0;\n+            } else { self.advance_right(); }\n+            debug!(\"pp Break({})/buffer Vec<{},{}>\",\n+                   b.offset, self.left, self.right);\n+            self.check_stack(0);\n+            let right = self.right;\n+            self.scan_push(right);\n+            self.token[self.right] = token;\n+            self.size[self.right] = -self.right_total;\n+            self.right_total += b.blank_space;\n+            Ok(())\n+          }\n+          Token::String(s, len) => {\n+            if self.scan_stack_empty {\n+                debug!(\"pp String('{}')/print Vec<{},{}>\",\n+                       s, self.left, self.right);\n+                self.print(Token::String(s, len), len)\n+            } else {\n+                debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n+                       s, self.left, self.right);\n+                self.advance_right();\n+                self.token[self.right] = Token::String(s, len);\n+                self.size[self.right] = len;\n+                self.right_total += len;\n+                self.check_stream()\n+            }\n+          }\n+        }\n+    }\n+    pub fn check_stream(&mut self) -> io::Result<()> {\n+        debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n+               self.left, self.right, self.left_total, self.right_total);\n+        if self.right_total - self.left_total > self.space {\n+            debug!(\"scan window is {}, longer than space on line ({})\",\n+                   self.right_total - self.left_total, self.space);\n+            if !self.scan_stack_empty {\n+                if self.left == self.scan_stack[self.bottom] {\n+                    debug!(\"setting {} to infinity and popping\", self.left);\n+                    let scanned = self.scan_pop_bottom();\n+                    self.size[scanned] = SIZE_INFINITY;\n+                }\n+            }\n+            try!(self.advance_left());\n+            if self.left != self.right {\n+                try!(self.check_stream());\n+            }\n+        }\n+        Ok(())\n+    }\n+    pub fn scan_push(&mut self, x: usize) {\n+        debug!(\"scan_push {}\", x);\n+        if self.scan_stack_empty {\n+            self.scan_stack_empty = false;\n+        } else {\n+            self.top += 1;\n+            self.top %= self.buf_len;\n+            assert!((self.top != self.bottom));\n+        }\n+        self.scan_stack[self.top] = x;\n+    }\n+    pub fn scan_pop(&mut self) -> usize {\n+        assert!((!self.scan_stack_empty));\n+        let x = self.scan_stack[self.top];\n+        if self.top == self.bottom {\n+            self.scan_stack_empty = true;\n+        } else {\n+            self.top += self.buf_len - 1; self.top %= self.buf_len;\n+        }\n+        return x;\n+    }\n+    pub fn scan_top(&mut self) -> usize {\n+        assert!((!self.scan_stack_empty));\n+        return self.scan_stack[self.top];\n+    }\n+    pub fn scan_pop_bottom(&mut self) -> usize {\n+        assert!((!self.scan_stack_empty));\n+        let x = self.scan_stack[self.bottom];\n+        if self.top == self.bottom {\n+            self.scan_stack_empty = true;\n+        } else {\n+            self.bottom += 1; self.bottom %= self.buf_len;\n+        }\n+        return x;\n+    }\n+    pub fn advance_right(&mut self) {\n+        self.right += 1;\n+        self.right %= self.buf_len;\n+        assert!((self.right != self.left));\n+    }\n+    pub fn advance_left(&mut self) -> io::Result<()> {\n+        debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n+               self.left, self.size[self.left]);\n+\n+        let mut left_size = self.size[self.left];\n+\n+        while left_size >= 0 {\n+            let left = self.token[self.left].clone();\n+\n+            let len = match left {\n+                Token::Break(b) => b.blank_space,\n+                Token::String(_, len) => {\n+                    assert_eq!(len, left_size);\n+                    len\n+                }\n+                _ => 0\n+            };\n+\n+            try!(self.print(left, left_size));\n+\n+            self.left_total += len;\n+\n+            if self.left == self.right {\n+                break;\n+            }\n+\n+            self.left += 1;\n+            self.left %= self.buf_len;\n+\n+            left_size = self.size[self.left];\n+        }\n+\n+        Ok(())\n+    }\n+    pub fn check_stack(&mut self, k: isize) {\n+        if !self.scan_stack_empty {\n+            let x = self.scan_top();\n+            match self.token[x] {\n+                Token::Begin(_) => {\n+                    if k > 0 {\n+                        let popped = self.scan_pop();\n+                        self.size[popped] = self.size[x] + self.right_total;\n+                        self.check_stack(k - 1);\n+                    }\n+                }\n+                Token::End => {\n+                    // paper says + not =, but that makes no sense.\n+                    let popped = self.scan_pop();\n+                    self.size[popped] = 1;\n+                    self.check_stack(k + 1);\n+                }\n+                _ => {\n+                    let popped = self.scan_pop();\n+                    self.size[popped] = self.size[x] + self.right_total;\n+                    if k > 0 {\n+                        self.check_stack(k);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    pub fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n+        debug!(\"NEWLINE {}\", amount);\n+        let ret = write!(self.out, \"\\n\");\n+        self.pending_indentation = 0;\n+        self.indent(amount);\n+        return ret;\n+    }\n+    pub fn indent(&mut self, amount: isize) {\n+        debug!(\"INDENT {}\", amount);\n+        self.pending_indentation += amount;\n+    }\n+    pub fn get_top(&mut self) -> PrintStackElem {\n+        let print_stack = &mut self.print_stack;\n+        let n = print_stack.len();\n+        if n != 0 {\n+            (*print_stack)[n - 1]\n+        } else {\n+            PrintStackElem {\n+                offset: 0,\n+                pbreak: PrintStackBreak::Broken(Breaks::Inconsistent)\n+            }\n+        }\n+    }\n+    pub fn print_str(&mut self, s: &str) -> io::Result<()> {\n+        while self.pending_indentation > 0 {\n+            try!(write!(self.out, \" \"));\n+            self.pending_indentation -= 1;\n+        }\n+        write!(self.out, \"{}\", s)\n+    }\n+    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n+        debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n+               self.space);\n+        debug!(\"{}\", buf_str(&self.token,\n+                             &self.size,\n+                             self.left,\n+                             self.right,\n+                             6));\n+        match token {\n+          Token::Begin(b) => {\n+            if l > self.space {\n+                let col = self.margin - self.space + b.offset;\n+                debug!(\"print Begin -> push broken block at col {}\", col);\n+                self.print_stack.push(PrintStackElem {\n+                    offset: col,\n+                    pbreak: PrintStackBreak::Broken(b.breaks)\n+                });\n+            } else {\n+                debug!(\"print Begin -> push fitting block\");\n+                self.print_stack.push(PrintStackElem {\n+                    offset: 0,\n+                    pbreak: PrintStackBreak::Fits\n+                });\n+            }\n+            Ok(())\n+          }\n+          Token::End => {\n+            debug!(\"print End -> pop End\");\n+            let print_stack = &mut self.print_stack;\n+            assert!((!print_stack.is_empty()));\n+            print_stack.pop().unwrap();\n+            Ok(())\n+          }\n+          Token::Break(b) => {\n+            let top = self.get_top();\n+            match top.pbreak {\n+              PrintStackBreak::Fits => {\n+                debug!(\"print Break({}) in fitting block\", b.blank_space);\n+                self.space -= b.blank_space;\n+                self.indent(b.blank_space);\n+                Ok(())\n+              }\n+              PrintStackBreak::Broken(Breaks::Consistent) => {\n+                debug!(\"print Break({}+{}) in consistent block\",\n+                       top.offset, b.offset);\n+                let ret = self.print_newline(top.offset + b.offset);\n+                self.space = self.margin - (top.offset + b.offset);\n+                ret\n+              }\n+              PrintStackBreak::Broken(Breaks::Inconsistent) => {\n+                if l > self.space {\n+                    debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n+                           top.offset, b.offset);\n+                    let ret = self.print_newline(top.offset + b.offset);\n+                    self.space = self.margin - (top.offset + b.offset);\n+                    ret\n+                } else {\n+                    debug!(\"print Break({}) w/o newline in inconsistent\",\n+                           b.blank_space);\n+                    self.indent(b.blank_space);\n+                    self.space -= b.blank_space;\n+                    Ok(())\n+                }\n+              }\n+            }\n+          }\n+          Token::String(s, len) => {\n+            debug!(\"print String({})\", s);\n+            assert_eq!(l, len);\n+            // assert!(l <= space);\n+            self.space -= len;\n+            self.print_str(&s[..])\n+          }\n+          Token::Eof => {\n+            // Eof should never get here.\n+            panic!();\n+          }\n+        }\n+    }\n+}\n+\n+// Convenience functions to talk to the printer.\n+//\n+// \"raw box\"\n+pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::Result<()> {\n+    p.pretty_print(Token::Begin(BeginToken {\n+        offset: indent as isize,\n+        breaks: b\n+    }))\n+}\n+\n+pub fn ibox(p: &mut Printer, indent: usize) -> io::Result<()> {\n+    rbox(p, indent, Breaks::Inconsistent)\n+}\n+\n+pub fn cbox(p: &mut Printer, indent: usize) -> io::Result<()> {\n+    rbox(p, indent, Breaks::Consistent)\n+}\n+\n+pub fn break_offset(p: &mut Printer, n: usize, off: isize) -> io::Result<()> {\n+    p.pretty_print(Token::Break(BreakToken {\n+        offset: off,\n+        blank_space: n as isize\n+    }))\n+}\n+\n+pub fn end(p: &mut Printer) -> io::Result<()> {\n+    p.pretty_print(Token::End)\n+}\n+\n+pub fn eof(p: &mut Printer) -> io::Result<()> {\n+    p.pretty_print(Token::Eof)\n+}\n+\n+pub fn word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as isize))\n+}\n+\n+pub fn huge_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n+}\n+\n+pub fn zero_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n+}\n+\n+pub fn spaces(p: &mut Printer, n: usize) -> io::Result<()> {\n+    break_offset(p, n, 0)\n+}\n+\n+pub fn zerobreak(p: &mut Printer) -> io::Result<()> {\n+    spaces(p, 0)\n+}\n+\n+pub fn space(p: &mut Printer) -> io::Result<()> {\n+    spaces(p, 1)\n+}\n+\n+pub fn hardbreak(p: &mut Printer) -> io::Result<()> {\n+    spaces(p, SIZE_INFINITY as usize)\n+}\n+\n+pub fn hardbreak_tok_offset(off: isize) -> Token {\n+    Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n+}\n+\n+pub fn hardbreak_tok() -> Token {\n+    hardbreak_tok_offset(0)\n+}"}, {"sha": "eeb1f2e167a0dc337ee3e6d6d387c7001424f398", "filename": "src/librustc_front/print/pprust.rs", "status": "added", "additions": 2760, "deletions": 0, "changes": 2760, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "247ea2ea23b8cb63fec155efb728549e515d53e0", "filename": "src/librustc_front/util.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -0,0 +1,427 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir;\n+use hir::*;\n+use visit::{self, Visitor, FnKind};\n+use syntax::ast_util;\n+use syntax::ast::{Ident, NodeId, DUMMY_NODE_ID};\n+use syntax::codemap::Span;\n+use syntax::ptr::P;\n+use syntax::owned_slice::OwnedSlice;\n+\n+pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n+    // FIXME(#19596) this is a workaround, but there should be a better way\n+    fn walk_pat_<G>(pat: &Pat, it: &mut G) -> bool where G: FnMut(&Pat) -> bool {\n+        if !(*it)(pat) {\n+            return false;\n+        }\n+\n+        match pat.node {\n+            PatIdent(_, _, Some(ref p)) => walk_pat_(&**p, it),\n+            PatStruct(_, ref fields, _) => {\n+                fields.iter().all(|field| walk_pat_(&*field.node.pat, it))\n+            }\n+            PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n+                s.iter().all(|p| walk_pat_(&**p, it))\n+            }\n+            PatBox(ref s) | PatRegion(ref s, _) => {\n+                walk_pat_(&**s, it)\n+            }\n+            PatVec(ref before, ref slice, ref after) => {\n+                before.iter().all(|p| walk_pat_(&**p, it)) &&\n+                slice.iter().all(|p| walk_pat_(&**p, it)) &&\n+                after.iter().all(|p| walk_pat_(&**p, it))\n+            }\n+            PatWild(_) | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n+            PatEnum(_, _) | PatQPath(_, _) => {\n+                true\n+            }\n+        }\n+    }\n+\n+    walk_pat_(pat, &mut it)\n+}\n+\n+pub fn binop_to_string(op: BinOp_) -> &'static str {\n+    match op {\n+        BiAdd => \"+\",\n+        BiSub => \"-\",\n+        BiMul => \"*\",\n+        BiDiv => \"/\",\n+        BiRem => \"%\",\n+        BiAnd => \"&&\",\n+        BiOr => \"||\",\n+        BiBitXor => \"^\",\n+        BiBitAnd => \"&\",\n+        BiBitOr => \"|\",\n+        BiShl => \"<<\",\n+        BiShr => \">>\",\n+        BiEq => \"==\",\n+        BiLt => \"<\",\n+        BiLe => \"<=\",\n+        BiNe => \"!=\",\n+        BiGe => \">=\",\n+        BiGt => \">\"\n+    }\n+}\n+\n+/// Returns true if the given struct def is tuple-like; i.e. that its fields\n+/// are unnamed.\n+pub fn struct_def_is_tuple_like(struct_def: &hir::StructDef) -> bool {\n+    struct_def.ctor_id.is_some()\n+}\n+\n+pub fn stmt_id(s: &Stmt) -> NodeId {\n+    match s.node {\n+      StmtDecl(_, id) => id,\n+      StmtExpr(_, id) => id,\n+      StmtSemi(_, id) => id,\n+    }\n+}\n+\n+pub fn lazy_binop(b: BinOp_) -> bool {\n+    match b {\n+      BiAnd => true,\n+      BiOr => true,\n+      _ => false\n+    }\n+}\n+\n+pub fn is_shift_binop(b: BinOp_) -> bool {\n+    match b {\n+      BiShl => true,\n+      BiShr => true,\n+      _ => false\n+    }\n+}\n+\n+pub fn is_comparison_binop(b: BinOp_) -> bool {\n+    match b {\n+        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe =>\n+            true,\n+        BiAnd | BiOr | BiAdd | BiSub | BiMul | BiDiv | BiRem |\n+        BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr =>\n+            false,\n+    }\n+}\n+\n+/// Returns `true` if the binary operator takes its arguments by value\n+pub fn is_by_value_binop(b: BinOp_) -> bool {\n+    !is_comparison_binop(b)\n+}\n+\n+/// Returns `true` if the unary operator takes its argument by value\n+pub fn is_by_value_unop(u: UnOp) -> bool {\n+    match u {\n+        UnNeg | UnNot => true,\n+        _ => false,\n+    }\n+}\n+\n+pub fn unop_to_string(op: UnOp) -> &'static str {\n+    match op {\n+      UnUniq => \"box() \",\n+      UnDeref => \"*\",\n+      UnNot => \"!\",\n+      UnNeg => \"-\",\n+    }\n+}\n+\n+pub struct IdVisitor<'a, O:'a> {\n+    pub operation: &'a mut O,\n+    pub pass_through_items: bool,\n+    pub visited_outermost: bool,\n+}\n+\n+impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n+    fn visit_generics_helper(&mut self, generics: &Generics) {\n+        for type_parameter in generics.ty_params.iter() {\n+            self.operation.visit_id(type_parameter.id)\n+        }\n+        for lifetime in &generics.lifetimes {\n+            self.operation.visit_id(lifetime.lifetime.id)\n+        }\n+    }\n+}\n+\n+impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n+    fn visit_mod(&mut self,\n+                 module: &Mod,\n+                 _: Span,\n+                 node_id: NodeId) {\n+        self.operation.visit_id(node_id);\n+        visit::walk_mod(self, module)\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+        self.operation.visit_id(foreign_item.id);\n+        visit::walk_foreign_item(self, foreign_item)\n+    }\n+\n+    fn visit_item(&mut self, item: &Item) {\n+        if !self.pass_through_items {\n+            if self.visited_outermost {\n+                return\n+            } else {\n+                self.visited_outermost = true\n+            }\n+        }\n+\n+        self.operation.visit_id(item.id);\n+        match item.node {\n+            ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathSimple(_, _) |\n+                    ViewPathGlob(_) => {}\n+                    ViewPathList(_, ref paths) => {\n+                        for path in paths {\n+                            self.operation.visit_id(path.node.id())\n+                        }\n+                    }\n+                }\n+            }\n+            ItemEnum(ref enum_definition, _) => {\n+                for variant in &enum_definition.variants {\n+                    self.operation.visit_id(variant.node.id)\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_item(self, item);\n+\n+        self.visited_outermost = false\n+    }\n+\n+    fn visit_local(&mut self, local: &Local) {\n+        self.operation.visit_id(local.id);\n+        visit::walk_local(self, local)\n+    }\n+\n+    fn visit_block(&mut self, block: &Block) {\n+        self.operation.visit_id(block.id);\n+        visit::walk_block(self, block)\n+    }\n+\n+    fn visit_stmt(&mut self, statement: &Stmt) {\n+        self.operation.visit_id(stmt_id(statement));\n+        visit::walk_stmt(self, statement)\n+    }\n+\n+    fn visit_pat(&mut self, pattern: &Pat) {\n+        self.operation.visit_id(pattern.id);\n+        visit::walk_pat(self, pattern)\n+    }\n+\n+    fn visit_expr(&mut self, expression: &Expr) {\n+        self.operation.visit_id(expression.id);\n+        visit::walk_expr(self, expression)\n+    }\n+\n+    fn visit_ty(&mut self, typ: &Ty) {\n+        self.operation.visit_id(typ.id);\n+        visit::walk_ty(self, typ)\n+    }\n+\n+    fn visit_generics(&mut self, generics: &Generics) {\n+        self.visit_generics_helper(generics);\n+        visit::walk_generics(self, generics)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                function_kind: FnKind<'v>,\n+                function_declaration: &'v FnDecl,\n+                block: &'v Block,\n+                span: Span,\n+                node_id: NodeId) {\n+        if !self.pass_through_items {\n+            match function_kind {\n+                FnKind::Method(..) if self.visited_outermost => return,\n+                FnKind::Method(..) => self.visited_outermost = true,\n+                _ => {}\n+            }\n+        }\n+\n+        self.operation.visit_id(node_id);\n+\n+        match function_kind {\n+            FnKind::ItemFn(_, generics, _, _, _, _) => {\n+                self.visit_generics_helper(generics)\n+            }\n+            FnKind::Method(_, sig, _) => {\n+                self.visit_generics_helper(&sig.generics)\n+            }\n+            FnKind::Closure => {}\n+        }\n+\n+        for argument in &function_declaration.inputs {\n+            self.operation.visit_id(argument.id)\n+        }\n+\n+        visit::walk_fn(self,\n+                       function_kind,\n+                       function_declaration,\n+                       block,\n+                       span);\n+\n+        if !self.pass_through_items {\n+            if let FnKind::Method(..) = function_kind {\n+                self.visited_outermost = false;\n+            }\n+        }\n+    }\n+\n+    fn visit_struct_field(&mut self, struct_field: &StructField) {\n+        self.operation.visit_id(struct_field.node.id);\n+        visit::walk_struct_field(self, struct_field)\n+    }\n+\n+    fn visit_struct_def(&mut self,\n+                        struct_def: &StructDef,\n+                        _: Ident,\n+                        _: &hir::Generics,\n+                        id: NodeId) {\n+        self.operation.visit_id(id);\n+        struct_def.ctor_id.map(|ctor_id| self.operation.visit_id(ctor_id));\n+        visit::walk_struct_def(self, struct_def);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+        self.operation.visit_id(ti.id);\n+        visit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+        self.operation.visit_id(ii.id);\n+        visit::walk_impl_item(self, ii);\n+    }\n+\n+    fn visit_lifetime_ref(&mut self, lifetime: &Lifetime) {\n+        self.operation.visit_id(lifetime.id);\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n+        self.visit_lifetime_ref(&def.lifetime);\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n+        self.operation.visit_id(trait_ref.ref_id);\n+        visit::walk_trait_ref(self, trait_ref);\n+    }\n+}\n+\n+/// Computes the id range for a single fn body, ignoring nested items.\n+pub fn compute_id_range_for_fn_body(fk: FnKind,\n+                                    decl: &FnDecl,\n+                                    body: &Block,\n+                                    sp: Span,\n+                                    id: NodeId)\n+                                    -> ast_util::IdRange\n+{\n+    let mut visitor = ast_util::IdRangeComputingVisitor {\n+        result: ast_util::IdRange::max()\n+    };\n+    let mut id_visitor = IdVisitor {\n+        operation: &mut visitor,\n+        pass_through_items: false,\n+        visited_outermost: false,\n+    };\n+    id_visitor.visit_fn(fk, decl, body, sp, id);\n+    id_visitor.operation.result\n+}\n+\n+/// Returns true if this literal is a string and false otherwise.\n+pub fn lit_is_str(lit: &Lit) -> bool {\n+    match lit.node {\n+        LitStr(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+pub fn is_path(e: P<Expr>) -> bool {\n+    match e.node { ExprPath(..) => true, _ => false }\n+}\n+\n+/// Get a string representation of a signed int type, with its value.\n+/// We want to avoid \"45int\" and \"-3int\" in favor of \"45\" and \"-3\"\n+pub fn int_ty_to_string(t: IntTy, val: Option<i64>) -> String {\n+    let s = match t {\n+        TyIs => \"isize\",\n+        TyI8 => \"i8\",\n+        TyI16 => \"i16\",\n+        TyI32 => \"i32\",\n+        TyI64 => \"i64\"\n+    };\n+\n+    match val {\n+        // cast to a u64 so we can correctly print INT64_MIN. All integral types\n+        // are parsed as u64, so we wouldn't want to print an extra negative\n+        // sign.\n+        Some(n) => format!(\"{}{}\", n as u64, s),\n+        None => s.to_string()\n+    }\n+}\n+\n+\n+/// Get a string representation of an unsigned int type, with its value.\n+/// We want to avoid \"42u\" in favor of \"42us\". \"42uint\" is right out.\n+pub fn uint_ty_to_string(t: UintTy, val: Option<u64>) -> String {\n+    let s = match t {\n+        TyUs => \"usize\",\n+        TyU8 => \"u8\",\n+        TyU16 => \"u16\",\n+        TyU32 => \"u32\",\n+        TyU64 => \"u64\"\n+    };\n+\n+    match val {\n+        Some(n) => format!(\"{}{}\", n, s),\n+        None => s.to_string()\n+    }\n+}\n+\n+pub fn float_ty_to_string(t: FloatTy) -> String {\n+    match t {\n+        TyF32 => \"f32\".to_string(),\n+        TyF64 => \"f64\".to_string(),\n+    }\n+}\n+\n+\n+pub fn empty_generics() -> Generics {\n+    Generics {\n+        lifetimes: Vec::new(),\n+        ty_params: OwnedSlice::empty(),\n+        where_clause: WhereClause {\n+            id: DUMMY_NODE_ID,\n+            predicates: Vec::new(),\n+        }\n+    }\n+}\n+\n+// convert a span and an identifier to the corresponding\n+// 1-segment path\n+pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n+    hir::Path {\n+        span: s,\n+        global: false,\n+        segments: vec!(\n+            hir::PathSegment {\n+                identifier: identifier,\n+                parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n+                    lifetimes: Vec::new(),\n+                    types: OwnedSlice::empty(),\n+                    bindings: OwnedSlice::empty(),\n+                })\n+            }\n+        ),\n+    }\n+}"}, {"sha": "703ac6d6e1649fcc2262439e1d02c0d6eb39f01b", "filename": "src/librustc_front/visit.rs", "status": "added", "additions": 841, "deletions": 0, "changes": 841, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -0,0 +1,841 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! HIR walker. Each overridden visit method has full control over what\n+//! happens with its node, it can do its own traversal of the node's children,\n+//! call `visit::walk_*` to apply the default traversal algorithm, or prevent\n+//! deeper traversal by doing nothing.\n+//!\n+//! Note: it is an important invariant that the default visitor walks the body\n+//! of a function in \"execution order\" (more concretely, reverse post-order\n+//! with respect to the CFG implied by the AST), meaning that if AST node A may\n+//! execute before AST node B, then A is visited first.  The borrow checker in\n+//! particular relies on this property.\n+//!\n+//! Note: walking an AST before macro expansion is probably a bad idea. For\n+//! instance, a walker looking for item names in a module will miss all of\n+//! those that are created by the expansion of a macro.\n+\n+use syntax::abi::Abi;\n+use syntax::ast::{Ident, NodeId, CRATE_NODE_ID, Name};\n+use hir::*;\n+use hir;\n+use syntax::codemap::Span;\n+use syntax::ptr::P;\n+use syntax::owned_slice::OwnedSlice;\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum FnKind<'a> {\n+    /// fn foo() or extern \"Abi\" fn foo()\n+    ItemFn(Ident, &'a Generics, Unsafety, Constness, Abi, Visibility),\n+\n+    /// fn foo(&self)\n+    Method(Ident, &'a MethodSig, Option<Visibility>),\n+\n+    /// |x, y| ...\n+    /// proc(x, y) ...\n+    Closure,\n+}\n+\n+/// Each method of the Visitor trait is a hook to be potentially\n+/// overridden.  Each method's default implementation recursively visits\n+/// the substructure of the input via the corresponding `walk` method;\n+/// e.g. the `visit_mod` method by default calls `visit::walk_mod`.\n+///\n+/// If you want to ensure that your code handles every variant\n+/// explicitly, you need to override each method.  (And you also need\n+/// to monitor future changes to `Visitor` in case a new method with a\n+/// new default implementation gets introduced.)\n+pub trait Visitor<'v> : Sized {\n+    fn visit_name(&mut self, _span: Span, _name: Name) {\n+        // Nothing to do.\n+    }\n+    fn visit_ident(&mut self, span: Span, ident: Ident) {\n+        self.visit_name(span, ident.name);\n+    }\n+    fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n+    fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n+    fn visit_item(&mut self, i: &'v Item) { walk_item(self, i) }\n+    fn visit_local(&mut self, l: &'v Local) { walk_local(self, l) }\n+    fn visit_block(&mut self, b: &'v Block) { walk_block(self, b) }\n+    fn visit_stmt(&mut self, s: &'v Stmt) { walk_stmt(self, s) }\n+    fn visit_arm(&mut self, a: &'v Arm) { walk_arm(self, a) }\n+    fn visit_pat(&mut self, p: &'v Pat) { walk_pat(self, p) }\n+    fn visit_decl(&mut self, d: &'v Decl) { walk_decl(self, d) }\n+    fn visit_expr(&mut self, ex: &'v Expr) { walk_expr(self, ex) }\n+    fn visit_expr_post(&mut self, _ex: &'v Expr) { }\n+    fn visit_ty(&mut self, t: &'v Ty) { walk_ty(self, t) }\n+    fn visit_generics(&mut self, g: &'v Generics) { walk_generics(self, g) }\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n+        walk_fn(self, fk, fd, b, s)\n+    }\n+    fn visit_trait_item(&mut self, ti: &'v TraitItem) { walk_trait_item(self, ti) }\n+    fn visit_impl_item(&mut self, ii: &'v ImplItem) { walk_impl_item(self, ii) }\n+    fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n+    fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n+        walk_ty_param_bound(self, bounds)\n+    }\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+        walk_poly_trait_ref(self, t, m)\n+    }\n+    fn visit_struct_def(&mut self, s: &'v StructDef, _: Ident, _: &'v Generics, _: NodeId) {\n+        walk_struct_def(self, s)\n+    }\n+    fn visit_struct_field(&mut self, s: &'v StructField) { walk_struct_field(self, s) }\n+    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n+                      generics: &'v Generics) {\n+        walk_enum_def(self, enum_definition, generics)\n+    }\n+\n+    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) { walk_variant(self, v, g) }\n+\n+    /// Visits an optional reference to a lifetime. The `span` is the span of some surrounding\n+    /// reference should opt_lifetime be None.\n+    fn visit_opt_lifetime_ref(&mut self,\n+                              _span: Span,\n+                              opt_lifetime: &'v Option<Lifetime>) {\n+        match *opt_lifetime {\n+            Some(ref l) => self.visit_lifetime_ref(l),\n+            None => ()\n+        }\n+    }\n+    fn visit_lifetime_bound(&mut self, lifetime: &'v Lifetime) {\n+        walk_lifetime_bound(self, lifetime)\n+    }\n+    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n+        walk_lifetime_ref(self, lifetime)\n+    }\n+    fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n+        walk_lifetime_def(self, lifetime)\n+    }\n+    fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n+        walk_explicit_self(self, es)\n+    }\n+    fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n+        walk_path(self, path)\n+    }\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n+        walk_path_segment(self, path_span, path_segment)\n+    }\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n+        walk_path_parameters(self, path_span, path_parameters)\n+    }\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+        walk_assoc_type_binding(self, type_binding)\n+    }\n+    fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n+}\n+\n+pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n+    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n+    for attr in &krate.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+}\n+\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n+    for item in &module.items {\n+        visitor.visit_item(&**item)\n+    }\n+}\n+\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+    visitor.visit_pat(&*local.pat);\n+    walk_ty_opt(visitor, &local.ty);\n+    walk_expr_opt(visitor, &local.init);\n+}\n+\n+pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                              lifetime_def: &'v LifetimeDef) {\n+    visitor.visit_name(lifetime_def.lifetime.span, lifetime_def.lifetime.name);\n+    for bound in &lifetime_def.bounds {\n+        visitor.visit_lifetime_bound(bound);\n+    }\n+}\n+\n+pub fn walk_lifetime_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                               lifetime_ref: &'v Lifetime) {\n+    visitor.visit_lifetime_ref(lifetime_ref)\n+}\n+\n+pub fn walk_lifetime_ref<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             lifetime_ref: &'v Lifetime) {\n+    visitor.visit_name(lifetime_ref.span, lifetime_ref.name)\n+}\n+\n+pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                              explicit_self: &'v ExplicitSelf) {\n+    match explicit_self.node {\n+        SelfStatic | SelfValue(_) => {},\n+        SelfRegion(ref lifetime, _, _) => {\n+            visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime)\n+        }\n+        SelfExplicit(ref typ, _) => visitor.visit_ty(&**typ),\n+    }\n+}\n+\n+pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n+                                  trait_ref: &'v PolyTraitRef,\n+                                  _modifier: &'v TraitBoundModifier)\n+    where V: Visitor<'v>\n+{\n+    walk_lifetime_decls_helper(visitor, &trait_ref.bound_lifetimes);\n+    visitor.visit_trait_ref(&trait_ref.trait_ref);\n+}\n+\n+pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n+                                   trait_ref: &'v TraitRef)\n+    where V: Visitor<'v>\n+{\n+    visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n+}\n+\n+pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n+    visitor.visit_ident(item.span, item.ident);\n+    match item.node {\n+        ItemExternCrate(..) => {}\n+        ItemUse(ref vp) => {\n+            match vp.node {\n+                ViewPathSimple(ident, ref path) => {\n+                    visitor.visit_ident(vp.span, ident);\n+                    visitor.visit_path(path, item.id);\n+                }\n+                ViewPathGlob(ref path) => {\n+                    visitor.visit_path(path, item.id);\n+                }\n+                ViewPathList(ref prefix, ref list) => {\n+                    for id in list {\n+                        match id.node {\n+                            PathListIdent { name, .. } => {\n+                                visitor.visit_ident(id.span, name);\n+                            }\n+                            PathListMod { .. } => ()\n+                        }\n+                    }\n+\n+                    // Note that the `prefix` here is not a complete\n+                    // path, so we don't use `visit_path`.\n+                    walk_path(visitor, prefix);\n+                }\n+            }\n+        }\n+        ItemStatic(ref typ, _, ref expr) |\n+        ItemConst(ref typ, ref expr) => {\n+            visitor.visit_ty(&**typ);\n+            visitor.visit_expr(&**expr);\n+        }\n+        ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+            visitor.visit_fn(FnKind::ItemFn(item.ident, generics, unsafety,\n+                                            constness, abi, item.vis),\n+                             &**declaration,\n+                             &**body,\n+                             item.span,\n+                             item.id)\n+        }\n+        ItemMod(ref module) => {\n+            visitor.visit_mod(module, item.span, item.id)\n+        }\n+        ItemForeignMod(ref foreign_module) => {\n+            for foreign_item in &foreign_module.items {\n+                visitor.visit_foreign_item(&**foreign_item)\n+            }\n+        }\n+        ItemTy(ref typ, ref type_parameters) => {\n+            visitor.visit_ty(&**typ);\n+            visitor.visit_generics(type_parameters)\n+        }\n+        ItemEnum(ref enum_definition, ref type_parameters) => {\n+            visitor.visit_generics(type_parameters);\n+            visitor.visit_enum_def(enum_definition, type_parameters)\n+        }\n+        ItemDefaultImpl(_, ref trait_ref) => {\n+            visitor.visit_trait_ref(trait_ref)\n+        }\n+        ItemImpl(_, _,\n+                 ref type_parameters,\n+                 ref trait_reference,\n+                 ref typ,\n+                 ref impl_items) => {\n+            visitor.visit_generics(type_parameters);\n+            match *trait_reference {\n+                Some(ref trait_reference) => visitor.visit_trait_ref(trait_reference),\n+                None => ()\n+            }\n+            visitor.visit_ty(&**typ);\n+            for impl_item in impl_items {\n+                visitor.visit_impl_item(impl_item);\n+            }\n+        }\n+        ItemStruct(ref struct_definition, ref generics) => {\n+            visitor.visit_generics(generics);\n+            visitor.visit_struct_def(&**struct_definition,\n+                                     item.ident,\n+                                     generics,\n+                                     item.id)\n+        }\n+        ItemTrait(_, ref generics, ref bounds, ref methods) => {\n+            visitor.visit_generics(generics);\n+            walk_ty_param_bounds_helper(visitor, bounds);\n+            for method in methods {\n+                visitor.visit_trait_item(method)\n+            }\n+        }\n+    }\n+    for attr in &item.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+}\n+\n+pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                         enum_definition: &'v EnumDef,\n+                                         generics: &'v Generics) {\n+    for variant in &enum_definition.variants {\n+        visitor.visit_variant(&**variant, generics);\n+    }\n+}\n+\n+pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                        variant: &'v Variant,\n+                                        generics: &'v Generics) {\n+    visitor.visit_ident(variant.span, variant.node.name);\n+\n+    match variant.node.kind {\n+        TupleVariantKind(ref variant_arguments) => {\n+            for variant_argument in variant_arguments {\n+                visitor.visit_ty(&*variant_argument.ty)\n+            }\n+        }\n+        StructVariantKind(ref struct_definition) => {\n+            visitor.visit_struct_def(&**struct_definition,\n+                                     variant.node.name,\n+                                     generics,\n+                                     variant.node.id)\n+        }\n+    }\n+    match variant.node.disr_expr {\n+        Some(ref expr) => visitor.visit_expr(&**expr),\n+        None => ()\n+    }\n+    for attr in &variant.node.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+}\n+\n+pub fn skip_ty<'v, V: Visitor<'v>>(_: &mut V, _: &'v Ty) {\n+    // Empty!\n+}\n+\n+pub fn walk_ty_opt<'v, V: Visitor<'v>>(visitor: &mut V, optional_type: &'v Option<P<Ty>>) {\n+    match *optional_type {\n+        Some(ref ty) => visitor.visit_ty(&**ty),\n+        None => ()\n+    }\n+}\n+\n+pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n+    match typ.node {\n+        TyVec(ref ty) | TyParen(ref ty) => {\n+            visitor.visit_ty(&**ty)\n+        }\n+        TyPtr(ref mutable_type) => {\n+            visitor.visit_ty(&*mutable_type.ty)\n+        }\n+        TyRptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_opt_lifetime_ref(typ.span, lifetime);\n+            visitor.visit_ty(&*mutable_type.ty)\n+        }\n+        TyTup(ref tuple_element_types) => {\n+            for tuple_element_type in tuple_element_types {\n+                visitor.visit_ty(&**tuple_element_type)\n+            }\n+        }\n+        TyBareFn(ref function_declaration) => {\n+            for argument in &function_declaration.decl.inputs {\n+                visitor.visit_ty(&*argument.ty)\n+            }\n+            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n+            walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n+        }\n+        TyPath(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n+            visitor.visit_path(path, typ.id);\n+        }\n+        TyObjectSum(ref ty, ref bounds) => {\n+            visitor.visit_ty(&**ty);\n+            walk_ty_param_bounds_helper(visitor, bounds);\n+        }\n+        TyFixedLengthVec(ref ty, ref expression) => {\n+            visitor.visit_ty(&**ty);\n+            visitor.visit_expr(&**expression)\n+        }\n+        TyPolyTraitRef(ref bounds) => {\n+            walk_ty_param_bounds_helper(visitor, bounds)\n+        }\n+        TyTypeof(ref expression) => {\n+            visitor.visit_expr(&**expression)\n+        }\n+        TyInfer => {}\n+    }\n+}\n+\n+pub fn walk_lifetime_decls_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                      lifetimes: &'v Vec<LifetimeDef>) {\n+    for l in lifetimes {\n+        visitor.visit_lifetime_def(l);\n+    }\n+}\n+\n+pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n+    for segment in &path.segments {\n+        visitor.visit_path_segment(path.span, segment);\n+    }\n+}\n+\n+pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             path_span: Span,\n+                                             segment: &'v PathSegment) {\n+    visitor.visit_ident(path_span, segment.identifier);\n+    visitor.visit_path_parameters(path_span, &segment.parameters);\n+}\n+\n+pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                _path_span: Span,\n+                                                path_parameters: &'v PathParameters) {\n+    match *path_parameters {\n+        hir::AngleBracketedParameters(ref data) => {\n+            for typ in data.types.iter() {\n+                visitor.visit_ty(&**typ);\n+            }\n+            for lifetime in &data.lifetimes {\n+                visitor.visit_lifetime_ref(lifetime);\n+            }\n+            for binding in data.bindings.iter() {\n+                visitor.visit_assoc_type_binding(&**binding);\n+            }\n+        }\n+        hir::ParenthesizedParameters(ref data) => {\n+            for typ in &data.inputs {\n+                visitor.visit_ty(&**typ);\n+            }\n+            if let Some(ref typ) = data.output {\n+                visitor.visit_ty(&**typ);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                   type_binding: &'v TypeBinding) {\n+    visitor.visit_ident(type_binding.span, type_binding.ident);\n+    visitor.visit_ty(&*type_binding.ty);\n+}\n+\n+pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n+    match pattern.node {\n+        PatEnum(ref path, ref children) => {\n+            visitor.visit_path(path, pattern.id);\n+            if let Some(ref children) = *children {\n+                for child in children {\n+                    visitor.visit_pat(&*child)\n+                }\n+            }\n+        }\n+        PatQPath(ref qself, ref path) => {\n+            visitor.visit_ty(&qself.ty);\n+            visitor.visit_path(path, pattern.id)\n+        }\n+        PatStruct(ref path, ref fields, _) => {\n+            visitor.visit_path(path, pattern.id);\n+            for field in fields {\n+                visitor.visit_pat(&*field.node.pat)\n+            }\n+        }\n+        PatTup(ref tuple_elements) => {\n+            for tuple_element in tuple_elements {\n+                visitor.visit_pat(&**tuple_element)\n+            }\n+        }\n+        PatBox(ref subpattern) |\n+        PatRegion(ref subpattern, _) => {\n+            visitor.visit_pat(&**subpattern)\n+        }\n+        PatIdent(_, ref pth1, ref optional_subpattern) => {\n+            visitor.visit_ident(pth1.span, pth1.node);\n+            match *optional_subpattern {\n+                None => {}\n+                Some(ref subpattern) => visitor.visit_pat(&**subpattern),\n+            }\n+        }\n+        PatLit(ref expression) => visitor.visit_expr(&**expression),\n+        PatRange(ref lower_bound, ref upper_bound) => {\n+            visitor.visit_expr(&**lower_bound);\n+            visitor.visit_expr(&**upper_bound)\n+        }\n+        PatWild(_) => (),\n+        PatVec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n+            for prepattern in prepattern {\n+                visitor.visit_pat(&**prepattern)\n+            }\n+            if let Some(ref slice_pattern) = *slice_pattern {\n+                visitor.visit_pat(&**slice_pattern)\n+            }\n+            for postpattern in postpatterns {\n+                visitor.visit_pat(&**postpattern)\n+            }\n+        }\n+    }\n+}\n+\n+pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             foreign_item: &'v ForeignItem) {\n+    visitor.visit_ident(foreign_item.span, foreign_item.ident);\n+\n+    match foreign_item.node {\n+        ForeignItemFn(ref function_declaration, ref generics) => {\n+            walk_fn_decl(visitor, &**function_declaration);\n+            visitor.visit_generics(generics)\n+        }\n+        ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ),\n+    }\n+\n+    for attr in &foreign_item.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+}\n+\n+pub fn walk_ty_param_bounds_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                       bounds: &'v OwnedSlice<TyParamBound>) {\n+    for bound in bounds.iter() {\n+        visitor.visit_ty_param_bound(bound)\n+    }\n+}\n+\n+pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                               bound: &'v TyParamBound) {\n+    match *bound {\n+        TraitTyParamBound(ref typ, ref modifier) => {\n+            visitor.visit_poly_trait_ref(typ, modifier);\n+        }\n+        RegionTyParamBound(ref lifetime) => {\n+            visitor.visit_lifetime_bound(lifetime);\n+        }\n+    }\n+}\n+\n+pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n+    for param in generics.ty_params.iter() {\n+        visitor.visit_ident(param.span, param.ident);\n+        walk_ty_param_bounds_helper(visitor, &param.bounds);\n+        walk_ty_opt(visitor, &param.default);\n+    }\n+    walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n+    for predicate in &generics.where_clause.predicates {\n+        match predicate {\n+            &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bounded_ty,\n+                                                                          ref bounds,\n+                                                                          ..}) => {\n+                visitor.visit_ty(&**bounded_ty);\n+                walk_ty_param_bounds_helper(visitor, bounds);\n+            }\n+            &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n+                                                                            ref bounds,\n+                                                                            ..}) => {\n+                visitor.visit_lifetime_ref(lifetime);\n+\n+                for bound in bounds {\n+                    visitor.visit_lifetime_ref(bound);\n+                }\n+            }\n+            &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{id,\n+                                                                    ref path,\n+                                                                    ref ty,\n+                                                                    ..}) => {\n+                visitor.visit_path(path, id);\n+                visitor.visit_ty(&**ty);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n+    if let Return(ref output_ty) = *ret_ty {\n+        visitor.visit_ty(&**output_ty)\n+    }\n+}\n+\n+pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n+    for argument in &function_declaration.inputs {\n+        visitor.visit_pat(&*argument.pat);\n+        visitor.visit_ty(&*argument.ty)\n+    }\n+    walk_fn_ret_ty(visitor, &function_declaration.output)\n+}\n+\n+pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                   function_kind: FnKind<'v>,\n+                                   function_declaration: &'v FnDecl,\n+                                   function_body: &'v Block,\n+                                   _span: Span) {\n+    walk_fn_decl(visitor, function_declaration);\n+\n+    match function_kind {\n+        FnKind::ItemFn(_, generics, _, _, _, _) => {\n+            visitor.visit_generics(generics);\n+        }\n+        FnKind::Method(_, sig, _) => {\n+            visitor.visit_generics(&sig.generics);\n+            visitor.visit_explicit_self(&sig.explicit_self);\n+        }\n+        FnKind::Closure(..) => {}\n+    }\n+\n+    visitor.visit_block(function_body)\n+}\n+\n+pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n+    visitor.visit_ident(trait_item.span, trait_item.ident);\n+    for attr in &trait_item.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+    match trait_item.node {\n+        ConstTraitItem(ref ty, ref default) => {\n+            visitor.visit_ty(ty);\n+            if let Some(ref expr) = *default {\n+                visitor.visit_expr(expr);\n+            }\n+        }\n+        MethodTraitItem(ref sig, None) => {\n+            visitor.visit_explicit_self(&sig.explicit_self);\n+            visitor.visit_generics(&sig.generics);\n+            walk_fn_decl(visitor, &sig.decl);\n+        }\n+        MethodTraitItem(ref sig, Some(ref body)) => {\n+            visitor.visit_fn(FnKind::Method(trait_item.ident, sig, None), &sig.decl,\n+                             body, trait_item.span, trait_item.id);\n+        }\n+        TypeTraitItem(ref bounds, ref default) => {\n+            walk_ty_param_bounds_helper(visitor, bounds);\n+            walk_ty_opt(visitor, default);\n+        }\n+    }\n+}\n+\n+pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n+    visitor.visit_ident(impl_item.span, impl_item.ident);\n+    for attr in &impl_item.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+    match impl_item.node {\n+        ConstImplItem(ref ty, ref expr) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_expr(expr);\n+        }\n+        MethodImplItem(ref sig, ref body) => {\n+            visitor.visit_fn(FnKind::Method(impl_item.ident, sig, Some(impl_item.vis)), &sig.decl,\n+                             body, impl_item.span, impl_item.id);\n+        }\n+        TypeImplItem(ref ty) => {\n+            visitor.visit_ty(ty);\n+        }\n+    }\n+}\n+\n+pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                           struct_definition: &'v StructDef) {\n+    for field in &struct_definition.fields {\n+        visitor.visit_struct_field(field)\n+    }\n+}\n+\n+pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             struct_field: &'v StructField) {\n+    if let NamedField(name, _) = struct_field.node.kind {\n+        visitor.visit_ident(struct_field.span, name);\n+    }\n+\n+    visitor.visit_ty(&*struct_field.node.ty);\n+\n+    for attr in &struct_field.node.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+}\n+\n+pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n+    for statement in &block.stmts {\n+        visitor.visit_stmt(&**statement)\n+    }\n+    walk_expr_opt(visitor, &block.expr)\n+}\n+\n+pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n+    match statement.node {\n+        StmtDecl(ref declaration, _) => visitor.visit_decl(&**declaration),\n+        StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n+            visitor.visit_expr(&**expression)\n+        }\n+    }\n+}\n+\n+pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n+    match declaration.node {\n+        DeclLocal(ref local) => visitor.visit_local(&**local),\n+        DeclItem(ref item) => visitor.visit_item(&**item),\n+    }\n+}\n+\n+pub fn walk_expr_opt<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                         optional_expression: &'v Option<P<Expr>>) {\n+    match *optional_expression {\n+        None => {}\n+        Some(ref expression) => visitor.visit_expr(&**expression),\n+    }\n+}\n+\n+pub fn walk_exprs<'v, V: Visitor<'v>>(visitor: &mut V, expressions: &'v [P<Expr>]) {\n+    for expression in expressions {\n+        visitor.visit_expr(&**expression)\n+    }\n+}\n+\n+pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n+    match expression.node {\n+        ExprBox(ref place, ref subexpression) => {\n+            place.as_ref().map(|e|visitor.visit_expr(&**e));\n+            visitor.visit_expr(&**subexpression)\n+        }\n+        ExprVec(ref subexpressions) => {\n+            walk_exprs(visitor, subexpressions)\n+        }\n+        ExprRepeat(ref element, ref count) => {\n+            visitor.visit_expr(&**element);\n+            visitor.visit_expr(&**count)\n+        }\n+        ExprStruct(ref path, ref fields, ref optional_base) => {\n+            visitor.visit_path(path, expression.id);\n+            for field in fields {\n+                visitor.visit_expr(&*field.expr)\n+            }\n+            walk_expr_opt(visitor, optional_base)\n+        }\n+        ExprTup(ref subexpressions) => {\n+            for subexpression in subexpressions {\n+                visitor.visit_expr(&**subexpression)\n+            }\n+        }\n+        ExprCall(ref callee_expression, ref arguments) => {\n+            for argument in arguments {\n+                visitor.visit_expr(&**argument)\n+            }\n+            visitor.visit_expr(&**callee_expression)\n+        }\n+        ExprMethodCall(_, ref types, ref arguments) => {\n+            walk_exprs(visitor, arguments);\n+            for typ in types {\n+                visitor.visit_ty(&**typ)\n+            }\n+        }\n+        ExprBinary(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(&**left_expression);\n+            visitor.visit_expr(&**right_expression)\n+        }\n+        ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n+            visitor.visit_expr(&**subexpression)\n+        }\n+        ExprLit(_) => {}\n+        ExprCast(ref subexpression, ref typ) => {\n+            visitor.visit_expr(&**subexpression);\n+            visitor.visit_ty(&**typ)\n+        }\n+        ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n+            visitor.visit_expr(&**head_expression);\n+            visitor.visit_block(&**if_block);\n+            walk_expr_opt(visitor, optional_else)\n+        }\n+        ExprWhile(ref subexpression, ref block, _) => {\n+            visitor.visit_expr(&**subexpression);\n+            visitor.visit_block(&**block)\n+        }\n+        ExprLoop(ref block, _) => visitor.visit_block(&**block),\n+        ExprMatch(ref subexpression, ref arms, _) => {\n+            visitor.visit_expr(&**subexpression);\n+            for arm in arms {\n+                visitor.visit_arm(arm)\n+            }\n+        }\n+        ExprClosure(_, ref function_declaration, ref body) => {\n+            visitor.visit_fn(FnKind::Closure,\n+                             &**function_declaration,\n+                             &**body,\n+                             expression.span,\n+                             expression.id)\n+        }\n+        ExprBlock(ref block) => visitor.visit_block(&**block),\n+        ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n+            visitor.visit_expr(&**right_hand_expression);\n+            visitor.visit_expr(&**left_hand_expression)\n+        }\n+        ExprAssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(&**right_expression);\n+            visitor.visit_expr(&**left_expression)\n+        }\n+        ExprField(ref subexpression, _) => {\n+            visitor.visit_expr(&**subexpression);\n+        }\n+        ExprTupField(ref subexpression, _) => {\n+            visitor.visit_expr(&**subexpression);\n+        }\n+        ExprIndex(ref main_expression, ref index_expression) => {\n+            visitor.visit_expr(&**main_expression);\n+            visitor.visit_expr(&**index_expression)\n+        }\n+        ExprRange(ref start, ref end) => {\n+            walk_expr_opt(visitor, start);\n+            walk_expr_opt(visitor, end)\n+        }\n+        ExprPath(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n+            visitor.visit_path(path, expression.id)\n+        }\n+        ExprBreak(_) | ExprAgain(_) => {}\n+        ExprRet(ref optional_expression) => {\n+            walk_expr_opt(visitor, optional_expression)\n+        }\n+        ExprParen(ref subexpression) => {\n+            visitor.visit_expr(&**subexpression)\n+        }\n+        ExprInlineAsm(ref ia) => {\n+            for input in &ia.inputs {\n+                let (_, ref input) = *input;\n+                visitor.visit_expr(&**input)\n+            }\n+            for output in &ia.outputs {\n+                let (_, ref output, _) = *output;\n+                visitor.visit_expr(&**output)\n+            }\n+        }\n+    }\n+\n+    visitor.visit_expr_post(expression)\n+}\n+\n+pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n+    for pattern in &arm.pats {\n+        visitor.visit_pat(&**pattern)\n+    }\n+    walk_expr_opt(visitor, &arm.guard);\n+    visitor.visit_expr(&*arm.body);\n+    for attr in &arm.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+}"}, {"sha": "40f7fbbdef702521d05643b39a6543b66b5d0a17", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 108, "deletions": 74, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -35,7 +35,7 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n-use rustc::ast_map;\n+use rustc::front::map as hir_map;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n@@ -53,6 +53,14 @@ use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU\n use syntax::ptr::P;\n use syntax::visit::{self, FnKind, Visitor};\n \n+use rustc_front::lowering::{lower_expr, lower_block, lower_item, lower_path, lower_pat,\n+                            lower_trait_ref};\n+use rustc_front::hir;\n+use rustc_front::attr as front_attr;\n+use rustc_front::attr::AttrMetaMethods as FrontAttrMetaMethods;\n+use rustc_front::visit::Visitor as HirVisitor;\n+use rustc_front::visit as hir_visit;\n+\n // hardwired lints from librustc\n pub use lint::builtin::*;\n \n@@ -129,15 +137,15 @@ impl LintPass for TypeLimits {\n                                 check_unsigned_negation_feature(cx, e.span);\n                             },\n                             ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n-                                if let ty::TyUint(_) = cx.tcx.expr_ty(e).sty {\n+                                if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n                                     check_unsigned_negation_feature(cx, e.span);\n                                 }\n                             },\n                             _ => ()\n                         }\n                     },\n                     _ => {\n-                        let t = cx.tcx.expr_ty(&**expr);\n+                        let t = cx.tcx.node_id_to_type(expr.id);\n                         match t.sty {\n                             ty::TyUint(_) => {\n                                 check_unsigned_negation_feature(cx, e.span);\n@@ -161,7 +169,7 @@ impl LintPass for TypeLimits {\n                 }\n \n                 if is_shift_binop(binop.node) {\n-                    let opt_ty_bits = match cx.tcx.expr_ty(&**l).sty {\n+                    let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None\n@@ -172,7 +180,8 @@ impl LintPass for TypeLimits {\n                             if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &**r, ExprTypeChecked) {\n+                            let r = lower_expr(r);\n+                            match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked) {\n                                 Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n                                 Ok(ConstVal::Uint(shift)) => { shift >= bits },\n                                 _ => { false }\n@@ -186,12 +195,12 @@ impl LintPass for TypeLimits {\n                 }\n             },\n             ast::ExprLit(ref lit) => {\n-                match cx.tcx.expr_ty(e).sty {\n+                match cx.tcx.node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                                let int_type = if let ast::TyIs = t {\n+                                let int_type = if let hir::TyIs = t {\n                                     cx.sess().target.int_type\n                                 } else {\n                                     t\n@@ -212,7 +221,7 @@ impl LintPass for TypeLimits {\n                         };\n                     },\n                     ty::TyUint(t) => {\n-                        let uint_type = if let ast::TyUs = t {\n+                        let uint_type = if let hir::TyUs = t {\n                             cx.sess().target.uint_type\n                         } else {\n                             t\n@@ -275,50 +284,50 @@ impl LintPass for TypeLimits {\n \n         // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+        fn int_ty_range(int_ty: hir::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::TyIs => (i64::MIN,        i64::MAX),\n-                ast::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n-                ast::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n-                ast::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n-                ast::TyI64 =>   (i64::MIN,        i64::MAX)\n+                hir::TyIs => (i64::MIN,        i64::MAX),\n+                hir::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n+                hir::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n+                hir::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n+                hir::TyI64 =>   (i64::MIN,        i64::MAX)\n             }\n         }\n \n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+        fn uint_ty_range(uint_ty: hir::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::TyUs => (u64::MIN,         u64::MAX),\n-                ast::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n-                ast::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n-                ast::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n-                ast::TyU64 =>   (u64::MIN,         u64::MAX)\n+                hir::TyUs => (u64::MIN,         u64::MAX),\n+                hir::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n+                hir::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n+                hir::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n+                hir::TyU64 =>   (u64::MIN,         u64::MAX)\n             }\n         }\n \n-        fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n+        fn float_ty_range(float_ty: hir::FloatTy) -> (f64, f64) {\n             match float_ty {\n-                ast::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n-                ast::TyF64 => (f64::MIN,        f64::MAX)\n+                hir::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n+                hir::TyF64 => (f64::MIN,        f64::MAX)\n             }\n         }\n \n-        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n+        fn int_ty_bits(int_ty: hir::IntTy, target_int_ty: hir::IntTy) -> u64 {\n             match int_ty {\n-                ast::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n-                ast::TyI8 =>    i8::BITS  as u64,\n-                ast::TyI16 =>   i16::BITS as u64,\n-                ast::TyI32 =>   i32::BITS as u64,\n-                ast::TyI64 =>   i64::BITS as u64\n+                hir::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n+                hir::TyI8 =>    i8::BITS  as u64,\n+                hir::TyI16 =>   i16::BITS as u64,\n+                hir::TyI32 =>   i32::BITS as u64,\n+                hir::TyI64 =>   i64::BITS as u64\n             }\n         }\n \n-        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n+        fn uint_ty_bits(uint_ty: hir::UintTy, target_uint_ty: hir::UintTy) -> u64 {\n             match uint_ty {\n-                ast::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n-                ast::TyU8 =>    u8::BITS  as u64,\n-                ast::TyU16 =>   u16::BITS as u64,\n-                ast::TyU32 =>   u32::BITS as u64,\n-                ast::TyU64 =>   u64::BITS as u64\n+                hir::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                hir::TyU8 =>    u8::BITS  as u64,\n+                hir::TyU16 =>   u16::BITS as u64,\n+                hir::TyU32 =>   u32::BITS as u64,\n+                hir::TyU64 =>   u64::BITS as u64\n             }\n         }\n \n@@ -336,7 +345,7 @@ impl LintPass for TypeLimits {\n             } else {\n                 binop\n             };\n-            match tcx.expr_ty(expr).sty {\n+            match tcx.node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -466,7 +475,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         match ty.sty {\n             ty::TyStruct(def, substs) => {\n-                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                if !cx.lookup_repr_hints(def.did).contains(&front_attr::ReprExtern) {\n                     return FfiUnsafe(\n                         \"found struct without foreign-function-safe \\\n                          representation annotation in foreign module, \\\n@@ -550,11 +559,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 FfiSafe\n             }\n \n-            ty::TyInt(ast::TyIs) => {\n+            ty::TyInt(hir::TyIs) => {\n                 FfiUnsafe(\"found Rust type `isize` in foreign module, while \\\n                           `libc::c_int` or `libc::c_long` should be used\")\n             }\n-            ty::TyUint(ast::TyUs) => {\n+            ty::TyUint(hir::TyUs) => {\n                 FfiUnsafe(\"found Rust type `usize` in foreign module, while \\\n                           `libc::c_uint` or `libc::c_ulong` should be used\")\n             }\n@@ -784,7 +793,7 @@ impl LintPass for BoxPointers {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        let ty = cx.tcx.expr_ty(e);\n+        let ty = cx.tcx.node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -799,17 +808,17 @@ struct RawPtrDeriveVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty) {\n+impl<'a, 'tcx, 'v> HirVisitor<'v> for RawPtrDeriveVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n         const MSG: &'static str = \"use of `#[derive]` with a raw pointer\";\n-        if let ast::TyPtr(..) = ty.node {\n+        if let hir::TyPtr(..) = ty.node {\n             self.cx.span_lint(RAW_POINTER_DERIVE, ty.span, MSG);\n         }\n-        visit::walk_ty(self, ty);\n+        hir_visit::walk_ty(self, ty);\n     }\n     // explicit override to a no-op to reduce code bloat\n-    fn visit_expr(&mut self, _: &ast::Expr) {}\n-    fn visit_block(&mut self, _: &ast::Block) {}\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    fn visit_block(&mut self, _: &hir::Block) {}\n }\n \n pub struct RawPointerDerive {\n@@ -833,8 +842,9 @@ impl LintPass for RawPointerDerive {\n         if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n             return;\n         }\n+        let item = lower_item(item);\n         let did = match item.node {\n-            ast::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n+            hir::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n                 // Deriving the Copy trait does not cause a warning\n                 if let &Some(ref trait_ref) = t_ref_opt {\n                     let def_id = cx.tcx.trait_ref_to_def_id(trait_ref);\n@@ -855,16 +865,16 @@ impl LintPass for RawPointerDerive {\n             return;\n         }\n         let item = match cx.tcx.map.find(did.node) {\n-            Some(ast_map::NodeItem(item)) => item,\n+            Some(hir_map::NodeItem(item)) => item,\n             _ => return,\n         };\n         if !self.checked_raw_pointers.insert(item.id) {\n             return;\n         }\n         match item.node {\n-            ast::ItemStruct(..) | ast::ItemEnum(..) => {\n+            hir::ItemStruct(..) | hir::ItemEnum(..) => {\n                 let mut visitor = RawPtrDeriveVisitor { cx: cx };\n-                visit::walk_item(&mut visitor, &*item);\n+                hir_visit::walk_item(&mut visitor, &item);\n             }\n             _ => {}\n         }\n@@ -989,14 +999,15 @@ impl LintPass for UnusedResults {\n             return;\n         }\n \n-        let t = cx.tcx.expr_ty(expr);\n+        let expr = lower_expr(expr);\n+        let t = cx.tcx.expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyBool => return,\n             ty::TyStruct(def, _) |\n             ty::TyEnum(def, _) => {\n                 if def.did.is_local() {\n-                    if let ast_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n+                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n                         check_must_use(cx, &it.attrs, s.span)\n                     } else {\n                         false\n@@ -1012,7 +1023,7 @@ impl LintPass for UnusedResults {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n-        fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n+        fn check_must_use(cx: &Context, attrs: &[hir::Attribute], sp: Span) -> bool {\n             for attr in attrs {\n                 if attr.check_name(\"must_use\") {\n                     let mut msg = \"unused result which must be used\".to_string();\n@@ -1642,9 +1653,9 @@ impl UnusedMut {\n \n         let mut mutables = FnvHashMap();\n         for p in pats {\n-            pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n+            pat_util::pat_bindings(&cx.tcx.def_map, &lower_pat(p), |mode, id, _, path1| {\n                 let ident = path1.node;\n-                if let ast::BindByValue(ast::MutMutable) = mode {\n+                if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !ident.name.as_str().starts_with(\"_\") {\n                         match mutables.entry(ident.name.usize()) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n@@ -1718,11 +1729,11 @@ impl LintPass for UnusedAllocation {\n         if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n             if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n                 match autoref {\n-                    &Some(ty::AutoPtr(_, ast::MutImmutable)) => {\n+                    &Some(ty::AutoPtr(_, hir::MutImmutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n-                    &Some(ty::AutoPtr(_, ast::MutMutable)) => {\n+                    &Some(ty::AutoPtr(_, hir::MutMutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                      \"unnecessary allocation, use &mut instead\");\n                     }\n@@ -1862,9 +1873,9 @@ impl LintPass for MissingDoc {\n             ast::ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = cx.tcx.trait_ref_to_def_id(trait_ref);\n+                let real_trait = cx.tcx.trait_ref_to_def_id(&lower_trait_ref(trait_ref));\n                 match cx.tcx.map.find(real_trait.node) {\n-                    Some(ast_map::NodeItem(item)) => if item.vis == ast::Visibility::Inherited {\n+                    Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n                         for itm in impl_items {\n                             self.private_traits.insert(itm.id);\n                         }\n@@ -2087,29 +2098,51 @@ impl Stability {\n     }\n }\n \n+fn hir_to_ast_stability(stab: &front_attr::Stability) -> attr::Stability {\n+    attr::Stability {\n+        level: match stab.level {\n+            front_attr::Unstable => attr::Unstable,\n+            front_attr::Stable => attr::Stable,\n+        },\n+        feature: stab.feature.clone(),\n+        since: stab.since.clone(),\n+        deprecated_since: stab.deprecated_since.clone(),\n+        reason: stab.reason.clone(),\n+        issue: stab.issue,\n+    }\n+}\n+\n impl LintPass for Stability {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DEPRECATED)\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        stability::check_item(cx.tcx, item, false,\n-                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+        stability::check_item(cx.tcx, &lower_item(item), false,\n+                              &mut |id, sp, stab|\n+                                self.lint(cx, id, sp,\n+                                          &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        stability::check_expr(cx.tcx, e,\n-                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+        stability::check_expr(cx.tcx, &lower_expr(e),\n+                              &mut |id, sp, stab|\n+                                self.lint(cx, id, sp,\n+                                          &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n     fn check_path(&mut self, cx: &Context, path: &ast::Path, id: ast::NodeId) {\n-        stability::check_path(cx.tcx, path, id,\n-                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+        stability::check_path(cx.tcx, &lower_path(path), id,\n+                              &mut |id, sp, stab|\n+                                self.lint(cx, id, sp,\n+                                          &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n \n     fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n-        stability::check_pat(cx.tcx, pat,\n-                             &mut |id, sp, stab| self.lint(cx, id, sp, stab))\n+        stability::check_pat(cx.tcx, &lower_pat(pat),\n+                             &mut |id, sp, stab|\n+                                self.lint(cx, id, sp,\n+                                          &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n     }\n }\n \n@@ -2168,7 +2201,7 @@ impl LintPass for UnconditionalRecursion {\n         // to have behaviour like the above, rather than\n         // e.g. accidentally recurring after an assert.\n \n-        let cfg = cfg::CFG::new(cx.tcx, blk);\n+        let cfg = cfg::CFG::new(cx.tcx, &lower_block(blk));\n \n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;\n@@ -2248,7 +2281,7 @@ impl LintPass for UnconditionalRecursion {\n                                   fn_id: ast::NodeId,\n                                   id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n-                ast_map::NodeExpr(&ast::Expr { node: ast::ExprCall(ref callee, _), .. }) => {\n+                hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     tcx.def_map.borrow().get(&callee.id)\n                         .map_or(false, |def| def.def_id() == DefId::local(fn_id))\n                 }\n@@ -2283,7 +2316,7 @@ impl LintPass for UnconditionalRecursion {\n \n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n             match tcx.map.get(id) {\n-                ast_map::NodeExpr(&ast::Expr { node: ast::ExprCall(ref callee, _), .. }) => {\n+                hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n                         Some(def::DefMethod(def_id)) => {\n                             let no_substs = &ty::ItemSubsts::empty();\n@@ -2479,12 +2512,13 @@ impl LintPass for MutableTransmutes {\n \n     fn check_expr(&mut self, cx: &Context, expr: &ast::Expr) {\n         use syntax::abi::RustIntrinsic;\n+\n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n             Some((&ty::TyRef(_, from_mt), &ty::TyRef(_, to_mt))) => {\n-                if to_mt.mutbl == ast::Mutability::MutMutable\n-                    && from_mt.mutbl == ast::Mutability::MutImmutable {\n+                if to_mt.mutbl == hir::Mutability::MutMutable\n+                    && from_mt.mutbl == hir::Mutability::MutImmutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }\n@@ -2497,7 +2531,7 @@ impl LintPass for MutableTransmutes {\n                 ast::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let def::DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n+            if let def::DefFn(did, _) = cx.tcx.resolve_expr(&lower_expr(expr)) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n@@ -2584,7 +2618,7 @@ impl LintPass for DropWithReprExtern {\n                 ty::TyStruct(self_type_def, _) => {\n                     let self_type_did = self_type_def.did;\n                     let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n-                    if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n+                    if hints.iter().any(|attr| *attr == front_attr::ReprExtern) &&\n                         self_type_def.dtor_kind().has_drop_flag() {\n                         let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n                                                                      codemap::DUMMY_SP);"}, {"sha": "517a3d13ddf76d810fcf7b51b6f986a487e5b3d6", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -47,6 +47,7 @@ extern crate syntax;\n extern crate rustc;\n #[macro_use]\n extern crate log;\n+extern crate rustc_front;\n \n pub use rustc::lint as lint;\n pub use rustc::metadata as metadata;"}, {"sha": "7f72ccb51e60db41da7bf83ee68cefda2a871fa6", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 143, "deletions": 143, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -27,13 +27,16 @@\n #[macro_use] extern crate syntax;\n \n extern crate rustc;\n+extern crate rustc_front;\n \n use self::PrivacyResult::*;\n use self::FieldName::*;\n \n use std::mem::replace;\n \n-use rustc::ast_map;\n+use rustc_front::hir;\n+use rustc_front::visit::{self, Visitor};\n+\n use rustc::middle::def;\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::ImportUse::*;\n@@ -42,10 +45,10 @@ use rustc::middle::privacy::PrivateDep::*;\n use rustc::middle::privacy::{ExternalExports, ExportedItems, PublicItems};\n use rustc::middle::ty::{self, Ty};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n+use rustc::front::map as ast_map;\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::visit::{self, Visitor};\n \n type Context<'a, 'tcx> = (&'a ty::MethodMap<'tcx>, &'a def::ExportMap);\n \n@@ -64,15 +67,15 @@ struct ParentVisitor {\n }\n \n impl<'v> Visitor<'v> for ParentVisitor {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         self.parents.insert(item.id, self.curparent);\n \n         let prev = self.curparent;\n         match item.node {\n-            ast::ItemMod(..) => { self.curparent = item.id; }\n+            hir::ItemMod(..) => { self.curparent = item.id; }\n             // Enum variants are parented to the enum definition itself because\n             // they inherit privacy\n-            ast::ItemEnum(ref def, _) => {\n+            hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n                     // The parent is considered the enclosing enum because the\n                     // enum will dictate the privacy visibility of this variant\n@@ -86,7 +89,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // method to the root. In this case, if the trait is private, then\n             // parent all the methods to the trait to indicate that they're\n             // private.\n-            ast::ItemTrait(_, _, _, ref trait_items) if item.vis != ast::Public => {\n+            hir::ItemTrait(_, _, _, ref trait_items) if item.vis != hir::Public => {\n                 for trait_item in trait_items {\n                     self.parents.insert(trait_item.id, item.id);\n                 }\n@@ -98,13 +101,13 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         self.curparent = prev;\n     }\n \n-    fn visit_foreign_item(&mut self, a: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, a: &hir::ForeignItem) {\n         self.parents.insert(a.id, self.curparent);\n         visit::walk_foreign_item(self, a);\n     }\n \n-    fn visit_fn(&mut self, a: visit::FnKind<'v>, b: &'v ast::FnDecl,\n-                c: &'v ast::Block, d: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, a: visit::FnKind<'v>, b: &'v hir::FnDecl,\n+                c: &'v hir::Block, d: Span, id: ast::NodeId) {\n         // We already took care of some trait methods above, otherwise things\n         // like impl methods and pub trait methods are parented to the\n         // containing module, not the containing trait.\n@@ -114,7 +117,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         visit::walk_fn(self, a, b, c, d);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         // visit_fn handles methods, but associated consts have to be handled\n         // here.\n         if !self.parents.contains_key(&ii.id) {\n@@ -123,8 +126,8 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_struct_def(&mut self, s: &ast::StructDef, _: ast::Ident,\n-                        _: &'v ast::Generics, n: ast::NodeId) {\n+    fn visit_struct_def(&mut self, s: &hir::StructDef, _: ast::Ident,\n+                        _: &'v hir::Generics, n: ast::NodeId) {\n         // Struct constructors are parented to their struct definitions because\n         // they essentially are the struct definitions.\n         match s.ctor_id {\n@@ -193,9 +196,9 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         let orig_all_pub = self.prev_public;\n-        self.prev_public = orig_all_pub && item.vis == ast::Public;\n+        self.prev_public = orig_all_pub && item.vis == hir::Public;\n         if self.prev_public {\n             self.public_items.insert(item.id);\n         }\n@@ -204,19 +207,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n             // cannot have visibility qualifiers on them anyway\n-            ast::ItemImpl(..) | ast::ItemDefaultImpl(..) | ast::ItemForeignMod(..) => {}\n+            hir::ItemImpl(..) | hir::ItemDefaultImpl(..) | hir::ItemForeignMod(..) => {}\n \n             // Traits are a little special in that even if they themselves are\n             // not public they may still be exported.\n-            ast::ItemTrait(..) => {\n+            hir::ItemTrait(..) => {\n                 self.prev_exported = self.exported_trait(item.id);\n             }\n \n             // Private by default, hence we only retain the \"public chain\" if\n             // `pub` is explicitly listed.\n             _ => {\n                 self.prev_exported =\n-                    (orig_all_exported && item.vis == ast::Public) ||\n+                    (orig_all_exported && item.vis == hir::Public) ||\n                      self.reexports.contains(&item.id);\n             }\n         }\n@@ -227,7 +230,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         match item.node {\n             // Enum variants inherit from their parent, so if the enum is\n             // public all variants are public unless they're explicitly priv\n-            ast::ItemEnum(ref def, _) if public_first => {\n+            hir::ItemEnum(ref def, _) if public_first => {\n                 for variant in &def.variants {\n                     self.exported_items.insert(variant.node.id);\n                     self.public_items.insert(variant.node.id);\n@@ -253,9 +256,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             //   undefined symbols at linkage time if this case is not handled.\n             //\n             // * Private trait impls for private types can be completely ignored\n-            ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n+            hir::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n-                    ast::TyPath(..) => {\n+                    hir::TyPath(..) => {\n                         match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n@@ -276,56 +279,55 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n                         match impl_item.node {\n-                            ast::ConstImplItem(..) => {\n-                                if (public_ty && impl_item.vis == ast::Public)\n+                            hir::ConstImplItem(..) => {\n+                                if (public_ty && impl_item.vis == hir::Public)\n                                     || tr.is_some() {\n                                     self.exported_items.insert(impl_item.id);\n                                 }\n                             }\n-                            ast::MethodImplItem(ref sig, _) => {\n+                            hir::MethodImplItem(ref sig, _) => {\n                                 let meth_public = match sig.explicit_self.node {\n-                                    ast::SelfStatic => public_ty,\n+                                    hir::SelfStatic => public_ty,\n                                     _ => true,\n-                                } && impl_item.vis == ast::Public;\n+                                } && impl_item.vis == hir::Public;\n                                 if meth_public || tr.is_some() {\n                                     self.exported_items.insert(impl_item.id);\n                                 }\n                             }\n-                            ast::TypeImplItem(_) |\n-                            ast::MacImplItem(_) => {}\n+                            hir::TypeImplItem(_) => {}\n                         }\n                     }\n                 }\n             }\n \n             // Default methods on traits are all public so long as the trait\n             // is public\n-            ast::ItemTrait(_, _, _, ref trait_items) if public_first => {\n+            hir::ItemTrait(_, _, _, ref trait_items) if public_first => {\n                 for trait_item in trait_items {\n                     debug!(\"trait item {}\", trait_item.id);\n                     self.exported_items.insert(trait_item.id);\n                 }\n             }\n \n             // Struct constructors are public if the struct is all public.\n-            ast::ItemStruct(ref def, _) if public_first => {\n+            hir::ItemStruct(ref def, _) if public_first => {\n                 match def.ctor_id {\n                     Some(id) => { self.exported_items.insert(id); }\n                     None => {}\n                 }\n                 // fields can be public or private, so lets check\n                 for field in &def.fields {\n                     let vis = match field.node.kind {\n-                        ast::NamedField(_, vis) | ast::UnnamedField(vis) => vis\n+                        hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n                     };\n-                    if vis == ast::Public {\n+                    if vis == hir::Public {\n                         self.public_items.insert(field.node.id);\n                     }\n                 }\n             }\n \n-            ast::ItemTy(ref ty, _) if public_first => {\n-                if let ast::TyPath(..) = ty.node {\n+            hir::ItemTy(ref ty, _) if public_first => {\n+                if let hir::TyPath(..) = ty.node {\n                     match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n@@ -347,13 +349,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         self.prev_public = orig_all_pub;\n     }\n \n-    fn visit_foreign_item(&mut self, a: &ast::ForeignItem) {\n-        if (self.prev_exported && a.vis == ast::Public) || self.reexports.contains(&a.id) {\n+    fn visit_foreign_item(&mut self, a: &hir::ForeignItem) {\n+        if (self.prev_exported && a.vis == hir::Public) || self.reexports.contains(&a.id) {\n             self.exported_items.insert(a.id);\n         }\n     }\n \n-    fn visit_mod(&mut self, m: &ast::Mod, _sp: Span, id: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &hir::Mod, _sp: Span, id: ast::NodeId) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_exported {\n@@ -426,7 +428,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                     debug!(\"privacy - found inherent \\\n                                             associated constant {:?}\",\n                                             ac.vis);\n-                                    if ac.vis == ast::Public {\n+                                    if ac.vis == hir::Public {\n                                         Allowable\n                                     } else {\n                                         ExternallyDenied\n@@ -453,7 +455,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                 None => {\n                                     debug!(\"privacy - found a method {:?}\",\n                                             meth.vis);\n-                                    if meth.vis == ast::Public {\n+                                    if meth.vis == hir::Public {\n                                         Allowable\n                                     } else {\n                                         ExternallyDenied\n@@ -478,7 +480,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                 None => {\n                                     debug!(\"privacy - found a typedef {:?}\",\n                                             typedef.vis);\n-                                    if typedef.vis == ast::Public {\n+                                    if typedef.vis == hir::Public {\n                                         Allowable\n                                     } else {\n                                         ExternallyDenied\n@@ -527,20 +529,19 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 //               where the method was defined?\n                 Some(ast_map::NodeImplItem(ii)) => {\n                     match ii.node {\n-                        ast::ConstImplItem(..) |\n-                        ast::MethodImplItem(..) => {\n+                        hir::ConstImplItem(..) |\n+                        hir::MethodImplItem(..) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n                             match self.tcx.impl_trait_ref(imp) {\n                                 Some(..) => return Allowable,\n-                                _ if ii.vis == ast::Public => {\n+                                _ if ii.vis == hir::Public => {\n                                     return Allowable\n                                 }\n                                 _ => ii.vis\n                             }\n                         }\n-                        ast::TypeImplItem(_) |\n-                        ast::MacImplItem(_) => return Allowable,\n+                        hir::TypeImplItem(_) => return Allowable,\n                     }\n                 }\n                 Some(ast_map::NodeTraitItem(_)) => {\n@@ -554,11 +555,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                     self.tcx.map.get_foreign_vis(closest_private_id)\n                 }\n                 Some(ast_map::NodeVariant(..)) => {\n-                    ast::Public // need to move up a level (to the enum)\n+                    hir::Public // need to move up a level (to the enum)\n                 }\n-                _ => ast::Public,\n+                _ => hir::Public,\n             };\n-            if vis != ast::Public { break }\n+            if vis != hir::Public { break }\n             // if we've reached the root, then everything was allowable and this\n             // access is public.\n             if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n@@ -654,9 +655,9 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                     // invoked, and the struct/enum itself is private. Crawl\n                     // back up the chains to find the relevant struct/enum that\n                     // was private.\n-                    ast::ItemImpl(_, _, _, _, ref ty, _) => {\n+                    hir::ItemImpl(_, _, _, _, ref ty, _) => {\n                         match ty.node {\n-                            ast::TyPath(..) => {}\n+                            hir::TyPath(..) => {}\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n                         let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n@@ -674,10 +675,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             Some(..) | None => return Some((err_span, err_msg, None)),\n         };\n         let desc = match item.node {\n-            ast::ItemMod(..) => \"module\",\n-            ast::ItemTrait(..) => \"trait\",\n-            ast::ItemStruct(..) => \"struct\",\n-            ast::ItemEnum(..) => \"enum\",\n+            hir::ItemMod(..) => \"module\",\n+            hir::ItemTrait(..) => \"trait\",\n+            hir::ItemStruct(..) => \"struct\",\n+            hir::ItemEnum(..) => \"enum\",\n             _ => return Some((err_span, err_msg, None))\n         };\n         let msg = format!(\"{} `{}` is private\", desc, item.ident);\n@@ -697,7 +698,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n             UnnamedField(idx) => &v.fields[idx]\n         };\n-        if field.vis == ast::Public ||\n+        if field.vis == hir::Public ||\n             (field.did.is_local() && self.private_accessible(field.did.node)) {\n             return\n         }\n@@ -854,16 +855,16 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        if let ast::ItemUse(ref vpath) = item.node {\n-            if let ast::ViewPathList(ref prefix, ref list) = vpath.node {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        if let hir::ItemUse(ref vpath) = item.node {\n+            if let hir::ViewPathList(ref prefix, ref list) = vpath.node {\n                 for pid in list {\n                     match pid.node {\n-                        ast::PathListIdent { id, name, .. } => {\n+                        hir::PathListIdent { id, name, .. } => {\n                             debug!(\"privacy - ident item {}\", id);\n                             self.check_path(pid.span, id, name.name);\n                         }\n-                        ast::PathListMod { id, .. } => {\n+                        hir::PathListMod { id, .. } => {\n                             debug!(\"privacy - mod item {}\", id);\n                             let name = prefix.segments.last().unwrap().identifier.name;\n                             self.check_path(pid.span, id, name);\n@@ -877,31 +878,31 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         self.curitem = orig_curitem;\n     }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            ast::ExprField(ref base, ident) => {\n+            hir::ExprField(ref base, ident) => {\n                 if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n                     self.check_field(expr.span,\n                                      def,\n                                      def.struct_variant(),\n                                      NamedField(ident.node.name));\n                 }\n             }\n-            ast::ExprTupField(ref base, idx) => {\n+            hir::ExprTupField(ref base, idx) => {\n                 if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n                     self.check_field(expr.span,\n                                      def,\n                                      def.struct_variant(),\n                                      UnnamedField(idx.node));\n                 }\n             }\n-            ast::ExprMethodCall(ident, _, _) => {\n+            hir::ExprMethodCall(ident, _, _) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method = self.tcx.tables.borrow().method_map[&method_call];\n                 debug!(\"(privacy checking) checking impl method\");\n                 self.check_method(expr.span, method.def_id, ident.node.name);\n             }\n-            ast::ExprStruct(..) => {\n+            hir::ExprStruct(..) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.resolve_expr(expr));\n                 // RFC 736: ensure all unmentioned fields are visible.\n@@ -911,7 +912,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     self.check_field(expr.span, adt, variant, NamedField(field.name));\n                 }\n             }\n-            ast::ExprPath(..) => {\n+            hir::ExprPath(..) => {\n \n                 if let def::DefStruct(_) = self.tcx.resolve_expr(expr) {\n                     let expr_ty = self.tcx.expr_ty(expr);\n@@ -922,10 +923,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != ast::Public && (\n+                        f.vis != hir::Public && (\n                             !f.did.is_local() ||\n                                     !self.private_accessible(f.did.node))\n                         });\n+\n                     if any_priv {\n                         self.tcx.sess.span_err(expr.span,\n                                                \"cannot invoke tuple struct constructor \\\n@@ -939,15 +941,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         visit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pattern: &ast::Pat) {\n+    fn visit_pat(&mut self, pattern: &hir::Pat) {\n         // Foreign functions do not have their patterns mapped in the def_map,\n         // and there's nothing really relevant there anyway, so don't bother\n         // checking privacy. If you can name the type then you can pass it to an\n         // external C function anyway.\n         if self.in_foreign { return }\n \n         match pattern.node {\n-            ast::PatStruct(_, ref fields, _) => {\n+            hir::PatStruct(_, ref fields, _) => {\n                 let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n                 let def = self.tcx.def_map.borrow().get(&pattern.id).unwrap().full_def();\n                 let variant = adt.variant_of_def(def);\n@@ -959,11 +961,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n-            ast::PatEnum(_, Some(ref fields)) => {\n+            hir::PatEnum(_, Some(ref fields)) => {\n                 match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(def, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n-                            if let ast::PatWild(..) = field.node {\n+                            if let hir::PatWild(..) = field.node {\n                                 continue\n                             }\n                             self.check_field(field.span,\n@@ -985,13 +987,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         visit::walk_pat(self, pattern);\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n         self.in_foreign = true;\n         visit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n     }\n \n-    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         self.check_path(path.span, id, path.segments.last().unwrap().identifier.name);\n         visit::walk_path(self, path);\n     }\n@@ -1007,7 +1009,7 @@ struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         if self.in_fn {\n             self.check_all_inherited(item);\n         } else {\n@@ -1016,15 +1018,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n \n         let in_fn = self.in_fn;\n         let orig_in_fn = replace(&mut self.in_fn, match item.node {\n-            ast::ItemMod(..) => false, // modules turn privacy back on\n+            hir::ItemMod(..) => false, // modules turn privacy back on\n             _ => in_fn,           // otherwise we inherit\n         });\n         visit::walk_item(self, item);\n         self.in_fn = orig_in_fn;\n     }\n \n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, _: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, _: ast::NodeId) {\n         // This catches both functions and methods\n         let orig_in_fn = replace(&mut self.in_fn, true);\n         visit::walk_fn(self, fk, fd, b, s);\n@@ -1037,10 +1039,10 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n     /// later on down the road...\n-    fn check_sane_privacy(&self, item: &ast::Item) {\n+    fn check_sane_privacy(&self, item: &hir::Item) {\n         let tcx = self.tcx;\n-        let check_inherited = |sp: Span, vis: ast::Visibility, note: &str| {\n-            if vis != ast::Inherited {\n+        let check_inherited = |sp: Span, vis: hir::Visibility, note: &str| {\n+            if vis != hir::Inherited {\n                 tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n                 if !note.is_empty() {\n                     tcx.sess.span_note(sp, note);\n@@ -1050,7 +1052,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n         match item.node {\n             // implementations of traits don't need visibility qualifiers because\n             // that's controlled by having the trait in scope.\n-            ast::ItemImpl(_, _, _, Some(..), _, ref impl_items) => {\n+            hir::ItemImpl(_, _, _, Some(..), _, ref impl_items) => {\n                 check_inherited(item.span, item.vis,\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n@@ -1059,84 +1061,83 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemImpl(..) => {\n+            hir::ItemImpl(..) => {\n                 check_inherited(item.span, item.vis,\n                                 \"place qualifiers on individual methods instead\");\n             }\n-            ast::ItemForeignMod(..) => {\n+            hir::ItemForeignMod(..) => {\n                 check_inherited(item.span, item.vis,\n                                 \"place qualifiers on individual functions \\\n                                  instead\");\n             }\n \n-            ast::ItemEnum(ref def, _) => {\n+            hir::ItemEnum(ref def, _) => {\n                 for v in &def.variants {\n                     match v.node.vis {\n-                        ast::Public => {\n-                            if item.vis == ast::Public {\n+                        hir::Public => {\n+                            if item.vis == hir::Public {\n                                 tcx.sess.span_err(v.span, \"unnecessary `pub` \\\n                                                            visibility\");\n                             }\n                         }\n-                        ast::Inherited => {}\n+                        hir::Inherited => {}\n                     }\n                 }\n             }\n \n-            ast::ItemTrait(..) | ast::ItemDefaultImpl(..) |\n-            ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n-            ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n-            ast::ItemExternCrate(_) | ast::ItemUse(_) | ast::ItemMac(..) => {}\n+            hir::ItemTrait(..) | hir::ItemDefaultImpl(..) |\n+            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemStruct(..) |\n+            hir::ItemFn(..) | hir::ItemMod(..) | hir::ItemTy(..) |\n+            hir::ItemExternCrate(_) | hir::ItemUse(_) => {}\n         }\n     }\n \n     /// When inside of something like a function or a method, visibility has no\n     /// control over anything so this forbids any mention of any visibility\n-    fn check_all_inherited(&self, item: &ast::Item) {\n+    fn check_all_inherited(&self, item: &hir::Item) {\n         let tcx = self.tcx;\n-        fn check_inherited(tcx: &ty::ctxt, sp: Span, vis: ast::Visibility) {\n-            if vis != ast::Inherited {\n+        fn check_inherited(tcx: &ty::ctxt, sp: Span, vis: hir::Visibility) {\n+            if vis != hir::Inherited {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n         }\n-        let check_struct = |def: &ast::StructDef| {\n+        let check_struct = |def: &hir::StructDef| {\n             for f in &def.fields {\n                match f.node.kind {\n-                    ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n-                    ast::UnnamedField(..) => {}\n+                    hir::NamedField(_, p) => check_inherited(tcx, f.span, p),\n+                    hir::UnnamedField(..) => {}\n                 }\n             }\n         };\n         check_inherited(tcx, item.span, item.vis);\n         match item.node {\n-            ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n+            hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     match impl_item.node {\n-                        ast::MethodImplItem(..) => {\n+                        hir::MethodImplItem(..) => {\n                             check_inherited(tcx, impl_item.span, impl_item.vis);\n                         }\n                         _ => {}\n                     }\n                 }\n             }\n-            ast::ItemForeignMod(ref fm) => {\n+            hir::ItemForeignMod(ref fm) => {\n                 for i in &fm.items {\n                     check_inherited(tcx, i.span, i.vis);\n                 }\n             }\n-            ast::ItemEnum(ref def, _) => {\n+            hir::ItemEnum(ref def, _) => {\n                 for v in &def.variants {\n                     check_inherited(tcx, v.span, v.node.vis);\n                 }\n             }\n \n-            ast::ItemStruct(ref def, _) => check_struct(&**def),\n+            hir::ItemStruct(ref def, _) => check_struct(&**def),\n \n-            ast::ItemExternCrate(_) | ast::ItemUse(_) |\n-            ast::ItemTrait(..) | ast::ItemDefaultImpl(..) |\n-            ast::ItemStatic(..) | ast::ItemConst(..) |\n-            ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n-            ast::ItemMac(..) => {}\n+            hir::ItemExternCrate(_) | hir::ItemUse(_) |\n+            hir::ItemTrait(..) | hir::ItemDefaultImpl(..) |\n+            hir::ItemStatic(..) | hir::ItemConst(..) |\n+            hir::ItemFn(..) | hir::ItemMod(..) | hir::ItemTy(..) => {}\n         }\n     }\n }\n@@ -1175,7 +1176,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n         // .. and it corresponds to a private type in the AST (this returns\n         // None for type parameters)\n         match self.tcx.map.find(did.node) {\n-            Some(ast_map::NodeItem(ref item)) => item.vis != ast::Public,\n+            Some(ast_map::NodeItem(ref item)) => item.vis != hir::Public,\n             Some(_) | None => false,\n         }\n     }\n@@ -1187,8 +1188,8 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_ty_param_bound(&self,\n-                            ty_param_bound: &ast::TyParamBound) {\n-        if let ast::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n+                            ty_param_bound: &hir::TyParamBound) {\n+        if let hir::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n             if !self.tcx.sess.features.borrow().visible_private_types &&\n                 self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n                     let span = trait_ref.trait_ref.path.span;\n@@ -1198,14 +1199,14 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn item_is_public(&self, id: &ast::NodeId, vis: ast::Visibility) -> bool {\n-        self.exported_items.contains(id) || vis == ast::Public\n+    fn item_is_public(&self, id: &ast::NodeId, vis: hir::Visibility) -> bool {\n+        self.exported_items.contains(id) || vis == hir::Public\n     }\n }\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty) {\n-        if let ast::TyPath(..) = ty.node {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyPath(..) = ty.node {\n             if self.inner.path_is_private_type(ty.id) {\n                 self.contains_private = true;\n                 // found what we're looking for so let's stop\n@@ -1220,21 +1221,21 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 't\n     }\n \n     // don't want to recurse into [, .. expr]\n-    fn visit_expr(&mut self, _: &ast::Expr) {}\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need\n             // to check internals.\n-            ast::ItemMod(_) => {}\n+            hir::ItemMod(_) => {}\n \n             // An `extern {}` doesn't introduce a new privacy\n             // namespace (the contents have their own privacies).\n-            ast::ItemForeignMod(_) => {}\n+            hir::ItemForeignMod(_) => {}\n \n-            ast::ItemTrait(_, _, ref bounds, _) => {\n+            hir::ItemTrait(_, _, ref bounds, _) => {\n                 if !self.trait_is_public(item.id) {\n                     return\n                 }\n@@ -1249,7 +1250,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            ast::ItemImpl(_, _, ref g, ref trait_ref, ref self_, ref impl_items) => {\n+            hir::ItemImpl(_, _, ref g, ref trait_ref, ref self_, ref impl_items) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -1293,12 +1294,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     impl_items.iter()\n                               .any(|impl_item| {\n                                   match impl_item.node {\n-                                      ast::ConstImplItem(..) |\n-                                      ast::MethodImplItem(..) => {\n+                                      hir::ConstImplItem(..) |\n+                                      hir::MethodImplItem(..) => {\n                                           self.exported_items.contains(&impl_item.id)\n                                       }\n-                                      ast::TypeImplItem(_) |\n-                                      ast::MacImplItem(_) => false,\n+                                      hir::TypeImplItem(_) => false,\n                                   }\n                               });\n \n@@ -1317,13 +1317,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n                                 match impl_item.node {\n-                                    ast::ConstImplItem(..) |\n-                                    ast::MethodImplItem(..)\n+                                    hir::ConstImplItem(..) |\n+                                    hir::MethodImplItem(..)\n                                         if self.item_is_public(&impl_item.id, impl_item.vis) =>\n                                     {\n                                         visit::walk_impl_item(self, impl_item)\n                                     }\n-                                    ast::TypeImplItem(..) => {\n+                                    hir::TypeImplItem(..) => {\n                                         visit::walk_impl_item(self, impl_item)\n                                     }\n                                     _ => {}\n@@ -1348,7 +1348,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n-                                if let ast::TypeImplItem(ref ty) = impl_item.node {\n+                                if let hir::TypeImplItem(ref ty) = impl_item.node {\n                                     self.visit_ty(ty);\n                                 }\n                             }\n@@ -1360,14 +1360,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items {\n                         match impl_item.node {\n-                            ast::ConstImplItem(..) => {\n+                            hir::ConstImplItem(..) => {\n                                 if self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n                                     visit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n-                            ast::MethodImplItem(ref sig, _) => {\n-                                if sig.explicit_self.node == ast::SelfStatic &&\n+                            hir::MethodImplItem(ref sig, _) => {\n+                                if sig.explicit_self.node == hir::SelfStatic &&\n                                       self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n                                     visit::walk_impl_item(self, impl_item);\n@@ -1385,7 +1385,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n             // `type ... = ...;` can contain private types, because\n             // we're introducing a new name.\n-            ast::ItemTy(..) => return,\n+            hir::ItemTy(..) => return,\n \n             // not at all public, so we don't care\n             _ if !self.item_is_public(&item.id, item.vis) => {\n@@ -1403,36 +1403,36 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n         visit::walk_item(self, item);\n     }\n \n-    fn visit_generics(&mut self, generics: &ast::Generics) {\n+    fn visit_generics(&mut self, generics: &hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             for bound in ty_param.bounds.iter() {\n                 self.check_ty_param_bound(bound)\n             }\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                     for bound in bound_pred.bounds.iter() {\n                         self.check_ty_param_bound(bound)\n                     }\n                 }\n-                &ast::WherePredicate::RegionPredicate(_) => {}\n-                &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n+                &hir::WherePredicate::RegionPredicate(_) => {}\n+                &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n                     self.visit_ty(&*eq_pred.ty);\n                 }\n             }\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n         if self.exported_items.contains(&item.id) {\n             visit::walk_foreign_item(self, item)\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &hir::Ty) {\n         debug!(\"VisiblePrivateTypesVisitor checking ty {:?}\", t);\n-        if let ast::TyPath(_, ref p) = t.node {\n+        if let hir::TyPath(_, ref p) = t.node {\n             if !self.tcx.sess.features.borrow().visible_private_types &&\n                 self.path_is_private_type(t.id) {\n                 self.tcx.sess.span_err(p.span, \"private type in exported type signature\");\n@@ -1441,17 +1441,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n         visit::walk_ty(self, t)\n     }\n \n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n+    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics) {\n         if self.exported_items.contains(&v.node.id) {\n             self.in_variant = true;\n             visit::walk_variant(self, v, g);\n             self.in_variant = false;\n         }\n     }\n \n-    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+    fn visit_struct_field(&mut self, s: &hir::StructField) {\n         match s.node.kind {\n-            ast::NamedField(_, vis) if vis == ast::Public || self.in_variant => {\n+            hir::NamedField(_, vis) if vis == hir::Public || self.in_variant => {\n                 visit::walk_struct_field(self, s);\n             }\n             _ => {}\n@@ -1463,8 +1463,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n-    fn visit_block(&mut self, _: &ast::Block) {}\n-    fn visit_expr(&mut self, _: &ast::Expr) {}\n+    fn visit_block(&mut self, _: &hir::Block) {}\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n pub fn check_crate(tcx: &ty::ctxt,"}, {"sha": "6e72e51d9fefa3370180a4b1fc63184227ec872a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -36,25 +36,25 @@ use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n \n-use syntax::ast::{Block, Crate};\n-use syntax::ast::{DeclItem};\n-use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n-use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n-use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use syntax::ast::{Name, NamedField, NodeId};\n-use syntax::ast::{PathListIdent, PathListMod, Public};\n-use syntax::ast::StmtDecl;\n-use syntax::ast::StructVariantKind;\n-use syntax::ast::TupleVariantKind;\n-use syntax::ast::UnnamedField;\n-use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ast::Visibility;\n-use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::ast::{Name, NodeId};\n use syntax::parse::token::special_idents;\n use syntax::codemap::{Span, DUMMY_SP};\n-use syntax::visit::{self, Visitor};\n+\n+use rustc_front::hir;\n+use rustc_front::hir::{Block, Crate, DeclItem};\n+use rustc_front::hir::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n+use rustc_front::hir::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n+use rustc_front::hir::{ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaultImpl};\n+use rustc_front::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n+use rustc_front::hir::{NamedField, PathListIdent, PathListMod, Public};\n+use rustc_front::hir::StmtDecl;\n+use rustc_front::hir::StructVariantKind;\n+use rustc_front::hir::TupleVariantKind;\n+use rustc_front::hir::UnnamedField;\n+use rustc_front::hir::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use rustc_front::hir::Visibility;\n+use rustc_front::attr::AttrMetaMethods;\n+use rustc_front::visit::{self, Visitor};\n \n use std::mem::replace;\n use std::ops::{Deref, DerefMut};\n@@ -107,7 +107,7 @@ impl<'a, 'b:'a, 'tcx:'b> DerefMut for GraphBuilder<'a, 'b, 'tcx> {\n \n impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Constructs the reduced graph for the entire crate.\n-    fn build_reduced_graph(self, krate: &ast::Crate) {\n+    fn build_reduced_graph(self, krate: &hir::Crate) {\n         let parent = self.graph_root.get_module();\n         let mut visitor = BuildReducedGraphVisitor {\n             builder: self,\n@@ -265,7 +265,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn build_reduced_graph_for_item(&mut self, item: &Item, parent: &Rc<Module>) -> Rc<Module> {\n         let name = item.ident.name;\n         let sp = item.span;\n-        let is_public = item.vis == ast::Public;\n+        let is_public = item.vis == hir::Public;\n         let modifiers = if is_public {\n             DefModifiers::PUBLIC\n         } else {\n@@ -426,7 +426,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             // These items live in the value namespace.\n             ItemStatic(_, m, _) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n-                let mutbl = m == ast::MutMutable;\n+                let mutbl = m == hir::MutMutable;\n \n                 name_bindings.define_value(DefStatic(DefId::local(item.id), mutbl), sp, modifiers);\n                 parent.clone()\n@@ -545,17 +545,17 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                         trait_item.span);\n \n                     match trait_item.node {\n-                        ast::ConstTraitItem(..) => {\n+                        hir::ConstTraitItem(..) => {\n                             let def = DefAssociatedConst(DefId::local(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n-                        ast::MethodTraitItem(..) => {\n+                        hir::MethodTraitItem(..) => {\n                             let def = DefMethod(DefId::local(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n-                        ast::TypeTraitItem(..) => {\n+                        hir::TypeTraitItem(..) => {\n                             let def = DefAssociatedTy(DefId::local(item.id),\n                                                       DefId::local(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n@@ -570,7 +570,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n                 parent.clone()\n             }\n-            ItemMac(..) => parent.clone()\n         }\n     }\n \n@@ -608,7 +607,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             foreign_item: &ForeignItem,\n                                             parent: &Rc<Module>) {\n         let name = foreign_item.ident.name;\n-        let is_public = foreign_item.vis == ast::Public;\n+        let is_public = foreign_item.vis == hir::Public;\n         let modifiers = if is_public {\n             DefModifiers::PUBLIC\n         } else {\n@@ -660,7 +659,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         debug!(\"(building reduced graph for \\\n                 external crate) building external def {}, priv {:?}\",\n                final_ident, vis);\n-        let is_public = vis == ast::Public;\n+        let is_public = vis == hir::Public;\n         let modifiers = if is_public {\n             DefModifiers::PUBLIC\n         } else {\n@@ -1001,7 +1000,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n }\n \n-pub fn build_reduced_graph(resolver: &mut Resolver, krate: &ast::Crate) {\n+pub fn build_reduced_graph(resolver: &mut Resolver, krate: &hir::Crate) {\n     GraphBuilder {\n         resolver: resolver\n     }.build_reduced_graph(krate);"}, {"sha": "4ebc1093a0b6bec8799fc637bd377c6e70ab8b22", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -25,9 +25,11 @@ use Namespace::{TypeNS, ValueNS};\n use rustc::lint;\n use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n use syntax::ast;\n-use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::codemap::{Span, DUMMY_SP};\n-use syntax::visit::{self, Visitor};\n+\n+use rustc_front::hir;\n+use rustc_front::hir::{ViewPathGlob, ViewPathList, ViewPathSimple};\n+use rustc_front::visit::{self, Visitor};\n \n struct UnusedImportCheckVisitor<'a, 'b:'a, 'tcx:'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>\n@@ -110,18 +112,18 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+    fn visit_item(&mut self, item: &hir::Item) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if item.vis == ast::Public || item.span == DUMMY_SP {\n+        if item.vis == hir::Public || item.span == DUMMY_SP {\n             visit::walk_item(self, item);\n             return;\n         }\n \n         match item.node {\n-            ast::ItemExternCrate(_) => {\n+            hir::ItemExternCrate(_) => {\n                 if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     if !self.used_crates.contains(&crate_num) {\n                         self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n@@ -131,7 +133,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                     }\n                 }\n             },\n-            ast::ItemUse(ref p) => {\n+            hir::ItemUse(ref p) => {\n                 match p.node {\n                     ViewPathSimple(_, _) => {\n                         self.finalize_import(item.id, p.span)\n@@ -161,7 +163,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     }\n }\n \n-pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n+pub fn check_crate(resolver: &mut Resolver, krate: &hir::Crate) {\n     let mut visitor = UnusedImportCheckVisitor { resolver: resolver };\n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "fee7d4d1d44162f45446998c4c847c18a1a67d60", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -30,6 +30,7 @@\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n+extern crate rustc_front;\n \n extern crate rustc;\n \n@@ -50,7 +51,7 @@ use self::ParentLink::*;\n use self::ModuleKind::*;\n use self::FallbackChecks::*;\n \n-use rustc::ast_map;\n+use rustc::front::map as hir_map;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::metadata::csearch;\n@@ -64,31 +65,34 @@ use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n-use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block};\n-use syntax::ast::{ConstImplItem, Crate, CrateNum};\n-use syntax::ast::{Expr, ExprAgain, ExprBreak, ExprField};\n-use syntax::ast::{ExprLoop, ExprWhile, ExprMethodCall};\n-use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n-use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n-use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n-use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use syntax::ast::{Local, MethodImplItem, Name, NodeId};\n-use syntax::ast::{Pat, PatEnum, PatIdent, PatLit, PatQPath};\n-use syntax::ast::{PatRange, PatStruct, Path, PrimTy};\n-use syntax::ast::{TraitRef, Ty, TyBool, TyChar, TyF32};\n-use syntax::ast::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt};\n-use syntax::ast::{TyPath, TyPtr};\n-use syntax::ast::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n-use syntax::ast::TypeImplItem;\n use syntax::ast;\n-use syntax::ast_util::{walk_pat};\n+use syntax::ast::{Ident, Name, NodeId, CrateNum};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{self, special_names, special_idents};\n use syntax::ptr::P;\n use syntax::codemap::{self, Span, Pos};\n-use syntax::visit::{self, FnKind, Visitor};\n+\n+use rustc_front::visit::{self, FnKind, Visitor};\n+use rustc_front::hir;\n+use rustc_front::hir::{Arm, BindByRef, BindByValue, BindingMode, Block};\n+use rustc_front::hir::{ConstImplItem, Crate};\n+use rustc_front::hir::{Expr, ExprAgain, ExprBreak, ExprField};\n+use rustc_front::hir::{ExprLoop, ExprWhile, ExprMethodCall};\n+use rustc_front::hir::{ExprPath, ExprStruct, FnDecl};\n+use rustc_front::hir::{ForeignItemFn, ForeignItemStatic, Generics};\n+use rustc_front::hir::{ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n+use rustc_front::hir::{ItemFn, ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaultImpl};\n+use rustc_front::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n+use rustc_front::hir::{Local, MethodImplItem};\n+use rustc_front::hir::{Pat, PatEnum, PatIdent, PatLit, PatQPath};\n+use rustc_front::hir::{PatRange, PatStruct, Path, PrimTy};\n+use rustc_front::hir::{TraitRef, Ty, TyBool, TyChar, TyF32};\n+use rustc_front::hir::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt};\n+use rustc_front::hir::{TyPath, TyPtr};\n+use rustc_front::hir::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n+use rustc_front::hir::TypeImplItem;\n+use rustc_front::util::walk_pat;\n \n use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -457,22 +461,22 @@ enum NameDefinition {\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        execute_callback!(ast_map::Node::NodeItem(item), self);\n+        execute_callback!(hir_map::Node::NodeItem(item), self);\n         self.resolve_item(item);\n     }\n     fn visit_arm(&mut self, arm: &Arm) {\n         self.resolve_arm(arm);\n     }\n     fn visit_block(&mut self, block: &Block) {\n-        execute_callback!(ast_map::Node::NodeBlock(block), self);\n+        execute_callback!(hir_map::Node::NodeBlock(block), self);\n         self.resolve_block(block);\n     }\n     fn visit_expr(&mut self, expr: &Expr) {\n-        execute_callback!(ast_map::Node::NodeExpr(expr), self);\n+        execute_callback!(hir_map::Node::NodeExpr(expr), self);\n         self.resolve_expr(expr);\n     }\n     fn visit_local(&mut self, local: &Local) {\n-        execute_callback!(ast_map::Node::NodeLocal(&*local.pat), self);\n+        execute_callback!(hir_map::Node::NodeLocal(&*local.pat), self);\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &Ty) {\n@@ -482,16 +486,16 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         self.resolve_generics(generics);\n     }\n     fn visit_poly_trait_ref(&mut self,\n-                            tref: &ast::PolyTraitRef,\n-                            m: &ast::TraitBoundModifier) {\n+                            tref: &hir::PolyTraitRef,\n+                            m: &hir::TraitBoundModifier) {\n         match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0) {\n             Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n             Err(_) => { /* error already reported */ }\n         }\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n-    fn visit_variant(&mut self, variant: &ast::Variant, generics: &Generics) {\n-        execute_callback!(ast_map::Node::NodeVariant(variant), self);\n+    fn visit_variant(&mut self, variant: &hir::Variant, generics: &Generics) {\n+        execute_callback!(hir_map::Node::NodeVariant(variant), self);\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n             // resolve the discriminator expr as a constant\n             self.with_constant_rib(|this| {\n@@ -501,21 +505,21 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n \n         // `visit::walk_variant` without the discriminant expression.\n         match variant.node.kind {\n-            ast::TupleVariantKind(ref variant_arguments) => {\n+            hir::TupleVariantKind(ref variant_arguments) => {\n                 for variant_argument in variant_arguments {\n                     self.visit_ty(&*variant_argument.ty);\n                 }\n             }\n-            ast::StructVariantKind(ref struct_definition) => {\n+            hir::StructVariantKind(ref struct_definition) => {\n                 self.visit_struct_def(&**struct_definition,\n                                       variant.node.name,\n                                       generics,\n                                       variant.node.id);\n             }\n         }\n     }\n-    fn visit_foreign_item(&mut self, foreign_item: &ast::ForeignItem) {\n-        execute_callback!(ast_map::Node::NodeForeignItem(foreign_item), self);\n+    fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem) {\n+        execute_callback!(hir_map::Node::NodeForeignItem(foreign_item), self);\n         let type_parameters = match foreign_item.node {\n             ForeignItemFn(_, ref generics) => {\n                 HasTypeParameters(generics, FnSpace, ItemRibKind)\n@@ -1113,7 +1117,7 @@ impl PrimitiveTypeTable {\n pub struct Resolver<'a, 'tcx:'a> {\n     session: &'a Session,\n \n-    ast_map: &'a ast_map::Map<'tcx>,\n+    ast_map: &'a hir_map::Map<'tcx>,\n \n     graph_root: NameBindings,\n \n@@ -1167,7 +1171,7 @@ pub struct Resolver<'a, 'tcx:'a> {\n     used_crates: HashSet<CrateNum>,\n \n     // Callback function for intercepting walks\n-    callback: Option<Box<Fn(ast_map::Node, &mut bool) -> bool>>,\n+    callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>,\n     // The intention is that the callback modifies this flag.\n     // Once set, the resolver falls out of the walk, preserving the ribs.\n     resolved: bool,\n@@ -1182,7 +1186,7 @@ enum FallbackChecks {\n \n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn new(session: &'a Session,\n-           ast_map: &'a ast_map::Map<'tcx>,\n+           ast_map: &'a hir_map::Map<'tcx>,\n            crate_span: Span,\n            make_glob_map: MakeGlobMap) -> Resolver<'a, 'tcx> {\n         let graph_root = NameBindings::new();\n@@ -2094,7 +2098,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         None\n     }\n \n-    fn resolve_crate(&mut self, krate: &ast::Crate) {\n+    fn resolve_crate(&mut self, krate: &hir::Crate) {\n         debug!(\"(resolving crate) starting\");\n \n         visit::walk_crate(self, krate);\n@@ -2161,7 +2165,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                         for trait_item in trait_items {\n                             match trait_item.node {\n-                                ast::ConstTraitItem(_, ref default) => {\n+                                hir::ConstTraitItem(_, ref default) => {\n                                     // Only impose the restrictions of\n                                     // ConstRibKind if there's an actual constant\n                                     // expression in a provided default.\n@@ -2173,7 +2177,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         visit::walk_trait_item(this, trait_item)\n                                     }\n                                 }\n-                                ast::MethodTraitItem(ref sig, _) => {\n+                                hir::MethodTraitItem(ref sig, _) => {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n@@ -2182,7 +2186,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         visit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n-                                ast::TypeTraitItem(..) => {\n+                                hir::TypeTraitItem(..) => {\n                                     this.check_if_primitive_type_name(trait_item.ident.name,\n                                                                       trait_item.span);\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n@@ -2209,7 +2213,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ItemUse(ref view_path) => {\n                 // check for imports shadowing primitive types\n-                if let ast::ViewPathSimple(ident, _) = view_path.node {\n+                if let hir::ViewPathSimple(ident, _) = view_path.node {\n                     match self.def_map.borrow().get(&item.id).map(|d| d.full_def()) {\n                         Some(DefTy(..)) | Some(DefStruct(..)) | Some(DefTrait(..)) | None => {\n                             self.check_if_primitive_type_name(ident.name, item.span);\n@@ -2219,7 +2223,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            ItemExternCrate(_) | ItemMac(..) => {\n+            ItemExternCrate(_) => {\n                 // do nothing, these are just around to be encoded\n             }\n         }\n@@ -2363,9 +2367,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(_) |\n-                &ast::WherePredicate::RegionPredicate(_) => {}\n-                &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n+                &hir::WherePredicate::BoundPredicate(_) |\n+                &hir::WherePredicate::RegionPredicate(_) => {}\n+                &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n                     let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true);\n                     if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n@@ -2488,7 +2492,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                                     this.visit_ty(ty);\n                                 }\n-                                ast::MacImplItem(_) => {}\n                             }\n                         }\n                     });\n@@ -2618,8 +2621,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Check for imports appearing after non-item statements.\n         let mut found_non_item = false;\n         for statement in &block.stmts {\n-            if let ast::StmtDecl(ref declaration, _) = statement.node {\n-                if let ast::DeclItem(ref i) = declaration.node {\n+            if let hir::StmtDecl(ref declaration, _) = statement.node {\n+                if let hir::DeclItem(ref i) = declaration.node {\n                     match i.node {\n                         ItemExternCrate(_) | ItemUse(_) if found_non_item => {\n                             span_err!(self.session, i.span, E0154,\n@@ -3039,7 +3042,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Handles paths that may refer to associated items\n     fn resolve_possibly_assoc_item(&mut self,\n                                    id: NodeId,\n-                                   maybe_qself: Option<&ast::QSelf>,\n+                                   maybe_qself: Option<&hir::QSelf>,\n                                    path: &Path,\n                                    namespace: Namespace,\n                                    check_ribs: bool)\n@@ -3228,7 +3231,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n                                     span: Span,\n-                                    segments: &[ast::PathSegment],\n+                                    segments: &[hir::PathSegment],\n                                     namespace: Namespace)\n                                     -> Option<(Def, LastPrivate)> {\n         let module_path = segments.split_last().unwrap().1.iter()\n@@ -3285,7 +3288,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// import resolution.\n     fn resolve_crate_relative_path(&mut self,\n                                    span: Span,\n-                                   segments: &[ast::PathSegment],\n+                                   segments: &[hir::PathSegment],\n                                    namespace: Namespace)\n                                        -> Option<(Def, LastPrivate)> {\n         let module_path = segments.split_last().unwrap().1.iter()\n@@ -3469,17 +3472,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         fn is_static_method(this: &Resolver, did: DefId) -> bool {\n             if did.is_local() {\n                 let sig = match this.ast_map.get(did.node) {\n-                    ast_map::NodeTraitItem(trait_item) => match trait_item.node {\n-                        ast::MethodTraitItem(ref sig, _) => sig,\n+                    hir_map::NodeTraitItem(trait_item) => match trait_item.node {\n+                        hir::MethodTraitItem(ref sig, _) => sig,\n                         _ => return false\n                     },\n-                    ast_map::NodeImplItem(impl_item) => match impl_item.node {\n-                        ast::MethodImplItem(ref sig, _) => sig,\n+                    hir_map::NodeImplItem(impl_item) => match impl_item.node {\n+                        hir::MethodImplItem(ref sig, _) => sig,\n                         _ => return false\n                     },\n                     _ => return false\n                 };\n-                sig.explicit_self.node == ast::SelfStatic\n+                sig.explicit_self.node == hir::SelfStatic\n             } else {\n                 csearch::is_static_method(&this.session.cstore, did)\n             }\n@@ -4024,7 +4027,7 @@ pub enum MakeGlobMap {\n \n /// Entry point to crate resolution.\n pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n-                               ast_map: &'a ast_map::Map<'tcx>,\n+                               ast_map: &'a hir_map::Map<'tcx>,\n                                make_glob_map: MakeGlobMap)\n                                -> CrateMap {\n     let krate = ast_map.krate();\n@@ -4058,10 +4061,10 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n /// calls to be made with the correct scope info. The node in the\n /// callback corresponds to the current node in the walk.\n pub fn create_resolver<'a, 'tcx>(session: &'a Session,\n-                                 ast_map: &'a ast_map::Map<'tcx>,\n+                                 ast_map: &'a hir_map::Map<'tcx>,\n                                  krate: &'a Crate,\n                                  make_glob_map: MakeGlobMap,\n-                                 callback: Option<Box<Fn(ast_map::Node, &mut bool) -> bool>>)\n+                                 callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>)\n                                  -> Resolver<'a, 'tcx> {\n     let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n "}, {"sha": "d5486e84fc43123fc8bdbe99f94931f1e581af71", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -25,7 +25,7 @@ use metadata::loader::METADATA_FILENAME;\n use metadata::{encoder, cstore, filesearch, csearch, creader};\n use middle::dependency_format::Linkage;\n use middle::ty::{self, Ty};\n-use rustc::ast_map::{PathElem, PathElems, PathName};\n+use rustc::front::map::{PathElem, PathElems, PathName};\n use trans::{CrateContext, CrateTranslation, gensym_name};\n use util::common::time;\n use util::sha2::{Digest, Sha256};\n@@ -43,9 +43,12 @@ use std::str;\n use flate;\n use serialize::hex::ToHex;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::attr::AttrMetaMethods;\n+use rustc_front::attr::AttrMetaMethods as FrontAttrMetaMethods;\n+\n+use rustc_front::hir;\n \n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n // Version 1\n@@ -178,7 +181,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n     \"rust_out\".to_string()\n }\n \n-pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n+pub fn build_link_meta(sess: &Session, krate: &hir::Crate,\n                        name: String) -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name,"}, {"sha": "3a122c7b41ce8e8a89411302f28a3c14a9910c3e", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -53,6 +53,7 @@ extern crate graphviz;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n+extern crate rustc_front;\n extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;"}, {"sha": "9960d022d5300c535086b27743b32827ce8e2cad", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -47,6 +47,8 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n \n+use rustc_front::lowering::lower_expr;\n+\n use super::span_utils::SpanUtils;\n use super::recorder::{Recorder, FmtStrs};\n \n@@ -1074,8 +1076,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 visit::walk_expr(self, ex);\n             }\n             ast::ExprStruct(ref path, ref fields, ref base) => {\n-                let adt = self.tcx.expr_ty(ex).ty_adt_def().unwrap();\n-                let def = self.tcx.resolve_expr(ex);\n+                let hir_expr = lower_expr(ex);\n+                let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n+                let def = self.tcx.resolve_expr(&hir_expr);\n                 self.process_struct_lit(ex,\n                                         path,\n                                         fields,\n@@ -1106,7 +1109,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let ty = &self.tcx.expr_ty_adjusted(&**sub_ex).sty;\n+                let hir_node = self.tcx.map.expect_expr(sub_ex.id);\n+                let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);"}, {"sha": "42a7ea0a6935328162d2bc1991c8c7a241a6cdba", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb", "patch": "@@ -16,9 +16,11 @@ use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n-use rustc::ast_map::NodeItem;\n+use rustc_front;\n+use rustc::front::map::NodeItem;\n+use rustc_front::hir;\n \n-use syntax::{attr};\n+use syntax::attr;\n use syntax::ast::{self, NodeId};\n use syntax::ast_util;\n use syntax::codemap::*;\n@@ -356,9 +358,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     match item.node {\n-                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n+                        hir::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n-                            result.push_str(&ty_to_string(&**ty));\n+                            result.push_str(&rustc_front::print::pprust::ty_to_string(&**ty));\n \n                             match self.tcx.trait_of_item(DefId::local(id)) {\n                                 Some(def_id) => {\n@@ -446,7 +448,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n-                let ty = &self.tcx.expr_ty_adjusted(&sub_ex).sty;\n+                let hir_node = self.tcx.map.expect_expr(sub_ex.id);\n+                let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n@@ -465,7 +468,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(ref path, _, _) => {\n-                let ty = &self.tcx.expr_ty_adjusted(expr).sty;\n+                let hir_node = self.tcx.map.expect_expr(expr.id);\n+                let ty = &self.tcx.expr_ty_adjusted(hir_node).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n@@ -605,7 +609,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n \n         let trait_item = self.tcx.map.expect_trait_item(def_id.node);\n-        if let ast::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n+        if let hir::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n             true\n         } else {\n             false\n@@ -705,9 +709,9 @@ impl<'v> Visitor<'v> for PathCollector {\n }\n \n pub fn process_crate(tcx: &ty::ctxt,\n+                     krate: &ast::Crate,\n                      analysis: &ty::CrateAnalysis,\n                      odir: Option<&Path>) {\n-    let krate = tcx.map.krate();\n     if generated_code(krate.span) {\n         return;\n     }"}, {"sha": "05a3e81839e088a86f07077e025ed7d5498f8849", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "9b630037fe8264df5f0616d478f8c30a8175091c", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "891baca75a860f519aabe852679b926998a5b00c", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "a1f4ed5c20d3250ffd73970e199455ce1afb793c", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "f8b60ebdea56f11ac213cf2426c7964a29ba9d8b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 94, "deletions": 92, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "eba82047bd9210a096ec668f6ca635eef69a9401", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "5877c81923bfac7b895b9fb3d8b714c7a3226c7c", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "6843e4cab83e9fb374a6d652385d35d11c45d62d", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "b707c48adc881d03b681b40db55aad66608ceae4", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 93, "deletions": 90, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "340eabf77daec4c57126f5378177a10885181211", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "ca616b5622a64f38de53039233db4d528bc47a9b", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 60, "deletions": 83, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "3d330fc1c7116df59496d6633f14fd266b919102", "filename": "src/librustc_trans/trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "a68eab953c3fa5a8d96af154bcffbbf98d7cb310", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "869dff724fb7203a4f2d8cf14f74e1ccb5bd7cf2", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "533f8d7bad7adc6d610e1ae9019403f93b50a80a", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "425364407b51b6bc8b123b1abde42174e1e409e6", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "c019a0a950cba5bfd9b0ef2cf3ab6686bf875912", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "730ab22e1e0b8dfc84293990e515cdd3a7bdd449", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 161, "deletions": 175, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "9781fd037d75d6871ac02581f213a58b3a69176c", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "22d624be6fcc87151459733720e8c782f3759f06", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "abe72aed323f2d4807f3f260480bb19d67671b65", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "4b36734c67fdfaf094bf9444716772d5539a4ac2", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "ae425f29132fa7e1e2f184c983f279848714a3f8", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "8deaa045c84d5d50e0da5feb0bd451e027b633c4", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "e0df6ec35c2f9febb252d249d9763b6a46126e62", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "127140691f05fa3df80d2e907108e48a8134e1e7", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "e4c3926fba18bc3a2f611a61a7c62207e45710d0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "a17d97a824a725cf142aa73b9eaa49cc821e63e9", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "65366fb9176b4c14a74769276770ea3f923cea47", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "799a3e86a75196e82c811549db8e1d0dcc99521b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "82c898214c5b69f23fcac152225c3587d8c7fea0", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "d6140fbe954e47af82de847f2d52ea45c4506577", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "c16892d07416325cc965ae5077f5c131a32e8983", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "0c8bdc0ee04a3a59225463ed67099092f12e6b03", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "217c9ebacb3c9d0a0358db43314ec027f76bf02d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "e319e37fa30981a5e429ee48693d77664b951a9a", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "5adc71b229f4ebde46ef53eeeb532afd690c7155", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "d9f691d065ba2065c8fa7a223aa3dbb817f584a7", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "c838243a2badd4671711527d8f6b7959bef4b189", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 233, "deletions": 242, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "bdca8ae444bd48022126297f1e3ab2fb585fd3cd", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 62, "deletions": 61, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "ab67dfebdacfe154fa37d8cc732ffad9c51601b0", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 69, "deletions": 67, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "f9f711a1a631656005573eb93481ddc8ef714f90", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "99cb12813077cfe3b69120565080662e6a115399", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "a53f15ce2aa84cf8192bf88e8f8258f042f9e649", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "94c01eb70e88a2d523053a4fbb6e7ae7f1e4bafa", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "8683afe44735a4f8c13e338e6f55b5c939d0e393", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "022f1e3646a12f6e599ff1754e9b1985e99436e7", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "55b5f665d11f62d5f4f4a2502d411044b1e9f7ac", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "b739709e622c25270ec07864c023723df27cb757", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "f0b68e5e9025f2c9c9b17cd9a61becf6510cc3c9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 170, "deletions": 171, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "125af57c4869ae14acd9e11980c38c6f258f82fd", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "229c52a4e5e5a415009a24438ec4822915a8db75", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "c9af86f06db9325ee1ca4d7c96929767b7ca51ba", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "5510d3ee06426c1650de4bd3652ca55cee995608", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 151, "deletions": 161, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "63468dd55f8a900e5d06d0bd7ab5fbdfcd387bea", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "5140cca03ea340eb1ffc0c0301330f7682f57dff", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "947ae3abd8d776a39ea55167a59d9c162bf2b1d2", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "86b268001a6aeb357e682abac729a6492b7ab370", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "efe5a73fad216eeabe5f56a07e221e7e76d7aa4b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "c11d9b8e31d8a7797a66171c08455c148540c8f7", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "95215cf2d5caf76985e1ff49cf1f9a9f53f2ffba", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "978b572ac9372e539ca496cdb7808b7228721e8f", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "d024ff117f579d97cbffd8bd11a337b39b92b0b8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "2b4df3186de6bc99629189e254d616d51a308857", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "0c0c68c89a10d4601ef9efe6dc363d28a7b803d0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "6398c76d0a351dca8856a93ede20c621510e6331", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "6d52ad3ff1e1fd7eb7d5dd33056096510e69823b", "filename": "src/test/pretty/issue-4264.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Ftest%2Fpretty%2Fissue-4264.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Ftest%2Fpretty%2Fissue-4264.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "a7c6f5225a6526506ce8bd321b4912cda2bc5a8c", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}, {"sha": "d53005011790bebebfac74481469a4dc23814b38", "filename": "src/test/run-make/pretty-print-path-suffix/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/facdf2ebb1dce9400a8c8ef0d85d7d278654effb/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2FMakefile?ref=facdf2ebb1dce9400a8c8ef0d85d7d278654effb"}]}