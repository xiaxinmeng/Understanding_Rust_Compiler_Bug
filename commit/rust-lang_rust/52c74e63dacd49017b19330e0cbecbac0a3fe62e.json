{"sha": "52c74e63dacd49017b19330e0cbecbac0a3fe62e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYzc0ZTYzZGFjZDQ5MDE3YjE5MzMwZTBjYmVjYmFjMGEzZmU2MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-29T22:54:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-29T22:54:19Z"}, "message": "Auto merge of #21692 - pnkfelix:fsk-fix-coerce-match-20055, r=eddyb\n\ntrans: When coercing to `Box<Trait>` or `Box<[T]>`, leave datum in it's original L-/R-value state.\r\n\r\nThis fixes a subtle issue where temporaries were being allocated (but not necessarily initialized) to the (parent) terminating scope of a match expression; in particular, the code to zero out the temporary emitted by `datum.store_to` is only attached to the particular match-arm for that temporary, but when going down other arms of the match expression, the temporary may falsely appear to have been initialized, depending on what the stack held at that location, and thus may have its destructor erroneously run at the end of the terminating scope.\r\n\r\nFIx #20055.\r\n\r\n(There may be a latent bug still remaining in `fn into_fat_ptr`, but I am so annoyed by the test/run-pass/coerce_match.rs failures that I want to land this now.)", "tree": {"sha": "9a89b5422499ca8fe4e285eec431ef96045f20d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a89b5422499ca8fe4e285eec431ef96045f20d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52c74e63dacd49017b19330e0cbecbac0a3fe62e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52c74e63dacd49017b19330e0cbecbac0a3fe62e", "html_url": "https://github.com/rust-lang/rust/commit/52c74e63dacd49017b19330e0cbecbac0a3fe62e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52c74e63dacd49017b19330e0cbecbac0a3fe62e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ea93abfb2c11111496d6e1f5b82fc21c2da27ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ea93abfb2c11111496d6e1f5b82fc21c2da27ad", "html_url": "https://github.com/rust-lang/rust/commit/7ea93abfb2c11111496d6e1f5b82fc21c2da27ad"}, {"sha": "d85520202ab05f1d67da26e00905bf22c548b86f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d85520202ab05f1d67da26e00905bf22c548b86f", "html_url": "https://github.com/rust-lang/rust/commit/d85520202ab05f1d67da26e00905bf22c548b86f"}], "stats": {"total": 114, "additions": 102, "deletions": 12}, "files": [{"sha": "bd5acb9b2e890735be2e60de948ca89b2306f2b3", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/52c74e63dacd49017b19330e0cbecbac0a3fe62e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c74e63dacd49017b19330e0cbecbac0a3fe62e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=52c74e63dacd49017b19330e0cbecbac0a3fe62e", "patch": "@@ -420,9 +420,15 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let tcx = bcx.tcx();\n \n         let datum_ty = datum.ty;\n-        // Arrange cleanup\n-        let lval = unpack_datum!(bcx,\n-                                 datum.to_lvalue_datum(bcx, \"unsize_unique_vec\", expr.id));\n+\n+        debug!(\"unsize_unique_vec expr.id={} datum_ty={} len={}\",\n+               expr.id, datum_ty.repr(tcx), len);\n+\n+        // We do not arrange cleanup ourselves; if we already are an\n+        // L-value, then cleanup will have already been scheduled (and\n+        // the `datum.store_to` call below will emit code to zero the\n+        // drop flag when moving out of the L-value). If we are an R-value,\n+        // then we do not need to schedule cleanup.\n \n         let ll_len = C_uint(bcx.ccx(), len);\n         let unit_ty = ty::sequence_element_type(tcx, ty::type_content(datum_ty));\n@@ -433,7 +439,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let base = PointerCast(bcx,\n                                base,\n                                type_of::type_of(bcx.ccx(), datum_ty).ptr_to());\n-        bcx = lval.store_to(bcx, base);\n+        bcx = datum.store_to(bcx, base);\n \n         Store(bcx, ll_len, get_len(bcx, scratch.val));\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n@@ -455,22 +461,20 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n-        let lval = unpack_datum!(bcx,\n-                                 datum.to_lvalue_datum(bcx, \"unsize_unique_expr\", expr.id));\n+        // We do not arrange cleanup ourselves; if we already are an\n+        // L-value, then cleanup will have already been scheduled (and\n+        // the `datum.store_to` call below will emit code to zero the\n+        // drop flag when moving out of the L-value). If we are an R-value,\n+        // then we do not need to schedule cleanup.\n \n         let scratch = rvalue_scratch_datum(bcx, result_ty, \"__uniq_fat_ptr\");\n         let llbox_ty = type_of::type_of(bcx.ccx(), datum_ty);\n         let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n-        bcx = lval.store_to(bcx, base);\n+        bcx = datum.store_to(bcx, base);\n \n         let info = unsized_info(bcx, k, expr.id, unboxed_ty, |t| ty::mk_uniq(tcx, t));\n         Store(bcx, info, get_len(bcx, scratch.val));\n \n-        let scratch = unpack_datum!(bcx,\n-                                    scratch.to_expr_datum().to_lvalue_datum(bcx,\n-                                                                            \"fresh_uniq_fat_ptr\",\n-                                                                            expr.id));\n-\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n }"}, {"sha": "836e78b5b51439e279a97499b9cf01899096b959", "filename": "src/test/run-pass/issue-20055-box-trait.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/52c74e63dacd49017b19330e0cbecbac0a3fe62e/src%2Ftest%2Frun-pass%2Fissue-20055-box-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c74e63dacd49017b19330e0cbecbac0a3fe62e/src%2Ftest%2Frun-pass%2Fissue-20055-box-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20055-box-trait.rs?ref=52c74e63dacd49017b19330e0cbecbac0a3fe62e", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See Issues #20055 and #21695.\n+\n+// We are checking here that the temporaries `Box<[i8, k]>`, for `k`\n+// in 1, 2, 3, 4, that are induced by the match expression are\n+// properly handled, in that only *one* will be initialized by\n+// whichever arm is run, and subsequently dropped at the end of the\n+// statement surrounding the `match`.\n+\n+trait Boo { }\n+\n+impl Boo for [i8; 1] { }\n+impl Boo for [i8; 2] { }\n+impl Boo for [i8; 3] { }\n+impl Boo for [i8; 4] { }\n+\n+pub fn foo(box_1: fn () -> Box<[i8; 1]>,\n+           box_2: fn () -> Box<[i8; 2]>,\n+           box_3: fn () -> Box<[i8; 3]>,\n+           box_4: fn () -> Box<[i8; 4]>,\n+            ) {\n+    println!(\"Hello World 1\");\n+    let _: Box<Boo> = match 3 {\n+        1 => box_1(),\n+        2 => box_2(),\n+        3 => box_3(),\n+        _ => box_4(),\n+    };\n+    println!(\"Hello World 2\");\n+}\n+\n+pub fn main() {\n+    fn box_1() -> Box<[i8; 1]> { Box::new( [1i8; 1] ) }\n+    fn box_2() -> Box<[i8; 2]> { Box::new( [1i8; 2] ) }\n+    fn box_3() -> Box<[i8; 3]> { Box::new( [1i8; 3] ) }\n+    fn box_4() -> Box<[i8; 4]> { Box::new( [1i8; 4] ) }\n+\n+    foo(box_1, box_2, box_3, box_4);\n+}"}, {"sha": "f751be6f13bc10ac9ee5ce2fbf1b78c0670c4376", "filename": "src/test/run-pass/issue-20055-box-unsized-array.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/52c74e63dacd49017b19330e0cbecbac0a3fe62e/src%2Ftest%2Frun-pass%2Fissue-20055-box-unsized-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c74e63dacd49017b19330e0cbecbac0a3fe62e/src%2Ftest%2Frun-pass%2Fissue-20055-box-unsized-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20055-box-unsized-array.rs?ref=52c74e63dacd49017b19330e0cbecbac0a3fe62e", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #2005: Check that boxed fixed-size arrays are properly\n+// accounted for (namely, only deallocated if they were actually\n+// created) when they appear as temporaries in unused arms of a match\n+// expression.\n+\n+pub fn foo(box_1: fn () -> Box<[i8; 1]>,\n+           box_2: fn () -> Box<[i8; 20]>,\n+           box_3: fn () -> Box<[i8; 300]>,\n+           box_4: fn () -> Box<[i8; 4000]>,\n+            ) {\n+    println!(\"Hello World 1\");\n+    let _: Box<[i8]> = match 3 {\n+        1 => box_1(),\n+        2 => box_2(),\n+        3 => box_3(),\n+        _ => box_4(),\n+    };\n+    println!(\"Hello World 2\");\n+}\n+\n+pub fn main() {\n+    fn box_1() -> Box<[i8; 1]> { Box::new( [1i8] ) }\n+    fn box_2() -> Box<[i8; 20]> { Box::new( [1i8; 20] ) }\n+    fn box_3() -> Box<[i8; 300]> { Box::new( [1i8; 300] ) }\n+    fn box_4() -> Box<[i8; 4000]> { Box::new( [1i8; 4000] ) }\n+\n+    foo(box_1, box_2, box_3, box_4);\n+}"}]}