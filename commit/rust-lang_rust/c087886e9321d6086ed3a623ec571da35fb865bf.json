{"sha": "c087886e9321d6086ed3a623ec571da35fb865bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwODc4ODZlOTMyMWQ2MDg2ZWQzYTYyM2VjNTcxZGEzNWZiODY1YmY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-12T00:17:54Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-12T03:02:34Z"}, "message": "Make moves explicit in arguments", "tree": {"sha": "51949005b792266cf48fe1f53b25cc587732eb75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51949005b792266cf48fe1f53b25cc587732eb75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c087886e9321d6086ed3a623ec571da35fb865bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c087886e9321d6086ed3a623ec571da35fb865bf", "html_url": "https://github.com/rust-lang/rust/commit/c087886e9321d6086ed3a623ec571da35fb865bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c087886e9321d6086ed3a623ec571da35fb865bf/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c6c963f61d84d2a959df0d5c82f519c157ef552", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6c963f61d84d2a959df0d5c82f519c157ef552", "html_url": "https://github.com/rust-lang/rust/commit/2c6c963f61d84d2a959df0d5c82f519c157ef552"}], "stats": {"total": 222, "additions": 113, "deletions": 109}, "files": [{"sha": "e2749a5bd5761552d530ac3edeee0f57d7e4b072", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -177,7 +177,7 @@ mod unsafe {\n         (**repr).fill += sys::size_of::<T>();\n         let p = ptr::addr_of((**repr).data);\n         let p = ptr::offset(p, fill) as *mut T;\n-        rusti::move_val_init(*p, initval);\n+        rusti::move_val_init(*p, move initval);\n     }\n \n     unsafe fn push_slow<T>(&v: @[const T], +initval: T) {"}, {"sha": "f9db36f0fc1fb7dcc022acce65263433ea8ec2bb", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -181,7 +181,7 @@ fn send<T: Send>(ch: Chan<T>, +data: T) {\n     let res = rustrt::rust_port_id_send(p, data_ptr);\n     if res != 0 unsafe {\n         // Data sent successfully\n-        unsafe::forget(data);\n+        unsafe::forget(move data);\n     }\n     task::yield();\n }"}, {"sha": "58c7edd33cdfe27430ad9d8e28d94c1cc9215244", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -198,27 +198,27 @@ impl<T> DList<T> {\n \n     /// Add data to the head of the list. O(1).\n     fn push_head(+data: T) {\n-        self.add_head(self.new_link(data));\n+        self.add_head(self.new_link(move data));\n     }\n     /**\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n     fn push_head_n(+data: T) -> DListNode<T> {\n-        let mut nobe = self.new_link(data);\n+        let mut nobe = self.new_link(move data);\n         self.add_head(nobe);\n         option::get(nobe)\n     }\n     /// Add data to the tail of the list. O(1).\n     fn push(+data: T) {\n-        self.add_tail(self.new_link(data));\n+        self.add_tail(self.new_link(move data));\n     }\n     /**\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n     fn push_n(+data: T) -> DListNode<T> {\n-        let mut nobe = self.new_link(data);\n+        let mut nobe = self.new_link(move data);\n         self.add_tail(nobe);\n         option::get(nobe)\n     }\n@@ -227,7 +227,7 @@ impl<T> DList<T> {\n      * O(1).\n      */\n     fn insert_before(+data: T, neighbour: DListNode<T>) {\n-        self.insert_left(self.new_link(data), neighbour);\n+        self.insert_left(self.new_link(move data), neighbour);\n     }\n     /**\n      * Insert an existing node in the middle of the list, left of the\n@@ -242,7 +242,7 @@ impl<T> DList<T> {\n      * and get its containing node. O(1).\n      */\n     fn insert_before_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n-        let mut nobe = self.new_link(data);\n+        let mut nobe = self.new_link(move data);\n         self.insert_left(nobe, neighbour);\n         option::get(nobe)\n     }\n@@ -251,7 +251,7 @@ impl<T> DList<T> {\n      * O(1).\n      */\n     fn insert_after(+data: T, neighbour: DListNode<T>) {\n-        self.insert_right(neighbour, self.new_link(data));\n+        self.insert_right(neighbour, self.new_link(move data));\n     }\n     /**\n      * Insert an existing node in the middle of the list, right of the\n@@ -266,7 +266,7 @@ impl<T> DList<T> {\n      * and get its containing node. O(1).\n      */\n     fn insert_after_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n-        let mut nobe = self.new_link(data);\n+        let mut nobe = self.new_link(move data);\n         self.insert_right(neighbour, nobe);\n         option::get(nobe)\n     }"}, {"sha": "ed8a814bba8e2367253ff642f15a229bf9877789", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -95,7 +95,7 @@ priv impl<A> DVec<A> {\n             data <-> self.data;\n             let data_ptr: *() = unsafe::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n-            return f(data);\n+            return f(move data);\n         }\n     }\n \n@@ -123,15 +123,15 @@ impl<A> DVec<A> {\n      */\n     #[inline(always)]\n     fn swap(f: fn(-~[mut A]) -> ~[mut A]) {\n-        self.check_out(|v| self.give_back(f(v)))\n+        self.check_out(|v| self.give_back(f(move v)))\n     }\n \n     /// Returns the number of elements currently in the dvec\n     pure fn len() -> uint {\n         unchecked {\n             do self.check_out |v| {\n                 let l = v.len();\n-                self.give_back(v);\n+                self.give_back(move v);\n                 l\n             }\n         }\n@@ -148,7 +148,7 @@ impl<A> DVec<A> {\n         do self.check_out |v| {\n             let mut v <- v;\n             let result = vec::pop(v);\n-            self.give_back(v);\n+            self.give_back(move v);\n             move result\n         }\n     }\n@@ -162,7 +162,7 @@ impl<A> DVec<A> {\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n             log(error, ~\"a\");\n             self.data <- ~[mut move t];\n-            vec::push_all_move(self.data, data);\n+            vec::push_all_move(self.data, move data);\n             log(error, ~\"b\");\n         }\n     }\n@@ -187,15 +187,15 @@ impl<A> DVec<A> {\n     fn reverse() {\n         do self.check_out |v| {\n             vec::reverse(v);\n-            self.give_back(v);\n+            self.give_back(move v);\n         }\n     }\n \n     /// Gives access to the vector as a slice with immutable contents\n     fn borrow<R>(op: fn(x: &[A]) -> R) -> R {\n         do self.check_out |v| {\n             let result = op(v);\n-            self.give_back(v);\n+            self.give_back(move v);\n             move result\n         }\n     }\n@@ -204,7 +204,7 @@ impl<A> DVec<A> {\n     fn borrow_mut<R>(op: fn(x: &[mut A]) -> R) -> R {\n         do self.check_out |v| {\n             let result = op(v);\n-            self.give_back(v);\n+            self.give_back(move v);\n             move result\n         }\n     }\n@@ -269,7 +269,7 @@ impl<A: Copy> DVec<A> {\n         unchecked {\n             do self.check_out |v| {\n                 let w = vec::from_mut(copy v);\n-                self.give_back(v);\n+                self.give_back(move v);\n                 move w\n             }\n         }"}, {"sha": "94f7aa8f3c5b32f8dbba0de54926733c9de2e8c6", "filename": "src/libcore/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -90,7 +90,7 @@ fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n     do from_fn |move port| {\n         let mut port_ = None;\n         port_ <-> *port;\n-        let port = option::unwrap(port_);\n+        let port = option::unwrap(move port_);\n         match recv(move port) {\n             future_pipe::completed(move data) => move data\n         }"}, {"sha": "f8f1c9df4e47e05f225ff2a5ffa2d464be4d9508", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -74,7 +74,7 @@ pure fn map_consume<T, U>(+opt: Option<T>, f: fn(+T) -> U) -> Option<U> {\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n      */\n-    if opt.is_some() { Some(f(option::unwrap(opt))) } else { None }\n+    if opt.is_some() { Some(f(option::unwrap(move opt))) } else { None }\n }\n \n pure fn chain<T, U>(opt: Option<T>, f: fn(T) -> Option<U>) -> Option<U> {\n@@ -112,7 +112,7 @@ pure fn while_some<T>(+x: Option<T>, blk: fn(+T) -> Option<T>) {\n \n     let mut opt <- x;\n     while opt.is_some() {\n-        opt = blk(unwrap(opt));\n+        opt = blk(unwrap(move opt));\n     }\n }\n \n@@ -186,7 +186,7 @@ fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n pure fn unwrap_expect<T>(+opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n-    unwrap(opt)\n+    unwrap(move opt)\n }\n \n // Some of these should change to be &Option<T>, some should not. See below."}, {"sha": "1bc706d16d1bc3f92a0c7337da0a49a26c27962f", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -272,7 +272,7 @@ fn packet<T: Send>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(b.data);\n     // We'll take over memory management from here.\n-    unsafe { forget(b) }\n+    unsafe { forget(move b) }\n     p\n }\n \n@@ -283,7 +283,7 @@ fn entangle_buffer<T: Send, Tstart: Send>(\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n     let p = init(unsafe { reinterpret_cast(&buffer) }, &buffer.data);\n-    unsafe { forget(buffer) }\n+    unsafe { forget(move buffer) }\n     (SendPacketBuffered(p), RecvPacketBuffered(p))\n }\n \n@@ -320,7 +320,7 @@ fn swap_task(+dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n     unsafe {\n-        transmute(rusti::atomic_xchg(transmute(dst), src as int))\n+        transmute(rusti::atomic_xchg(transmute(move dst), src as int))\n     }\n }\n \n@@ -357,14 +357,14 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n #[doc(hidden)]\n fn swap_state_acq(+dst: &mut State, src: State) -> State {\n     unsafe {\n-        transmute(rusti::atomic_xchg_acq(transmute(dst), src as int))\n+        transmute(rusti::atomic_xchg_acq(transmute(move dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n fn swap_state_rel(+dst: &mut State, src: State) -> State {\n     unsafe {\n-        transmute(rusti::atomic_xchg_rel(transmute(dst), src as int))\n+        transmute(rusti::atomic_xchg_rel(transmute(move dst), src as int))\n     }\n }\n \n@@ -389,7 +389,7 @@ struct BufferResource<T: Send> {\n             // go go gadget drop glue\n         }\n         else {\n-            forget(b)\n+            forget(move b)\n         }\n     }\n }\n@@ -488,7 +488,7 @@ fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n         let mut payload = None;\n         payload <-> p.payload;\n         p.header.state = Empty;\n-        return Some(option::unwrap(payload))\n+        return Some(option::unwrap(move payload))\n       },\n       Terminated => return None,\n       _ => {}\n@@ -534,7 +534,7 @@ fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n                 rustrt::rust_task_deref(old_task);\n             }\n             p.header.state = Empty;\n-            return Some(option::unwrap(payload))\n+            return Some(option::unwrap(move payload))\n           }\n           Terminated => {\n             // This assert detects when we've accidentally unsafely\n@@ -789,7 +789,7 @@ struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n         if self.p != None {\n             let mut p = None;\n             p <-> self.p;\n-            sender_terminate(option::unwrap(p))\n+            sender_terminate(option::unwrap(move p))\n         }\n         //unsafe { error!(\"send_drop: %?\",\n         //                if self.buffer == none {\n@@ -814,7 +814,7 @@ impl<T: Send, Tbuffer: Send> SendPacketBuffered<T, Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n-        option::unwrap(p)\n+        option::unwrap(move p)\n     }\n \n     pure fn header() -> *PacketHeader {\n@@ -833,7 +833,7 @@ impl<T: Send, Tbuffer: Send> SendPacketBuffered<T, Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n-        option::unwrap(tmp)\n+        option::unwrap(move tmp)\n     }\n }\n \n@@ -873,7 +873,7 @@ struct RecvPacketBuffered<T: Send, Tbuffer: Send> {\n         if self.p != None {\n             let mut p = None;\n             p <-> self.p;\n-            receiver_terminate(option::unwrap(p))\n+            receiver_terminate(option::unwrap(move p))\n         }\n         //unsafe { error!(\"recv_drop: %?\",\n         //                if self.buffer == none {\n@@ -886,7 +886,7 @@ impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> : Selectable {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n-        option::unwrap(p)\n+        option::unwrap(move p)\n     }\n \n     pure fn header() -> *PacketHeader {\n@@ -905,7 +905,7 @@ impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> : Selectable {\n         //error!(\"recv reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n-        option::unwrap(tmp)\n+        option::unwrap(move tmp)\n     }\n }\n \n@@ -954,7 +954,7 @@ fn spawn_service<T: Send, Tb: Send>(\n     do task::spawn |move service, move server| {\n         let mut server_ = None;\n         server_ <-> *server;\n-        service(option::unwrap(server_))\n+        service(option::unwrap(move server_))\n     }\n \n     move client\n@@ -978,7 +978,7 @@ fn spawn_service_recv<T: Send, Tb: Send>(\n     do task::spawn |move service, move server| {\n         let mut server_ = None;\n         server_ <-> *server;\n-        service(option::unwrap(server_))\n+        service(option::unwrap(move server_))\n     }\n \n     move client\n@@ -1054,13 +1054,13 @@ impl<T: Send> Chan<T>: Channel<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n         self.endp = Some(\n-            streamp::client::data(unwrap(endp), move x))\n+            streamp::client::data(unwrap(move endp), move x))\n     }\n \n     fn try_send(+x: T) -> bool {\n         let mut endp = None;\n         endp <-> self.endp;\n-        match move streamp::client::try_data(unwrap(endp), move x) {\n+        match move streamp::client::try_data(unwrap(move endp), move x) {\n             Some(move next) => {\n                 self.endp = Some(move next);\n                 true\n@@ -1074,15 +1074,15 @@ impl<T: Send> Port<T>: Recv<T> {\n     fn recv() -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n-        let streamp::data(x, endp) = pipes::recv(unwrap(endp));\n+        let streamp::data(x, endp) = pipes::recv(unwrap(move endp));\n         self.endp = Some(move endp);\n         move x\n     }\n \n     fn try_recv() -> Option<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n-        match move pipes::try_recv(unwrap(endp)) {\n+        match move pipes::try_recv(unwrap(move endp)) {\n           Some(streamp::data(move x, move endp)) => {\n             self.endp = Some(move endp);\n             Some(move x)\n@@ -1180,7 +1180,7 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n         do self.with |chan| {\n             let mut x = None;\n             x <-> xx;\n-            chan.send(option::unwrap(x))\n+            chan.send(option::unwrap(move x))\n         }\n     }\n \n@@ -1189,7 +1189,7 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n         do self.with |chan| {\n             let mut x = None;\n             x <-> xx;\n-            chan.try_send(option::unwrap(x))\n+            chan.try_send(option::unwrap(move x))\n         }\n     }\n }\n@@ -1260,7 +1260,7 @@ fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n \n     if message.is_none() { None }\n     else {\n-        let oneshot::send(message) = option::unwrap(message);\n+        let oneshot::send(message) = option::unwrap(move message);\n         Some(move message)\n     }\n }"}, {"sha": "a15c2f01659a415d7972f83a252a4de110019087", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -337,7 +337,7 @@ mod linear {\n             if value.is_none() {\n                 fail fmt!(\"No entry found for key: %?\", k);\n             }\n-            option::unwrap(value)\n+            option::unwrap(move value)\n         }\n \n     }"}, {"sha": "3a2aa0b0f0dd7764ba825299d3c58d5c2cf0dbe8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -149,8 +149,7 @@ pure fn from_slice(s: &str) -> ~str {\n  */\n pure fn from_byte(b: u8) -> ~str {\n     assert b < 128u8;\n-    let mut v = ~[b, 0u8];\n-    unsafe { ::unsafe::transmute(v) }\n+    unsafe { ::unsafe::transmute(~[b, 0u8]) }\n }\n \n /// Appends a character at the end of a string\n@@ -437,8 +436,7 @@ Section: Transforming strings\n  * The result vector is not null-terminated.\n  */\n pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n-    let mut s_copy = from_slice(s);\n-    let mut v: ~[u8] = ::unsafe::transmute(s_copy);\n+    let mut v: ~[u8] = ::unsafe::transmute(from_slice(s));\n     vec::unsafe::set_len(v, len(s));\n     move v\n }\n@@ -1997,15 +1995,15 @@ mod unsafe {\n         vec::push(v, 0u8);\n \n         assert is_utf8(v);\n-        return ::unsafe::transmute(v);\n+        return ::unsafe::transmute(move v);\n     }\n \n     /// Create a Rust string from a *u8 buffer of the given length\n     /// without copying\n     unsafe fn from_buf_len_nocopy(buf: &a / *u8, len: uint) -> &a / str {\n         let v = (*buf, len + 1);\n         assert is_utf8(::unsafe::reinterpret_cast(&v));\n-        return ::unsafe::transmute(v);\n+        return ::unsafe::transmute(move v);\n     }\n \n     /// Create a Rust string from a null-terminated C string\n@@ -2052,7 +2050,7 @@ mod unsafe {\n                 }\n                 vec::unsafe::set_len(v, end - begin);\n                 vec::push(v, 0u8);\n-                ::unsafe::transmute(v)\n+                ::unsafe::transmute(move v)\n             }\n         }\n     }"}, {"sha": "8f186d86168ce655a93bfe432b66d9b045e91049", "filename": "src/libcore/task.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -574,7 +574,7 @@ impl TaskBuilder {\n         do fr_task_builder.spawn |move f| {\n             comm::send(ch, f());\n         }\n-        match future::get(&option::unwrap(result)) {\n+        match future::get(&option::unwrap(move result)) {\n             Success => result::Ok(comm::recv(po)),\n             Failure => result::Err(())\n         }\n@@ -972,7 +972,7 @@ fn each_ancestor(list:        &mut AncestorList,\n         if coalesce_this.is_some() {\n             // Needed coalesce. Our next ancestor becomes our old\n             // ancestor's next ancestor. (\"next = old_next->next;\")\n-            *list <- option::unwrap(coalesce_this);\n+            *list <- option::unwrap(move coalesce_this);\n         } else {\n             // No coalesce; restore from tmp. (\"next = old_next;\")\n             *list <- tmp_list;\n@@ -1144,7 +1144,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n-        let group = option::unwrap(newstate);\n+        let group = option::unwrap(move newstate);\n         taskset_insert(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n         *state = Some(move group);\n@@ -1159,7 +1159,7 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n     let newstate = util::replace(state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n-        let group = option::unwrap(newstate);\n+        let group = option::unwrap(move newstate);\n         taskset_remove(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n         *state = Some(move group);\n@@ -1181,7 +1181,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // That's ok; only one task needs to do the dirty work. (Might also\n     // see 'None' if Somebody already failed and we got a kill signal.)\n     if newstate.is_some() {\n-        let group = option::unwrap(newstate);\n+        let group = option::unwrap(move newstate);\n         for taskset_each(&group.members) |+sibling| {\n             // Skip self - killing ourself won't do much good.\n             if sibling != me {\n@@ -1277,7 +1277,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         //    None               { ancestor_list(None) }\n         let tmp = util::replace(&mut **ancestors, None);\n         if tmp.is_some() {\n-            let ancestor_arc = option::unwrap(tmp);\n+            let ancestor_arc = option::unwrap(move tmp);\n             let result = ancestor_arc.clone();\n             **ancestors <- Some(move ancestor_arc);\n             AncestorList(Some(move result))\n@@ -1319,7 +1319,7 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n             // closure. (Reordering them wouldn't help - then getting killed\n             // between them would leak.)\n             rustrt::start_task(new_task, closure);\n-            unsafe::forget(child_wrapper);\n+            unsafe::forget(move child_wrapper);\n         }\n     }\n \n@@ -1500,7 +1500,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n         unsafe::bump_box_refcount(map);\n         map\n     } else {\n-        let map = unsafe::transmute(map_ptr);\n+        let map = unsafe::transmute(move map_ptr);\n         unsafe::bump_box_refcount(map);\n         map\n     }\n@@ -1546,7 +1546,7 @@ unsafe fn local_get_helper<T: Owned>(\n         // overwriting the local_data_box we need to give an extra reference.\n         // We must also give an extra reference when not removing.\n         let (index, data_ptr) = result;\n-        let data: @T = unsafe::transmute(data_ptr);\n+        let data: @T = unsafe::transmute(move data_ptr);\n         unsafe::bump_box_refcount(data);\n         if do_pop {\n             (*map).set_elt(index, None);\n@@ -1608,7 +1608,7 @@ unsafe fn local_modify<T: Owned>(\n     // Could be more efficient by doing the lookup work, but this is easy.\n     let newdata = modify_fn(local_pop(task, key));\n     if newdata.is_some() {\n-        local_set(task, key, option::unwrap(newdata));\n+        local_set(task, key, option::unwrap(move newdata));\n     }\n }\n "}, {"sha": "14205f39e9f6223d92d384aa3bedd2da9cf746a5", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -32,15 +32,15 @@ unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n  * reinterpret_cast on managed pointer types.\n  */\n #[inline(always)]\n-unsafe fn forget<T>(-thing: T) { rusti::forget(thing); }\n+unsafe fn forget<T>(-thing: T) { rusti::forget(move thing); }\n \n /**\n  * Force-increment the reference count on a shared box. If used\n- * uncarefully, this can leak the box. Use this in conjunction with transmute\n+ * carelessly, this can leak the box. Use this in conjunction with transmute\n  * and/or reinterpret_cast when such calls would otherwise scramble a box's\n  * reference count\n  */\n-unsafe fn bump_box_refcount<T>(+t: @T) { forget(t); }\n+unsafe fn bump_box_refcount<T>(+t: @T) { forget(move t); }\n \n /**\n  * Transform a value of one type into a value of another type.\n@@ -51,23 +51,26 @@ unsafe fn bump_box_refcount<T>(+t: @T) { forget(t); }\n  *     assert transmute(\"L\") == ~[76u8, 0u8];\n  */\n unsafe fn transmute<L, G>(-thing: L) -> G {\n-    let newthing = reinterpret_cast(&thing);\n-    forget(thing);\n+    debug!(\">>> in transmute! <<<\");\n+    debug!(\"transmute 1: %?\", &thing);\n+    let newthing: G = reinterpret_cast(&thing);\n+    forget(move thing);\n+    debug!(\"transmute 2: %?\", &newthing);\n     move newthing\n }\n \n /// Coerce an immutable reference to be mutable.\n-unsafe fn transmute_mut<T>(+ptr: &a/T) -> &a/mut T { transmute(ptr) }\n+unsafe fn transmute_mut<T>(+ptr: &a/T) -> &a/mut T { transmute(move ptr) }\n \n /// Coerce a mutable reference to be immutable.\n-unsafe fn transmute_immut<T>(+ptr: &a/mut T) -> &a/T { transmute(ptr) }\n+unsafe fn transmute_immut<T>(+ptr: &a/mut T) -> &a/T { transmute(move ptr) }\n \n /// Coerce a borrowed pointer to have an arbitrary associated region.\n-unsafe fn transmute_region<T>(+ptr: &a/T) -> &b/T { transmute(ptr) }\n+unsafe fn transmute_region<T>(+ptr: &a/T) -> &b/T { transmute(move ptr) }\n \n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n-    transmute(ptr)\n+    transmute(move ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n@@ -117,15 +120,15 @@ struct ArcDestruct<T> {\n                     // Unkillable wait. Message guaranteed to come.\n                     if pipes::recv_one(move response) {\n                         // Other task got the data.\n-                        unsafe::forget(data);\n+                        unsafe::forget(move data);\n                     } else {\n                         // Other task was killed. drop glue takes over.\n                     }\n                 } else {\n                     // drop glue takes over.\n                 }\n             } else {\n-                unsafe::forget(data);\n+                unsafe::forget(move data);\n             }\n         }\n     }\n@@ -163,7 +166,7 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n         let (c1,p1) = pipes::oneshot(); // ()\n         let (c2,p2) = pipes::oneshot(); // bool\n         let server: UnwrapProto = ~mut Some((move c1,move p2));\n-        let serverp: libc::uintptr_t = unsafe::transmute(server);\n+        let serverp: libc::uintptr_t = unsafe::transmute(move server);\n         // Try to put our server end in the unwrapper slot.\n         if rustrt::rust_compare_and_swap_ptr(&mut ptr.unwrapper, 0, serverp) {\n             // Got in. Step 0: Tell destructor not to run. We are now it.\n@@ -174,7 +177,7 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n             if new_count == 0 {\n                 // We were the last owner. Can unwrap immediately.\n                 // Also we have to free the server endpoints.\n-                let _server: UnwrapProto = unsafe::transmute(serverp);\n+                let _server: UnwrapProto = unsafe::transmute(move serverp);\n                 option::swap_unwrap(&mut ptr.data)\n                 // drop glue takes over.\n             } else {\n@@ -194,9 +197,9 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n             }\n         } else {\n             // Somebody else was trying to unwrap. Avoid guaranteed deadlock.\n-            unsafe::forget(ptr);\n+            unsafe::forget(move ptr);\n             // Also we have to free the (rejected) server endpoints.\n-            let _server: UnwrapProto = unsafe::transmute(serverp);\n+            let _server: UnwrapProto = unsafe::transmute(move serverp);\n             fail ~\"Another task is already unwrapping this ARC!\";\n         }\n     }\n@@ -213,7 +216,7 @@ type SharedMutableState<T: Send> = ArcDestruct<T>;\n unsafe fn shared_mutable_state<T: Send>(+data: T) -> SharedMutableState<T> {\n     let data = ~ArcData { count: 1, unwrapper: 0, data: Some(move data) };\n     unsafe {\n-        let ptr = unsafe::transmute(data);\n+        let ptr = unsafe::transmute(move data);\n         ArcDestruct(ptr)\n     }\n }\n@@ -226,7 +229,7 @@ unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n         assert ptr.count > 0;\n         // Cast us back into the correct region\n         let r = unsafe::transmute_region(option::get_ref(&ptr.data));\n-        unsafe::forget(ptr);\n+        unsafe::forget(move ptr);\n         return unsafe::transmute_mut(r);\n     }\n }\n@@ -238,7 +241,7 @@ unsafe fn get_shared_immutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n         assert ptr.count > 0;\n         // Cast us back into the correct region\n         let r = unsafe::transmute_region(option::get_ref(&ptr.data));\n-        unsafe::forget(ptr);\n+        unsafe::forget(move ptr);\n         return r;\n     }\n }\n@@ -249,7 +252,7 @@ unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n         let ptr: ~ArcData<T> = unsafe::reinterpret_cast(&(*rc).data);\n         let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n         assert new_count >= 2;\n-        unsafe::forget(ptr);\n+        unsafe::forget(move ptr);\n     }\n     ArcDestruct((*rc).data)\n }"}, {"sha": "38340c2b8d11f1c5e71ae1f038a87480bb1208f3", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -271,12 +271,12 @@ pure fn build_sized_opt<A>(size: Option<uint>,\n \n /// Produces a mut vector from an immutable vector.\n pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n-    unsafe { ::unsafe::transmute(v) }\n+    unsafe { ::unsafe::transmute(move v) }\n }\n \n /// Produces an immutable vector from a mut vector.\n pure fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n-    unsafe { ::unsafe::transmute(v) }\n+    unsafe { ::unsafe::transmute(move v) }\n }\n \n // Accessors\n@@ -580,7 +580,7 @@ unsafe fn push_fast<T>(&v: ~[const T], +initval: T) {\n     (**repr).fill += sys::size_of::<T>();\n     let p = ptr::addr_of((**repr).data);\n     let p = ptr::offset(p, fill) as *mut T;\n-    rusti::move_val_init(*p, initval);\n+    rusti::move_val_init(*p, move initval);\n }\n \n #[inline(never)]\n@@ -1835,7 +1835,7 @@ mod unsafe {\n             let mut box2 = None;\n             box2 <-> box;\n             rusti::move_val_init(*ptr::mut_offset(p, i),\n-                                 option::unwrap(box2));\n+                                 option::unwrap(move box2));\n         }\n     }\n "}, {"sha": "ae696d912cd9367b218e9891d8d5ea8092fab264", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -221,7 +221,7 @@ fn Bitv (nbits: uint, init: bool) -> Bitv {\n                      if nbits % uint_bits == 0 {0} else {1};\n         let elem = if init {!0} else {0};\n         let s = to_mut(from_elem(nelems, elem));\n-        Big(~BigBitv(s))\n+        Big(~BigBitv(move s))\n     };\n     Bitv {rep: rep, nbits: nbits}\n }"}, {"sha": "bc16aa2e03e823dac61f9d97f9dc56b5c723770e", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -26,7 +26,7 @@ impl<T> Cell<T> {\n \n         let mut value = None;\n         value <-> self.value;\n-        return option::unwrap(value);\n+        return option::unwrap(move value);\n     }\n \n     /// Returns the value, failing if the cell is full."}, {"sha": "1eac198c773f292115393be3901c155b91b1b9ca", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -57,7 +57,7 @@ fn create<T: Copy>() -> Deque<T> {\n                 self.lo = self.elts.len() - 1u;\n             } else { self.lo -= 1u; }\n             if self.lo == self.hi {\n-                self.elts.swap(|v| grow(self.nelts, oldlo, v));\n+                self.elts.swap(|v| grow(self.nelts, oldlo, move v));\n                 self.lo = self.elts.len() - 1u;\n                 self.hi = self.nelts;\n             }\n@@ -66,7 +66,7 @@ fn create<T: Copy>() -> Deque<T> {\n         }\n         fn add_back(t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n-                self.elts.swap(|v| grow(self.nelts, self.lo, v));\n+                self.elts.swap(|v| grow(self.nelts, self.lo, move v));\n                 self.lo = 0u;\n                 self.hi = self.nelts;\n             }\n@@ -111,7 +111,7 @@ fn create<T: Copy>() -> Deque<T> {\n                 vec::to_mut(\n                     vec::from_elem(initial_capacity, None)))\n     };\n-    move (repr as Deque::<T>)\n+    (move repr) as Deque::<T>\n }\n \n #[cfg(test)]"}, {"sha": "dad1fd6f6f997f792d62d7a2c1aa6e753109cfcf", "filename": "src/libstd/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -279,7 +279,7 @@ mod chained {\n             if opt_v.is_none() {\n                 fail fmt!(\"Key not found in table: %?\", k);\n             }\n-            option::unwrap(opt_v)\n+            option::unwrap(move opt_v)\n         }\n \n         fn remove(+k: K) -> bool {"}, {"sha": "a6357c9fbb7dd553408fa14e7e702ecdf1d98610", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -275,7 +275,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                         result::Err(GetAddrUnknownError));\n                     break;\n                 };\n-                out_vec += ~[new_ip_addr];\n+                out_vec += ~[move new_ip_addr];\n \n                 let next_addr = ll::get_next_addrinfo(curr_addr);\n                 if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n@@ -289,7 +289,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n             }\n             log(debug, fmt!(\"successful process addrinfo result, len: %?\",\n                             vec::len(out_vec)));\n-            (*handle_data).output_ch.send(result::Ok(out_vec));\n+            (*handle_data).output_ch.send(result::Ok(move out_vec));\n         }\n         else {\n             log(debug, ~\"addrinfo pointer is NULL\");"}, {"sha": "d4eb5ce69986974578c2f08cafd1802b8805fd03", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -155,7 +155,7 @@ fn connect(-input_ip: ip::IpAddr, port: uint,\n     // we can send into the interact cb to be handled in libuv..\n     log(debug, fmt!(\"stream_handle_ptr outside interact %?\",\n         stream_handle_ptr));\n-    do iotask::interact(iotask) |loop_ptr| unsafe {\n+    do iotask::interact(iotask) |move input_ip, loop_ptr| unsafe {\n         log(debug, ~\"in interact cb for tcp client connect..\");\n         log(debug, fmt!(\"stream_handle_ptr in interact %?\",\n             stream_handle_ptr));\n@@ -575,7 +575,7 @@ fn listen(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n           +new_connect_cb: fn~(TcpNewConnection,\n                                comm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> unsafe {\n-    do listen_common(host_ip, port, backlog, iotask, on_establish_cb)\n+    do listen_common(move host_ip, port, backlog, iotask, on_establish_cb)\n         // on_connect_cb\n         |move new_connect_cb, handle| unsafe {\n             let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n@@ -600,7 +600,7 @@ fn listen_common(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n         server_stream_ptr: server_stream_ptr,\n         stream_closed_ch: core::comm::Chan(stream_closed_po),\n         kill_ch: kill_ch,\n-        on_connect_cb: on_connect_cb,\n+        on_connect_cb: move on_connect_cb,\n         iotask: iotask,\n         mut active: true\n     };\n@@ -614,7 +614,7 @@ fn listen_common(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n         // tcp::connect (because the iotask::interact cb isn't\n         // nested within a core::comm::listen block)\n         let loc_ip = copy(host_ip);\n-        do iotask::interact(iotask) |loop_ptr| unsafe {\n+        do iotask::interact(iotask) |move loc_ip, loop_ptr| unsafe {\n             match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n               0i32 => {\n                 uv::ll::set_data_for_uv_handle(\n@@ -739,7 +739,7 @@ impl TcpSocket {\n     fn read_stop(-read_port:\n                  comm::Port<result::Result<~[u8], TcpErrData>>) ->\n         result::Result<(), TcpErrData> {\n-        read_stop(self, read_port)\n+        read_stop(self, move read_port)\n     }\n     fn read(timeout_msecs: uint) ->\n         result::Result<~[u8], TcpErrData> {\n@@ -1491,7 +1491,8 @@ mod test {\n                           cont_ch: comm::Chan<()>,\n                           iotask: IoTask) -> ~str {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n+        let listen_result = listen(move server_ip_addr, server_port, 128,\n+                                   iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n                 log(debug, fmt!(\"establish_cb %?\",\n@@ -1574,7 +1575,8 @@ mod test {\n     fn run_tcp_test_server_fail(server_ip: ~str, server_port: uint,\n                           iotask: IoTask) -> TcpListenErrData {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n+        let listen_result = listen(move server_ip_addr, server_port, 128,\n+                                   iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n                 log(debug, fmt!(\"establish_cb %?\",\n@@ -1600,7 +1602,8 @@ mod test {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n         log(debug, ~\"CLIENT: starting..\");\n-        let connect_result = connect(server_ip_addr, server_port, iotask);\n+        let connect_result = connect(move server_ip_addr, server_port,\n+                                     iotask);\n         if result::is_err(connect_result) {\n             log(debug, ~\"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);"}, {"sha": "4e7eaeccf9d8a541e2d02b5e03e3d3d0dfb69144", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -814,11 +814,11 @@ mod node {\n                     offset += 1u;\n                     i      += 1u;\n                 }\n-                unsafe::forget(local_buf);\n+                unsafe::forget(move local_buf);\n               }\n             }\n         }\n-        return unsafe::transmute(buf);\n+        return unsafe::transmute(move buf);\n     }\n \n     /**"}, {"sha": "f7cdfd60f50e4eb1ef51c36beef038f80a780455", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -253,7 +253,7 @@ fn sha1() -> Sha1 {\n         mut computed: false,\n         work_buf: @vec::to_mut(vec::from_elem(work_buf_len, 0u32))\n     };\n-    let sh <- st as Sha1;\n+    let sh = (move st) as Sha1;\n     sh.reset();\n     return sh;\n }"}, {"sha": "9a1760134744a5d675860a771370a7275cf538c1", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -108,7 +108,7 @@ impl<Q: Send> &Sem<Q> {\n         /* for 1000.times { task::yield(); } */\n         // Need to wait outside the exclusive.\n         if waiter_nobe.is_some() {\n-            let _ = pipes::recv_one(option::unwrap(waiter_nobe));\n+            let _ = pipes::recv_one(option::unwrap(move waiter_nobe));\n         }\n     }\n     fn release() {"}, {"sha": "b1f03f713d8ca9b1a6eb8adfd421fc7fb47d66a3", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -401,7 +401,7 @@ fn run_test(+test: TestDesc, monitor_ch: comm::Chan<MonitorMsg>) {\n         task::task().unlinked().future_result(|+r| {\n             result_future = Some(move r);\n         }).spawn(move testfn);\n-        let task_result = future::get(&option::unwrap(result_future));\n+        let task_result = future::get(&option::unwrap(move result_future));\n         let test_result = calc_result(test, task_result == task::Success);\n         comm::send(monitor_ch, (copy test, test_result));\n     };"}, {"sha": "34f5c28ba958c359522ae12e2522c5979c632b29", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c087886e9321d6086ed3a623ec571da35fb865bf/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=c087886e9321d6086ed3a623ec571da35fb865bf", "patch": "@@ -104,7 +104,7 @@ fn spawn_loop() -> IoTask {\n             }\n         }\n     };\n-    spawn_iotask(builder)\n+    spawn_iotask(move builder)\n }\n \n #[cfg(test)]"}]}