{"sha": "f30f54e9d062bdb5b3cb10dd7185470280c1c278", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMGY1NGU5ZDA2MmJkYjViM2NiMTBkZDcxODU0NzAyODBjMWMyNzg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-24T08:29:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-29T21:30:55Z"}, "message": "librustc: Remove the concept of modes from the compiler.\n\nThis commit does not remove `ty::arg`, although that should be\npossible to do now.", "tree": {"sha": "b641e10eb9ee445b023d9d9b69ea8330c41ca30b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b641e10eb9ee445b023d9d9b69ea8330c41ca30b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f30f54e9d062bdb5b3cb10dd7185470280c1c278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f30f54e9d062bdb5b3cb10dd7185470280c1c278", "html_url": "https://github.com/rust-lang/rust/commit/f30f54e9d062bdb5b3cb10dd7185470280c1c278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f30f54e9d062bdb5b3cb10dd7185470280c1c278/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a12a3db5b44d539f5512376a2e7bb40fbab63683", "url": "https://api.github.com/repos/rust-lang/rust/commits/a12a3db5b44d539f5512376a2e7bb40fbab63683", "html_url": "https://github.com/rust-lang/rust/commit/a12a3db5b44d539f5512376a2e7bb40fbab63683"}], "stats": {"total": 1640, "additions": 557, "deletions": 1083}, "files": [{"sha": "8e689f3147b6b5f6ff7cad29a779b63604ece76e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -128,7 +128,6 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_freevars = 0x59,\n     tag_table_tcache = 0x5a,\n     tag_table_param_defs = 0x5b,\n-    tag_table_inferred_modes = 0x5c,\n     tag_table_mutbl = 0x5d,\n     tag_table_last_use = 0x5e,\n     tag_table_spill = 0x5f,"}, {"sha": "cfe31360d321b20a141d4cee4d0392ca0f29211e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -244,8 +244,8 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n     }\n }\n \n-pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n-                 tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+pub fn item_type(_: ast::def_id, item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n+                 -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n "}, {"sha": "011ee115e8c1521f3f6d5eb1804723dc45e155dd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -469,16 +469,9 @@ fn parse_onceness(c: char) -> ast::Onceness {\n }\n \n fn parse_arg(st: @mut PState, conv: conv_did) -> ty::arg {\n-    ty::arg { mode: parse_mode(st), ty: parse_ty(st, conv) }\n-}\n-\n-fn parse_mode(st: @mut PState) -> ast::mode {\n-    let m = ast::expl(match next(st) {\n-        '+' => ast::by_copy,\n-        '=' => ast::by_ref,\n-        _ => fail!(~\"bad mode\")\n-    });\n-    return m;\n+    ty::arg {\n+        ty: parse_ty(st, conv)\n+    }\n }\n \n fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n@@ -511,8 +504,7 @@ fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n     assert!((next(st) == '['));\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n-        let mode = parse_mode(st);\n-        inputs.push(ty::arg { mode: mode, ty: parse_ty(st, conv) });\n+        inputs.push(ty::arg { ty: parse_ty(st, conv) });\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);"}, {"sha": "763b1984b81c86dbfdfcb5e46f21782b1cfa3872", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -344,17 +344,9 @@ fn enc_sigil(w: @io::Writer, sigil: Sigil) {\n }\n \n pub fn enc_arg(w: @io::Writer, cx: @ctxt, arg: ty::arg) {\n-    enc_mode(w, cx, arg.mode);\n     enc_ty(w, cx, arg.ty);\n }\n \n-pub fn enc_mode(w: @io::Writer, cx: @ctxt, m: mode) {\n-    match ty::resolved_mode(cx.tcx, m) {\n-      by_copy => w.write_char('+'),\n-      by_ref => w.write_char('='),\n-    }\n-}\n-\n fn enc_purity(w: @io::Writer, p: purity) {\n     match p {\n       pure_fn => w.write_char('p'),"}, {"sha": "c7c9c110586c7dadc950242a08d7e46f145a9ae7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -410,7 +410,7 @@ impl tr for ast::def {\n           ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n           ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n           ast::def_const(did) => { ast::def_const(did.tr(xcx)) }\n-          ast::def_arg(nid, m, b) => { ast::def_arg(xcx.tr_id(nid), m, b) }\n+          ast::def_arg(nid, b) => { ast::def_arg(xcx.tr_id(nid), b) }\n           ast::def_local(nid, b) => { ast::def_local(xcx.tr_id(nid), b) }\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n@@ -571,6 +571,9 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n         do ebml_w.emit_field(~\"origin\", 1u) {\n             mme.origin.encode(ebml_w);\n         }\n+        do ebml_w.emit_field(~\"self_mode\", 3) {\n+            mme.self_mode.encode(ebml_w);\n+        }\n     }\n }\n \n@@ -590,6 +593,9 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n         do ebml_w.emit_struct_field(\"origin\", 1u) {\n             mme.origin.encode(ebml_w);\n         }\n+        do ebml_w.emit_struct_field(\"self_mode\", 3) {\n+            mme.self_mode.encode(ebml_w);\n+        }\n     }\n }\n \n@@ -611,6 +617,10 @@ impl read_method_map_entry_helper for reader::Decoder {\n                         Decodable::decode(self);\n                     method_origin.tr(xcx)\n                 }),\n+                self_mode: self.read_field(~\"self_mode\", 3, || {\n+                    let self_mode: ty::SelfMode = Decodable::decode(self);\n+                    self_mode\n+                }),\n             }\n         }\n     }\n@@ -625,7 +635,7 @@ impl read_method_map_entry_helper for reader::Decoder {\n                 self_arg: self.read_struct_field(\"self_arg\", 0u, || {\n                     self.read_arg(xcx)\n                 }),\n-                explicit_self: self.read_struct_field(\"explicit_self\", 2u, || {\n+                explicit_self: self.read_struct_field(\"explicit_self\", 2, || {\n                     let self_type: ast::self_ty_ = Decodable::decode(self);\n                     self_type\n                 }),\n@@ -634,6 +644,10 @@ impl read_method_map_entry_helper for reader::Decoder {\n                         Decodable::decode(self);\n                     method_origin.tr(xcx)\n                 }),\n+                self_mode: self.read_struct_field(\"self_mode\", 3, || {\n+                    let self_mode: ty::SelfMode = Decodable::decode(self);\n+                    self_mode\n+                }),\n             }\n         }\n     }\n@@ -978,20 +992,6 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    // I believe it is not necessary to encode this information.  The\n-    // ids will appear in the AST but in the *type* information, which\n-    // is what we actually use in trans, all modes will have been\n-    // resolved.\n-    //\n-    //for tcx.inferred_modes.find(&id).each |m| {\n-    //    ebml_w.tag(c::tag_table_inferred_modes) {||\n-    //        ebml_w.id(id);\n-    //        ebml_w.tag(c::tag_table_val) {||\n-    //            tyencode::enc_mode(ebml_w.writer, ty_str_ctxt(), m);\n-    //        }\n-    //    }\n-    //}\n-\n     if maps.mutbl_map.contains(&id) {\n         do ebml_w.tag(c::tag_table_mutbl) {\n             ebml_w.id(id);"}, {"sha": "e40d0e63eb38eab0bd03d5fb44af06f48ae698ec", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -147,38 +147,6 @@ fn req_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, self, vt);\n       }\n \n-      ast::expr_call(f, ref args, _) => {\n-        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n-        let scope_r = ty::re_scope(ex.id);\n-        for vec::each2(*args, arg_tys) |arg, arg_ty| {\n-            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-                ast::by_ref => {\n-                    let arg_cmt = self.bccx.cat_expr(*arg);\n-                    self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n-                }\n-                ast::by_copy => {}\n-            }\n-        }\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      ast::expr_method_call(_, _, _, ref args, _) => {\n-        let arg_tys = ty::ty_fn_args(ty::node_id_to_type(self.tcx(),\n-                                                         ex.callee_id));\n-        let scope_r = ty::re_scope(ex.id);\n-        for vec::each2(*args, arg_tys) |arg, arg_ty| {\n-            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-                ast::by_ref => {\n-                    let arg_cmt = self.bccx.cat_expr(*arg);\n-                    self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n-                }\n-                ast::by_copy => {}\n-            }\n-        }\n-\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n       ast::expr_match(ex_v, ref arms) => {\n         let cmt = self.bccx.cat_expr(ex_v);\n         for (*arms).each |arm| {"}, {"sha": "faf4b1c31061b72616de4c45f83ce43d31253032", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 153, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -19,7 +19,6 @@ use std::smallintmap::SmallIntMap;\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::print::pprust::mode_to_str;\n use syntax::{ast, visit};\n \n /**\n@@ -53,22 +52,18 @@ pub enum lint {\n     unrecognized_lint,\n     non_implicitly_copyable_typarams,\n     vecs_implicitly_copyable,\n-    deprecated_mode,\n     deprecated_pattern,\n     non_camel_case_types,\n     type_limits,\n     default_methods,\n     deprecated_mutable_fields,\n     deprecated_drop,\n     unused_unsafe,\n-    foreign_mode,\n \n     managed_heap_memory,\n     owned_heap_memory,\n     heap_memory,\n \n-    legacy_modes,\n-\n     unused_variable,\n     dead_assignment,\n     unused_mut,\n@@ -159,20 +154,6 @@ pub fn get_lint_dict() -> LintDict {\n             default: warn\n          }),\n \n-        (~\"deprecated_mode\",\n-         LintSpec {\n-            lint: deprecated_mode,\n-            desc: \"warn about deprecated uses of modes\",\n-            default: warn\n-         }),\n-\n-        (~\"foreign_mode\",\n-         LintSpec {\n-            lint: foreign_mode,\n-            desc: \"warn about deprecated uses of modes in foreign fns\",\n-            default: warn\n-         }),\n-\n         (~\"deprecated_pattern\",\n          LintSpec {\n             lint: deprecated_pattern,\n@@ -208,13 +189,6 @@ pub fn get_lint_dict() -> LintDict {\n             default: allow\n          }),\n \n-        (~\"legacy modes\",\n-         LintSpec {\n-            lint: legacy_modes,\n-            desc: \"allow legacy modes\",\n-            default: forbid\n-         }),\n-\n         (~\"type_limits\",\n          LintSpec {\n             lint: type_limits,\n@@ -486,7 +460,6 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_path_statement(cx, i);\n     check_item_non_camel_case_types(cx, i);\n     check_item_heap(cx, i);\n-    check_item_deprecated_modes(cx, i);\n     check_item_type_limits(cx, i);\n     check_item_default_methods(cx, i);\n     check_item_deprecated_mutable_fields(cx, i);\n@@ -719,20 +692,6 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n                         decl: &ast::fn_decl) {\n-        // warn about `&&` mode on foreign functions, both because it is\n-        // deprecated and because its semantics have changed recently:\n-        for decl.inputs.eachi |i, arg| {\n-            match ty::resolved_mode(cx, arg.mode) {\n-                ast::by_copy => {}\n-                ast::by_ref => {\n-                    cx.sess.span_lint(\n-                        foreign_mode, fn_id, fn_id, arg.ty.span,\n-                        fmt!(\"foreign function uses `&&` mode \\\n-                              on argument %u\", i));\n-                }\n-            }\n-        }\n-\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n@@ -995,119 +954,13 @@ fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n     visit::visit_item(it, (), visit);\n }\n \n-fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: &ast::fn_decl,\n-            _body: &ast::blk, span: span, id: ast::node_id) {\n+fn check_fn(_: ty::ctxt,\n+            fk: &visit::fn_kind,\n+            _: &ast::fn_decl,\n+            _: &ast::blk,\n+            _: span,\n+            id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n-\n-    // Check for deprecated modes\n-    match *fk {\n-        // don't complain about blocks, since they tend to get their modes\n-        // specified from the outside\n-        visit::fk_fn_block(*) => {}\n-\n-        _ => {\n-            let fn_ty = ty::node_id_to_type(tcx, id);\n-            check_fn_deprecated_modes(tcx, fn_ty, decl, span, id);\n-        }\n-    }\n-\n-}\n-\n-fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: &ast::fn_decl,\n-                             span: span, id: ast::node_id) {\n-    match ty::get(fn_ty).sty {\n-        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) |\n-        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) => {\n-            let mut counter = 0;\n-            for vec::each2(sig.inputs, decl.inputs) |arg_ty, arg_ast| {\n-                counter += 1;\n-                debug!(\"arg %d, ty=%s, mode=%s\",\n-                       counter,\n-                       ty_to_str(tcx, arg_ty.ty),\n-                       mode_to_str(arg_ast.mode));\n-                match arg_ast.mode {\n-                    ast::expl(ast::by_copy) => {\n-                        if !tcx.legacy_modes {\n-                            tcx.sess.span_lint(\n-                                deprecated_mode, id, id, span,\n-                                fmt!(\"argument %d uses by-copy mode\",\n-                                     counter));\n-                        }\n-                    }\n-\n-                    ast::expl(_) => {\n-                        tcx.sess.span_lint(\n-                            deprecated_mode, id, id,\n-                            span,\n-                         fmt!(\"argument %d uses an explicit mode\", counter));\n-                    }\n-\n-                    ast::infer(_) => {\n-                        if tcx.legacy_modes {\n-                            let kind = ty::type_contents(tcx, arg_ty.ty);\n-                            if !kind.is_safe_for_default_mode(tcx) {\n-                                tcx.sess.span_lint(\n-                                    deprecated_mode, id, id,\n-                                    span,\n-                                    fmt!(\"argument %d uses the default mode \\\n-                                          but shouldn't\",\n-                                         counter));\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                match ty::get(arg_ty.ty).sty {\n-                    ty::ty_closure(*) | ty::ty_bare_fn(*) => {\n-                        let span = arg_ast.ty.span;\n-                        // Recurse to check fn-type argument\n-                        match arg_ast.ty.node {\n-                            ast::ty_closure(@ast::TyClosure{decl: ref d, _}) |\n-                            ast::ty_bare_fn(@ast::TyBareFn{decl: ref d, _})=>{\n-                                check_fn_deprecated_modes(tcx, arg_ty.ty,\n-                                                          d, span, id);\n-                            }\n-                            ast::ty_path(*) => {\n-                                // This is probably a typedef, so we can't\n-                                // see the actual fn decl\n-                                // e.g. fn foo(f: InitOp<T>)\n-                            }\n-                            _ => {\n-                                tcx.sess.span_warn(span, ~\"what\");\n-                                error!(\"arg %d, ty=%s, mode=%s\",\n-                                       counter,\n-                                       ty_to_str(tcx, arg_ty.ty),\n-                                       mode_to_str(arg_ast.mode));\n-                                error!(\"%?\",arg_ast.ty.node);\n-                                fail!()\n-                            }\n-                        };\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-\n-        _ => tcx.sess.impossible_case(span, ~\"check_fn: function has \\\n-                                              non-fn type\")\n-    }\n-}\n-\n-fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n-    match it.node {\n-        ast::item_ty(ty, _) => {\n-            match ty.node {\n-                ast::ty_closure(@ast::TyClosure {decl: ref decl, _}) |\n-                ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n-                    let fn_ty = ty::node_id_to_type(tcx, it.id);\n-                    check_fn_deprecated_modes(\n-                        tcx, fn_ty, decl, ty.span, it.id)\n-                }\n-                _ => ()\n-            }\n-        }\n-        _ => ()\n-    }\n }\n \n pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {"}, {"sha": "94d82d0acb8e4eaf5c90d65cafb1dc06edecb378", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 32, "deletions": 61, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -236,19 +236,19 @@ struct LocalInfo {\n }\n \n enum VarKind {\n-    Arg(node_id, ident, rmode),\n+    Arg(node_id, ident),\n     Local(LocalInfo),\n     ImplicitRet\n }\n \n fn relevant_def(def: def) -> Option<node_id> {\n     match def {\n-      def_binding(nid, _) |\n-      def_arg(nid, _, _) |\n-      def_local(nid, _) |\n-      def_self(nid, _) => Some(nid),\n+        def_binding(nid, _) |\n+        def_arg(nid, _) |\n+        def_local(nid, _) |\n+        def_self(nid, _) => Some(nid),\n \n-      _ => None\n+        _ => None\n     }\n }\n \n@@ -321,10 +321,9 @@ pub impl IrMaps {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo {id:node_id, _}) |\n-            Arg(node_id, _, _) => {\n+            Local(LocalInfo { id: node_id, _ }) | Arg(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n-            }\n+            },\n             ImplicitRet => {}\n         }\n \n@@ -345,8 +344,9 @@ pub impl IrMaps {\n \n     fn variable_name(&mut self, var: Variable) -> @~str {\n         match self.var_kinds[*var] {\n-            Local(LocalInfo {ident: nm, _}) |\n-            Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n+            Local(LocalInfo { ident: nm, _ }) | Arg(_, nm) => {\n+                self.tcx.sess.str_of(nm)\n+            },\n             ImplicitRet => @~\"<implicit-ret>\"\n         }\n     }\n@@ -372,25 +372,22 @@ pub impl IrMaps {\n         let vk = self.var_kinds[*var];\n         debug!(\"Node %d is a last use of variable %?\", expr_id, vk);\n         match vk {\n-          Arg(id, _, by_copy) |\n-          Local(LocalInfo {id: id, kind: FromLetNoInitializer, _}) |\n-          Local(LocalInfo {id: id, kind: FromLetWithInitializer, _}) |\n-          Local(LocalInfo {id: id, kind: FromMatch(_), _}) => {\n-            let v = match self.last_use_map.find(&expr_id) {\n-              Some(&v) => v,\n-              None => {\n-                let v = @mut ~[];\n-                self.last_use_map.insert(expr_id, v);\n-                v\n-              }\n-            };\n+            Arg(id, _) |\n+            Local(LocalInfo { id: id, kind: FromLetNoInitializer, _ }) |\n+            Local(LocalInfo { id: id, kind: FromLetWithInitializer, _ }) |\n+            Local(LocalInfo { id: id, kind: FromMatch(_), _ }) => {\n+                let v = match self.last_use_map.find(&expr_id) {\n+                    Some(&v) => v,\n+                    None => {\n+                        let v = @mut ~[];\n+                        self.last_use_map.insert(expr_id, v);\n+                        v\n+                    }\n+                };\n \n-            v.push(id);\n-          }\n-          Arg(_, _, by_ref) |\n-          ImplicitRet => {\n-            debug!(\"--but it is not owned\");\n-          }\n+                v.push(id);\n+            }\n+            ImplicitRet => debug!(\"--but it is not owned\"),\n         }\n     }\n }\n@@ -424,12 +421,11 @@ fn visit_fn(fk: &visit::fn_kind,\n     }\n \n     for decl.inputs.each |arg| {\n-        let mode = ty::resolved_mode(self.tcx, arg.mode);\n         do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n             debug!(\"adding argument %d\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n-            fn_maps.add_variable(Arg(arg_id, ident, mode));\n+            fn_maps.add_variable(Arg(arg_id, ident));\n         }\n     };\n \n@@ -439,16 +435,13 @@ fn visit_fn(fk: &visit::fn_kind,\n             match method.self_ty.node {\n                 sty_value | sty_region(*) | sty_box(_) | sty_uniq(_) => {\n                     fn_maps.add_variable(Arg(method.self_id,\n-                                             special_idents::self_,\n-                                             by_copy));\n+                                             special_idents::self_));\n                 }\n                 sty_static => {}\n             }\n         }\n         fk_dtor(_, _, self_id, _) => {\n-            fn_maps.add_variable(Arg(self_id,\n-                                     special_idents::self_,\n-                                     by_copy));\n+            fn_maps.add_variable(Arg(self_id, special_idents::self_));\n         }\n         fk_item_fn(*) | fk_anon(*) | fk_fn_block(*) => {}\n     }\n@@ -973,30 +966,8 @@ pub impl Liveness {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&self, decl: &fn_decl, blk: &blk)\n-                                 -> LiveNode {\n-        // inputs passed by & mode should be considered live on exit:\n-        for decl.inputs.each |arg| {\n-            match ty::resolved_mode(self.tcx, arg.mode) {\n-                by_ref => {\n-                    // By val and by ref do not own, so register a\n-                    // read at the end.  This will prevent us from\n-                    // moving out of such variables but also prevent\n-                    // us from registering last uses and so forth.\n-                    do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n-                        |_bm, arg_id, _sp, _path|\n-                    {\n-                        let var = self.variable(arg_id, blk.span);\n-                        self.acc(self.s.exit_ln, var, ACC_READ);\n-                    }\n-                }\n-                by_copy => {\n-                    // By copy is an owned mode.  If we don't use the\n-                    // variable, nobody will.\n-                }\n-            }\n-        }\n-\n+    fn propagate_through_fn_block(&self, _: &fn_decl, blk: &blk)\n+                                  -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n         self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n@@ -1771,7 +1742,7 @@ pub impl Liveness {\n             // borrow checker\n             let vk = self.ir.var_kinds[*var];\n             match vk {\n-              Arg(_, name, _) => {\n+              Arg(_, name) => {\n                 self.tcx.sess.span_err(\n                     move_expr.span,\n                     fmt!(\"illegal move from argument `%s`, which is not \\"}, {"sha": "31cb39bc231b94a2d040e6c184691f9db48f184e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -482,17 +482,14 @@ pub impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::def_arg(vid, mode, mutbl) => {\n+          ast::def_arg(vid, mutbl) => {\n             // Idea: make this could be rewritten to model by-ref\n             // stuff as `&const` and `&mut`?\n \n             // m: mutability of the argument\n             // lp: loan path, must be none for aliasable things\n             let m = if mutbl {McDeclared} else {McImmutable};\n-            let lp = match ty::resolved_mode(self.tcx, mode) {\n-                ast::by_copy => Some(@lp_arg(vid)),\n-                ast::by_ref => None,\n-            };\n+            let lp = Some(@lp_arg(vid));\n             @cmt_ {\n                 id:id,\n                 span:span,"}, {"sha": "fe1466bf808a372d99f985943eee75c6ba581b82", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -718,41 +718,22 @@ pub impl VisitContext {\n                     receiver_expr: @expr,\n                     visitor: vt<VisitContext>)\n     {\n-        self.use_fn_arg(by_copy, receiver_expr, visitor);\n+        self.use_fn_arg(receiver_expr, visitor);\n     }\n \n     fn use_fn_args(&self,\n-                   callee_id: node_id,\n+                   _: node_id,\n                    arg_exprs: &[@expr],\n-                   visitor: vt<VisitContext>)\n-    {\n-        /*!\n-         *\n-         * Uses the argument expressions according to the function modes.\n-         */\n-\n-        let arg_tys =\n-            ty::ty_fn_args(ty::node_id_to_type(self.tcx, callee_id));\n-        for vec::each2(arg_exprs, arg_tys) |arg_expr, arg_ty| {\n-            let arg_mode = ty::resolved_mode(self.tcx, arg_ty.mode);\n-            self.use_fn_arg(arg_mode, *arg_expr, visitor);\n+                   visitor: vt<VisitContext>) {\n+        //! Uses the argument expressions.\n+        for arg_exprs.each |arg_expr| {\n+            self.use_fn_arg(*arg_expr, visitor);\n         }\n     }\n \n-    fn use_fn_arg(&self,\n-                  arg_mode: rmode,\n-                  arg_expr: @expr,\n-                  visitor: vt<VisitContext>)\n-    {\n-        /*!\n-         *\n-         * Uses the argument according to the given argument mode.\n-         */\n-\n-        match arg_mode {\n-            by_ref => self.use_expr(arg_expr, Read, visitor),\n-            by_copy => self.consume_expr(arg_expr, visitor)\n-        }\n+    fn use_fn_arg(&self, arg_expr: @expr, visitor: vt<VisitContext>) {\n+        //! Uses the argument.\n+        self.consume_expr(arg_expr, visitor)\n     }\n \n     fn arms_have_by_move_bindings(&self,"}, {"sha": "681c38633273c2286cfdd1bfc856007d4072bf9d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -42,7 +42,7 @@ use syntax::ast::Generics;\n use syntax::ast::{gt, ident, inherited, item, item_struct};\n use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n-use syntax::ast::{local, local_crate, lt, method, mode, mul};\n+use syntax::ast::{local, local_crate, lt, method, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n@@ -123,7 +123,7 @@ pub struct Export2 {\n pub enum PatternBindingMode {\n     RefutableMode,\n     LocalIrrefutableMode,\n-    ArgumentIrrefutableMode(mode)\n+    ArgumentIrrefutableMode,\n }\n \n #[deriving(Eq)]\n@@ -3708,8 +3708,7 @@ pub impl Resolver {\n                 }\n                 Some(declaration) => {\n                     for declaration.inputs.each |argument| {\n-                        let binding_mode =\n-                            ArgumentIrrefutableMode(argument.mode);\n+                        let binding_mode = ArgumentIrrefutableMode;\n                         let mutability =\n                             if argument.is_mutbl {Mutable} else {Immutable};\n                         self.resolve_pattern(argument.pat,\n@@ -4184,10 +4183,9 @@ pub impl Resolver {\n                                     // But for locals, we use `def_local`.\n                                     def_local(pattern.id, is_mutable)\n                                 }\n-                                ArgumentIrrefutableMode(argument_mode) => {\n+                                ArgumentIrrefutableMode => {\n                                     // And for function arguments, `def_arg`.\n-                                    def_arg(pattern.id, argument_mode,\n-                                            is_mutable)\n+                                    def_arg(pattern.id, is_mutable)\n                                 }\n                             };\n "}, {"sha": "9c84b2a418232a8f0a46a7890c9cad0f2cbfd773", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -33,11 +33,16 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         constraints.push(copy *c);\n \n         let aoutty = ty::arg {\n-            mode: ast::expl(ast::by_copy),\n             ty: expr_ty(bcx, out)\n         };\n         aoutputs.push(unpack_result!(bcx, {\n-            callee::trans_arg_expr(bcx, aoutty, out, &mut cleanups, None, callee::DontAutorefArg)\n+            callee::trans_arg_expr(bcx,\n+                                   aoutty,\n+                                   ty::ByCopy,\n+                                   out,\n+                                   &mut cleanups,\n+                                   None,\n+                                   callee::DontAutorefArg)\n         }));\n \n         let e = match out.node {\n@@ -46,12 +51,17 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         };\n \n         let outty = ty::arg {\n-            mode: ast::expl(ast::by_copy),\n             ty: expr_ty(bcx, e)\n         };\n \n         unpack_result!(bcx, {\n-            callee::trans_arg_expr(bcx, outty, e, &mut cleanups, None, callee::DontAutorefArg)\n+            callee::trans_arg_expr(bcx,\n+                                   outty,\n+                                   ty::ByCopy,\n+                                   e,\n+                                   &mut cleanups,\n+                                   None,\n+                                   callee::DontAutorefArg)\n         })\n \n     };\n@@ -66,12 +76,17 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         constraints.push(copy *c);\n \n         let inty = ty::arg {\n-            mode: ast::expl(ast::by_copy),\n             ty: expr_ty(bcx, in)\n         };\n \n         unpack_result!(bcx, {\n-            callee::trans_arg_expr(bcx, inty, in, &mut cleanups, None, callee::DontAutorefArg)\n+            callee::trans_arg_expr(bcx,\n+                                   inty,\n+                                   ty::ByCopy,\n+                                   in,\n+                                   &mut cleanups,\n+                                   None,\n+                                   callee::DontAutorefArg)\n         })\n \n     };"}, {"sha": "efa10dfc2aa34db55b5e887c09e5eed3d03767db", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -1728,7 +1728,6 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n                             raw_llargs: &[ValueRef],\n                             arg_tys: &[ty::arg]) -> block {\n     let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n-    let tcx = bcx.tcx();\n     let mut bcx = bcx;\n \n     match fcx.llself {\n@@ -1757,24 +1756,16 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         // the argument would be passed by value, we store it into an alloca.\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n-        let llarg;\n-        match ty::resolved_mode(tcx, arg_ty.mode) {\n-            ast::by_ref => {\n-                llarg = raw_llarg;\n-            }\n-            ast::by_copy => {\n-                // only by value if immediate:\n-                if datum::appropriate_mode(arg_ty.ty).is_by_value() {\n-                    let alloc = alloc_ty(bcx, arg_ty.ty);\n-                    Store(bcx, raw_llarg, alloc);\n-                    llarg = alloc;\n-                } else {\n-                    llarg = raw_llarg;\n-                }\n+        // only by value if immediate:\n+        let llarg = if datum::appropriate_mode(arg_ty.ty).is_by_value() {\n+            let alloc = alloc_ty(bcx, arg_ty.ty);\n+            Store(bcx, raw_llarg, alloc);\n+            alloc\n+        } else {\n+            raw_llarg\n+        };\n \n-                add_clean(bcx, llarg, arg_ty.ty);\n-            }\n-        }\n+        add_clean(bcx, llarg, arg_ty.ty);\n \n         bcx = _match::bind_irrefutable_pat(bcx,\n                                           args[arg_n].pat,\n@@ -1966,7 +1957,6 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n     // Translate variant arguments to function arguments.\n     let fn_args = do args.map |varg| {\n         ast::arg {\n-            mode: ast::expl(ast::by_copy),\n             is_mutbl: false,\n             ty: varg.ty,\n             pat: ast_util::ident_to_pat(\n@@ -2041,7 +2031,6 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     // Translate struct fields to function arguments.\n     let fn_args = do fields.map |field| {\n         ast::arg {\n-            mode: ast::expl(ast::by_copy),\n             is_mutbl: false,\n             ty: field.node.ty,\n             pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n@@ -2408,8 +2397,8 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n             } else {\n                 let start_fn_type = csearch::get_type(ccx.tcx,\n                                                       start_def_id).ty;\n-                trans_external_path(ccx, start_def_id, start_fn_type)\n-            };\n+                trans_external_path(ccx, start_def_id, start_fn_type);\n+            }\n \n             let retptr = llvm::LLVMBuildAlloca(bld, T_i8(), noname());\n "}, {"sha": "ad0fea3b4b4aff0405c2db7c0411bd0d21f08f08", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -57,7 +57,7 @@ pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n     self_ty: ty::t,\n-    self_mode: ast::rmode\n+    self_mode: ty::SelfMode,\n }\n \n pub enum CalleeData {\n@@ -378,10 +378,20 @@ pub fn trans_lang_call(bcx: block,\n         csearch::get_type(bcx.ccx().tcx, did).ty\n     };\n     let rty = ty::ty_fn_ret(fty);\n-    return callee::trans_call_inner(\n-        bcx, None, fty, rty,\n-        |bcx| trans_fn_ref_with_vtables_to_callee(bcx, did, 0, ~[], None),\n-        ArgVals(args), dest, DontAutorefArg);\n+    callee::trans_call_inner(bcx,\n+                             None,\n+                             fty,\n+                             rty,\n+                             |bcx| {\n+                                trans_fn_ref_with_vtables_to_callee(bcx,\n+                                                                    did,\n+                                                                    0,\n+                                                                    ~[],\n+                                                                    None)\n+                             },\n+                             ArgVals(args),\n+                             dest,\n+                             DontAutorefArg)\n }\n \n pub fn trans_lang_call_with_type_params(bcx: block,\n@@ -483,7 +493,8 @@ pub fn trans_call_inner(in_cx: block,\n                 }\n                 Method(d) => {\n                     // Weird but true: we pass self in the *environment* slot!\n-                    let llself = PointerCast(bcx, d.llself,\n+                    let llself = PointerCast(bcx,\n+                                             d.llself,\n                                              T_opaque_box_ptr(ccx));\n                     (d.llfn, llself)\n                 }\n@@ -520,7 +531,7 @@ pub fn trans_call_inner(in_cx: block,\n         // Now that the arguments have finished evaluating, we need to revoke\n         // the cleanup for the self argument, if it exists\n         match callee.data {\n-            Method(d) if d.self_mode == ast::by_copy => {\n+            Method(d) if d.self_mode == ty::ByCopy => {\n                 revoke_clean(bcx, d.llself);\n             }\n             _ => {}\n@@ -629,7 +640,11 @@ pub fn trans_args(cx: block,\n         let last = arg_exprs.len() - 1u;\n         for vec::eachi(arg_exprs) |i, arg_expr| {\n             let arg_val = unpack_result!(bcx, {\n-                trans_arg_expr(bcx, arg_tys[i], *arg_expr, &mut temp_cleanups,\n+                trans_arg_expr(bcx,\n+                               arg_tys[i],\n+                               ty::ByCopy,\n+                               *arg_expr,\n+                               &mut temp_cleanups,\n                                if i == last { ret_flag } else { None },\n                                autoref_arg)\n             });\n@@ -660,17 +675,18 @@ pub enum AutorefArg {\n // call takes place:\n pub fn trans_arg_expr(bcx: block,\n                       formal_ty: ty::arg,\n+                      self_mode: ty::SelfMode,\n                       arg_expr: @ast::expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       ret_flag: Option<ValueRef>,\n                       autoref_arg: AutorefArg) -> Result {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_ty=(%?,%s), arg_expr=%s, \\\n+    debug!(\"trans_arg_expr(formal_ty=(%s), self_mode=%?, arg_expr=%s, \\\n             ret_flag=%?)\",\n-           formal_ty.mode,\n            formal_ty.ty.repr(bcx.tcx()),\n+           self_mode,\n            arg_expr.repr(bcx.tcx()),\n            ret_flag.map(|v| bcx.val_str(*v)));\n     let _indenter = indenter();\n@@ -686,8 +702,7 @@ pub fn trans_arg_expr(bcx: block,\n                     blk @ @ast::expr {\n                         node: ast::expr_fn_block(ref decl, ref body),\n                         _\n-                    }) =>\n-                {\n+                    }) => {\n                     let scratch_ty = expr_ty(bcx, arg_expr);\n                     let scratch = alloc_ty(bcx, scratch_ty);\n                     let arg_ty = expr_ty(bcx, arg_expr);\n@@ -714,8 +729,6 @@ pub fn trans_arg_expr(bcx: block,\n \n     debug!(\"   arg datum: %s\", arg_datum.to_str(bcx.ccx()));\n \n-    // finally, deal with the various modes\n-    let arg_mode = ty::resolved_mode(ccx.tcx, formal_ty.mode);\n     let mut val;\n     if ty::type_is_bot(arg_datum.ty) {\n         // For values of type _|_, we generate an\n@@ -735,24 +748,27 @@ pub fn trans_arg_expr(bcx: block,\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n-                match arg_mode {\n-                    ast::by_ref => {\n+                match self_mode {\n+                    ty::ByRef => {\n                         // This assertion should really be valid, but because\n                         // the explicit self code currently passes by-ref, it\n                         // does not hold.\n                         //\n                         //assert !bcx.ccx().maps.moves_map.contains_key(\n                         //    &arg_expr.id);\n+                        debug!(\"by ref arg with type %s\",\n+                               bcx.ty_to_str(arg_datum.ty));\n                         val = arg_datum.to_ref_llval(bcx);\n                     }\n-\n-                    ast::by_copy => {\n+                    ty::ByCopy => {\n                         debug!(\"by copy arg with type %s, storing to scratch\",\n                                bcx.ty_to_str(arg_datum.ty));\n                         let scratch = scratch_datum(bcx, arg_datum.ty, false);\n \n-                        arg_datum.store_to_datum(bcx, arg_expr.id,\n-                                                 INIT, scratch);\n+                        arg_datum.store_to_datum(bcx,\n+                                                 arg_expr.id,\n+                                                 INIT,\n+                                                 scratch);\n \n                         // Technically, ownership of val passes to the callee.\n                         // However, we must cleanup should we fail before the\n@@ -761,12 +777,8 @@ pub fn trans_arg_expr(bcx: block,\n                         temp_cleanups.push(scratch.val);\n \n                         match arg_datum.appropriate_mode() {\n-                            ByValue => {\n-                                val = Load(bcx, scratch.val);\n-                            }\n-                            ByRef => {\n-                                val = scratch.val;\n-                            }\n+                            ByValue => val = Load(bcx, scratch.val),\n+                            ByRef => val = scratch.val,\n                         }\n                     }\n                 }\n@@ -776,6 +788,10 @@ pub fn trans_arg_expr(bcx: block,\n         if formal_ty.ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n             let llformal_ty = type_of::type_of_explicit_arg(ccx, &formal_ty);\n+            let llformal_ty = match self_mode {\n+                ty::ByRef => T_ptr(llformal_ty),\n+                ty::ByCopy => llformal_ty,\n+            };\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n                    bcx.val_str(val), bcx.llty_str(llformal_ty));\n             val = PointerCast(bcx, val, llformal_ty);"}, {"sha": "f83562add31691bd413e6a3253ef4078af56a625", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -1072,7 +1072,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n                 }\n             }\n         }\n-        ast::def_arg(nid, _, _) => {\n+        ast::def_arg(nid, _) => {\n             take_local(bcx, bcx.fcx.llargs, nid)\n         }\n         ast::def_local(nid, _) | ast::def_binding(nid, _) => {"}, {"sha": "587f13ad65ef051f8b8f61b5f1de64155b9dfbe8", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -791,10 +791,11 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 sigil: ast::BorrowedSigil,\n                 onceness: ast::Many,\n                 region: ty::re_bound(ty::br_anon(0)),\n-                sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n-                            inputs: ~[arg {mode: ast::expl(ast::by_copy),\n-                                           ty: star_u8}],\n-                            output: ty::mk_nil()}\n+                sig: FnSig {\n+                    bound_lifetime_names: opt_vec::Empty,\n+                    inputs: ~[ arg { ty: star_u8 } ],\n+                    output: ty::mk_nil()\n+                }\n             });\n             let datum = Datum {val: get_param(decl, first_real_arg),\n                                mode: ByRef, ty: fty, source: ZeroMem};"}, {"sha": "90f9f93be2b48f1763e20c0d5d0c1fcef65c24a2", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -145,14 +145,18 @@ pub fn trans_self_arg(bcx: block,\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let mut temp_cleanups = ~[];\n \n-    // Compute the mode and type of self.\n+    // Compute the type of self.\n     let self_arg = arg {\n-        mode: mentry.self_arg.mode,\n         ty: monomorphize_type(bcx, mentry.self_arg.ty)\n     };\n \n-    let result = trans_arg_expr(bcx, self_arg, base,\n-                                &mut temp_cleanups, None, DontAutorefArg);\n+    let result = trans_arg_expr(bcx,\n+                                self_arg,\n+                                mentry.self_mode,\n+                                base,\n+                                &mut temp_cleanups,\n+                                None,\n+                                DontAutorefArg);\n \n     // FIXME(#3446)---this is wrong, actually.  The temp_cleanups\n     // should be revoked only after all arguments have been passed.\n@@ -224,14 +228,13 @@ pub fn trans_method_callee(bcx: block,\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n             let Result {bcx, val} = trans_self_arg(bcx, self, mentry);\n-            let tcx = bcx.tcx();\n             Callee {\n                 bcx: bcx,\n                 data: Method(MethodData {\n                     llfn: callee_fn.llfn,\n                     llself: val,\n                     self_ty: node_id_type(bcx, self.id),\n-                    self_mode: ty::resolved_mode(tcx, mentry.self_arg.mode)\n+                    self_mode: mentry.self_mode,\n                 })\n             }\n         }\n@@ -442,7 +445,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n                                   trait_id: ast::def_id,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n-                               -> Callee {\n+                                  -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n@@ -463,23 +466,25 @@ pub fn trans_monomorphized_callee(bcx: block,\n               bcx, mth_id, impl_did, callee_id, rcvr_origins);\n \n           // translate the function\n-          let callee = trans_fn_ref_with_vtables(\n-              bcx, mth_id, callee_id, callee_substs, Some(callee_origins));\n+          let callee = trans_fn_ref_with_vtables(bcx,\n+                                                 mth_id,\n+                                                 callee_id,\n+                                                 callee_substs,\n+                                                 Some(callee_origins));\n \n           // create a llvalue that represents the fn ptr\n           let fn_ty = node_id_type(bcx, callee_id);\n           let llfn_ty = T_ptr(type_of_fn_from_ty(ccx, fn_ty));\n           let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n \n           // combine the self environment with the rest\n-          let tcx = bcx.tcx();\n           Callee {\n               bcx: bcx,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n                   llself: llself_val,\n                   self_ty: node_id_type(bcx, base.id),\n-                  self_mode: ty::resolved_mode(tcx, mentry.self_arg.mode)\n+                  self_mode: mentry.self_mode,\n               })\n           }\n       }\n@@ -496,7 +501,7 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n                                     impl_did: ast::def_id,\n                                     callee_id: ast::node_id,\n                                     rcvr_substs: &[ty::t])\n-                                 -> ~[ty::t] {\n+                                    -> ~[ty::t] {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -668,7 +673,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             Store(bcx, llself, llscratch);\n             llself = llscratch;\n \n-            self_mode = ast::by_ref;\n+            self_mode = ty::ByRef;\n         }\n         ast::sty_box(_) => {\n             // Bump the reference count on the box.\n@@ -686,7 +691,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             Store(bcx, llself, llscratch);\n             llself = llscratch;\n \n-            self_mode = ast::by_ref;\n+            self_mode = ty::ByRef;\n         }\n         ast::sty_uniq(_) => {\n             // Pass the unique pointer.\n@@ -699,7 +704,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             Store(bcx, llself, llscratch);\n             llself = llscratch;\n \n-            self_mode = ast::by_ref;\n+            self_mode = ty::ByRef;\n         }\n     }\n "}, {"sha": "7e59f580a2c3ca612dfab2a6cf41362c20f7cab8", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -280,9 +280,15 @@ pub impl Reflector {\n \n             let make_get_disr = || {\n                 let sub_path = bcx.fcx.path + ~[path_name(special_idents::anon)];\n-                let sym = mangle_internal_name_by_path_and_seq(ccx, sub_path, ~\"get_disr\");\n-                let args = [ty::arg { mode: ast::expl(ast::by_copy),\n-                                      ty: opaqueptrty }];\n+                let sym = mangle_internal_name_by_path_and_seq(ccx,\n+                                                               sub_path,\n+                                                               ~\"get_disr\");\n+                let args = [\n+                    ty::arg {\n+                        ty: opaqueptrty\n+                    }\n+                ];\n+\n                 let llfty = type_of_fn(ccx, args, ty::mk_int());\n                 let llfdecl = decl_internal_cdecl_fn(ccx.llmod, sym, llfty);\n                 let arg = unsafe {\n@@ -347,13 +353,7 @@ pub impl Reflector {\n \n     fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n         for sig.inputs.eachi |i, arg| {\n-            let modeval = match arg.mode {\n-                ast::infer(_) => 0u,\n-                ast::expl(e) => match e {\n-                    ast::by_ref => 1u,\n-                    ast::by_copy => 5u\n-                }\n-            };\n+            let modeval = 5u;   // \"by copy\"\n             let extra = ~[self.c_uint(i),\n                          self.c_uint(modeval),\n                          self.c_tydesc(arg.ty)];"}, {"sha": "a842f91f0ed6e7fa951fcbfdd0a5b38261bbe31e", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -19,11 +19,8 @@ use util::ppaux;\n \n use syntax::ast;\n \n-pub fn arg_is_indirect(ccx: @CrateContext, arg: &ty::arg) -> bool {\n-    match ty::resolved_mode(ccx.tcx, arg.mode) {\n-        ast::by_copy => !ty::type_is_immediate(arg.ty),\n-        ast::by_ref => true\n-    }\n+pub fn arg_is_indirect(_: @CrateContext, arg: &ty::arg) -> bool {\n+    !ty::type_is_immediate(arg.ty)\n }\n \n pub fn type_of_explicit_arg(ccx: @CrateContext, arg: &ty::arg) -> TypeRef {"}, {"sha": "33145dd4334a5deed6eb5348dec95a9df2964fd9", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -78,12 +78,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n             for vec::each(sig.inputs) |arg| {\n-                match ty::resolved_mode(ccx.tcx, arg.mode) {\n-                    by_copy => {\n-                        type_needs(cx, use_repr, arg.ty);\n-                    }\n-                    by_ref => {}\n-                }\n+                type_needs(cx, use_repr, arg.ty);\n             }\n         }\n         _ => ()\n@@ -332,15 +327,9 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n       expr_call(f, _, _) => {\n-          for vec::each(\n-              ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id))\n-          ) |a| {\n-              match a.mode {\n-                  expl(by_copy) => {\n-                      type_needs(cx, use_repr, a.ty);\n-                  }\n-                  _ => ()\n-              }\n+          for vec::each(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx,\n+                                                           f.id))) |a| {\n+              type_needs(cx, use_repr, a.ty);\n           }\n       }\n       expr_method_call(rcvr, _, _, _, _) => {\n@@ -349,12 +338,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n \n         for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx,\n                                                e.callee_id)).each |a| {\n-          match a.mode {\n-              expl(by_copy) => {\n-                  type_needs(cx, use_repr, a.ty);\n-              }\n-              _ => ()\n-          }\n+            type_needs(cx, use_repr, a.ty);\n         }\n         mark_for_method_call(cx, e.id, e.callee_id);\n       }"}, {"sha": "c7fb1e94adf4cea2f010d754d12ea81c35bc441a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 127, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -38,7 +38,6 @@ use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::print::pprust;\n use syntax::parse::token::special_idents;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n@@ -48,11 +47,8 @@ use syntax;\n \n // Data types\n \n-// Note: after typeck, you should use resolved_mode() to convert this mode\n-// into an rmode, which will take into account the results of mode inference.\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct arg {\n-    mode: ast::mode,\n     ty: t\n }\n \n@@ -99,6 +95,16 @@ pub enum TraitStore {\n     RegionTraitStore(Region),   // &Trait\n }\n \n+// XXX: This should probably go away at some point. Maybe after destructors\n+// do?\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving(Eq)]\n+pub enum SelfMode {\n+    ByCopy,\n+    ByRef,\n+}\n+\n pub struct field_ty {\n   ident: ident,\n   id: def_id,\n@@ -270,7 +276,6 @@ struct ctxt_ {\n     ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: @mut HashMap<def_id, @~[VariantInfo]>,\n     ty_param_defs: @mut HashMap<ast::node_id, TypeParameterDef>,\n-    inferred_modes: @mut HashMap<ast::node_id, ast::mode>,\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n@@ -630,7 +635,6 @@ pub enum type_err {\n     terr_record_mutability,\n     terr_record_fields(expected_found<ident>),\n     terr_arg_count,\n-    terr_mode_mismatch(expected_found<mode>),\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n     terr_regions_no_overlap(Region, Region),\n@@ -919,7 +923,6 @@ pub fn mk_ctxt(s: session::Session,\n         trait_method_def_ids: @mut HashMap::new(),\n         trait_methods_cache: @mut HashMap::new(),\n         ty_param_defs: @mut HashMap::new(),\n-        inferred_modes: @mut HashMap::new(),\n         adjustments: @mut HashMap::new(),\n         normalized_cache: new_ty_hash(),\n         lang_items: lang_items,\n@@ -1199,15 +1202,17 @@ pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n }\n \n pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n-    let input_args = input_tys.map(|t| arg {mode: ast::expl(ast::by_copy),\n-                                            ty: *t});\n+    let input_args = input_tys.map(|t| arg { ty: *t });\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::pure_fn,\n                    abis: AbiSet::Rust(),\n-                   sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n-                               inputs: input_args,\n-                               output: output}})\n+                   sig: FnSig {\n+                    bound_lifetime_names: opt_vec::Empty,\n+                    inputs: input_args,\n+                    output: output\n+                   }\n+                })\n }\n \n \n@@ -1258,40 +1263,14 @@ pub fn mach_sty(cfg: @session::config, t: t) -> sty {\n     }\n }\n \n-pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n-    return if tcx.legacy_modes {\n-        if type_is_borrowed(ty) {\n-            // the old mode default was ++ for things like &ptr, but to be\n-            // forward-compatible with non-legacy, we should use +\n-            ast::by_copy\n-        } else if ty::type_is_immediate(ty) {\n-            ast::by_copy\n-        } else {\n-            ast::by_ref\n-        }\n-    } else {\n-        ast::by_copy\n-    };\n-\n-    fn type_is_borrowed(ty: t) -> bool {\n-        match ty::get(ty).sty {\n-            ty::ty_rptr(*) => true,\n-            ty_evec(_, vstore_slice(_)) => true,\n-            ty_estr(vstore_slice(_)) => true,\n-\n-            // technically, we prob ought to include\n-            // &fn(), but that is treated specially due to #2202\n-            _ => false\n-        }\n-    }\n-}\n-\n pub fn walk_ty(ty: t, f: &fn(t)) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n \n pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n-    if !f(ty) { return; }\n+    if !f(ty) {\n+        return;\n+    }\n     match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self(_) |\n@@ -1323,7 +1302,9 @@ pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: &fn(t) -> t) -> t {\n \n pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n     let args = do sig.inputs.map |arg| {\n-        arg { mode: arg.mode, ty: fldop(arg.ty) }\n+        arg {\n+            ty: fldop(arg.ty)\n+        }\n     };\n \n     FnSig {\n@@ -2696,13 +2677,6 @@ impl to_bytes::IterBytes for field {\n     }\n }\n \n-impl to_bytes::IterBytes for arg {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.mode,\n-                               &self.ty, lsb0, f)\n-    }\n-}\n-\n impl to_bytes::IterBytes for FnSig {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n@@ -3368,78 +3342,6 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n     }\n }\n \n-// Maintains a little union-set tree for inferred modes.  `canon()` returns\n-// the current head value for `m0`.\n-fn canon<T:Copy + cmp::Eq>(tbl: &mut HashMap<ast::node_id, ast::inferable<T>>,\n-                           m0: ast::inferable<T>) -> ast::inferable<T> {\n-    match m0 {\n-        ast::infer(id) => {\n-            let m1 = match tbl.find(&id) {\n-                None => return m0,\n-                Some(&m1) => m1\n-            };\n-            let cm1 = canon(tbl, m1);\n-            // path compression:\n-            if cm1 != m1 { tbl.insert(id, cm1); }\n-            cm1\n-        },\n-        _ => m0\n-    }\n-}\n-\n-// Maintains a little union-set tree for inferred modes.  `resolve_mode()`\n-// returns the current head value for `m0`.\n-pub fn canon_mode(cx: ctxt, m0: ast::mode) -> ast::mode {\n-    canon(cx.inferred_modes, m0)\n-}\n-\n-// Returns the head value for mode, failing if `m` was a infer(_) that\n-// was never inferred.  This should be safe for use after typeck.\n-pub fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n-    match canon_mode(cx, m) {\n-      ast::infer(_) => {\n-        cx.sess.bug(fmt!(\"mode %? was never resolved\", m));\n-      }\n-      ast::expl(m0) => m0\n-    }\n-}\n-\n-pub fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { resolved_mode(cx, a.mode) }\n-\n-// Unifies `m1` and `m2`.  Returns unified value or failure code.\n-pub fn unify_mode(cx: ctxt, modes: expected_found<ast::mode>)\n-               -> Result<ast::mode, type_err> {\n-    let m1 = modes.expected;\n-    let m2 = modes.found;\n-    match (canon_mode(cx, m1), canon_mode(cx, m2)) {\n-      (m1, m2) if (m1 == m2) => {\n-        result::Ok(m1)\n-      }\n-      (ast::infer(_), ast::infer(id2)) => {\n-        cx.inferred_modes.insert(id2, m1);\n-        result::Ok(m1)\n-      }\n-      (ast::infer(id), m) | (m, ast::infer(id)) => {\n-        cx.inferred_modes.insert(id, m);\n-        result::Ok(m1)\n-      }\n-      (_, _) => {\n-        result::Err(terr_mode_mismatch(modes))\n-      }\n-    }\n-}\n-\n-// If `m` was never unified, unifies it with `m_def`.  Returns the final value\n-// for `m`.\n-pub fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n-    match canon_mode(cx, m) {\n-      ast::infer(id) => {\n-        cx.inferred_modes.insert(id, ast::expl(m_def));\n-      }\n-      ast::expl(_) => ()\n-    }\n-}\n-\n pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) |\n@@ -3537,11 +3439,6 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  *cx.sess.str_of(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n-        terr_mode_mismatch(values) => {\n-            fmt!(\"expected argument mode %s, but found %s\",\n-                 pprust::mode_to_str(values.expected),\n-                 pprust::mode_to_str(values.found))\n-        }\n         terr_regions_does_not_outlive(*) => {\n             fmt!(\"lifetime mismatch\")\n         }"}, {"sha": "ffaa6d46d3379de181ca6aea3ec6c054f735b403", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -501,52 +501,22 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     return typ;\n }\n \n-pub fn ty_of_arg<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: &AC,\n-        rscope: &RS,\n-        a: ast::arg,\n-        expected_ty: Option<ty::arg>)\n-     -> ty::arg {\n+pub fn ty_of_arg<AC:AstConv,\n+                 RS:region_scope + Copy + Durable>(\n+                 self: &AC,\n+                 rscope: &RS,\n+                 a: ast::arg,\n+                 expected_ty: Option<ty::arg>)\n+                 -> ty::arg {\n     let ty = match a.ty.node {\n-      ast::ty_infer if expected_ty.is_some() => expected_ty.get().ty,\n-      ast::ty_infer => self.ty_infer(a.ty.span),\n-      _ => ast_ty_to_ty(self, rscope, a.ty)\n-    };\n-\n-    let mode = {\n-        match a.mode {\n-          ast::infer(_) if expected_ty.is_some() => {\n-            result::get(&ty::unify_mode(\n-                self.tcx(),\n-                ty::expected_found {expected: expected_ty.get().mode,\n-                                    found: a.mode}))\n-          }\n-          ast::infer(_) => {\n-            match ty::get(ty).sty {\n-              // If the type is not specified, then this must be a fn expr.\n-              // Leave the mode as infer(_), it will get inferred based\n-              // on constraints elsewhere.\n-              ty::ty_infer(_) => a.mode,\n-\n-              // If the type is known, then use the default for that type.\n-              // Here we unify m and the default.  This should update the\n-              // tables in tcx but should never fail, because nothing else\n-              // will have been unified with m yet:\n-              _ => {\n-                let m1 = ast::expl(ty::default_arg_mode_for_ty(self.tcx(),\n-                                                               ty));\n-                result::get(&ty::unify_mode(\n-                    self.tcx(),\n-                    ty::expected_found {expected: m1,\n-                                        found: a.mode}))\n-              }\n-            }\n-          }\n-          ast::expl(_) => a.mode\n-        }\n+        ast::ty_infer if expected_ty.is_some() => expected_ty.get().ty,\n+        ast::ty_infer => self.ty_infer(a.ty.span),\n+        _ => ast_ty_to_ty(self, rscope, a.ty),\n     };\n \n-    arg {mode: mode, ty: ty}\n+    arg {\n+        ty: ty\n+    }\n }\n \n pub fn bound_lifetimes<AC:AstConv>("}, {"sha": "fb5b53d9400fb9816504f80ef390723181d590b7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -96,7 +96,7 @@ use util::common::indenter;\n use core::hashmap::HashSet;\n use std::list::Nil;\n use syntax::ast::{def_id, sty_value, sty_region, sty_box};\n-use syntax::ast::{sty_uniq, sty_static, node_id, by_copy, by_ref};\n+use syntax::ast::{sty_uniq, sty_static, node_id};\n use syntax::ast::{m_const, m_mutbl, m_imm};\n use syntax::ast;\n use syntax::ast_map;\n@@ -1051,9 +1051,9 @@ pub impl<'self> LookupContext<'self> {\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n             self_arg: arg {\n-                mode: ast::expl(self_mode),\n                 ty: candidate.rcvr_ty,\n             },\n+            self_mode: self_mode,\n             explicit_self: candidate.method_ty.self_ty,\n             origin: candidate.origin,\n         }\n@@ -1298,6 +1298,9 @@ pub impl<'self> LookupContext<'self> {\n     }\n }\n \n-pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n-    match self_type { sty_value => by_copy, _ => by_ref }\n+pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> SelfMode {\n+    match self_type {\n+        sty_value => ty::ByCopy,\n+        _ => ty::ByRef,\n+    }\n }"}, {"sha": "7ce34bba29cd4c5ba279c0e26a1d766804050141", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 182, "deletions": 271, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -1292,8 +1292,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn err_args(len: uint) -> ~[ty::arg] {\n-        vec::from_fn(len, |_| ty::arg {mode: ast::expl(ast::by_copy),\n-                                       ty: ty::mk_err()})\n+        vec::from_fn(len, |_| ty::arg { ty: ty::mk_err() })\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1694,10 +1693,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let fty = if error_happened {\n             fty_sig = FnSig {\n                 bound_lifetime_names: opt_vec::Empty,\n-                inputs: fn_ty.sig.inputs.map(|an_arg| {\n-                    arg { mode: an_arg.mode,\n-                         ty: ty::mk_err()\n-                        }}),\n+                inputs: fn_ty.sig.inputs.map(|_| {\n+                    arg {\n+                        ty: ty::mk_err()\n+                    }\n+                }),\n                 output: ty::mk_err()\n             };\n             ty::mk_err()\n@@ -2762,11 +2762,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n         if bot_field {\n             fcx.write_bot(id);\n-        }\n-        else if err_field {\n+        } else if err_field {\n             fcx.write_error(id);\n-        }\n-        else {\n+        } else {\n             let typ = ty::mk_tup(tcx, elt_ts);\n             fcx.write_ty(id, typ);\n         }\n@@ -2796,15 +2794,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           check_expr(fcx, idx);\n           let raw_base_t = fcx.expr_ty(base);\n           let idx_t = fcx.expr_ty(idx);\n-          if ty::type_is_error(raw_base_t)\n-              || ty::type_is_bot(raw_base_t) {\n+          if ty::type_is_error(raw_base_t) || ty::type_is_bot(raw_base_t) {\n               fcx.write_ty(id, raw_base_t);\n-          }\n-          else if ty::type_is_error(idx_t)\n-              || ty::type_is_bot(idx_t) {\n+          } else if ty::type_is_error(idx_t) || ty::type_is_bot(idx_t) {\n               fcx.write_ty(id, idx_t);\n-          }\n-          else {\n+          } else {\n               let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n               let base_sty = structure_of(fcx, expr.span, base_t);\n               match ty::index_sty(&base_sty) {\n@@ -2815,15 +2809,29 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   }\n                   None => {\n                       let resolved = structurally_resolved_type(fcx,\n-                          expr.span, raw_base_t);\n-                      let ret_ty = lookup_op_method(fcx, expr, base, resolved,\n-                                             tcx.sess.ident_of(~\"index\"),\n-                                             ~[idx], DoDerefArgs, AutoderefReceiver,\n-                        || {\n-                            fcx.type_error_message(expr.span, |actual|\n-                                fmt!(\"cannot index a value \\\n-                                      of type `%s`\", actual), base_t, None);\n-                        }, expected);\n+                                                                expr.span,\n+                                                                raw_base_t);\n+                      let index_ident = tcx.sess.ident_of(~\"index\");\n+                      let error_message = || {\n+                        fcx.type_error_message(expr.span,\n+                                               |actual| {\n+                                                fmt!(\"cannot index a value \\\n+                                                      of type `%s`\",\n+                                                     actual)\n+                                               },\n+                                               base_t,\n+                                               None);\n+                      };\n+                      let ret_ty = lookup_op_method(fcx,\n+                                                    expr,\n+                                                    base,\n+                                                    resolved,\n+                                                    index_ident,\n+                                                    ~[idx],\n+                                                    DoDerefArgs,\n+                                                    AutoderefReceiver,\n+                                                    error_message,\n+                                                    expected);\n                       fcx.write_ty(id, ret_ty);\n                   }\n               }\n@@ -3180,8 +3188,8 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n                                    -> ty_param_bounds_and_ty {\n \n     match defn {\n-      ast::def_arg(nid, _, _) | ast::def_local(nid, _) |\n-      ast::def_self(nid, _) | ast::def_binding(nid, _) => {\n+      ast::def_arg(nid, _) | ast::def_local(nid, _) | ast::def_self(nid, _) |\n+      ast::def_binding(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }\n@@ -3429,41 +3437,52 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     fn param(ccx: @mut CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n-    fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n-        arg {mode: ast::expl(m), ty: ty}\n+    fn arg(ty: ty::t) -> ty::arg {\n+        arg {\n+            ty: ty\n+        }\n     }\n+\n     let tcx = ccx.tcx;\n     let (n_tps, inputs, output) = match *ccx.tcx.sess.str_of(it.ident) {\n       ~\"size_of\" |\n       ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint()),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),\n-      ~\"forget\" => (1u, ~[arg(ast::by_copy, param(ccx, 0u))],\n-                    ty::mk_nil()),\n-      ~\"transmute\" => (2, ~[arg(ast::by_copy, param(ccx, 0))], param(ccx, 1)),\n+      ~\"forget\" => (1u, ~[arg(param(ccx, 0u))], ty::mk_nil()),\n+      ~\"transmute\" => (2, ~[ arg(param(ccx, 0)) ], param(ccx, 1)),\n       ~\"move_val\" | ~\"move_val_init\" => {\n-          (1u, ~[arg(ast::by_copy,\n-                     ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n-                                     param(ccx, 0u))),\n-               arg(ast::by_copy, param(ccx, 0u))],\n+          (1u,\n+           ~[\n+            arg(ty::mk_mut_rptr(tcx,\n+                                ty::re_bound(ty::br_anon(0)),\n+                                param(ccx, 0))),\n+               arg(param(ccx, 0u))\n+            ],\n          ty::mk_nil())\n       }\n       ~\"needs_drop\" => (1u, ~[], ty::mk_bool()),\n \n       ~\"atomic_cxchg\"    | ~\"atomic_cxchg_acq\"| ~\"atomic_cxchg_rel\" => {\n-        (0u, ~[arg(ast::by_copy,\n-                   ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n-                                   ty::mk_int())),\n-               arg(ast::by_copy, ty::mk_int()),\n-               arg(ast::by_copy, ty::mk_int())],\n-         ty::mk_int())\n+        (0,\n+         ~[\n+            arg(ty::mk_mut_rptr(tcx,\n+                                ty::re_bound(ty::br_anon(0)),\n+                                ty::mk_int(tcx))),\n+               arg(ty::mk_int()),\n+               arg(ty::mk_int())\n+         ],\n+         ty::mk_int(tcx))\n       }\n       ~\"atomic_xchg\"     | ~\"atomic_xadd\"     | ~\"atomic_xsub\"     |\n       ~\"atomic_xchg_acq\" | ~\"atomic_xadd_acq\" | ~\"atomic_xsub_acq\" |\n       ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => {\n-        (0u, ~[arg(ast::by_copy,\n-                   ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n-                                   ty::mk_int())),\n-               arg(ast::by_copy, ty::mk_int())],\n+        (0,\n+         ~[\n+            arg(ty::mk_mut_rptr(tcx,\n+                                ty::re_bound(ty::br_anon(0)),\n+                                ty::mk_int(tcx))),\n+            arg(ty::mk_int())\n+         ],\n          ty::mk_int())\n       }\n \n@@ -3472,14 +3491,15 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n         (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n       }\n       ~\"visit_tydesc\" => {\n-          let tydesc_name = special_idents::tydesc;\n-          assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-          let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n-          let (_, visitor_object_ty) = ty::visitor_object_ty(ccx.tcx);\n-          let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n-                                                   mutbl: ast::m_imm});\n-          (0u, ~[arg(ast::by_copy, td_ptr),\n-                 arg(ast::by_copy, visitor_object_ty)], ty::mk_nil())\n+        let tydesc_name = special_idents::tydesc;\n+        assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n+        let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n+        let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n+        let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n+            ty: tydesc_ty,\n+            mutbl: ast::m_imm\n+        });\n+        (0, ~[ arg(td_ptr), arg(visitor_object_ty) ], ty::mk_nil())\n       }\n       ~\"frame_address\" => {\n         let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n@@ -3489,233 +3509,124 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             region: ty::re_bound(ty::br_anon(0)),\n             sig: ty::FnSig {\n                 bound_lifetime_names: opt_vec::Empty,\n-                inputs: ~[arg {mode: ast::expl(ast::by_copy),\n-                               ty: ty::mk_imm_ptr(\n-                                   ccx.tcx,\n-                                   ty::mk_mach_uint(ast::ty_u8))}],\n+                inputs: ~[\n+                    arg {\n+                        ty: ty::mk_imm_ptr(ccx.tcx,\n+                                           ty::mk_mach_uint(ast::ty_u8))\n+                    }\n+                ],\n                 output: ty::mk_nil()\n             }\n         });\n-        (0u, ~[arg(ast::by_copy, fty)], ty::mk_nil())\n+        (0u, ~[ arg(fty) ], ty::mk_nil())\n       }\n       ~\"morestack_addr\" => {\n         (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n       }\n       ~\"memmove32\" => {\n-        (0, ~[arg(ast::by_copy,\n-                  ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_mutbl })),\n-              arg(ast::by_copy,\n-                  ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_imm })),\n-              arg(ast::by_copy,\n-                  ty::mk_u32())],\n+        (0,\n+         ~[\n+            arg(ty::mk_ptr(tcx, ty::mt {\n+                ty: ty::mk_u8(),\n+                mutbl: ast::m_mutbl\n+            })),\n+            arg(ty::mk_ptr(tcx, ty::mt {\n+                ty: ty::mk_u8(),\n+                mutbl: ast::m_imm\n+            })),\n+            arg(ty::mk_u32())\n+         ],\n          ty::mk_nil())\n       }\n       ~\"memmove64\" => {\n-        (0, ~[arg(ast::by_copy,\n-                  ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_mutbl })),\n-              arg(ast::by_copy,\n-                  ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_imm })),\n-              arg(ast::by_copy,\n-                  ty::mk_u64())],\n-         ty::mk_nil())\n-      }\n-     ~\"sqrtf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"sqrtf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"powif32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n-               arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_f32())\n-     }\n-     ~\"powif64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n-               arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_f64())\n-     }\n-     ~\"sinf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"sinf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"cosf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"cosf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"powf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n-               arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"powf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n-               arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"expf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"expf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"exp2f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"exp2f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"logf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"logf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"log10f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"log10f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"log2f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"log2f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"fmaf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n-               arg(ast::by_copy, ty::mk_f32()),\n-               arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"fmaf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n-               arg(ast::by_copy, ty::mk_f64()),\n-               arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"fabsf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"fabsf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"floorf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"floorf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"ceilf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"ceilf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"truncf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"truncf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"ctpop8\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n-         ty::mk_i8())\n-     }\n-     ~\"ctpop16\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n-         ty::mk_i16())\n-     }\n-     ~\"ctpop32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_i32())\n-     }\n-     ~\"ctpop64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n-         ty::mk_i64())\n-     }\n-     ~\"ctlz8\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n-         ty::mk_i8())\n-     }\n-     ~\"ctlz16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n-         ty::mk_i16())\n-     }\n-     ~\"ctlz32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_i32())\n-     }\n-     ~\"ctlz64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n-         ty::mk_i64())\n-     }\n-     ~\"cttz8\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n-         ty::mk_i8())\n-     }\n-     ~\"cttz16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n-         ty::mk_i16())\n-     }\n-     ~\"cttz32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_i32())\n-     }\n-     ~\"cttz64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n-         ty::mk_i64())\n-     }\n-     ~\"bswap16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n-         ty::mk_i16())\n-     }\n-     ~\"bswap32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_i32())\n-     }\n-     ~\"bswap64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n-         ty::mk_i64())\n-     }\n-     ref other => {\n-        tcx.sess.span_err(it.span, ~\"unrecognized intrinsic function: `\" +\n-                          (*other) + ~\"`\");\n-        return;\n-      }\n+        (0,\n+         ~[arg(ty::mk_ptr(tcx, ty::mt {\n+            ty: ty::mk_u8(),\n+            mutbl: ast::m_mutbl\n+           })),\n+           arg(ty::mk_ptr(tcx, ty::mt {\n+            ty: ty::mk_u8(),\n+            mutbl: ast::m_imm\n+           })),\n+           arg(ty::mk_u64())\n+         ],\n+         ty::mk_nil(tcx))\n+      }\n+        ~\"sqrtf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"sqrtf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"powif32\" => {\n+           (0,\n+            ~[ arg(ty::mk_f32()), arg(ty::mk_i32()) ],\n+            ty::mk_f32())\n+        }\n+        ~\"powif64\" => {\n+           (0,\n+            ~[ arg(ty::mk_f64()), arg(ty::mk_i32()) ],\n+            ty::mk_f64())\n+        }\n+        ~\"sinf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"sinf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"cosf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"cosf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"powf32\" => {\n+           (0,\n+            ~[ arg(ty::mk_f32()), arg(ty::mk_f32()) ],\n+            ty::mk_f32())\n+        }\n+        ~\"powf64\" => {\n+           (0,\n+            ~[ arg(ty::mk_f64()), arg(ty::mk_f64()) ],\n+            ty::mk_f64())\n+        }\n+        ~\"expf32\"   => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"expf64\"   => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"exp2f32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"exp2f64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"logf32\"   => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"logf64\"   => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"log10f32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"log10f64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"log2f32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"log2f64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"fmaf32\" => {\n+            (0,\n+             ~[ arg(ty::mk_f32()), arg(ty::mk_f32()), arg(ty::mk_f32()) ],\n+             ty::mk_f32())\n+        }\n+        ~\"fmaf64\" => {\n+            (0,\n+             ~[ arg(ty::mk_f64()), arg(ty::mk_f64()), arg(ty::mk_f64()) ],\n+             ty::mk_f64())\n+        }\n+        ~\"fabsf32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"fabsf64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"floorf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"floorf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"ceilf32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"ceilf64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"truncf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"truncf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"ctpop8\"   => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n+        ~\"ctpop16\"  => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n+        ~\"ctpop32\"  => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n+        ~\"ctpop64\"  => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ~\"ctlz8\"    => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n+        ~\"ctlz16\"   => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n+        ~\"ctlz32\"   => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n+        ~\"ctlz64\"   => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ~\"cttz8\"    => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n+        ~\"cttz16\"   => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n+        ~\"cttz32\"   => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n+        ~\"cttz64\"   => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ~\"bswap16\"  => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n+        ~\"bswap32\"  => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n+        ~\"bswap64\"  => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ref other => {\n+            tcx.sess.span_err(it.span,\n+                              ~\"unrecognized intrinsic function: `\" +\n+                              (*other) + ~\"`\");\n+            return;\n+        }\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         purity: ast::unsafe_fn,"}, {"sha": "cb2b854276d6fef91a17a48e4862eb43873407bb", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -55,7 +55,7 @@ pub type rvt = visit::vt<@mut Rcx>;\n fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n-        def_local(node_id, _) | def_arg(node_id, _, _) |\n+        def_local(node_id, _) | def_arg(node_id, _) |\n         def_self(node_id, _) | def_binding(node_id, _) => {\n             tcx.region_maps.encl_region(node_id)\n         }"}, {"sha": "d6b09d1e7f4537c7b37c9a5fec28068bfc245b5a", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -66,7 +66,9 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n             for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n                 let method_map = fcx.ccx.method_map;\n                 let new_entry = method_map_entry {\n-                    self_arg: arg {mode: mme.self_arg.mode, ty: *t },\n+                    self_arg: arg {\n+                        ty: *t\n+                    },\n                     ..*mme\n                 };\n                 debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n@@ -213,52 +215,55 @@ fn visit_stmt(s: @ast::stmt, wbcx: @mut WbCtxt, v: wb_vt) {\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n     visit::visit_stmt(s, wbcx, v);\n }\n+\n fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n-    if !wbcx.success { return; }\n+    if !wbcx.success {\n+        return;\n+    }\n+\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.callee_id);\n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.callee_id);\n+\n     match e.node {\n-      ast::expr_fn_block(ref decl, _) => {\n-          for vec::each(decl.inputs) |input| {\n-              let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n-\n-              // Just in case we never constrained the mode to anything,\n-              // constrain it to the default for the type in question.\n-              match (r_ty, input.mode) {\n-                  (Some(t), ast::infer(_)) => {\n-                      let tcx = wbcx.fcx.ccx.tcx;\n-                      let m_def = ty::default_arg_mode_for_ty(tcx, t);\n-                      ty::set_default_mode(tcx, input.mode, m_def);\n-                  }\n-                  _ => ()\n-              }\n-          }\n-      }\n+        ast::expr_fn_block(ref decl, _) => {\n+            for vec::each(decl.inputs) |input| {\n+                let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n+            }\n+        }\n \n-      ast::expr_binary(*) | ast::expr_unary(*) | ast::expr_assign_op(*)\n-        | ast::expr_index(*) => {\n-        maybe_resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n-      }\n+        ast::expr_binary(*) | ast::expr_unary(*) | ast::expr_assign_op(*) |\n+        ast::expr_index(*) => {\n+            maybe_resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n+        }\n \n-      ast::expr_method_call(*) => {\n-        // We must always have written in a callee ID type for these.\n-        resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n-      }\n+        ast::expr_method_call(*) => {\n+            // We must always have written in a callee ID type for these.\n+            resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n+        }\n \n-      _ => ()\n+        _ => ()\n     }\n+\n     visit::visit_expr(e, wbcx, v);\n }\n+\n fn visit_block(b: &ast::blk, wbcx: @mut WbCtxt, v: wb_vt) {\n-    if !wbcx.success { return; }\n+    if !wbcx.success {\n+        return;\n+    }\n+\n     resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n     visit::visit_block(b, wbcx, v);\n }\n+\n fn visit_pat(p: @ast::pat, wbcx: @mut WbCtxt, v: wb_vt) {\n-    if !wbcx.success { return; }\n+    if !wbcx.success {\n+        return;\n+    }\n+\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n            pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n@@ -267,6 +272,7 @@ fn visit_pat(p: @ast::pat, wbcx: @mut WbCtxt, v: wb_vt) {\n                                    p.id)));\n     visit::visit_pat(p, wbcx, v);\n }\n+\n fn visit_local(l: @ast::local, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     let var_ty = wbcx.fcx.local_ty(l.span, l.node.id);"}, {"sha": "0ffd398d03c194caef5fec5abfa33b4752436330", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -552,10 +552,14 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // represent the self argument (unless this is a static method).\n     // This argument will have the *transformed* self type.\n     for trait_m.transformed_self_ty.each |&t| {\n-        trait_fn_args.push(ty::arg {mode: ast::expl(ast::by_copy), ty: t});\n+        trait_fn_args.push(ty::arg {\n+            ty: t\n+        });\n     }\n     for impl_m.transformed_self_ty.each |&t| {\n-        impl_fn_args.push(ty::arg {mode: ast::expl(ast::by_copy), ty: t});\n+        impl_fn_args.push(ty::arg {\n+            ty: t\n+        });\n     }\n \n     // Add in the normal arguments."}, {"sha": "e4db423c2e35c14597adbc1d58620cd108a92312", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -95,7 +95,6 @@ pub trait Combine {\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy>;\n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n     fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field>;\n-    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n     fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n     fn purities(&self, a: purity, b: purity) -> cres<purity>;\n@@ -312,28 +311,20 @@ pub fn super_flds<C:Combine>(\n     }\n }\n \n-pub fn super_modes<C:Combine>(\n-    self: &C, a: ast::mode, b: ast::mode)\n-    -> cres<ast::mode> {\n-\n-    let tcx = self.infcx().tcx;\n-    ty::unify_mode(tcx, expected_found(self, a, b))\n-}\n-\n-pub fn super_args<C:Combine>(\n-    self: &C, a: ty::arg, b: ty::arg)\n-    -> cres<ty::arg> {\n-\n-    do self.modes(a.mode, b.mode).chain |m| {\n-        do self.contratys(a.ty, b.ty).chain |t| {\n-            Ok(arg {mode: m, ty: t})\n-        }\n+pub fn super_args<C:Combine>(self: &C, a: ty::arg, b: ty::arg)\n+                             -> cres<ty::arg> {\n+    do self.contratys(a.ty, b.ty).chain |t| {\n+        Ok(arg {\n+            ty: t\n+        })\n     }\n }\n \n-pub fn super_vstores<C:Combine>(\n-    self: &C, vk: ty::terr_vstore_kind,\n-    a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n+pub fn super_vstores<C:Combine>(self: &C,\n+                                vk: ty::terr_vstore_kind,\n+                                a: ty::vstore,\n+                                b: ty::vstore)\n+                                -> cres<ty::vstore> {\n     debug!(\"%s.super_vstores(a=%?, b=%?)\", self.tag(), a, b);\n \n     match (a, b) {"}, {"sha": "2bbcd24595cba86aa6b59dc33bb1c01a59d91b98", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -152,10 +152,6 @@ impl Combine for Glb {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n-    }\n-\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n         super_args(self, a, b)\n     }"}, {"sha": "85914338017964731185eb017620dd8854435991", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -234,10 +234,6 @@ impl Combine for Lub {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n-    }\n-\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n         super_args(self, a, b)\n     }"}, {"sha": "266d157c4d040353b0b4c9de384f64aedb6e620f", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -241,14 +241,10 @@ impl Combine for Sub {\n                     vk: ty::terr_vstore_kind,\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n-                 -> cres<ty::TraitStore> {\n+                    -> cres<ty::TraitStore> {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n-    }\n-\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n         super_args(self, a, b)\n     }"}, {"sha": "646b6412f5507c824d212ce340f2de0a1c6dcc1f", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -116,10 +116,13 @@ pub struct method_param {\n }\n \n pub struct method_map_entry {\n-    // the type and mode of the self parameter, which is not reflected\n-    // in the fn type (FIXME #3446)\n+    // the type of the self parameter, which is not reflected in the fn type\n+    // (FIXME #3446)\n     self_arg: ty::arg,\n \n+    // the mode of `self`\n+    self_mode: ty::SelfMode,\n+\n     // the type of explicit self on the method\n     explicit_self: ast::self_ty_,\n \n@@ -329,7 +332,6 @@ fn check_main_fn_ty(ccx: @mut CrateCtxt,\n fn check_start_fn_ty(ccx: @mut CrateCtxt,\n                      start_id: ast::node_id,\n                      start_span: span) {\n-\n     let tcx = ccx.tcx;\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match ty::get(start_t).sty {\n@@ -351,19 +353,25 @@ fn check_start_fn_ty(ccx: @mut CrateCtxt,\n                 _ => ()\n             }\n \n-            fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n-                ty::arg {mode: ast::expl(m), ty: ty}\n+            fn arg(ty: ty::t) -> ty::arg {\n+                ty::arg {\n+                    ty: ty\n+                }\n             }\n \n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 purity: ast::impure_fn,\n                 abis: abi::AbiSet::Rust(),\n-                sig: ty::FnSig {bound_lifetime_names: opt_vec::Empty,\n-                            inputs: ~[arg(ast::by_copy, ty::mk_int()),\n-                                      arg(ast::by_copy, ty::mk_imm_ptr(tcx,\n-                                                            ty::mk_imm_ptr(tcx, ty::mk_u8()))),\n-                                      arg(ast::by_copy, ty::mk_imm_ptr(tcx, ty::mk_u8()))],\n-                            output: ty::mk_int()}\n+                sig: ty::FnSig {\n+                    bound_lifetime_names: opt_vec::Empty,\n+                    inputs: ~[\n+                        arg(ty::mk_int()),\n+                        arg(ty::mk_imm_ptr(tcx,\n+                                           ty::mk_imm_ptr(tcx, ty::mk_u8()))),\n+                        arg(ty::mk_imm_ptr(tcx, ty::mk_u8()))\n+                    ],\n+                    output: ty::mk_int()\n+                }\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,"}, {"sha": "aa8c3f8fd1b7eb1e2b7a7b77a0a2e172105cd582", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -8,28 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::ty;\n-use middle::typeck;\n-use middle::ty::canon_mode;\n-use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid,\n-                 br_fresh};\n-use middle::ty::{ctxt, field, method};\n+use metadata::encoder;\n+use middle::ty::{ReSkolemized, ReVar};\n+use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n+use middle::ty::{br_fresh, ctxt, field, method};\n use middle::ty::{mt, t, param_bound, param_ty};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n-use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n+use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_uint, ty_unboxed_vec, ty_infer};\n-use metadata::encoder;\n+use middle::ty;\n+use middle::typeck;\n+use syntax::abi::AbiSet;\n+use syntax::ast_map;\n use syntax::codemap::span;\n use syntax::print::pprust;\n-use syntax::print::pprust::mode_to_str;\n use syntax::{ast, ast_util};\n-use syntax::ast_map;\n-use syntax::abi::AbiSet;\n \n pub trait Repr {\n     fn repr(&self, tcx: ctxt) -> ~str;\n@@ -293,26 +290,14 @@ pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n \n pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn fn_input_to_str(cx: ctxt, input: ty::arg) -> ~str {\n-        let ty::arg {mode: mode, ty: ty} = input;\n-        let modestr = match canon_mode(cx, mode) {\n-          ast::infer(_) => ~\"\",\n-          ast::expl(m) => {\n-            if !ty::type_needs_infer(ty) &&\n-                m == ty::default_arg_mode_for_ty(cx, ty) {\n-                ~\"\"\n-            } else {\n-                mode_to_str(ast::expl(m)) + ~\":\"\n-            }\n-          }\n-        };\n-        fmt!(\"%s%s\", modestr, ty_to_str(cx, ty))\n+        ty_to_str(cx, input.ty)\n     }\n     fn bare_fn_to_str(cx: ctxt,\n                       purity: ast::purity,\n                       abis: AbiSet,\n                       ident: Option<ast::ident>,\n-                      sig: &ty::FnSig) -> ~str\n-    {\n+                      sig: &ty::FnSig)\n+                      -> ~str {\n         let mut s = ~\"extern \";\n \n         s.push_str(abis.to_str());\n@@ -701,7 +686,7 @@ impl Repr for typeck::method_map_entry {\n \n impl Repr for ty::arg {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"%?(%s)\", self.mode, self.ty.repr(tcx))\n+        fmt!(\"(%s)\", self.ty.repr(tcx))\n     }\n }\n "}, {"sha": "ba6fe1cda4f31b83eba478a36d0d186ab7f1d44c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -198,7 +198,7 @@ pub enum def {\n     def_mod(def_id),\n     def_foreign_mod(def_id),\n     def_const(def_id),\n-    def_arg(node_id, mode, bool /* is_mutbl */),\n+    def_arg(node_id, bool /* is_mutbl */),\n     def_local(node_id, bool /* is_mutbl */),\n     def_variant(def_id /* enum */, def_id /* variant */),\n     def_ty(def_id),\n@@ -417,43 +417,6 @@ pub enum unop {\n     neg\n }\n \n-// Generally, after typeck you can get the inferred value\n-// using ty::resolved_T(...).\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub enum inferable<T> {\n-    expl(T),\n-    infer(node_id)\n-}\n-\n-impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          expl(ref t) =>\n-          to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n-\n-          infer(ref n) =>\n-          to_bytes::iter_bytes_2(&1u8, n, lsb0, f),\n-        }\n-    }\n-}\n-\n-// \"resolved\" mode: the real modes.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub enum rmode { by_ref, by_copy }\n-\n-impl to_bytes::IterBytes for rmode {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-// inferable mode.\n-pub type mode = inferable<rmode>;\n-\n pub type stmt = spanned<stmt_>;\n \n #[auto_encode]\n@@ -941,7 +904,6 @@ pub struct inline_asm {\n #[auto_decode]\n #[deriving(Eq)]\n pub struct arg {\n-    mode: mode,\n     is_mutbl: bool,\n     ty: @Ty,\n     pat: @pat,"}, {"sha": "148b713a4f58f388adc0dcbb8aa34d0d66828372", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -58,7 +58,7 @@ pub fn def_id_of_def(d: def) -> def_id {\n       def_use(id) | def_struct(id) | def_trait(id) => {\n         id\n       }\n-      def_arg(id, _, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)\n+      def_arg(id, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)\n       | def_upvar(id, _, _, _) | def_binding(id, _) | def_region(id)\n       | def_typaram_binder(id) | def_label(id) => {\n         local_def(id)"}, {"sha": "da7b9570131a46e6945f9b0707f73151a16b2276", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -608,7 +608,6 @@ fn mk_ser_method(\n     };\n \n     let ser_inputs = ~[ast::arg {\n-        mode: ast::infer(cx.next_id()),\n         is_mutbl: false,\n         ty: ty_s,\n         pat: @ast::pat {\n@@ -670,20 +669,22 @@ fn mk_deser_method(\n         span: span,\n     };\n \n-    let deser_inputs = ~[ast::arg {\n-        mode: ast::infer(cx.next_id()),\n-        is_mutbl: false,\n-        ty: ty_d,\n-        pat: @ast::pat {\n+    let deser_inputs = ~[\n+        ast::arg {\n+            is_mutbl: false,\n+            ty: ty_d,\n+            pat: @ast::pat {\n+                id: cx.next_id(),\n+                node: ast::pat_ident(ast::bind_by_copy,\n+                                     ast_util::ident_to_path(span,\n+                                                             cx.ident_of(\n+                                                                ~\"__d\")),\n+                                     None),\n+                span: span,\n+            },\n             id: cx.next_id(),\n-            node: ast::pat_ident(\n-                ast::bind_by_copy,\n-                ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n-                None),\n-            span: span,\n-        },\n-        id: cx.next_id(),\n-    }];\n+        }\n+    ];\n \n     let deser_decl = ast::fn_decl {\n         inputs: deser_inputs,\n@@ -1120,7 +1121,6 @@ fn mk_enum_deser_body(\n         ast::expr_fn_block(\n             ast::fn_decl {\n                 inputs: ~[ast::arg {\n-                    mode: ast::infer(ext_cx.next_id()),\n                     is_mutbl: false,\n                     ty: @ast::Ty {\n                         id: ext_cx.next_id(),"}, {"sha": "4c876669f471d9e1c79ad714d35215a2b340a995", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -419,7 +419,6 @@ pub fn mk_arg(cx: @ext_ctxt,\n            -> ast::arg {\n     let arg_pat = mk_pat_ident(cx, span, ident);\n     ast::arg {\n-        mode: ast::infer(cx.next_id()),\n         is_mutbl: false,\n         ty: ty,\n         pat: arg_pat,"}, {"sha": "deaf1b1c754a0f88bf203d6cc38b1b23a1b61d25", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -196,7 +196,6 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n \n     fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n         ast::arg {\n-            mode: ast::infer(self.next_id()),\n             is_mutbl: false,\n             ty: ty,\n             pat: @ast::pat {"}, {"sha": "cee1f531176cda60ee64572781ce6c68803a0462", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -105,7 +105,6 @@ fn fold_attribute_(at: attribute, fld: @ast_fold) -> attribute {\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     ast::arg {\n-        mode: a.mode,\n         is_mutbl: a.is_mutbl,\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),"}, {"sha": "ae3748082708ed614075e8daf7eb876a596d415b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -17,10 +17,10 @@ use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n-use ast::{blk_check_mode, box, by_copy, by_ref};\n+use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n use ast::{decl_local, default_blk, deref, quot, enum_def};\n-use ast::{expl, expr, expr_, expr_addr_of, expr_match, expr_again};\n+use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n use ast::{expr_field, expr_fn_block, expr_if, expr_index};\n@@ -32,13 +32,13 @@ use ast::{expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl};\n use ast::{expr_vstore_uniq, TyClosure, TyBareFn, Onceness, Once, Many};\n use ast::{foreign_item, foreign_item_const, foreign_item_fn, foreign_mod};\n-use ast::{ident, impure_fn, infer, inherited, item, item_, item_const};\n+use ast::{ident, impure_fn, inherited, item, item_, item_const};\n use ast::{item_const, item_enum, item_fn, item_foreign_mod, item_impl};\n use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local, m_const};\n use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n-use ast::{match_seq, match_tok, method, mode, mt, mul, mutability};\n+use ast::{match_seq, match_tok, method, mt, mul, mutability};\n use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct};\n use ast::{pat_tup, pat_uniq, pat_wild, private};\n@@ -765,22 +765,22 @@ pub impl Parser {\n     }\n \n     // parse an optional mode.\n-    fn parse_arg_mode(&self) -> mode {\n+    // XXX: Remove after snapshot.\n+    fn parse_arg_mode(&self) {\n         if self.eat(&token::BINOP(token::MINUS)) {\n             self.obsolete(*self.span, ObsoleteMode);\n-            expl(by_copy)\n         } else if self.eat(&token::ANDAND) {\n-            expl(by_ref)\n+            // Ignore.\n         } else if self.eat(&token::BINOP(token::PLUS)) {\n             if self.eat(&token::BINOP(token::PLUS)) {\n                 // ++ mode is obsolete, but we need a snapshot\n                 // to stop parsing it.\n-                expl(by_copy)\n+                // Ignore.\n             } else {\n-                expl(by_copy)\n+                // Ignore.\n             }\n         } else {\n-            infer(self.get_id())\n+            // Ignore.\n         }\n     }\n \n@@ -810,25 +810,27 @@ pub impl Parser {\n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n     fn parse_arg_general(&self, require_name: bool) -> arg {\n-        let m;\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n-            m = self.parse_arg_mode();\n+            self.parse_arg_mode();\n             is_mutbl = self.eat_keyword(&~\"mut\");\n             let pat = self.parse_pat(false);\n             self.expect(&token::COLON);\n             pat\n         } else {\n-            m = infer(self.get_id());\n             ast_util::ident_to_pat(self.get_id(),\n                                    *self.last_span,\n                                    special_idents::invalid)\n         };\n \n         let t = self.parse_ty(false);\n \n-        ast::arg { mode: m, is_mutbl: is_mutbl,\n-                  ty: t, pat: pat, id: self.get_id() }\n+        ast::arg {\n+            is_mutbl: is_mutbl,\n+            ty: t,\n+            pat: pat,\n+            id: self.get_id(),\n+        }\n     }\n \n     // parse a single function argument\n@@ -838,7 +840,7 @@ pub impl Parser {\n \n     // parse an argument in a lambda header e.g. |arg, arg|\n     fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n-        let m = self.parse_arg_mode();\n+        self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n         let pat = self.parse_pat(false);\n         let t = if self.eat(&token::COLON) {\n@@ -851,7 +853,6 @@ pub impl Parser {\n             }\n         };\n         either::Left(ast::arg {\n-            mode: m,\n             is_mutbl: is_mutbl,\n             ty: t,\n             pat: pat,\n@@ -2440,18 +2441,21 @@ pub impl Parser {\n \n     // used by the copy foo and ref foo patterns to give a good\n     // error message when parsing mistakes like ref foo(a,b)\n-    fn parse_pat_ident(&self, refutable: bool,\n-                       binding_mode: ast::binding_mode) -> ast::pat_ {\n+    fn parse_pat_ident(&self,\n+                       refutable: bool,\n+                       binding_mode: ast::binding_mode)\n+                       -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n-            self.span_fatal(\n-                *self.last_span,\n-                ~\"expected identifier, found path\");\n+            self.span_fatal(*self.last_span,\n+                            ~\"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n         let name = self.parse_path_without_tps();\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat(refutable))\n-        } else { None };\n+        } else {\n+            None\n+        };\n \n         // just to be friendly, if they write something like\n         //   ref Some(i)\n@@ -4406,10 +4410,11 @@ pub impl Parser {\n     // text that can't be parsed as an item\n     // - mod_items uses extern_mod_allowed = true\n     // - block_tail_ uses extern_mod_allowed = false\n-    fn parse_items_and_view_items(&self, first_item_attrs: ~[attribute],\n+    fn parse_items_and_view_items(&self,\n+                                  first_item_attrs: ~[attribute],\n                                   mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n-                                -> ParsedItemsAndViewItems {\n+                                  -> ParsedItemsAndViewItems {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n         // First, parse view items.\n@@ -4539,8 +4544,11 @@ pub impl Parser {\n \n     fn parse_str(&self) -> @~str {\n         match *self.token {\n-          token::LIT_STR(s) => { self.bump(); self.id_to_str(s) }\n-          _ =>  self.fatal(~\"expected string literal\")\n+            token::LIT_STR(s) => {\n+                self.bump();\n+                self.id_to_str(s)\n+            }\n+            _ =>  self.fatal(~\"expected string literal\")\n         }\n     }\n }"}, {"sha": "337355304d4a6a835d33a3fa35e5749ae8791ccf", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30f54e9d062bdb5b3cb10dd7185470280c1c278/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f30f54e9d062bdb5b3cb10dd7185470280c1c278", "patch": "@@ -1718,19 +1718,6 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-pub fn mode_to_str(m: ast::mode) -> ~str {\n-    match m {\n-      ast::expl(ast::by_ref) => ~\"&&\",\n-      ast::expl(ast::by_copy) => ~\"+\",\n-      ast::infer(_) => ~\"\"\n-    }\n-}\n-\n-pub fn print_arg_mode(s: @ps, m: ast::mode) {\n-    let ms = mode_to_str(m);\n-    if ms != ~\"\" { word(s.s, ms); }\n-}\n-\n pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     if !bounds.is_empty() {\n         word(s.s, ~\":\");\n@@ -1879,7 +1866,6 @@ pub fn print_mt(s: @ps, mt: &ast::mt) {\n \n pub fn print_arg(s: @ps, input: ast::arg) {\n     ibox(s, indent_unit);\n-    print_arg_mode(s, input.mode);\n     if input.is_mutbl {\n         word_space(s, ~\"mut\");\n     }"}]}