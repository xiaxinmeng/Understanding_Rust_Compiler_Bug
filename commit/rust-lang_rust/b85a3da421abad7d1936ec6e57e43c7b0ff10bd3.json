{"sha": "b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NWEzZGE0MjFhYmFkN2QxOTM2ZWM2ZTU3ZTQzYzdiMGZmMTBiZDM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-10T12:32:41Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-16T18:21:37Z"}, "message": "parse: Support parsing optional literals\n\nRevert weird renaming of the former `LitError::report`", "tree": {"sha": "dec60e5f95768d7d15524a2e01defcb2f525ec50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dec60e5f95768d7d15524a2e01defcb2f525ec50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "html_url": "https://github.com/rust-lang/rust/commit/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00bc4496026a3168eed95e88c29f17dac2739d48", "url": "https://api.github.com/repos/rust-lang/rust/commits/00bc4496026a3168eed95e88c29f17dac2739d48", "html_url": "https://github.com/rust-lang/rust/commit/00bc4496026a3168eed95e88c29f17dac2739d48"}], "stats": {"total": 48, "additions": 27, "deletions": 21}, "files": [{"sha": "df2f6822465121087fd6b7328b844cb81f178b33", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "patch": "@@ -778,13 +778,12 @@ impl<'a> Parser<'a> {\n \n         macro_rules! parse_lit {\n             () => {\n-                match self.parse_lit() {\n-                    Ok(literal) => {\n+                match self.parse_opt_lit() {\n+                    Some(literal) => {\n                         hi = self.prev_span;\n                         ex = ExprKind::Lit(literal);\n                     }\n-                    Err(mut err) => {\n-                        err.cancel();\n+                    None => {\n                         return Err(self.expected_expression_found());\n                     }\n                 }\n@@ -1074,11 +1073,20 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n-    /// Matches `lit = true | false | token_lit`.\n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n+        self.parse_opt_lit().ok_or_else(|| {\n+            let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n+            self.span_fatal(self.token.span, &msg)\n+        })\n+    }\n+\n+    /// Matches `lit = true | false | token_lit`.\n+    /// Returns `None` if the next token is not a literal.\n+    pub(super) fn parse_opt_lit(&mut self) -> Option<Lit> {\n         let mut recovered = None;\n         if self.token == token::Dot {\n-            // Attempt to recover `.4` as `0.4`.\n+            // Attempt to recover `.4` as `0.4`. We don't currently have any syntax where\n+            // dot would follow an optional literal, so we do this unconditionally.\n             recovered = self.look_ahead(1, |next_token| {\n                 if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix })\n                         = next_token.kind {\n@@ -1107,11 +1115,10 @@ impl<'a> Parser<'a> {\n         match Lit::from_token(token) {\n             Ok(lit) => {\n                 self.bump();\n-                Ok(lit)\n+                Some(lit)\n             }\n             Err(LitError::NotLiteral) => {\n-                let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n-                Err(self.span_fatal(token.span, &msg))\n+                None\n             }\n             Err(err) => {\n                 let span = token.span;\n@@ -1120,18 +1127,18 @@ impl<'a> Parser<'a> {\n                     _ => unreachable!(),\n                 };\n                 self.bump();\n-                self.error_literal_from_token(err, lit, span);\n+                self.report_lit_error(err, lit, span);\n                 // Pack possible quotes and prefixes from the original literal into\n                 // the error literal's symbol so they can be pretty-printed faithfully.\n                 let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n                 let symbol = Symbol::intern(&suffixless_lit.to_string());\n                 let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n-                Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n+                Some(Lit::from_lit_token(lit, span).unwrap_or_else(|_| unreachable!()))\n             }\n         }\n     }\n \n-    fn error_literal_from_token(&self, err: LitError, lit: token::Lit, span: Span) {\n+    fn report_lit_error(&self, err: LitError, lit: token::Lit, span: Span) {\n         // Checks if `s` looks like i32 or u1234 etc.\n         fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n             s.len() > 1"}, {"sha": "8e6df0fa4f39fd874a5bc43d061c399d1c3a1b30", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "patch": "@@ -105,7 +105,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n \n-            let abi = self.parse_opt_abi()?;\n+            let abi = self.parse_opt_abi();\n \n             if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM"}, {"sha": "7757e00020a2246dbebf8b93699ac083681c39df", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b85a3da421abad7d1936ec6e57e43c7b0ff10bd3/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=b85a3da421abad7d1936ec6e57e43c7b0ff10bd3", "patch": "@@ -1214,21 +1214,20 @@ impl<'a> Parser<'a> {\n     /// Parses `extern string_literal?`.\n     fn parse_extern(&mut self) -> PResult<'a, Extern> {\n         Ok(if self.eat_keyword(kw::Extern) {\n-            Extern::from_abi(self.parse_opt_abi()?)\n+            Extern::from_abi(self.parse_opt_abi())\n         } else {\n             Extern::None\n         })\n     }\n \n     /// Parses a string literal as an ABI spec.\n-    fn parse_opt_abi(&mut self) -> PResult<'a, Option<StrLit>> {\n-        if self.token.can_begin_literal_or_bool() {\n-            let ast::Lit { token: token::Lit { symbol, suffix, .. }, span, kind }\n-                = self.parse_lit()?;\n+    fn parse_opt_abi(&mut self) -> Option<StrLit> {\n+        if let Some(ast::Lit { token: token::Lit { symbol, suffix, .. }, span, kind })\n+                = self.parse_opt_lit() {\n             match kind {\n-                ast::LitKind::Str(symbol_unescaped, style) => return Ok(Some(StrLit {\n+                ast::LitKind::Str(symbol_unescaped, style) => return Some(StrLit {\n                     style, symbol, suffix, span, symbol_unescaped,\n-                })),\n+                }),\n                 ast::LitKind::Err(_) => {}\n                 _ => {\n                     self.struct_span_err(span, \"non-string ABI literal\")\n@@ -1242,7 +1241,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         }\n-        Ok(None)\n+        None\n     }\n \n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error."}]}