{"sha": "28847e5c37d27438ce865ab40f3c4e3799051974", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ODQ3ZTVjMzdkMjc0MzhjZTg2NWFiNDBmM2M0ZTM3OTkwNTE5NzQ=", "commit": {"author": {"name": "Tyler Ruckinger", "email": "t.ruckinger@gmail.com", "date": "2020-04-23T14:47:30Z"}, "committer": {"name": "Tyler Ruckinger", "email": "t.ruckinger@gmail.com", "date": "2020-04-23T14:47:30Z"}, "message": "Merge branch 'master' into fix-doc-links", "tree": {"sha": "a8608243907395aaac0daeb74fd253c7bb702aa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8608243907395aaac0daeb74fd253c7bb702aa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28847e5c37d27438ce865ab40f3c4e3799051974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28847e5c37d27438ce865ab40f3c4e3799051974", "html_url": "https://github.com/rust-lang/rust/commit/28847e5c37d27438ce865ab40f3c4e3799051974", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28847e5c37d27438ce865ab40f3c4e3799051974/comments", "author": {"login": "TyPR124", "id": 29851190, "node_id": "MDQ6VXNlcjI5ODUxMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/29851190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TyPR124", "html_url": "https://github.com/TyPR124", "followers_url": "https://api.github.com/users/TyPR124/followers", "following_url": "https://api.github.com/users/TyPR124/following{/other_user}", "gists_url": "https://api.github.com/users/TyPR124/gists{/gist_id}", "starred_url": "https://api.github.com/users/TyPR124/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TyPR124/subscriptions", "organizations_url": "https://api.github.com/users/TyPR124/orgs", "repos_url": "https://api.github.com/users/TyPR124/repos", "events_url": "https://api.github.com/users/TyPR124/events{/privacy}", "received_events_url": "https://api.github.com/users/TyPR124/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TyPR124", "id": 29851190, "node_id": "MDQ6VXNlcjI5ODUxMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/29851190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TyPR124", "html_url": "https://github.com/TyPR124", "followers_url": "https://api.github.com/users/TyPR124/followers", "following_url": "https://api.github.com/users/TyPR124/following{/other_user}", "gists_url": "https://api.github.com/users/TyPR124/gists{/gist_id}", "starred_url": "https://api.github.com/users/TyPR124/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TyPR124/subscriptions", "organizations_url": "https://api.github.com/users/TyPR124/orgs", "repos_url": "https://api.github.com/users/TyPR124/repos", "events_url": "https://api.github.com/users/TyPR124/events{/privacy}", "received_events_url": "https://api.github.com/users/TyPR124/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547219c7e4f375f1ae8dcbfadce2fec4ae639730", "url": "https://api.github.com/repos/rust-lang/rust/commits/547219c7e4f375f1ae8dcbfadce2fec4ae639730", "html_url": "https://github.com/rust-lang/rust/commit/547219c7e4f375f1ae8dcbfadce2fec4ae639730"}, {"sha": "66f7a5d92f5adb9053bf66e0bf8f6d31d404870d", "url": "https://api.github.com/repos/rust-lang/rust/commits/66f7a5d92f5adb9053bf66e0bf8f6d31d404870d", "html_url": "https://github.com/rust-lang/rust/commit/66f7a5d92f5adb9053bf66e0bf8f6d31d404870d"}], "stats": {"total": 1623, "additions": 804, "deletions": 819}, "files": [{"sha": "86a6fa7f8ba3c82a6113225b03e7c4302ab2f3e9", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -18,7 +18,7 @@ use crate::ptr::{self, NonNull};\n /// something wrong when combining the given input arguments with this\n /// allocator.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct AllocErr;\n \n // (we need this for downstream impl of trait Error)"}, {"sha": "549933ceeb6457f13813fbced35c37effe67a12f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -709,6 +709,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// So this, for example, can only be done on types implementing `Unpin`:\n ///\n /// ```rust\n+/// # #![allow(unused_must_use)]\n /// use std::mem;\n /// use std::pin::Pin;\n ///"}, {"sha": "3fa2b7a2d042c3e2755612e117d8b54411ed054c", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -808,6 +808,7 @@ pub fn take<T: Default>(dest: &mut T) -> T {\n /// [`Clone`]: ../../std/clone/trait.Clone.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[must_use = \"if you don't need the old value, you can just assign the new value directly\"]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src"}, {"sha": "d2222d12623f9b8cd81778e2177cb7e4cc205c6d", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -290,6 +290,13 @@ impl BridgeState<'_> {\n }\n \n impl Bridge<'_> {\n+    pub(crate) fn is_available() -> bool {\n+        BridgeState::with(|state| match state {\n+            BridgeState::Connected(_) | BridgeState::InUse => true,\n+            BridgeState::NotConnected => false,\n+        })\n+    }\n+\n     fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n         // Hide the default panic output within `proc_macro` expansions.\n         // NB. the server can't do this because it may use a different libstd."}, {"sha": "3cbe852de7b5a4722d6c0d7a91dbf972d613a9e5", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -45,6 +45,24 @@ use std::path::PathBuf;\n use std::str::FromStr;\n use std::{error, fmt, iter, mem};\n \n+/// Determines whether proc_macro has been made accessible to the currently\n+/// running program.\n+///\n+/// The proc_macro crate is only intended for use inside the implementation of\n+/// procedural macros. All the functions in this crate panic if invoked from\n+/// outside of a procedural macro, such as from a build script or unit test or\n+/// ordinary Rust binary.\n+///\n+/// With consideration for Rust libraries that are designed to support both\n+/// macro and non-macro use cases, `proc_macro::is_available()` provides a\n+/// non-panicking way to detect whether the infrastructure required to use the\n+/// API of proc_macro is presently available. Returns true if invoked from\n+/// inside of a procedural macro, false if invoked from any other binary.\n+#[unstable(feature = \"proc_macro_is_available\", issue = \"71436\")]\n+pub fn is_available() -> bool {\n+    bridge::Bridge::is_available()\n+}\n+\n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n /// The type provide interfaces for iterating over those token trees and, conversely,"}, {"sha": "a677ffea3af1708110b8b5e80b7af223acce7405", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -120,7 +120,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.local, proj_base, *self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.local, proj_base, self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access."}, {"sha": "dfb1656a6e0cb820d2aefd8aff04f392fc0f3d2f", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n     // a loop.\n     fn maybe_sideeffect<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        mir: mir::ReadOnlyBodyAndCache<'tcx, 'tcx>,\n+        mir: &'tcx mir::Body<'tcx>,\n         bx: &mut Bx,\n         targets: &[mir::BasicBlock],\n     ) {\n@@ -306,7 +306,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(*self.mir, bx.tcx()).ty;\n+        let ty = location.ty(self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n@@ -572,7 +572,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let extra_args = extra_args\n             .iter()\n             .map(|op_arg| {\n-                let op_ty = op_arg.ty(*self.mir, bx.tcx());\n+                let op_ty = op_arg.ty(self.mir, bx.tcx());\n                 self.monomorphize(&op_ty)\n             })\n             .collect::<Vec<_>>();"}, {"sha": "cb6d2d297cd735afccac48dca0922c26b01be707", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -21,7 +21,7 @@ use self::operand::{OperandRef, OperandValue};\n pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n-    mir: mir::ReadOnlyBodyAndCache<'tcx, 'tcx>,\n+    mir: &'tcx mir::Body<'tcx>,\n \n     debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n \n@@ -169,7 +169,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         .collect();\n \n     let (landing_pads, funclets) = create_funclets(&mir, &mut bx, &cleanup_kinds, &block_bxs);\n-    let mir_body: &mir::Body<'_> = *mir;\n     let mut fx = FunctionCx {\n         instance,\n         mir,\n@@ -197,7 +196,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let args = arg_local_refs(&mut bx, &mut fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n-            let decl = &mir_body.local_decls[local];\n+            let decl = &mir.local_decls[local];\n             let layout = bx.layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n@@ -223,7 +222,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let retptr = allocate_local(mir::RETURN_PLACE);\n         iter::once(retptr)\n             .chain(args.into_iter())\n-            .chain(mir_body.vars_and_temps_iter().map(allocate_local))\n+            .chain(mir.vars_and_temps_iter().map(allocate_local))\n             .collect()\n     };\n \n@@ -235,8 +234,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.br(fx.blocks[mir::START_BLOCK]);\n     }\n \n-    let rpo = traversal::reverse_postorder(&mir_body);\n-    let mut visited = BitSet::new_empty(mir_body.basic_blocks().len());\n+    let rpo = traversal::reverse_postorder(&mir);\n+    let mut visited = BitSet::new_empty(mir.basic_blocks().len());\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in rpo {\n@@ -246,7 +245,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n-    for bb in mir_body.basic_blocks().indices() {\n+    for bb in mir.basic_blocks().indices() {\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n             debug!(\"codegen_mir: block {:?} was not visited\", bb);"}, {"sha": "aaba2ec1362ac77e25b1b4b5331c59983a7d8fad", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, *self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, self.mir, tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "19a0138d9cb6d026fd23a2a95dc044bb985aa6cf", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(*self.mir, bx.tcx());\n+                let discr_ty = rvalue.ty(self.mir, bx.tcx());\n                 let discr = self\n                     .codegen_place(&mut bx, place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n@@ -529,7 +529,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Repeat(..) | mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(*self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 let operand =\n                     OperandRef::new_zst(&mut bx, self.cx.layout_of(self.monomorphize(&ty)));\n                 (bx, operand)\n@@ -749,7 +749,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(*self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "07d16c6483ec797cbec35e747dda60f9d277c343", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -97,12 +97,17 @@ use std::time::{Duration, Instant};\n use measureme::{EventId, EventIdBuilder, SerializableString, StringId};\n use parking_lot::RwLock;\n \n-/// MmapSerializatioSink is faster on macOS and Linux\n-/// but FileSerializationSink is faster on Windows\n-#[cfg(not(windows))]\n-type SerializationSink = measureme::MmapSerializationSink;\n-#[cfg(windows)]\n-type SerializationSink = measureme::FileSerializationSink;\n+cfg_if! {\n+    if #[cfg(any(windows, target_os = \"wasi\"))] {\n+        /// FileSerializationSink is faster on Windows\n+        type SerializationSink = measureme::FileSerializationSink;\n+    } else if #[cfg(target_arch = \"wasm32\")] {\n+        type SerializationSink = measureme::ByteVecSink;\n+    } else {\n+        /// MmapSerializatioSink is faster on macOS and Linux\n+        type SerializationSink = measureme::MmapSerializationSink;\n+    }\n+}\n \n type Profiler = measureme::Profiler<SerializationSink>;\n \n@@ -602,31 +607,37 @@ pub fn duration_to_secs_str(dur: std::time::Duration) -> String {\n }\n \n // Memory reporting\n-#[cfg(unix)]\n-fn get_resident() -> Option<usize> {\n-    let field = 1;\n-    let contents = fs::read(\"/proc/self/statm\").ok()?;\n-    let contents = String::from_utf8(contents).ok()?;\n-    let s = contents.split_whitespace().nth(field)?;\n-    let npages = s.parse::<usize>().ok()?;\n-    Some(npages * 4096)\n-}\n-\n-#[cfg(windows)]\n-fn get_resident() -> Option<usize> {\n-    use std::mem::{self, MaybeUninit};\n-    use winapi::shared::minwindef::DWORD;\n-    use winapi::um::processthreadsapi::GetCurrentProcess;\n-    use winapi::um::psapi::{GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS};\n-\n-    let mut pmc = MaybeUninit::<PROCESS_MEMORY_COUNTERS>::uninit();\n-    match unsafe {\n-        GetProcessMemoryInfo(GetCurrentProcess(), pmc.as_mut_ptr(), mem::size_of_val(&pmc) as DWORD)\n-    } {\n-        0 => None,\n-        _ => {\n-            let pmc = unsafe { pmc.assume_init() };\n-            Some(pmc.WorkingSetSize as usize)\n+cfg_if! {\n+    if #[cfg(windows)] {\n+        fn get_resident() -> Option<usize> {\n+            use std::mem::{self, MaybeUninit};\n+            use winapi::shared::minwindef::DWORD;\n+            use winapi::um::processthreadsapi::GetCurrentProcess;\n+            use winapi::um::psapi::{GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS};\n+\n+            let mut pmc = MaybeUninit::<PROCESS_MEMORY_COUNTERS>::uninit();\n+            match unsafe {\n+                GetProcessMemoryInfo(GetCurrentProcess(), pmc.as_mut_ptr(), mem::size_of_val(&pmc) as DWORD)\n+            } {\n+                0 => None,\n+                _ => {\n+                    let pmc = unsafe { pmc.assume_init() };\n+                    Some(pmc.WorkingSetSize as usize)\n+                }\n+            }\n+        }\n+    } else if #[cfg(unix)] {\n+        fn get_resident() -> Option<usize> {\n+            let field = 1;\n+            let contents = fs::read(\"/proc/self/statm\").ok()?;\n+            let contents = String::from_utf8(contents).ok()?;\n+            let s = contents.split_whitespace().nth(field)?;\n+            let npages = s.parse::<usize>().ok()?;\n+            Some(npages * 4096)\n+        }\n+    } else {\n+        fn get_resident() -> Option<usize> {\n+            None\n         }\n     }\n }"}, {"sha": "e6906d72367d8faa346ff943faa9ff69e5f2c18b", "filename": "src/librustc_error_codes/error_codes/E0060.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,12 +2,14 @@ External C functions are allowed to be variadic. However, a variadic function\n takes a minimum number of arguments. For example, consider C's variadic `printf`\n function:\n \n-```\n+```compile_fail,E0060\n use std::os::raw::{c_char, c_int};\n \n extern \"C\" {\n     fn printf(_: *const c_char, ...) -> c_int;\n }\n+\n+unsafe { printf(); } // error!\n ```\n \n Using this declaration, it must be called with at least one argument, so"}, {"sha": "a270feaf58c17cb44cbfd9f0f08b1036ffb1b2df", "filename": "src/librustc_error_codes/error_codes/E0130.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,7 +2,7 @@ A pattern was declared as an argument in a foreign function declaration.\n \n Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0130\n extern {\n     fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign\n                                 //        function declarations"}, {"sha": "90f1e54287496fb7f32d90af946fd1673811c4db", "filename": "src/librustc_error_codes/error_codes/E0198.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,7 +2,7 @@ A negative implementation was marked as unsafe.\n \n Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0198\n struct Foo;\n \n unsafe impl !Clone for Foo { } // error!"}, {"sha": "afc61ec2e48ff87fc80b0c9733a3c8360f624ccc", "filename": "src/librustc_error_codes/error_codes/E0202.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,5 +1,15 @@\n Inherent associated types were part of [RFC 195] but are not yet implemented.\n See [the tracking issue][iss8995] for the status of this implementation.\n \n+Erroneous code example:\n+\n+```compile_fail,E0202\n+struct Foo;\n+\n+impl Foo {\n+    type Bar = isize; // error!\n+}\n+```\n+\n [RFC 195]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md\n [iss8995]: https://github.com/rust-lang/rust/issues/8995"}, {"sha": "cfb72e74319c1400816441e91bd69c7b66e703e7", "filename": "src/librustc_error_codes/error_codes/E0230.md", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,15 +3,11 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```compile_fail\n+```compile_fail,E0230\n #![feature(rustc_attrs)]\n \n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n+#[rustc_on_unimplemented = \"error on `{Self}` with params `<{A},{B}>`\"] // error\n+trait BadAnnotation<A> {}\n ```\n \n There will be an error about `bool` not implementing `Index<u8>`, followed by a"}, {"sha": "23a0a88ecdd9baf599d8fd58a05fd3f4544071ff", "filename": "src/librustc_error_codes/error_codes/E0231.md", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,15 +3,11 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```compile_fail\n+```compile_fail,E0231\n #![feature(rustc_attrs)]\n \n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n+#[rustc_on_unimplemented = \"error on `{Self}` with params `<{A},{}>`\"] // error!\n+trait BadAnnotation<A> {}\n ```\n \n there will be an error about `bool` not implementing `Index<u8>`, followed by a"}, {"sha": "b310caefa6e31165b4a3843a6c046868bd443c65", "filename": "src/librustc_error_codes/error_codes/E0232.md", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,15 +3,11 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```compile_fail\n+```compile_fail,E0232\n #![feature(rustc_attrs)]\n \n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n+#[rustc_on_unimplemented(lorem=\"\")] // error!\n+trait BadAnnotation {}\n ```\n \n there will be an error about `bool` not implementing `Index<u8>`, followed by a"}, {"sha": "1d7904b67ddb4b75f3142e4943f477903587ae69", "filename": "src/librustc_error_codes/error_codes/E0281.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -4,7 +4,7 @@ You tried to supply a type which doesn't implement some trait in a location\n which expected that trait. This error typically occurs when working with\n `Fn`-based types. Erroneous code example:\n \n-```compile-fail\n+```compile_fail\n fn foo<F: Fn(usize)>(x: F) { }\n \n fn main() {"}, {"sha": "d01fb0c9c4229427a140311d2165c54415435487", "filename": "src/librustc_error_codes/error_codes/E0364.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,27 +3,27 @@ attempted to `pub use` a type or value that was not itself public.\n \n Erroneous code example:\n \n-```compile_fail\n-mod foo {\n-    const X: u32 = 1;\n-}\n-\n-pub use foo::X;\n+```compile_fail,E0364\n+mod a {\n+    fn foo() {}\n \n-fn main() {}\n+    mod a {\n+        pub use super::foo; // error!\n+    }\n+}\n ```\n \n The solution to this problem is to ensure that the items that you are\n re-exporting are themselves marked with `pub`:\n \n ```\n-mod foo {\n-    pub const X: u32 = 1;\n-}\n-\n-pub use foo::X;\n+mod a {\n+    pub fn foo() {} // ok!\n \n-fn main() {}\n+    mod a {\n+        pub use super::foo;\n+    }\n+}\n ```\n \n See the [Use Declarations][use-declarations] section of the reference for"}, {"sha": "c6fe997f3dcfc8443d4b551b77f31229bd16a890", "filename": "src/librustc_error_codes/error_codes/E0378.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,7 +3,7 @@ or a newtype wrapper around a pointer.\n \n Erroneous code example:\n \n-```compile-fail,E0378\n+```compile_fail,E0378\n #![feature(dispatch_from_dyn)]\n use std::ops::DispatchFromDyn;\n "}, {"sha": "df7aa4f0a1e8dd3c3ff35d203701ba401dfc07e6", "filename": "src/librustc_error_codes/error_codes/E0590.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,7 +3,7 @@\n \n Example of erroneous code:\n \n-```compile_fail\n+```compile_fail,E0590\n while break {}\n ```\n "}, {"sha": "4646e37fb752632e69aa9e02e6479acee83b5a8e", "filename": "src/librustc_error_codes/error_codes/E0639.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0639.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0639.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0639.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,5 +3,17 @@ instantiated from outside of the defining crate as it has been marked\n as `non_exhaustive` and as such more fields/variants may be added in\n future that could cause adverse side effects for this code.\n \n+Erroneous code example:\n+\n+```ignore (it only works cross-crate)\n+#[non_exhaustive]\n+pub struct NormalStruct {\n+    pub first_field: u16,\n+    pub second_field: u16,\n+}\n+\n+let ns = NormalStruct { first_field: 640, second_field: 480 }; // error!\n+```\n+\n It is recommended that you look for a `new` function or equivalent in the\n crate's documentation."}, {"sha": "277643dfb1ab7d7ddffa4c2d861f590454c87976", "filename": "src/librustc_error_codes/error_codes/E0644.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,17 +2,17 @@ A closure or generator was constructed that references its own type.\n \n Erroneous example:\n \n-```compile-fail,E0644\n+```compile_fail,E0644\n fn fix<F>(f: &F)\n   where F: Fn(&F)\n {\n-  f(&f);\n+    f(&f);\n }\n \n fn main() {\n-  fix(&|y| {\n-    // Here, when `x` is called, the parameter `y` is equal to `x`.\n-  });\n+    fix(&|y| {\n+        // Here, when `x` is called, the parameter `y` is equal to `x`.\n+    });\n }\n ```\n "}, {"sha": "d821b9027f1363a6f9f86f14ec6c799e30db2c13", "filename": "src/librustc_error_codes/error_codes/E0658.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0658.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0658.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0658.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,7 +2,7 @@ An unstable feature was used.\n \n Erroneous code example:\n \n-```compile_fail,E658\n+```compile_fail,E0658\n #[repr(u128)] // error: use of unstable library feature 'repr128'\n enum Foo {\n     Bar(u64),"}, {"sha": "f078c441b342190c61b9dd4ab042a746718a8029", "filename": "src/librustc_error_codes/error_codes/E0669.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0669.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0669.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0669.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,5 +1,17 @@\n Cannot convert inline assembly operand to a single LLVM value.\n \n+Erroneous code example:\n+\n+```compile_fail,E0669\n+#![feature(llvm_asm)]\n+\n+fn main() {\n+    unsafe {\n+        llvm_asm!(\"\" :: \"r\"(\"\")); // error!\n+    }\n+}\n+```\n+\n This error usually happens when trying to pass in a value to an input inline\n assembly operand that is actually a pair of values. In particular, this can\n happen when trying to pass in a slice, for instance a `&str`. In Rust, these"}, {"sha": "3ba992a8476eda588872ef0ca9557a68afdc1754", "filename": "src/librustc_error_codes/error_codes/E0698.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0698.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0698.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0698.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,7 +3,7 @@ generator can be constructed.\n \n Erroneous code example:\n \n-```edition2018,compile-fail,E0698\n+```edition2018,compile_fail,E0698\n async fn bar<T>() -> () {}\n \n async fn foo() {"}, {"sha": "b1eb8b66ad682cf165a86d7323061340499669d9", "filename": "src/librustc_error_codes/error_codes/E0700.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0700.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0700.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0700.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,7 +3,7 @@ appear within the `impl Trait` itself.\n \n Erroneous code example:\n \n-```compile-fail,E0700\n+```compile_fail,E0700\n use std::cell::Cell;\n \n trait Trait<'a> { }"}, {"sha": "9287fc803d1de792ae03a81c932af0ad217933a1", "filename": "src/librustc_error_codes/error_codes/E0708.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0708.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0708.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0708.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,7 +2,7 @@\n \n Erroneous code example:\n \n-```compile_fail,edition2018\n+```compile_fail,edition2018,E0708\n #![feature(async_closure)]\n \n fn main() {"}, {"sha": "45d1cafa690624a0e49bf753cabfe4695d86e94d", "filename": "src/librustc_error_codes/error_codes/E0714.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0714.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0714.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0714.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,5 +1,19 @@\n A `#[marker]` trait contained an associated item.\n \n+Erroneous code example:\n+\n+```compile_fail,E0714\n+#![feature(marker_trait_attr)]\n+#![feature(associated_type_defaults)]\n+\n+#[marker]\n+trait MarkerConst {\n+    const N: usize; // error!\n+}\n+\n+fn main() {}\n+```\n+\n The items of marker traits cannot be overridden, so there's no need to have them\n when they cannot be changed per-type anyway.  If you wanted them for ergonomic\n reasons, consider making an extension trait instead."}, {"sha": "8f0022d9425471de4ef3357962e6f5620bdd9865", "filename": "src/librustc_error_codes/error_codes/E0715.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0715.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0715.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0715.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,5 +1,24 @@\n An `impl` for a `#[marker]` trait tried to override an associated item.\n \n+Erroneous code example:\n+\n+```compile_fail,E0715\n+#![feature(marker_trait_attr)]\n+\n+#[marker]\n+trait Marker {\n+    const N: usize = 0;\n+    fn do_something() {}\n+}\n+\n+struct OverrideConst;\n+impl Marker for OverrideConst { // error!\n+    const N: usize = 1;\n+}\n+\n+fn main() {}\n+```\n+\n Because marker traits are allowed to have multiple implementations for the same\n type, it's not allowed to override anything in those implementations, as it\n would be ambiguous which override should actually be used."}, {"sha": "be1b68e645d012ca3223c1627a8b5f3fe01d40ae", "filename": "src/librustc_error_codes/error_codes/E0727.md", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,25 +2,29 @@ A `yield` clause was used in an `async` context.\n \n Example of erroneous code:\n \n-```compile_fail\n+```compile_fail,E0727,edition2018\n #![feature(generators)]\n \n-let generator = || {\n-    async {\n-        yield;\n-    }\n-};\n+fn main() {\n+    let generator = || {\n+        async {\n+            yield;\n+        }\n+    };\n+}\n ```\n \n Here, the `yield` keyword is used in an `async` block,\n which is not yet supported.\n \n To fix this error, you have to move `yield` out of the `async` block:\n \n-```\n+```edition2018\n #![feature(generators)]\n \n-let generator = || {\n-    yield;\n-};\n+fn main() {\n+    let generator = || {\n+        yield;\n+    };\n+}\n ```"}, {"sha": "7347e6654c5b3acd99a55085d01791edebdd22b7", "filename": "src/librustc_error_codes/error_codes/E0732.md", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0732.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0732.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0732.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,5 +1,18 @@\n An `enum` with a discriminant must specify a `#[repr(inttype)]`.\n \n+Erroneous code example:\n+\n+```compile_fail,E0732\n+#![feature(arbitrary_enum_discriminant)]\n+\n+enum Enum { // error!\n+    Unit = 1,\n+    Tuple() = 2,\n+    Struct{} = 3,\n+}\n+# fn main() {}\n+```\n+\n A `#[repr(inttype)]` must be provided on an `enum` if it has a non-unit\n variant with a discriminant, or where there are both unit variants with\n discriminants and non-unit variants. This restriction ensures that there\n@@ -23,7 +36,9 @@ fn discriminant(v : &Enum) -> u8 {\n     unsafe { *(v as *const Enum as *const u8) }\n }\n \n-assert_eq!(3, discriminant(&Enum::Unit));\n-assert_eq!(2, discriminant(&Enum::Tuple(5)));\n-assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n+fn main() {\n+    assert_eq!(3, discriminant(&Enum::Unit));\n+    assert_eq!(2, discriminant(&Enum::Tuple(5)));\n+    assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n+}\n ```"}, {"sha": "37776785189643880ea89fd18f6f6af256ad22e6", "filename": "src/librustc_error_codes/error_codes/E0740.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1 +1,16 @@\n A `union` cannot have fields with destructors.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0740\n+union Test {\n+    a: A, // error!\n+}\n+\n+#[derive(Debug)]\n+struct A(i32);\n+\n+impl Drop for A {\n+    fn drop(&mut self) { println!(\"A\"); }\n+}\n+```"}, {"sha": "56b947a8282edb585ee2416f4e96426e5478d7af", "filename": "src/librustc_error_codes/error_codes/E0744.md", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,16 +3,13 @@ Control-flow expressions are not allowed inside a const context.\n At the moment, `if` and `match`, as well as the looping constructs `for`,\n `while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n \n-```compile_fail,E0658\n+```compile_fail,E0744\n const _: i32 = {\n     let mut x = 0;\n-    loop {\n-        x += 1;\n-        if x == 4 {\n-            break;\n-        }\n+\n+    for i in 0..4 { // error!\n+        x += i;\n     }\n-    x\n };\n ```\n "}, {"sha": "1fb260f66fa3bb47223560a5998e86d0beb30a84", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::middle::cstore::{CrateSource, ExternCrate};\n use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLibrary};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_middle::mir::{self, interpret, BodyAndCache, Promoted};\n+use rustc_middle::mir::{self, interpret, Body, Promoted};\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util::common::record_time;\n@@ -1099,40 +1099,28 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         !self.is_proc_macro(id) && self.root.tables.mir.get(self, id).is_some()\n     }\n \n-    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> BodyAndCache<'tcx> {\n-        let mut cache = self\n-            .root\n+    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+        self.root\n             .tables\n             .mir\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n-            .decode((self, tcx));\n-        cache.ensure_predecessors();\n-        cache\n+            .decode((self, tcx))\n     }\n \n-    fn get_promoted_mir(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        id: DefIndex,\n-    ) -> IndexVec<Promoted, BodyAndCache<'tcx>> {\n-        let mut cache = self\n-            .root\n+    fn get_promoted_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> IndexVec<Promoted, Body<'tcx>> {\n+        self.root\n             .tables\n             .promoted_mir\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n-            .decode((self, tcx));\n-        for body in cache.iter_mut() {\n-            body.ensure_predecessors();\n-        }\n-        cache\n+            .decode((self, tcx))\n     }\n \n     fn mir_const_qualif(&self, id: DefIndex) -> mir::ConstQualifs {"}, {"sha": "b56198724db0bbf6a713a7525bcc4f94915b7437", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -68,6 +68,7 @@ macro_rules! encoder_methods {\n impl<'tcx> Encoder for EncodeContext<'tcx> {\n     type Error = <opaque::Encoder as Encoder>::Error;\n \n+    #[inline]\n     fn emit_unit(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n     }"}, {"sha": "e2d979ae48828adef114a5eb9315632ccddc97ec", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -275,8 +275,8 @@ define_tables! {\n     // Also, as an optimization, a missing entry indicates an empty `&[]`.\n     inferred_outlives: Table<DefIndex, Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>,\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n-    mir: Table<DefIndex, Lazy!(mir::BodyAndCache<'tcx>)>,\n-    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::BodyAndCache<'tcx>>)>,\n+    mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n+    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "0409f1f38e14a67a6538cae69b3bb9bdab4f9f60", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -15,17 +15,17 @@ macro_rules! arena_types {\n             [] generics: rustc_middle::ty::Generics,\n             [] trait_def: rustc_middle::ty::TraitDef,\n             [] adt_def: rustc_middle::ty::AdtDef,\n-            [] steal_mir: rustc_middle::ty::steal::Steal<rustc_middle::mir::BodyAndCache<$tcx>>,\n-            [] mir: rustc_middle::mir::BodyAndCache<$tcx>,\n+            [] steal_mir: rustc_middle::ty::steal::Steal<rustc_middle::mir::Body<$tcx>>,\n+            [] mir: rustc_middle::mir::Body<$tcx>,\n             [] steal_promoted: rustc_middle::ty::steal::Steal<\n                 rustc_index::vec::IndexVec<\n                     rustc_middle::mir::Promoted,\n-                    rustc_middle::mir::BodyAndCache<$tcx>\n+                    rustc_middle::mir::Body<$tcx>\n                 >\n             >,\n             [] promoted: rustc_index::vec::IndexVec<\n                 rustc_middle::mir::Promoted,\n-                rustc_middle::mir::BodyAndCache<$tcx>\n+                rustc_middle::mir::Body<$tcx>\n             >,\n             [decode] tables: rustc_middle::ty::TypeckTables<$tcx>,\n             [decode] borrowck_result: rustc_middle::mir::BorrowCheckResult<$tcx>,"}, {"sha": "12822cea418d7b9bdd83558b391d6b6d0789b0a4", "filename": "src/librustc_middle/mir/cache.rs", "status": "removed", "additions": 0, "deletions": 276, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/547219c7e4f375f1ae8dcbfadce2fec4ae639730/src%2Flibrustc_middle%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547219c7e4f375f1ae8dcbfadce2fec4ae639730/src%2Flibrustc_middle%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcache.rs?ref=547219c7e4f375f1ae8dcbfadce2fec4ae639730", "patch": "@@ -1,276 +0,0 @@\n-use crate::ich::StableHashingContext;\n-use crate::mir::{BasicBlock, BasicBlockData, Body, LocalDecls, Location, Successors};\n-use rustc_data_structures::graph::dominators::{dominators, Dominators};\n-use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use smallvec::SmallVec;\n-use std::iter;\n-use std::ops::{Deref, DerefMut, Index, IndexMut};\n-use std::vec::IntoIter;\n-\n-#[derive(Clone, Debug)]\n-pub struct Cache {\n-    // Typically 95%+ of the inner vectors have 4 or fewer elements.\n-    predecessors: Option<IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>>,\n-}\n-\n-impl rustc_serialize::Encodable for Cache {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&(), s)\n-    }\n-}\n-\n-impl rustc_serialize::Decodable for Cache {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n-        Decodable::decode(d).map(|_v: ()| Self::new())\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n-    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n-        // Do nothing.\n-    }\n-}\n-\n-impl Cache {\n-    pub fn new() -> Self {\n-        Self { predecessors: None }\n-    }\n-\n-    pub fn invalidate_predecessors(&mut self) {\n-        // FIXME: consider being more fine-grained\n-        self.predecessors = None;\n-    }\n-\n-    pub fn ensure_predecessors(&mut self, body: &Body<'_>) {\n-        if self.predecessors.is_none() {\n-            let mut result = IndexVec::from_elem(smallvec![], body.basic_blocks());\n-            for (bb, data) in body.basic_blocks().iter_enumerated() {\n-                if let Some(ref term) = data.terminator {\n-                    for &tgt in term.successors() {\n-                        result[tgt].push(bb);\n-                    }\n-                }\n-            }\n-\n-            self.predecessors = Some(result)\n-        }\n-    }\n-\n-    /// This will recompute the predecessors cache if it is not available\n-    fn predecessors(\n-        &mut self,\n-        body: &Body<'_>,\n-    ) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n-        self.ensure_predecessors(body);\n-        self.predecessors.as_ref().unwrap()\n-    }\n-\n-    fn unwrap_predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n-        &self.predecessors.as_ref().unwrap()[bb]\n-    }\n-\n-    fn unwrap_predecessor_locations<'a>(\n-        &'a self,\n-        loc: Location,\n-        body: &'a Body<'a>,\n-    ) -> impl Iterator<Item = Location> + 'a {\n-        let if_zero_locations = if loc.statement_index == 0 {\n-            let predecessor_blocks = self.unwrap_predecessors_for(loc.block);\n-            let num_predecessor_blocks = predecessor_blocks.len();\n-            Some(\n-                (0..num_predecessor_blocks)\n-                    .map(move |i| predecessor_blocks[i])\n-                    .map(move |bb| body.terminator_loc(bb)),\n-            )\n-        } else {\n-            None\n-        };\n-\n-        let if_not_zero_locations = if loc.statement_index == 0 {\n-            None\n-        } else {\n-            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n-        };\n-\n-        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n-    }\n-\n-    pub fn basic_blocks_mut<'a, 'tcx>(\n-        &mut self,\n-        body: &'a mut Body<'tcx>,\n-    ) -> &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        debug!(\"bbm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n-        self.invalidate_predecessors();\n-        &mut body.basic_blocks\n-    }\n-\n-    pub fn basic_blocks_and_local_decls_mut<'a, 'tcx>(\n-        &mut self,\n-        body: &'a mut Body<'tcx>,\n-    ) -> (&'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &'a mut LocalDecls<'tcx>) {\n-        debug!(\"bbaldm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n-        self.invalidate_predecessors();\n-        (&mut body.basic_blocks, &mut body.local_decls)\n-    }\n-}\n-\n-#[derive(Clone, Debug, HashStable, RustcEncodable, RustcDecodable, TypeFoldable)]\n-pub struct BodyAndCache<'tcx> {\n-    body: Body<'tcx>,\n-    cache: Cache,\n-}\n-\n-impl BodyAndCache<'tcx> {\n-    pub fn new(body: Body<'tcx>) -> Self {\n-        Self { body, cache: Cache::new() }\n-    }\n-}\n-\n-#[macro_export]\n-macro_rules! read_only {\n-    ($body:expr) => {{\n-        $body.ensure_predecessors();\n-        $body.unwrap_read_only()\n-    }};\n-}\n-\n-impl BodyAndCache<'tcx> {\n-    pub fn ensure_predecessors(&mut self) {\n-        self.cache.ensure_predecessors(&self.body);\n-    }\n-\n-    pub fn predecessors(&mut self) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n-        self.cache.predecessors(&self.body)\n-    }\n-\n-    pub fn unwrap_read_only(&self) -> ReadOnlyBodyAndCache<'_, 'tcx> {\n-        ReadOnlyBodyAndCache::new(&self.body, &self.cache)\n-    }\n-\n-    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        self.cache.basic_blocks_mut(&mut self.body)\n-    }\n-\n-    pub fn basic_blocks_and_local_decls_mut(\n-        &mut self,\n-    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n-        self.cache.basic_blocks_and_local_decls_mut(&mut self.body)\n-    }\n-}\n-\n-impl<'tcx> Index<BasicBlock> for BodyAndCache<'tcx> {\n-    type Output = BasicBlockData<'tcx>;\n-\n-    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.body[index]\n-    }\n-}\n-\n-impl<'tcx> IndexMut<BasicBlock> for BodyAndCache<'tcx> {\n-    fn index_mut(&mut self, index: BasicBlock) -> &mut Self::Output {\n-        &mut self.basic_blocks_mut()[index]\n-    }\n-}\n-\n-impl<'tcx> Deref for BodyAndCache<'tcx> {\n-    type Target = Body<'tcx>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.body\n-    }\n-}\n-\n-impl<'tcx> DerefMut for BodyAndCache<'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.body\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct ReadOnlyBodyAndCache<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n-    cache: &'a Cache,\n-}\n-\n-impl ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn new(body: &'a Body<'tcx>, cache: &'a Cache) -> Self {\n-        assert!(\n-            cache.predecessors.is_some(),\n-            \"Cannot construct ReadOnlyBodyAndCache without computed predecessors\"\n-        );\n-        Self { body, cache }\n-    }\n-\n-    pub fn predecessors(&self) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n-        self.cache.predecessors.as_ref().unwrap()\n-    }\n-\n-    pub fn predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n-        self.cache.unwrap_predecessors_for(bb)\n-    }\n-\n-    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n-        self.cache.unwrap_predecessor_locations(loc, self.body)\n-    }\n-\n-    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        &self.body.basic_blocks\n-    }\n-\n-    pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(self)\n-    }\n-}\n-\n-impl graph::DirectedGraph for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    type Node = BasicBlock;\n-}\n-\n-impl graph::GraphPredecessors<'graph> for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    type Item = BasicBlock;\n-    type Iter = IntoIter<BasicBlock>;\n-}\n-\n-impl graph::WithPredecessors for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn predecessors(&self, node: Self::Node) -> <Self as GraphPredecessors<'_>>::Iter {\n-        self.cache.unwrap_predecessors_for(node).to_vec().into_iter()\n-    }\n-}\n-\n-impl graph::WithNumNodes for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn num_nodes(&self) -> usize {\n-        self.body.num_nodes()\n-    }\n-}\n-\n-impl graph::WithStartNode for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn start_node(&self) -> Self::Node {\n-        self.body.start_node()\n-    }\n-}\n-\n-impl graph::WithSuccessors for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n-        self.body.successors(node)\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    type Item = BasicBlock;\n-    type Iter = iter::Cloned<Successors<'b>>;\n-}\n-\n-impl Deref for ReadOnlyBodyAndCache<'a, 'tcx> {\n-    type Target = &'a Body<'tcx>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.body\n-    }\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    Cache,\n-}"}, {"sha": "e476729c11b4d3f6013e9d0dc2090842d3dccb9c", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 78, "deletions": 13, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -21,27 +21,28 @@ use polonius_engine::Atom;\n pub use rustc_ast::ast::Mutability;\n use rustc_ast::ast::Name;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors};\n+use rustc_data_structures::sync::MappedLockGuard;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n+use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::ops::Index;\n+use std::ops::{Index, IndexMut};\n use std::slice;\n use std::{iter, mem, option};\n \n-pub use self::cache::{BodyAndCache, ReadOnlyBodyAndCache};\n+use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n-pub use crate::read_only;\n \n-mod cache;\n pub mod interpret;\n pub mod mono;\n+mod predecessors;\n mod query;\n pub mod tcx;\n pub mod traversal;\n@@ -108,7 +109,7 @@ pub struct Body<'tcx> {\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue.\n-    pub generator_drop: Option<Box<BodyAndCache<'tcx>>>,\n+    pub generator_drop: Option<Box<Body<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n     pub generator_layout: Option<GeneratorLayout<'tcx>>,\n@@ -164,6 +165,8 @@ pub struct Body<'tcx> {\n     /// implementation without the flag hid this situation silently.\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n     pub ignore_interior_mut_in_const_validation: bool,\n+\n+    pub predecessor_cache: PredecessorCache,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -202,6 +205,7 @@ impl<'tcx> Body<'tcx> {\n             span,\n             ignore_interior_mut_in_const_validation: false,\n             control_flow_destroyed,\n+            predecessor_cache: PredecessorCache::new(),\n         }\n     }\n \n@@ -227,6 +231,7 @@ impl<'tcx> Body<'tcx> {\n             generator_kind: None,\n             var_debug_info: Vec::new(),\n             ignore_interior_mut_in_const_validation: false,\n+            predecessor_cache: PredecessorCache::new(),\n         }\n     }\n \n@@ -235,6 +240,25 @@ impl<'tcx> Body<'tcx> {\n         &self.basic_blocks\n     }\n \n+    #[inline]\n+    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        // Because the user could mutate basic block terminators via this reference, we need to\n+        // invalidate the predecessor cache.\n+        //\n+        // FIXME: Use a finer-grained API for this, so only transformations that alter terminators\n+        // invalidate the predecessor cache.\n+        self.predecessor_cache.invalidate();\n+        &mut self.basic_blocks\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks_and_local_decls_mut(\n+        &mut self,\n+    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n+        self.predecessor_cache.invalidate();\n+        (&mut self.basic_blocks, &mut self.local_decls)\n+    }\n+\n     /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n     /// `START_BLOCK`.\n     pub fn is_cfg_cyclic(&self) -> bool {\n@@ -357,14 +381,35 @@ impl<'tcx> Body<'tcx> {\n     }\n \n     /// Returns the return type; it always return first element from `local_decls` array.\n+    #[inline]\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n \n     /// Gets the location of the terminator for the given block.\n+    #[inline]\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n         Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n+\n+    #[inline]\n+    pub fn predecessors_for(\n+        &self,\n+        bb: BasicBlock,\n+    ) -> impl std::ops::Deref<Target = SmallVec<[BasicBlock; 4]>> + '_ {\n+        let predecessors = self.predecessor_cache.compute(&self.basic_blocks);\n+        MappedLockGuard::map(predecessors, |preds| &mut preds[bb])\n+    }\n+\n+    #[inline]\n+    pub fn predecessors(&self) -> impl std::ops::Deref<Target = Predecessors> + '_ {\n+        self.predecessor_cache.compute(&self.basic_blocks)\n+    }\n+\n+    #[inline]\n+    pub fn dominators(&self) -> Dominators<BasicBlock> {\n+        dominators(self)\n+    }\n }\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n@@ -387,6 +432,13 @@ impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n     }\n }\n \n+impl<'tcx> IndexMut<BasicBlock> for Body<'tcx> {\n+    #[inline]\n+    fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n+        &mut self.basic_blocks_mut()[index]\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n@@ -2591,18 +2643,21 @@ impl<'tcx> graph::DirectedGraph for Body<'tcx> {\n }\n \n impl<'tcx> graph::WithNumNodes for Body<'tcx> {\n+    #[inline]\n     fn num_nodes(&self) -> usize {\n         self.basic_blocks.len()\n     }\n }\n \n impl<'tcx> graph::WithStartNode for Body<'tcx> {\n+    #[inline]\n     fn start_node(&self) -> Self::Node {\n         START_BLOCK\n     }\n }\n \n impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n+    #[inline]\n     fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n         self.basic_blocks[node].terminator().successors().cloned()\n     }\n@@ -2613,6 +2668,18 @@ impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n     type Iter = iter::Cloned<Successors<'b>>;\n }\n \n+impl graph::GraphPredecessors<'graph> for Body<'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = smallvec::IntoIter<[BasicBlock; 4]>;\n+}\n+\n+impl graph::WithPredecessors for Body<'tcx> {\n+    #[inline]\n+    fn predecessors(&self, node: Self::Node) -> <Self as graph::GraphPredecessors<'_>>::Iter {\n+        self.predecessors_for(node).clone().into_iter()\n+    }\n+}\n+\n /// `Location` represents the position of the start of the statement; or, if\n /// `statement_index` equals the number of statements, then the start of the\n /// terminator.\n@@ -2642,25 +2709,23 @@ impl Location {\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n-    pub fn is_predecessor_of<'tcx>(\n-        &self,\n-        other: Location,\n-        body: ReadOnlyBodyAndCache<'_, 'tcx>,\n-    ) -> bool {\n+    pub fn is_predecessor_of<'tcx>(&self, other: Location, body: &Body<'tcx>) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n         if self.block == other.block && self.statement_index < other.statement_index {\n             return true;\n         }\n \n+        let predecessors = body.predecessors();\n+\n         // If we're in another block, then we want to check that block is a predecessor of `other`.\n-        let mut queue: Vec<BasicBlock> = body.predecessors_for(other.block).to_vec();\n+        let mut queue: Vec<BasicBlock> = predecessors[other.block].to_vec();\n         let mut visited = FxHashSet::default();\n \n         while let Some(block) = queue.pop() {\n             // If we haven't visited this block before, then make sure we visit it's predecessors.\n             if visited.insert(block) {\n-                queue.extend(body.predecessors_for(block).iter().cloned());\n+                queue.extend(predecessors[block].iter().cloned());\n             } else {\n                 continue;\n             }"}, {"sha": "629b5c2efb7112d944d0ffae708bb11183b0f271", "filename": "src/librustc_middle/mir/predecessors.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -0,0 +1,73 @@\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::{Lock, LockGuard, MappedLockGuard};\n+use rustc_index::vec::IndexVec;\n+use rustc_serialize as serialize;\n+use smallvec::SmallVec;\n+\n+use crate::mir::{BasicBlock, BasicBlockData};\n+\n+// Typically 95%+ of basic blocks have 4 or fewer predecessors.\n+pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n+\n+#[derive(Clone, Debug)]\n+pub struct PredecessorCache {\n+    cache: Lock<Option<Predecessors>>,\n+}\n+\n+impl PredecessorCache {\n+    #[inline]\n+    pub fn new() -> Self {\n+        PredecessorCache { cache: Lock::new(None) }\n+    }\n+\n+    #[inline]\n+    pub fn invalidate(&mut self) {\n+        *self.cache.get_mut() = None;\n+    }\n+\n+    #[inline]\n+    pub fn compute(\n+        &self,\n+        basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n+    ) -> MappedLockGuard<'_, Predecessors> {\n+        LockGuard::map(self.cache.lock(), |cache| {\n+            cache.get_or_insert_with(|| {\n+                let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n+                for (bb, data) in basic_blocks.iter_enumerated() {\n+                    if let Some(term) = &data.terminator {\n+                        for &succ in term.successors() {\n+                            preds[succ].push(bb);\n+                        }\n+                    }\n+                }\n+\n+                preds\n+            })\n+        })\n+    }\n+}\n+\n+impl serialize::Encodable for PredecessorCache {\n+    #[inline]\n+    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&(), s)\n+    }\n+}\n+\n+impl serialize::Decodable for PredecessorCache {\n+    #[inline]\n+    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for PredecessorCache {\n+    #[inline]\n+    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n+        // do nothing\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    PredecessorCache,\n+}"}, {"sha": "9f8355b0cb090b18121eea5289e869c086f8d67e", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -65,15 +65,6 @@ use rustc_span::Span;\n // variant argument) that does not require visiting, as in\n // `is_cleanup` above.\n \n-macro_rules! body_type {\n-    (mut $tcx:lifetime) => {\n-        &mut BodyAndCache<$tcx>\n-    };\n-    ($tcx:lifetime) => {\n-        &Body<$tcx>\n-    };\n-}\n-\n macro_rules! make_mir_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {\n@@ -82,7 +73,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_body(\n                 &mut self,\n-                body: body_type!($($mutability)? 'tcx)\n+                body: &$($mutability)? Body<'tcx>,\n             ) {\n                 self.super_body(body);\n             }\n@@ -247,7 +238,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_body(\n                 &mut self,\n-                $($mutability)? body: body_type!($($mutability)? 'tcx)\n+                body: &$($mutability)? Body<'tcx>,\n             ) {\n                 let span = body.span;\n                 if let Some(yield_ty) = &$($mutability)? body.yield_ty {\n@@ -268,7 +259,6 @@ macro_rules! make_mir_visitor {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n-                let body: & $($mutability)? Body<'_> = & $($mutability)? body;\n                 for scope in &$($mutability)? body.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n@@ -805,10 +795,14 @@ macro_rules! make_mir_visitor {\n \n             fn visit_location(\n                 &mut self,\n-                body: body_type!($($mutability)? 'tcx),\n+                body: &$($mutability)? Body<'tcx>,\n                 location: Location\n             ) {\n-                let basic_block = & $($mutability)? body[location.block];\n+                macro_rules! basic_blocks {\n+                    (mut) => (body.basic_blocks_mut());\n+                    () => (body.basic_blocks());\n+                };\n+                let basic_block = & $($mutability)? basic_blocks!($($mutability)?)[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(terminator, location)"}, {"sha": "c7eaf9cdbd0123d3d205f8530a36f4dbf17191d0", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -170,56 +170,46 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: DefId) -> &'tcx Steal<mir::BodyAndCache<'tcx>> {\n+        query mir_built(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n             desc { \"building MIR for\" }\n         }\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(_: DefId) -> &'tcx Steal<mir::BodyAndCache<'tcx>> {\n+        query mir_const(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n             no_hash\n         }\n \n         query mir_validated(_: DefId) ->\n             (\n-                &'tcx Steal<mir::BodyAndCache<'tcx>>,\n-                &'tcx Steal<IndexVec<mir::Promoted, mir::BodyAndCache<'tcx>>>\n+                &'tcx Steal<mir::Body<'tcx>>,\n+                &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n             ) {\n             no_hash\n         }\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-        query optimized_mir(key: DefId) -> &'tcx mir::BodyAndCache<'tcx> {\n+        query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n-                let mir: Option<crate::mir::BodyAndCache<'tcx>>\n+                let mir: Option<crate::mir::Body<'tcx>>\n                     = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n-                mir.map(|x| {\n-                    let cache = tcx.arena.alloc(x);\n-                    cache.ensure_predecessors();\n-                    &*cache\n-                })\n+                mir.map(|x| &*tcx.arena.alloc(x))\n             }\n         }\n \n-        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::BodyAndCache<'tcx>> {\n+        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let promoted: Option<\n                     rustc_index::vec::IndexVec<\n                         crate::mir::Promoted,\n-                        crate::mir::BodyAndCache<'tcx>\n+                        crate::mir::Body<'tcx>\n                     >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n-                promoted.map(|p| {\n-                    let cache = tcx.arena.alloc(p);\n-                    for body in cache.iter_mut() {\n-                        body.ensure_predecessors();\n-                    }\n-                    &*cache\n-                })\n+                promoted.map(|p| &*tcx.arena.alloc(p))\n             }\n         }\n     }\n@@ -618,7 +608,7 @@ rustc_queries! {\n         /// in the case of closures, this will be redirected to the enclosing function.\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n-        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::BodyAndCache<'tcx> {\n+        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Body<'tcx> {\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }\n "}, {"sha": "7f15179f7074f768f8c7af83f790d84d64e255a2", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -14,9 +14,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n use crate::mir::interpret::{Allocation, ConstValue, Scalar};\n-use crate::mir::{\n-    interpret, BodyAndCache, Field, Local, Place, PlaceElem, ProjectionKind, Promoted,\n-};\n+use crate::mir::{interpret, Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n use crate::traits::{Clause, Clauses, Goal, GoalKind, Goals};\n use crate::ty::query;\n@@ -993,21 +991,21 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn alloc_steal_mir(self, mir: BodyAndCache<'tcx>) -> &'tcx Steal<BodyAndCache<'tcx>> {\n+    pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> &'tcx Steal<Body<'tcx>> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n     pub fn alloc_steal_promoted(\n         self,\n-        promoted: IndexVec<Promoted, BodyAndCache<'tcx>>,\n-    ) -> &'tcx Steal<IndexVec<Promoted, BodyAndCache<'tcx>>> {\n+        promoted: IndexVec<Promoted, Body<'tcx>>,\n+    ) -> &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {\n         self.arena.alloc(Steal::new(promoted))\n     }\n \n     pub fn intern_promoted(\n         self,\n-        promoted: IndexVec<Promoted, BodyAndCache<'tcx>>,\n-    ) -> &'tcx IndexVec<Promoted, BodyAndCache<'tcx>> {\n+        promoted: IndexVec<Promoted, Body<'tcx>>,\n+    ) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n         self.arena.alloc(promoted)\n     }\n "}, {"sha": "97bc3fdb100a1f74699bf48cca378818b3fbe22b", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -11,8 +11,8 @@ use crate::infer::canonical::Canonical;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::interpret::ErrorHandled;\n+use crate::mir::Body;\n use crate::mir::GeneratorLayout;\n-use crate::mir::ReadOnlyBodyAndCache;\n use crate::traits::{self, Reveal};\n use crate::ty;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n@@ -2808,17 +2808,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n-    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> ReadOnlyBodyAndCache<'tcx, 'tcx> {\n+    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n         match instance {\n-            ty::InstanceDef::Item(did) => self.optimized_mir(did).unwrap_read_only(),\n+            ty::InstanceDef::Item(did) => self.optimized_mir(did),\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n             | ty::InstanceDef::Intrinsic(..)\n             | ty::InstanceDef::FnPtrShim(..)\n             | ty::InstanceDef::Virtual(..)\n             | ty::InstanceDef::ClosureOnceShim { .. }\n             | ty::InstanceDef::DropGlue(..)\n-            | ty::InstanceDef::CloneShim(..) => self.mir_shims(instance).unwrap_read_only(),\n+            | ty::InstanceDef::CloneShim(..) => self.mir_shims(instance),\n         }\n     }\n "}, {"sha": "e9bb659d5c839ee115725f319b1a08264e468045", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -922,6 +922,7 @@ where\n {\n     type Error = E::Error;\n \n+    #[inline]\n     fn emit_unit(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n     }"}, {"sha": "ef9af7bace96f4f1af8109c01a0bd34328281c59", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -8,7 +8,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{MutatingUseContext, NonUseContext, PlaceContext, Visitor};\n-use rustc_middle::mir::{self, Body, Local, Location, ReadOnlyBodyAndCache};\n+use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n use std::fmt;\n use std::ops::Index;\n@@ -90,7 +90,7 @@ crate enum LocalsStateAtExit {\n impl LocalsStateAtExit {\n     fn build(\n         locals_are_invalidated_at_exit: bool,\n-        body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+        body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n     ) -> Self {\n         struct HasStorageDead(BitSet<Local>);\n@@ -122,7 +122,7 @@ impl LocalsStateAtExit {\n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n         tcx: TyCtxt<'tcx>,\n-        body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+        body: &Body<'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>,\n     ) -> Self {"}, {"sha": "22947610448d3123c759daae2898cedf58d016e3", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,3 +1,4 @@\n+use either::Either;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -186,7 +187,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             let ty =\n-                Place::ty_from(used_place.local, used_place.projection, *self.body, self.infcx.tcx)\n+                Place::ty_from(used_place.local, used_place.projection, self.body, self.infcx.tcx)\n                     .ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n@@ -202,7 +203,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(*self.body, self.infcx.tcx).ty;\n+                let ty = place.ty(self.body, self.infcx.tcx).ty;\n                 let opt_name =\n                     self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n@@ -591,7 +592,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let union_ty = |place_base, place_projection| {\n-            let ty = Place::ty_from(place_base, place_projection, *self.body, self.infcx.tcx).ty;\n+            let ty = Place::ty_from(place_base, place_projection, self.body, self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n \n@@ -1262,8 +1263,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n+        fn predecessor_locations(\n+            body: &'a mir::Body<'tcx>,\n+            location: Location,\n+        ) -> impl Iterator<Item = Location> + 'a {\n+            if location.statement_index == 0 {\n+                let predecessors = body.predecessors_for(location.block).to_vec();\n+                Either::Left(predecessors.into_iter().map(move |bb| body.terminator_loc(bb)))\n+            } else {\n+                Either::Right(std::iter::once(Location {\n+                    statement_index: location.statement_index - 1,\n+                    ..location\n+                }))\n+            }\n+        }\n+\n         let mut stack = Vec::new();\n-        stack.extend(self.body.predecessor_locations(location).map(|predecessor| {\n+        stack.extend(predecessor_locations(self.body, location).map(|predecessor| {\n             let is_back_edge = location.dominates(predecessor, &self.dominators);\n             (predecessor, is_back_edge)\n         }));\n@@ -1345,7 +1361,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 continue 'dfs;\n             }\n \n-            stack.extend(self.body.predecessor_locations(location).map(|predecessor| {\n+            stack.extend(predecessor_locations(self.body, location).map(|predecessor| {\n                 let back_edge = location.dominates(predecessor, &self.dominators);\n                 (predecessor, is_back_edge || back_edge)\n             }));\n@@ -1486,15 +1502,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(place.local, proj_base, *self.body, tcx).ty.is_box(),\n+                                Place::ty_from(place.local, proj_base, self.body, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(place.local, proj_base, *self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(place.local, proj_base, self.body, tcx).ty;\n                         match base_ty.kind {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor"}, {"sha": "91d8d853eafdb780d86321de0c525a3dc64c4a45", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -331,8 +331,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n-                        Place::ty_from(place.local, place.projection, *self.body, self.infcx.tcx)\n-                            .ty;\n+                        Place::ty_from(place.local, place.projection, self.body, self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -449,7 +448,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }) = bbd.terminator\n                     {\n                         if let Some(source) =\n-                            BorrowedContentSource::from_call(func.ty(*self.body, tcx), tcx)\n+                            BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n                         {\n                             return source;\n                         }\n@@ -462,7 +461,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = Place::ty_from(deref_base.local, deref_base.projection, *self.body, tcx).ty;\n+        let base_ty = Place::ty_from(deref_base.local, deref_base.projection, self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_ptr() {"}, {"sha": "457e263a46611912cbadca99819e455ebe2020dd", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -296,7 +296,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n-        let ty = deref_target_place.ty(*self.body, self.infcx.tcx).ty;\n+        let ty = deref_target_place.ty(self.body, self.infcx.tcx).ty;\n         let upvar_field = self\n             .prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         };\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-            let def_id = match move_place.ty(*self.body, self.infcx.tcx).ty.kind {\n+            let def_id = match move_place.ty(self.body, self.infcx.tcx).ty.kind {\n                 ty::Adt(self_def, _) => self_def.did,\n                 ty::Foreign(def_id)\n                 | ty::FnDef(def_id, _)\n@@ -441,7 +441,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 if binds_to.is_empty() {\n-                    let place_ty = move_from.ty(*self.body, self.infcx.tcx).ty;\n+                    let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => \"value\".to_string(),\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // No binding. Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n-                let place_ty = original_path.ty(*self.body, self.infcx.tcx).ty;\n+                let place_ty = original_path.ty(self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => \"value\".to_string(),"}, {"sha": "c0aee31781e4fcf811e6a1e6e924377edd28ee7f", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         Place::ty_from(\n                             the_place_err.local,\n                             the_place_err.projection,\n-                            *self.body,\n+                            self.body,\n                             self.infcx.tcx\n                         )\n                         .ty\n@@ -197,7 +197,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));"}, {"sha": "a8c7a959b28e23b67e5d9d301f003e991e650c29", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::TerminatorKind;\n-use rustc_middle::mir::{BasicBlock, Body, Location, Place, ReadOnlyBodyAndCache, Rvalue};\n+use rustc_middle::mir::{BasicBlock, Body, Location, Place, Rvalue};\n use rustc_middle::mir::{BorrowKind, Mutability, Operand};\n use rustc_middle::mir::{Statement, StatementKind};\n use rustc_middle::ty::TyCtxt;\n@@ -18,7 +18,7 @@ pub(super) fn generate_invalidates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+    body: &Body<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if all_facts.is_none() {\n@@ -37,7 +37,7 @@ pub(super) fn generate_invalidates<'tcx>(\n             body: &body,\n             dominators,\n         };\n-        ig.visit_body(&body);\n+        ig.visit_body(body);\n     }\n }\n "}, {"sha": "a330dc95f239a58060972fea6f18a24d3c75f9de", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -10,8 +10,8 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{\n-    read_only, traversal, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability,\n-    Operand, Place, PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n+    traversal, Body, ClearCrossCrate, Local, Location, Mutability, Operand, Place, PlaceElem,\n+    PlaceRef,\n };\n use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -106,7 +106,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> &BorrowCheckResult<'_> {\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n-    input_promoted: &IndexVec<Promoted, BodyAndCache<'tcx>>,\n+    input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n     def_id: DefId,\n ) -> BorrowCheckResult<'tcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n@@ -168,13 +168,11 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n-    let body_clone: Body<'tcx> = input_body.clone();\n+    let mut body = input_body.clone();\n     let mut promoted = input_promoted.clone();\n-    let mut body = BodyAndCache::new(body_clone);\n     let free_regions =\n         nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n-    let body = read_only!(body); // no further changes\n-    let promoted: IndexVec<_, _> = promoted.iter_mut().map(|body| read_only!(body)).collect();\n+    let body = &body; // no further changes\n \n     let location_table = &LocationTable::new(&body);\n \n@@ -415,7 +413,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    body: ReadOnlyBodyAndCache<'cx, 'tcx>,\n+    body: &'cx Body<'tcx>,\n     mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n \n@@ -619,7 +617,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(*self.body, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n@@ -871,7 +869,7 @@ impl InitializationRequiringAction {\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn body(&self) -> &'cx Body<'tcx> {\n-        *self.body\n+        self.body\n     }\n \n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n@@ -952,7 +950,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n-        let body: &Body<'_> = &body;\n         let borrow_set = self.borrow_set.clone();\n \n         // Use polonius output if it has been enabled."}, {"sha": "141ed00e789dfb0cfd0fb7c2efcc6b7d778bcfe9", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -6,8 +6,8 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{\n-    BasicBlock, Body, BodyAndCache, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind,\n-    Location, Promoted, ReadOnlyBodyAndCache,\n+    BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n+    Promoted,\n };\n use rustc_middle::ty::{self, RegionKind, RegionVid};\n use rustc_span::symbol::sym;\n@@ -60,8 +60,8 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n-    promoted: &mut IndexVec<Promoted, BodyAndCache<'tcx>>,\n+    body: &mut Body<'tcx>,\n+    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n@@ -159,8 +159,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n-    promoted: &IndexVec<Promoted, ReadOnlyBodyAndCache<'_, 'tcx>>,\n+    body: &Body<'tcx>,\n+    promoted: &IndexVec<Promoted, Body<'tcx>>,\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'tcx>,\n     flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,"}, {"sha": "a2475e0ff29fe3dce7236caa8c0e1398f355b53e", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -10,7 +10,7 @@\n use super::MirBorrowckCtxt;\n \n use rustc_hir as hir;\n-use rustc_middle::mir::{Place, PlaceRef, ProjectionElem, ReadOnlyBodyAndCache};\n+use rustc_middle::mir::{Body, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, TyCtxt};\n \n pub trait IsPrefixOf<'tcx> {\n@@ -26,7 +26,7 @@ impl<'tcx> IsPrefixOf<'tcx> for PlaceRef<'tcx> {\n }\n \n pub(super) struct Prefixes<'cx, 'tcx> {\n-    body: ReadOnlyBodyAndCache<'cx, 'tcx>,\n+    body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,\n     next: Option<PlaceRef<'tcx>>,\n@@ -120,7 +120,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.local, proj_base, *self.body, self.tcx).ty;\n+                    let ty = Place::ty_from(cursor.local, proj_base, self.body, self.tcx).ty;\n                     match ty.kind {\n                         ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared"}, {"sha": "57a3fa6f79b5043a70c2cac1fac146541f58dfba", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::{HybridBitSet, SparseBitMatrix};\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::{BasicBlock, Body, Location, ReadOnlyBodyAndCache};\n+use rustc_middle::mir::{BasicBlock, Body, Location};\n use rustc_middle::ty::{self, RegionVid};\n use std::fmt::Debug;\n use std::rc::Rc;\n@@ -80,7 +80,7 @@ impl RegionValueElements {\n     /// Pushes all predecessors of `index` onto `stack`.\n     crate fn push_predecessors(\n         &self,\n-        body: ReadOnlyBodyAndCache<'_, '_>,\n+        body: &Body<'_>,\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {"}, {"sha": "5956896881941b9037de272a8ce8f935905e3aa4", "filename": "src/librustc_mir/borrow_check/renumber.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,16 +1,16 @@\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n-use rustc_middle::mir::{BodyAndCache, Location, PlaceElem, Promoted};\n+use rustc_middle::mir::{Body, Location, PlaceElem, Promoted};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n pub fn renumber_mir<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n-    promoted: &mut IndexVec<Promoted, BodyAndCache<'tcx>>,\n+    body: &mut Body<'tcx>,\n+    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);"}, {"sha": "0fdf96710c6e8db0701a7fb87779e6010bacca6c", "filename": "src/librustc_mir/borrow_check/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::vec_linked_list as vll;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n-use rustc_middle::mir::{Local, Location, ReadOnlyBodyAndCache};\n+use rustc_middle::mir::{Body, Local, Location};\n \n use crate::util::liveness::{categorize, DefUse};\n \n@@ -62,7 +62,7 @@ impl LocalUseMap {\n     crate fn build(\n         live_locals: &Vec<Local>,\n         elements: &RegionValueElements,\n-        body: ReadOnlyBodyAndCache<'_, '_>,\n+        body: &Body<'_>,\n     ) -> Self {\n         let nones = IndexVec::from_elem_n(None, body.local_decls.len());\n         let mut local_use_map = LocalUseMap {"}, {"sha": "717bfb8fe7de00c9c1f65e9368e26218b545665a", "filename": "src/librustc_mir/borrow_check/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_middle::mir::{Body, Local, ReadOnlyBodyAndCache};\n+use rustc_middle::mir::{Body, Local};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n use std::rc::Rc;\n \n@@ -32,7 +32,7 @@ mod trace;\n /// performed before\n pub(super) fn generate<'mir, 'tcx>(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+    body: &Body<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,"}, {"sha": "2e033896ce15dbf93dafbb9e9d4281db2aebceb6", "filename": "src/librustc_mir/borrow_check/type_check/liveness/polonius.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -3,7 +3,7 @@ use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::{LookupResult, MoveData};\n use crate::util::liveness::{categorize, DefUse};\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n-use rustc_middle::mir::{Local, Location, Place, ReadOnlyBodyAndCache};\n+use rustc_middle::mir::{Body, Local, Location, Place};\n use rustc_middle::ty::subst::GenericArg;\n \n use super::TypeChecker;\n@@ -85,7 +85,7 @@ impl Visitor<'tcx> for UseFactsExtractor<'_> {\n \n pub(super) fn populate_access_facts(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+    body: &Body<'tcx>,\n     location_table: &LocationTable,\n     move_data: &MoveData<'_>,\n     dropped_at: &mut Vec<(Local, Location)>,"}, {"sha": "af09dc5b8039e034abd8fea7d9bee47bf6c89807", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::HybridBitSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n-use rustc_middle::mir::{BasicBlock, ConstraintCategory, Local, Location, ReadOnlyBodyAndCache};\n+use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n use rustc_middle::ty::{Ty, TypeFoldable};\n use rustc_trait_selection::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n@@ -37,7 +37,7 @@ use crate::borrow_check::{\n /// this respects `#[may_dangle]` annotations).\n pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+    body: &Body<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -76,7 +76,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     elements: &'me RegionValueElements,\n \n     /// MIR we are analyzing.\n-    body: ReadOnlyBodyAndCache<'me, 'tcx>,\n+    body: &'me Body<'tcx>,\n \n     /// Mapping to/from the various indices used for initialization tracking.\n     move_data: &'me MoveData<'tcx>,"}, {"sha": "796efd2bab976949c1ed5ad91ae39a958e70419f", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 30, "deletions": 44, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -122,8 +122,8 @@ mod relate_tys;\n pub(crate) fn type_check<'mir, 'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n-    promoted: &IndexVec<Promoted, ReadOnlyBodyAndCache<'_, 'tcx>>,\n+    body: &Body<'tcx>,\n+    promoted: &IndexVec<Promoted, Body<'tcx>>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n@@ -190,8 +190,8 @@ fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: ReadOnlyBodyAndCache<'a, 'tcx>,\n-    promoted: &'a IndexVec<Promoted, ReadOnlyBodyAndCache<'_, 'tcx>>,\n+    body: &'a Body<'tcx>,\n+    promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n@@ -200,7 +200,7 @@ fn type_check_internal<'a, 'tcx, R>(\n ) -> R {\n     let mut checker = TypeChecker::new(\n         infcx,\n-        *body,\n+        body,\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -209,7 +209,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         universal_region_relations,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, *body, promoted);\n+        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n         verifier.visit_body(&body);\n         verifier.errors_reported\n     };\n@@ -266,7 +266,7 @@ enum FieldAccessError {\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n     body: &'b Body<'tcx>,\n-    promoted: &'b IndexVec<Promoted, ReadOnlyBodyAndCache<'b, 'tcx>>,\n+    promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n@@ -320,7 +320,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n             if let ty::ConstKind::Unevaluated(def_id, substs, promoted) = constant.literal.val {\n                 if let Some(promoted) = promoted {\n                     let check_err = |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n-                                     promoted: &ReadOnlyBodyAndCache<'_, 'tcx>,\n+                                     promoted: &Body<'tcx>,\n                                      ty,\n                                      san_ty| {\n                         if let Err(terr) = verifier.cx.eq_types(\n@@ -341,11 +341,11 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     };\n \n                     if !self.errors_reported {\n-                        let promoted_body = self.promoted[promoted];\n+                        let promoted_body = &self.promoted[promoted];\n                         self.sanitize_promoted(promoted_body, location);\n \n                         let promoted_ty = promoted_body.return_ty();\n-                        check_err(self, &promoted_body, ty, promoted_ty);\n+                        check_err(self, promoted_body, ty, promoted_ty);\n                     }\n                 } else {\n                     if let Err(terr) = self.cx.fully_perform_op(\n@@ -451,7 +451,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn new(\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n         body: &'b Body<'tcx>,\n-        promoted: &'b IndexVec<Promoted, ReadOnlyBodyAndCache<'b, 'tcx>>,\n+        promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     ) -> Self {\n         TypeVerifier {\n             body,\n@@ -525,16 +525,12 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         place_ty\n     }\n \n-    fn sanitize_promoted(\n-        &mut self,\n-        promoted_body: ReadOnlyBodyAndCache<'b, 'tcx>,\n-        location: Location,\n-    ) {\n+    fn sanitize_promoted(&mut self, promoted_body: &'b Body<'tcx>, location: Location) {\n         // Determine the constraints from the promoted MIR by running the type\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_body = mem::replace(&mut self.body, *promoted_body);\n+        let parent_body = mem::replace(&mut self.body, promoted_body);\n \n         // Use new sets of constraints and closure bounds so that we can\n         // modify their locations.\n@@ -1396,12 +1392,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn check_stmt(\n-        &mut self,\n-        body: ReadOnlyBodyAndCache<'_, 'tcx>,\n-        stmt: &Statement<'tcx>,\n-        location: Location,\n-    ) {\n+    fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n@@ -1433,9 +1424,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(*body, tcx).ty;\n+                let place_ty = place.ty(body, tcx).ty;\n                 let place_ty = self.normalize(place_ty, location);\n-                let rv_ty = rv.ty(*body, tcx);\n+                let rv_ty = rv.ty(body, tcx);\n                 let rv_ty = self.normalize(rv_ty, location);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1484,7 +1475,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::SetDiscriminant { ref place, variant_index } => {\n-                let place_type = place.ty(*body, tcx).ty;\n+                let place_type = place.ty(body, tcx).ty;\n                 let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1506,7 +1497,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(box (ref place, ref projection), variance) => {\n-                let place_ty = place.ty(*body, tcx).ty;\n+                let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1973,12 +1964,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn check_rvalue(\n-        &mut self,\n-        body: ReadOnlyBodyAndCache<'_, 'tcx>,\n-        rvalue: &Rvalue<'tcx>,\n-        location: Location,\n-    ) {\n+    fn check_rvalue(&mut self, body: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         let tcx = self.tcx();\n \n         match rvalue {\n@@ -1996,7 +1982,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         // While this is located in `nll::typeck` this error is not an NLL error, it's\n                         // a required check to make sure that repeated elements implement `Copy`.\n                         let span = body.source_info(location).span;\n-                        let ty = operand.ty(*body, tcx);\n+                        let ty = operand.ty(body, tcx);\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                             // To determine if `const_in_array_repeat_expressions` feature gate should\n                             // be mentioned, need to check if the rvalue is promotable.\n@@ -2060,7 +2046,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Cast(cast_kind, op, ty) => {\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        let fn_sig = op.ty(*body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2089,7 +2075,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(*body, tcx).kind {\n+                        let sig = match op.ty(body, tcx).kind {\n                             ty::Closure(_, substs) => substs.as_closure().sig(),\n                             _ => bug!(),\n                         };\n@@ -2113,7 +2099,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        let fn_sig = op.ty(*body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2145,7 +2131,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n                             def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(*body, tcx), &[ty.into()]),\n+                            substs: tcx.mk_substs_trait(op.ty(body, tcx), &[ty.into()]),\n                         };\n \n                         self.prove_trait_ref(\n@@ -2156,7 +2142,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(*body, tcx).kind {\n+                        let ty_from = match op.ty(body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::Mutability::Mut,\n@@ -2204,7 +2190,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ArrayToPointer) => {\n-                        let ty_from = op.ty(*body, tcx);\n+                        let ty_from = op.ty(body, tcx);\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(ty::TypeAndMut {\n@@ -2264,7 +2250,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        let ty_from = op.ty(*body, tcx);\n+                        let ty_from = op.ty(body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n@@ -2295,9 +2281,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 left,\n                 right,\n             ) => {\n-                let ty_left = left.ty(*body, tcx);\n+                let ty_left = left.ty(body, tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n-                    let ty_right = right.ty(*body, tcx);\n+                    let ty_right = right.ty(body, tcx);\n                     let common_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::MiscVariable,\n                         span: body.source_info(location).span,\n@@ -2712,7 +2698,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self, body: ReadOnlyBodyAndCache<'_, 'tcx>) {\n+    fn typeck_mir(&mut self, body: &Body<'tcx>) {\n         self.last_span = body.span;\n         debug!(\"run_on_mir: {:?}\", body.span);\n "}, {"sha": "cb146059fb1bf93ddea4cbc60b27de92c6b74dc3", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -226,7 +226,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def, None) {\n-            Ok(body) => *body,\n+            Ok(body) => body,\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(did)) = err.kind {\n                     let path = ecx.tcx.def_path_str(did);"}, {"sha": "5d130213e1f92b5c6c6badaaf732586d8e22173f", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -84,13 +84,13 @@ type BorrowedLocalsResults<'a, 'tcx> = ResultsRefCursor<'a, 'a, 'tcx, MaybeBorro\n /// Dataflow analysis that determines whether each local requires storage at a\n /// given location; i.e. whether its storage can go away without being observed.\n pub struct MaybeRequiresStorage<'mir, 'tcx> {\n-    body: ReadOnlyBodyAndCache<'mir, 'tcx>,\n+    body: &'mir Body<'tcx>,\n     borrowed_locals: RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n }\n \n impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n     pub fn new(\n-        body: ReadOnlyBodyAndCache<'mir, 'tcx>,\n+        body: &'mir Body<'tcx>,\n         borrowed_locals: &'mir Results<'tcx, MaybeBorrowedLocals>,\n     ) -> Self {\n         MaybeRequiresStorage {"}, {"sha": "ae4ad49fe667ff09f959ed17c61f4b79f1f25c04", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -405,7 +405,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n         promoted: Option<mir::Promoted>,\n-    ) -> InterpResult<'tcx, mir::ReadOnlyBodyAndCache<'tcx, 'tcx>> {\n+    ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n         if did.is_local() && self.tcx.has_typeck_tables(did) {\n@@ -415,12 +415,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         if let Some(promoted) = promoted {\n-            return Ok(self.tcx.promoted_mir(did)[promoted].unwrap_read_only());\n+            return Ok(&self.tcx.promoted_mir(did)[promoted]);\n         }\n         match instance {\n             ty::InstanceDef::Item(def_id) => {\n                 if self.tcx.is_mir_available(did) {\n-                    Ok(self.tcx.optimized_mir(did).unwrap_read_only())\n+                    Ok(self.tcx.optimized_mir(did))\n                 } else {\n                     throw_unsup!(NoMirFor(def_id))\n                 }"}, {"sha": "6dc6935179be159a32fe026fd93c95f5c25465da", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -26,7 +26,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx BodyAndCache<'tcx> {\n+fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n     debug!(\"make_shim({:?})\", instance);\n \n     let mut result = match instance {\n@@ -128,7 +128,6 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n \n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n-    result.ensure_predecessors();\n     tcx.arena.alloc(result)\n }\n \n@@ -168,11 +167,7 @@ fn local_decls_for_sig<'tcx>(\n         .collect()\n }\n \n-fn build_drop_shim<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    ty: Option<Ty<'tcx>>,\n-) -> BodyAndCache<'tcx> {\n+fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>) -> Body<'tcx> {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n@@ -204,9 +199,7 @@ fn build_drop_shim<'tcx>(\n     block(&mut blocks, TerminatorKind::Goto { target: return_block });\n     block(&mut blocks, TerminatorKind::Return);\n \n-    let body = new_body(blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n-\n-    let mut body = BodyAndCache::new(body);\n+    let mut body = new_body(blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n \n     if let Some(..) = ty {\n         // The first argument (index 0), but add 1 for the return value.\n@@ -320,11 +313,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n }\n \n /// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n-fn build_clone_shim<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    self_ty: Ty<'tcx>,\n-) -> BodyAndCache<'tcx> {\n+fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n     let param_env = tcx.param_env(def_id);\n@@ -348,7 +337,7 @@ fn build_clone_shim<'tcx>(\n         _ => bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty),\n     };\n \n-    BodyAndCache::new(builder.into_mir())\n+    builder.into_mir()\n }\n \n struct CloneShimBuilder<'tcx> {\n@@ -671,7 +660,7 @@ fn build_call_shim<'tcx>(\n     rcvr_adjustment: Option<Adjustment>,\n     call_kind: CallKind,\n     untuple_args: Option<&[Ty<'tcx>]>,\n-) -> BodyAndCache<'tcx> {\n+) -> Body<'tcx> {\n     debug!(\n         \"build_call_shim(instance={:?}, rcvr_adjustment={:?}, \\\n             call_kind={:?}, untuple_args={:?})\",\n@@ -835,10 +824,11 @@ fn build_call_shim<'tcx>(\n     if let Abi::RustCall = sig.abi {\n         body.spread_arg = Some(Local::new(sig.inputs().len()));\n     }\n-    BodyAndCache::new(body)\n+\n+    body\n }\n \n-pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &BodyAndCache<'_> {\n+pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n     let span =\n@@ -905,7 +895,5 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &BodyAndCache<'_> {\n         |_, _| Ok(()),\n     );\n \n-    let mut body = BodyAndCache::new(body);\n-    body.ensure_predecessors();\n     tcx.arena.alloc(body)\n }"}, {"sha": "33859115359e0ce46cd42f0c7a3c519638368580", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -31,13 +31,13 @@ pub use self::AddCallGuards::*;\n  */\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         self.add_call_guards(body);\n     }\n }\n \n impl AddCallGuards {\n-    pub fn add_call_guards(&self, body: &mut BodyAndCache<'_>) {\n+    pub fn add_call_guards(&self, body: &mut Body<'_>) {\n         let pred_count: IndexVec<_, _> = body.predecessors().iter().map(|ps| ps.len()).collect();\n \n         // We need a place to store the new blocks generated"}, {"sha": "39ce2340aed2198a67a46754a440dd01f15c023c", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -40,17 +40,13 @@ use crate::util::patch::MirPatch;\n pub struct AddMovesForPackedDrops;\n \n impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n         add_moves_for_packed_drops(tcx, body, src.def_id());\n     }\n }\n \n-pub fn add_moves_for_packed_drops<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n-    def_id: DefId,\n-) {\n+pub fn add_moves_for_packed_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, def_id: DefId) {\n     let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n     patch.apply(body);\n }"}, {"sha": "6d5853def1e9c8096f28e9c7eb1d9b9f245a5a54", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -58,7 +58,7 @@ fn may_be_reference(ty: Ty<'tcx>) -> bool {\n }\n \n impl<'tcx> MirPass<'tcx> for AddRetag {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }"}, {"sha": "8aac5c791ecd25d3c12ace23fd565848230b5e77", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -21,19 +21,15 @@ pub mod validation;\n /// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n pub struct Item<'mir, 'tcx> {\n-    pub body: mir::ReadOnlyBodyAndCache<'mir, 'tcx>,\n+    pub body: &'mir mir::Body<'tcx>,\n     pub tcx: TyCtxt<'tcx>,\n     pub def_id: DefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub const_kind: Option<ConstKind>,\n }\n \n impl Item<'mir, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        body: mir::ReadOnlyBodyAndCache<'mir, 'tcx>,\n-    ) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'mir mir::Body<'tcx>) -> Self {\n         let param_env = tcx.param_env(def_id);\n         let const_kind = ConstKind::for_item(tcx, def_id);\n "}, {"sha": "5f50e073e29a6f6f75d8c3a24f1224abf33d0705", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -113,7 +113,7 @@ where\n     F: FnMut(Local) -> bool,\n {\n     match rvalue {\n-        Rvalue::NullaryOp(..) => Q::in_any_value_of_ty(cx, rvalue.ty(*cx.body, cx.tcx)),\n+        Rvalue::NullaryOp(..) => Q::in_any_value_of_ty(cx, rvalue.ty(cx.body, cx.tcx)),\n \n         Rvalue::Discriminant(place) | Rvalue::Len(place) => {\n             in_place::<Q, _>(cx, in_local, place.as_ref())\n@@ -131,7 +131,7 @@ where\n         Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n             // Special-case reborrows to be more like a copy of the reference.\n             if let &[ref proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx).ty;\n+                let base_ty = Place::ty_from(place.local, proj_base, cx.body, cx.tcx).ty;\n                 if let ty::Ref(..) = base_ty.kind {\n                     return in_place::<Q, _>(\n                         cx,\n@@ -178,7 +178,7 @@ where\n             | ProjectionElem::Index(_) => {}\n         }\n \n-        let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx);\n+        let base_ty = Place::ty_from(place.local, proj_base, cx.body, cx.tcx);\n         let proj_ty = base_ty.projection_ty(cx.tcx, proj_elem).ty;\n         if !Q::in_any_value_of_ty(cx, proj_ty) {\n             return false;"}, {"sha": "6ae314b973ffea8a450c3bb5bc61dc920247d46b", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -72,7 +72,7 @@ where\n     ) {\n         // We cannot reason about another function's internals, so use conservative type-based\n         // qualification for the result of a function call.\n-        let return_ty = return_place.ty(*self.item.body, self.item.tcx).ty;\n+        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n         let qualif = Q::in_any_value_of_ty(self.item, return_ty);\n \n         if !return_place.is_indirect() {"}, {"sha": "ce0cdc2bac07bb015d84ec589447c0c5b1da0802", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -39,9 +39,9 @@ struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n     pub fn new(q: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n         let cursor = FlowSensitiveAnalysis::new(q, item)\n-            .into_engine(item.tcx, &item.body, item.def_id)\n+            .into_engine(item.tcx, item.body, item.def_id)\n             .iterate_to_fixpoint()\n-            .into_results_cursor(*item.body);\n+            .into_results_cursor(item.body);\n \n         let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n         for (local, decl) in item.body.local_decls.iter_enumerated() {\n@@ -148,11 +148,11 @@ impl Validator<'a, 'mir, 'tcx> {\n         //\n         // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n         // without breaking stable code?\n-        let indirectly_mutable = MaybeMutBorrowedLocals::mut_borrows_only(tcx, *body, param_env)\n+        let indirectly_mutable = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n             .unsound_ignore_borrow_on_drop()\n-            .into_engine(tcx, *body, def_id)\n+            .into_engine(tcx, body, def_id)\n             .iterate_to_fixpoint()\n-            .into_results_cursor(*body);\n+            .into_results_cursor(body);\n \n         let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n \n@@ -261,7 +261,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         // Special-case reborrows to be more like a copy of a reference.\n         match *rvalue {\n             Rvalue::Ref(_, kind, place) => {\n-                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n+                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n                     let ctx = match kind {\n                         BorrowKind::Shared => {\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow)\n@@ -282,7 +282,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 }\n             }\n             Rvalue::AddressOf(mutbl, place) => {\n-                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n+                if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n                     let ctx = match mutbl {\n                         Mutability::Not => {\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf)\n@@ -313,7 +313,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n             Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n             | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place) => {\n-                let ty = place.ty(*self.body, self.tcx).ty;\n+                let ty = place.ty(self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n                     ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut => {\n@@ -355,7 +355,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(*self.body, self.tcx);\n+                let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n \n@@ -365,7 +365,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(*self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     assert!(\n                         op == BinOp::Eq\n                             || op == BinOp::Ne\n@@ -425,7 +425,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_local, proj_base, self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n                         if let (local, []) = (place_local, proj_base) {\n@@ -449,7 +449,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_local, proj_base, *self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_local, proj_base, self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -507,7 +507,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match &terminator.kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(*self.body, self.tcx);\n+                let fn_ty = func.ty(self.body, self.tcx);\n \n                 let (def_id, substs) = match fn_ty.kind {\n                     ty::FnDef(def_id, substs) => (def_id, substs),\n@@ -562,7 +562,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // Check to see if the type of this place can ever have a drop impl. If not, this\n                 // `Drop` terminator is frivolous.\n                 let ty_needs_drop =\n-                    dropped_place.ty(*self.body, self.tcx).ty.needs_drop(self.tcx, self.param_env);\n+                    dropped_place.ty(self.body, self.tcx).ty.needs_drop(self.tcx, self.param_env);\n \n                 if !ty_needs_drop {\n                     return;"}, {"sha": "5215c985107a0e5147fb6b341b6a4ae869db3189", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -502,9 +502,6 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n         hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);\n-    // mir_built ensures that body has a computed cache, so we don't (and can't) attempt to\n-    // recompute it here.\n-    let body = body.unwrap_read_only();\n     checker.visit_body(&body);\n \n     check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);"}, {"sha": "a3880d691b2d144e2756dfaec83b95a3bf81fa4c", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -18,7 +18,7 @@\n \n use crate::transform::{MirPass, MirSource};\n use rustc_middle::mir::visit::MutVisitor;\n-use rustc_middle::mir::{BodyAndCache, BorrowKind, Location, Rvalue};\n+use rustc_middle::mir::{Body, BorrowKind, Location, Rvalue};\n use rustc_middle::mir::{Statement, StatementKind};\n use rustc_middle::ty::TyCtxt;\n \n@@ -29,7 +29,7 @@ pub struct DeleteNonCodegenStatements<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements { tcx };\n         delete.visit_body(body);\n         body.user_type_annotations.raw.clear();"}, {"sha": "271c746aa0feff7ca13063bc87458f0247d93abf", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -8,16 +8,16 @@ use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n use rustc_middle::mir::{\n-    read_only, AggregateKind, AssertKind, BasicBlock, BinOp, Body, BodyAndCache, ClearCrossCrate,\n-    Constant, Local, LocalDecl, LocalKind, Location, Operand, Place, ReadOnlyBodyAndCache, Rvalue,\n-    SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n-    UnOp, RETURN_PLACE,\n+    AggregateKind, AssertKind, BasicBlock, BinOp, Body, ClearCrossCrate, Constant, Local,\n+    LocalDecl, LocalKind, Location, Operand, Place, Rvalue, SourceInfo, SourceScope,\n+    SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutError, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -59,7 +59,7 @@ macro_rules! throw_machine_stop_str {\n pub struct ConstProp;\n \n impl<'tcx> MirPass<'tcx> for ConstProp {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -150,8 +150,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         // constants, instead of just checking for const-folding succeeding.\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n-        let mut optimization_finder =\n-            ConstPropagator::new(read_only!(body), dummy_body, tcx, source);\n+        let mut optimization_finder = ConstPropagator::new(body, dummy_body, tcx, source);\n         optimization_finder.visit_body(body);\n \n         trace!(\"ConstProp done for {:?}\", source.def_id());\n@@ -362,7 +361,7 @@ impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n-        body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+        body: &Body<'tcx>,\n         dummy_body: &'mir Body<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n@@ -777,15 +776,15 @@ enum ConstPropMode {\n struct CanConstProp {\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     // false at the beginning, once set, there are not allowed to be any more assignments\n-    found_assignment: IndexVec<Local, bool>,\n+    found_assignment: BitSet<Local>,\n }\n \n impl CanConstProp {\n     /// returns true if `local` can be propagated\n-    fn check(body: ReadOnlyBodyAndCache<'_, '_>) -> IndexVec<Local, ConstPropMode> {\n+    fn check(body: &Body<'_>) -> IndexVec<Local, ConstPropMode> {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n-            found_assignment: IndexVec::from_elem(false, &body.local_decls),\n+            found_assignment: BitSet::new_empty(body.local_decls.len()),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n             // cannot use args at all\n@@ -813,11 +812,9 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n             // FIXME(oli-obk): we could be more powerful here, if the multiple writes\n             // only occur in independent execution paths\n             MutatingUse(MutatingUseContext::Store) => {\n-                if self.found_assignment[local] {\n+                if !self.found_assignment.insert(local) {\n                     trace!(\"local {:?} can't be propagated because of multiple assignments\", local);\n                     self.can_const_prop[local] = ConstPropMode::NoPropagation;\n-                } else {\n-                    self.found_assignment[local] = true\n                 }\n             }\n             // Reading constants is allowed an arbitrary number of times"}, {"sha": "bc1cb52ae855f8ce0ac43bbd36ea06459788fe8f", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -23,15 +23,14 @@ use crate::transform::{MirPass, MirSource};\n use crate::util::def_use::DefUseAnalysis;\n use rustc_middle::mir::visit::MutVisitor;\n use rustc_middle::mir::{\n-    read_only, Body, BodyAndCache, Constant, Local, LocalKind, Location, Operand, Place, Rvalue,\n-    StatementKind,\n+    Body, Constant, Local, LocalKind, Location, Operand, Place, Rvalue, StatementKind,\n };\n use rustc_middle::ty::TyCtxt;\n \n pub struct CopyPropagation;\n \n impl<'tcx> MirPass<'tcx> for CopyPropagation {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n@@ -40,10 +39,10 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n \n         let mut def_use_analysis = DefUseAnalysis::new(body);\n         loop {\n-            def_use_analysis.analyze(read_only!(body));\n+            def_use_analysis.analyze(body);\n \n             if eliminate_self_assignments(body, &def_use_analysis) {\n-                def_use_analysis.analyze(read_only!(body));\n+                def_use_analysis.analyze(body);\n             }\n \n             let mut changed = false;\n@@ -252,7 +251,7 @@ impl<'tcx> Action<'tcx> {\n \n     fn perform(\n         self,\n-        body: &mut BodyAndCache<'tcx>,\n+        body: &mut Body<'tcx>,\n         def_use_analysis: &DefUseAnalysis,\n         dest_local: Local,\n         location: Location,"}, {"sha": "2de701284e3f5815dfd7e7a9df876c1a84c78e71", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty::TyCtxt;\n pub struct Deaggregator;\n \n impl<'tcx> MirPass<'tcx> for Deaggregator {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "5ce6f4fa7414edf77f27a1305ffef440d832ae34", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -7,7 +7,7 @@ use std::io;\n \n use crate::transform::{MirPass, MirSource};\n use crate::util as mir_util;\n-use rustc_middle::mir::{Body, BodyAndCache};\n+use rustc_middle::mir::Body;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{OutputFilenames, OutputType};\n \n@@ -18,13 +18,7 @@ impl<'tcx> MirPass<'tcx> for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass(\n-        &self,\n-        _tcx: TyCtxt<'tcx>,\n-        _source: MirSource<'tcx>,\n-        _body: &mut BodyAndCache<'tcx>,\n-    ) {\n-    }\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut Body<'tcx>) {}\n }\n \n pub struct Disambiguator {"}, {"sha": "6074619dd1545e1bf9e671e2e24b94fbe19735b6", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -21,7 +21,7 @@ use std::fmt;\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();"}, {"sha": "8e7302dae449eae14231c9a97ad040c79775a486", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -354,7 +354,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n     }\n }\n \n-fn make_generator_state_argument_indirect<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+fn make_generator_state_argument_indirect<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let gen_ty = body.local_decls.raw[1].ty;\n \n     let ref_gen_ty =\n@@ -367,7 +367,7 @@ fn make_generator_state_argument_indirect<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Bo\n     DerefArgVisitor { tcx }.visit_body(body);\n }\n \n-fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let ref_gen_ty = body.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n@@ -391,7 +391,7 @@ fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body\n fn replace_local<'tcx>(\n     local: Local,\n     ty: Ty<'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n ) -> Local {\n     let source_info = source_info(body);\n@@ -436,7 +436,7 @@ struct LivenessInfo {\n \n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'tcx>,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+    body: &Body<'tcx>,\n     source: MirSource<'tcx>,\n     always_live_locals: &storage::AlwaysLiveLocals,\n     movable: bool,\n@@ -686,7 +686,7 @@ fn compute_layout<'tcx>(\n     interior: Ty<'tcx>,\n     always_live_locals: &storage::AlwaysLiveLocals,\n     movable: bool,\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n@@ -698,13 +698,7 @@ fn compute_layout<'tcx>(\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness,\n-    } = locals_live_across_suspend_points(\n-        tcx,\n-        read_only!(body),\n-        source,\n-        always_live_locals,\n-        movable,\n-    );\n+    } = locals_live_across_suspend_points(tcx, body, source, always_live_locals, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -779,7 +773,7 @@ fn compute_layout<'tcx>(\n ///\n /// After this function, the former entry point of the function will be bb1.\n fn insert_switch<'tcx>(\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     cases: Vec<(usize, BasicBlock)>,\n     transform: &TransformVisitor<'tcx>,\n     default: TerminatorKind<'tcx>,\n@@ -810,11 +804,7 @@ fn insert_switch<'tcx>(\n     }\n }\n \n-fn elaborate_generator_drops<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    body: &mut BodyAndCache<'tcx>,\n-) {\n+fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut Body<'tcx>) {\n     use crate::shim::DropShimElaborator;\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n@@ -865,9 +855,9 @@ fn create_generator_drop_shim<'tcx>(\n     transform: &TransformVisitor<'tcx>,\n     source: MirSource<'tcx>,\n     gen_ty: Ty<'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     drop_clean: BasicBlock,\n-) -> BodyAndCache<'tcx> {\n+) -> Body<'tcx> {\n     let mut body = body.clone();\n     body.arg_count = 1; // make sure the resume argument is not included here\n \n@@ -934,10 +924,7 @@ fn create_generator_drop_shim<'tcx>(\n     body\n }\n \n-fn insert_term_block<'tcx>(\n-    body: &mut BodyAndCache<'tcx>,\n-    kind: TerminatorKind<'tcx>,\n-) -> BasicBlock {\n+fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n     let term_block = BasicBlock::new(body.basic_blocks().len());\n     let source_info = source_info(body);\n     body.basic_blocks_mut().push(BasicBlockData {\n@@ -950,7 +937,7 @@ fn insert_term_block<'tcx>(\n \n fn insert_panic_block<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     message: AssertMessage<'tcx>,\n ) -> BasicBlock {\n     let assert_block = BasicBlock::new(body.basic_blocks().len());\n@@ -1036,7 +1023,7 @@ fn create_generator_resume_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     transform: TransformVisitor<'tcx>,\n     source: MirSource<'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     can_return: bool,\n ) {\n     let can_unwind = can_unwind(tcx, body);\n@@ -1115,7 +1102,7 @@ fn source_info(body: &Body<'_>) -> SourceInfo {\n     SourceInfo { span: body.span, scope: OUTERMOST_SOURCE_SCOPE }\n }\n \n-fn insert_clean_drop(body: &mut BodyAndCache<'_>) -> BasicBlock {\n+fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n@@ -1152,7 +1139,7 @@ impl Operation {\n }\n \n fn create_cases<'tcx>(\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     transform: &TransformVisitor<'tcx>,\n     operation: Operation,\n ) -> Vec<(usize, BasicBlock)> {\n@@ -1215,7 +1202,7 @@ fn create_cases<'tcx>(\n }\n \n impl<'tcx> MirPass<'tcx> for StateTransform {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {"}, {"sha": "d8bb8a0b52c66b73efbaf7f016fbc04dd50b089c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -38,7 +38,7 @@ struct CallSite<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for Inline {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(body);\n         }\n@@ -51,7 +51,7 @@ struct Inliner<'tcx> {\n }\n \n impl Inliner<'tcx> {\n-    fn run_pass(&self, caller_body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, caller_body: &mut Body<'tcx>) {\n         // Keep a queue of callsites to try inlining on. We take\n         // advantage of the fact that queries detect cycles here to\n         // allow us to try and fetch the fully optimized MIR of a\n@@ -405,8 +405,8 @@ impl Inliner<'tcx> {\n     fn inline_call(\n         &self,\n         callsite: CallSite<'tcx>,\n-        caller_body: &mut BodyAndCache<'tcx>,\n-        mut callee_body: BodyAndCache<'tcx>,\n+        caller_body: &mut Body<'tcx>,\n+        mut callee_body: Body<'tcx>,\n     ) -> bool {\n         let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n@@ -468,7 +468,7 @@ impl Inliner<'tcx> {\n                         destination.0,\n                     );\n \n-                    let ty = dest.ty(&**caller_body, self.tcx);\n+                    let ty = dest.ty(caller_body, self.tcx);\n \n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n@@ -534,7 +534,7 @@ impl Inliner<'tcx> {\n         &self,\n         args: Vec<Operand<'tcx>>,\n         callsite: &CallSite<'tcx>,\n-        caller_body: &mut BodyAndCache<'tcx>,\n+        caller_body: &mut Body<'tcx>,\n     ) -> Vec<Local> {\n         let tcx = self.tcx;\n \n@@ -568,7 +568,7 @@ impl Inliner<'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::from(tuple);\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(&**caller_body, tcx).ty.kind {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.kind {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");\n@@ -601,7 +601,7 @@ impl Inliner<'tcx> {\n         &self,\n         arg: Operand<'tcx>,\n         callsite: &CallSite<'tcx>,\n-        caller_body: &mut BodyAndCache<'tcx>,\n+        caller_body: &mut Body<'tcx>,\n     ) -> Local {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n@@ -619,7 +619,7 @@ impl Inliner<'tcx> {\n         // Otherwise, create a temporary for the arg\n         let arg = Rvalue::Use(arg);\n \n-        let ty = arg.ty(&**caller_body, self.tcx);\n+        let ty = arg.ty(caller_body, self.tcx);\n \n         let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n         let arg_tmp = caller_body.local_decls.push(arg_tmp);"}, {"sha": "d570e093353ab10c231ceb476369172f9ee55934", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -5,16 +5,15 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::{\n-    read_only, Body, BodyAndCache, Constant, Local, Location, Operand, Place, PlaceRef,\n-    ProjectionElem, Rvalue,\n+    Body, Constant, Local, Location, Operand, Place, PlaceRef, ProjectionElem, Rvalue,\n };\n use rustc_middle::ty::{self, TyCtxt};\n use std::mem;\n \n pub struct InstCombine;\n \n impl<'tcx> MirPass<'tcx> for InstCombine {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return;\n@@ -24,9 +23,8 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Place::ty()`).\n         let optimizations = {\n-            let read_only_cache = read_only!(body);\n             let mut optimization_finder = OptimizationFinder::new(body, tcx);\n-            optimization_finder.visit_body(&read_only_cache);\n+            optimization_finder.visit_body(body);\n             optimization_finder.optimizations\n         };\n "}, {"sha": "b7b67f36ae42fcb779cceef3c29d00f2b0b8652e", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -4,7 +4,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::{BodyAndCache, ConstQualifs, MirPhase, Promoted};\n+use rustc_middle::mir::{Body, ConstQualifs, MirPhase, Promoted};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::steal::Steal;\n use rustc_middle::ty::{InstanceDef, TyCtxt, TypeFoldable};\n@@ -131,12 +131,12 @@ pub trait MirPass<'tcx> {\n         default_name::<Self>()\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>);\n }\n \n pub fn run_passes(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     instance: InstanceDef<'tcx>,\n     promoted: Option<Promoted>,\n     mir_phase: MirPhase,\n@@ -194,13 +194,8 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n         return Default::default();\n     }\n \n-    let item = check_consts::Item {\n-        body: body.unwrap_read_only(),\n-        tcx,\n-        def_id,\n-        const_kind,\n-        param_env: tcx.param_env(def_id),\n-    };\n+    let item =\n+        check_consts::Item { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n \n     let mut validator = check_consts::validation::Validator::new(&item);\n     validator.check_body();\n@@ -210,7 +205,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n     validator.qualifs_in_return_place()\n }\n \n-fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyAndCache<'_>> {\n+fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n@@ -230,14 +225,13 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyAndCache<'_>> {\n             &rustc_peek::SanityCheck,\n         ],\n     );\n-    body.ensure_predecessors();\n     tcx.alloc_steal_mir(body)\n }\n \n fn mir_validated(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-) -> (&'tcx Steal<BodyAndCache<'tcx>>, &'tcx Steal<IndexVec<Promoted, BodyAndCache<'tcx>>>) {\n+) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n     // Ensure that we compute the `mir_const_qualif` for constants at\n     // this point, before we steal the mir-const result.\n     let _ = tcx.mir_const_qualif(def_id);\n@@ -263,7 +257,7 @@ fn mir_validated(\n \n fn run_optimization_passes<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     def_id: DefId,\n     promoted: Option<Promoted>,\n ) {\n@@ -319,7 +313,7 @@ fn run_optimization_passes<'tcx>(\n     );\n }\n \n-fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &BodyAndCache<'_> {\n+fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const\n@@ -335,14 +329,13 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &BodyAndCache<'_> {\n     let (body, _) = tcx.mir_validated(def_id);\n     let mut body = body.steal();\n     run_optimization_passes(tcx, &mut body, def_id, None);\n-    body.ensure_predecessors();\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n \n     tcx.arena.alloc(body)\n }\n \n-fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, BodyAndCache<'_>> {\n+fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, Body<'_>> {\n     if tcx.is_constructor(def_id) {\n         return tcx.intern_promoted(IndexVec::new());\n     }\n@@ -353,7 +346,6 @@ fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, BodyAndCa\n \n     for (p, mut body) in promoted.iter_enumerated_mut() {\n         run_optimization_passes(tcx, &mut body, def_id, Some(p));\n-        body.ensure_predecessors();\n     }\n \n     debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");"}, {"sha": "d89c8e72e526ab0d8412c3d468df4e68ed99311b", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -17,12 +17,12 @@ impl<'tcx> NoLandingPads<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }\n \n-pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         NoLandingPads::new(tcx).visit_body(body);\n     }"}, {"sha": "20576d82b1c7cae998285b0d66f75a84a32c8e56", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -42,11 +42,11 @@ use crate::transform::{MirPass, MirSource};\n /// newly created `Constant`.\n #[derive(Default)]\n pub struct PromoteTemps<'tcx> {\n-    pub promoted_fragments: Cell<IndexVec<Promoted, BodyAndCache<'tcx>>>,\n+    pub promoted_fragments: Cell<IndexVec<Promoted, Body<'tcx>>>,\n }\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         //\n         // This does not include MIR that failed const-checking, which we still try to promote.\n@@ -64,8 +64,7 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         let mut rpo = traversal::reverse_postorder(body);\n         let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n \n-        let promotable_candidates =\n-            validate_candidates(tcx, read_only!(body), def_id, &temps, &all_candidates);\n+        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n \n         let promoted = promote_candidates(def_id, body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n@@ -329,7 +328,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 // FIXME(eddyb) this is probably excessive, with\n                                 // the exception of `union` member accesses.\n                                 let ty =\n-                                    Place::ty_from(place.local, proj_base, *self.body, self.tcx)\n+                                    Place::ty_from(place.local, proj_base, self.body, self.tcx)\n                                         .projection_ty(self.tcx, elem)\n                                         .ty;\n                                 if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -350,7 +349,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         }\n \n                         if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(*self.body, self.tcx).ty;\n+                            let ty = place.ty(self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n@@ -494,7 +493,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n+                                Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -539,7 +538,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n-                let operand_ty = operand.ty(*self.body, self.tcx);\n+                let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -552,7 +551,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(*self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n                     assert!(\n                         op == BinOp::Eq\n                             || op == BinOp::Ne\n@@ -592,7 +591,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Raw reborrows can come from reference to pointer coercions,\n                 // so are allowed.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         return self.validate_place(PlaceRef {\n                             local: place.local,\n@@ -605,7 +604,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(*self.body, self.tcx).ty;\n+                    let ty = place.ty(self.body, self.tcx).ty;\n \n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -631,7 +630,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n-                    let base_ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         place = PlaceRef { local: place.local, projection: proj_base };\n                     }\n@@ -650,7 +649,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx)\n+                        let ty = Place::ty_from(place.local, proj_base, self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -683,7 +682,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n-        let fn_ty = callee.ty(*self.body, self.tcx);\n+        let fn_ty = callee.ty(self.body, self.tcx);\n \n         if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n@@ -719,7 +718,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n // FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     tcx: TyCtxt<'tcx>,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+    body: &Body<'tcx>,\n     def_id: DefId,\n     temps: &IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n@@ -752,8 +751,8 @@ pub fn validate_candidates(\n \n struct Promoter<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    source: &'a mut BodyAndCache<'tcx>,\n-    promoted: BodyAndCache<'tcx>,\n+    source: &'a mut Body<'tcx>,\n+    promoted: Body<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n     extra_statements: &'a mut Vec<(Location, Statement<'tcx>)>,\n \n@@ -901,7 +900,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         def_id: DefId,\n         candidate: Candidate,\n         next_promoted_id: usize,\n-    ) -> Option<BodyAndCache<'tcx>> {\n+    ) -> Option<Body<'tcx>> {\n         let mut rvalue = {\n             let promoted = &mut self.promoted;\n             let promoted_id = Promoted::new(next_promoted_id);\n@@ -1044,11 +1043,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n \n pub fn promote_candidates<'tcx>(\n     def_id: DefId,\n-    body: &mut BodyAndCache<'tcx>,\n+    body: &mut Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     mut temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n-) -> IndexVec<Promoted, BodyAndCache<'tcx>> {\n+) -> IndexVec<Promoted, Body<'tcx>> {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n \n@@ -1093,7 +1092,7 @@ pub fn promote_candidates<'tcx>(\n         promoted.ignore_interior_mut_in_const_validation = true;\n \n         let promoter = Promoter {\n-            promoted: BodyAndCache::new(promoted),\n+            promoted,\n             tcx,\n             source: body,\n             temps: &mut temps,\n@@ -1150,7 +1149,7 @@ pub fn promote_candidates<'tcx>(\n crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mir_def_id: DefId,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n+    body: &Body<'tcx>,\n     operand: &Operand<'tcx>,\n ) -> bool {\n     let mut rpo = traversal::reverse_postorder(&body);"}, {"sha": "44a68a8040f15e6e27162d4fdbdc9e7e3ab108f0", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::TyCtxt;\n /// code for these.\n pub struct RemoveNoopLandingPads;\n \n-pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         return;\n     }\n@@ -19,7 +19,7 @@ pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyAndCache\n }\n \n impl<'tcx> MirPass<'tcx> for RemoveNoopLandingPads {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         remove_noop_landing_pads(tcx, body);\n     }\n }\n@@ -80,7 +80,7 @@ impl RemoveNoopLandingPads {\n         }\n     }\n \n-    fn remove_nop_landing_pads(&self, body: &mut BodyAndCache<'_>) {\n+    fn remove_nop_landing_pads(&self, body: &mut Body<'_>) {\n         // make sure there's a single resume block\n         let resume_block = {\n             let patch = MirPatch::new(body);"}, {"sha": "88af60dbeb6576ad6cd7135430a759c29da91ab2", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -6,7 +6,7 @@ use rustc_target::spec::abi::Abi;\n use crate::transform::{MirPass, MirSource};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n-use rustc_middle::mir::{self, Body, BodyAndCache, Local, Location};\n+use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n@@ -21,7 +21,7 @@ use crate::dataflow::{\n pub struct SanityCheck;\n \n impl<'tcx> MirPass<'tcx> for SanityCheck {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         use crate::dataflow::has_rustc_mir_with;\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {"}, {"sha": "e579950d8c0acb3460f1aebb32e08fcfe8315fd8", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -45,7 +45,7 @@ impl SimplifyCfg {\n     }\n }\n \n-pub fn simplify_cfg(body: &mut BodyAndCache<'_>) {\n+pub fn simplify_cfg(body: &mut Body<'_>) {\n     CfgSimplifier::new(body).simplify();\n     remove_dead_blocks(body);\n \n@@ -58,7 +58,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n         simplify_cfg(body);\n     }\n@@ -70,7 +70,7 @@ pub struct CfgSimplifier<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n-    pub fn new(body: &'a mut BodyAndCache<'tcx>) -> Self {\n+    pub fn new(body: &'a mut Body<'tcx>) -> Self {\n         let mut pred_count = IndexVec::from_elem(0u32, body.basic_blocks());\n \n         // we can't use mir.predecessors() here because that counts\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n-pub fn remove_dead_blocks(body: &mut BodyAndCache<'_>) {\n+pub fn remove_dead_blocks(body: &mut Body<'_>) {\n     let mut seen = BitSet::new_empty(body.basic_blocks().len());\n     for (bb, _) in traversal::preorder(body) {\n         seen.insert(bb.index());\n@@ -304,15 +304,14 @@ pub fn remove_dead_blocks(body: &mut BodyAndCache<'_>) {\n pub struct SimplifyLocals;\n \n impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         trace!(\"running SimplifyLocals on {:?}\", source);\n \n         // First, we're going to get a count of *actual* uses for every `Local`.\n         // Take a look at `DeclMarker::visit_local()` to see exactly what is ignored.\n         let mut used_locals = {\n-            let read_only_cache = read_only!(body);\n             let mut marker = DeclMarker::new(body);\n-            marker.visit_body(&read_only_cache);\n+            marker.visit_body(&body);\n \n             marker.local_counts\n         };"}, {"sha": "38e7f9d8ae45b6bf7671ebdf6a92187720684c8e", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -21,7 +21,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let param_env = tcx.param_env(src.def_id());\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();"}, {"sha": "d22c2d906003541af875ec1ca7fd8824ba9653e7", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -33,7 +33,7 @@ use rustc_target::abi::VariantIdx;\n pub struct SimplifyArmIdentity;\n \n impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         for bb in basic_blocks {\n             // Need 3 statements:\n@@ -153,7 +153,7 @@ fn match_variant_field_place<'tcx>(place: Place<'tcx>) -> Option<(Local, VarFiel\n pub struct SimplifyBranchSame;\n \n impl<'tcx> MirPass<'tcx> for SimplifyBranchSame {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut did_remove_blocks = false;\n         let bbs = body.basic_blocks_mut();\n         for bb_idx in bbs.indices() {"}, {"sha": "e3b182b88492f10e81f5b2e7430dd3c3a6114452", "filename": "src/librustc_mir/transform/uninhabited_enum_branching.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,8 +2,7 @@\n \n use crate::transform::{MirPass, MirSource};\n use rustc_middle::mir::{\n-    BasicBlock, BasicBlockData, Body, BodyAndCache, Local, Operand, Rvalue, StatementKind,\n-    TerminatorKind,\n+    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, TerminatorKind,\n };\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{Ty, TyCtxt};\n@@ -67,7 +66,7 @@ fn variant_discriminants<'tcx>(\n }\n \n impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if source.promoted.is_some() {\n             return;\n         }"}, {"sha": "d9f2259030ff5b0b05ee715e8687b7405259bcb1", "filename": "src/librustc_mir/transform/unreachable_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Ftransform%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funreachable_prop.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -12,7 +12,7 @@ use std::borrow::Cow;\n pub struct UnreachablePropagation;\n \n impl MirPass<'_> for UnreachablePropagation {\n-    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level < 3 {\n             // Enable only under -Zmir-opt-level=3 as in some cases (check the deeply-nested-opt\n             // perf benchmark) LLVM may spend quite a lot of time optimizing the generated code."}, {"sha": "b4448ead8eb8124f4d304f1653e76514fe1ecb7a", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n-use rustc_middle::mir::{Body, BodyAndCache, Local, Location, ReadOnlyBodyAndCache, VarDebugInfo};\n+use rustc_middle::mir::{Body, Local, Location, VarDebugInfo};\n use rustc_middle::ty::TyCtxt;\n use std::mem;\n \n@@ -28,7 +28,7 @@ impl DefUseAnalysis {\n         DefUseAnalysis { info: IndexVec::from_elem_n(Info::new(), body.local_decls.len()) }\n     }\n \n-    pub fn analyze(&mut self, body: ReadOnlyBodyAndCache<'_, '_>) {\n+    pub fn analyze(&mut self, body: &Body<'_>) {\n         self.clear();\n \n         let mut finder = DefUseFinder {\n@@ -53,7 +53,7 @@ impl DefUseAnalysis {\n     fn mutate_defs_and_uses(\n         &self,\n         local: Local,\n-        body: &mut BodyAndCache<'tcx>,\n+        body: &mut Body<'tcx>,\n         new_local: Local,\n         tcx: TyCtxt<'tcx>,\n     ) {\n@@ -72,7 +72,7 @@ impl DefUseAnalysis {\n     pub fn replace_all_defs_and_uses_with(\n         &self,\n         local: Local,\n-        body: &mut BodyAndCache<'tcx>,\n+        body: &mut Body<'tcx>,\n         new_local: Local,\n         tcx: TyCtxt<'tcx>,\n     ) {"}, {"sha": "80b31be84caa2c7a8dcb8537e87a2662bc8e818d", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -56,7 +56,7 @@ pub struct LivenessResult {\n \n /// Computes which local variables are live within the given function\n /// `mir`, including drops.\n-pub fn liveness_of_locals(body: ReadOnlyBodyAndCache<'_, '_>) -> LivenessResult {\n+pub fn liveness_of_locals(body: &Body<'_>) -> LivenessResult {\n     let num_live_vars = body.local_decls.len();\n \n     let def_use: IndexVec<_, DefsUses> ="}, {"sha": "9153f82588b9ebcb5ff1e56fb072eb32b33fa02c", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> MirPatch<'tcx> {\n         self.make_nop.push(loc);\n     }\n \n-    pub fn apply(self, body: &mut BodyAndCache<'tcx>) {\n+    pub fn apply(self, body: &mut Body<'tcx>) {\n         debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n         for loc in self.make_nop {\n             body.make_statement_nop(loc);"}, {"sha": "2a3e91884375a0fa78ee22a1c8715bb900a7e542", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -21,12 +21,12 @@ use rustc_target::spec::PanicStrategy;\n \n use super::lints;\n \n-crate fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::steal::Steal<BodyAndCache<'_>> {\n+crate fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::steal::Steal<Body<'_>> {\n     tcx.alloc_steal_mir(mir_build(tcx, def_id))\n }\n \n /// Construct the MIR for a given `DefId`.\n-fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n+fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -183,9 +183,6 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n \n         lints::check(tcx, &body, def_id);\n \n-        let mut body = BodyAndCache::new(body);\n-        body.ensure_predecessors();\n-\n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here.\n         // The exception is `body.user_type_annotations`, which is used unmodified"}, {"sha": "3f08fb79790fb2aa3f1525241ad57c24fc624390", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -547,8 +547,7 @@ impl<'a> Parser<'a> {\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n-                let parser_snapshot_after_type = self.clone();\n-                mem::replace(self, parser_snapshot_before_type);\n+                let parser_snapshot_after_type = mem::replace(self, parser_snapshot_before_type);\n \n                 match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n@@ -560,7 +559,7 @@ impl<'a> Parser<'a> {\n                                 // example because `parse_ty_no_plus` returns `Err` on keywords,\n                                 // but `parse_path` returns `Ok` on them due to error recovery.\n                                 // Return original error and parser state.\n-                                mem::replace(self, parser_snapshot_after_type);\n+                                *self = parser_snapshot_after_type;\n                                 return Err(type_err);\n                             }\n                         };\n@@ -601,7 +600,7 @@ impl<'a> Parser<'a> {\n                     Err(mut path_err) => {\n                         // Couldn't parse as a path, return original error and parser state.\n                         path_err.cancel();\n-                        mem::replace(self, parser_snapshot_after_type);\n+                        *self = parser_snapshot_after_type;\n                         return Err(type_err);\n                     }\n                 }"}, {"sha": "8e8f864728ce67463c925baad8cb2a6010271c23", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -105,7 +105,7 @@ impl<'a> Parser<'a> {\n                     }\n                     Err(mut err) => {\n                         err.cancel();\n-                        std::mem::replace(self, snapshot);\n+                        *self = snapshot;\n                         break;\n                     }\n                 }"}, {"sha": "e9f5f2c0deafcc76d338a3ae8a3f919b220289e0", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1650,7 +1650,7 @@ impl<'a> Parser<'a> {\n                 // Recover from attempting to parse the argument as a type without pattern.\n                 Err(mut err) => {\n                     err.cancel();\n-                    mem::replace(self, parser_snapshot_before_ty);\n+                    *self = parser_snapshot_before_ty;\n                     self.recover_arg_parse()?\n                 }\n             }"}, {"sha": "e5d0ab247aa46ed4a9bcf0d61f3af0df96f11582", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -163,8 +163,8 @@ impl<'a> Parser<'a> {\n                 Ok(ty) => (None, Some(ty)),\n                 Err(mut err) => {\n                     // Rewind to before attempting to parse the type and continue parsing.\n-                    let parser_snapshot_after_type = self.clone();\n-                    mem::replace(self, parser_snapshot_before_type);\n+                    let parser_snapshot_after_type =\n+                        mem::replace(self, parser_snapshot_before_type);\n                     if let Ok(snip) = self.span_to_snippet(pat.span) {\n                         err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snip));\n                     }\n@@ -201,7 +201,7 @@ impl<'a> Parser<'a> {\n                 // Couldn't parse the type nor the initializer, only raise the type error and\n                 // return to the parser state before parsing the type as the initializer.\n                 // let x: <parse_error>;\n-                mem::replace(self, snapshot);\n+                *self = snapshot;\n                 return Err(ty_err);\n             }\n             (Err(err), None) => {"}, {"sha": "0d12bf08747fae3f88cac270dc504b1c14231289", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -26,7 +26,7 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::mem::{replace, take};\n+use std::mem::take;\n \n use log::debug;\n \n@@ -371,7 +371,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n             this.visit_body(body);\n         });\n-        replace(&mut self.labels_in_fn, saved);\n+        self.labels_in_fn = saved;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {"}, {"sha": "094c468a6770e25f5d2bcc37e530d42b0cd08d3a", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -301,7 +301,7 @@ mod lazy {\n             // value (an aliasing violation). To avoid setting the \"I'm running a\n             // destructor\" flag we just use `mem::replace` which should sequence the\n             // operations a little differently and make this safe to call.\n-            mem::replace(&mut *ptr, Some(value));\n+            let _ = mem::replace(&mut *ptr, Some(value));\n \n             // After storing `Some` we want to get a reference to the contents of\n             // what we just stored. While we could use `unwrap` here and it should"}, {"sha": "19703904ece91923cde03c7a0b5321920edd03c3", "filename": "src/test/ui/imports/import-in-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftest%2Fui%2Fimports%2Fimport-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftest%2Fui%2Fimports%2Fimport-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fimport-in-block.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -4,7 +4,7 @@\n pub fn main() {\n     use std::mem::replace;\n     let mut x = 5;\n-    replace(&mut x, 6);\n+    let _ = replace(&mut x, 6);\n     {\n         use std::mem::*;\n         let mut y = 6;"}, {"sha": "403cf970bcb0a52a49336c0ecf0dd2dcc2ff433a", "filename": "src/test/ui/issues/issue-23611-enum-swap-in-drop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftest%2Fui%2Fissues%2Fissue-23611-enum-swap-in-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftest%2Fui%2Fissues%2Fissue-23611-enum-swap-in-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23611-enum-swap-in-drop.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -153,6 +153,7 @@ impl<'a> Drop for E<'a> {\n             }\n         };\n \n+        #[allow(unused_must_use)]\n         if do_drop {\n             mem::replace(self, E::A(GaspA(f_a, 0xA3A0, log, D::new(\"drop\", 6, log)), true));\n         }"}, {"sha": "0caf186db1d5fac483284bcb1435303ca0560378", "filename": "src/test/ui/proc-macro/auxiliary/is-available.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -0,0 +1,14 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_is_available)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{Literal, TokenStream, TokenTree};\n+\n+#[proc_macro]\n+pub fn from_inside_proc_macro(_input: TokenStream) -> TokenStream {\n+    proc_macro::is_available().to_string().parse().unwrap()\n+}"}, {"sha": "943d9fe797a6ec80ee30cd587dcb16a8850c6c8a", "filename": "src/test/ui/proc-macro/is-available.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(proc_macro_hygiene, proc_macro_is_available)]\n+\n+extern crate proc_macro;\n+\n+// aux-build:is-available.rs\n+extern crate is_available;\n+\n+fn main() {\n+    let a = proc_macro::is_available();\n+    let b = is_available::from_inside_proc_macro!();\n+    let c = proc_macro::is_available();\n+    assert!(!a);\n+    assert!(b);\n+    assert!(!c);\n+}"}, {"sha": "26baf87e4300386910f9db7545edf784dbec88f0", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -1 +1 @@\n-Subproject commit 5c823a1ec1eb3ff89bcbcb6c1fa8e1f8b24eb521\n+Subproject commit 26baf87e4300386910f9db7545edf784dbec88f0"}, {"sha": "243d41598f86c739dba3941f668a42e75e47f9f1", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28847e5c37d27438ce865ab40f3c4e3799051974/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=28847e5c37d27438ce865ab40f3c4e3799051974", "patch": "@@ -15,21 +15,57 @@ const WHITELIST: &[&str] = &[\n     \"E0727\", \"E0729\",\n ];\n \n+// Some error codes don't have any tests apparently...\n+const IGNORE_EXPLANATION_CHECK: &[&str] =\n+    &[\"E0570\", \"E0601\", \"E0602\", \"E0639\", \"E0729\", \"E0749\", \"E0750\", \"E0751\"];\n+\n fn check_error_code_explanation(\n     f: &str,\n     error_codes: &mut HashMap<String, bool>,\n     err_code: String,\n-) {\n+) -> bool {\n+    let mut invalid_compile_fail_format = false;\n+    let mut found_error_code = false;\n+\n     for line in f.lines() {\n         let s = line.trim();\n-        if s.starts_with(\"```\") && s.contains(\"compile_fail\") && s.contains('E') {\n-            error_codes.insert(err_code, true);\n-            return;\n+        if s.starts_with(\"```\") {\n+            if s.contains(\"compile_fail\") && s.contains('E') {\n+                if !found_error_code {\n+                    error_codes.insert(err_code.clone(), true);\n+                    found_error_code = true;\n+                }\n+            } else if s.contains(\"compile-fail\") {\n+                invalid_compile_fail_format = true;\n+            }\n         } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n-            error_codes.get_mut(&err_code).map(|x| *x = true);\n-            return;\n+            if !found_error_code {\n+                error_codes.get_mut(&err_code).map(|x| *x = true);\n+                found_error_code = true;\n+            }\n         }\n     }\n+    invalid_compile_fail_format\n+}\n+\n+fn check_if_error_code_is_test_in_explanation(f: &str, err_code: &String) -> bool {\n+    let mut can_be_ignored = false;\n+\n+    for line in f.lines() {\n+        let s = line.trim();\n+        if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n+            return true;\n+        }\n+        if s.starts_with(\"```\") {\n+            if s.contains(\"compile_fail\") && s.contains(err_code) {\n+                return true;\n+            } else if s.contains(\"(\") {\n+                // It's very likely that we can't actually make it fail compilation...\n+                can_be_ignored = true;\n+            }\n+        }\n+    }\n+    can_be_ignored\n }\n \n macro_rules! some_or_continue {\n@@ -41,7 +77,12 @@ macro_rules! some_or_continue {\n     };\n }\n \n-fn extract_error_codes(f: &str, error_codes: &mut HashMap<String, bool>, path: &Path) {\n+fn extract_error_codes(\n+    f: &str,\n+    error_codes: &mut HashMap<String, bool>,\n+    path: &Path,\n+    errors: &mut Vec<String>,\n+) {\n     let mut reached_no_explanation = false;\n \n     for line in f.lines() {\n@@ -55,10 +96,26 @@ fn extract_error_codes(f: &str, error_codes: &mut HashMap<String, bool>, path: &\n                 // Now we extract the tests from the markdown file!\n                 let md = some_or_continue!(s.splitn(2, \"include_str!(\\\"\").nth(1));\n                 let md_file_name = some_or_continue!(md.splitn(2, \"\\\")\").next());\n-                let path = some_or_continue!(path.parent()).join(md_file_name);\n+                let path = some_or_continue!(path.parent())\n+                    .join(md_file_name)\n+                    .canonicalize()\n+                    .expect(\"failed to canonicalize error explanation file path\");\n                 match read_to_string(&path) {\n                     Ok(content) => {\n-                        check_error_code_explanation(&content, error_codes, err_code);\n+                        if !IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str())\n+                            && !check_if_error_code_is_test_in_explanation(&content, &err_code)\n+                        {\n+                            errors.push(format!(\n+                                \"`{}` doesn't use its own error code in compile_fail example\",\n+                                path.display(),\n+                            ));\n+                        }\n+                        if check_error_code_explanation(&content, error_codes, err_code) {\n+                            errors.push(format!(\n+                                \"`{}` uses invalid tag `compile-fail` instead of `compile_fail`\",\n+                                path.display(),\n+                            ));\n+                        }\n                     }\n                     Err(e) => {\n                         eprintln!(\"Couldn't read `{}`: {}\", path.display(), e);\n@@ -94,22 +151,24 @@ fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, boo\n }\n \n pub fn check(path: &Path, bad: &mut bool) {\n+    let mut errors = Vec::new();\n     println!(\"Checking which error codes lack tests...\");\n     let mut error_codes: HashMap<String, bool> = HashMap::new();\n     super::walk(path, &mut |path| super::filter_dirs(path), &mut |entry, contents| {\n         let file_name = entry.file_name();\n         if file_name == \"error_codes.rs\" {\n-            extract_error_codes(contents, &mut error_codes, entry.path());\n+            extract_error_codes(contents, &mut error_codes, entry.path(), &mut errors);\n         } else if entry.path().extension() == Some(OsStr::new(\"stderr\")) {\n             extract_error_codes_from_tests(contents, &mut error_codes);\n         }\n     });\n-    println!(\"Found {} error codes\", error_codes.len());\n+    if errors.is_empty() {\n+        println!(\"Found {} error codes\", error_codes.len());\n \n-    let mut errors = Vec::new();\n-    for (err_code, nb) in &error_codes {\n-        if !*nb && !WHITELIST.contains(&err_code.as_str()) {\n-            errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n+        for (err_code, nb) in &error_codes {\n+            if !*nb && !WHITELIST.contains(&err_code.as_str()) {\n+                errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n+            }\n         }\n     }\n     errors.sort();"}]}