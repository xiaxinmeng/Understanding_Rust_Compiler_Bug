{"sha": "8d2d0014922e9f541694bfe87642749239990e0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMmQwMDE0OTIyZTlmNTQxNjk0YmZlODc2NDI3NDkyMzk5OTBlMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-18T18:16:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-18T18:16:31Z"}, "message": "Auto merge of #79167 - m-ou-se:rollup-4g15apk, r=m-ou-se\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #78361 (Updated the list of white-listed target features for x86)\n - #78785 (linux: try to use libc getrandom to allow interposition)\n - #78999 (stability: More precise location for deprecation lint on macros)\n - #79039 (Tighten the bounds on atomic Ordering in std::sys::unix::weak::Weak)\n - #79079 (Turn top-level comments into module docs in MIR visitor)\n - #79114 (add trailing_zeros and leading_zeros to non zero types)\n - #79131 (Enable AVX512 *epi64 variants by updating stdarch)\n - #79133 (bootstrap: use the same version number for rustc and cargo)\n - #79145 (Fix handling of panic calls)\n - #79151 (Fix typo in `std::io::Write` docs)\n - #79158 (type is too big -> values of the type are too big)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ca8ebb464fe87caa0665186f44cec18e2ba19558", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca8ebb464fe87caa0665186f44cec18e2ba19558"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d2d0014922e9f541694bfe87642749239990e0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2d0014922e9f541694bfe87642749239990e0e", "html_url": "https://github.com/rust-lang/rust/commit/8d2d0014922e9f541694bfe87642749239990e0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d2d0014922e9f541694bfe87642749239990e0e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d747db0d5dd8f08f2efb073e2e77a34553465a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d747db0d5dd8f08f2efb073e2e77a34553465a7", "html_url": "https://github.com/rust-lang/rust/commit/7d747db0d5dd8f08f2efb073e2e77a34553465a7"}, {"sha": "43d13e2d584c32b125d61f055e6e7127a77b1d54", "url": "https://api.github.com/repos/rust-lang/rust/commits/43d13e2d584c32b125d61f055e6e7127a77b1d54", "html_url": "https://github.com/rust-lang/rust/commit/43d13e2d584c32b125d61f055e6e7127a77b1d54"}], "stats": {"total": 771, "additions": 549, "deletions": 222}, "files": [{"sha": "a3139ce5a345543984b8f89520139fbf6d4a75ff", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -129,13 +129,23 @@ pub fn time_trace_profiler_finish(file_name: &str) {\n // WARNING: the features after applying `to_llvm_feature` must be known\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n+// To find a list of LLVM's names, check llvm-project/llvm/include/llvm/Support/*TargetParser.def\n+// where the * matches the architecture's name\n+// Beware to not use the llvm github project for this, but check the git submodule\n+// found in src/llvm-project\n+// Though note that Rust can also be build with an external precompiled version of LLVM\n+// which might lead to failures if the oldest tested / supported LLVM version\n+// doesn't yet support the relevant intrinsics\n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n     let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n     match (arch, s) {\n         (\"x86\", \"pclmulqdq\") => \"pclmul\",\n         (\"x86\", \"rdrand\") => \"rdrnd\",\n         (\"x86\", \"bmi1\") => \"bmi\",\n         (\"x86\", \"cmpxchg16b\") => \"cx16\",\n+        (\"x86\", \"avx512vaes\") => \"vaes\",\n+        (\"x86\", \"avx512gfni\") => \"gfni\",\n+        (\"x86\", \"avx512vpclmulqdq\") => \"vpclmulqdq\",\n         (\"aarch64\", \"fp\") => \"fp-armv8\",\n         (\"aarch64\", \"fp16\") => \"fullfp16\",\n         (_, s) => s,"}, {"sha": "fd18f42f2dd4feab445a6b3dfb766e3be3bf1dd0", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -4,6 +4,11 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n \n+// When adding features to the below lists\n+// check whether they're named already elsewhere in rust\n+// e.g. in stdarch and whether the given name matches LLVM's\n+// if it doesn't, to_llvm_feature in llvm_util in rustc_codegen_llvm needs to be adapted\n+\n const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"aclass\", Some(sym::arm_target_feature)),\n     (\"mclass\", Some(sym::arm_target_feature)),\n@@ -50,15 +55,23 @@ const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"aes\", None),\n     (\"avx\", None),\n     (\"avx2\", None),\n+    (\"avx512bf16\", Some(sym::avx512_target_feature)),\n+    (\"avx512bitalg\", Some(sym::avx512_target_feature)),\n     (\"avx512bw\", Some(sym::avx512_target_feature)),\n     (\"avx512cd\", Some(sym::avx512_target_feature)),\n     (\"avx512dq\", Some(sym::avx512_target_feature)),\n     (\"avx512er\", Some(sym::avx512_target_feature)),\n     (\"avx512f\", Some(sym::avx512_target_feature)),\n+    (\"avx512gfni\", Some(sym::avx512_target_feature)),\n     (\"avx512ifma\", Some(sym::avx512_target_feature)),\n     (\"avx512pf\", Some(sym::avx512_target_feature)),\n+    (\"avx512vaes\", Some(sym::avx512_target_feature)),\n     (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n+    (\"avx512vbmi2\", Some(sym::avx512_target_feature)),\n     (\"avx512vl\", Some(sym::avx512_target_feature)),\n+    (\"avx512vnni\", Some(sym::avx512_target_feature)),\n+    (\"avx512vp2intersect\", Some(sym::avx512_target_feature)),\n+    (\"avx512vpclmulqdq\", Some(sym::avx512_target_feature)),\n     (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n     (\"bmi1\", None),\n     (\"bmi2\", None),"}, {"sha": "47c140e0b18829b4e82b051f1dbd9000edda2e7f", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -4,7 +4,7 @@\n pub use self::StabilityLevel::*;\n \n use crate::ty::{self, TyCtxt};\n-use rustc_ast::CRATE_NODE_ID;\n+use rustc_ast::NodeId;\n use rustc_attr::{self as attr, ConstStability, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -211,13 +211,14 @@ pub fn early_report_deprecation(\n     suggestion: Option<Symbol>,\n     lint: &'static Lint,\n     span: Span,\n+    node_id: NodeId,\n ) {\n     if span.in_derive_expansion() {\n         return;\n     }\n \n     let diag = BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span);\n-    lint_buffer.buffer_lint_with_diagnostic(lint, CRATE_NODE_ID, span, message, diag);\n+    lint_buffer.buffer_lint_with_diagnostic(lint, node_id, span, message, diag);\n }\n \n fn late_report_deprecation("}, {"sha": "638dd8ce9706f355a408c8a0438ac801b06224e9", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,70 +1,70 @@\n+//! # The MIR Visitor\n+//!\n+//! ## Overview\n+//!\n+//! There are two visitors, one for immutable and one for mutable references,\n+//! but both are generated by the following macro. The code is written according\n+//! to the following conventions:\n+//!\n+//! - introduce a `visit_foo` and a `super_foo` method for every MIR type\n+//! - `visit_foo`, by default, calls `super_foo`\n+//! - `super_foo`, by default, destructures the `foo` and calls `visit_foo`\n+//!\n+//! This allows you as a user to override `visit_foo` for types are\n+//! interested in, and invoke (within that method) call\n+//! `self.super_foo` to get the default behavior. Just as in an OO\n+//! language, you should never call `super` methods ordinarily except\n+//! in that circumstance.\n+//!\n+//! For the most part, we do not destructure things external to the\n+//! MIR, e.g., types, spans, etc, but simply visit them and stop. This\n+//! avoids duplication with other visitors like `TypeFoldable`.\n+//!\n+//! ## Updating\n+//!\n+//! The code is written in a very deliberate style intended to minimize\n+//! the chance of things being overlooked. You'll notice that we always\n+//! use pattern matching to reference fields and we ensure that all\n+//! matches are exhaustive.\n+//!\n+//! For example, the `super_basic_block_data` method begins like this:\n+//!\n+//! ```rust\n+//! fn super_basic_block_data(&mut self,\n+//!                           block: BasicBlock,\n+//!                           data: & $($mutability)? BasicBlockData<'tcx>) {\n+//!     let BasicBlockData {\n+//!         statements,\n+//!         terminator,\n+//!         is_cleanup: _\n+//!     } = *data;\n+//!\n+//!     for statement in statements {\n+//!         self.visit_statement(block, statement);\n+//!     }\n+//!\n+//!     ...\n+//! }\n+//! ```\n+//!\n+//! Here we used `let BasicBlockData { <fields> } = *data` deliberately,\n+//! rather than writing `data.statements` in the body. This is because if one\n+//! adds a new field to `BasicBlockData`, one will be forced to revise this code,\n+//! and hence one will (hopefully) invoke the correct visit methods (if any).\n+//!\n+//! For this to work, ALL MATCHES MUST BE EXHAUSTIVE IN FIELDS AND VARIANTS.\n+//! That means you never write `..` to skip over fields, nor do you write `_`\n+//! to skip over variants in a `match`.\n+//!\n+//! The only place that `_` is acceptable is to match a field (or\n+//! variant argument) that does not require visiting, as in\n+//! `is_cleanup` above.\n+\n use crate::mir::*;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{CanonicalUserTypeAnnotation, Ty};\n use rustc_span::Span;\n \n-// # The MIR Visitor\n-//\n-// ## Overview\n-//\n-// There are two visitors, one for immutable and one for mutable references,\n-// but both are generated by the following macro. The code is written according\n-// to the following conventions:\n-//\n-// - introduce a `visit_foo` and a `super_foo` method for every MIR type\n-// - `visit_foo`, by default, calls `super_foo`\n-// - `super_foo`, by default, destructures the `foo` and calls `visit_foo`\n-//\n-// This allows you as a user to override `visit_foo` for types are\n-// interested in, and invoke (within that method) call\n-// `self.super_foo` to get the default behavior. Just as in an OO\n-// language, you should never call `super` methods ordinarily except\n-// in that circumstance.\n-//\n-// For the most part, we do not destructure things external to the\n-// MIR, e.g., types, spans, etc, but simply visit them and stop. This\n-// avoids duplication with other visitors like `TypeFoldable`.\n-//\n-// ## Updating\n-//\n-// The code is written in a very deliberate style intended to minimize\n-// the chance of things being overlooked. You'll notice that we always\n-// use pattern matching to reference fields and we ensure that all\n-// matches are exhaustive.\n-//\n-// For example, the `super_basic_block_data` method begins like this:\n-//\n-// ```rust\n-// fn super_basic_block_data(&mut self,\n-//                           block: BasicBlock,\n-//                           data: & $($mutability)? BasicBlockData<'tcx>) {\n-//     let BasicBlockData {\n-//         statements,\n-//         terminator,\n-//         is_cleanup: _\n-//     } = *data;\n-//\n-//     for statement in statements {\n-//         self.visit_statement(block, statement);\n-//     }\n-//\n-//     ...\n-// }\n-// ```\n-//\n-// Here we used `let BasicBlockData { <fields> } = *data` deliberately,\n-// rather than writing `data.statements` in the body. This is because if one\n-// adds a new field to `BasicBlockData`, one will be forced to revise this code,\n-// and hence one will (hopefully) invoke the correct visit methods (if any).\n-//\n-// For this to work, ALL MATCHES MUST BE EXHAUSTIVE IN FIELDS AND VARIANTS.\n-// That means you never write `..` to skip over fields, nor do you write `_`\n-// to skip over variants in a `match`.\n-//\n-// The only place that `_` is acceptable is to match a field (or\n-// variant argument) that does not require visiting, as in\n-// `is_cleanup` above.\n-\n macro_rules! make_mir_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {"}, {"sha": "5626c864fe175e13ded320a28d7e2b939803863d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -176,7 +176,7 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n         match *self {\n             LayoutError::Unknown(ty) => write!(f, \"the type `{}` has an unknown layout\", ty),\n             LayoutError::SizeOverflow(ty) => {\n-                write!(f, \"the type `{}` is too big for the current architecture\", ty)\n+                write!(f, \"values of the type `{}` are too big for the current architecture\", ty)\n             }\n         }\n     }"}, {"sha": "21e43be20456b654697fc376f997a0243867e536", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1034,6 +1034,7 @@ impl<'a> Resolver<'a> {\n                 depr.suggestion,\n                 lint,\n                 span,\n+                node_id,\n             );\n         }\n     }"}, {"sha": "54743ef9ce9115cd2349ee2cbcf002edb55fea92", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -97,6 +97,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    #[instrument(skip(self))]\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty.has_projections() {\n             return ty;"}, {"sha": "d67f9c15a1916dc218c5d27141df209076ca9659", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -80,6 +80,7 @@\n #![feature(const_mut_refs)]\n #![feature(const_int_pow)]\n #![feature(constctlz)]\n+#![feature(const_cttz)]\n #![feature(const_panic)]\n #![feature(const_pin)]\n #![feature(const_fn)]"}, {"sha": "716b4a90e5ec279885a1647014449ccf9974d891", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -6,6 +6,7 @@ use crate::str::FromStr;\n \n use super::from_str_radix;\n use super::{IntErrorKind, ParseIntError};\n+use crate::intrinsics;\n \n macro_rules! doc_comment {\n     ($x:expr, $($tt:tt)*) => {\n@@ -189,3 +190,76 @@ macro_rules! from_str_radix_nzint_impl {\n \n from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\n NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n+\n+macro_rules! nonzero_leading_trailing_zeros {\n+    ( $( $Ty: ident($Uint: ty) , $LeadingTestExpr:expr ;)+ ) => {\n+        $(\n+            impl $Ty {\n+                doc_comment! {\n+                    concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n+\n+On many architectures, this function can perform better than `leading_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(nonzero_leading_trailing_zeros)]\n+let n = std::num::\", stringify!($Ty), \"::new(\", stringify!($LeadingTestExpr), \").unwrap();\n+\n+assert_eq!(n.leading_zeros(), 0);\n+```\"),\n+                    #[unstable(feature = \"nonzero_leading_trailing_zeros\", issue = \"79143\")]\n+                    #[rustc_const_unstable(feature = \"nonzero_leading_trailing_zeros\", issue = \"79143\")]\n+                    #[inline]\n+                    pub const fn leading_zeros(self) -> u32 {\n+                        // SAFETY: since `self` can not be zero it is safe to call ctlz_nonzero\n+                        unsafe { intrinsics::ctlz_nonzero(self.0 as $Uint) as u32 }\n+                    }\n+                }\n+\n+                doc_comment! {\n+                    concat!(\"Returns the number of trailing zeros in the binary representation\n+of `self`.\n+\n+On many architectures, this function can perform better than `trailing_zeros()` on the underlying integer type, as special handling of zero can be avoided.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(nonzero_leading_trailing_zeros)]\n+let n = std::num::\", stringify!($Ty), \"::new(0b0101000).unwrap();\n+\n+assert_eq!(n.trailing_zeros(), 3);\n+```\"),\n+                    #[unstable(feature = \"nonzero_leading_trailing_zeros\", issue = \"79143\")]\n+                    #[rustc_const_unstable(feature = \"nonzero_leading_trailing_zeros\", issue = \"79143\")]\n+                    #[inline]\n+                    pub const fn trailing_zeros(self) -> u32 {\n+                        // SAFETY: since `self` can not be zero it is safe to call cttz_nonzero\n+                        unsafe { intrinsics::cttz_nonzero(self.0 as $Uint) as u32 }\n+                    }\n+                }\n+\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_leading_trailing_zeros! {\n+    NonZeroU8(u8), u8::MAX;\n+    NonZeroU16(u16), u16::MAX;\n+    NonZeroU32(u32), u32::MAX;\n+    NonZeroU64(u64), u64::MAX;\n+    NonZeroU128(u128), u128::MAX;\n+    NonZeroUsize(usize), usize::MAX;\n+    NonZeroI8(u8), -1i8;\n+    NonZeroI16(u16), -1i16;\n+    NonZeroI32(u32), -1i32;\n+    NonZeroI64(u64), -1i64;\n+    NonZeroI128(u128), -1i128;\n+    NonZeroIsize(usize), -1isize;\n+}"}, {"sha": "14ef03fd53ebacbceaf5a9f37a21b6e2df0cbbec", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -60,6 +60,8 @@\n #![feature(once_cell)]\n #![feature(unsafe_block_in_unsafe_fn)]\n #![feature(int_bits_const)]\n+#![feature(nonzero_leading_trailing_zeros)]\n+#![feature(const_option)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}, {"sha": "ca449b4350ede910479698cc7257cc64f2489d50", "filename": "library/core/tests/nonzero.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnonzero.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,5 +1,8 @@\n use core::convert::TryFrom;\n-use core::num::{IntErrorKind, NonZeroI32, NonZeroI8, NonZeroU32, NonZeroU8};\n+use core::num::{\n+    IntErrorKind, NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize,\n+    NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize,\n+};\n use core::option::Option::{self, None, Some};\n use std::mem::size_of;\n \n@@ -212,3 +215,100 @@ fn nonzero_const() {\n     const ONE: Option<NonZeroU8> = NonZeroU8::new(1);\n     assert!(ONE.is_some());\n }\n+\n+#[test]\n+fn nonzero_leading_zeros() {\n+    assert_eq!(NonZeroU8::new(1).unwrap().leading_zeros(), 7);\n+    assert_eq!(NonZeroI8::new(1).unwrap().leading_zeros(), 7);\n+    assert_eq!(NonZeroU16::new(1).unwrap().leading_zeros(), 15);\n+    assert_eq!(NonZeroI16::new(1).unwrap().leading_zeros(), 15);\n+    assert_eq!(NonZeroU32::new(1).unwrap().leading_zeros(), 31);\n+    assert_eq!(NonZeroI32::new(1).unwrap().leading_zeros(), 31);\n+    assert_eq!(NonZeroU64::new(1).unwrap().leading_zeros(), 63);\n+    assert_eq!(NonZeroI64::new(1).unwrap().leading_zeros(), 63);\n+    assert_eq!(NonZeroU128::new(1).unwrap().leading_zeros(), 127);\n+    assert_eq!(NonZeroI128::new(1).unwrap().leading_zeros(), 127);\n+    assert_eq!(NonZeroUsize::new(1).unwrap().leading_zeros(), usize::BITS - 1);\n+    assert_eq!(NonZeroIsize::new(1).unwrap().leading_zeros(), usize::BITS - 1);\n+\n+    assert_eq!(NonZeroU8::new(u8::MAX >> 2).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroI8::new((u8::MAX >> 2) as i8).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroU16::new(u16::MAX >> 2).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroI16::new((u16::MAX >> 2) as i16).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroU32::new(u32::MAX >> 2).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroI32::new((u32::MAX >> 2) as i32).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroU64::new(u64::MAX >> 2).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroI64::new((u64::MAX >> 2) as i64).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroU128::new(u128::MAX >> 2).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroI128::new((u128::MAX >> 2) as i128).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroUsize::new(usize::MAX >> 2).unwrap().leading_zeros(), 2);\n+    assert_eq!(NonZeroIsize::new((usize::MAX >> 2) as isize).unwrap().leading_zeros(), 2);\n+\n+    assert_eq!(NonZeroU8::new(u8::MAX).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroI8::new(-1i8).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroU16::new(u16::MAX).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroI16::new(-1i16).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroU32::new(u32::MAX).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroI32::new(-1i32).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroU64::new(u64::MAX).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroI64::new(-1i64).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroU128::new(u128::MAX).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroI128::new(-1i128).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroUsize::new(usize::MAX).unwrap().leading_zeros(), 0);\n+    assert_eq!(NonZeroIsize::new(-1isize).unwrap().leading_zeros(), 0);\n+\n+    const LEADING_ZEROS: u32 = NonZeroU16::new(1).unwrap().leading_zeros();\n+    assert_eq!(LEADING_ZEROS, 15);\n+}\n+\n+#[test]\n+fn nonzero_trailing_zeros() {\n+    assert_eq!(NonZeroU8::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroI8::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroU16::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroI16::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroU32::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroI32::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroU64::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroI64::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroU128::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroI128::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroUsize::new(1).unwrap().trailing_zeros(), 0);\n+    assert_eq!(NonZeroIsize::new(1).unwrap().trailing_zeros(), 0);\n+\n+    assert_eq!(NonZeroU8::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroI8::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroU16::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroI16::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroU32::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroI32::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroU64::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroI64::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroU128::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroI128::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroUsize::new(1 << 2).unwrap().trailing_zeros(), 2);\n+    assert_eq!(NonZeroIsize::new(1 << 2).unwrap().trailing_zeros(), 2);\n+\n+    assert_eq!(NonZeroU8::new(1 << 7).unwrap().trailing_zeros(), 7);\n+    assert_eq!(NonZeroI8::new(1 << 7).unwrap().trailing_zeros(), 7);\n+    assert_eq!(NonZeroU16::new(1 << 15).unwrap().trailing_zeros(), 15);\n+    assert_eq!(NonZeroI16::new(1 << 15).unwrap().trailing_zeros(), 15);\n+    assert_eq!(NonZeroU32::new(1 << 31).unwrap().trailing_zeros(), 31);\n+    assert_eq!(NonZeroI32::new(1 << 31).unwrap().trailing_zeros(), 31);\n+    assert_eq!(NonZeroU64::new(1 << 63).unwrap().trailing_zeros(), 63);\n+    assert_eq!(NonZeroI64::new(1 << 63).unwrap().trailing_zeros(), 63);\n+    assert_eq!(NonZeroU128::new(1 << 127).unwrap().trailing_zeros(), 127);\n+    assert_eq!(NonZeroI128::new(1 << 127).unwrap().trailing_zeros(), 127);\n+\n+    assert_eq!(\n+        NonZeroUsize::new(1 << (usize::BITS - 1)).unwrap().trailing_zeros(),\n+        usize::BITS - 1\n+    );\n+    assert_eq!(\n+        NonZeroIsize::new(1 << (usize::BITS - 1)).unwrap().trailing_zeros(),\n+        usize::BITS - 1\n+    );\n+\n+    const TRAILING_ZEROS: u32 = NonZeroU16::new(1 << 2).unwrap().trailing_zeros();\n+    assert_eq!(TRAILING_ZEROS, 2);\n+}"}, {"sha": "dfbf6c3f24443e84e1db0de6ee530adc65a26ca5", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1307,10 +1307,10 @@ pub trait Write {\n         default_write_vectored(|b| self.write(b), bufs)\n     }\n \n-    /// Determines if this `Write`er has an efficient [`write_vectored`]\n+    /// Determines if this `Write`r has an efficient [`write_vectored`]\n     /// implementation.\n     ///\n-    /// If a `Write`er does not override the default [`write_vectored`]\n+    /// If a `Write`r does not override the default [`write_vectored`]\n     /// implementation, code using it may want to avoid the method all together\n     /// and coalesce writes into a single buffer for higher performance.\n     ///"}, {"sha": "1dc16ef099367c8835f503943bc1e869d4b21a5d", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -445,15 +445,15 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n     // We store the availability in a global to avoid unnecessary syscalls\n     static HAS_COPY_FILE_RANGE: AtomicBool = AtomicBool::new(true);\n \n-    unsafe fn copy_file_range(\n-        fd_in: libc::c_int,\n-        off_in: *mut libc::loff_t,\n-        fd_out: libc::c_int,\n-        off_out: *mut libc::loff_t,\n-        len: libc::size_t,\n-        flags: libc::c_uint,\n-    ) -> libc::c_long {\n-        libc::syscall(libc::SYS_copy_file_range, fd_in, off_in, fd_out, off_out, len, flags)\n+    syscall! {\n+        fn copy_file_range(\n+            fd_in: libc::c_int,\n+            off_in: *mut libc::loff_t,\n+            fd_out: libc::c_int,\n+            off_out: *mut libc::loff_t,\n+            len: libc::size_t,\n+            flags: libc::c_uint\n+        ) -> libc::ssize_t\n     }\n \n     let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);"}, {"sha": "38ddb41700c4b323c6ec2719f3c6d1072a019e91", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -25,10 +25,19 @@ mod imp {\n     use crate::io::Read;\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn getrandom(buf: &mut [u8]) -> libc::c_long {\n-        unsafe {\n-            libc::syscall(libc::SYS_getrandom, buf.as_mut_ptr(), buf.len(), libc::GRND_NONBLOCK)\n+    fn getrandom(buf: &mut [u8]) -> libc::ssize_t {\n+        // A weak symbol allows interposition, e.g. for perf measurements that want to\n+        // disable randomness for consistency. Otherwise, we'll try a raw syscall.\n+        // (`getrandom` was added in glibc 2.25, musl 1.1.20, android API level 28)\n+        syscall! {\n+            fn getrandom(\n+                buffer: *mut libc::c_void,\n+                length: libc::size_t,\n+                flags: libc::c_uint\n+            ) -> libc::ssize_t\n         }\n+\n+        unsafe { getrandom(buf.as_mut_ptr().cast(), buf.len(), libc::GRND_NONBLOCK) }\n     }\n \n     #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]"}, {"sha": "53d95dca4cd8272b27f3f1894db27e230d0320b8", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -24,7 +24,7 @@\n use crate::ffi::CStr;\n use crate::marker;\n use crate::mem;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::atomic::{self, AtomicUsize, Ordering};\n \n macro_rules! weak {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n@@ -47,15 +47,49 @@ impl<F> Weak<F> {\n     pub fn get(&self) -> Option<F> {\n         assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n         unsafe {\n-            if self.addr.load(Ordering::SeqCst) == 1 {\n-                self.addr.store(fetch(self.name), Ordering::SeqCst);\n-            }\n-            match self.addr.load(Ordering::SeqCst) {\n+            // Relaxed is fine here because we fence before reading through the\n+            // pointer (see the comment below).\n+            match self.addr.load(Ordering::Relaxed) {\n+                1 => self.initialize(),\n                 0 => None,\n-                addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n+                addr => {\n+                    let func = mem::transmute_copy::<usize, F>(&addr);\n+                    // The caller is presumably going to read through this value\n+                    // (by calling the function we've dlsymed). This means we'd\n+                    // need to have loaded it with at least C11's consume\n+                    // ordering in order to be guaranteed that the data we read\n+                    // from the pointer isn't from before the pointer was\n+                    // stored. Rust has no equivalent to memory_order_consume,\n+                    // so we use an acquire fence (sorry, ARM).\n+                    //\n+                    // Now, in practice this likely isn't needed even on CPUs\n+                    // where relaxed and consume mean different things. The\n+                    // symbols we're loading are probably present (or not) at\n+                    // init, and even if they aren't the runtime dynamic loader\n+                    // is extremely likely have sufficient barriers internally\n+                    // (possibly implicitly, for example the ones provided by\n+                    // invoking `mprotect`).\n+                    //\n+                    // That said, none of that's *guaranteed*, and so we fence.\n+                    atomic::fence(Ordering::Acquire);\n+                    Some(func)\n+                }\n             }\n         }\n     }\n+\n+    // Cold because it should only happen during first-time initalization.\n+    #[cold]\n+    unsafe fn initialize(&self) -> Option<F> {\n+        let val = fetch(self.name);\n+        // This synchronizes with the acquire fence in `get`.\n+        self.addr.store(val, Ordering::Release);\n+\n+        match val {\n+            0 => None,\n+            addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n+        }\n+    }\n }\n \n unsafe fn fetch(name: &str) -> usize {\n@@ -66,7 +100,7 @@ unsafe fn fetch(name: &str) -> usize {\n     libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n }\n \n-#[cfg(not(target_os = \"linux\"))]\n+#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n macro_rules! syscall {\n     (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n         unsafe fn $name($($arg_name: $t),*) -> $ret {\n@@ -84,18 +118,26 @@ macro_rules! syscall {\n     )\n }\n \n-#[cfg(target_os = \"linux\")]\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n macro_rules! syscall {\n     (fn $name:ident($($arg_name:ident: $t:ty),*) -> $ret:ty) => (\n         unsafe fn $name($($arg_name:$t),*) -> $ret {\n             // This looks like a hack, but concat_idents only accepts idents\n             // (not paths).\n             use libc::*;\n \n-            syscall(\n-                concat_idents!(SYS_, $name),\n-                $($arg_name as c_long),*\n-            ) as $ret\n+            weak! { fn $name($($t),*) -> $ret }\n+\n+            // Use a weak symbol from libc when possible, allowing `LD_PRELOAD`\n+            // interposition, but if it's not found just use a raw syscall.\n+            if let Some(fun) = $name.get() {\n+                fun($($arg_name),*)\n+            } else {\n+                syscall(\n+                    concat_idents!(SYS_, $name),\n+                    $($arg_name as c_long),*\n+                ) as $ret\n+            }\n         }\n     )\n }"}, {"sha": "61a04c467224b620baf44cda66dc6363bb494326", "filename": "library/std/tests/run-time-detect.rs", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Ftests%2Frun-time-detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/library%2Fstd%2Ftests%2Frun-time-detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Frun-time-detect.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -54,42 +54,62 @@ fn powerpc64_linux() {\n #[test]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n fn x86_all() {\n+    // the below is the set of features we can test at runtime, but don't actually\n+    // use to gate anything and are thus not part of the X86_ALLOWED_FEATURES list\n+\n+    println!(\"abm: {:?}\", is_x86_feature_detected!(\"abm\")); // this is a synonym for lzcnt but we test it anyways\n+    println!(\"mmx: {:?}\", is_x86_feature_detected!(\"mmx\"));\n+    println!(\"tsc: {:?}\", is_x86_feature_detected!(\"tsc\"));\n+\n+    // the below is in alphabetical order and matches\n+    // the order of X86_ALLOWED_FEATURES in rustc_codegen_ssa's target_features.rs\n+\n+    println!(\"adx: {:?}\", is_x86_feature_detected!(\"adx\"));\n     println!(\"aes: {:?}\", is_x86_feature_detected!(\"aes\"));\n-    println!(\"pcmulqdq: {:?}\", is_x86_feature_detected!(\"pclmulqdq\"));\n+    println!(\"avx: {:?}\", is_x86_feature_detected!(\"avx\"));\n+    println!(\"avx2: {:?}\", is_x86_feature_detected!(\"avx2\"));\n+    println!(\"avx512bf16: {:?}\", is_x86_feature_detected!(\"avx512bf16\"));\n+    println!(\"avx512bitalg: {:?}\", is_x86_feature_detected!(\"avx512bitalg\"));\n+    println!(\"avx512bw: {:?}\", is_x86_feature_detected!(\"avx512bw\"));\n+    println!(\"avx512cd: {:?}\", is_x86_feature_detected!(\"avx512cd\"));\n+    println!(\"avx512dq: {:?}\", is_x86_feature_detected!(\"avx512dq\"));\n+    println!(\"avx512er: {:?}\", is_x86_feature_detected!(\"avx512er\"));\n+    println!(\"avx512f: {:?}\", is_x86_feature_detected!(\"avx512f\"));\n+    println!(\"avx512gfni: {:?}\", is_x86_feature_detected!(\"avx512gfni\"));\n+    println!(\"avx512ifma: {:?}\", is_x86_feature_detected!(\"avx512ifma\"));\n+    println!(\"avx512pf: {:?}\", is_x86_feature_detected!(\"avx512pf\"));\n+    println!(\"avx512vaes: {:?}\", is_x86_feature_detected!(\"avx512vaes\"));\n+    println!(\"avx512vbmi: {:?}\", is_x86_feature_detected!(\"avx512vbmi\"));\n+    println!(\"avx512vbmi2: {:?}\", is_x86_feature_detected!(\"avx512vbmi2\"));\n+    println!(\"avx512vl: {:?}\", is_x86_feature_detected!(\"avx512vl\"));\n+    println!(\"avx512vnni: {:?}\", is_x86_feature_detected!(\"avx512vnni\"));\n+    println!(\"avx512vp2intersect: {:?}\", is_x86_feature_detected!(\"avx512vp2intersect\"));\n+    println!(\"avx512vpclmulqdq: {:?}\", is_x86_feature_detected!(\"avx512vpclmulqdq\"));\n+    println!(\"avx512vpopcntdq: {:?}\", is_x86_feature_detected!(\"avx512vpopcntdq\"));\n+    println!(\"bmi1: {:?}\", is_x86_feature_detected!(\"bmi1\"));\n+    println!(\"bmi2: {:?}\", is_x86_feature_detected!(\"bmi2\"));\n+    println!(\"cmpxchg16b: {:?}\", is_x86_feature_detected!(\"cmpxchg16b\"));\n+    println!(\"f16c: {:?}\", is_x86_feature_detected!(\"f16c\"));\n+    println!(\"fma: {:?}\", is_x86_feature_detected!(\"fma\"));\n+    println!(\"fxsr: {:?}\", is_x86_feature_detected!(\"fxsr\"));\n+    println!(\"lzcnt: {:?}\", is_x86_feature_detected!(\"lzcnt\"));\n+    //println!(\"movbe: {:?}\", is_x86_feature_detected!(\"movbe\")); // movbe is unsupported as a target feature\n+    println!(\"pclmulqdq: {:?}\", is_x86_feature_detected!(\"pclmulqdq\"));\n+    println!(\"popcnt: {:?}\", is_x86_feature_detected!(\"popcnt\"));\n     println!(\"rdrand: {:?}\", is_x86_feature_detected!(\"rdrand\"));\n     println!(\"rdseed: {:?}\", is_x86_feature_detected!(\"rdseed\"));\n-    println!(\"tsc: {:?}\", is_x86_feature_detected!(\"tsc\"));\n-    println!(\"mmx: {:?}\", is_x86_feature_detected!(\"mmx\"));\n+    println!(\"rtm: {:?}\", is_x86_feature_detected!(\"rtm\"));\n+    println!(\"sha: {:?}\", is_x86_feature_detected!(\"sha\"));\n     println!(\"sse: {:?}\", is_x86_feature_detected!(\"sse\"));\n     println!(\"sse2: {:?}\", is_x86_feature_detected!(\"sse2\"));\n     println!(\"sse3: {:?}\", is_x86_feature_detected!(\"sse3\"));\n-    println!(\"ssse3: {:?}\", is_x86_feature_detected!(\"ssse3\"));\n     println!(\"sse4.1: {:?}\", is_x86_feature_detected!(\"sse4.1\"));\n     println!(\"sse4.2: {:?}\", is_x86_feature_detected!(\"sse4.2\"));\n     println!(\"sse4a: {:?}\", is_x86_feature_detected!(\"sse4a\"));\n-    println!(\"sha: {:?}\", is_x86_feature_detected!(\"sha\"));\n-    println!(\"avx: {:?}\", is_x86_feature_detected!(\"avx\"));\n-    println!(\"avx2: {:?}\", is_x86_feature_detected!(\"avx2\"));\n-    println!(\"avx512f {:?}\", is_x86_feature_detected!(\"avx512f\"));\n-    println!(\"avx512cd {:?}\", is_x86_feature_detected!(\"avx512cd\"));\n-    println!(\"avx512er {:?}\", is_x86_feature_detected!(\"avx512er\"));\n-    println!(\"avx512pf {:?}\", is_x86_feature_detected!(\"avx512pf\"));\n-    println!(\"avx512bw {:?}\", is_x86_feature_detected!(\"avx512bw\"));\n-    println!(\"avx512dq {:?}\", is_x86_feature_detected!(\"avx512dq\"));\n-    println!(\"avx512vl {:?}\", is_x86_feature_detected!(\"avx512vl\"));\n-    println!(\"avx512_ifma {:?}\", is_x86_feature_detected!(\"avx512ifma\"));\n-    println!(\"avx512_vbmi {:?}\", is_x86_feature_detected!(\"avx512vbmi\"));\n-    println!(\"avx512_vpopcntdq {:?}\", is_x86_feature_detected!(\"avx512vpopcntdq\"));\n-    println!(\"fma: {:?}\", is_x86_feature_detected!(\"fma\"));\n-    println!(\"bmi1: {:?}\", is_x86_feature_detected!(\"bmi1\"));\n-    println!(\"bmi2: {:?}\", is_x86_feature_detected!(\"bmi2\"));\n-    println!(\"abm: {:?}\", is_x86_feature_detected!(\"abm\"));\n-    println!(\"lzcnt: {:?}\", is_x86_feature_detected!(\"lzcnt\"));\n+    println!(\"ssse3: {:?}\", is_x86_feature_detected!(\"ssse3\"));\n     println!(\"tbm: {:?}\", is_x86_feature_detected!(\"tbm\"));\n-    println!(\"popcnt: {:?}\", is_x86_feature_detected!(\"popcnt\"));\n-    println!(\"fxsr: {:?}\", is_x86_feature_detected!(\"fxsr\"));\n     println!(\"xsave: {:?}\", is_x86_feature_detected!(\"xsave\"));\n+    println!(\"xsavec: {:?}\", is_x86_feature_detected!(\"xsavec\"));\n     println!(\"xsaveopt: {:?}\", is_x86_feature_detected!(\"xsaveopt\"));\n     println!(\"xsaves: {:?}\", is_x86_feature_detected!(\"xsaves\"));\n-    println!(\"xsavec: {:?}\", is_x86_feature_detected!(\"xsavec\"));\n }"}, {"sha": "777efaf5644706b36706a7a5c51edb63835e05ca", "filename": "library/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstdarch?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1 +1 @@\n-Subproject commit 3c3664355ef46e788b53080e521d6542fbddfd84\n+Subproject commit 777efaf5644706b36706a7a5c51edb63835e05ca"}, {"sha": "4fb58034ce2166ceb061f83a25365213eb1538db", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -360,7 +360,6 @@ def output(filepath):\n class RustBuild(object):\n     \"\"\"Provide all the methods required to build Rust\"\"\"\n     def __init__(self):\n-        self.cargo_channel = ''\n         self.date = ''\n         self._download_url = ''\n         self.rustc_channel = ''\n@@ -387,7 +386,6 @@ def download_stage0(self):\n         will move all the content to the right place.\n         \"\"\"\n         rustc_channel = self.rustc_channel\n-        cargo_channel = self.cargo_channel\n         rustfmt_channel = self.rustfmt_channel\n \n         if self.rustc().startswith(self.bin_root()) and \\\n@@ -400,30 +398,22 @@ def download_stage0(self):\n                 rustc_channel, self.build, tarball_suffix)\n             pattern = \"rust-std-{}\".format(self.build)\n             self._download_stage0_helper(filename, pattern, tarball_suffix)\n-\n             filename = \"rustc-{}-{}{}\".format(rustc_channel, self.build,\n                                               tarball_suffix)\n             self._download_stage0_helper(filename, \"rustc\", tarball_suffix)\n+            filename = \"cargo-{}-{}{}\".format(rustc_channel, self.build,\n+                                              tarball_suffix)\n+            self._download_stage0_helper(filename, \"cargo\", tarball_suffix)\n             self.fix_bin_or_dylib(\"{}/bin/rustc\".format(self.bin_root()))\n             self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(self.bin_root()))\n+            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(self.bin_root()))\n             lib_dir = \"{}/lib\".format(self.bin_root())\n             for lib in os.listdir(lib_dir):\n                 if lib.endswith(\".so\"):\n                     self.fix_bin_or_dylib(\"{}/{}\".format(lib_dir, lib))\n             with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(self.date)\n \n-        if self.cargo().startswith(self.bin_root()) and \\\n-                (not os.path.exists(self.cargo()) or\n-                 self.program_out_of_date(self.cargo_stamp())):\n-            tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n-            filename = \"cargo-{}-{}{}\".format(cargo_channel, self.build,\n-                                              tarball_suffix)\n-            self._download_stage0_helper(filename, \"cargo\", tarball_suffix)\n-            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(self.bin_root()))\n-            with output(self.cargo_stamp()) as cargo_stamp:\n-                cargo_stamp.write(self.date)\n-\n         if self.rustfmt() and self.rustfmt().startswith(self.bin_root()) and (\n             not os.path.exists(self.rustfmt())\n             or self.program_out_of_date(self.rustfmt_stamp(), self.rustfmt_channel)\n@@ -601,16 +591,6 @@ def rustc_stamp(self):\n         \"\"\"\n         return os.path.join(self.bin_root(), '.rustc-stamp')\n \n-    def cargo_stamp(self):\n-        \"\"\"Return the path for .cargo-stamp\n-\n-        >>> rb = RustBuild()\n-        >>> rb.build_dir = \"build\"\n-        >>> rb.cargo_stamp() == os.path.join(\"build\", \"stage0\", \".cargo-stamp\")\n-        True\n-        \"\"\"\n-        return os.path.join(self.bin_root(), '.cargo-stamp')\n-\n     def rustfmt_stamp(self):\n         \"\"\"Return the path for .rustfmt-stamp\n \n@@ -1056,7 +1036,6 @@ def bootstrap(help_triggered):\n     data = stage0_data(build.rust_root)\n     build.date = data['date']\n     build.rustc_channel = data['rustc']\n-    build.cargo_channel = data['cargo']\n \n     if \"rustfmt\" in data:\n         build.rustfmt_channel = data['rustfmt']"}, {"sha": "dae9d219b7b9be9bb41a3682d791d2c55eb4e004", "filename": "src/stage0.txt", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,20 +1,19 @@\n # This file describes the stage0 compiler that's used to then bootstrap the Rust\n-# compiler itself. For the rustbuild build system, this also describes the\n-# relevant Cargo revision that we're using.\n+# compiler itself.\n #\n # Currently Rust always bootstraps from the previous stable release, and in our\n # train model this means that the master branch bootstraps from beta, beta\n # bootstraps from current stable, and stable bootstraps from the previous stable\n # release.\n #\n # If you're looking at this file on the master branch, you'll likely see that\n-# rustc and cargo are configured to `beta`, whereas if you're looking at a\n-# source tarball for a stable release you'll likely see `1.x.0` for rustc and\n-# `0.(x+1).0` for Cargo where they were released on `date`.\n+# rustc is configured to `beta`, whereas if you're looking at a source tarball\n+# for a stable release you'll likely see `1.x.0` for rustc, with the previous\n+# stable release's version number. `date` is the date where the release we're\n+# bootstrapping off was released.\n \n date: 2020-10-16\n rustc: beta\n-cargo: beta\n \n # We use a nightly rustfmt to format the source because it solves some\n # bootstrapping issues with use of new syntax in this repo. If you're looking at"}, {"sha": "541befa7b1310d2987f27c7e9c6286d54cebbe9d", "filename": "src/test/compile-fail/consts/issue-55878.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fcompile-fail%2Fconsts%2Fissue-55878.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fcompile-fail%2Fconsts%2Fissue-55878.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsts%2Fissue-55878.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,7 +1,7 @@\n // normalize-stderr-64bit \"18446744073709551615\" -> \"SIZE\"\n // normalize-stderr-32bit \"4294967295\" -> \"SIZE\"\n \n-// error-pattern: is too big for the current architecture\n+// error-pattern: are too big for the current architecture\n fn main() {\n     println!(\"Size: {}\", std::mem::size_of::<[u8; std::u64::MAX as usize]>());\n }"}, {"sha": "31e120df626de5b8f04f83ee2a29f17de7e7c977", "filename": "src/test/ui/huge-array-simple-32.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-array-simple-32.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-array-simple-32.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-array-simple-32.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `[u8; 2147516416]` is too big for the current architecture\n+error: values of the type `[u8; 2147516416]` are too big for the current architecture\n   --> $DIR/huge-array-simple-32.rs:10:9\n    |\n LL |     let _fat: [u8; (1<<31)+(1<<15)] ="}, {"sha": "c5d3fe85d0d83e668f70ee69e514aed049024b33", "filename": "src/test/ui/huge-array-simple-64.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-array-simple-64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-array-simple-64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-array-simple-64.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `[u8; 2305843011361177600]` is too big for the current architecture\n+error: values of the type `[u8; 2305843011361177600]` are too big for the current architecture\n   --> $DIR/huge-array-simple-64.rs:10:9\n    |\n LL |     let _fat: [u8; (1<<61)+(1<<31)] ="}, {"sha": "3070801f86576b283d6b3ae0ec7b4087885b576b", "filename": "src/test/ui/huge-array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-array.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -6,7 +6,7 @@\n \n fn generic<T: Copy>(t: T) {\n     let s: [T; 1518600000] = [t; 1518600000];\n-    //~^ ERROR the type `[[u8; 1518599999]; 1518600000]` is too big for the current architecture\n+    //~^ ERROR values of the type `[[u8; 1518599999]; 1518600000]` are too big\n }\n \n fn main() {"}, {"sha": "817458b73e47ba44df1b0286b4d9dddb23eef9f1", "filename": "src/test/ui/huge-array.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-array.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `[[u8; 1518599999]; 1518600000]` is too big for the current architecture\n+error: values of the type `[[u8; 1518599999]; 1518600000]` are too big for the current architecture\n   --> $DIR/huge-array.rs:8:9\n    |\n LL |     let s: [T; 1518600000] = [t; 1518600000];"}, {"sha": "39ea6e11b1ff7b379f81132d824a68374fa6a0ed", "filename": "src/test/ui/huge-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-enum.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -14,5 +14,5 @@ type BIG = Option<[u32; (1<<45)-1]>;\n \n fn main() {\n     let big: BIG = None;\n-    //~^ ERROR is too big for the current architecture\n+    //~^ ERROR are too big for the current architecture\n }"}, {"sha": "a1456e1a8ab0a7860d168eadf5d237b7e626144c", "filename": "src/test/ui/huge-enum.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-enum.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `Option<TYPE>` is too big for the current architecture\n+error: values of the type `Option<TYPE>` are too big for the current architecture\n   --> $DIR/huge-enum.rs:16:9\n    |\n LL |     let big: BIG = None;"}, {"sha": "02f38d860b4964dd4620fae3ef8660a83aa401ab", "filename": "src/test/ui/huge-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-struct.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -48,6 +48,6 @@ struct S1M<T> { val: S1k<S1k<T>> }\n \n fn main() {\n     let fat: Option<S1M<S1M<S1M<u32>>>> = None;\n-    //~^ ERROR is too big for the current architecture\n+    //~^ ERROR are too big for the current architecture\n \n }"}, {"sha": "f0ee88e59553954d45c42321ac1090398f236441", "filename": "src/test/ui/huge-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fhuge-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-struct.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `SXX<SXX<SXX<u32>>>` is too big for the current architecture\n+error: values of the type `SXX<SXX<SXX<u32>>>` are too big for the current architecture\n   --> $DIR/huge-struct.rs:50:9\n    |\n LL |     let fat: Option<SXX<SXX<SXX<u32>>>> = None;"}, {"sha": "133637f9a058be0ebadf393bc84a213d5b20bec9", "filename": "src/test/ui/issues/issue-15919-32.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-15919-32.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-15919-32.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15919-32.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `[usize; 4294967295]` is too big for the current architecture\n+error: values of the type `[usize; 4294967295]` are too big for the current architecture\n   --> $DIR/issue-15919-32.rs:9:9\n    |\n LL |     let x = [0usize; 0xffff_ffff];"}, {"sha": "193b823035c09951f1dd62db96258251e5c8c5ee", "filename": "src/test/ui/issues/issue-15919-64.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-15919-64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-15919-64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15919-64.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `[usize; 18446744073709551615]` is too big for the current architecture\n+error: values of the type `[usize; 18446744073709551615]` are too big for the current architecture\n   --> $DIR/issue-15919-64.rs:9:9\n    |\n LL |     let x = [0usize; 0xffff_ffff_ffff_ffff];"}, {"sha": "9a6431d44700492cb0ecdb9b63bb9b7bfc4506c6", "filename": "src/test/ui/issues/issue-17913.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-17913.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-17913.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17913.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `[&usize; N]` is too big for the current architecture\n+error: values of the type `[&usize; N]` are too big for the current architecture\n \n error: aborting due to previous error\n "}, {"sha": "fb0a270f18befb66d03425b1a3725661b4d5a76a", "filename": "src/test/ui/issues/issue-56762.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-56762.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-56762.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56762.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -17,8 +17,8 @@ impl TooBigArray {\n }\n \n static MY_TOO_BIG_ARRAY_1: TooBigArray = TooBigArray::new();\n-//~^ ERROR the type `[u8; 2305843009213693951]` is too big for the current architecture\n+//~^ ERROR values of the type `[u8; 2305843009213693951]` are too big\n static MY_TOO_BIG_ARRAY_2: [u8; HUGE_SIZE] = [0x00; HUGE_SIZE];\n-//~^ ERROR the type `[u8; 2305843009213693951]` is too big for the current architecture\n+//~^ ERROR values of the type `[u8; 2305843009213693951]` are too big\n \n fn main() { }"}, {"sha": "f26ef280b20b78e76742335f7a92029b1e0d1413", "filename": "src/test/ui/issues/issue-56762.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-56762.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Fissues%2Fissue-56762.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56762.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,10 +1,10 @@\n-error[E0080]: the type `[u8; 2305843009213693951]` is too big for the current architecture\n+error[E0080]: values of the type `[u8; 2305843009213693951]` are too big for the current architecture\n   --> $DIR/issue-56762.rs:19:1\n    |\n LL | static MY_TOO_BIG_ARRAY_1: TooBigArray = TooBigArray::new();\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0080]: the type `[u8; 2305843009213693951]` is too big for the current architecture\n+error[E0080]: values of the type `[u8; 2305843009213693951]` are too big for the current architecture\n   --> $DIR/issue-56762.rs:21:1\n    |\n LL | static MY_TOO_BIG_ARRAY_2: [u8; HUGE_SIZE] = [0x00; HUGE_SIZE];"}, {"sha": "af8191a9cb919614c8be3be2ca9a4ff0f64e99fe", "filename": "src/test/ui/layout/big-type-no-err.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flayout%2Fbig-type-no-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flayout%2Fbig-type-no-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fbig-type-no-err.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -0,0 +1,13 @@\n+// Enormous types are allowed if they are never actually instantiated.\n+// run-pass\n+trait Foo {\n+    type Assoc;\n+}\n+\n+impl Foo for [u16; usize::MAX] {\n+    type Assoc = u32;\n+}\n+\n+fn main() {\n+    let _a: Option<<[u16; usize::MAX] as Foo>::Assoc> = None;\n+}"}, {"sha": "a9c7ac363b0b31261b0993c550d84dc99c5badb7", "filename": "src/test/ui/lint/expansion-time.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flint%2Fexpansion-time.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flint%2Fexpansion-time.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fexpansion-time.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -12,6 +12,16 @@ mod benches {\n     fn foo() {}\n }\n \n+#[deprecated = \"reason\"]\n+macro_rules! deprecated {\n+    () => {}\n+}\n+\n+#[allow(deprecated)]\n+mod deprecated {\n+    deprecated!(); // No warning\n+}\n+\n #[warn(incomplete_include)]\n fn main() {\n     // WARN see in the stderr file, the warning points to the included file."}, {"sha": "24e2733064e48029f0be9f6eab9977db04e861b3", "filename": "src/test/ui/lint/expansion-time.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flint%2Fexpansion-time.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flint%2Fexpansion-time.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fexpansion-time.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -33,7 +33,7 @@ LL | 2\n    | ^\n    |\n note: the lint level is defined here\n-  --> $DIR/expansion-time.rs:15:8\n+  --> $DIR/expansion-time.rs:25:8\n    |\n LL | #[warn(incomplete_include)]\n    |        ^^^^^^^^^^^^^^^^^^"}, {"sha": "2560ffe168be55257e9df586143c99d7e831efed", "filename": "src/test/ui/lint/issue-69485-var-size-diffs-too-large.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -3,7 +3,7 @@\n // compile-flags: -Zmir-opt-level=0\n \n fn main() {\n-    Bug::V([0; !0]); //~ ERROR is too big for the current\n+    Bug::V([0; !0]); //~ ERROR are too big for the current\n }\n \n enum Bug {"}, {"sha": "c229458da47daabe37c9dd49650c3faa4d62404a", "filename": "src/test/ui/lint/issue-69485-var-size-diffs-too-large.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-69485-var-size-diffs-too-large.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-error: the type `[u8; 18446744073709551615]` is too big for the current architecture\n+error: values of the type `[u8; 18446744073709551615]` are too big for the current architecture\n   --> $DIR/issue-69485-var-size-diffs-too-large.rs:6:12\n    |\n LL |     Bug::V([0; !0]);"}, {"sha": "a2ccb0369c4a42c8dd25edae486b868f0d90deff", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,6 +1,5 @@\n use crate::consts::{constant, Constant};\n-use crate::utils::paths;\n-use crate::utils::{is_direct_expn_of, is_expn_of, match_function_call, snippet_opt, span_lint_and_help};\n+use crate::utils::{is_direct_expn_of, is_expn_of, match_panic_call, snippet_opt, span_lint_and_help};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_hir::{Expr, ExprKind, PatKind, UnOp};\n@@ -133,7 +132,7 @@ fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n         if let ExprKind::Block(ref inner_block, _) = block_expr.kind;\n         if let Some(begin_panic_call) = &inner_block.expr;\n         // function call\n-        if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n+        if let Some(args) = match_panic_call(cx, begin_panic_call);\n         if args.len() == 1;\n         // bind the second argument of the `assert!` macro if it exists\n         if let panic_message = snippet_opt(cx, args[0].span);"}, {"sha": "57702dafa6a0ce8a878102a15443db90afdea860", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,7 +1,7 @@\n //! checks for attributes\n \n use crate::utils::{\n-    first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_help,\n+    first_line_of_span, is_present_in_source, match_panic_def_id, snippet_opt, span_lint, span_lint_and_help,\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n@@ -513,7 +513,7 @@ fn is_relevant_expr(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>\n                 typeck_results\n                     .qpath_res(qpath, path_expr.hir_id)\n                     .opt_def_id()\n-                    .map_or(true, |fun_id| !match_def_path(cx, fun_id, &paths::BEGIN_PANIC))\n+                    .map_or(true, |fun_id| !match_panic_def_id(cx, fun_id))\n             } else {\n                 true\n             }"}, {"sha": "509a4a4e15f628162e78ba6bea9375af3d3c5e61", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,5 +1,7 @@\n-use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT};\n-use crate::utils::{is_expn_of, is_type_diagnostic_item, match_def_path, method_chain_args, span_lint_and_then};\n+use crate::utils::paths::FROM_TRAIT;\n+use crate::utils::{\n+    is_expn_of, is_type_diagnostic_item, match_def_path, match_panic_def_id, method_chain_args, span_lint_and_then,\n+};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -84,8 +86,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n                 if let ExprKind::Call(ref func_expr, _) = expr.kind;\n                 if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.kind;\n                 if let Some(path_def_id) = path.res.opt_def_id();\n-                if match_def_path(self.lcx, path_def_id, &BEGIN_PANIC) ||\n-                    match_def_path(self.lcx, path_def_id, &BEGIN_PANIC_FMT);\n+                if match_panic_def_id(self.lcx, path_def_id);\n                 if is_expn_of(expr.span, \"unreachable\").is_none();\n                 then {\n                     self.result.push(expr.span);"}, {"sha": "ed7f3b9293dbf856904e597ba09e7e16012fa396", "filename": "src/tools/clippy/clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,8 +1,4 @@\n-use crate::utils::{\n-    fn_has_unsatisfiable_preds, match_def_path,\n-    paths::{BEGIN_PANIC, BEGIN_PANIC_FMT},\n-    snippet_opt, span_lint_and_then,\n-};\n+use crate::utils::{fn_has_unsatisfiable_preds, match_panic_def_id, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -109,8 +105,7 @@ fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             if_chain! {\n                 if let ExprKind::Path(qpath) = &expr.kind;\n                 if let Some(path_def_id) = cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n-                if match_def_path(cx, path_def_id, &BEGIN_PANIC) ||\n-                    match_def_path(cx, path_def_id, &BEGIN_PANIC_FMT);\n+                if match_panic_def_id(cx, path_def_id);\n                 then { }\n                 else {\n                     lint(cx, expr.span, expr.span, LINT_RETURN)"}, {"sha": "3d888fe73257322453792f913648a410f0c51912", "filename": "src/tools/clippy/clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_direct_expn_of, is_expn_of, match_function_call, paths, span_lint};\n+use crate::utils::{is_direct_expn_of, is_expn_of, match_panic_call, span_lint};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_hir::{Expr, ExprKind};\n@@ -93,27 +93,27 @@ declare_lint_pass!(PanicUnimplemented => [PANIC_PARAMS, UNIMPLEMENTED, UNREACHAB\n \n impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Block(ref block, _) = expr.kind;\n-            if let Some(ref ex) = block.expr;\n-            if let Some(params) = match_function_call(cx, ex, &paths::BEGIN_PANIC)\n-                .or_else(|| match_function_call(cx, ex, &paths::BEGIN_PANIC_FMT));\n-            then {\n-                let span = get_outer_span(expr);\n-                if is_expn_of(expr.span, \"unimplemented\").is_some() {\n-                    span_lint(cx, UNIMPLEMENTED, span,\n-                              \"`unimplemented` should not be present in production code\");\n-                } else if is_expn_of(expr.span, \"todo\").is_some() {\n-                    span_lint(cx, TODO, span,\n-                              \"`todo` should not be present in production code\");\n-                } else if is_expn_of(expr.span, \"unreachable\").is_some() {\n-                    span_lint(cx, UNREACHABLE, span,\n-                              \"`unreachable` should not be present in production code\");\n-                } else if is_expn_of(expr.span, \"panic\").is_some() {\n-                    span_lint(cx, PANIC, span,\n-                              \"`panic` should not be present in production code\");\n-                    match_panic(params, expr, cx);\n-                }\n+        if let Some(params) = match_panic_call(cx, expr) {\n+            let span = get_outer_span(expr);\n+            if is_expn_of(expr.span, \"unimplemented\").is_some() {\n+                span_lint(\n+                    cx,\n+                    UNIMPLEMENTED,\n+                    span,\n+                    \"`unimplemented` should not be present in production code\",\n+                );\n+            } else if is_expn_of(expr.span, \"todo\").is_some() {\n+                span_lint(cx, TODO, span, \"`todo` should not be present in production code\");\n+            } else if is_expn_of(expr.span, \"unreachable\").is_some() {\n+                span_lint(\n+                    cx,\n+                    UNREACHABLE,\n+                    span,\n+                    \"`unreachable` should not be present in production code\",\n+                );\n+            } else if is_expn_of(expr.span, \"panic\").is_some() {\n+                span_lint(cx, PANIC, span, \"`panic` should not be present in production code\");\n+                match_panic(params, expr, cx);\n             }\n         }\n     }"}, {"sha": "270fdc9bf462f6750621c2d83929528d7e933f30", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1196,7 +1196,7 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n /// Usage:\n ///\n /// ```rust,ignore\n-/// if let Some(args) = match_function_call(cx, begin_panic_call, &paths::BEGIN_PANIC);\n+/// if let Some(args) = match_function_call(cx, cmp_max_call, &paths::CMP_MAX);\n /// ```\n pub fn match_function_call<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -1231,6 +1231,24 @@ pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -\n     cx.match_def_path(did, &syms)\n }\n \n+pub fn match_panic_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx [Expr<'tcx>]> {\n+    match_function_call(cx, expr, &paths::BEGIN_PANIC)\n+        .or_else(|| match_function_call(cx, expr, &paths::BEGIN_PANIC_FMT))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANIC_ANY))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_FMT))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_STR))\n+}\n+\n+pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n+    match_def_path(cx, did, &paths::BEGIN_PANIC)\n+        || match_def_path(cx, did, &paths::BEGIN_PANIC_FMT)\n+        || match_def_path(cx, did, &paths::PANIC_ANY)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC_FMT)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC_STR)\n+}\n+\n /// Returns the list of condition expressions and the list of blocks in a\n /// sequence of `if/else`.\n /// E.g., this returns `([a, b], [c, d, e])` for the expression"}, {"sha": "8f5fbfd9f846a5706a3a3e2cec2a5eb98c5854a3", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -8,8 +8,8 @@ pub const ANY_TRAIT: [&str; 3] = [\"std\", \"any\", \"Any\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n-pub const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n-pub const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_fmt\"];\n+pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n+pub(super) const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_fmt\"];\n pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BOX: [&str; 3] = [\"alloc\", \"boxed\", \"Box\"];\n@@ -78,6 +78,10 @@ pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING: [&str; 4] = [\"std\", \"ffi\", \"os_str\", \"OsString\"];\n pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\", \"as_os_str\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n+pub(super) const PANICKING_PANIC: [&str; 3] = [\"core\", \"panicking\", \"panic\"];\n+pub(super) const PANICKING_PANIC_FMT: [&str; 3] = [\"core\", \"panicking\", \"panic_fmt\"];\n+pub(super) const PANICKING_PANIC_STR: [&str; 3] = [\"core\", \"panicking\", \"panic_str\"];\n+pub(super) const PANIC_ANY: [&str; 3] = [\"std\", \"panic\", \"panic_any\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];"}, {"sha": "77fcb8dfd02fd7460fd097e3c06570cb3cb41cc8", "filename": "src/tools/clippy/tests/ui/panicking_macros.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.rs?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,6 +1,8 @@\n #![warn(clippy::unimplemented, clippy::unreachable, clippy::todo, clippy::panic)]\n #![allow(clippy::assertions_on_constants)]\n \n+extern crate core;\n+\n fn panic() {\n     let a = 2;\n     panic!();\n@@ -33,9 +35,18 @@ fn unreachable() {\n     let b = a + 2;\n }\n \n+fn core_versions() {\n+    use core::{panic, todo, unimplemented, unreachable};\n+    panic!();\n+    todo!();\n+    unimplemented!();\n+    unreachable!();\n+}\n+\n fn main() {\n     panic();\n     todo();\n     unimplemented();\n     unreachable();\n+    core_versions();\n }"}, {"sha": "83234c0ed92cc4fc93a53e30d2e22aa1f36d9bdb", "filename": "src/tools/clippy/tests/ui/panicking_macros.stderr", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2d0014922e9f541694bfe87642749239990e0e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.stderr?ref=8d2d0014922e9f541694bfe87642749239990e0e", "patch": "@@ -1,88 +1,112 @@\n error: `panic` should not be present in production code\n-  --> $DIR/panicking_macros.rs:6:5\n+  --> $DIR/panicking_macros.rs:8:5\n    |\n LL |     panic!();\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::panic` implied by `-D warnings`\n \n error: `panic` should not be present in production code\n-  --> $DIR/panicking_macros.rs:7:5\n+  --> $DIR/panicking_macros.rs:9:5\n    |\n LL |     panic!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `panic` should not be present in production code\n-  --> $DIR/panicking_macros.rs:8:5\n+  --> $DIR/panicking_macros.rs:10:5\n    |\n LL |     panic!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `todo` should not be present in production code\n-  --> $DIR/panicking_macros.rs:14:5\n+  --> $DIR/panicking_macros.rs:16:5\n    |\n LL |     todo!();\n    |     ^^^^^^^^\n    |\n    = note: `-D clippy::todo` implied by `-D warnings`\n \n error: `todo` should not be present in production code\n-  --> $DIR/panicking_macros.rs:15:5\n+  --> $DIR/panicking_macros.rs:17:5\n    |\n LL |     todo!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^\n \n error: `todo` should not be present in production code\n-  --> $DIR/panicking_macros.rs:16:5\n+  --> $DIR/panicking_macros.rs:18:5\n    |\n LL |     todo!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `unimplemented` should not be present in production code\n-  --> $DIR/panicking_macros.rs:22:5\n+  --> $DIR/panicking_macros.rs:24:5\n    |\n LL |     unimplemented!();\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unimplemented` implied by `-D warnings`\n \n error: `unimplemented` should not be present in production code\n-  --> $DIR/panicking_macros.rs:23:5\n+  --> $DIR/panicking_macros.rs:25:5\n    |\n LL |     unimplemented!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `unimplemented` should not be present in production code\n-  --> $DIR/panicking_macros.rs:24:5\n+  --> $DIR/panicking_macros.rs:26:5\n    |\n LL |     unimplemented!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `unreachable` should not be present in production code\n-  --> $DIR/panicking_macros.rs:30:5\n+  --> $DIR/panicking_macros.rs:32:5\n    |\n LL |     unreachable!();\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unreachable` implied by `-D warnings`\n \n error: `unreachable` should not be present in production code\n-  --> $DIR/panicking_macros.rs:31:5\n+  --> $DIR/panicking_macros.rs:33:5\n    |\n LL |     unreachable!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unreachable` should not be present in production code\n-  --> $DIR/panicking_macros.rs:32:5\n+  --> $DIR/panicking_macros.rs:34:5\n    |\n LL |     unreachable!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: `panic` should not be present in production code\n+  --> $DIR/panicking_macros.rs:40:5\n+   |\n+LL |     panic!();\n+   |     ^^^^^^^^^\n+\n+error: `todo` should not be present in production code\n+  --> $DIR/panicking_macros.rs:41:5\n+   |\n+LL |     todo!();\n+   |     ^^^^^^^^\n+\n+error: `unimplemented` should not be present in production code\n+  --> $DIR/panicking_macros.rs:42:5\n+   |\n+LL |     unimplemented!();\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: `unreachable` should not be present in production code\n+  --> $DIR/panicking_macros.rs:43:5\n+   |\n+LL |     unreachable!();\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: aborting due to 16 previous errors\n "}]}