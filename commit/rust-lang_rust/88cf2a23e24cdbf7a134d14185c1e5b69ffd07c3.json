{"sha": "88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Y2YyYTIzZTI0Y2RiZjdhMTM0ZDE0MTg1YzFlNWI2OWZmZDA3YzM=", "commit": {"author": {"name": "David Herrmann", "email": "dh.herrmann@gmail.com", "date": "2018-12-13T09:08:20Z"}, "committer": {"name": "David Herrmann", "email": "dh.herrmann@gmail.com", "date": "2018-12-13T09:08:20Z"}, "message": "Add x86_64-unknown-uefi target\n\nThis adds a new rustc target-configuration called 'x86_64-unknown_uefi'.\nFurthermore, it adds a UEFI base-configuration to be used with other\ntargets supported by UEFI (e.g., i386, armv7hl, aarch64, itanium, ...).\n\nUEFI systems provide a very basic operating-system environment, meant\nto unify how systems are booted. It is tailored for simplicity and fast\nsetup, as it is only meant to bootstrap other systems. For instance, it\ncopies most of the ABI from Microsoft Windows, rather than inventing\nanything on its own. Furthermore, any complex CPU features are\ndisabled. Only one CPU is allowed to be up, no interrupts other than\nthe timer-interrupt are allowed, no process-separation is performed,\npage-tables are identity-mapped, ...\n\nNevertheless, UEFI has an application model. Its main purpose is to\nallow operating-system vendors to write small UEFI applications that\nload their kernel and terminate the UEFI system. However, many other\nUEFI applications have emerged in the past, including network-boot,\ndebug-consoles, and more.\n\nThis UEFI target allows to compile rust code natively as UEFI\napplications. No standard library support is added, but libcore can be\nused out-of-the-box if a panic-handler is provided. Furthermore,\nliballoc works as well, if a `GlobalAlloc` handler is provided. Both\nhave been tested with this target-configuration.\n\nNote that full libstd support is unlikely to happen. While UEFI does\nhave standardized interfaces for networking and alike, none of these\nare mandatory and they are unlikely to be shipped in common consumer\nfirmwares. Furthermore, several features like process-separation are\nnot available (or only in very limited fashion). Those parts of libstd\nwould have to be masked.", "tree": {"sha": "277fd0ebb36fb8e9bfcd30adef878f98ad9801de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/277fd0ebb36fb8e9bfcd30adef878f98ad9801de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3", "html_url": "https://github.com/rust-lang/rust/commit/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3/comments", "author": null, "committer": null, "parents": [{"sha": "3a3121337122637fa11f0e5d42aec67551e8c125", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a3121337122637fa11f0e5d42aec67551e8c125", "html_url": "https://github.com/rust-lang/rust/commit/3a3121337122637fa11f0e5d42aec67551e8c125"}], "stats": {"total": 135, "additions": 135, "deletions": 0}, "files": [{"sha": "f29108c0f97c5ee35ce4dac7d1e1a5e2316cdaa8", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3", "patch": "@@ -68,6 +68,7 @@ mod linux_musl_base;\n mod openbsd_base;\n mod netbsd_base;\n mod solaris_base;\n+mod uefi_base;\n mod windows_base;\n mod windows_msvc_base;\n mod thumb_base;\n@@ -419,6 +420,8 @@ supported_targets! {\n     (\"aarch64-unknown-none\", aarch64_unknown_none),\n \n     (\"x86_64-fortanix-unknown-sgx\", x86_64_fortanix_unknown_sgx),\n+\n+    (\"x86_64-unknown-uefi\", x86_64_unknown_uefi),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target."}, {"sha": "9b0515837600be9a3b76bae61f096d50120a1819", "filename": "src/librustc_target/spec/uefi_base.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fuefi_base.rs?ref=88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This defines a base target-configuration for native UEFI systems. The UEFI specification has\n+// quite detailed sections on the ABI of all the supported target architectures. In almost all\n+// cases it simply follows what Microsoft Windows does. Hence, whenever in doubt, see the MSDN\n+// documentation.\n+// UEFI uses COFF/PE32+ format for binaries. All binaries must be statically linked. No dynamic\n+// linker is supported. As native to COFF, binaries are position-dependent, but will be relocated\n+// by the loader if the pre-chosen memory location is already in use.\n+// UEFI forbids running code on anything but the boot-CPU. Not interrupts are allowed other than\n+// the timer-interrupt. Device-drivers are required to use polling-based models. Furthermore, all\n+// code runs in the same environment, no process separation is supported.\n+\n+use spec::{LinkArgs, LinkerFlavor, LldFlavor, PanicStrategy, TargetOptions};\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut pre_link_args = LinkArgs::new();\n+\n+    pre_link_args.insert(LinkerFlavor::Lld(LldFlavor::Link), vec![\n+            // Suppress the verbose logo and authorship debugging output, which would needlessly\n+            // clog any log files.\n+            \"/NOLOGO\".to_string(),\n+\n+            // UEFI is fully compatible to non-executable data pages. Tell the compiler that\n+            // non-code sections can be marked as non-executable, including stack pages.\n+            \"/NXCOMPAT\".to_string(),\n+\n+            // There is no runtime for UEFI targets, prevent them from being linked. UEFI targets\n+            // must be freestanding.\n+            \"/nodefaultlib\".to_string(),\n+\n+            // Non-standard subsystems have no default entry-point in PE+ files. We have to define\n+            // one. \"efi_main\" seems to be a common choice amongst other implementations and the\n+            // spec.\n+            \"/entry:efi_main\".to_string(),\n+\n+            // COFF images have a \"Subsystem\" field in their header, which defines what kind of\n+            // program it is. UEFI has 3 fields reserved, which are EFI_APPLICATION,\n+            // EFI_BOOT_SERVICE_DRIVER, and EFI_RUNTIME_DRIVER. We default to EFI_APPLICATION,\n+            // which is very likely the most common option. Individual projects can override this\n+            // with custom linker flags.\n+            // The subsystem-type only has minor effects on the application. It defines the memory\n+            // regions the application is loaded into (runtime-drivers need to be put into\n+            // reserved areas), as well as whether a return from the entry-point is treated as\n+            // exit (default for applications).\n+            \"/subsystem:efi_application\".to_string(),\n+        ]);\n+\n+    TargetOptions {\n+        dynamic_linking: false,\n+        executables: true,\n+        disable_redzone: true,\n+        exe_suffix: \".efi\".to_string(),\n+        allows_weak_linkage: false,\n+        panic_strategy: PanicStrategy::Abort,\n+        singlethread: true,\n+        emit_debug_gdb_scripts: false,\n+\n+        linker: Some(\"lld-link\".to_string()),\n+        lld_flavor: LldFlavor::Link,\n+        pre_link_args,\n+\n+        .. Default::default()\n+    }\n+}"}, {"sha": "ea68afa717335ebf23bd273d1efb72cf9e9ccef3", "filename": "src/librustc_target/spec/x86_64_unknown_uefi.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_uefi.rs?ref=88cf2a23e24cdbf7a134d14185c1e5b69ffd07c3", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This defines the amd64 target for UEFI systems as described in the UEFI specification. See the\n+// uefi-base module for generic UEFI options. On x86_64 systems (mostly called \"x64\" in the spec)\n+// UEFI systems always run in long-mode, have the interrupt-controller pre-configured and force a\n+// single-CPU execution.\n+// The win64 ABI is used. It differs from the sysv64 ABI, so we must use a windows target with\n+// LLVM. \"x86_64-unknown-windows\" is used to get the minimal subset of windows-specific features.\n+\n+use spec::{LinkerFlavor, LldFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::uefi_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+\n+    // We disable MMX and SSE for now. UEFI does not prevent these from being used, but there have\n+    // been reports to GRUB that some firmware does not initialize the FP exception handlers\n+    // properly. Therefore, using FP coprocessors will end you up at random memory locations when\n+    // you throw FP exceptions.\n+    // To be safe, we disable them for now and force soft-float. This can be revisited when we\n+    // have more test coverage. Disabling FP served GRUB well so far, so it should be good for us\n+    // as well.\n+    base.features = \"-mmx,-sse,+soft-float\".to_string();\n+\n+    // UEFI systems run without a host OS, hence we cannot assume any code locality. We must tell\n+    // LLVM to expect code to reference any address in the address-space. The \"large\" code-model\n+    // places no locality-restrictions, so it fits well here.\n+    base.code_model = Some(\"large\".to_string());\n+\n+    // UEFI mostly mirrors the calling-conventions used on windows. In case of x86-64 this means\n+    // small structs will be returned as int. This shouldn't matter much, since the restrictions\n+    // placed by the UEFI specifications forbid any ABI to return structures.\n+    base.abi_return_struct_as_int = true;\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-windows\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:w-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        target_os: \"uefi\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Link),\n+\n+        options: base,\n+    })\n+}"}]}