{"sha": "43ae38019167ef02e53cfc202df8b6be0f79c32d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYWUzODAxOTE2N2VmMDJlNTNjZmMyMDJkZjhiNmJlMGY3OWMzMmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-31T15:07:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-05T14:37:39Z"}, "message": "rustc: Flag some CrateStore methods as \"untracked\"\n\nThe main use of `CrateStore` *before* the `TyCtxt` is created is during\nresolution, but we want to be sure that any methods used before resolution are\nnot used after the `TyCtxt` is created. This commit starts moving the methods\nused by resolve to all be named `{name}_untracked` where the rest of the\ncompiler uses just `{name}` as a query.\n\nDuring this transition a number of new queries were added to account for\npost-resolve usage of these methods.", "tree": {"sha": "df5a04c15b5911e2f71c2318946cb5e19ded157b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df5a04c15b5911e2f71c2318946cb5e19ded157b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43ae38019167ef02e53cfc202df8b6be0f79c32d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43ae38019167ef02e53cfc202df8b6be0f79c32d", "html_url": "https://github.com/rust-lang/rust/commit/43ae38019167ef02e53cfc202df8b6be0f79c32d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43ae38019167ef02e53cfc202df8b6be0f79c32d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd61fa5aef171e27209f1fad6388f730a64d61a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd61fa5aef171e27209f1fad6388f730a64d61a2", "html_url": "https://github.com/rust-lang/rust/commit/fd61fa5aef171e27209f1fad6388f730a64d61a2"}], "stats": {"total": 251, "additions": 152, "deletions": 99}, "files": [{"sha": "aa1a8726f9d00ce165570cb87ee35dd91f03f042", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -554,6 +554,12 @@ define_dep_nodes!( <'tcx>\n     [] NamedRegion(HirId),\n     [] IsLateBound(HirId),\n     [] ObjectLifetimeDefaults(HirId),\n+\n+    [] Visibility(DefId),\n+    [] DepKind(CrateNum),\n+    [] CrateName(CrateNum),\n+    [] ItemChildren(DefId),\n+    [] ExternModStmtCnum(HirId),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "ff52f1e4e39ff785cfc35f4efbbc5594d818aa7e", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -357,7 +357,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // for imported and non-imported crates\n                 if exp_path == found_path\n                 || exp_abs_path == found_abs_path {\n-                    let crate_name = self.tcx.sess.cstore.crate_name(did1.krate);\n+                    let crate_name = self.tcx.crate_name(did1.krate);\n                     err.span_note(sp, &format!(\"Perhaps two different versions \\\n                                                 of crate `{}` are being used?\",\n                                                crate_name));"}, {"sha": "61a923a5954be86178bde37da84fcaf1311d7664", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -222,37 +222,46 @@ pub trait MetadataLoader {\n \n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n+///\n+/// Note that this trait should probably not be expanding today. All new\n+/// functionality should be driven through queries instead!\n+///\n+/// If you find a method on this trait named `{name}_untracked` it signifies\n+/// that it's *not* tracked for dependency information throughout compilation\n+/// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n+/// during resolve)\n pub trait CrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n \n     // access to the metadata loader\n     fn metadata_loader(&self) -> &MetadataLoader;\n \n     // item info\n-    fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn visible_parent_map<'a>(&'a self, sess: &Session) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n \n     // trait/impl-item info\n     fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem;\n \n     // crate metadata\n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind;\n-    fn export_macros(&self, cnum: CrateNum);\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n-    /// The name of the crate as it is referred to in source code of the current\n-    /// crate.\n-    fn crate_name(&self, cnum: CrateNum) -> Symbol;\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n     fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable>;\n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n-    fn item_children(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n-    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n+\n+    // \"queries\" used in resolve that aren't tracked for incremental compilation\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility;\n+    fn export_macros_untracked(&self, cnum: CrateNum);\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind;\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>;\n+    fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n+    fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro;\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n \n     // misc. metadata\n     fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -265,7 +274,6 @@ pub trait CrateStore {\n     // utility functions\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n@@ -310,7 +318,7 @@ impl CrateStore for DummyCrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>\n         { bug!(\"crate_data_as_rc_any\") }\n     // item info\n-    fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n     fn visible_parent_map<'a>(&'a self, session: &Session)\n         -> ::std::cell::Ref<'a, DefIdMap<DefId>>\n     {\n@@ -328,9 +336,9 @@ impl CrateStore for DummyCrateStore {\n         { bug!(\"lang_items\") }\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n         { bug!(\"missing_lang_items\") }\n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n-    fn export_macros(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n-    fn crate_name(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n+    fn export_macros_untracked(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }\n@@ -343,11 +351,13 @@ impl CrateStore for DummyCrateStore {\n     fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable> {\n         bug!(\"def_path_table\")\n     }\n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n-    fn item_children(&self, did: DefId, sess: &Session) -> Vec<def::Export> {\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name> {\n+        bug!(\"struct_field_names\")\n+    }\n+    fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export> {\n         bug!(\"item_children\")\n     }\n-    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n+    fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n     fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -363,7 +373,7 @@ impl CrateStore for DummyCrateStore {\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,"}, {"sha": "a34ef099344bd812f7a74de55210d29b89374e2d", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -133,11 +133,11 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 return v;\n             }\n             for cnum in sess.cstore.crates() {\n-                if sess.cstore.dep_kind(cnum).macros_only() { continue }\n+                if tcx.dep_kind(cnum).macros_only() { continue }\n                 let src = sess.cstore.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n-                                  sess.cstore.crate_name(cnum)));\n+                                  tcx.crate_name(cnum)));\n             }\n             return Vec::new();\n         }\n@@ -166,17 +166,16 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n     for cnum in sess.cstore.crates() {\n-        if sess.cstore.dep_kind(cnum).macros_only() { continue }\n-        let name = sess.cstore.crate_name(cnum);\n+        if tcx.dep_kind(cnum).macros_only() { continue }\n+        let name = tcx.crate_name(cnum);\n         let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_some() {\n             info!(\"adding dylib: {}\", name);\n-            add_library(sess, cnum, RequireDynamic, &mut formats);\n+            add_library(tcx, cnum, RequireDynamic, &mut formats);\n             let deps = tcx.dylib_dependency_formats(cnum);\n             for &(depnum, style) in deps.iter() {\n-                info!(\"adding {:?}: {}\", style,\n-                      sess.cstore.crate_name(depnum));\n-                add_library(sess, depnum, style, &mut formats);\n+                info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n+                add_library(tcx, depnum, style, &mut formats);\n             }\n         }\n     }\n@@ -200,10 +199,10 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n-           sess.cstore.dep_kind(cnum) == DepKind::Explicit {\n+           tcx.dep_kind(cnum) == DepKind::Explicit {\n             assert!(src.rlib.is_some() || src.rmeta.is_some());\n-            info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n-            add_library(sess, cnum, RequireStatic, &mut formats);\n+            info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n+            add_library(tcx, cnum, RequireStatic, &mut formats);\n             ret[cnum.as_usize() - 1] = Linkage::Static;\n         }\n     }\n@@ -237,7 +236,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                let name = sess.cstore.crate_name(cnum);\n+                let name = tcx.crate_name(cnum);\n                 sess.err(&format!(\"crate `{}` required to be available in {}, \\\n                                   but it was not available in this form\",\n                                   name, kind));\n@@ -248,7 +247,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return ret;\n }\n \n-fn add_library(sess: &session::Session,\n+fn add_library(tcx: TyCtxt,\n                cnum: CrateNum,\n                link: LinkagePreference,\n                m: &mut FxHashMap<CrateNum, LinkagePreference>) {\n@@ -262,8 +261,8 @@ fn add_library(sess: &session::Session,\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n             if link2 != link || link == RequireStatic {\n-                sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                          shows up once\", sess.cstore.crate_name(cnum)))\n+                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n+                                              shows up once\", tcx.crate_name(cnum)))\n                     .help(\"having upstream crates all available in one format \\\n                            will likely make this go away\")\n                     .emit();\n@@ -284,7 +283,7 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n     // everything in explicitly so long as it's actually required.\n     let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -357,8 +356,8 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n \n         if tcx.is_panic_runtime(cnum) {\n             if let Some((prev, _)) = panic_runtime {\n-                let prev_name = sess.cstore.crate_name(prev);\n-                let cur_name = sess.cstore.crate_name(cnum);\n+                let prev_name = tcx.crate_name(prev);\n+                let cur_name = tcx.crate_name(cnum);\n                 sess.err(&format!(\"cannot link together two \\\n                                    panic runtimes: {} and {}\",\n                                   prev_name, cur_name));\n@@ -379,7 +378,7 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n             sess.err(&format!(\"the linked panic runtime `{}` is \\\n                                not compiled with this crate's \\\n                                panic strategy `{}`\",\n-                              sess.cstore.crate_name(cnum),\n+                              tcx.crate_name(cnum),\n                               desired_strategy.desc()));\n         }\n \n@@ -405,7 +404,7 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n                                panic strategy `{}` which is \\\n                                incompatible with this crate's \\\n                                strategy of `{}`\",\n-                              sess.cstore.crate_name(cnum),\n+                              tcx.crate_name(cnum),\n                               found_strategy.desc(),\n                               desired_strategy.desc()));\n         }"}, {"sha": "351daa198e8dc6cbba42c89787898b0f9c8403eb", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -179,15 +179,15 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n                         name),\n                     None => self.session.struct_err(&format!(\n                             \"duplicate lang item in crate `{}`: `{}`.\",\n-                            cstore.crate_name(item_def_id.krate),\n+                            cstore.crate_name_untracked(item_def_id.krate),\n                             name)),\n                 };\n                 if let Some(span) = self.hir_map.span_if_local(original_def_id) {\n                     span_note!(&mut err, span,\n                                \"first defined here.\");\n                 } else {\n                     err.note(&format!(\"first defined in crate `{}`.\",\n-                                      cstore.crate_name(original_def_id.krate)));\n+                                      cstore.crate_name_untracked(original_def_id.krate)));\n                 }\n                 err.emit();\n             }"}, {"sha": "6d7d028d286caafe954c66f4235d6fb0cb9b1324", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -476,7 +476,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        let visibility = self.sess.cstore.visibility(def_id);\n+        let visibility = self.visibility(def_id);\n \n         match visibility {\n             // must check stability for pub items.\n@@ -610,7 +610,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span == DUMMY_SP { return }\n \n-                let cnum = match self.tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(item.id);\n+                let cnum = match self.tcx.extern_mod_stmt_cnum(hir_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n                 };"}, {"sha": "dbd288c6f2d30767c849bcec8b70b28775eb07bf", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -909,14 +909,6 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: CrateNum) -> Symbol {\n-        if cnum == LOCAL_CRATE {\n-            self.crate_name\n-        } else {\n-            self.sess.cstore.crate_name(cnum)\n-        }\n-    }\n-\n     pub fn alloc_generics(self, generics: ty::Generics) -> &'gcx ty::Generics {\n         self.global_arenas.generics.alloc(generics)\n     }\n@@ -2008,4 +2000,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     providers.object_lifetime_defaults = |tcx, id| {\n         tcx.gcx.named_region_map.object_lifetime_defaults.get(&id).cloned()\n     };\n+    providers.crate_name = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        tcx.crate_name\n+    };\n }"}, {"sha": "762b35793de0b6823cb9e0cb212a253349c14811", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -17,7 +17,7 @@ use hir::svh::Svh;\n use lint;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary};\n-use middle::cstore::NativeLibraryKind;\n+use middle::cstore::{NativeLibraryKind, DepKind};\n use middle::privacy::AccessLevels;\n use middle::region;\n use middle::region::RegionMaps;\n@@ -669,6 +669,24 @@ impl<'tcx> QueryDescription for queries::object_lifetime_defaults<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::dep_kind<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a dependency looks like\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a crate is named\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::extern_mod_stmt_cnum<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"looking up the CrateNum for an `extern mod` statement\")\n+    }\n+}\n+\n // If enabled, send a message to the profile-queries thread\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n@@ -1268,6 +1286,12 @@ define_maps! { <'tcx>\n     [] is_late_bound: IsLateBound(HirId) -> bool,\n     [] object_lifetime_defaults: ObjectLifetimeDefaults(HirId)\n         -> Option<Rc<Vec<ObjectLifetimeDefault>>>,\n+\n+    [] visibility: Visibility(DefId) -> ty::Visibility,\n+    [] dep_kind: DepKind(CrateNum) -> DepKind,\n+    [] crate_name: CrateName(CrateNum) -> Symbol,\n+    [] item_children: ItemChildren(DefId) -> Rc<Vec<Export>>,\n+    [] extern_mod_stmt_cnum: ExternModStmtCnum(HirId) -> Option<CrateNum>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {"}, {"sha": "c58d98147047edf73d4f0d0ff3ddc3412e91c622", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -2315,7 +2315,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let node_id = self.hir.as_local_node_id(impl_did).unwrap();\n             Ok(self.hir.span(node_id))\n         } else {\n-            Err(self.sess.cstore.crate_name(impl_did.krate))\n+            Err(self.crate_name(impl_did.krate))\n         }\n     }\n "}, {"sha": "60d7a4ce87ed065bd7f09f40ceab1168b691050b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -1063,7 +1063,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n             _ => return,\n         };\n \n-        let prfn = match cx.sess().cstore.extern_mod_stmt_cnum(it.id) {\n+        let hir_id = cx.tcx.hir.node_to_hir_id(it.id);\n+        let prfn = match cx.tcx.extern_mod_stmt_cnum(hir_id) {\n             Some(cnum) => cx.tcx.plugin_registrar_fn(cnum),\n             None => {\n                 // Probably means we aren't linking the crate for some reason."}, {"sha": "326ec8398080375220b49abd5a7048e8d64ffb6c", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -205,6 +205,14 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_dllimport_foreign_item => {\n         cdata.is_dllimport_foreign_item(def_id.index, &tcx.dep_graph)\n     }\n+    visibility => { cdata.get_visibility(def_id.index) }\n+    dep_kind => { cdata.dep_kind.get() }\n+    crate_name => { cdata.name }\n+    item_children => {\n+        let mut result = vec![];\n+        cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n+        Rc::new(result)\n+    }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -246,6 +254,10 @@ pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n             assert_eq!(cnum, LOCAL_CRATE);\n             Rc::new(link_args::collect(tcx))\n         },\n+        extern_mod_stmt_cnum: |tcx, id| {\n+            let id = tcx.hir.definitions().find_node_for_hir_id(id);\n+            tcx.sess.cstore.extern_mod_stmt_cnum_untracked(id)\n+        },\n         ..*providers\n     };\n }\n@@ -259,7 +271,7 @@ impl CrateStore for cstore::CStore {\n         &*self.metadata_loader\n     }\n \n-    fn visibility(&self, def: DefId) -> ty::Visibility {\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility {\n         self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n@@ -275,15 +287,15 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind\n     {\n         let data = self.get_crate_data(cnum);\n         let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n         self.dep_graph.read(dep_node);\n         data.dep_kind.get()\n     }\n \n-    fn export_macros(&self, cnum: CrateNum) {\n+    fn export_macros_untracked(&self, cnum: CrateNum) {\n         let data = self.get_crate_data(cnum);\n         let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n \n@@ -304,7 +316,7 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).get_missing_lang_items(&self.dep_graph)\n     }\n \n-    fn crate_name(&self, cnum: CrateNum) -> Symbol\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol\n     {\n         self.get_crate_data(cnum).name\n     }\n@@ -338,13 +350,13 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).def_path_table.clone()\n     }\n \n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>\n     {\n         self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n-    fn item_children(&self, def_id: DefId, sess: &Session) -> Vec<def::Export>\n+    fn item_children_untracked(&self, def_id: DefId, sess: &Session) -> Vec<def::Export>\n     {\n         self.read_dep_node(def_id);\n         let mut result = vec![];\n@@ -353,7 +365,7 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn load_macro(&self, id: DefId, sess: &Session) -> LoadedMacro {\n+    fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.as_usize() - 1].1.clone());\n@@ -427,7 +439,7 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).source.clone()\n     }\n \n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n     {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n@@ -475,7 +487,7 @@ impl CrateStore for cstore::CStore {\n             let mut add_child = |bfs_queue: &mut VecDeque<_>, child: def::Export, parent: DefId| {\n                 let child = child.def.def_id();\n \n-                if self.visibility(child) != ty::Visibility::Public {\n+                if self.visibility_untracked(child) != ty::Visibility::Public {\n                     return;\n                 }\n \n@@ -499,7 +511,7 @@ impl CrateStore for cstore::CStore {\n                 index: CRATE_DEF_INDEX\n             });\n             while let Some(def) = bfs_queue.pop_front() {\n-                for child in self.item_children(def, sess) {\n+                for child in self.item_children_untracked(def, sess) {\n                     add_child(bfs_queue, child, def);\n                 }\n             }"}, {"sha": "0893842eff0e7989ef9046fe9614972c9887d2f0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -1288,16 +1288,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {\n-        let cstore = &*self.tcx.sess.cstore;\n-        let crates = cstore.crates();\n+        let crates = self.tcx.sess.cstore.crates();\n \n         let mut deps = crates\n             .iter()\n             .map(|&cnum| {\n                 let dep = CrateDep {\n                     name: self.tcx.original_crate_name(cnum),\n                     hash: self.tcx.crate_hash(cnum),\n-                    kind: cstore.dep_kind(cnum),\n+                    kind: self.tcx.dep_kind(cnum),\n                 };\n                 (cnum, dep)\n             })"}, {"sha": "139cb61bd9bd72a2a175f5ac14ddccb682d0b35e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -630,7 +630,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n                 };\n                 ty::Visibility::from_hir(vis, node_id, self.tcx)\n             }\n-            None => self.tcx.sess.cstore.visibility(did),\n+            None => self.tcx.visibility(did),\n         }\n     }\n "}, {"sha": "776ec3fd3f998d6dd2de5ac94b4d080ac7e3b3b3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -253,7 +253,7 @@ impl<'a> Resolver<'a> {\n                 self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n+                let crate_id = self.session.cstore.extern_mod_stmt_cnum_untracked(item.id).unwrap();\n                 let module =\n                     self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(module);\n@@ -449,7 +449,7 @@ impl<'a> Resolver<'a> {\n         let ident = child.ident;\n         let def = child.def;\n         let def_id = def.def_id();\n-        let vis = self.session.cstore.visibility(def_id);\n+        let vis = self.session.cstore.visibility_untracked(def_id);\n         let span = child.span;\n         let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n         match def {\n@@ -485,7 +485,7 @@ impl<'a> Resolver<'a> {\n                                              span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n \n-                for child in self.session.cstore.item_children(def_id, self.session) {\n+                for child in self.session.cstore.item_children_untracked(def_id, self.session) {\n                     let ns = if let Def::AssociatedTy(..) = child.def { TypeNS } else { ValueNS };\n                     self.define(module, child.ident, ns,\n                                 (child.def, ty::Visibility::Public, DUMMY_SP, expansion));\n@@ -501,7 +501,7 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n-                let field_names = self.session.cstore.struct_field_names(def_id);\n+                let field_names = self.session.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n@@ -516,13 +516,13 @@ impl<'a> Resolver<'a> {\n             return self.module_map[&def_id]\n         }\n \n-        let macros_only = self.session.cstore.dep_kind(def_id.krate).macros_only();\n+        let macros_only = self.session.cstore.dep_kind_untracked(def_id.krate).macros_only();\n         if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n             return module;\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.session.cstore.crate_name(def_id.krate), None)\n+            (self.session.cstore.crate_name_untracked(def_id.krate), None)\n         } else {\n             let def_key = self.session.cstore.def_key(def_id);\n             (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n@@ -558,7 +558,7 @@ impl<'a> Resolver<'a> {\n             return ext.clone();\n         }\n \n-        let macro_def = match self.session.cstore.load_macro(def_id, &self.session) {\n+        let macro_def = match self.session.cstore.load_macro_untracked(def_id, &self.session) {\n             LoadedMacro::MacroDef(macro_def) => macro_def,\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n@@ -574,7 +574,8 @@ impl<'a> Resolver<'a> {\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n         if module.populated.get() { return }\n-        for child in self.session.cstore.item_children(module.def_id().unwrap(), self.session) {\n+        let def_id = module.def_id().unwrap();\n+        for child in self.session.cstore.item_children_untracked(def_id, self.session) {\n             self.build_reduced_graph_for_external_crate_def(module, child);\n         }\n         module.populated.set(true)\n@@ -605,7 +606,8 @@ impl<'a> Resolver<'a> {\n             span_err!(self.session, item.span, E0468,\n                       \"an `extern crate` loading macros must be at the crate root\");\n         } else if !self.use_extern_macros && !used &&\n-                  self.session.cstore.dep_kind(module.def_id().unwrap().krate).macros_only() {\n+                  self.session.cstore.dep_kind_untracked(module.def_id().unwrap().krate)\n+                      .macros_only() {\n             let msg = \"proc macro crates and `#[no_link]` crates have no effect without \\\n                        `#[macro_use]`\";\n             self.session.span_warn(item.span, msg);\n@@ -648,7 +650,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n         for (name, span) in legacy_imports.reexports {\n-            self.session.cstore.export_macros(module.def_id().unwrap().krate);\n+            self.session.cstore.export_macros_untracked(module.def_id().unwrap().krate);\n             let ident = Ident::with_empty_ctxt(name);\n             let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n             if let Ok(binding) = result {"}, {"sha": "c083a0ff58855a51eaddc86d508a0300ee087ffb", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -778,7 +778,7 @@ impl<'a> Resolver<'a> {\n             _ => return,\n         };\n \n-        let crate_name = self.session.cstore.crate_name(krate);\n+        let crate_name = self.session.cstore.crate_name_untracked(krate);\n \n         self.session.struct_span_err(use_span, warn_msg)\n             .help(&format!(\"instead, import the procedural macro like any other item: \\"}, {"sha": "7524b7e8c6c215fab11417b379e1e3d07117f60d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let def = binding.def();\n                 if def != Def::Err {\n                     if !def.def_id().is_local() {\n-                        self.session.cstore.export_macros(def.def_id().krate);\n+                        self.session.cstore.export_macros_untracked(def.def_id().krate);\n                     }\n                     if let Def::Macro(..) = def {\n                         if let Some(&span) = exported_macro_names.get(&ident.modern()) {"}, {"sha": "3dc3bad602a90e5a1384070dcab0859e684e6dc4", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -119,7 +119,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             };\n             let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo());\n             result.push(ExternalCrateData {\n-                name: self.tcx.sess.cstore.crate_name(n).to_string(),\n+                name: self.tcx.crate_name(n).to_string(),\n                 num: n.as_u32(),\n                 file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             });"}, {"sha": "6be7968dba4c2a4f9cd744f6ef11d6588d112fc1", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -216,6 +216,7 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n }\n \n pub fn each_linked_rlib(sess: &Session,\n+                        info: &CrateInfo,\n                         f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n     let fmts = sess.dependency_formats.borrow();\n@@ -234,7 +235,7 @@ pub fn each_linked_rlib(sess: &Session,\n             Some(_) => {}\n             None => return Err(format!(\"could not find formats for rlibs\"))\n         }\n-        let name = sess.cstore.crate_name(cnum).clone();\n+        let name = &info.crate_name[&cnum];\n         let path = match path {\n             LibSource::Some(p) => p,\n             LibSource::MetadataOnly => {\n@@ -611,8 +612,8 @@ fn link_staticlib(sess: &Session,\n                            tempdir);\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(sess, &mut |cnum, path| {\n-        let name = sess.cstore.crate_name(cnum);\n+    let res = each_linked_rlib(sess, &trans.crate_info, &mut |cnum, path| {\n+        let name = &trans.crate_info.crate_name[&cnum];\n         let native_libs = &trans.crate_info.native_libraries[&cnum];\n \n         // Here when we include the rlib into our staticlib we need to make a"}, {"sha": "72e1fc34789540b7e055f4f4ae66da7ff69521ba", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -1130,7 +1130,7 @@ fn start_executing_work(sess: &Session,\n     }).expect(\"failed to spawn helper thread\");\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n+    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n         if link::ignored_for_lto(crate_info, cnum) {\n             return\n         }"}, {"sha": "687d3cff48e8e19e0ca38a3f7a804e8fa5d64330", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -1518,10 +1518,12 @@ impl CrateInfo {\n             native_libraries: FxHashMap(),\n             used_libraries: tcx.native_libraries(LOCAL_CRATE),\n             link_args: tcx.link_args(LOCAL_CRATE),\n+            crate_name: FxHashMap(),\n         };\n \n         for cnum in tcx.sess.cstore.crates() {\n             info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n+            info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n             if tcx.is_panic_runtime(cnum) {\n                 info.panic_runtime = Some(cnum);\n             }"}, {"sha": "588141290f12d620f451be85bfb3b787586428c5", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -234,6 +234,7 @@ pub struct CrateInfo {\n     sanitizer_runtime: Option<CrateNum>,\n     is_no_builtins: FxHashSet<CrateNum>,\n     native_libraries: FxHashMap<CrateNum, Rc<Vec<NativeLibrary>>>,\n+    crate_name: FxHashMap<CrateNum, String>,\n     used_libraries: Rc<Vec<NativeLibrary>>,\n     link_args: Rc<Vec<String>>,\n }"}, {"sha": "5c8f237b2a7e294de23c949a8c54dc0c5ea5d132", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -552,7 +552,7 @@ pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a>\n                     if !external_mods.insert(def_id) {\n                         return;\n                     }\n-                    for child in tcx.sess.cstore.item_children(def_id, tcx.sess) {\n+                    for child in tcx.item_children(def_id).iter() {\n                         handle_external_def(tcx, traits, external_mods, child.def)\n                     }\n                 }"}, {"sha": "efcb9a0f8d0a91694ea7656946b2ffa279d8302d", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -74,7 +74,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir.krate().visit_all_item_likes(&mut visitor);\n \n     for &(id, span) in &tcx.maybe_unused_extern_crates {\n-        let cnum = tcx.sess.cstore.extern_mod_stmt_cnum(id).unwrap();\n+        let hir_id = tcx.hir.node_to_hir_id(id);\n+        let cnum = tcx.extern_mod_stmt_cnum(hir_id).unwrap();\n         if !tcx.is_compiler_builtins(cnum)\n             && !tcx.is_panic_runtime(cnum)\n             && !tcx.has_global_allocator(cnum) {"}, {"sha": "e9c6c0ce02a2711fe41491f516ffd5a5a041f063", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -120,7 +120,7 @@ pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n-    let crate_name = cx.tcx.sess.cstore.crate_name(did.krate).to_string();\n+    let crate_name = cx.tcx.crate_name(did.krate).to_string();\n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n         let s = elem.data.to_string();\n@@ -445,9 +445,9 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n         let mut visited = FxHashSet();\n-        for item in cx.tcx.sess.cstore.item_children(did, cx.tcx.sess) {\n+        for &item in cx.tcx.item_children(did).iter() {\n             let def_id = item.def.def_id();\n-            if cx.tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n+            if cx.tcx.visibility(def_id) == ty::Visibility::Public {\n                 if !visited.insert(def_id) { continue }\n                 if let Some(i) = try_inline(cx, item.def, item.ident.name) {\n                     items.extend(i)"}, {"sha": "0a9583278c6d0d56fd16b405015865a96d780037", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -244,7 +244,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                 }\n             }).collect()\n         } else {\n-            cx.tcx.sess.cstore.item_children(root, cx.tcx.sess).iter().map(|item| item.def)\n+            cx.tcx.item_children(root).iter().map(|item| item.def)\n               .filter_map(as_primitive).collect()\n         };\n "}, {"sha": "d354d726ff703ec2598bf604e0b052bcd88507ee", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -208,7 +208,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n \n                     let imported_from = self.cx.tcx.original_crate_name(def_id.krate);\n-                    let def = match self.cx.sess().cstore.load_macro(def_id, self.cx.sess()) {\n+                    let cstore = &self.cx.sess().cstore;\n+                    let def = match cstore.load_macro_untracked(def_id, self.cx.sess()) {\n                         LoadedMacro::MacroDef(macro_def) => macro_def,\n                         // FIXME(jseyfried): document proc macro reexports\n                         LoadedMacro::ProcMacro(..) => continue,\n@@ -371,9 +372,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             _ if self.inlining && item.vis != hir::Public => {}\n             hir::ItemGlobalAsm(..) => {}\n             hir::ItemExternCrate(ref p) => {\n-                let cstore = &self.cx.sess().cstore;\n+                let hir_id = self.cx.tcx.hir.node_to_hir_id(item.id);\n                 om.extern_crates.push(ExternCrate {\n-                    cnum: cstore.extern_mod_stmt_cnum(item.id)\n+                    cnum: self.cx.tcx.extern_mod_stmt_cnum(hir_id)\n                                 .unwrap_or(LOCAL_CRATE),\n                     name,\n                     path: p.map(|x|x.to_string()),"}, {"sha": "9f75388238f0c0785bafb78d1659c389fc80a759", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ae38019167ef02e53cfc202df8b6be0f79c32d/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=43ae38019167ef02e53cfc202df8b6be0f79c32d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n@@ -25,7 +24,6 @@ use clean::{AttributesExt, NestedAttributesExt};\n /// specific rustdoc annotations into account (i.e. `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     cx: &'a ::core::DocContext<'b, 'tcx>,\n-    cstore: &'a CrateStore,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable\n@@ -38,7 +36,6 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n     pub fn new(cx: &'a ::core::DocContext<'b, 'tcx>) -> LibEmbargoVisitor<'a, 'b, 'tcx> {\n         LibEmbargoVisitor {\n             cx,\n-            cstore: &*cx.sess().cstore,\n             access_levels: cx.access_levels.borrow_mut(),\n             prev_level: Some(AccessLevel::Public),\n             visited_mods: FxHashSet()\n@@ -70,14 +67,14 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n             return;\n         }\n \n-        for item in self.cstore.item_children(def_id, self.cx.tcx.sess) {\n+        for item in self.cx.tcx.item_children(def_id).iter() {\n             self.visit_item(item.def);\n         }\n     }\n \n     fn visit_item(&mut self, def: Def) {\n         let def_id = def.def_id();\n-        let vis = self.cstore.visibility(def_id);\n+        let vis = self.cx.tcx.visibility(def_id);\n         let inherited_item_level = if vis == Visibility::Public {\n             self.prev_level\n         } else {"}]}