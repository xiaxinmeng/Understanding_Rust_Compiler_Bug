{"sha": "2bf053c0a349a5968820780314c942ef4555b47e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZjA1M2MwYTM0OWE1OTY4ODIwNzgwMzE0Yzk0MmVmNDU1NWI0N2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-01T06:10:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-01T06:10:36Z"}, "message": "auto merge of #6851 : alexcrichton/rust/bugfixes, r=pcwalton\n\nCloses #5090 by using the excellent new generic deriving code\r\n\r\nPromotes the unreachable code attribute to a lint attribute (instead of always being a warning)\r\n\r\nFixes some edge cases when creating hashmaps/hashsets and also when consuming them. (fixes #5998)", "tree": {"sha": "f56b06e74a72c6a034aec68960efab5f334ba351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f56b06e74a72c6a034aec68960efab5f334ba351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bf053c0a349a5968820780314c942ef4555b47e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bf053c0a349a5968820780314c942ef4555b47e", "html_url": "https://github.com/rust-lang/rust/commit/2bf053c0a349a5968820780314c942ef4555b47e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bf053c0a349a5968820780314c942ef4555b47e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c23843c4471dcacb203d4439ef7c19bb2c3238b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c23843c4471dcacb203d4439ef7c19bb2c3238b0", "html_url": "https://github.com/rust-lang/rust/commit/c23843c4471dcacb203d4439ef7c19bb2c3238b0"}, {"sha": "e694e5fc592491097470e996fb41bd25104252fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e694e5fc592491097470e996fb41bd25104252fc", "html_url": "https://github.com/rust-lang/rust/commit/e694e5fc592491097470e996fb41bd25104252fc"}], "stats": {"total": 1346, "additions": 365, "deletions": 981}, "files": [{"sha": "c460ec89e4e9e0bd404da06107e277e99728795e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -96,6 +96,7 @@ pub enum lint {\n     unnecessary_allocation,\n \n     missing_doc,\n+    unreachable_code,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -273,6 +274,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         desc: \"detects missing documentation for public members\",\n         default: allow\n     }),\n+\n+    (\"unreachable_code\",\n+     LintSpec {\n+        lint: unreachable_code,\n+        desc: \"detects unreachable code\",\n+        default: warn\n+    }),\n ];\n \n /*"}, {"sha": "f8481d4cf904d0e8b195052c93f93183dbbafc5d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -81,6 +81,7 @@ use core::prelude::*;\n use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n+use middle::lint::unreachable_code;\n use middle::ty::{FnSig, VariantInfo_};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty::{substs, param_ty};\n@@ -2937,7 +2938,8 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n         let mut any_err = false;\n         for blk.node.stmts.each |s| {\n             check_stmt(fcx, *s);\n-            let s_ty = fcx.node_ty(ast_util::stmt_id(*s));\n+            let s_id = ast_util::stmt_id(*s);\n+            let s_ty = fcx.node_ty(s_id);\n             if last_was_bot && !warned && match s.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n                                                  _}, _) |\n@@ -2946,7 +2948,8 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n                   }\n                   _ => false\n                 } {\n-                fcx.ccx.tcx.sess.span_warn(s.span, \"unreachable statement\");\n+                fcx.ccx.tcx.sess.add_lint(unreachable_code, s_id, s.span,\n+                                          ~\"unreachable statement\");\n                 warned = true;\n             }\n             if ty::type_is_bot(s_ty) {"}, {"sha": "4826af20c69a1f6c9fccc59ccc7c7b936041f7f6", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -72,11 +72,12 @@ pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n     k0: u64, k1: u64,\n     initial_capacity: uint) -> HashMap<K, V> {\n+    let cap = uint::max(INITIAL_CAPACITY, initial_capacity);\n     HashMap {\n         k0: k0, k1: k1,\n-        resize_at: resize_at(initial_capacity),\n+        resize_at: resize_at(cap),\n         size: 0,\n-        buckets: vec::from_fn(initial_capacity, |_| None)\n+        buckets: vec::from_fn(cap, |_| None)\n     }\n }\n \n@@ -480,7 +481,8 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n \n     fn consume(&mut self, f: &fn(K, V)) {\n-        let buckets = replace(&mut self.buckets, ~[]);\n+        let buckets = replace(&mut self.buckets,\n+                              vec::from_fn(INITIAL_CAPACITY, |_| None));\n         self.size = 0;\n \n         do vec::consume(buckets) |_, bucket| {\n@@ -664,6 +666,12 @@ mod test_map {\n     use super::*;\n     use uint;\n \n+    #[test]\n+    fn test_create_capacity_zero() {\n+        let mut m = HashMap::with_capacity(0);\n+        assert!(m.insert(1, 1));\n+    }\n+\n     #[test]\n     fn test_insert() {\n         let mut m = HashMap::new();\n@@ -771,6 +779,14 @@ mod test_map {\n         assert_eq!(m2.get(&2), &3);\n     }\n \n+    #[test]\n+    fn test_consume_still_usable() {\n+        let mut m = HashMap::new();\n+        assert!(m.insert(1, 2));\n+        do m.consume |_, _| {}\n+        assert!(m.insert(1, 2));\n+    }\n+\n     #[test]\n     fn test_iterate() {\n         let mut m = linear_map_with_capacity(4);"}, {"sha": "1991b2456d97d8da3c425f2f0da865d9c500f30b", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 133, "deletions": 393, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -14,410 +14,150 @@ encodable.rs for more.\n */\n \n use core::prelude::*;\n+use core::vec;\n+use core::uint;\n \n-use ast::*;\n-use ast;\n-use ast_util;\n-use codemap::{span, spanned};\n+use ast::{meta_item, item, expr, m_mutbl};\n+use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use ext::deriving::*;\n-use opt_vec;\n-\n-use core::uint;\n-\n-pub fn expand_deriving_decodable(\n-    cx: @ExtCtxt,\n-    span: span,\n-    _mitem: @meta_item,\n-    in_items: ~[@item]\n-) -> ~[@item] {\n-    expand_deriving(\n-        cx,\n-        span,\n-        in_items,\n-        expand_deriving_decodable_struct_def,\n-        expand_deriving_decodable_enum_def\n-    )\n-}\n-\n-fn create_derived_decodable_impl(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ident,\n-    generics: &Generics,\n-    method: @method\n-) -> @item {\n-    let decoder_ty_param = cx.typaram(\n-        cx.ident_of(\"__D\"),\n-        @opt_vec::with(\n-            cx.typarambound(\n-                cx.path_global(\n-                    span,\n-                    ~[\n-                        cx.ident_of(\"extra\"),\n-                        cx.ident_of(\"serialize\"),\n-                        cx.ident_of(\"Decoder\"),\n-                    ]))));\n-\n-    // All the type parameters need to bound to the trait.\n-    let generic_ty_params = opt_vec::with(decoder_ty_param);\n-\n-    let methods = [method];\n-    let trait_path = cx.path_all(\n-        span,\n-        true,\n-        ~[\n-            cx.ident_of(\"extra\"),\n-            cx.ident_of(\"serialize\"),\n-            cx.ident_of(\"Decodable\")\n-        ],\n-        None,\n-        ~[\n-            cx.ty_ident(span, cx.ident_of(\"__D\"))\n+use ext::deriving::generic::*;\n+\n+pub fn expand_deriving_decodable(cx: @ExtCtxt,\n+                                 span: span,\n+                                 mitem: @meta_item,\n+                                 in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new_(~[\"extra\", \"serialize\", \"Decodable\"], None,\n+                         ~[~Literal(Path::new_local(\"__D\"))], true),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds {\n+            lifetimes: ~[],\n+            bounds: ~[(\"__D\", ~[Path::new(~[\"extra\", \"serialize\", \"Decoder\"])])],\n+        },\n+        methods: ~[\n+            MethodDef {\n+                name: \"decode\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[Ptr(~Literal(Path::new_local(\"__D\")),\n+                            Borrowed(None, m_mutbl))],\n+                ret_ty: Self,\n+                const_nonmatching: true,\n+                combine_substructure: decodable_substructure,\n+            },\n         ]\n-    );\n-    create_derived_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        methods,\n-        trait_path,\n-        Generics { ty_params: generic_ty_params, lifetimes: opt_vec::Empty },\n-        opt_vec::Empty\n-    )\n-}\n-\n-// Creates a method from the given set of statements conforming to the\n-// signature of the `decodable` method.\n-fn create_decode_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ast::ident,\n-    generics: &Generics,\n-    expr: @ast::expr\n-) -> @method {\n-    // Create the `e` parameter.\n-    let d_arg_type = cx.ty_rptr(\n-        span,\n-        cx.ty_ident(span, cx.ident_of(\"__D\")),\n-        None,\n-        ast::m_mutbl\n-    );\n-    let d_ident = cx.ident_of(\"__d\");\n-    let d_arg = cx.arg(span, d_ident, d_arg_type);\n-\n-    // Create the type of the return value.\n-    let output_type = create_self_type_with_params(\n-        cx,\n-        span,\n-        type_ident,\n-        generics\n-    );\n-\n-    // Create the function declaration.\n-    let inputs = ~[d_arg];\n-    let fn_decl = cx.fn_decl(inputs, output_type);\n-\n-    // Create the body block.\n-    let body_block = cx.blk_expr(expr);\n+    };\n \n-    // Create the method.\n-    let explicit_self = spanned { node: sty_static, span: span };\n-    let method_ident = cx.ident_of(\"decode\");\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        explicit_self: explicit_self,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n }\n \n-fn call_substructure_decode_method(\n-    cx: @ExtCtxt,\n-    span: span\n-) -> @ast::expr {\n-    // Call the substructure method.\n-    cx.expr_call(\n-        span,\n-        cx.expr_path(\n-            cx.path_global(\n-                span,\n-                ~[\n-                    cx.ident_of(\"extra\"),\n+fn decodable_substructure(cx: @ExtCtxt, span: span,\n+                          substr: &Substructure) -> @expr {\n+    let decoder = substr.nonself_args[0];\n+    let recurse = ~[cx.ident_of(\"extra\"),\n                     cx.ident_of(\"serialize\"),\n                     cx.ident_of(\"Decodable\"),\n-                    cx.ident_of(\"decode\"),\n-                ]\n-            )\n-        ),\n-        ~[\n-            cx.expr_ident(span, cx.ident_of(\"__d\"))\n-        ]\n-    )\n-}\n-\n-fn expand_deriving_decodable_struct_def(\n-    cx: @ExtCtxt,\n-    span: span,\n-    struct_def: &struct_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @item {\n-    // Create the method.\n-    let method = expand_deriving_decodable_struct_method(\n-        cx,\n-        span,\n-        struct_def,\n-        type_ident,\n-        generics\n-    );\n-\n-    // Create the implementation.\n-    create_derived_decodable_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        method\n-    )\n-}\n-\n-fn expand_deriving_decodable_enum_def(\n-    cx: @ExtCtxt,\n-    span: span,\n-    enum_definition: &enum_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @item {\n-    // Create the method.\n-    let method = expand_deriving_decodable_enum_method(\n-        cx,\n-        span,\n-        enum_definition,\n-        type_ident,\n-        generics\n-    );\n-\n-    // Create the implementation.\n-    create_derived_decodable_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        method\n-    )\n-}\n-\n-fn create_read_struct_field(\n-    cx: @ExtCtxt,\n-    span: span,\n-    idx: uint,\n-    ident: ident\n-) -> ast::field {\n-    // Call the substructure method.\n-    let decode_expr = call_substructure_decode_method(cx, span);\n-\n-    let d_id = cx.ident_of(\"__d\");\n-\n-    let call_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, d_id),\n-        cx.ident_of(\"read_struct_field\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(ident)),\n-            cx.expr_uint(span, idx),\n-            cx.lambda_expr_1(span, decode_expr, d_id)\n-        ]\n-    );\n-\n-    cx.field_imm(span, ident, call_expr)\n-}\n-\n-fn create_read_struct_arg(\n-    cx: @ExtCtxt,\n-    span: span,\n-    idx: uint,\n-    ident: ident\n-) -> ast::field {\n-    // Call the substructure method.\n-    let decode_expr = call_substructure_decode_method(cx, span);\n-\n-    let call_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, cx.ident_of(\"__d\")),\n-        cx.ident_of(\"read_struct_arg\"),\n-        ~[\n-            cx.expr_uint(span, idx),\n-            cx.lambda_expr_0(span, decode_expr),\n-        ]\n-    );\n-\n-    cx.field_imm(span, ident, call_expr)\n-}\n-\n-fn expand_deriving_decodable_struct_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    struct_def: &struct_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @method {\n-    // Create the body of the method.\n-    let mut i = 0;\n-    let mut fields = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _) => {\n-                fields.push(create_read_struct_field(cx, span, i, ident));\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(\n-                    span,\n-                    \"unnamed fields with `deriving(Decodable)`\"\n-                );\n-            }\n-        }\n-        i += 1;\n-    }\n-\n-    let d_id = cx.ident_of(\"__d\");\n-\n-    let read_struct_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, d_id),\n-        cx.ident_of(\"read_struct\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(type_ident)),\n-            cx.expr_uint(span, fields.len()),\n-            cx.lambda_expr_1(\n-                span,\n-                cx.expr_struct_ident(span, type_ident, fields),\n-                d_id)\n-        ]\n-    );\n-\n-    // Create the method itself.\n-    create_decode_method(cx, span, type_ident, generics, read_struct_expr)\n-}\n-\n-fn create_read_variant_arg(\n-    cx: @ExtCtxt,\n-    span: span,\n-    idx: uint,\n-    variant: &ast::variant\n-) -> ast::arm {\n-    // Create the matching pattern.\n-    let pat = cx.pat_lit(span, cx.expr_uint(span, idx));\n-\n-    // Feed each argument in this variant to the decode function\n-    // as well.\n-    let variant_arg_len = variant_arg_count(cx, span, variant);\n-\n-    let expr = if variant_arg_len == 0 {\n-        cx.expr_ident(span, variant.node.name)\n-    } else {\n-        // Feed the discriminant to the decode function.\n-        let mut args = ~[];\n-\n-        for uint::range(0, variant_arg_len) |j| {\n-            // Call the substructure method.\n-            let expr = call_substructure_decode_method(cx, span);\n-\n-            let d_id = cx.ident_of(\"__d\");\n-\n-            let call_expr = cx.expr_method_call(\n-                span,\n-                cx.expr_ident(span, d_id),\n-                cx.ident_of(\"read_enum_variant_arg\"),\n-                ~[\n-                    cx.expr_uint(span, j),\n-                    cx.lambda_expr_1(span, expr, d_id),\n-                ]\n-            );\n-\n-            args.push(call_expr);\n+                    cx.ident_of(\"decode\")];\n+    // throw an underscore in front to suppress unused variable warnings\n+    let blkarg = cx.ident_of(\"_d\");\n+    let blkdecoder = cx.expr_ident(span, blkarg);\n+    let calldecode = cx.expr_call_global(span, recurse, ~[blkdecoder]);\n+    let lambdadecode = cx.lambda_expr_1(span, calldecode, blkarg);\n+\n+    return match *substr.fields {\n+        StaticStruct(_, ref summary) => {\n+            let nfields = match *summary {\n+                Left(n) => n, Right(ref fields) => fields.len()\n+            };\n+            let read_struct_field = cx.ident_of(\"read_struct_field\");\n+\n+            let getarg = |name: ~str, field: uint| {\n+                cx.expr_method_call(span, blkdecoder, read_struct_field,\n+                                    ~[cx.expr_str(span, name),\n+                                      cx.expr_uint(span, field),\n+                                      lambdadecode])\n+            };\n+\n+            let result = match *summary {\n+                Left(n) => {\n+                    if n == 0 {\n+                        cx.expr_ident(span, substr.type_ident)\n+                    } else {\n+                        let mut fields = vec::with_capacity(n);\n+                        for uint::range(0, n) |i| {\n+                            fields.push(getarg(fmt!(\"_field%u\", i), i));\n+                        }\n+                        cx.expr_call_ident(span, substr.type_ident, fields)\n+                    }\n+                }\n+                Right(ref fields) => {\n+                    let fields = do fields.mapi |i, f| {\n+                        cx.field_imm(span, *f, getarg(cx.str_of(*f), i))\n+                    };\n+                    cx.expr_struct_ident(span, substr.type_ident, fields)\n+                }\n+            };\n+\n+            cx.expr_method_call(span, decoder, cx.ident_of(\"read_struct\"),\n+                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n+                                  cx.expr_uint(span, nfields),\n+                                  cx.lambda_expr_1(span, result, blkarg)])\n         }\n+        StaticEnum(_, ref fields) => {\n+            let variant = cx.ident_of(\"i\");\n+\n+            let mut arms = ~[];\n+            let mut variants = ~[];\n+            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n+\n+            for fields.eachi |i, f| {\n+                let (name, parts) = match *f { (i, ref p) => (i, p) };\n+                variants.push(cx.expr_str(span, cx.str_of(name)));\n+\n+                let getarg = |field: uint| {\n+                    cx.expr_method_call(span, blkdecoder, rvariant_arg,\n+                                        ~[cx.expr_uint(span, field),\n+                                          lambdadecode])\n+                };\n+\n+                let decoded = match *parts {\n+                    Left(n) => {\n+                        if n == 0 {\n+                            cx.expr_ident(span, name)\n+                        } else {\n+                            let mut fields = vec::with_capacity(n);\n+                            for uint::range(0, n) |i| {\n+                                fields.push(getarg(i));\n+                            }\n+                            cx.expr_call_ident(span, name, fields)\n+                        }\n+                    }\n+                    Right(ref fields) => {\n+                        let fields = do fields.mapi |i, f| {\n+                            cx.field_imm(span, *f, getarg(i))\n+                        };\n+                        cx.expr_struct_ident(span, name, fields)\n+                    }\n+                };\n+                arms.push(cx.arm(span,\n+                                 ~[cx.pat_lit(span, cx.expr_uint(span, i))],\n+                                 decoded));\n+            }\n \n-        cx.expr_call_ident(span, variant.node.name, args)\n-    };\n-\n-    // Create the arm.\n-    cx.arm(span, ~[pat], expr)\n-}\n-\n-fn create_read_enum_variant(\n-    cx: @ExtCtxt,\n-    span: span,\n-    enum_definition: &enum_def\n-) -> @expr {\n-    // Create a vector that contains all the variant names.\n-    let expr_arm_names = cx.expr_vec(\n-        span,\n-        do enum_definition.variants.map |variant| {\n-            cx.expr_str(\n-                span,\n-                cx.str_of(variant.node.name)\n-            )\n+            arms.push(cx.arm_unreachable(span));\n+\n+            let result = cx.expr_match(span, cx.expr_ident(span, variant), arms);\n+            let lambda = cx.lambda_expr(span, ~[blkarg, variant], result);\n+            let variant_vec = cx.expr_vec(span, variants);\n+            let result = cx.expr_method_call(span, blkdecoder,\n+                                             cx.ident_of(\"read_enum_variant\"),\n+                                             ~[variant_vec, lambda]);\n+            cx.expr_method_call(span, decoder, cx.ident_of(\"read_enum\"),\n+                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n+                                  cx.lambda_expr_1(span, result, blkarg)])\n         }\n-    );\n-\n-    // Create the arms of the match in the method body.\n-    let mut arms = do enum_definition.variants.mapi |i, variant| {\n-        create_read_variant_arg(cx, span, i, variant)\n+        _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };\n-\n-    // Add the impossible case arm.\n-    arms.push(cx.arm_unreachable(span));\n-\n-    // Create the read_enum_variant expression.\n-    cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, cx.ident_of(\"__d\")),\n-        cx.ident_of(\"read_enum_variant\"),\n-        ~[\n-            expr_arm_names,\n-            cx.lambda_expr(span,\n-                           ~[cx.ident_of(\"__d\"), cx.ident_of(\"__i\")],\n-                           cx.expr_match(span, cx.expr_ident(span, cx.ident_of(\"__i\")), arms))\n-        ]\n-    )\n-}\n-\n-fn expand_deriving_decodable_enum_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    enum_definition: &enum_def,\n-    type_ident: ast::ident,\n-    generics: &Generics\n-) -> @method {\n-    let read_enum_variant_expr = create_read_enum_variant(\n-        cx,\n-        span,\n-        enum_definition\n-    );\n-\n-    let d_id = cx.ident_of(\"__d\");\n-\n-    // Create the read_enum expression\n-    let read_enum_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, d_id),\n-        cx.ident_of(\"read_enum\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(type_ident)),\n-            cx.lambda_expr_1(span, read_enum_variant_expr, d_id)\n-        ]\n-    );\n-\n-    // Create the method.\n-    create_decode_method(cx, span, type_ident, generics, read_enum_expr)\n }"}, {"sha": "b9c4bf7bf26af1f04a9e930a5ba4358d9e589c42", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 99, "deletions": 564, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -77,578 +77,113 @@ would yield functions like:\n \n use core::prelude::*;\n \n-use ast;\n-use ast::*;\n+use ast::{meta_item, item, expr, m_imm, m_mutbl};\n+use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use ext::deriving::*;\n-use codemap::{span, spanned};\n-use ast_util;\n-use opt_vec;\n-\n-pub fn expand_deriving_encodable(\n-    cx: @ExtCtxt,\n-    span: span,\n-    _mitem: @meta_item,\n-    in_items: ~[@item]\n-) -> ~[@item] {\n-    expand_deriving(\n-        cx,\n-        span,\n-        in_items,\n-        expand_deriving_encodable_struct_def,\n-        expand_deriving_encodable_enum_def\n-    )\n-}\n-\n-fn create_derived_encodable_impl(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ident,\n-    generics: &Generics,\n-    method: @method\n-) -> @item {\n-    let encoder_ty_param = cx.typaram(\n-        cx.ident_of(\"__E\"),\n-        @opt_vec::with(\n-            cx.typarambound(\n-                cx.path_global(\n-                    span,\n-                    ~[\n-                        cx.ident_of(\"extra\"),\n-                        cx.ident_of(\"serialize\"),\n-                        cx.ident_of(\"Encoder\"),\n-                    ]))));\n-\n-    // All the type parameters need to bound to the trait.\n-    let generic_ty_params = opt_vec::with(encoder_ty_param);\n-\n-    let methods = [method];\n-    let trait_path = cx.path_all(\n-        span,\n-        true,\n-        ~[\n-            cx.ident_of(\"extra\"),\n-            cx.ident_of(\"serialize\"),\n-            cx.ident_of(\"Encodable\")\n-        ],\n-        None,\n-        ~[\n-            cx.ty_ident(span, cx.ident_of(\"__E\"))\n+use ext::deriving::generic::*;\n+\n+pub fn expand_deriving_encodable(cx: @ExtCtxt,\n+                                 span: span,\n+                                 mitem: @meta_item,\n+                                 in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new_(~[\"extra\", \"serialize\", \"Encodable\"], None,\n+                         ~[~Literal(Path::new_local(\"__E\"))], true),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds {\n+            lifetimes: ~[],\n+            bounds: ~[(\"__E\", ~[Path::new(~[\"extra\", \"serialize\", \"Encoder\"])])],\n+        },\n+        methods: ~[\n+            MethodDef {\n+                name: \"encode\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: Some(Some(Borrowed(None, m_imm))),\n+                args: ~[Ptr(~Literal(Path::new_local(\"__E\")),\n+                            Borrowed(None, m_mutbl))],\n+                ret_ty: nil_ty(),\n+                const_nonmatching: true,\n+                combine_substructure: encodable_substructure,\n+            },\n         ]\n-    );\n-    create_derived_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        methods,\n-        trait_path,\n-        Generics { ty_params: generic_ty_params, lifetimes: opt_vec::Empty },\n-        opt_vec::Empty\n-    )\n-}\n-\n-// Creates a method from the given set of statements conforming to the\n-// signature of the `encodable` method.\n-fn create_encode_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    statements: ~[@stmt]\n-) -> @method {\n-    // Create the `e` parameter.\n-    let e_arg_type = cx.ty_rptr(\n-        span,\n-        cx.ty_ident(span, cx.ident_of(\"__E\")),\n-        None,\n-        ast::m_mutbl\n-    );\n-    let e_arg = cx.arg(span, cx.ident_of(\"__e\"), e_arg_type);\n-\n-    // Create the type of the return value.\n-    let output_type = cx.ty_nil();\n-\n-    // Create the function declaration.\n-    let inputs = ~[e_arg];\n-    let fn_decl = cx.fn_decl(inputs, output_type);\n-\n-    // Create the body block.\n-    let body_block = cx.blk(span, statements, None);\n-\n-    // Create the method.\n-    let explicit_self = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(\"encode\");\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        explicit_self: explicit_self,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-fn call_substructure_encode_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    self_field: @expr\n-) -> @ast::expr {\n-    // Gather up the parameters we want to chain along.\n-    let e_ident = cx.ident_of(\"__e\");\n-    let e_expr = cx.expr_ident(span, e_ident);\n-\n-    // Call the substructure method.\n-    let encode_ident = cx.ident_of(\"encode\");\n-    cx.expr_method_call(\n-        span,\n-        self_field,\n-        encode_ident,\n-        ~[e_expr]\n-    )\n-}\n-\n-fn expand_deriving_encodable_struct_def(\n-    cx: @ExtCtxt,\n-    span: span,\n-    struct_def: &struct_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @item {\n-    // Create the method.\n-    let method = expand_deriving_encodable_struct_method(\n-        cx,\n-        span,\n-        type_ident,\n-        struct_def\n-    );\n-\n-    // Create the implementation.\n-    create_derived_encodable_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        method\n-    )\n-}\n-\n-fn expand_deriving_encodable_enum_def(\n-    cx: @ExtCtxt,\n-    span: span,\n-    enum_definition: &enum_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @item {\n-    // Create the method.\n-    let method = expand_deriving_encodable_enum_method(\n-        cx,\n-        span,\n-        type_ident,\n-        enum_definition\n-    );\n+    };\n \n-    // Create the implementation.\n-    create_derived_encodable_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        method\n-    )\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n }\n \n-fn expand_deriving_encodable_struct_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ident,\n-    struct_def: &struct_def\n-) -> @method {\n-    // Create the body of the method.\n-    let mut idx = 0;\n-    let mut statements = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _) => {\n-                // Create the accessor for this field.\n-                let self_field = cx.expr_field_access(span,\n-                                                      cx.expr_self(span),\n-                                                      ident);\n-\n-                // Call the substructure method.\n-                let encode_expr = call_substructure_encode_method(\n-                    cx,\n-                    span,\n-                    self_field\n-                );\n-\n-                let e_ident = cx.ident_of(\"__e\");\n-\n-                let call_expr = cx.expr_method_call(\n-                    span,\n-                    cx.expr_ident(span, e_ident),\n-                    cx.ident_of(\"emit_struct_field\"),\n-                    ~[\n-                        cx.expr_str(span, cx.str_of(ident)),\n-                        cx.expr_uint(span, idx),\n-                        cx.lambda_expr_1(span, encode_expr, e_ident)\n-                    ]\n-                );\n-\n-                statements.push(cx.stmt_expr(call_expr));\n+fn encodable_substructure(cx: @ExtCtxt, span: span,\n+                          substr: &Substructure) -> @expr {\n+    let encoder = substr.nonself_args[0];\n+    // throw an underscore in front to suppress unused variable warnings\n+    let blkarg = cx.ident_of(\"_e\");\n+    let blkencoder = cx.expr_ident(span, blkarg);\n+    let encode = cx.ident_of(\"encode\");\n+\n+    return match *substr.fields {\n+        Struct(ref fields) => {\n+            let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n+            let mut stmts = ~[];\n+            for fields.eachi |i, f| {\n+                let (name, val) = match *f {\n+                    (Some(id), e, _) => (cx.str_of(id), e),\n+                    (None, e, _) => (fmt!(\"_field%u\", i), e)\n+                };\n+                let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n+                let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                let call = cx.expr_method_call(span, blkencoder,\n+                                               emit_struct_field,\n+                                               ~[cx.expr_str(span, name),\n+                                                 cx.expr_uint(span, i),\n+                                                 lambda]);\n+                stmts.push(cx.stmt_expr(call));\n             }\n-            unnamed_field => {\n-                cx.span_unimpl(\n-                    span,\n-                    \"unnamed fields with `deriving(Encodable)`\"\n-                );\n-            }\n-        }\n-        idx += 1;\n-    }\n \n-    let e_id = cx.ident_of(\"__e\");\n-    let emit_struct_stmt = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, e_id),\n-        cx.ident_of(\"emit_struct\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(type_ident)),\n-            cx.expr_uint(span, statements.len()),\n-            cx.lambda_stmts_1(span, statements, e_id),\n-        ]\n-    );\n-\n-    let statements = ~[cx.stmt_expr(emit_struct_stmt)];\n-\n-    // Create the method itself.\n-    return create_encode_method(cx, span, statements);\n-}\n-\n-fn expand_deriving_encodable_enum_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ast::ident,\n-    enum_definition: &enum_def\n-) -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.mapi |i, variant| {\n-        // Create the matching pattern.\n-        let (pat, fields) = create_enum_variant_pattern(cx, span, variant, \"__self\", ast::m_imm);\n-\n-        // Feed the discriminant to the encode function.\n-        let mut stmts = ~[];\n-\n-        // Feed each argument in this variant to the encode function\n-        // as well.\n-        let variant_arg_len = variant_arg_count(cx, span, variant);\n-        for fields.eachi |j, &(_, field)| {\n-            // Call the substructure method.\n-            let expr = call_substructure_encode_method(cx, span, field);\n-\n-            let e_ident = cx.ident_of(\"__e\");\n-            let call_expr = cx.expr_method_call(\n-                span,\n-                cx.expr_ident(span, e_ident),\n-                cx.ident_of(\"emit_enum_variant_arg\"),\n-                ~[\n-                    cx.expr_uint(span, j),\n-                    cx.lambda_expr_1(span, expr, e_ident),\n-                ]\n-            );\n-\n-            stmts.push(cx.stmt_expr(call_expr));\n-        }\n-\n-        // Create the pattern body.\n-        let e_id = cx.ident_of(\"__e\");\n-\n-        let call_expr = cx.expr_method_call(\n-            span,\n-            cx.expr_ident(span, e_id),\n-            cx.ident_of(\"emit_enum_variant\"),\n-            ~[\n-                cx.expr_str(span, cx.str_of(variant.node.name)),\n-                cx.expr_uint(span, i),\n-                cx.expr_uint(span, variant_arg_len),\n-                cx.lambda_stmts_1(span, stmts, e_id)\n-            ]\n-        );\n-\n-        //let match_body_block = cx.blk_expr(call_expr);\n+            let blk = cx.lambda_stmts_1(span, stmts, blkarg);\n+            cx.expr_method_call(span, encoder, cx.ident_of(\"emit_struct\"),\n+                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n+                                  cx.expr_uint(span, fields.len()),\n+                                  blk])\n+        }\n+\n+        EnumMatching(idx, variant, ref fields) => {\n+            // We're not generating an AST that the borrow checker is expecting,\n+            // so we need to generate a unique local variable to take the\n+            // mutable loan out on, otherwise we get conflicts which don't\n+            // actually exist.\n+            let me = cx.stmt_let(span, false, blkarg, encoder);\n+            let encoder = cx.expr_ident(span, blkarg);\n+            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n+            let mut stmts = ~[];\n+            for fields.eachi |i, f| {\n+                let val = match *f { (_, e, _) => e };\n+                let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n+                let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                let call = cx.expr_method_call(span, blkencoder,\n+                                               emit_variant_arg,\n+                                               ~[cx.expr_uint(span, i),\n+                                                 lambda]);\n+                stmts.push(cx.stmt_expr(call));\n+            }\n \n-        // Create the arm.\n-        cx.arm(span, ~[pat], call_expr) //match_body_block)\n+            let blk = cx.lambda_stmts_1(span, stmts, blkarg);\n+            let name = cx.expr_str(span, cx.str_of(variant.node.name));\n+            let call = cx.expr_method_call(span, blkencoder,\n+                                           cx.ident_of(\"emit_enum_variant\"),\n+                                           ~[name,\n+                                             cx.expr_uint(span, idx),\n+                                             cx.expr_uint(span, fields.len()),\n+                                             blk]);\n+            let blk = cx.lambda_expr_1(span, call, blkarg);\n+            let ret = cx.expr_method_call(span, encoder,\n+                                          cx.ident_of(\"emit_enum\"),\n+                                          ~[cx.expr_str(span,\n+                                            cx.str_of(substr.type_ident)),\n+                                            blk]);\n+            cx.expr_blk(cx.blk(span, ~[me], Some(ret)))\n+        }\n+\n+        _ => cx.bug(\"expected Struct or EnumMatching in deriving(Encodable)\")\n     };\n-\n-    let e_ident = cx.ident_of(\"__e\");\n-\n-    // Create the method body.\n-    let lambda_expr = cx.lambda_expr_1(\n-        span,\n-        expand_enum_or_struct_match(cx, span, arms),\n-        e_ident);\n-\n-    let call_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, e_ident),\n-        cx.ident_of(\"emit_enum\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(type_ident)),\n-            lambda_expr,\n-        ]\n-    );\n-\n-    let stmt = cx.stmt_expr(call_expr);\n-\n-    // Create the method.\n-    create_encode_method(cx, span, ~[stmt])\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    extern mod extra;\n-    use core::option::{None, Some};\n-    use extra::serialize::Encodable;\n-    use extra::serialize::Encoder;\n-\n-    // just adding the ones I want to test, for now:\n-    #[deriving(Eq)]\n-    pub enum call {\n-        CallToEmitEnum(~str),\n-        CallToEmitEnumVariant(~str, uint, uint),\n-        CallToEmitEnumVariantArg(uint),\n-        CallToEmitUint(uint),\n-        CallToEmitNil,\n-        CallToEmitStruct(~str,uint),\n-        CallToEmitField(~str,uint),\n-        CallToEmitOption,\n-        CallToEmitOptionNone,\n-        CallToEmitOptionSome,\n-        // all of the ones I was too lazy to handle:\n-        CallToOther\n-    }\n-    // using `@mut` rather than changing the\n-    // type of self in every method of every encoder everywhere.\n-    pub struct TestEncoder {call_log : @mut ~[call]}\n-\n-    pub impl TestEncoder {\n-        // these self's should be &mut self's, as well....\n-        fn add_to_log (&self, c : call) {\n-            self.call_log.push(copy c);\n-        }\n-        fn add_unknown_to_log (&self) {\n-            self.add_to_log (CallToOther)\n-        }\n-    }\n-\n-    impl Encoder for TestEncoder {\n-        fn emit_nil(&mut self) { self.add_to_log(CallToEmitNil) }\n-\n-        fn emit_uint(&mut self, v: uint) {\n-            self.add_to_log(CallToEmitUint(v));\n-        }\n-        fn emit_u64(&mut self, _v: u64) { self.add_unknown_to_log(); }\n-        fn emit_u32(&mut self, _v: u32) { self.add_unknown_to_log(); }\n-        fn emit_u16(&mut self, _v: u16) { self.add_unknown_to_log(); }\n-        fn emit_u8(&mut self, _v: u8)   { self.add_unknown_to_log(); }\n-\n-        fn emit_int(&mut self, _v: int) { self.add_unknown_to_log(); }\n-        fn emit_i64(&mut self, _v: i64) { self.add_unknown_to_log(); }\n-        fn emit_i32(&mut self, _v: i32) { self.add_unknown_to_log(); }\n-        fn emit_i16(&mut self, _v: i16) { self.add_unknown_to_log(); }\n-        fn emit_i8(&mut self, _v: i8)   { self.add_unknown_to_log(); }\n-\n-        fn emit_bool(&mut self, _v: bool) { self.add_unknown_to_log(); }\n-\n-        fn emit_f64(&mut self, _v: f64) { self.add_unknown_to_log(); }\n-        fn emit_f32(&mut self, _v: f32) { self.add_unknown_to_log(); }\n-        fn emit_float(&mut self, _v: float) { self.add_unknown_to_log(); }\n-\n-        fn emit_char(&mut self, _v: char) { self.add_unknown_to_log(); }\n-        fn emit_str(&mut self, _v: &str) { self.add_unknown_to_log(); }\n-\n-        fn emit_enum(&mut self, name: &str, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnum(name.to_str()));\n-            f(self);\n-        }\n-\n-        fn emit_enum_variant(&mut self,\n-                             name: &str,\n-                             id: uint,\n-                             cnt: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnumVariant(name.to_str(), id, cnt));\n-            f(self);\n-        }\n-\n-        fn emit_enum_variant_arg(&mut self,\n-                                 idx: uint,\n-                                 f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnumVariantArg(idx));\n-            f(self);\n-        }\n-\n-        fn emit_enum_struct_variant(&mut self,\n-                                    name: &str,\n-                                    id: uint,\n-                                    cnt: uint,\n-                                    f: &fn(&mut TestEncoder)) {\n-            self.emit_enum_variant(name, id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field(&mut self,\n-                                          _name: &str,\n-                                          idx: uint,\n-                                          f: &fn(&mut TestEncoder)) {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct(&mut self,\n-                       name: &str,\n-                       len: uint,\n-                       f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitStruct (name.to_str(),len));\n-            f(self);\n-        }\n-        fn emit_struct_field(&mut self,\n-                             name: &str,\n-                             idx: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitField (name.to_str(),idx));\n-            f(self);\n-        }\n-\n-        fn emit_tuple(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_tuple_arg(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_tuple_struct(&mut self,\n-                             _name: &str,\n-                             _len: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_tuple_struct_arg(&mut self,\n-                                 _idx: uint,\n-                                 f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_option(&mut self, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitOption);\n-            f(self);\n-        }\n-        fn emit_option_none(&mut self) {\n-            self.add_to_log(CallToEmitOptionNone);\n-        }\n-        fn emit_option_some(&mut self, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitOptionSome);\n-            f(self);\n-        }\n-\n-        fn emit_seq(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_map(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-    }\n-\n-\n-    fn to_call_log<E:Encodable<TestEncoder>>(val: E) -> ~[call] {\n-        let mut te = TestEncoder {\n-            call_log: @mut ~[]\n-        };\n-        val.encode(&mut te);\n-        copy *te.call_log\n-    }\n-\n-    #[deriving(Encodable)]\n-    enum Written {\n-        Book(uint,uint),\n-        Magazine(~str)\n-    }\n-\n-    #[test]\n-    fn test_encode_enum() {\n-        assert_eq!(\n-            to_call_log(Book(34,44)),\n-            ~[\n-                CallToEmitEnum(~\"Written\"),\n-                CallToEmitEnumVariant(~\"Book\",0,2),\n-                CallToEmitEnumVariantArg(0),\n-                CallToEmitUint(34),\n-                CallToEmitEnumVariantArg(1),\n-                CallToEmitUint(44),\n-            ]\n-        );\n-    }\n-\n-    pub struct BPos(uint);\n-\n-    #[deriving(Encodable)]\n-    pub struct HasPos { pos : BPos }\n-\n-    #[test]\n-    fn test_encode_newtype() {\n-        assert_eq!(\n-            to_call_log(HasPos { pos:BPos(48) }),\n-            ~[\n-                CallToEmitStruct(~\"HasPos\",1),\n-                CallToEmitField(~\"pos\",0),\n-                CallToEmitUint(48),\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_encode_option() {\n-        let mut v = None;\n-\n-        assert_eq!(\n-            to_call_log(v),\n-            ~[\n-                CallToEmitOption,\n-                CallToEmitOptionNone,\n-            ]\n-        );\n-\n-        v = Some(54u);\n-        assert_eq!(\n-            to_call_log(v),\n-            ~[\n-                CallToEmitOption,\n-                CallToEmitOptionSome,\n-                CallToEmitUint(54)\n-            ]\n-        );\n-    }\n }"}, {"sha": "91b89a67ee3484859ab65123cef0a0bfbb85c366", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -9,13 +9,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-fn f(caller: &str) {\n-    debug!(caller);\n-    let x: uint = 0u32; // induce type error //~ ERROR mismatched types\n-}\n+#[deny(unreachable_code)];\n \n fn main() {\n-    return f(\"main\");\n-    debug!(\"Paul is dead\"); //~ WARNING unreachable\n+    return;\n+    debug!(\"Paul is dead\"); //~ ERROR: unreachable\n }"}, {"sha": "0b35104841e64b678e6104cbb0a7c67a043fc05d", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -8,11 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deny(unreachable_code)];\n+#[allow(unused_variable)];\n+\n fn fail_len(v: ~[int]) -> uint {\n-    let mut i = fail!();\n+    let mut i = 3;\n+    fail!();\n     for v.each |x| { i += 1u; }\n-    //~^ WARNING unreachable statement\n-    //~^^ ERROR the type of this value must be known\n+    //~^ ERROR: unreachable statement\n     return i;\n }\n fn main() {}"}, {"sha": "eb60e34df8f14e5f4259634f7d6bb5673b41fd41", "filename": "src/test/compile-fail/issue-897-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deny(unreachable_code)];\n+\n fn g() -> ! { fail!(); }\n fn f() -> ! {\n-    return 42i; //~ ERROR expected `!` but found `int`\n-    g(); //~ WARNING unreachable statement\n+    return g();\n+    g(); //~ ERROR: unreachable statement\n }\n fn main() { }"}, {"sha": "103156175a3fd0d8447568173f6cb8b0be90310f", "filename": "src/test/compile-fail/issue-897.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deny(unreachable_code)];\n+\n fn f() -> ! {\n-    return 42i; //~ ERROR expected `!` but found `int`\n-    fail!(); //~ WARNING unreachable statement\n+    return fail!();\n+    fail!(); //~ ERROR: unreachable statement\n }\n fn main() { }"}, {"sha": "2ed02e2cdd7db3e3f54ef6d82afcf4c8a0ade012", "filename": "src/test/compile-fail/liveness-break-uninit-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -13,7 +13,7 @@ fn foo() -> int {\n \n     while 1 != 2  {\n         break;\n-        x = 0; //~ WARNING unreachable statement\n+        x = 0;\n     }\n \n     debug!(x); //~ ERROR use of possibly uninitialized variable: `x`"}, {"sha": "2dcbad2804c16e7eb70c553d651950f5b3be188b", "filename": "src/test/compile-fail/liveness-break-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -13,7 +13,7 @@ fn foo() -> int {\n \n     loop {\n         break;\n-        x = 0;  //~ WARNING unreachable statement\n+        x = 0;\n     }\n \n     debug!(x); //~ ERROR use of possibly uninitialized variable: `x`"}, {"sha": "a9365eeda1c55a62aa350340763c7205d3435def", "filename": "src/test/compile-fail/unreachable-code.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Funreachable-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Fcompile-fail%2Funreachable-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-code.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:unreachable statement\n+#[deny(unreachable_code)];\n+#[allow(unused_variable)];\n+\n fn main() {\n   loop{}\n-             // red herring to make sure compilation fails\n-  error!(42 == 'c');\n+\n+  let a = 3; //~ ERROR: unreachable statement\n }"}, {"sha": "fa672581238feed577d97516607a8aa2edde9b92", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf053c0a349a5968820780314c942ef4555b47e/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=2bf053c0a349a5968820780314c942ef4555b47e", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This actually tests a lot more than just encodable/decodable, but it gets the\n+// job done at least\n+\n+// xfail-fast\n+\n+extern mod extra;\n+\n+use std::io;\n+use std::rand::{random, Rand};\n+use extra::serialize::*;\n+use extra::ebml;\n+use extra::ebml::writer::Encoder;\n+use extra::ebml::reader::Decoder;\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct A;\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct B(int);\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct C(int, int, uint);\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct D {\n+    a: int,\n+    b: uint,\n+}\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+enum E {\n+    E1,\n+    E2(uint),\n+    E3(D),\n+    E4{ x: uint },\n+}\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+enum F { F1 }\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct G<T> {\n+    t: T\n+}\n+\n+fn roundtrip<T: Rand + Eq + Encodable<Encoder> + Decodable<Decoder>>() {\n+    let obj: T = random();\n+    let bytes = do io::with_bytes_writer |w| {\n+        let mut e = Encoder(w);\n+        obj.encode(&mut e);\n+    };\n+    let doc = ebml::reader::Doc(@bytes);\n+    let mut dec = Decoder(doc);\n+    let obj2 = Decodable::decode(&mut dec);\n+    assert!(obj == obj2);\n+}\n+\n+pub fn main() {\n+    roundtrip::<A>();\n+    roundtrip::<B>();\n+    roundtrip::<C>();\n+    roundtrip::<D>();\n+\n+    for 20.times {\n+        roundtrip::<E>();\n+        roundtrip::<F>();\n+        roundtrip::<G<int>>();\n+    }\n+}"}]}