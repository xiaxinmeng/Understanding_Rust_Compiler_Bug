{"sha": "8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiODZiMjhmNTBkN2M4ZmRiYmQ1ZjA0NWZlNWZlZmRkMzE0NjMyZGM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-14T23:51:46Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-08-16T18:04:28Z"}, "message": "Use LocalDefId instead of HirId for reachable_set elements.", "tree": {"sha": "10cea15adbf1a33dbf0c62936d14ef062e77eb61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10cea15adbf1a33dbf0c62936d14ef062e77eb61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc", "html_url": "https://github.com/rust-lang/rust/commit/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a4fb355c6ce4e534e0998d83b68591bbe234ddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4fb355c6ce4e534e0998d83b68591bbe234ddb", "html_url": "https://github.com/rust-lang/rust/commit/7a4fb355c6ce4e534e0998d83b68591bbe234ddb"}], "stats": {"total": 112, "additions": 55, "deletions": 57}, "files": [{"sha": "51cc1ada432dc7bf9b47c29bf4086db92a5544be", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc", "patch": "@@ -61,7 +61,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n     let mut reachable_non_generics: DefIdMap<_> = tcx\n         .reachable_set(LOCAL_CRATE)\n         .iter()\n-        .filter_map(|&hir_id| {\n+        .filter_map(|&def_id| {\n             // We want to ignore some FFI functions that are not exposed from\n             // this crate. Reachable FFI functions can be lumped into two\n             // categories:\n@@ -75,9 +75,8 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get(hir_id) {\n+            match tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n                 Node::ForeignItem(..) => {\n-                    let def_id = tcx.hir().local_def_id(hir_id);\n                     tcx.is_statically_included_foreign_item(def_id).then_some(def_id)\n                 }\n \n@@ -87,7 +86,6 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                     ..\n                 })\n                 | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n-                    let def_id = tcx.hir().local_def_id(hir_id);\n                     let generics = tcx.generics_of(def_id);\n                     if !generics.requires_monomorphization(tcx)\n                         // Functions marked with #[inline] are codegened with \"internal\"\n@@ -361,7 +359,7 @@ fn upstream_drop_glue_for_provider<'tcx>(\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(def_id) = def_id.as_local() {\n-        !tcx.reachable_set(LOCAL_CRATE).contains(&tcx.hir().local_def_id_to_hir_id(def_id))\n+        !tcx.reachable_set(LOCAL_CRATE).contains(&def_id)\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\", def_id)\n     }"}, {"sha": "d874edf627472362fd7740a067c0c278405a3a60", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc", "patch": "@@ -740,7 +740,8 @@ rustc_queries! {\n     }\n \n     Other {\n-        query reachable_set(_: CrateNum) -> &'tcx HirIdSet {\n+        query reachable_set(_: CrateNum) -> FxHashSet<LocalDefId> {\n+            storage(ArenaCacheSelector<'tcx>)\n             desc { \"reachability\" }\n         }\n "}, {"sha": "4d820f75c56c457da3cb5a12e1c30cf5df6f1202", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc", "patch": "@@ -43,7 +43,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n-use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n+use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::utils::NativeLibKind;"}, {"sha": "8d5c980609cd9a99c7d921e1ce4acf19bfadd8ce", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=8b86b28f50d7c8fdbbd5f045fe5fefdd314632dc", "patch": "@@ -12,11 +12,11 @@ use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{HirIdSet, Node};\n+use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::middle::privacy;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::CrateType;\n use rustc_target::spec::abi::Abi;\n \n@@ -65,10 +65,11 @@ struct ReachableContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: HirIdSet,\n+    reachable_symbols: FxHashSet<LocalDefId>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: Vec<hir::HirId>,\n+    // FIXME(eddyb) benchmark if this would be faster as a `VecDeque`.\n+    worklist: Vec<LocalDefId>,\n     // Whether any output of this compilation is a library\n     any_library: bool,\n }\n@@ -100,37 +101,27 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n             _ => None,\n         };\n \n-        match res {\n-            Some(Res::Local(hir_id)) => {\n-                self.reachable_symbols.insert(hir_id);\n-            }\n-            Some(res) => {\n-                if let Some((hir_id, def_id)) = res.opt_def_id().and_then(|def_id| {\n-                    def_id\n-                        .as_local()\n-                        .map(|def_id| (self.tcx.hir().local_def_id_to_hir_id(def_id), def_id))\n-                }) {\n-                    if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n-                        self.worklist.push(hir_id);\n-                    } else {\n-                        match res {\n-                            // If this path leads to a constant, then we need to\n-                            // recurse into the constant to continue finding\n-                            // items that are reachable.\n-                            Res::Def(DefKind::Const | DefKind::AssocConst, _) => {\n-                                self.worklist.push(hir_id);\n-                            }\n+        if let Some(res) = res {\n+            if let Some(def_id) = res.opt_def_id().and_then(|def_id| def_id.as_local()) {\n+                if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n+                    self.worklist.push(def_id);\n+                } else {\n+                    match res {\n+                        // If this path leads to a constant, then we need to\n+                        // recurse into the constant to continue finding\n+                        // items that are reachable.\n+                        Res::Def(DefKind::Const | DefKind::AssocConst, _) => {\n+                            self.worklist.push(def_id);\n+                        }\n \n-                            // If this wasn't a static, then the destination is\n-                            // surely reachable.\n-                            _ => {\n-                                self.reachable_symbols.insert(hir_id);\n-                            }\n+                        // If this wasn't a static, then the destination is\n+                        // surely reachable.\n+                        _ => {\n+                            self.reachable_symbols.insert(def_id);\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr)\n@@ -209,13 +200,15 @@ impl<'tcx> ReachableContext<'tcx> {\n                 continue;\n             }\n \n-            if let Some(ref item) = self.tcx.hir().find(search_item) {\n+            if let Some(ref item) =\n+                self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(search_item))\n+            {\n                 self.propagate_node(item, search_item);\n             }\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &Node<'tcx>, search_item: hir::HirId) {\n+    fn propagate_node(&mut self, node: &Node<'tcx>, search_item: LocalDefId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n@@ -297,8 +290,9 @@ impl<'tcx> ReachableContext<'tcx> {\n                     self.visit_nested_body(body);\n                 }\n                 hir::ImplItemKind::Fn(_, body) => {\n-                    let did = self.tcx.hir().get_parent_did(search_item);\n-                    if method_might_be_inlined(self.tcx, impl_item, did) {\n+                    let impl_def_id =\n+                        self.tcx.parent(search_item.to_def_id()).unwrap().expect_local();\n+                    if method_might_be_inlined(self.tcx, impl_item, impl_def_id) {\n                         self.visit_nested_body(body)\n                     }\n                 }\n@@ -317,7 +311,9 @@ impl<'tcx> ReachableContext<'tcx> {\n             _ => {\n                 bug!(\n                     \"found unexpected node kind in worklist: {} ({:?})\",\n-                    self.tcx.hir().node_to_string(search_item),\n+                    self.tcx\n+                        .hir()\n+                        .node_to_string(self.tcx.hir().local_def_id_to_hir_id(search_item)),\n                     node,\n                 );\n             }\n@@ -336,7 +332,7 @@ impl<'tcx> ReachableContext<'tcx> {\n struct CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n-    worklist: &'a mut Vec<hir::HirId>,\n+    worklist: &'a mut Vec<LocalDefId>,\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n@@ -349,13 +345,16 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         if codegen_attrs.contains_extern_indicator()\n             || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n         {\n-            self.worklist.push(item.hir_id);\n+            self.worklist.push(def_id);\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemKind::Impl { of_trait: Some(ref trait_ref), ref items, .. } = item.kind {\n             if !self.access_levels.is_reachable(item.hir_id) {\n-                self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.hir_id));\n+                // FIXME(#53488) remove `let`\n+                let tcx = self.tcx;\n+                self.worklist\n+                    .extend(items.iter().map(|ii_ref| tcx.hir().local_def_id(ii_ref.id.hir_id)));\n \n                 let trait_def_id = match trait_ref.path.res {\n                     Res::Def(DefKind::Trait, def_id) => def_id,\n@@ -366,12 +365,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n                     return;\n                 }\n \n-                // FIXME(#53488) remove `let`\n-                let tcx = self.tcx;\n-                self.worklist\n-                    .extend(tcx.provided_trait_methods(trait_def_id).map(|assoc| {\n-                        tcx.hir().local_def_id_to_hir_id(assoc.def_id.expect_local())\n-                    }));\n+                self.worklist.extend(\n+                    tcx.provided_trait_methods(trait_def_id)\n+                        .map(|assoc| assoc.def_id.expect_local()),\n+                );\n             }\n         }\n     }\n@@ -383,7 +380,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n     }\n }\n \n-fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet {\n+fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> FxHashSet<LocalDefId> {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n@@ -405,11 +402,13 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n+    reachable_context\n+        .worklist\n+        .extend(access_levels.map.iter().map(|(id, _)| tcx.hir().local_def_id(*id)));\n     for item in tcx.lang_items().items().iter() {\n-        if let Some(did) = *item {\n-            if let Some(hir_id) = did.as_local().map(|did| tcx.hir().local_def_id_to_hir_id(did)) {\n-                reachable_context.worklist.push(hir_id);\n+        if let Some(def_id) = *item {\n+            if let Some(def_id) = def_id.as_local() {\n+                reachable_context.worklist.push(def_id);\n             }\n         }\n     }\n@@ -428,7 +427,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     debug!(\"Inline reachability shows: {:?}\", reachable_context.reachable_symbols);\n \n     // Return the set of reachable symbols.\n-    tcx.arena.alloc(reachable_context.reachable_symbols)\n+    reachable_context.reachable_symbols\n }\n \n pub fn provide(providers: &mut Providers) {"}]}