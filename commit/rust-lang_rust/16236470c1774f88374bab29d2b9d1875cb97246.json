{"sha": "16236470c1774f88374bab29d2b9d1875cb97246", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MjM2NDcwYzE3NzRmODgzNzRiYWIyOWQyYjlkMTg3NWNiOTcyNDY=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-07-28T22:35:01Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-13T18:45:27Z"}, "message": "specialize io::copy to use copy_file_range, splice or sendfile\n\nCurrently it only applies to linux systems. It can be extended to make use\nof similar syscalls on other unix systems.", "tree": {"sha": "ee8ae7f56d50fa384ed77c9e3e99244912c56ab2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8ae7f56d50fa384ed77c9e3e99244912c56ab2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16236470c1774f88374bab29d2b9d1875cb97246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16236470c1774f88374bab29d2b9d1875cb97246", "html_url": "https://github.com/rust-lang/rust/commit/16236470c1774f88374bab29d2b9d1875cb97246", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16236470c1774f88374bab29d2b9d1875cb97246/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35debd4c111610317346f46d791f32551d449bd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/35debd4c111610317346f46d791f32551d449bd8", "html_url": "https://github.com/rust-lang/rust/commit/35debd4c111610317346f46d791f32551d449bd8"}], "stats": {"total": 620, "additions": 540, "deletions": 80}, "files": [{"sha": "c9fd20bd204b0cf88fb5aa6538559b210e6a9517", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=16236470c1774f88374bab29d2b9d1875cb97246", "patch": "@@ -1656,7 +1656,7 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// the length of the `to` file as reported by `metadata`.\n ///\n /// If you\u2019re wanting to copy the contents of one file to another and you\u2019re\n-/// working with [`File`]s, see the [`io::copy`] function.\n+/// working with [`File`]s, see the [`io::copy()`] function.\n ///\n /// # Platform-specific behavior\n ///"}, {"sha": "45291293655cb1c86b44c4f13c4f9089056a5547", "filename": "library/std/src/io/copy.rs", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=16236470c1774f88374bab29d2b9d1875cb97246", "patch": "@@ -0,0 +1,456 @@\n+use crate::io::{self, ErrorKind, Read, Write};\n+use crate::mem::MaybeUninit;\n+\n+/// Copies the entire contents of a reader into a writer.\n+///\n+/// This function will continuously read data from `reader` and then\n+/// write it into `writer` in a streaming fashion until `reader`\n+/// returns EOF.\n+///\n+/// On success, the total number of bytes that were copied from\n+/// `reader` to `writer` is returned.\n+///\n+/// If you\u2019re wanting to copy the contents of one file to another and you\u2019re\n+/// working with filesystem paths, see the [`fs::copy`] function.\n+///\n+/// [`fs::copy`]: crate::fs::copy\n+///\n+/// # Errors\n+///\n+/// This function will return an error immediately if any call to [`read`] or\n+/// [`write`] returns an error. All instances of [`ErrorKind::Interrupted`] are\n+/// handled by this function and the underlying operation is retried.\n+///\n+/// [`read`]: Read::read\n+/// [`write`]: Write::write\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::io;\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut reader: &[u8] = b\"hello\";\n+///     let mut writer: Vec<u8> = vec![];\n+///\n+///     io::copy(&mut reader, &mut writer)?;\n+///\n+///     assert_eq!(&b\"hello\"[..], &writer[..]);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+where\n+    R: Read,\n+    W: Write,\n+{\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    {\n+        kernel_copy::copy_spec(reader, writer)\n+    }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    generic_copy(reader, writer)\n+}\n+\n+pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+where\n+    R: Read,\n+    W: Write,\n+{\n+    let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n+    // FIXME: #42788\n+    //\n+    //   - This creates a (mut) reference to a slice of\n+    //     _uninitialized_ integers, which is **undefined behavior**\n+    //\n+    //   - Only the standard library gets to soundly \"ignore\" this,\n+    //     based on its privileged knowledge of unstable rustc\n+    //     internals;\n+    unsafe {\n+        reader.initializer().initialize(buf.assume_init_mut());\n+    }\n+\n+    let mut written = 0;\n+    loop {\n+        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n+            Ok(0) => return Ok(written),\n+            Ok(len) => len,\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+            Err(e) => return Err(e),\n+        };\n+        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n+        written += len as u64;\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+mod kernel_copy {\n+\n+    use crate::cmp::min;\n+    use crate::convert::TryInto;\n+    use crate::fs::{File, Metadata};\n+    use crate::io::{\n+        BufRead, BufReader, BufWriter, Read, Result, StderrLock, StdinLock, StdoutLock, Take, Write,\n+    };\n+    use crate::mem::ManuallyDrop;\n+    use crate::net::TcpStream;\n+    use crate::os::unix::fs::FileTypeExt;\n+    use crate::os::unix::io::{AsRawFd, FromRawFd, RawFd};\n+    use crate::process::{ChildStderr, ChildStdin, ChildStdout};\n+\n+    pub(super) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n+        read: &mut R,\n+        write: &mut W,\n+    ) -> Result<u64> {\n+        let copier = Copier { read, write };\n+        SpecCopy::copy(copier)\n+    }\n+\n+    enum FdMeta {\n+        Metadata(Metadata),\n+        Socket,\n+        Pipe,\n+        None,\n+    }\n+\n+    impl FdMeta {\n+        fn is_fifo(&self) -> bool {\n+            match self {\n+                FdMeta::Metadata(meta) => meta.file_type().is_fifo(),\n+                FdMeta::Socket => false,\n+                FdMeta::Pipe => true,\n+                FdMeta::None => false,\n+            }\n+        }\n+    }\n+\n+    struct CopyParams(FdMeta, Option<RawFd>);\n+\n+    struct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n+        pub read: &'a mut R,\n+        pub write: &'b mut W,\n+    }\n+\n+    trait SpecCopy {\n+        fn copy(self) -> Result<u64>;\n+    }\n+\n+    impl<R: Read + ?Sized, W: Write + ?Sized> SpecCopy for Copier<'_, '_, R, W> {\n+        default fn copy(self) -> Result<u64> {\n+            super::generic_copy(self.read, self.write)\n+        }\n+    }\n+\n+    impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n+        fn copy(self) -> Result<u64> {\n+            let (reader, writer) = (self.read, self.write);\n+            let r_cfg = reader.properties();\n+            let w_cfg = writer.properties();\n+\n+            // before direct operations  on file descriptors ensure that all source and sink buffers are emtpy\n+            let mut flush = || -> crate::io::Result<u64> {\n+                let bytes = reader.drain_to(writer, u64::MAX)?;\n+                writer.flush()?;\n+                Ok(bytes)\n+            };\n+\n+            match (r_cfg, w_cfg) {\n+                (\n+                    CopyParams(FdMeta::Metadata(reader_meta), Some(readfd)),\n+                    CopyParams(FdMeta::Metadata(writer_meta), Some(writefd)),\n+                ) if reader_meta.is_file() && writer_meta.is_file() => {\n+                    let bytes_flushed = flush()?;\n+                    let max_write = reader.min_limit();\n+                    let (mut reader, mut writer) =\n+                        unsafe { (fd_as_file(readfd), fd_as_file(writefd)) };\n+                    let len = reader_meta.len();\n+                    crate::sys::fs::copy_regular_files(\n+                        &mut reader,\n+                        &mut writer,\n+                        min(len, max_write),\n+                    )\n+                    .map(|bytes_copied| bytes_copied + bytes_flushed)\n+                }\n+                (CopyParams(reader_meta, Some(readfd)), CopyParams(writer_meta, Some(writefd)))\n+                    if reader_meta.is_fifo() || writer_meta.is_fifo() =>\n+                {\n+                    // splice\n+                    let bytes_flushed = flush()?;\n+                    let max_write = reader.min_limit();\n+                    let (mut reader, mut writer) =\n+                        unsafe { (fd_as_file(readfd), fd_as_file(writefd)) };\n+                    crate::sys::fs::sendfile_splice(\n+                        crate::sys::fs::SpliceMode::Splice,\n+                        &mut reader,\n+                        &mut writer,\n+                        max_write,\n+                    )\n+                    .map(|bytes_sent| bytes_sent + bytes_flushed)\n+                }\n+                (\n+                    CopyParams(FdMeta::Metadata(reader_meta), Some(readfd)),\n+                    CopyParams(_, Some(writefd)),\n+                ) if reader_meta.is_file() => {\n+                    // try sendfile, most modern systems it should work with any target as long as the source is a mmapable file.\n+                    // in the rare cases where it's no supported the wrapper function will fall back to a normal copy loop\n+                    let bytes_flushed = flush()?;\n+                    let (mut reader, mut writer) =\n+                        unsafe { (fd_as_file(readfd), fd_as_file(writefd)) };\n+                    let len = reader_meta.len();\n+                    let max_write = reader.min_limit();\n+                    crate::sys::fs::sendfile_splice(\n+                        crate::sys::fs::SpliceMode::Sendfile,\n+                        &mut reader,\n+                        &mut writer,\n+                        min(len, max_write),\n+                    )\n+                    .map(|bytes_sent| bytes_sent + bytes_flushed)\n+                }\n+                _ => super::generic_copy(reader, writer),\n+            }\n+        }\n+    }\n+\n+    #[rustc_specialization_trait]\n+    trait CopyRead: Read {\n+        fn drain_to<W: Write>(&mut self, _writer: &mut W, _limit: u64) -> Result<u64> {\n+            Ok(0)\n+        }\n+\n+        /// The minimum of the limit of all `Take<_>` wrappers, `u64::MAX` otherwise.\n+        /// This method does not account for data `BufReader` buffers and would underreport\n+        /// the limit of a `Take<BufReader<Take<_>>>` type. Thus its result is only valid\n+        /// after draining the buffers.\n+        fn min_limit(&self) -> u64 {\n+            u64::MAX\n+        }\n+\n+        fn properties(&self) -> CopyParams;\n+    }\n+\n+    #[rustc_specialization_trait]\n+    trait CopyWrite: Write {\n+        fn properties(&self) -> CopyParams;\n+    }\n+\n+    impl CopyRead for File {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyRead for &File {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyWrite for File {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyWrite for &File {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyRead for TcpStream {\n+        fn properties(&self) -> CopyParams {\n+            // avoid the stat syscall since we can be fairly sure it's a socket\n+            CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyRead for &TcpStream {\n+        fn properties(&self) -> CopyParams {\n+            // avoid the stat syscall since we can be fairly sure it's a socket\n+            CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyWrite for TcpStream {\n+        fn properties(&self) -> CopyParams {\n+            // avoid the stat syscall since we can be fairly sure it's a socket\n+            CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyWrite for &TcpStream {\n+        fn properties(&self) -> CopyParams {\n+            // avoid the stat syscall since we can be fairly sure it's a socket\n+            CopyParams(FdMeta::Socket, Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyWrite for ChildStdin {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyRead for ChildStdout {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyRead for ChildStderr {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(FdMeta::Pipe, Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyRead for StdinLock<'_> {\n+        fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+            let buf_reader = self.as_mut_buf();\n+            let buf = buf_reader.buffer();\n+            let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n+            let bytes_drained = buf.len();\n+            writer.write_all(buf)?;\n+            buf_reader.consume(bytes_drained);\n+\n+            Ok(bytes_drained as u64)\n+        }\n+\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyWrite for StdoutLock<'_> {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl CopyWrite for StderrLock<'_> {\n+        fn properties(&self) -> CopyParams {\n+            CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n+        }\n+    }\n+\n+    impl<T: CopyRead> CopyRead for Take<T> {\n+        fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+            let local_limit = self.limit();\n+            let combined_limit = min(outer_limit, local_limit);\n+            let bytes_drained = self.get_mut().drain_to(writer, combined_limit)?;\n+            // update limit since read() was bypassed\n+            self.set_limit(local_limit - bytes_drained);\n+\n+            Ok(bytes_drained)\n+        }\n+\n+        fn min_limit(&self) -> u64 {\n+            min(Take::limit(self), self.get_ref().min_limit())\n+        }\n+\n+        fn properties(&self) -> CopyParams {\n+            self.get_ref().properties()\n+        }\n+    }\n+\n+    impl<T: CopyRead> CopyRead for BufReader<T> {\n+        fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n+            let buf = self.buffer();\n+            let buf = &buf[0..min(buf.len(), outer_limit.try_into().unwrap_or(usize::MAX))];\n+            let bytes = buf.len();\n+            writer.write_all(buf)?;\n+            self.consume(bytes);\n+\n+            let remaining = outer_limit - bytes as u64;\n+\n+            // in case of nested bufreaders we also need to drain the ones closer to the source\n+            let inner_bytes = self.get_mut().drain_to(writer, remaining)?;\n+\n+            Ok(bytes as u64 + inner_bytes)\n+        }\n+\n+        fn min_limit(&self) -> u64 {\n+            self.get_ref().min_limit()\n+        }\n+\n+        fn properties(&self) -> CopyParams {\n+            self.get_ref().properties()\n+        }\n+    }\n+\n+    impl<T: CopyWrite> CopyWrite for BufWriter<T> {\n+        fn properties(&self) -> CopyParams {\n+            self.get_ref().properties()\n+        }\n+    }\n+\n+    fn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n+        let fd = fd.as_raw_fd();\n+        let file: ManuallyDrop<File> = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });\n+        match file.metadata() {\n+            Ok(meta) => FdMeta::Metadata(meta),\n+            Err(_) => FdMeta::None,\n+        }\n+    }\n+\n+    unsafe fn fd_as_file(fd: RawFd) -> ManuallyDrop<File> {\n+        ManuallyDrop::new(File::from_raw_fd(fd))\n+    }\n+\n+    #[cfg(test)]\n+    mod tests {\n+\n+        use crate::io::{BufRead, BufReader, BufWriter, Read, Result, Seek, SeekFrom, Write};\n+\n+        #[test]\n+        fn copy_specialization() -> Result<()> {\n+            let path = crate::env::temp_dir();\n+            let source_path = path.join(\"copy-spec.source\");\n+            let sink_path = path.join(\"copy-spec.sink\");\n+\n+            let result: Result<()> = try {\n+                let mut source = crate::fs::OpenOptions::new()\n+                    .read(true)\n+                    .write(true)\n+                    .create(true)\n+                    .truncate(true)\n+                    .open(&source_path)?;\n+                source.write_all(b\"abcdefghiklmnopqr\")?;\n+                source.seek(SeekFrom::Start(8))?;\n+                let mut source = BufReader::with_capacity(8, source.take(5));\n+                source.fill_buf()?;\n+                assert_eq!(source.buffer(), b\"iklmn\");\n+                source.get_mut().set_limit(6);\n+                source.get_mut().get_mut().seek(SeekFrom::Start(1))?; // \"bcdefg\"\n+                let mut source = source.take(10); // \"iklmnbcdef\"\n+\n+                let mut sink = crate::fs::OpenOptions::new()\n+                    .read(true)\n+                    .write(true)\n+                    .create(true)\n+                    .truncate(true)\n+                    .open(&sink_path)?;\n+                sink.write_all(b\"000000\")?;\n+                let mut sink = BufWriter::with_capacity(5, sink);\n+                sink.write_all(b\"wxyz\")?;\n+                assert_eq!(sink.buffer(), b\"wxyz\");\n+\n+                let copied = crate::io::copy(&mut source, &mut sink)?;\n+                assert_eq!(copied, 10);\n+                assert_eq!(sink.buffer().len(), 0);\n+\n+                let mut sink = sink.into_inner()?;\n+                sink.seek(SeekFrom::Start(0))?;\n+                let mut copied = Vec::new();\n+                sink.read_to_end(&mut copied)?;\n+                assert_eq!(&copied, b\"000000wxyziklmnbcdef\");\n+            };\n+\n+            let rm1 = crate::fs::remove_file(source_path);\n+            let rm2 = crate::fs::remove_file(sink_path);\n+\n+            result.and(rm1).and(rm2)\n+        }\n+    }\n+}"}, {"sha": "0529b42347e23ebd53dcdbd0ed68675fa2b79075", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=16236470c1774f88374bab29d2b9d1875cb97246", "patch": "@@ -266,6 +266,8 @@ pub use self::buffered::IntoInnerError;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::{BufReader, BufWriter, LineWriter};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::copy::copy;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::cursor::Cursor;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::error::{Error, ErrorKind, Result};\n@@ -279,9 +281,12 @@ pub use self::stdio::{_eprint, _print};\n #[doc(no_inline, hidden)]\n pub use self::stdio::{set_panic, set_print};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::util::{copy, empty, repeat, sink, Empty, Repeat, Sink};\n+pub use self::util::{empty, repeat, sink, Empty, Repeat, Sink};\n+\n+pub(crate) use self::copy::generic_copy;\n \n mod buffered;\n+mod copy;\n mod cursor;\n mod error;\n mod impls;"}, {"sha": "47ff13f5298639cb5a2ea4cfae5ff2923579421e", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=16236470c1774f88374bab29d2b9d1875cb97246", "patch": "@@ -409,6 +409,12 @@ impl Read for Stdin {\n     }\n }\n \n+impl StdinLock<'_> {\n+    pub(crate) fn as_mut_buf(&mut self) -> &mut BufReader<impl Read> {\n+        &mut self.inner\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for StdinLock<'_> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {"}, {"sha": "ba80eb46599ba66c70e70004eb25ff397afaa6bf", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 1, "deletions": 72, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=16236470c1774f88374bab29d2b9d1875cb97246", "patch": "@@ -4,78 +4,7 @@\n mod tests;\n \n use crate::fmt;\n-use crate::io::{self, BufRead, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Write};\n-use crate::mem::MaybeUninit;\n-\n-/// Copies the entire contents of a reader into a writer.\n-///\n-/// This function will continuously read data from `reader` and then\n-/// write it into `writer` in a streaming fashion until `reader`\n-/// returns EOF.\n-///\n-/// On success, the total number of bytes that were copied from\n-/// `reader` to `writer` is returned.\n-///\n-/// If you\u2019re wanting to copy the contents of one file to another and you\u2019re\n-/// working with filesystem paths, see the [`fs::copy`] function.\n-///\n-/// [`fs::copy`]: crate::fs::copy\n-///\n-/// # Errors\n-///\n-/// This function will return an error immediately if any call to [`read`] or\n-/// [`write`] returns an error. All instances of [`ErrorKind::Interrupted`] are\n-/// handled by this function and the underlying operation is retried.\n-///\n-/// [`read`]: Read::read\n-/// [`write`]: Write::write\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::io;\n-///\n-/// fn main() -> io::Result<()> {\n-///     let mut reader: &[u8] = b\"hello\";\n-///     let mut writer: Vec<u8> = vec![];\n-///\n-///     io::copy(&mut reader, &mut writer)?;\n-///\n-///     assert_eq!(&b\"hello\"[..], &writer[..]);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n-where\n-    R: Read,\n-    W: Write,\n-{\n-    let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n-    // FIXME: #42788\n-    //\n-    //   - This creates a (mut) reference to a slice of\n-    //     _uninitialized_ integers, which is **undefined behavior**\n-    //\n-    //   - Only the standard library gets to soundly \"ignore\" this,\n-    //     based on its privileged knowledge of unstable rustc\n-    //     internals;\n-    unsafe {\n-        reader.initializer().initialize(buf.assume_init_mut());\n-    }\n-\n-    let mut written = 0;\n-    loop {\n-        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n-            Ok(0) => return Ok(written),\n-            Ok(len) => len,\n-            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n-            Err(e) => return Err(e),\n-        };\n-        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n-        written += len as u64;\n-    }\n-}\n+use crate::io::{self, BufRead, Initializer, IoSlice, IoSliceMut, Read, Write};\n \n /// A reader which is always at EOF.\n ///"}, {"sha": "bf4ec9c8b644bdd881174c442e437de0c7eb2432", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=16236470c1774f88374bab29d2b9d1875cb97246", "patch": "@@ -316,6 +316,7 @@\n #![feature(toowned_clone_into)]\n #![feature(total_cmp)]\n #![feature(trace_macros)]\n+#![feature(try_blocks)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_block_in_unsafe_fn)]"}, {"sha": "012e4a16b9f8458a83a70afea47e81252b746795", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16236470c1774f88374bab29d2b9d1875cb97246/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=16236470c1774f88374bab29d2b9d1875cb97246", "patch": "@@ -1191,6 +1191,21 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    let (mut reader, reader_metadata) = open_from(from)?;\n+    let max_len = u64::MAX;\n+    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n+\n+    copy_regular_files(&mut reader, &mut writer, max_len)\n+}\n+\n+/// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n+/// as the name says, it only works on regular files\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub(crate) fn copy_regular_files(\n+    reader: &mut crate::fs::File,\n+    writer: &mut crate::fs::File,\n+    max_len: u64,\n+) -> io::Result<u64> {\n     use crate::cmp;\n     use crate::sync::atomic::{AtomicBool, Ordering};\n \n@@ -1209,10 +1224,6 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         libc::syscall(libc::SYS_copy_file_range, fd_in, off_in, fd_out, off_out, len, flags)\n     }\n \n-    let (mut reader, reader_metadata) = open_from(from)?;\n-    let max_len = u64::MAX;\n-    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n-\n     let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n     let mut written = 0u64;\n     while written < max_len {\n@@ -1249,7 +1260,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n                 // - reading virtual files from the proc filesystem which appear to have 0 size\n                 //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n                 // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n-                return io::copy(&mut reader, &mut writer);\n+                return io::copy(reader, writer);\n             }\n             Ok(0) => return Ok(written), // reached EOF\n             Ok(ret) => written += ret as u64,\n@@ -1265,7 +1276,59 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n                         // - copy_file_range is disallowed, for example by seccomp (EPERM)\n                         // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n                         assert_eq!(written, 0);\n-                        return io::copy(&mut reader, &mut writer);\n+                        return io::generic_copy(reader, writer);\n+                    }\n+                    _ => return Err(err),\n+                }\n+            }\n+        }\n+    }\n+    Ok(written)\n+}\n+\n+pub(crate) enum SpliceMode {\n+    Sendfile,\n+    Splice,\n+}\n+\n+/// performs splice or sendfile between file descriptors\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+pub(crate) fn sendfile_splice(\n+    mode: SpliceMode,\n+    reader: &mut crate::fs::File,\n+    writer: &mut crate::fs::File,\n+    len: u64,\n+) -> io::Result<u64> {\n+    let mut written = 0u64;\n+    while written < len {\n+        let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n+\n+        let result = match mode {\n+            SpliceMode::Sendfile => cvt(unsafe {\n+                libc::sendfile(writer.as_raw_fd(), reader.as_raw_fd(), ptr::null_mut(), chunk_size)\n+            }),\n+            SpliceMode::Splice => cvt(unsafe {\n+                libc::splice(\n+                    reader.as_raw_fd(),\n+                    ptr::null_mut(),\n+                    writer.as_raw_fd(),\n+                    ptr::null_mut(),\n+                    chunk_size,\n+                    0,\n+                )\n+            }),\n+        };\n+\n+        match result {\n+            Ok(0) => break, // EOF\n+            Ok(ret) => written += ret as u64,\n+            Err(err) => {\n+                match err.raw_os_error() {\n+                    Some(os_err) if os_err == libc::EINVAL => {\n+                        // Try fallback io::copy if splice/sendfile do not support this particular\n+                        // file descritor (EINVAL)\n+                        assert_eq!(written, 0);\n+                        return io::generic_copy(reader, writer);\n                     }\n                     _ => return Err(err),\n                 }"}]}