{"sha": "8909ac97d52a8b099fd334d84db1073839e16b16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MDlhYzk3ZDUyYThiMDk5ZmQzMzRkODRkYjEwNzM4MzllMTZiMTY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-23T07:42:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-23T07:42:14Z"}, "message": "Rollup merge of #74606 - cuviper:cloexec, r=sfackler\n\nRemove Linux workarounds for missing CLOEXEC support\n\nNow that #74163 updated the minimum Linux kernel to 2.6.32, we can\nassume the availability of APIs that open file descriptors that are\nalready set to close on exec, including the flags `O_CLOEXEC`,\n`SOCK_CLOEXEC`, and `F_DUPFD_CLOEXEC`.\n\nCloses #74519.", "tree": {"sha": "5c22a4427333f6b7ddf4c081383d513aa66aeb96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c22a4427333f6b7ddf4c081383d513aa66aeb96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8909ac97d52a8b099fd334d84db1073839e16b16", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGT9WCRBK7hj4Ov3rIwAAdHIIALBGnav/mGKQrkKXiPXwIXDq\nJg7RwvLTEAKAP/kpPp5OZjUTxAhx4lsQtwHBwbdMPX7T2rFwUKRbKYvInXoewqaf\n8xBf4AtRTFJxH3sxCcPHI6P+kEM7EeOJ4UrMLCkE0x2NGFNj2tZujnnRa0PxX7Jq\nr5GriPoG21Qh5f6hxcpqDuHF/T/1zYLrCk5a1GRE//jiWoaYu7j3R9LFyN/I+tji\noFjAp/8VQ+SPSux7SG70cRdNmmZwucLSn+hTctYclUSUUjURNHUT6ksMZdAcxmrg\n41WGvNBtCEQASLNw6XcEHbLWCksdc95HGhPOfV+RAIZTIsiDfv9KAiYq0c+F6kg=\n=7MpD\n-----END PGP SIGNATURE-----\n", "payload": "tree 5c22a4427333f6b7ddf4c081383d513aa66aeb96\nparent bea2eedcb5cb08c08069db554abe7880a3dfd693\nparent ae06e13b8de23722d8bf2fb0143581df07848aa8\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595490134 -0700\ncommitter GitHub <noreply@github.com> 1595490134 -0700\n\nRollup merge of #74606 - cuviper:cloexec, r=sfackler\n\nRemove Linux workarounds for missing CLOEXEC support\n\nNow that #74163 updated the minimum Linux kernel to 2.6.32, we can\nassume the availability of APIs that open file descriptors that are\nalready set to close on exec, including the flags `O_CLOEXEC`,\n`SOCK_CLOEXEC`, and `F_DUPFD_CLOEXEC`.\n\nCloses #74519.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8909ac97d52a8b099fd334d84db1073839e16b16", "html_url": "https://github.com/rust-lang/rust/commit/8909ac97d52a8b099fd334d84db1073839e16b16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8909ac97d52a8b099fd334d84db1073839e16b16/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bea2eedcb5cb08c08069db554abe7880a3dfd693", "url": "https://api.github.com/repos/rust-lang/rust/commits/bea2eedcb5cb08c08069db554abe7880a3dfd693", "html_url": "https://github.com/rust-lang/rust/commit/bea2eedcb5cb08c08069db554abe7880a3dfd693"}, {"sha": "ae06e13b8de23722d8bf2fb0143581df07848aa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae06e13b8de23722d8bf2fb0143581df07848aa8", "html_url": "https://github.com/rust-lang/rust/commit/ae06e13b8de23722d8bf2fb0143581df07848aa8"}], "stats": {"total": 269, "additions": 74, "deletions": 195}, "files": [{"sha": "84c4d662161bca7fac8a938c71e5799618787e10", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=8909ac97d52a8b099fd334d84db1073839e16b16", "patch": "@@ -3,7 +3,6 @@\n use crate::cmp;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n use crate::mem;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::cvt;\n use crate::sys_common::AsInner;\n \n@@ -224,50 +223,9 @@ impl FileDesc {\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n         // We want to atomically duplicate this file descriptor and set the\n         // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n-        // flag, however, isn't supported on older Linux kernels (earlier than\n-        // 2.6.24).\n-        //\n-        // To detect this and ensure that CLOEXEC is still set, we\n-        // follow a strategy similar to musl [1] where if passing\n-        // F_DUPFD_CLOEXEC causes `fcntl` to return EINVAL it means it's not\n-        // supported (the third parameter, 0, is always valid), so we stop\n-        // trying that.\n-        //\n-        // Also note that Android doesn't have F_DUPFD_CLOEXEC, but get it to\n-        // resolve so we at least compile this.\n-        //\n-        // [1]: http://comments.gmane.org/gmane.linux.lib.musl.general/2963\n-        #[cfg(any(target_os = \"android\", target_os = \"haiku\"))]\n-        use libc::F_DUPFD as F_DUPFD_CLOEXEC;\n-        #[cfg(not(any(target_os = \"android\", target_os = \"haiku\")))]\n-        use libc::F_DUPFD_CLOEXEC;\n-\n-        let make_filedesc = |fd| {\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec()?;\n-            Ok(fd)\n-        };\n-        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(!cfg!(target_os = \"android\"));\n-        let fd = self.raw();\n-        if TRY_CLOEXEC.load(Ordering::Relaxed) {\n-            match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n-                // We *still* call the `set_cloexec` method as apparently some\n-                // linux kernel at some point stopped setting CLOEXEC even\n-                // though it reported doing so on F_DUPFD_CLOEXEC.\n-                Ok(fd) => {\n-                    return Ok(if cfg!(target_os = \"linux\") {\n-                        make_filedesc(fd)?\n-                    } else {\n-                        FileDesc::new(fd)\n-                    });\n-                }\n-                Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n-                    TRY_CLOEXEC.store(false, Ordering::Relaxed);\n-                }\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD, 0) }).and_then(make_filedesc)\n+        // is a POSIX flag that was added to Linux in 2.6.24.\n+        let fd = cvt(unsafe { libc::fcntl(self.raw(), libc::F_DUPFD_CLOEXEC, 0) })?;\n+        Ok(FileDesc::new(fd))\n     }\n }\n "}, {"sha": "acb18e6d064e6e826d0e3910035e12fd516f1e98", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=8909ac97d52a8b099fd334d84db1073839e16b16", "patch": "@@ -708,56 +708,7 @@ impl File {\n         // However, since this is a variadic function, C integer promotion rules mean that on\n         // the ABI level, this still gets passed as `c_int` (aka `u32` on Unix platforms).\n         let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;\n-        let fd = FileDesc::new(fd);\n-\n-        // Currently the standard library supports Linux 2.6.18 which did not\n-        // have the O_CLOEXEC flag (passed above). If we're running on an older\n-        // Linux kernel then the flag is just ignored by the OS. After we open\n-        // the first file, we check whether it has CLOEXEC set. If it doesn't,\n-        // we will explicitly ask for a CLOEXEC fd for every further file we\n-        // open, if it does, we will skip that step.\n-        //\n-        // The CLOEXEC flag, however, is supported on versions of macOS/BSD/etc\n-        // that we support, so we only do this on Linux currently.\n-        #[cfg(target_os = \"linux\")]\n-        fn ensure_cloexec(fd: &FileDesc) -> io::Result<()> {\n-            use crate::sync::atomic::{AtomicUsize, Ordering};\n-\n-            const OPEN_CLOEXEC_UNKNOWN: usize = 0;\n-            const OPEN_CLOEXEC_SUPPORTED: usize = 1;\n-            const OPEN_CLOEXEC_NOTSUPPORTED: usize = 2;\n-            static OPEN_CLOEXEC: AtomicUsize = AtomicUsize::new(OPEN_CLOEXEC_UNKNOWN);\n-\n-            let need_to_set;\n-            match OPEN_CLOEXEC.load(Ordering::Relaxed) {\n-                OPEN_CLOEXEC_UNKNOWN => {\n-                    need_to_set = !fd.get_cloexec()?;\n-                    OPEN_CLOEXEC.store(\n-                        if need_to_set {\n-                            OPEN_CLOEXEC_NOTSUPPORTED\n-                        } else {\n-                            OPEN_CLOEXEC_SUPPORTED\n-                        },\n-                        Ordering::Relaxed,\n-                    );\n-                }\n-                OPEN_CLOEXEC_SUPPORTED => need_to_set = false,\n-                OPEN_CLOEXEC_NOTSUPPORTED => need_to_set = true,\n-                _ => unreachable!(),\n-            }\n-            if need_to_set {\n-                fd.set_cloexec()?;\n-            }\n-            Ok(())\n-        }\n-\n-        #[cfg(not(target_os = \"linux\"))]\n-        fn ensure_cloexec(_: &FileDesc) -> io::Result<()> {\n-            Ok(())\n-        }\n-\n-        ensure_cloexec(&fd)?;\n-        Ok(File(fd))\n+        Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {"}, {"sha": "011325fddc5b93b08304406256bcc748d7e8e3eb", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 42, "deletions": 61, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=8909ac97d52a8b099fd334d84db1073839e16b16", "patch": "@@ -54,56 +54,47 @@ impl Socket {\n \n     pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n         unsafe {\n-            // On linux we first attempt to pass the SOCK_CLOEXEC flag to\n-            // atomically create the socket and set it as CLOEXEC. Support for\n-            // this option, however, was added in 2.6.27, and we still support\n-            // 2.6.18 as a kernel, so if the returned error is EINVAL we\n-            // fallthrough to the fallback.\n-            #[cfg(target_os = \"linux\")]\n-            {\n-                match cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0)) {\n-                    Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n-            let fd = cvt(libc::socket(fam, ty, 0))?;\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec()?;\n-            let socket = Socket(fd);\n+            cfg_if::cfg_if! {\n+                if #[cfg(target_os = \"linux\")] {\n+                    // On Linux we pass the SOCK_CLOEXEC flag to atomically create\n+                    // the socket and set it as CLOEXEC, added in 2.6.27.\n+                    let fd = cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0))?;\n+                    Ok(Socket(FileDesc::new(fd)))\n+                } else {\n+                    let fd = cvt(libc::socket(fam, ty, 0))?;\n+                    let fd = FileDesc::new(fd);\n+                    fd.set_cloexec()?;\n+                    let socket = Socket(fd);\n \n-            // macOS and iOS use `SO_NOSIGPIPE` as a `setsockopt`\n-            // flag to disable `SIGPIPE` emission on socket.\n-            #[cfg(target_vendor = \"apple\")]\n-            setsockopt(&socket, libc::SOL_SOCKET, libc::SO_NOSIGPIPE, 1)?;\n+                    // macOS and iOS use `SO_NOSIGPIPE` as a `setsockopt`\n+                    // flag to disable `SIGPIPE` emission on socket.\n+                    #[cfg(target_vendor = \"apple\")]\n+                    setsockopt(&socket, libc::SOL_SOCKET, libc::SO_NOSIGPIPE, 1)?;\n \n-            Ok(socket)\n+                    Ok(socket)\n+                }\n+            }\n         }\n     }\n \n     pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {\n         unsafe {\n             let mut fds = [0, 0];\n \n-            // Like above, see if we can set cloexec atomically\n-            #[cfg(target_os = \"linux\")]\n-            {\n-                match cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr())) {\n-                    Ok(_) => {\n-                        return Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))));\n-                    }\n-                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n-                    Err(e) => return Err(e),\n+            cfg_if::cfg_if! {\n+                if #[cfg(target_os = \"linux\")] {\n+                    // Like above, set cloexec atomically\n+                    cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr()))?;\n+                    Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))))\n+                } else {\n+                    cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n+                    let a = FileDesc::new(fds[0]);\n+                    let b = FileDesc::new(fds[1]);\n+                    a.set_cloexec()?;\n+                    b.set_cloexec()?;\n+                    Ok((Socket(a), Socket(b)))\n                 }\n             }\n-\n-            cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n-            let a = FileDesc::new(fds[0]);\n-            let b = FileDesc::new(fds[1]);\n-            a.set_cloexec()?;\n-            b.set_cloexec()?;\n-            Ok((Socket(a), Socket(b)))\n         }\n     }\n \n@@ -177,30 +168,20 @@ impl Socket {\n     pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n         // Unfortunately the only known way right now to accept a socket and\n         // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n-        // Linux. This was added in 2.6.28, however, and because we support\n-        // 2.6.18 we must detect this support dynamically.\n-        #[cfg(target_os = \"linux\")]\n-        {\n-            syscall! {\n-                fn accept4(\n-                    fd: c_int,\n-                    addr: *mut sockaddr,\n-                    addr_len: *mut socklen_t,\n-                    flags: c_int\n-                ) -> c_int\n-            }\n-            let res = cvt_r(|| unsafe { accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC) });\n-            match res {\n-                Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n-                Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}\n-                Err(e) => return Err(e),\n+        // Linux. This was added in 2.6.28, glibc 2.10 and musl 0.9.5.\n+        cfg_if::cfg_if! {\n+            if #[cfg(target_os = \"linux\")] {\n+                let fd = cvt_r(|| unsafe {\n+                    libc::accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC)\n+                })?;\n+                Ok(Socket(FileDesc::new(fd)))\n+            } else {\n+                let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n+                let fd = FileDesc::new(fd);\n+                fd.set_cloexec()?;\n+                Ok(Socket(fd))\n             }\n         }\n-\n-        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n-        let fd = FileDesc::new(fd);\n-        fd.set_cloexec()?;\n-        Ok(Socket(fd))\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {"}, {"sha": "2fcb5b9c4e66e722098efde38810b1ab60389582", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=8909ac97d52a8b099fd334d84db1073839e16b16", "patch": "@@ -71,6 +71,7 @@ pub fn errno() -> i32 {\n \n /// Sets the platform-specific value of errno\n #[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\")))] // needed for readdir and syscall!\n+#[allow(dead_code)] // but not all target cfgs actually end up using it\n pub fn set_errno(e: i32) {\n     unsafe { *errno_location() = e as c_int }\n }"}, {"sha": "7ae37bdda70bded963b72d304b7abbbbfed904a9", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 22, "deletions": 39, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=8909ac97d52a8b099fd334d84db1073839e16b16", "patch": "@@ -1,58 +1,41 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::fd::FileDesc;\n use crate::sys::{cvt, cvt_r};\n \n-use libc::c_int;\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Anonymous pipes\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct AnonPipe(FileDesc);\n \n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    syscall! { fn pipe2(fds: *mut c_int, flags: c_int) -> c_int }\n-    static INVALID: AtomicBool = AtomicBool::new(false);\n-\n     let mut fds = [0; 2];\n \n-    // Unfortunately the only known way right now to create atomically set the\n-    // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n-    // 2.6.27, however, and because we support 2.6.18 we must detect this\n-    // support dynamically.\n-    if cfg!(any(\n-        target_os = \"dragonfly\",\n-        target_os = \"freebsd\",\n-        target_os = \"linux\",\n-        target_os = \"netbsd\",\n-        target_os = \"openbsd\",\n-        target_os = \"redox\"\n-    )) && !INVALID.load(Ordering::SeqCst)\n-    {\n-        // Note that despite calling a glibc function here we may still\n-        // get ENOSYS. Glibc has `pipe2` since 2.9 and doesn't try to\n-        // emulate on older kernels, so if you happen to be running on\n-        // an older kernel you may see `pipe2` as a symbol but still not\n-        // see the syscall.\n-        match cvt(unsafe { pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) }) {\n-            Ok(_) => {\n-                return Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))));\n-            }\n-            Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {\n-                INVALID.store(true, Ordering::SeqCst);\n-            }\n-            Err(e) => return Err(e),\n+    // The only known way right now to create atomically set the CLOEXEC flag is\n+    // to use the `pipe2` syscall. This was added to Linux in 2.6.27, glibc 2.9\n+    // and musl 0.9.3, and some other targets also have it.\n+    cfg_if::cfg_if! {\n+        if #[cfg(any(\n+            target_os = \"dragonfly\",\n+            target_os = \"freebsd\",\n+            target_os = \"linux\",\n+            target_os = \"netbsd\",\n+            target_os = \"openbsd\",\n+            target_os = \"redox\"\n+        ))] {\n+            cvt(unsafe { libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) })?;\n+            Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n+        } else {\n+            cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n+\n+            let fd0 = FileDesc::new(fds[0]);\n+            let fd1 = FileDesc::new(fds[1]);\n+            fd0.set_cloexec()?;\n+            fd1.set_cloexec()?;\n+            Ok((AnonPipe(fd0), AnonPipe(fd1)))\n         }\n     }\n-    cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n-\n-    let fd0 = FileDesc::new(fds[0]);\n-    let fd1 = FileDesc::new(fds[1]);\n-    fd0.set_cloexec()?;\n-    fd1.set_cloexec()?;\n-    Ok((AnonPipe(fd0), AnonPipe(fd1)))\n }\n \n impl AnonPipe {"}, {"sha": "f4b33a00f7c85d79d8b682be0884024283a529f0", "filename": "src/libstd/sys/unix/weak.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8909ac97d52a8b099fd334d84db1073839e16b16/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fweak.rs?ref=8909ac97d52a8b099fd334d84db1073839e16b16", "patch": "@@ -16,6 +16,11 @@\n //! symbol, but that caused Debian to detect an unnecessarily strict versioned\n //! dependency on libc6 (#23628).\n \n+// There are a variety of `#[cfg]`s controlling which targets are involved in\n+// each instance of `weak!` and `syscall!`. Rather than trying to unify all of\n+// that, we'll just allow that some unix targets don't use this module at all.\n+#![allow(dead_code, unused_macros)]\n+\n use crate::ffi::CStr;\n use crate::marker;\n use crate::mem;"}]}