{"sha": "3ef3fd96cf7abb284d069f57043d58dd07ab9edb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZjNmZDk2Y2Y3YWJiMjg0ZDA2OWY1NzA0M2Q1OGRkMDdhYjllZGI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-11T19:29:30Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-11T19:29:30Z"}, "message": "Rollup merge of #29775 - arcnmx:raw-c_char, r=alexcrichton\n\nIt's a bit strange to expect users of `libstd` to require the use of an external crates.io crate to work with standard types. This commit encourages the use `os::raw::c_char` instead, although users are certainly free to use `libc::c_char` if they wish; the test still exists to ensure the two types are identical (though the reported bug only exists on platforms that are not officially tested).\n\nFixes #29774", "tree": {"sha": "2f4bc2b6c23e8b03b4bb5b464b8800450052914b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f4bc2b6c23e8b03b4bb5b464b8800450052914b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ef3fd96cf7abb284d069f57043d58dd07ab9edb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef3fd96cf7abb284d069f57043d58dd07ab9edb", "html_url": "https://github.com/rust-lang/rust/commit/3ef3fd96cf7abb284d069f57043d58dd07ab9edb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ef3fd96cf7abb284d069f57043d58dd07ab9edb/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f51e03043382675cb271032b5729431487dd491f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f51e03043382675cb271032b5729431487dd491f", "html_url": "https://github.com/rust-lang/rust/commit/f51e03043382675cb271032b5729431487dd491f"}, {"sha": "f9f734748cf3ac6bc5155afe288c0689cb57b918", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f734748cf3ac6bc5155afe288c0689cb57b918", "html_url": "https://github.com/rust-lang/rust/commit/f9f734748cf3ac6bc5155afe288c0689cb57b918"}], "stats": {"total": 80, "additions": 38, "deletions": 42}, "files": [{"sha": "42fd2321f011dc4bd09dae14ce3492bb28ab1189", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3ef3fd96cf7abb284d069f57043d58dd07ab9edb/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef3fd96cf7abb284d069f57043d58dd07ab9edb/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=3ef3fd96cf7abb284d069f57043d58dd07ab9edb", "patch": "@@ -21,6 +21,7 @@ use libc;\n use mem;\n use ops::Deref;\n use option::Option::{self, Some, None};\n+use os::raw::c_char;\n use result::Result::{self, Ok, Err};\n use slice;\n use str::{self, Utf8Error};\n@@ -36,23 +37,20 @@ use vec::Vec;\n ///\n /// A `CString` is created from either a byte slice or a byte vector. After\n /// being created, a `CString` predominately inherits all of its methods from\n-/// the `Deref` implementation to `[libc::c_char]`. Note that the underlying\n-/// array is represented as an array of `libc::c_char` as opposed to `u8`. A\n-/// `u8` slice can be obtained with the `as_bytes` method.  Slices produced from\n-/// a `CString` do *not* contain the trailing nul terminator unless otherwise\n-/// specified.\n+/// the `Deref` implementation to `[c_char]`. Note that the underlying array\n+/// is represented as an array of `c_char` as opposed to `u8`. A `u8` slice\n+/// can be obtained with the `as_bytes` method.  Slices produced from a `CString`\n+/// do *not* contain the trailing nul terminator unless otherwise specified.\n ///\n /// # Examples\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// # extern crate libc;\n /// # fn main() {\n /// use std::ffi::CString;\n-/// use libc;\n+/// use std::os::raw::c_char;\n ///\n /// extern {\n-///     fn my_printer(s: *const libc::c_char);\n+///     fn my_printer(s: *const c_char);\n /// }\n ///\n /// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n@@ -83,11 +81,10 @@ pub struct CString {\n /// Inspecting a foreign C string\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::CStr;\n+/// use std::os::raw::c_char;\n ///\n-/// extern { fn my_string() -> *const libc::c_char; }\n+/// extern { fn my_string() -> *const c_char; }\n ///\n /// fn main() {\n ///     unsafe {\n@@ -100,12 +97,11 @@ pub struct CString {\n /// Passing a Rust-originating C string\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::{CString, CStr};\n+/// use std::os::raw::c_char;\n ///\n /// fn work(data: &CStr) {\n-///     extern { fn work_with(data: *const libc::c_char); }\n+///     extern { fn work_with(data: *const c_char); }\n ///\n ///     unsafe { work_with(data.as_ptr()) }\n /// }\n@@ -119,11 +115,10 @@ pub struct CString {\n /// Converting a foreign C string into a Rust `String`\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::CStr;\n+/// use std::os::raw::c_char;\n ///\n-/// extern { fn my_string() -> *const libc::c_char; }\n+/// extern { fn my_string() -> *const c_char; }\n ///\n /// fn my_string_safe() -> String {\n ///     unsafe {\n@@ -139,10 +134,10 @@ pub struct CString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CStr {\n     // FIXME: this should not be represented with a DST slice but rather with\n-    //        just a raw `libc::c_char` along with some form of marker to make\n+    //        just a raw `c_char` along with some form of marker to make\n     //        this an unsized type. Essentially `sizeof(&CStr)` should be the\n     //        same as `sizeof(&c_char)` but `CStr` should be an unsized type.\n-    inner: [libc::c_char]\n+    inner: [c_char]\n }\n \n /// An error returned from `CString::new` to indicate that a nul byte was found\n@@ -169,11 +164,10 @@ impl CString {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n     /// use std::ffi::CString;\n+    /// use std::os::raw::c_char;\n     ///\n-    /// extern { fn puts(s: *const libc::c_char); }\n+    /// extern { fn puts(s: *const c_char); }\n     ///\n     /// fn main() {\n     ///     let to_print = CString::new(\"Hello!\").unwrap();\n@@ -220,7 +214,7 @@ impl CString {\n     #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n                issue = \"27769\")]\n     #[deprecated(since = \"1.4.0\", reason = \"renamed to from_raw\")]\n-    pub unsafe fn from_ptr(ptr: *const libc::c_char) -> CString {\n+    pub unsafe fn from_ptr(ptr: *const c_char) -> CString {\n         CString::from_raw(ptr as *mut _)\n     }\n \n@@ -230,7 +224,7 @@ impl CString {\n     /// `into_raw`. The length of the string will be recalculated\n     /// using the pointer.\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n-    pub unsafe fn from_raw(ptr: *mut libc::c_char) -> CString {\n+    pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n         let len = libc::strlen(ptr) + 1; // Including the NUL byte\n         let slice = slice::from_raw_parts(ptr, len as usize);\n         CString { inner: mem::transmute(slice) }\n@@ -247,7 +241,7 @@ impl CString {\n     #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n                issue = \"27769\")]\n     #[deprecated(since = \"1.4.0\", reason = \"renamed to into_raw\")]\n-    pub fn into_ptr(self) -> *const libc::c_char {\n+    pub fn into_ptr(self) -> *const c_char {\n         self.into_raw() as *const _\n     }\n \n@@ -260,8 +254,8 @@ impl CString {\n     ///\n     /// Failure to call `from_raw` will lead to a memory leak.\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n-    pub fn into_raw(self) -> *mut libc::c_char {\n-        Box::into_raw(self.inner) as *mut libc::c_char\n+    pub fn into_raw(self) -> *mut c_char {\n+        Box::into_raw(self.inner) as *mut c_char\n     }\n \n     /// Converts the `CString` into a `String` if it contains valid Unicode data.\n@@ -426,15 +420,13 @@ impl CStr {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(libc)]\n-    /// # extern crate libc;\n     /// # fn main() {\n     /// use std::ffi::CStr;\n+    /// use std::os::raw::c_char;\n     /// use std::str;\n-    /// use libc;\n     ///\n     /// extern {\n-    ///     fn my_string() -> *const libc::c_char;\n+    ///     fn my_string() -> *const c_char;\n     /// }\n     ///\n     /// unsafe {\n@@ -445,7 +437,7 @@ impl CStr {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_ptr<'a>(ptr: *const libc::c_char) -> &'a CStr {\n+    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n         let len = libc::strlen(ptr);\n         mem::transmute(slice::from_raw_parts(ptr, len as usize + 1))\n     }\n@@ -456,7 +448,7 @@ impl CStr {\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_ptr(&self) -> *const libc::c_char {\n+    pub fn as_ptr(&self) -> *const c_char {\n         self.inner.as_ptr()\n     }\n \n@@ -560,14 +552,14 @@ impl ToOwned for CStr {\n mod tests {\n     use prelude::v1::*;\n     use super::*;\n-    use libc;\n+    use os::raw::c_char;\n     use borrow::Cow::{Borrowed, Owned};\n     use hash::{SipHasher, Hash, Hasher};\n \n     #[test]\n     fn c_to_rust() {\n         let data = b\"123\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert_eq!(CStr::from_ptr(ptr).to_bytes(), b\"123\");\n             assert_eq!(CStr::from_ptr(ptr).to_bytes_with_nul(), b\"123\\0\");\n@@ -616,13 +608,13 @@ mod tests {\n     #[test]\n     fn to_str() {\n         let data = b\"123\\xE2\\x80\\xA6\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n             assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n         }\n         let data = b\"123\\xE2\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert!(CStr::from_ptr(ptr).to_str().is_err());\n             assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n@@ -632,7 +624,7 @@ mod tests {\n     #[test]\n     fn to_owned() {\n         let data = b\"123\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n \n         let owned = unsafe { CStr::from_ptr(ptr).to_owned() };\n         assert_eq!(owned.as_bytes_with_nul(), data);\n@@ -641,7 +633,7 @@ mod tests {\n     #[test]\n     fn equal_hash() {\n         let data = b\"123\\xE2\\xFA\\xA6\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n \n         let mut s = SipHasher::new_with_keys(0, 0);"}, {"sha": "17d6b2605c62831c7300491b4a824f3f90bb79cd", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ef3fd96cf7abb284d069f57043d58dd07ab9edb/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef3fd96cf7abb284d069f57043d58dd07ab9edb/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=3ef3fd96cf7abb284d069f57043d58dd07ab9edb", "patch": "@@ -12,9 +12,13 @@\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n-#[cfg(any(target_arch = \"aarch64\", target_os = \"android\"))]\n+#[cfg(any(target_os = \"android\",\n+          all(target_os = \"linux\", any(target_arch = \"aarch64\",\n+                                       target_arch = \"arm\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[cfg(not(any(target_arch = \"aarch64\", target_os = \"android\")))]\n+#[cfg(not(any(target_os = \"android\",\n+              all(target_os = \"linux\", any(target_arch = \"aarch64\",\n+                                           target_arch = \"arm\")))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;"}]}