{"sha": "086f5a55be73dff71ce5d93f16cdf5652d833090", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NmY1YTU1YmU3M2RmZjcxY2U1ZDkzZjE2Y2RmNTY1MmQ4MzMwOTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-10-23T07:59:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-10-23T07:59:14Z"}, "message": "Revert \"rustc: Fix (again) simd vectors by-val in ABI\"\n\nThis reverts commit 3cc8f738d4247a9b475d8e074b621e602ac2b7be.", "tree": {"sha": "da23072131ac5e092d2142a8797622eaebf8f929", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da23072131ac5e092d2142a8797622eaebf8f929"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/086f5a55be73dff71ce5d93f16cdf5652d833090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/086f5a55be73dff71ce5d93f16cdf5652d833090", "html_url": "https://github.com/rust-lang/rust/commit/086f5a55be73dff71ce5d93f16cdf5652d833090", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/086f5a55be73dff71ce5d93f16cdf5652d833090/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d570b36cd9dd0a3c1b94e6fc4004ee5557140d31", "url": "https://api.github.com/repos/rust-lang/rust/commits/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31", "html_url": "https://github.com/rust-lang/rust/commit/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31"}], "stats": {"total": 341, "additions": 9, "deletions": 332}, "files": [{"sha": "61856236a149141294fc6395d1f2f90e6d00ce84", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/086f5a55be73dff71ce5d93f16cdf5652d833090/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086f5a55be73dff71ce5d93f16cdf5652d833090/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=086f5a55be73dff71ce5d93f16cdf5652d833090", "patch": "@@ -80,7 +80,9 @@ impl LtoModuleCodegen {\n                 let module = module.take().unwrap();\n                 {\n                     let config = cgcx.config(module.kind);\n-                    run_pass_manager(cgcx, &module, config, false);\n+                    let llmod = module.module_llvm.llmod();\n+                    let tm = &*module.module_llvm.tm;\n+                    run_pass_manager(cgcx, tm, llmod, config, false);\n                     timeline.record(\"fat-done\");\n                 }\n                 Ok(module)\n@@ -555,7 +557,8 @@ fn thin_lto(cgcx: &CodegenContext,\n }\n \n fn run_pass_manager(cgcx: &CodegenContext,\n-                    module: &ModuleCodegen,\n+                    tm: &llvm::TargetMachine,\n+                    llmod: &llvm::Module,\n                     config: &ModuleConfig,\n                     thin: bool) {\n     // Now we have one massive module inside of llmod. Time to run the\n@@ -566,8 +569,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n     debug!(\"running the pass manager\");\n     unsafe {\n         let pm = llvm::LLVMCreatePassManager();\n-        let llmod = module.module_llvm.llmod();\n-        llvm::LLVMRustAddAnalysisPasses(module.module_llvm.tm, pm, llmod);\n+        llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n \n         if config.verify_llvm_ir {\n             let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n@@ -862,7 +864,7 @@ impl ThinModule {\n             // little differently.\n             info!(\"running thin lto passes over {}\", module.name);\n             let config = cgcx.config(module.kind);\n-            run_pass_manager(cgcx, &module, config, true);\n+            run_pass_manager(cgcx, module.module_llvm.tm, llmod, config, true);\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n             timeline.record(\"thin-done\");\n         }"}, {"sha": "81619c219757b4a11a43e627e7b5cca698b1b8c1", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/086f5a55be73dff71ce5d93f16cdf5652d833090/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086f5a55be73dff71ce5d93f16cdf5652d833090/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=086f5a55be73dff71ce5d93f16cdf5652d833090", "patch": "@@ -633,7 +633,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n                  None,\n                  &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n                  || {\n-            llvm::LLVMRunPassManager(mpm, llmod);\n+            llvm::LLVMRunPassManager(mpm, llmod)\n         });\n \n         // Deallocate managers that we're now done with\n@@ -691,38 +691,6 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             create_msvc_imps(cgcx, llcx, llmod);\n         }\n \n-        // Ok now this one's a super interesting invocations. SIMD in rustc is\n-        // difficult where we want some parts of the program to be able to use\n-        // some SIMD features while other parts of the program don't. The real\n-        // tough part is that we want this to actually work correctly!\n-        //\n-        // We go to great lengths to make sure this works, and one crucial\n-        // aspect is that vector arguments (simd types) are never passed by\n-        // value in the ABI of functions. It turns out, however, that LLVM will\n-        // undo our \"clever work\" of passing vector types by reference. Its\n-        // argument promotion pass will promote these by-ref arguments to\n-        // by-val. That, however, introduces codegen errors!\n-        //\n-        // The upstream LLVM bug [1] has unfortunatey not really seen a lot of\n-        // activity. The Rust bug [2], however, has seen quite a lot of reports\n-        // of this in the wild. As a result, this is worked around locally here.\n-        // We have a custom transformation, `LLVMRustDemoteSimdArguments`, which\n-        // does the opposite of argument promotion by demoting any by-value SIMD\n-        // arguments in function signatures to pointers intead of being\n-        // by-value.\n-        //\n-        // This operates at the LLVM IR layer because LLVM is thwarting our\n-        // codegen and this is the only chance we get to make sure it's correct\n-        // before we hit codegen.\n-        //\n-        // Hopefully one day the upstream LLVM bug will be fixed and we'll no\n-        // longer need this!\n-        //\n-        // [1]: https://bugs.llvm.org/show_bug.cgi?id=37358\n-        // [2]: https://github.com/rust-lang/rust/issues/50154\n-        llvm::LLVMRustDemoteSimdArguments(llmod);\n-        cgcx.save_temp_bitcode(&module, \"simd-demoted\");\n-\n         // A codegen-specific pass manager is used to generate object\n         // files for an LLVM module.\n         //"}, {"sha": "0b98fa4eaf55139ebce5967de1a234a26379b759", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086f5a55be73dff71ce5d93f16cdf5652d833090/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086f5a55be73dff71ce5d93f16cdf5652d833090/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=086f5a55be73dff71ce5d93f16cdf5652d833090", "patch": "@@ -1138,8 +1138,6 @@ extern \"C\" {\n     /// Runs a pass manager on a module.\n     pub fn LLVMRunPassManager(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n \n-    pub fn LLVMRustDemoteSimdArguments(M: &'a Module);\n-\n     pub fn LLVMInitializePasses();\n \n     pub fn LLVMPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;"}, {"sha": "7d01ed556c8ddbee7d76dbdc369c7cb937ab5480", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/086f5a55be73dff71ce5d93f16cdf5652d833090/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086f5a55be73dff71ce5d93f16cdf5652d833090/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=086f5a55be73dff71ce5d93f16cdf5652d833090", "patch": "@@ -162,9 +162,7 @@ fn main() {\n     }\n \n     build_helper::rerun_if_changed_anything_in_dir(Path::new(\"../rustllvm\"));\n-    cfg\n-       .file(\"../rustllvm/DemoteSimd.cpp\")\n-       .file(\"../rustllvm/PassWrapper.cpp\")\n+    cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n        .file(\"../rustllvm/Linker.cpp\")"}, {"sha": "e9203baa0d7b13e899584609efcaaa2e62d99ccc", "filename": "src/rustllvm/DemoteSimd.cpp", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Frustllvm%2FDemoteSimd.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Frustllvm%2FDemoteSimd.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FDemoteSimd.cpp?ref=d570b36cd9dd0a3c1b94e6fc4004ee5557140d31", "patch": "@@ -1,189 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include <vector>\n-#include <set>\n-\n-#include \"rustllvm.h\"\n-\n-#if LLVM_VERSION_GE(5, 0)\n-\n-#include \"llvm/IR/CallSite.h\"\n-#include \"llvm/IR/Module.h\"\n-#include \"llvm/ADT/STLExtras.h\"\n-\n-using namespace llvm;\n-\n-static std::vector<Function*>\n-GetFunctionsWithSimdArgs(Module *M) {\n-  std::vector<Function*> Ret;\n-\n-  for (auto &F : M->functions()) {\n-    // Skip all intrinsic calls as these are always tightly controlled to \"work\n-    // correctly\", so no need to fixup any of these.\n-    if (F.isIntrinsic())\n-      continue;\n-\n-    // We're only interested in rustc-defined functions, not unstably-defined\n-    // imported SIMD ffi functions.\n-    if (F.isDeclaration())\n-      continue;\n-\n-    // Argument promotion only happens on internal functions, so skip demoting\n-    // arguments in external functions like FFI shims and such.\n-    if (!F.hasLocalLinkage())\n-      continue;\n-\n-    // If any argument to this function is a by-value vector type, then that's\n-    // bad! The compiler didn't generate any functions that looked like this,\n-    // and we try to rely on LLVM to not do this! Argument promotion may,\n-    // however, promote arguments from behind references. In any case, figure\n-    // out if we're interested in demoting this argument.\n-    if (any_of(F.args(), [](Argument &arg) { return arg.getType()->isVectorTy(); }))\n-      Ret.push_back(&F);\n-  }\n-\n-  return Ret;\n-}\n-\n-extern \"C\" void\n-LLVMRustDemoteSimdArguments(LLVMModuleRef Mod) {\n-  Module *M = unwrap(Mod);\n-\n-  auto Functions = GetFunctionsWithSimdArgs(M);\n-\n-  for (auto F : Functions) {\n-    // Build up our list of new parameters and new argument attributes.\n-    // We're only changing those arguments which are vector types.\n-    SmallVector<Type*, 8> Params;\n-    SmallVector<AttributeSet, 8> ArgAttrVec;\n-    auto PAL = F->getAttributes();\n-    for (auto &Arg : F->args()) {\n-      auto *Ty = Arg.getType();\n-      if (Ty->isVectorTy()) {\n-        Params.push_back(PointerType::get(Ty, 0));\n-        ArgAttrVec.push_back(AttributeSet());\n-      } else {\n-        Params.push_back(Ty);\n-        ArgAttrVec.push_back(PAL.getParamAttributes(Arg.getArgNo()));\n-      }\n-    }\n-\n-    // Replace `F` with a new function with our new signature. I'm... not really\n-    // sure how this works, but this is all the steps `ArgumentPromotion` does\n-    // to replace a signature as well.\n-    assert(!F->isVarArg()); // ArgumentPromotion should skip these fns\n-    FunctionType *NFTy = FunctionType::get(F->getReturnType(), Params, false);\n-    Function *NF = Function::Create(NFTy, F->getLinkage(), F->getName());\n-    NF->copyAttributesFrom(F);\n-    NF->setSubprogram(F->getSubprogram());\n-    F->setSubprogram(nullptr);\n-    NF->setAttributes(AttributeList::get(F->getContext(),\n-                                         PAL.getFnAttributes(),\n-                                         PAL.getRetAttributes(),\n-                                         ArgAttrVec));\n-    ArgAttrVec.clear();\n-    F->getParent()->getFunctionList().insert(F->getIterator(), NF);\n-    NF->takeName(F);\n-\n-    // Iterate over all invocations of `F`, updating all `call` instructions to\n-    // store immediate vector types in a local `alloc` instead of a by-value\n-    // vector.\n-    //\n-    // Like before, much of this is copied from the `ArgumentPromotion` pass in\n-    // LLVM.\n-    SmallVector<Value*, 16> Args;\n-    while (!F->use_empty()) {\n-      CallSite CS(F->user_back());\n-      assert(CS.getCalledFunction() == F);\n-      Instruction *Call = CS.getInstruction();\n-      const AttributeList &CallPAL = CS.getAttributes();\n-\n-      // Loop over the operands, inserting an `alloca` and a store for any\n-      // argument we're demoting to be by reference\n-      //\n-      // FIXME: we probably want to figure out an LLVM pass to run and clean up\n-      // this function and instructions we're generating, we should in theory\n-      // only generate a maximum number of `alloca` instructions rather than\n-      // one-per-variable unconditionally.\n-      CallSite::arg_iterator AI = CS.arg_begin();\n-      size_t ArgNo = 0;\n-      for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;\n-           ++I, ++AI, ++ArgNo) {\n-        if (I->getType()->isVectorTy()) {\n-          AllocaInst *AllocA = new AllocaInst(I->getType(), 0, nullptr, \"\", Call);\n-          new StoreInst(*AI, AllocA, Call);\n-          Args.push_back(AllocA);\n-          ArgAttrVec.push_back(AttributeSet());\n-        } else {\n-          Args.push_back(*AI);\n-          ArgAttrVec.push_back(CallPAL.getParamAttributes(ArgNo));\n-        }\n-      }\n-      assert(AI == CS.arg_end());\n-\n-      // Create a new call instructions which we'll use to replace the old call\n-      // instruction, copying over as many attributes and such as possible.\n-      SmallVector<OperandBundleDef, 1> OpBundles;\n-      CS.getOperandBundlesAsDefs(OpBundles);\n-\n-      CallSite NewCS;\n-      if (InvokeInst *II = dyn_cast<InvokeInst>(Call)) {\n-        InvokeInst::Create(NF, II->getNormalDest(), II->getUnwindDest(),\n-                           Args, OpBundles, \"\", Call);\n-      } else {\n-        auto *NewCall = CallInst::Create(NF, Args, OpBundles, \"\", Call);\n-        NewCall->setTailCallKind(cast<CallInst>(Call)->getTailCallKind());\n-        NewCS = NewCall;\n-      }\n-      NewCS.setCallingConv(CS.getCallingConv());\n-      NewCS.setAttributes(\n-          AttributeList::get(F->getContext(), CallPAL.getFnAttributes(),\n-                             CallPAL.getRetAttributes(), ArgAttrVec));\n-      NewCS->setDebugLoc(Call->getDebugLoc());\n-      Args.clear();\n-      ArgAttrVec.clear();\n-      Call->replaceAllUsesWith(NewCS.getInstruction());\n-      NewCS->takeName(Call);\n-      Call->eraseFromParent();\n-    }\n-\n-    // Splice the body of the old function right into the new function.\n-    NF->getBasicBlockList().splice(NF->begin(), F->getBasicBlockList());\n-\n-    // Update our new function to replace all uses of the by-value argument with\n-    // loads of the pointer argument we've generated.\n-    //\n-    // FIXME: we probably want to only generate one load instruction per\n-    // function? Or maybe run an LLVM pass to clean up this function?\n-    for (Function::arg_iterator I = F->arg_begin(),\n-                                E = F->arg_end(),\n-                                I2 = NF->arg_begin();\n-         I != E;\n-         ++I, ++I2) {\n-      if (I->getType()->isVectorTy()) {\n-        I->replaceAllUsesWith(new LoadInst(&*I2, \"\", &NF->begin()->front()));\n-      } else {\n-        I->replaceAllUsesWith(&*I2);\n-      }\n-      I2->takeName(&*I);\n-    }\n-\n-    // Delete all references to the old function, it should be entirely dead\n-    // now.\n-    M->getFunctionList().remove(F);\n-  }\n-}\n-\n-#else // LLVM_VERSION_GE(8, 0)\n-extern \"C\" void\n-LLVMRustDemoteSimdArguments(LLVMModuleRef Mod) {\n-}\n-#endif // LLVM_VERSION_GE(8, 0)"}, {"sha": "3095432d0fe6965cc88171e506a9fd0021f0f8e3", "filename": "src/test/run-make/simd-argument-promotion-thwarted/Makefile", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile?ref=d570b36cd9dd0a3c1b94e6fc4004ee5557140d31", "patch": "@@ -1,13 +0,0 @@\n--include ../../run-make-fulldeps/tools.mk\n-\n-ifeq ($(TARGET),x86_64-unknown-linux-gnu)\n-all:\n-\t$(RUSTC) t1.rs -C opt-level=3\n-\t$(TMPDIR)/t1\n-\t$(RUSTC) t2.rs -C opt-level=3\n-\t$(TMPDIR)/t2\n-\t$(RUSTC) t3.rs -C opt-level=3\n-\t$(TMPDIR)/t3\n-else\n-all:\n-endif"}, {"sha": "cb4a3dd7d4a7cb978380cce0bafd0cfc9e2499cf", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t1.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs?ref=d570b36cd9dd0a3c1b94e6fc4004ee5557140d31", "patch": "@@ -1,21 +0,0 @@\n-use std::arch::x86_64;\n-\n-fn main() {\n-    if !is_x86_feature_detected!(\"avx2\") {\n-        return println!(\"AVX2 is not supported on this machine/build.\");\n-    }\n-    let load_bytes: [u8; 32] = [0x0f; 32];\n-    let lb_ptr = load_bytes.as_ptr();\n-    let reg_load = unsafe {\n-        x86_64::_mm256_loadu_si256(\n-            lb_ptr as *const x86_64::__m256i\n-        )\n-    };\n-    println!(\"{:?}\", reg_load);\n-    let mut store_bytes: [u8; 32] = [0; 32];\n-    let sb_ptr = store_bytes.as_mut_ptr();\n-    unsafe {\n-        x86_64::_mm256_storeu_si256(sb_ptr as *mut x86_64::__m256i, reg_load);\n-    }\n-    assert_eq!(load_bytes, store_bytes);\n-}"}, {"sha": "0e42b82a223d0aeab89c1880ab387c9f62dc9145", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs?ref=d570b36cd9dd0a3c1b94e6fc4004ee5557140d31", "patch": "@@ -1,14 +0,0 @@\n-use std::arch::x86_64::*;\n-\n-fn main() {\n-    if !is_x86_feature_detected!(\"avx\") {\n-        return println!(\"AVX is not supported on this machine/build.\");\n-    }\n-    unsafe {\n-        let f = _mm256_set_pd(2.0, 2.0, 2.0, 2.0);\n-        let r = _mm256_mul_pd(f, f);\n-\n-        union A { a: __m256d, b: [f64; 4] }\n-        assert_eq!(A { a: r }.b, [4.0, 4.0, 4.0, 4.0]);\n-    }\n-}"}, {"sha": "10062ab3e46438ce341da4dfc696f711eadf0aa8", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t3.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d570b36cd9dd0a3c1b94e6fc4004ee5557140d31/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs?ref=d570b36cd9dd0a3c1b94e6fc4004ee5557140d31", "patch": "@@ -1,52 +0,0 @@\n-use std::arch::x86_64::*;\n-\n-#[target_feature(enable = \"avx\")]\n-unsafe fn avx_mul(a: __m256, b: __m256) -> __m256 {\n-    _mm256_mul_ps(a, b)\n-}\n-\n-#[target_feature(enable = \"avx\")]\n-unsafe fn avx_store(p: *mut f32, a: __m256) {\n-    _mm256_storeu_ps(p, a)\n-}\n-\n-#[target_feature(enable = \"avx\")]\n-unsafe fn avx_setr(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> __m256 {\n-    _mm256_setr_ps(a, b, c, d, e, f, g, h)\n-}\n-\n-#[target_feature(enable = \"avx\")]\n-unsafe fn avx_set1(a: f32) -> __m256 {\n-    _mm256_set1_ps(a)\n-}\n-\n-struct Avx(__m256);\n-\n-fn mul(a: Avx, b: Avx) -> Avx {\n-    unsafe { Avx(avx_mul(a.0, b.0)) }\n-}\n-\n-fn set1(a: f32) -> Avx {\n-    unsafe { Avx(avx_set1(a)) }\n-}\n-\n-fn setr(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> Avx {\n-    unsafe { Avx(avx_setr(a, b, c, d, e, f, g, h)) }\n-}\n-\n-unsafe fn store(p: *mut f32, a: Avx) {\n-    avx_store(p, a.0);\n-}\n-\n-fn main() {\n-    if !is_x86_feature_detected!(\"avx\") {\n-        return println!(\"AVX is not supported on this machine/build.\");\n-    }\n-    let mut result = [0.0f32; 8];\n-    let a = mul(setr(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0), set1(0.25));\n-    unsafe {\n-        store(result.as_mut_ptr(), a);\n-    }\n-\n-    assert_eq!(result, [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.50, 1.75]);\n-}"}]}