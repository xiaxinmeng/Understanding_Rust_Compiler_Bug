{"sha": "d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzOWRkZGY3OTU2YmVlYWQ1MmM0YzRmYmQ4NWY0MGE1MzcyYmJkN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-06T22:26:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-06T22:26:16Z"}, "message": "Auto merge of #57344 - petrochenkov:regreach, r=arielb1\n\nprivacy: Fix regression in impl reachability\n\nRollback to pre-https://github.com/rust-lang/rust/pull/56878 logic of determining reachability.\n`reachability(impl Trait<Substs> for Type<Substs>) = reachability(Trait & Type)`, substs are ignored.\n\nFixes https://github.com/rust-lang/rust/issues/57264", "tree": {"sha": "cfe2a7f8964173a97ced0fba5cf0857b2089e770", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfe2a7f8964173a97ced0fba5cf0857b2089e770"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "html_url": "https://github.com/rust-lang/rust/commit/d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b92552d5578e4544006da0dd5e793a19c2149321", "url": "https://api.github.com/repos/rust-lang/rust/commits/b92552d5578e4544006da0dd5e793a19c2149321", "html_url": "https://github.com/rust-lang/rust/commit/b92552d5578e4544006da0dd5e793a19c2149321"}, {"sha": "fb00313c0df91b306e00a14176c2a9c57171f180", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb00313c0df91b306e00a14176c2a9c57171f180", "html_url": "https://github.com/rust-lang/rust/commit/fb00313c0df91b306e00a14176c2a9c57171f180"}], "stats": {"total": 89, "additions": 78, "deletions": 11}, "files": [{"sha": "5015ed027cc3c69ca26e87950e6d1522ffba57c8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "patch": "@@ -51,7 +51,8 @@ mod diagnostics;\n /// in `impl Trait`, see individual commits in `DefIdVisitorSkeleton::visit_ty`.\n trait DefIdVisitor<'a, 'tcx: 'a> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-    fn recurse_into_assoc_tys(&self) -> bool { true }\n+    fn shallow(&self) -> bool { false }\n+    fn skip_assoc_tys(&self) -> bool { false }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n \n     /// Not overridden, but used to actually visit types and traits.\n@@ -86,7 +87,8 @@ impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n         let TraitRef { def_id, substs } = trait_ref;\n-        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) || substs.visit_with(self)\n+        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) ||\n+        (!self.def_id_visitor.shallow() && substs.visit_with(self))\n     }\n \n     fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n@@ -138,6 +140,9 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n                 if self.def_id_visitor.visit_def_id(def_id, \"type\", ty) {\n                     return true;\n                 }\n+                if self.def_id_visitor.shallow() {\n+                    return false;\n+                }\n                 // Default type visitor doesn't visit signatures of fn types.\n                 // Something like `fn() -> Priv {my_func}` is considered a private type even if\n                 // `my_func` is public, so we need to visit signatures.\n@@ -159,18 +164,20 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n                 }\n             }\n             ty::Projection(proj) | ty::UnnormalizedProjection(proj) => {\n-                if !self.def_id_visitor.recurse_into_assoc_tys() {\n+                if self.def_id_visitor.skip_assoc_tys() {\n                     // Visitors searching for minimal visibility/reachability want to\n                     // conservatively approximate associated types like `<Type as Trait>::Alias`\n                     // as visible/reachable even if both `Type` and `Trait` are private.\n                     // Ideally, associated types should be substituted in the same way as\n                     // free type aliases, but this isn't done yet.\n                     return false;\n                 }\n-                // This will also visit substs, so we don't need to recurse.\n+                // This will also visit substs if necessary, so we don't need to recurse.\n                 return self.visit_trait(proj.trait_ref(tcx));\n             }\n             ty::Dynamic(predicates, ..) => {\n+                // All traits in the list are considered the \"primary\" part of the type\n+                // and are visited by shallow visitors.\n                 for predicate in *predicates.skip_binder() {\n                     let trait_ref = match *predicate {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n@@ -187,9 +194,13 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n             ty::Opaque(def_id, ..) => {\n                 // Skip repeated `Opaque`s to avoid infinite recursion.\n                 if self.visited_opaque_tys.insert(def_id) {\n-                    // Default type visitor doesn't visit traits in `impl Trait`.\n-                    // Something like `impl PrivTr` is considered a private type,\n-                    // so we need to visit the traits additionally.\n+                    // The intent is to treat `impl Trait1 + Trait2` identically to\n+                    // `dyn Trait1 + Trait2`. Therefore we ignore def-id of the opaque type itself\n+                    // (it either has no visibility, or its visibility is insignificant, like\n+                    // visibilities of type aliases) and recurse into predicates instead to go\n+                    // through the trait list (default type visitor doesn't visit those traits).\n+                    // All traits in the list are considered the \"primary\" part of the type\n+                    // and are visited by shallow visitors.\n                     if self.visit_predicates(tcx.predicates_of(def_id)) {\n                         return true;\n                     }\n@@ -206,7 +217,7 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n                 bug!(\"unexpected type: {:?}\", ty),\n         }\n \n-        ty.super_visit_with(self)\n+        !self.def_id_visitor.shallow() && ty.super_visit_with(self)\n     }\n }\n \n@@ -325,7 +336,8 @@ struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n \n impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx, VL> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n-    fn recurse_into_assoc_tys(&self) -> bool { false }\n+    fn shallow(&self) -> bool { VL::SHALLOW }\n+    fn skip_assoc_tys(&self) -> bool { true }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         self.min = VL::new_min(self, def_id);\n         false\n@@ -334,9 +346,10 @@ impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx,\n \n trait VisibilityLike: Sized {\n     const MAX: Self;\n+    const SHALLOW: bool = false;\n     fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self;\n \n-    // Returns an over-approximation (`recurse_into_assoc_tys` = false) of visibility due to\n+    // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n     fn of_impl<'a, 'tcx>(node_id: ast::NodeId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          access_levels: &'a AccessLevels) -> Self {\n@@ -357,6 +370,16 @@ impl VisibilityLike for ty::Visibility {\n }\n impl VisibilityLike for Option<AccessLevel> {\n     const MAX: Self = Some(AccessLevel::Public);\n+    // Type inference is very smart sometimes.\n+    // It can make an impl reachable even some components of its type or trait are unreachable.\n+    // E.g. methods of `impl ReachableTrait<UnreachableTy> for ReachableTy<UnreachableTy> { ... }`\n+    // can be usable from other crates (#57264). So we skip substs when calculating reachability\n+    // and consider an impl reachable if its \"shallow\" type and trait are reachable.\n+    //\n+    // The assumption we make here is that type-inference won't let you use an impl without knowing\n+    // both \"shallow\" version of its self type and \"shallow\" version of its trait if it exists\n+    // (which require reaching the `DefId`s in them).\n+    const SHALLOW: bool = true;\n     fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n         cmp::min(if let Some(node_id) = find.tcx.hir().as_local_node_id(def_id) {\n             find.access_levels.map.get(&node_id).cloned()\n@@ -542,7 +565,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(.., ref impl_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates().ty().trait_ref();\n \n                     for impl_item_ref in impl_item_refs {\n                         let impl_item_level = self.get(impl_item_ref.id.node_id);\n@@ -701,6 +724,13 @@ impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n         self.visit(self.ev.tcx.type_of(self.item_def_id));\n         self\n     }\n+\n+    fn trait_ref(&mut self) -> &mut Self {\n+        if let Some(trait_ref) = self.ev.tcx.impl_trait_ref(self.item_def_id) {\n+            self.visit_trait(trait_ref);\n+        }\n+        self\n+    }\n }\n \n impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {"}, {"sha": "9302fa0d9e8d115bda78bd1d890e12444e2e2827", "filename": "src/test/ui/privacy/auxiliary/issue-57264-1.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-57264-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-57264-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-57264-1.rs?ref=d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "patch": "@@ -0,0 +1,9 @@\n+mod inner {\n+    pub struct PubUnnameable;\n+}\n+\n+pub struct Pub<T>(T);\n+\n+impl Pub<inner::PubUnnameable> {\n+    pub fn pub_method() {}\n+}"}, {"sha": "416206b4f8e7b3163749191943a3d90e7e9e49b6", "filename": "src/test/ui/privacy/auxiliary/issue-57264-2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-57264-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-57264-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fauxiliary%2Fissue-57264-2.rs?ref=d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "patch": "@@ -0,0 +1,10 @@\n+mod inner {\n+    pub struct PubUnnameable;\n+\n+    impl PubUnnameable {\n+        pub fn pub_method(self) {}\n+    }\n+}\n+\n+pub trait PubTraitWithSingleImplementor {}\n+impl PubTraitWithSingleImplementor for Option<inner::PubUnnameable> {}"}, {"sha": "dcffdc3d4ef87e5a29f4d05ab125d09ab679a750", "filename": "src/test/ui/privacy/issue-57264-1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Ftest%2Fui%2Fprivacy%2Fissue-57264-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Ftest%2Fui%2Fprivacy%2Fissue-57264-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-57264-1.rs?ref=d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "patch": "@@ -0,0 +1,8 @@\n+// compile-pass\n+// aux-build:issue-57264-1.rs\n+\n+extern crate issue_57264_1;\n+\n+fn main() {\n+    issue_57264_1::Pub::pub_method();\n+}"}, {"sha": "79d0d2c7cd785b6e7b70ff8002e1b691cbed0101", "filename": "src/test/ui/privacy/issue-57264-2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Ftest%2Fui%2Fprivacy%2Fissue-57264-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39dddf7956beead52c4c4fbd85f40a5372bbd7a/src%2Ftest%2Fui%2Fprivacy%2Fissue-57264-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-57264-2.rs?ref=d39dddf7956beead52c4c4fbd85f40a5372bbd7a", "patch": "@@ -0,0 +1,10 @@\n+// compile-pass\n+// aux-build:issue-57264-2.rs\n+\n+extern crate issue_57264_2;\n+\n+fn infer<T: issue_57264_2::PubTraitWithSingleImplementor>(arg: T) -> T { arg }\n+\n+fn main() {\n+    infer(None).unwrap().pub_method();\n+}"}]}