{"sha": "fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "node_id": "C_kwDOAAsO6NoAKGZjZGJkMWMwN2YwYjZjOGU3ZDhiYmQ3MjdjNmNhNjlhMWFmOGM3ZTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-19T02:42:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-19T02:42:10Z"}, "message": "Auto merge of #107867 - compiler-errors:new-solver-fn-trait-safety, r=lcnr\n\nCheck that built-in callable types validate their output type is `Sized` (in new solver)\n\nWorking on parity with old solver. Putting this up for consideration, it's not *really* needed or anything just yet. Maybe it's better to approach this from another direction (like always checking the item bounds when calling `consider_assumption`? we may need that for coinduction to be sound though?)\n\nThis basically implements #100096 for the new solver.", "tree": {"sha": "8f40f2a535117ab02001953bb2028f22ed89c898", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f40f2a535117ab02001953bb2028f22ed89c898"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "html_url": "https://github.com/rust-lang/rust/commit/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f77f4d55bdf9d8955d3292f709bd9830c2fdeca5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f77f4d55bdf9d8955d3292f709bd9830c2fdeca5", "html_url": "https://github.com/rust-lang/rust/commit/f77f4d55bdf9d8955d3292f709bd9830c2fdeca5"}, {"sha": "6402c98621ab620a16adac072abc10779cf60573", "url": "https://api.github.com/repos/rust-lang/rust/commits/6402c98621ab620a16adac072abc10779cf60573", "html_url": "https://github.com/rust-lang/rust/commit/6402c98621ab620a16adac072abc10779cf60573"}], "stats": {"total": 209, "additions": 135, "deletions": 74}, "files": [{"sha": "841169ac78d7d83e648c0190e898e85cc9b20c4c", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "patch": "@@ -90,16 +90,20 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n-    fn consider_impl_candidate(\n+    // Consider a clause, which consists of a \"assumption\" and some \"requirements\",\n+    // to satisfy a goal. If the requirements hold, then attempt to satisfy our\n+    // goal by equating it with the assumption.\n+    fn consider_implied_clause(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        impl_def_id: DefId,\n+        assumption: ty::Predicate<'tcx>,\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx>;\n \n-    fn consider_assumption(\n+    fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        impl_def_id: DefId,\n     ) -> QueryResult<'tcx>;\n \n     // A type implements an `auto trait` if its components do as well. These components\n@@ -355,7 +359,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n-            match G::consider_assumption(self, goal, assumption) {\n+            match G::consider_implied_clause(self, goal, assumption, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n                 }\n@@ -402,7 +406,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_assumption(self, goal, assumption) {\n+            match G::consider_implied_clause(self, goal, assumption, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n                 }\n@@ -452,7 +456,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_assumption(self, goal, assumption.predicate) {\n+            match G::consider_implied_clause(self, goal, assumption.predicate, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "48153b465b7ec9487e2cef6c085032b82c7b6c0e", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 61, "deletions": 50, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "patch": "@@ -168,6 +168,37 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.trait_def_id(tcx)\n     }\n \n+    fn consider_implied_clause(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n+            ecx.infcx.probe(|_| {\n+                let assumption_projection_pred =\n+                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n+                let mut nested_goals = ecx.infcx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+                nested_goals.extend(requirements);\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n@@ -260,35 +291,6 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_assumption(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n-        {\n-            ecx.infcx.probe(|_| {\n-                let assumption_projection_pred =\n-                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n-                let nested_goals = ecx.infcx.eq(\n-                    goal.param_env,\n-                    goal.predicate.projection_ty,\n-                    assumption_projection_pred.projection_ty,\n-                )?;\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n     fn consider_auto_trait_candidate(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -329,25 +331,28 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n-        if let Some(tupled_inputs_and_output) =\n-            structural_traits::extract_tupled_inputs_and_output_from_callable(\n-                ecx.tcx(),\n-                goal.predicate.self_ty(),\n-                goal_kind,\n-            )?\n-        {\n-            let pred = tupled_inputs_and_output\n-                .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n-                    projection_ty: ecx\n-                        .tcx()\n-                        .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n-                    term: output.into(),\n-                })\n-                .to_predicate(ecx.tcx());\n-            Self::consider_assumption(ecx, goal, pred)\n-        } else {\n-            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n-        }\n+        let tcx = ecx.tcx();\n+        let Some(tupled_inputs_and_output) =\n+        structural_traits::extract_tupled_inputs_and_output_from_callable(\n+            tcx,\n+            goal.predicate.self_ty(),\n+            goal_kind,\n+        )? else {\n+        return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+    };\n+        let output_is_sized_pred = tupled_inputs_and_output\n+            .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n+\n+        let pred = tupled_inputs_and_output\n+            .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n+                projection_ty: tcx\n+                    .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n+                term: output.into(),\n+            })\n+            .to_predicate(tcx);\n+        // A built-in `Fn` impl only holds if the output is sized.\n+        // (FIXME: technically we only need to check this if the type is a fn ptr...)\n+        Self::consider_implied_clause(ecx, goal, pred, [goal.with(tcx, output_is_sized_pred)])\n     }\n \n     fn consider_builtin_tuple_candidate(\n@@ -466,14 +471,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n         let term = substs.as_generator().return_ty().into();\n \n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(ty::ProjectionPredicate {\n                 projection_ty: ecx.tcx().mk_alias_ty(goal.predicate.def_id(), [self_ty]),\n                 term,\n             })\n             .to_predicate(tcx),\n+            // Technically, we need to check that the future type is Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n \n@@ -503,7 +511,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             bug!(\"unexpected associated item `<{self_ty} as Generator>::{name}`\")\n         };\n \n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(ty::ProjectionPredicate {\n@@ -513,6 +521,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 term,\n             })\n             .to_predicate(tcx),\n+            // Technically, we need to check that the future type is Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n "}, {"sha": "f2f25ef850a9a6ac92f203ec5b4b7d0aa515e8eb", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "patch": "@@ -6,6 +6,7 @@ use super::assembly;\n use super::infcx_ext::InferCtxtExt;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n+use rustc_hir::LangItem;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n@@ -61,10 +62,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_assumption(\n+    fn consider_implied_clause(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n@@ -73,11 +75,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.infcx.probe(|_| {\n                 let assumption_trait_pred =\n                     ecx.infcx.instantiate_binder_with_infer(poly_trait_pred);\n-                let nested_goals = ecx.infcx.eq(\n+                let mut nested_goals = ecx.infcx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n+                nested_goals.extend(requirements);\n                 ecx.evaluate_all_and_make_canonical_response(nested_goals)\n             })\n         } else {\n@@ -173,23 +176,26 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n-        if let Some(tupled_inputs_and_output) =\n+        let tcx = ecx.tcx();\n+        let Some(tupled_inputs_and_output) =\n             structural_traits::extract_tupled_inputs_and_output_from_callable(\n-                ecx.tcx(),\n+                tcx,\n                 goal.predicate.self_ty(),\n                 goal_kind,\n-            )?\n-        {\n-            let pred = tupled_inputs_and_output\n-                .map_bound(|(inputs, _)| {\n-                    ecx.tcx()\n-                        .mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n-                })\n-                .to_predicate(ecx.tcx());\n-            Self::consider_assumption(ecx, goal, pred)\n-        } else {\n-            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n-        }\n+            )? else {\n+            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+        };\n+        let output_is_sized_pred = tupled_inputs_and_output\n+            .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n+\n+        let pred = tupled_inputs_and_output\n+            .map_bound(|(inputs, _)| {\n+                tcx.mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n+            })\n+            .to_predicate(tcx);\n+        // A built-in `Fn` impl only holds if the output is sized.\n+        // (FIXME: technically we only need to check this if the type is a fn ptr...)\n+        Self::consider_implied_clause(ecx, goal, pred, [goal.with(tcx, output_is_sized_pred)])\n     }\n \n     fn consider_builtin_tuple_candidate(\n@@ -225,6 +231,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n \n         // Async generator unconditionally implement `Future`\n+        // Technically, we need to check that the future output type is Sized,\n+        // but that's already proven by the generator being WF.\n         ecx.make_canonical_response(Certainty::Yes)\n     }\n \n@@ -244,13 +252,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n \n         let generator = substs.as_generator();\n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(\n                 tcx.mk_trait_ref(goal.predicate.def_id(), [self_ty, generator.resume_ty()]),\n             )\n             .to_predicate(tcx),\n+            // Technically, we need to check that the generator types are Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n "}, {"sha": "ba473653ecfe328ff545df1011a644ab097e6cf8", "filename": "tests/ui/traits/new-solver/builtin-fn-must-return-sized.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.rs?ref=fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+#![feature(fn_traits)]\n+#![feature(unboxed_closures)]\n+#![feature(tuple_trait)]\n+\n+use std::ops::Fn;\n+use std::marker::Tuple;\n+\n+fn foo<F: Fn<T>, T: Tuple>(f: Option<F>, t: T) {\n+    let y = (f.unwrap()).call(t);\n+}\n+\n+fn main() {\n+    foo::<fn() -> str, _>(None, ());\n+    //~^ expected a `Fn<_>` closure, found `fn() -> str`\n+}"}, {"sha": "f7551739b13286dfa23e7b8e8c4bc74ceec00980", "filename": "tests/ui/traits/new-solver/builtin-fn-must-return-sized.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fbuiltin-fn-must-return-sized.stderr?ref=fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: expected a `Fn<_>` closure, found `fn() -> str`\n+  --> $DIR/builtin-fn-must-return-sized.rs:15:27\n+   |\n+LL |     foo::<fn() -> str, _>(None, ());\n+   |     --------------------- ^^^^ expected an `Fn<_>` closure, found `fn() -> str`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<_>` is not implemented for `fn() -> str`\n+note: required by a bound in `foo`\n+  --> $DIR/builtin-fn-must-return-sized.rs:10:11\n+   |\n+LL | fn foo<F: Fn<T>, T: Tuple>(f: Option<F>, t: T) {\n+   |           ^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}