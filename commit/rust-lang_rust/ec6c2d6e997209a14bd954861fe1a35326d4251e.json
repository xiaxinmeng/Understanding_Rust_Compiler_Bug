{"sha": "ec6c2d6e997209a14bd954861fe1a35326d4251e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNmMyZDZlOTk3MjA5YTE0YmQ5NTQ4NjFmZTFhMzUzMjZkNDI1MWU=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-08-01T13:25:26Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-08-01T13:27:12Z"}, "message": "Refactor compute_budgets_for_args()", "tree": {"sha": "af6c32d3a074fb54c51a4e527546893b57b57ce3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af6c32d3a074fb54c51a4e527546893b57b57ce3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec6c2d6e997209a14bd954861fe1a35326d4251e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec6c2d6e997209a14bd954861fe1a35326d4251e", "html_url": "https://github.com/rust-lang/rust/commit/ec6c2d6e997209a14bd954861fe1a35326d4251e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec6c2d6e997209a14bd954861fe1a35326d4251e/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c67f729205f4472cb688bf947041ccc98568e5d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c67f729205f4472cb688bf947041ccc98568e5d0", "html_url": "https://github.com/rust-lang/rust/commit/c67f729205f4472cb688bf947041ccc98568e5d0"}], "stats": {"total": 106, "additions": 56, "deletions": 50}, "files": [{"sha": "4c3e650c36af34fa57e97c00d5e06bc4338099e2", "filename": "src/items.rs", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ec6c2d6e997209a14bd954861fe1a35326d4251e/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6c2d6e997209a14bd954861fe1a35326d4251e/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=ec6c2d6e997209a14bd954861fe1a35326d4251e", "patch": "@@ -1835,21 +1835,15 @@ fn rewrite_fn_base(\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n \n     // Args.\n-    let (mut one_line_budget, mut multi_line_budget, mut arg_indent) =\n-        try_opt!(compute_budgets_for_args(\n-            context,\n-            &result,\n-            indent,\n-            ret_str_len,\n-            newline_brace,\n-            has_braces,\n-        ));\n-\n-    if context.config.fn_args_layout() == IndentStyle::Block {\n-        arg_indent = indent.block_indent(context.config);\n-        // 1 = \",\"\n-        multi_line_budget = context.config.max_width() - (arg_indent.width() + 1);\n-    }\n+    let (one_line_budget, multi_line_budget, mut arg_indent) = try_opt!(compute_budgets_for_args(\n+        context,\n+        &result,\n+        indent,\n+        ret_str_len,\n+        newline_brace,\n+        has_braces,\n+        multi_line_ret_str,\n+    ));\n \n     debug!(\n         \"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n@@ -1885,10 +1879,6 @@ fn rewrite_fn_base(\n         result.push(' ')\n     }\n \n-    if multi_line_ret_str {\n-        one_line_budget = 0;\n-    }\n-\n     // A conservative estimation, to goal is to be over all parens in generics\n     let args_start = generics\n         .ty_params\n@@ -1917,11 +1907,8 @@ fn rewrite_fn_base(\n         generics_str.contains('\\n'),\n     ));\n \n-    let multi_line_arg_str =\n-        arg_str.contains('\\n') || arg_str.chars().last().map_or(false, |c| c == ',');\n-\n     let put_args_in_block = match context.config.fn_args_layout() {\n-        IndentStyle::Block => multi_line_arg_str || generics_str.contains('\\n'),\n+        IndentStyle::Block => arg_str.contains('\\n') || arg_str.len() > one_line_budget,\n         _ => false,\n     } && !fd.inputs.is_empty();\n \n@@ -1936,6 +1923,12 @@ fn rewrite_fn_base(\n         result.push(')');\n     } else {\n         result.push_str(&arg_str);\n+        let used_width = last_line_used_width(&result, indent.width()) + first_line_width(&ret_str);\n+        // Put the closing brace on the next line if it overflows the max width.\n+        // 1 = `)`\n+        if fd.inputs.len() == 0 && used_width + 1 > context.config.max_width() {\n+            result.push('\\n');\n+        }\n         if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n             result.push(' ')\n         }\n@@ -1954,15 +1947,16 @@ fn rewrite_fn_base(\n     }\n \n     // Return type.\n-    if !ret_str.is_empty() {\n+    if let ast::FunctionRetTy::Ty(..) = fd.output {\n         let ret_should_indent = match context.config.fn_args_layout() {\n             // If our args are block layout then we surely must have space.\n-            IndentStyle::Block if put_args_in_block => false,\n+            IndentStyle::Block if put_args_in_block || fd.inputs.len() == 0 => false,\n+            _ if args_last_line_contains_comment => false,\n+            _ if result.contains('\\n') || multi_line_ret_str => true,\n             _ => {\n-                // If we've already gone multi-line, or the return type would push over the max\n-                // width, then put the return type on a new line. With the +1 for the signature\n-                // length an additional space between the closing parenthesis of the argument and\n-                // the arrow '->' is considered.\n+                // If the return type would push over the max width, then put the return type on\n+                // a new line. With the +1 for the signature length an additional space between\n+                // the closing parenthesis of the argument and the arrow '->' is considered.\n                 let mut sig_length = result.len() + indent.width() + ret_str_len + 1;\n \n                 // If there is no where clause, take into account the space after the return type\n@@ -1971,10 +1965,7 @@ fn rewrite_fn_base(\n                     sig_length += 2;\n                 }\n \n-                let overlong_sig = sig_length > context.config.max_width();\n-\n-                (!args_last_line_contains_comment) &&\n-                    (result.contains('\\n') || multi_line_ret_str || overlong_sig)\n+                sig_length > context.config.max_width()\n             }\n         };\n         let ret_indent = if ret_should_indent {\n@@ -2276,6 +2267,7 @@ fn compute_budgets_for_args(\n     ret_str_len: usize,\n     newline_brace: bool,\n     has_braces: bool,\n+    force_vertical_layout: bool,\n ) -> Option<((usize, usize, Indent))> {\n     debug!(\n         \"compute_budgets_for_args {} {:?}, {}, {}\",\n@@ -2285,7 +2277,7 @@ fn compute_budgets_for_args(\n         newline_brace\n     );\n     // Try keeping everything on the same line.\n-    if !result.contains('\\n') {\n+    if !result.contains('\\n') && !force_vertical_layout {\n         // 2 = `()`, 3 = `() `, space is before ret_string.\n         let overhead = if ret_str_len == 0 { 2 } else { 3 };\n         let mut used_space = indent.width() + result.len() + ret_str_len + overhead;\n@@ -2306,31 +2298,45 @@ fn compute_budgets_for_args(\n \n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n-            let multi_line_overhead =\n-                indent.width() + result.len() + if newline_brace { 2 } else { 4 };\n-            let multi_line_budget =\n-                try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n-\n-            return Some((\n-                one_line_budget,\n-                multi_line_budget,\n-                indent + result.len() + 1,\n-            ));\n+            let (indent, multi_line_budget) = match context.config.fn_args_layout() {\n+                IndentStyle::Block => {\n+                    let indent = indent.block_indent(context.config);\n+                    let budget =\n+                        try_opt!(context.config.max_width().checked_sub(indent.width() + 1));\n+                    (indent, budget)\n+                }\n+                IndentStyle::Visual => {\n+                    let indent = indent + result.len() + 1;\n+                    let multi_line_overhead =\n+                        indent.width() + result.len() + if newline_brace { 2 } else { 4 };\n+                    let budget =\n+                        try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n+                    (indent, budget)\n+                }\n+            };\n+\n+            return Some((one_line_budget, multi_line_budget, indent));\n         }\n     }\n \n     // Didn't work. we must force vertical layout and put args on a newline.\n     let new_indent = indent.block_indent(context.config);\n-    // Account for `)` and possibly ` {`.\n-    let used_space = new_indent.width() + if ret_str_len == 0 { 1 } else { 3 };\n+    let used_space = match context.config.fn_args_layout() {\n+        // 1 = `,`\n+        IndentStyle::Block => new_indent.width() + 1,\n+        // Account for `)` and possibly ` {`.\n+        IndentStyle::Visual => new_indent.width() + if ret_str_len == 0 { 1 } else { 3 },\n+    };\n     let max_space = try_opt!(context.config.max_width().checked_sub(used_space));\n     Some((0, max_space, new_indent))\n }\n \n-fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n-    match config.fn_brace_style() {\n-        BraceStyle::AlwaysNextLine => true,\n-        BraceStyle::SameLineWhere if !where_clause.predicates.is_empty() => true,\n+fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause, has_body: bool) -> bool {\n+    match (config.fn_brace_style(), config.where_density()) {\n+        (BraceStyle::AlwaysNextLine, _) => true,\n+        (_, Density::Compressed) if where_clause.predicates.len() == 1 => false,\n+        (_, Density::CompressedIfEmpty) if where_clause.predicates.len() == 1 && !has_body => false,\n+        (BraceStyle::SameLineWhere, _) if !where_clause.predicates.is_empty() => true,\n         _ => false,\n     }\n }"}]}