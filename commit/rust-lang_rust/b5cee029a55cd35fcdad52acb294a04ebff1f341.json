{"sha": "b5cee029a55cd35fcdad52acb294a04ebff1f341", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1Y2VlMDI5YTU1Y2QzNWZjZGFkNTJhY2IyOTRhMDRlYmZmMWYzNDE=", "commit": {"author": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2018-05-05T04:33:20Z"}, "committer": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2018-06-27T21:54:27Z"}, "message": "Add str::split_ascii_whitespace.", "tree": {"sha": "038c8066457355be5193c16c4efe8e9a2bc3af21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038c8066457355be5193c16c4efe8e9a2bc3af21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5cee029a55cd35fcdad52acb294a04ebff1f341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5cee029a55cd35fcdad52acb294a04ebff1f341", "html_url": "https://github.com/rust-lang/rust/commit/b5cee029a55cd35fcdad52acb294a04ebff1f341", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5cee029a55cd35fcdad52acb294a04ebff1f341/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23b55161ab4cb6d4bf868ac575bd174ca2de0ffa", "url": "https://api.github.com/repos/rust-lang/rust/commits/23b55161ab4cb6d4bf868ac575bd174ca2de0ffa", "html_url": "https://github.com/rust-lang/rust/commit/23b55161ab4cb6d4bf868ac575bd174ca2de0ffa"}], "stats": {"total": 162, "additions": 158, "deletions": 4}, "files": [{"sha": "ec9b5eba561060a21efc741df7d0d9867d40796a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5cee029a55cd35fcdad52acb294a04ebff1f341/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5cee029a55cd35fcdad52acb294a04ebff1f341/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=b5cee029a55cd35fcdad52acb294a04ebff1f341", "patch": "@@ -108,6 +108,7 @@\n #![cfg_attr(stage0, feature(repr_transparent))]\n #![feature(rustc_attrs)]\n #![feature(specialization)]\n+#![feature(split_ascii_whitespace)]\n #![feature(staged_api)]\n #![feature(str_internals)]\n #![feature(trusted_len)]"}, {"sha": "ec9c39c916c4720badead169b96ad7a321588696", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5cee029a55cd35fcdad52acb294a04ebff1f341/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5cee029a55cd35fcdad52acb294a04ebff1f341/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=b5cee029a55cd35fcdad52acb294a04ebff1f341", "patch": "@@ -78,6 +78,8 @@ pub use core::str::SplitWhitespace;\n pub use core::str::pattern;\n #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n pub use core::str::EncodeUtf16;\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+pub use core::str::SplitAsciiWhitespace;\n \n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\","}, {"sha": "5ae2f6349e5b7e335846eeafb779c40e7ca106eb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 155, "deletions": 4, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/b5cee029a55cd35fcdad52acb294a04ebff1f341/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5cee029a55cd35fcdad52acb294a04ebff1f341/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b5cee029a55cd35fcdad52acb294a04ebff1f341", "patch": "@@ -21,7 +21,7 @@ use char;\n use fmt;\n use iter::{Map, Cloned, FusedIterator, TrustedLen, Filter};\n use iter_private::TrustedRandomAccess;\n-use slice::{self, SliceIndex};\n+use slice::{self, SliceIndex, Split as SliceSplit};\n use mem;\n \n pub mod pattern;\n@@ -2722,7 +2722,10 @@ impl str {\n     /// the original string slice, separated by any amount of whitespace.\n     ///\n     /// 'Whitespace' is defined according to the terms of the Unicode Derived\n-    /// Core Property `White_Space`.\n+    /// Core Property `White_Space`. If you only want to split on ASCII whitespace\n+    /// instead, use [`split_ascii_whitespace`].\n+    ///\n+    /// [`split_ascii_whitespace`]: #method.split_ascii_whitespace\n     ///\n     /// # Examples\n     ///\n@@ -2756,6 +2759,53 @@ impl str {\n         SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n     }\n \n+    /// Split a string slice by ASCII whitespace.\n+    ///\n+    /// The iterator returned will return string slices that are sub-slices of\n+    /// the original string slice, separated by any amount of ASCII whitespace.\n+    ///\n+    /// To split by Unicode `Whitespace` instead, use [`split_whitespace`].\n+    ///\n+    /// [`split_whitespace`]: #method.split_whitespace\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(split_ascii_whitespace)]\n+    /// let mut iter = \"A few words\".split_ascii_whitespace();\n+    ///\n+    /// assert_eq!(Some(\"A\"), iter.next());\n+    /// assert_eq!(Some(\"few\"), iter.next());\n+    /// assert_eq!(Some(\"words\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    ///\n+    /// All kinds of ASCII whitespace are considered:\n+    ///\n+    /// ```\n+    /// let mut iter = \" Mary   had\\ta little  \\n\\t lamb\".split_whitespace();\n+    /// assert_eq!(Some(\"Mary\"), iter.next());\n+    /// assert_eq!(Some(\"had\"), iter.next());\n+    /// assert_eq!(Some(\"a\"), iter.next());\n+    /// assert_eq!(Some(\"little\"), iter.next());\n+    /// assert_eq!(Some(\"lamb\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+    #[inline]\n+    pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace {\n+        let inner = self\n+            .as_bytes()\n+            .split(IsAsciiWhitespace)\n+            .filter(IsNotEmpty)\n+            .map(UnsafeBytesToStr);\n+        SplitAsciiWhitespace { inner }\n+    }\n+\n     /// An iterator over the lines of a string, as string slices.\n     ///\n     /// Lines are ended with either a newline (`\\n`) or a carriage return with\n@@ -3895,6 +3945,20 @@ pub struct SplitWhitespace<'a> {\n     inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n }\n \n+/// An iterator over the non-ASCII-whitespace substrings of a string,\n+/// separated by any amount of ASCII whitespace.\n+///\n+/// This struct is created by the [`split_ascii_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_ascii_whitespace`]: ../../std/primitive.str.html#method.split_ascii_whitespace\n+/// [`str`]: ../../std/primitive.str.html\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitAsciiWhitespace<'a> {\n+    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, IsNotEmpty>, UnsafeBytesToStr>,\n+}\n+\n #[derive(Clone)]\n struct IsWhitespace;\n \n@@ -3914,37 +3978,98 @@ impl FnMut<(char, )> for IsWhitespace {\n     }\n }\n \n+#[derive(Clone)]\n+struct IsAsciiWhitespace;\n+\n+impl<'a> FnOnce<(&'a u8, )> for IsAsciiWhitespace {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&u8, )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a> FnMut<(&'a u8, )> for IsAsciiWhitespace {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&u8, )) -> bool {\n+        arg.0.is_ascii_whitespace()\n+    }\n+}\n+\n #[derive(Clone)]\n struct IsNotEmpty;\n \n impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n     type Output = bool;\n \n     #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&&str, )) -> bool {\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b str, )) -> bool {\n         self.call_mut(arg)\n     }\n }\n \n impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n     #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&&str, )) -> bool {\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b str, )) -> bool {\n+        !arg.0.is_empty()\n+    }\n+}\n+\n+impl<'a, 'b> FnOnce<(&'a &'b [u8], )> for IsNotEmpty {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u8], )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a, 'b> FnMut<(&'a &'b [u8], )> for IsNotEmpty {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u8], )) -> bool {\n         !arg.0.is_empty()\n     }\n }\n \n+#[derive(Clone)]\n+struct UnsafeBytesToStr;\n+\n+impl<'a> FnOnce<(&'a [u8], )> for UnsafeBytesToStr {\n+    type Output = &'a str;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a [u8], )) -> &'a str {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a> FnMut<(&'a [u8], )> for UnsafeBytesToStr {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a [u8], )) -> &'a str {\n+        unsafe { from_utf8_unchecked(arg.0) }\n+    }\n+}\n+\n \n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n \n+    #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         self.inner.next()\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n+    #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         self.inner.next_back()\n     }\n@@ -3953,6 +4078,32 @@ impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for SplitWhitespace<'a> {}\n \n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+impl<'a> Iterator for SplitAsciiWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+impl<'a> FusedIterator for SplitAsciiWhitespace<'a> {}\n+\n /// An iterator of [`u16`] over the string encoded as UTF-16.\n ///\n /// [`u16`]: ../../std/primitive.u16.html"}]}