{"sha": "8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOGQ1NDJkZmExZDNiODMwODhhMWY0OGE5MTY2NWU5NWZkMDA4Y2M=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-17T09:34:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-17T09:34:08Z"}, "message": "Merge #3108\n\n3108: Magic Completion for `impl Trait for` Associated Items r=matklad a=kdelorey\n\n# Summary\r\nThis PR adds a set of magic completions to auto complete associated trait items (functions/consts/types). \r\n\r\n![Associated Trait Impl](https://user-images.githubusercontent.com/2295721/74493144-d8f1af00-4e96-11ea-93a4-82725bf89646.gif)\r\n\r\n## Notes\r\nSince the assist and completion share the same logic when figuring out the associated items that are missing, a shared utility was created in the `ra_assists::utils` module.\r\n\r\nResolves #1046 \r\n\r\nAs this is my first PR to the rust-analyzer project, I'm new to the codebase, feedback welcomed!\n\nCo-authored-by: Kevin DeLorey <2295721+kdelorey@users.noreply.github.com>", "tree": {"sha": "495e3d223f595404e46d5e58b426cda4b0c633bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495e3d223f595404e46d5e58b426cda4b0c633bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeSl4QCRBK7hj4Ov3rIwAAdHIIAEQYNp0DPHKCn+hxKbo9guql\nZU7WeU1ESRWIQY3TCLq4oUzyho890Jwj7VlBa5eoLQCIWD+zfhWvhRllMSPRXNCZ\nwO3vVJ7nRJV7ecM91BYV4HApjRStX5X/MlkEVHCMyaFYyEjTRta1nhV5FLnwW2RC\nDnltwn25tSrD2hxJ1vdj2fMIe2kUa4Ck97XTtF3zOWOoemEzfmyBm3sQjwlW58Fa\ndbRve3nJ0/VvP2nYCZCj1eOeA92nBtlBgq2g8lX3ZZmSkCooN/qL4f+6g07wazMN\nZkxvt3kzpvRp5rQfBlZ+B6uvdUW6EgT+lZz8/ysiirJ04WZKNbaJHa/xDOJw+HI=\n=kGY+\n-----END PGP SIGNATURE-----\n", "payload": "tree 495e3d223f595404e46d5e58b426cda4b0c633bc\nparent 953dbe3e02fa87bab2f12452746e6c50a47ac153\nparent 057d0bee5516dc7cba71479b27227c5ad22140ee\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1581932048 +0000\ncommitter GitHub <noreply@github.com> 1581932048 +0000\n\nMerge #3108\n\n3108: Magic Completion for `impl Trait for` Associated Items r=matklad a=kdelorey\n\n# Summary\r\nThis PR adds a set of magic completions to auto complete associated trait items (functions/consts/types). \r\n\r\n![Associated Trait Impl](https://user-images.githubusercontent.com/2295721/74493144-d8f1af00-4e96-11ea-93a4-82725bf89646.gif)\r\n\r\n## Notes\r\nSince the assist and completion share the same logic when figuring out the associated items that are missing, a shared utility was created in the `ra_assists::utils` module.\r\n\r\nResolves #1046 \r\n\r\nAs this is my first PR to the rust-analyzer project, I'm new to the codebase, feedback welcomed!\n\nCo-authored-by: Kevin DeLorey <2295721+kdelorey@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "html_url": "https://github.com/rust-lang/rust/commit/8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "953dbe3e02fa87bab2f12452746e6c50a47ac153", "url": "https://api.github.com/repos/rust-lang/rust/commits/953dbe3e02fa87bab2f12452746e6c50a47ac153", "html_url": "https://github.com/rust-lang/rust/commit/953dbe3e02fa87bab2f12452746e6c50a47ac153"}, {"sha": "057d0bee5516dc7cba71479b27227c5ad22140ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/057d0bee5516dc7cba71479b27227c5ad22140ee", "html_url": "https://github.com/rust-lang/rust/commit/057d0bee5516dc7cba71479b27227c5ad22140ee"}], "stats": {"total": 572, "additions": 536, "deletions": 36}, "files": [{"sha": "ab21388c8d4159a6974b632ca366a6ed7c24687c", "filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "patch": "@@ -1,11 +1,12 @@\n-use hir::{db::HirDatabase, HasSource, InFile};\n+use hir::{HasSource, InFile};\n use ra_syntax::{\n     ast::{self, edit, make, AstNode, NameOwner},\n     SmolStr,\n };\n \n use crate::{\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n+    utils::{get_missing_impl_items, resolve_target_trait},\n     Assist, AssistCtx, AssistId,\n };\n \n@@ -103,11 +104,9 @@ fn add_missing_impl_members_inner(\n     let impl_node = ctx.find_node_at_offset::<ast::ImplBlock>()?;\n     let impl_item_list = impl_node.item_list()?;\n \n-    let (trait_, trait_def) = {\n-        let analyzer = ctx.source_analyzer(impl_node.syntax(), None);\n+    let analyzer = ctx.source_analyzer(impl_node.syntax(), None);\n \n-        resolve_target_trait_def(ctx.db, &analyzer, &impl_node)?\n-    };\n+    let trait_ = resolve_target_trait(ctx.db, &analyzer, &impl_node)?;\n \n     let def_name = |item: &ast::ImplItem| -> Option<SmolStr> {\n         match item {\n@@ -118,20 +117,23 @@ fn add_missing_impl_members_inner(\n         .map(|it| it.text().clone())\n     };\n \n-    let trait_items = trait_def.item_list()?.impl_items();\n-    let impl_items = impl_item_list.impl_items().collect::<Vec<_>>();\n-\n-    let missing_items: Vec<_> = trait_items\n-        .filter(|t| def_name(t).is_some())\n+    let missing_items = get_missing_impl_items(ctx.db, &analyzer, &impl_node)\n+        .iter()\n+        .map(|i| match i {\n+            hir::AssocItem::Function(i) => ast::ImplItem::FnDef(i.source(ctx.db).value),\n+            hir::AssocItem::TypeAlias(i) => ast::ImplItem::TypeAliasDef(i.source(ctx.db).value),\n+            hir::AssocItem::Const(i) => ast::ImplItem::ConstDef(i.source(ctx.db).value),\n+        })\n+        .filter(|t| def_name(&t).is_some())\n         .filter(|t| match t {\n             ast::ImplItem::FnDef(def) => match mode {\n                 AddMissingImplMembersMode::DefaultMethodsOnly => def.body().is_some(),\n                 AddMissingImplMembersMode::NoDefaultMethods => def.body().is_none(),\n             },\n             _ => mode == AddMissingImplMembersMode::NoDefaultMethods,\n         })\n-        .filter(|t| impl_items.iter().all(|i| def_name(i) != def_name(t)))\n-        .collect();\n+        .collect::<Vec<_>>();\n+\n     if missing_items.is_empty() {\n         return None;\n     }\n@@ -177,27 +179,6 @@ fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n     }\n }\n \n-/// Given an `ast::ImplBlock`, resolves the target trait (the one being\n-/// implemented) to a `ast::TraitDef`.\n-fn resolve_target_trait_def(\n-    db: &impl HirDatabase,\n-    analyzer: &hir::SourceAnalyzer,\n-    impl_block: &ast::ImplBlock,\n-) -> Option<(hir::Trait, ast::TraitDef)> {\n-    let ast_path = impl_block\n-        .target_trait()\n-        .map(|it| it.syntax().clone())\n-        .and_then(ast::PathType::cast)?\n-        .path()?;\n-\n-    match analyzer.resolve_path(db, &ast_path) {\n-        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => {\n-            Some((def, def.source(db).value))\n-        }\n-        _ => None,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "cb124eaf0d2c8a6f08ff07f173e6ded1f3231481", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "patch": "@@ -9,7 +9,7 @@ mod assist_ctx;\n mod marks;\n #[cfg(test)]\n mod doc_tests;\n-mod utils;\n+pub mod utils;\n pub mod ast_transform;\n \n use ra_db::FileRange;"}, {"sha": "6ff44c95cb25716cdea820f919fd7dbeb5241a0c", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "patch": "@@ -1,10 +1,81 @@\n //! Assorted functions shared by several assists.\n \n use ra_syntax::{\n-    ast::{self, make},\n-    T,\n+    ast::{self, make, NameOwner},\n+    AstNode, T,\n };\n \n+use hir::db::HirDatabase;\n+use rustc_hash::FxHashSet;\n+\n+pub fn get_missing_impl_items(\n+    db: &impl HirDatabase,\n+    analyzer: &hir::SourceAnalyzer,\n+    impl_block: &ast::ImplBlock,\n+) -> Vec<hir::AssocItem> {\n+    // Names must be unique between constants and functions. However, type aliases\n+    // may share the same name as a function or constant.\n+    let mut impl_fns_consts = FxHashSet::default();\n+    let mut impl_type = FxHashSet::default();\n+\n+    if let Some(item_list) = impl_block.item_list() {\n+        for item in item_list.impl_items() {\n+            match item {\n+                ast::ImplItem::FnDef(f) => {\n+                    if let Some(n) = f.name() {\n+                        impl_fns_consts.insert(n.syntax().to_string());\n+                    }\n+                }\n+\n+                ast::ImplItem::TypeAliasDef(t) => {\n+                    if let Some(n) = t.name() {\n+                        impl_type.insert(n.syntax().to_string());\n+                    }\n+                }\n+\n+                ast::ImplItem::ConstDef(c) => {\n+                    if let Some(n) = c.name() {\n+                        impl_fns_consts.insert(n.syntax().to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    resolve_target_trait(db, analyzer, impl_block).map_or(vec![], |target_trait| {\n+        target_trait\n+            .items(db)\n+            .iter()\n+            .filter(|i| match i {\n+                hir::AssocItem::Function(f) => !impl_fns_consts.contains(&f.name(db).to_string()),\n+                hir::AssocItem::TypeAlias(t) => !impl_type.contains(&t.name(db).to_string()),\n+                hir::AssocItem::Const(c) => c\n+                    .name(db)\n+                    .map(|n| !impl_fns_consts.contains(&n.to_string()))\n+                    .unwrap_or_default(),\n+            })\n+            .cloned()\n+            .collect()\n+    })\n+}\n+\n+pub(crate) fn resolve_target_trait(\n+    db: &impl HirDatabase,\n+    analyzer: &hir::SourceAnalyzer,\n+    impl_block: &ast::ImplBlock,\n+) -> Option<hir::Trait> {\n+    let ast_path = impl_block\n+        .target_trait()\n+        .map(|it| it.syntax().clone())\n+        .and_then(ast::PathType::cast)?\n+        .path()?;\n+\n+    match analyzer.resolve_path(db, &ast_path) {\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def),\n+        _ => None,\n+    }\n+}\n+\n pub(crate) fn invert_boolean_expression(expr: ast::Expr) -> ast::Expr {\n     if let Some(expr) = invert_special_case(&expr) {\n         return expr;"}, {"sha": "4bdc6ba232b84c6ce2f9d13f6569177893167650", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "patch": "@@ -15,6 +15,7 @@ mod complete_path;\n mod complete_scope;\n mod complete_postfix;\n mod complete_macro_in_item_position;\n+mod complete_trait_impl;\n \n use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n@@ -74,5 +75,7 @@ pub(crate) fn completions(db: &RootDatabase, position: FilePosition) -> Option<C\n     complete_pattern::complete_pattern(&mut acc, &ctx);\n     complete_postfix::complete_postfix(&mut acc, &ctx);\n     complete_macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);\n+    complete_trait_impl::complete_trait_impl(&mut acc, &ctx);\n+\n     Some(acc)\n }"}, {"sha": "6ff10c01709e9cd50b3c0897ae75d3990ed0635a", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "patch": "@@ -0,0 +1,436 @@\n+//! Completion for associated items in a trait implementation.\n+//!\n+//! This module adds the completion items related to implementing associated\n+//! items within a `impl Trait for Struct` block. The current context node\n+//! must be within either a `FN_DEF`, `TYPE_ALIAS_DEF`, or `CONST_DEF` node\n+//! and an direct child of an `IMPL_BLOCK`.\n+//!\n+//! # Examples\n+//!\n+//! Considering the following trait `impl`:\n+//!\n+//! ```ignore\n+//! trait SomeTrait {\n+//!     fn foo();\n+//! }\n+//!\n+//! impl SomeTrait for () {\n+//!     fn f<|>\n+//! }\n+//! ```\n+//!\n+//! may result in the completion of the following method:\n+//!\n+//! ```ignore\n+//! # trait SomeTrait {\n+//! #    fn foo();\n+//! # }\n+//!\n+//! impl SomeTrait for () {\n+//!     fn foo() {}<|>\n+//! }\n+//! ```\n+\n+use hir::{self, Docs, HasSource};\n+use ra_assists::utils::get_missing_impl_items;\n+use ra_syntax::{\n+    ast::{self, edit},\n+    AstNode, SyntaxKind, SyntaxNode, TextRange,\n+};\n+use ra_text_edit::TextEdit;\n+\n+use crate::{\n+    completion::{\n+        CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n+    },\n+    display::FunctionSignature,\n+};\n+\n+pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n+    let trigger = ctx.token.ancestors().find(|p| match p.kind() {\n+        SyntaxKind::FN_DEF\n+        | SyntaxKind::TYPE_ALIAS_DEF\n+        | SyntaxKind::CONST_DEF\n+        | SyntaxKind::BLOCK_EXPR => true,\n+        _ => false,\n+    });\n+\n+    let impl_block = trigger\n+        .as_ref()\n+        .and_then(|node| node.parent())\n+        .and_then(|node| node.parent())\n+        .and_then(|node| ast::ImplBlock::cast(node));\n+\n+    if let (Some(trigger), Some(impl_block)) = (trigger, impl_block) {\n+        match trigger.kind() {\n+            SyntaxKind::FN_DEF => {\n+                for missing_fn in get_missing_impl_items(ctx.db, &ctx.analyzer, &impl_block)\n+                    .iter()\n+                    .filter_map(|item| match item {\n+                        hir::AssocItem::Function(fn_item) => Some(fn_item),\n+                        _ => None,\n+                    })\n+                {\n+                    add_function_impl(&trigger, acc, ctx, &missing_fn);\n+                }\n+            }\n+\n+            SyntaxKind::TYPE_ALIAS_DEF => {\n+                for missing_fn in get_missing_impl_items(ctx.db, &ctx.analyzer, &impl_block)\n+                    .iter()\n+                    .filter_map(|item| match item {\n+                        hir::AssocItem::TypeAlias(type_item) => Some(type_item),\n+                        _ => None,\n+                    })\n+                {\n+                    add_type_alias_impl(&trigger, acc, ctx, &missing_fn);\n+                }\n+            }\n+\n+            SyntaxKind::CONST_DEF => {\n+                for missing_fn in get_missing_impl_items(ctx.db, &ctx.analyzer, &impl_block)\n+                    .iter()\n+                    .filter_map(|item| match item {\n+                        hir::AssocItem::Const(const_item) => Some(const_item),\n+                        _ => None,\n+                    })\n+                {\n+                    add_const_impl(&trigger, acc, ctx, &missing_fn);\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+}\n+\n+fn add_function_impl(\n+    fn_def_node: &SyntaxNode,\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    func: &hir::Function,\n+) {\n+    let display = FunctionSignature::from_hir(ctx.db, func.clone());\n+\n+    let fn_name = func.name(ctx.db).to_string();\n+\n+    let label = if func.params(ctx.db).len() > 0 {\n+        format!(\"fn {}(..)\", fn_name)\n+    } else {\n+        format!(\"fn {}()\", fn_name)\n+    };\n+\n+    let builder = CompletionItem::new(CompletionKind::Magic, ctx.source_range(), label.clone())\n+        .lookup_by(fn_name)\n+        .set_documentation(func.docs(ctx.db));\n+\n+    let completion_kind = if func.has_self_param(ctx.db) {\n+        CompletionItemKind::Method\n+    } else {\n+        CompletionItemKind::Function\n+    };\n+\n+    let snippet = format!(\"{} {{}}\", display);\n+\n+    let range = TextRange::from_to(fn_def_node.text_range().start(), ctx.source_range().end());\n+\n+    builder.text_edit(TextEdit::replace(range, snippet)).kind(completion_kind).add_to(acc);\n+}\n+\n+fn add_type_alias_impl(\n+    type_def_node: &SyntaxNode,\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    type_alias: &hir::TypeAlias,\n+) {\n+    let alias_name = type_alias.name(ctx.db).to_string();\n+\n+    let snippet = format!(\"type {} = \", alias_name);\n+\n+    let range = TextRange::from_to(type_def_node.text_range().start(), ctx.source_range().end());\n+\n+    CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone())\n+        .text_edit(TextEdit::replace(range, snippet))\n+        .lookup_by(alias_name)\n+        .kind(CompletionItemKind::TypeAlias)\n+        .set_documentation(type_alias.docs(ctx.db))\n+        .add_to(acc);\n+}\n+\n+fn add_const_impl(\n+    const_def_node: &SyntaxNode,\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    const_: &hir::Const,\n+) {\n+    let const_name = const_.name(ctx.db).map(|n| n.to_string());\n+\n+    if let Some(const_name) = const_name {\n+        let snippet = make_const_compl_syntax(&const_.source(ctx.db).value);\n+\n+        let range =\n+            TextRange::from_to(const_def_node.text_range().start(), ctx.source_range().end());\n+\n+        CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone())\n+            .text_edit(TextEdit::replace(range, snippet))\n+            .lookup_by(const_name)\n+            .kind(CompletionItemKind::Const)\n+            .set_documentation(const_.docs(ctx.db))\n+            .add_to(acc);\n+    }\n+}\n+\n+fn make_const_compl_syntax(const_: &ast::ConstDef) -> String {\n+    let const_ = edit::strip_attrs_and_docs(const_);\n+\n+    let const_start = const_.syntax().text_range().start();\n+    let const_end = const_.syntax().text_range().end();\n+\n+    let start =\n+        const_.syntax().first_child_or_token().map_or(const_start, |f| f.text_range().start());\n+\n+    let end = const_\n+        .syntax()\n+        .children_with_tokens()\n+        .find(|s| s.kind() == SyntaxKind::SEMI || s.kind() == SyntaxKind::EQ)\n+        .map_or(const_end, |f| f.text_range().start());\n+\n+    let len = end - start;\n+    let range = TextRange::from_to(0.into(), len);\n+\n+    let syntax = const_.syntax().text().slice(range).to_string();\n+\n+    format!(\"{} = \", syntax.trim_end())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{do_completion, CompletionItem, CompletionKind};\n+    use insta::assert_debug_snapshot;\n+\n+    fn complete(code: &str) -> Vec<CompletionItem> {\n+        do_completion(code, CompletionKind::Magic)\n+    }\n+\n+    #[test]\n+    fn single_function() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                fn foo();\n+            }\n+\n+            struct T1;\n+\n+            impl Test for T1 {\n+                fn f<|>\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"fn foo()\",\n+                source_range: [141; 142),\n+                delete: [138; 142),\n+                insert: \"fn foo() {}\",\n+                kind: Function,\n+                lookup: \"foo\",\n+            },\n+        ]\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn hide_implemented_fn() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                fn foo();\n+                fn foo_bar();\n+            }\n+\n+            struct T1;\n+\n+            impl Test for T1 {\n+                fn foo() {}\n+\n+                fn f<|>\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"fn foo_bar()\",\n+                source_range: [200; 201),\n+                delete: [197; 201),\n+                insert: \"fn foo_bar() {}\",\n+                kind: Function,\n+                lookup: \"foo_bar\",\n+            },\n+        ]\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn completes_only_on_top_level() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                fn foo();\n+\n+                fn foo_bar();\n+            }\n+\n+            struct T1;\n+\n+            impl Test for T1 {\n+                fn foo() {\n+                    <|>\n+                }\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"[]\"###);\n+    }\n+\n+    #[test]\n+    fn generic_fn() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                fn foo<T>();\n+            }\n+\n+            struct T1;\n+\n+            impl Test for T1 {\n+                fn f<|>\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"fn foo()\",\n+                source_range: [144; 145),\n+                delete: [141; 145),\n+                insert: \"fn foo<T>() {}\",\n+                kind: Function,\n+                lookup: \"foo\",\n+            },\n+        ]\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn generic_constrait_fn() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                fn foo<T>() where T: Into<String>;\n+            }\n+\n+            struct T1;\n+\n+            impl Test for T1 {\n+                fn f<|>\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"fn foo()\",\n+                source_range: [166; 167),\n+                delete: [163; 167),\n+                insert: \"fn foo<T>()\\nwhere T: Into<String> {}\",\n+                kind: Function,\n+                lookup: \"foo\",\n+            },\n+        ]\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn associated_type() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                type SomeType;\n+            }\n+\n+            impl Test for () {\n+                type S<|>\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"type SomeType = \",\n+                source_range: [124; 125),\n+                delete: [119; 125),\n+                insert: \"type SomeType = \",\n+                kind: TypeAlias,\n+                lookup: \"SomeType\",\n+            },\n+        ]\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn associated_const() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                const SOME_CONST: u16;\n+            }\n+\n+            impl Test for () {\n+                const S<|>\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"const SOME_CONST: u16 = \",\n+                source_range: [133; 134),\n+                delete: [127; 134),\n+                insert: \"const SOME_CONST: u16 = \",\n+                kind: Const,\n+                lookup: \"SOME_CONST\",\n+            },\n+        ]\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn associated_const_with_default() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                const SOME_CONST: u16 = 42;\n+            }\n+\n+            impl Test for () {\n+                const S<|>\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"const SOME_CONST: u16 = \",\n+                source_range: [138; 139),\n+                delete: [132; 139),\n+                insert: \"const SOME_CONST: u16 = \",\n+                kind: Const,\n+                lookup: \"SOME_CONST\",\n+            },\n+        ]\n+        \"###);\n+    }\n+}"}, {"sha": "8678a3234f14f489e3eda4e6ce3019897f6d3f79", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d542dfa1d3b83088a1f48a91665e95fd008cc/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=8d8d542dfa1d3b83088a1f48a91665e95fd008cc", "patch": "@@ -25,6 +25,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) use_item_syntax: Option<ast::UseItem>,\n     pub(super) record_lit_syntax: Option<ast::RecordLit>,\n     pub(super) record_lit_pat: Option<ast::RecordPat>,\n+    pub(super) impl_block: Option<ast::ImplBlock>,\n     pub(super) is_param: bool,\n     /// If a name-binding or reference to a const in a pattern.\n     /// Irrefutable patterns (like let) are excluded.\n@@ -72,6 +73,7 @@ impl<'a> CompletionContext<'a> {\n             use_item_syntax: None,\n             record_lit_syntax: None,\n             record_lit_pat: None,\n+            impl_block: None,\n             is_param: false,\n             is_pat_binding: false,\n             is_trivial_path: false,\n@@ -148,6 +150,13 @@ impl<'a> CompletionContext<'a> {\n             self.record_lit_syntax = find_node_at_offset(original_file.syntax(), self.offset);\n         }\n \n+        self.impl_block = self\n+            .token\n+            .parent()\n+            .ancestors()\n+            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+            .find_map(ast::ImplBlock::cast);\n+\n         let top_node = name_ref\n             .syntax()\n             .ancestors()"}]}