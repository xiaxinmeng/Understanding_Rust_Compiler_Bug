{"sha": "c6e1e17a10f9a0c55dad34419403d1327680f240", "node_id": "C_kwDOAAsO6NoAKGM2ZTFlMTdhMTBmOWEwYzU1ZGFkMzQ0MTk0MDNkMTMyNzY4MGYyNDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-27T12:37:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-27T12:37:50Z"}, "message": "Auto merge of #13494 - lowr:feat/gats, r=flodiebold\n\nfeat: type inference for generic associated types\n\nThis PR implements type inference for generic associated types. Basically, this PR lowers generic arguments for associated types in valid places and creates `Substitution`s for them.\n\nI focused on the inference for correct Rust programs, so there are cases where we *accidentally* manage to infer things that are actually invalid (which would then be reported by flycheck so I deem them non-fatal). See the following tests and FIXME notes on them: `gats_with_dyn`, `gats_with_impl_trait`.\n\nThe added tests are rather arbitrary. Let me know if there are cases I'm missing or I should add.\n\nCloses #9673", "tree": {"sha": "e7637b892614d790836782cb91e72e0d9827de97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7637b892614d790836782cb91e72e0d9827de97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6e1e17a10f9a0c55dad34419403d1327680f240", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e1e17a10f9a0c55dad34419403d1327680f240", "html_url": "https://github.com/rust-lang/rust/commit/c6e1e17a10f9a0c55dad34419403d1327680f240", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6e1e17a10f9a0c55dad34419403d1327680f240/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0340b51ff710daf8e8b8895e8fc1a12c95e8886f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0340b51ff710daf8e8b8895e8fc1a12c95e8886f", "html_url": "https://github.com/rust-lang/rust/commit/0340b51ff710daf8e8b8895e8fc1a12c95e8886f"}, {"sha": "5fc18ad6fa635adac058160bc7ba13e53abd5ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc18ad6fa635adac058160bc7ba13e53abd5ece", "html_url": "https://github.com/rust-lang/rust/commit/5fc18ad6fa635adac058160bc7ba13e53abd5ece"}], "stats": {"total": 479, "additions": 381, "deletions": 98}, "files": [{"sha": "79249757d9e9bb407aee638c8338e489b58c7842", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -662,8 +662,12 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     let mut generic_args: Vec<_> =\n         std::iter::repeat(None).take(path.segments().len() - 1).collect();\n     let mut last = GenericArgs::empty();\n-    let binding =\n-        AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };\n+    let binding = AssociatedTypeBinding {\n+        name: name![Output],\n+        args: None,\n+        type_ref: Some(orig),\n+        bounds: Vec::new(),\n+    };\n     last.bindings.push(binding);\n     generic_args.push(Some(Interned::new(last)));\n "}, {"sha": "592223f7d85fe76c020892ce158625c9eeec28a5", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -68,6 +68,9 @@ pub struct GenericArgs {\n pub struct AssociatedTypeBinding {\n     /// The name of the associated type.\n     pub name: Name,\n+    /// The generic arguments to the associated type. e.g. For `Trait<Assoc<'a, T> = &'a T>`, this\n+    /// would be `['a, T]`.\n+    pub args: Option<Interned<GenericArgs>>,\n     /// The type bound to this associated type (in `Item = T`, this would be the\n     /// `T`). This can be `None` if there are bounds instead.\n     pub type_ref: Option<TypeRef>,"}, {"sha": "cfa3a6baaf8b4aae5cfc8dcdda63202036fd9c6a", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -163,6 +163,10 @@ pub(super) fn lower_generic_args(\n             ast::GenericArg::AssocTypeArg(assoc_type_arg) => {\n                 if let Some(name_ref) = assoc_type_arg.name_ref() {\n                     let name = name_ref.as_name();\n+                    let args = assoc_type_arg\n+                        .generic_arg_list()\n+                        .and_then(|args| lower_generic_args(lower_ctx, args))\n+                        .map(Interned::new);\n                     let type_ref = assoc_type_arg.ty().map(|it| TypeRef::from_ast(lower_ctx, it));\n                     let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n                         l.bounds()\n@@ -171,7 +175,7 @@ pub(super) fn lower_generic_args(\n                     } else {\n                         Vec::new()\n                     };\n-                    bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n+                    bindings.push(AssociatedTypeBinding { name, args, type_ref, bounds });\n                 }\n             }\n             ast::GenericArg::LifetimeArg(lifetime_arg) => {\n@@ -214,6 +218,7 @@ fn lower_generic_args_from_fn_path(\n         let type_ref = TypeRef::from_ast_opt(ctx, ret_type.ty());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n+            args: None,\n             type_ref: Some(type_ref),\n             bounds: Vec::new(),\n         });\n@@ -222,6 +227,7 @@ fn lower_generic_args_from_fn_path(\n         let type_ref = TypeRef::Tuple(Vec::new());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n+            args: None,\n             type_ref: Some(type_ref),\n             bounds: Vec::new(),\n         });"}, {"sha": "996b42f5bd83c03bb906bddf466d5eaa2c863973", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -11,9 +11,9 @@ use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n-    from_placeholder_idx, to_chalk_trait_id, AdtId, AliasEq, AliasTy, Binders, CallableDefId,\n-    CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy, QuantifiedWhereClause,\n-    Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n+    from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n+    CallableDefId, CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n+    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n pub trait TyExt {\n@@ -338,10 +338,13 @@ pub trait ProjectionTyExt {\n \n impl ProjectionTyExt for ProjectionTy {\n     fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef {\n-        TraitRef {\n-            trait_id: to_chalk_trait_id(self.trait_(db)),\n-            substitution: self.substitution.clone(),\n-        }\n+        // FIXME: something like `Split` trait from chalk-solve might be nice.\n+        let generics = generics(db.upcast(), from_assoc_type_id(self.associated_ty_id).into());\n+        let substitution = Substitution::from_iter(\n+            Interner,\n+            self.substitution.iter(Interner).skip(generics.len_self()),\n+        );\n+        TraitRef { trait_id: to_chalk_trait_id(self.trait_(db)), substitution }\n     }\n \n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId {"}, {"sha": "5ad66132635340c410488f425529be1d4397720f", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -289,16 +289,18 @@ impl HirDisplay for ProjectionTy {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        let trait_ = f.db.trait_data(self.trait_(f.db));\n+        let trait_ref = self.trait_ref(f.db);\n         write!(f, \"<\")?;\n-        self.self_type_parameter(f.db).hir_fmt(f)?;\n-        write!(f, \" as {}\", trait_.name)?;\n-        if self.substitution.len(Interner) > 1 {\n+        fmt_trait_ref(&trait_ref, f, true)?;\n+        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n+        let proj_params_count =\n+            self.substitution.len(Interner) - trait_ref.substitution.len(Interner);\n+        let proj_params = &self.substitution.as_slice(Interner)[..proj_params_count];\n+        if !proj_params.is_empty() {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.substitution.as_slice(Interner)[1..], \", \")?;\n+            f.write_joined(proj_params, \", \")?;\n             write!(f, \">\")?;\n         }\n-        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n         Ok(())\n     }\n }\n@@ -641,9 +643,12 @@ impl HirDisplay for Ty {\n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n                     write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n+                    // Note that the generic args for the associated type come before those for the\n+                    // trait (including the self type).\n+                    // FIXME: reconsider the generic args order upon formatting?\n                     if parameters.len(Interner) > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&*parameters.as_slice(Interner), \", \")?;\n+                        f.write_joined(parameters.as_slice(Interner), \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 } else {\n@@ -972,9 +977,20 @@ fn write_bounds_like_dyn_trait(\n                     angle_open = true;\n                 }\n                 if let AliasTy::Projection(proj) = alias {\n-                    let type_alias =\n-                        f.db.type_alias_data(from_assoc_type_id(proj.associated_ty_id));\n-                    write!(f, \"{} = \", type_alias.name)?;\n+                    let assoc_ty_id = from_assoc_type_id(proj.associated_ty_id);\n+                    let type_alias = f.db.type_alias_data(assoc_ty_id);\n+                    write!(f, \"{}\", type_alias.name)?;\n+\n+                    let proj_arg_count = generics(f.db.upcast(), assoc_ty_id.into()).len_self();\n+                    if proj_arg_count > 0 {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(\n+                            &proj.substitution.as_slice(Interner)[..proj_arg_count],\n+                            \", \",\n+                        )?;\n+                        write!(f, \">\")?;\n+                    }\n+                    write!(f, \" = \")?;\n                 }\n                 ty.hir_fmt(f)?;\n             }"}, {"sha": "ebe9d6fb5e0146d6c687f17a925c1c1e74a88a2e", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -157,7 +157,7 @@ impl<'a> InferenceContext<'a> {\n                     remaining_segments_for_ty,\n                     true,\n                 );\n-                if let TyKind::Error = ty.kind(Interner) {\n+                if ty.is_unknown() {\n                     return None;\n                 }\n "}, {"sha": "8458a4fe1cd15509793e1303cedc98dc2c5ae4b7", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -124,14 +124,6 @@ pub type ConstrainedSubst = chalk_ir::ConstrainedSubst<Interner>;\n pub type Guidance = chalk_solve::Guidance<Interner>;\n pub type WhereClause = chalk_ir::WhereClause<Interner>;\n \n-// FIXME: get rid of this\n-pub fn subst_prefix(s: &Substitution, n: usize) -> Substitution {\n-    Substitution::from_iter(\n-        Interner,\n-        s.as_slice(Interner)[..std::cmp::min(s.len(Interner), n)].iter().cloned(),\n-    )\n-}\n-\n /// Return an index of a parameter in the generic type parameter list by it's id.\n pub fn param_idx(db: &dyn HirDatabase, id: TypeOrConstParamId) -> Option<usize> {\n     generics(db.upcast(), id.parent).param_idx(id)\n@@ -382,7 +374,6 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n pub fn replace_errors_with_variables<T>(t: &T) -> Canonical<T>\n where\n     T: HasInterner<Interner = Interner> + TypeFoldable<Interner> + Clone,\n-    T: HasInterner<Interner = Interner>,\n {\n     use chalk_ir::{\n         fold::{FallibleTypeFolder, TypeSuperFoldable},"}, {"sha": "22a85cf154587fa79e05807f3196391255b6513e", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -447,12 +447,31 @@ impl<'a> TyLoweringContext<'a> {\n                             .db\n                             .trait_data(trait_ref.hir_trait_id())\n                             .associated_type_by_name(segment.name);\n+\n                         match found {\n                             Some(associated_ty) => {\n-                                // FIXME handle type parameters on the segment\n+                                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                                // that method to optionally take parent `Substitution` as we already know them at\n+                                // this point (`trait_ref.substitution`).\n+                                let substitution = self.substs_from_path_segment(\n+                                    segment,\n+                                    Some(associated_ty.into()),\n+                                    false,\n+                                    None,\n+                                );\n+                                let len_self =\n+                                    generics(self.db.upcast(), associated_ty.into()).len_self();\n+                                let substitution = Substitution::from_iter(\n+                                    Interner,\n+                                    substitution\n+                                        .iter(Interner)\n+                                        .take(len_self)\n+                                        .chain(trait_ref.substitution.iter(Interner)),\n+                                );\n                                 TyKind::Alias(AliasTy::Projection(ProjectionTy {\n                                     associated_ty_id: to_assoc_type_id(associated_ty),\n-                                    substitution: trait_ref.substitution,\n+                                    substitution,\n                                 }))\n                                 .intern(Interner)\n                             }\n@@ -590,36 +609,48 @@ impl<'a> TyLoweringContext<'a> {\n             res,\n             Some(segment.name.clone()),\n             move |name, t, associated_ty| {\n-                if name == segment.name {\n-                    let substs = match self.type_param_mode {\n-                        ParamLoweringMode::Placeholder => {\n-                            // if we're lowering to placeholders, we have to put\n-                            // them in now\n-                            let generics = generics(\n-                                self.db.upcast(),\n-                                self.resolver\n-                                    .generic_def()\n-                                    .expect(\"there should be generics if there's a generic param\"),\n-                            );\n-                            let s = generics.placeholder_subst(self.db);\n-                            s.apply(t.substitution.clone(), Interner)\n-                        }\n-                        ParamLoweringMode::Variable => t.substitution.clone(),\n-                    };\n-                    // We need to shift in the bound vars, since\n-                    // associated_type_shorthand_candidates does not do that\n-                    let substs = substs.shifted_in_from(Interner, self.in_binders);\n-                    // FIXME handle type parameters on the segment\n-                    Some(\n-                        TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                            associated_ty_id: to_assoc_type_id(associated_ty),\n-                            substitution: substs,\n-                        }))\n-                        .intern(Interner),\n-                    )\n-                } else {\n-                    None\n+                if name != segment.name {\n+                    return None;\n                 }\n+\n+                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                // that method to optionally take parent `Substitution` as we already know them at\n+                // this point (`t.substitution`).\n+                let substs = self.substs_from_path_segment(\n+                    segment.clone(),\n+                    Some(associated_ty.into()),\n+                    false,\n+                    None,\n+                );\n+\n+                let len_self = generics(self.db.upcast(), associated_ty.into()).len_self();\n+\n+                let substs = Substitution::from_iter(\n+                    Interner,\n+                    substs.iter(Interner).take(len_self).chain(t.substitution.iter(Interner)),\n+                );\n+\n+                let substs = match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // if we're lowering to placeholders, we have to put\n+                        // them in now\n+                        let generics = generics(self.db.upcast(), def);\n+                        let s = generics.placeholder_subst(self.db);\n+                        s.apply(substs, Interner)\n+                    }\n+                    ParamLoweringMode::Variable => substs,\n+                };\n+                // We need to shift in the bound vars, since\n+                // associated_type_shorthand_candidates does not do that\n+                let substs = substs.shifted_in_from(Interner, self.in_binders);\n+                Some(\n+                    TyKind::Alias(AliasTy::Projection(ProjectionTy {\n+                        associated_ty_id: to_assoc_type_id(associated_ty),\n+                        substitution: substs,\n+                    }))\n+                    .intern(Interner),\n+                )\n             },\n         );\n \n@@ -777,7 +808,15 @@ impl<'a> TyLoweringContext<'a> {\n         // handle defaults. In expression or pattern path segments without\n         // explicitly specified type arguments, missing type arguments are inferred\n         // (i.e. defaults aren't used).\n-        if !infer_args || had_explicit_args {\n+        // Generic parameters for associated types are not supposed to have defaults, so we just\n+        // ignore them.\n+        let is_assoc_ty = if let GenericDefId::TypeAliasId(id) = def {\n+            let container = id.lookup(self.db.upcast()).container;\n+            matches!(container, ItemContainerId::TraitId(_))\n+        } else {\n+            false\n+        };\n+        if !is_assoc_ty && (!infer_args || had_explicit_args) {\n             let defaults = self.db.generic_defaults(def);\n             assert_eq!(total_len, defaults.len());\n             let parent_from = item_len - substs.len();\n@@ -966,9 +1005,28 @@ impl<'a> TyLoweringContext<'a> {\n                     None => return SmallVec::new(),\n                     Some(t) => t,\n                 };\n+                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                // that method to optionally take parent `Substitution` as we already know them at\n+                // this point (`super_trait_ref.substitution`).\n+                let substitution = self.substs_from_path_segment(\n+                    // FIXME: This is hack. We shouldn't really build `PathSegment` directly.\n+                    PathSegment { name: &binding.name, args_and_bindings: binding.args.as_deref() },\n+                    Some(associated_ty.into()),\n+                    false, // this is not relevant\n+                    Some(super_trait_ref.self_type_parameter(Interner)),\n+                );\n+                let self_params = generics(self.db.upcast(), associated_ty.into()).len_self();\n+                let substitution = Substitution::from_iter(\n+                    Interner,\n+                    substitution\n+                        .iter(Interner)\n+                        .take(self_params)\n+                        .chain(super_trait_ref.substitution.iter(Interner)),\n+                );\n                 let projection_ty = ProjectionTy {\n                     associated_ty_id: to_assoc_type_id(associated_ty),\n-                    substitution: super_trait_ref.substitution,\n+                    substitution,\n                 };\n                 let mut preds: SmallVec<[_; 1]> = SmallVec::with_capacity(\n                     binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),"}, {"sha": "425432479e8159a822c907ce1b7ddd245530fbe1", "filename": "crates/hir-ty/src/tests/display_source_code.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -196,3 +196,34 @@ fn test(\n \"#,\n     );\n }\n+\n+#[test]\n+fn projection_type_correct_arguments_order() {\n+    check_types_source_code(\n+        r#\"\n+trait Foo<T> {\n+    type Assoc<U>;\n+}\n+fn f<T: Foo<i32>>(a: T::Assoc<usize>) {\n+    a;\n+  //^ <T as Foo<i32>>::Assoc<usize>\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn generic_associated_type_binding_in_impl_trait() {\n+    check_types_source_code(\n+        r#\"\n+//- minicore: sized\n+trait Foo<T> {\n+    type Assoc<U>;\n+}\n+fn f(a: impl Foo<i8, Assoc<i16> = i32>) {\n+    a;\n+  //^ impl Foo<i8, Assoc<i16> = i32>\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "7995f6446d07b5f56ab68dd5b2d2286a30009dd7", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -3963,3 +3963,160 @@ fn g(t: &(dyn T + Send)) {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn gats_in_path() {\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+trait PointerFamily {\n+    type Pointer<T>: Deref<Target = T>;\n+}\n+\n+fn f<P: PointerFamily>(p: P::Pointer<i32>) {\n+    let a = *p;\n+}\n+fn g<P: PointerFamily>(p: <P as PointerFamily>::Pointer<i32>) {\n+    let a = *p;\n+}\n+        \"#,\n+        expect![[r#\"\n+            110..111 'p': PointerFamily::Pointer<i32, P>\n+            130..149 '{     ... *p; }': ()\n+            140..141 'a': i32\n+            144..146 '*p': i32\n+            145..146 'p': PointerFamily::Pointer<i32, P>\n+            173..174 'p': PointerFamily::Pointer<i32, P>\n+            212..231 '{     ... *p; }': ()\n+            222..223 'a': i32\n+            226..228 '*p': i32\n+            227..228 'p': PointerFamily::Pointer<i32, P>\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn gats_with_impl_trait() {\n+    // FIXME: the last function (`fn h()`) is not valid Rust as of this writing because you cannot\n+    // specify the same associated type multiple times even if their arguments are different.\n+    // Reconsider how to treat these invalid types.\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+\n+trait Trait {\n+    type Assoc<T>: Deref<Target = T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<T>(v: impl Trait) {\n+    v.get::<i32>().deref();\n+    v.get::<T>().deref();\n+}\n+fn g<T>(v: impl Trait<Assoc<T> = &'a T>) {\n+    let a = v.get::<T>();\n+    let a = v.get::<()>();\n+}\n+fn h(v: impl Trait<Assoc<i32> = &'a i32, Assoc<i64> = &'a i64> {\n+    let a = v.get::<i32>();\n+    let a = v.get::<i64>();\n+}\n+    \"#,\n+        expect![[r#\"\n+            90..94 'self': &Self\n+            126..127 'v': impl Trait\n+            141..198 '{     ...f(); }': ()\n+            147..148 'v': impl Trait\n+            147..161 'v.get::<i32>()': Trait::Assoc<i32, impl Trait>\n+            147..169 'v.get:...eref()': &i32\n+            175..176 'v': impl Trait\n+            175..187 'v.get::<T>()': Trait::Assoc<T, impl Trait>\n+            175..195 'v.get:...eref()': &T\n+            207..208 'v': impl Trait<Assoc<T> = &T>\n+            240..296 '{     ...>(); }': ()\n+            250..251 'a': &T\n+            254..255 'v': impl Trait<Assoc<T> = &T>\n+            254..266 'v.get::<T>()': &T\n+            276..277 'a': Trait::Assoc<(), impl Trait<Assoc<T> = &T>>\n+            280..281 'v': impl Trait<Assoc<T> = &T>\n+            280..293 'v.get::<()>()': Trait::Assoc<(), impl Trait<Assoc<T> = &T>>\n+            302..303 'v': impl Trait<Assoc<i32> = &i32, Assoc<i64> = &i64>\n+            360..419 '{     ...>(); }': ()\n+            370..371 'a': &i32\n+            374..375 'v': impl Trait<Assoc<i32> = &i32, Assoc<i64> = &i64>\n+            374..388 'v.get::<i32>()': &i32\n+            398..399 'a': &i64\n+            402..403 'v': impl Trait<Assoc<i32> = &i32, Assoc<i64> = &i64>\n+            402..416 'v.get::<i64>()': &i64\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn gats_with_dyn() {\n+    // This test is here to keep track of how we infer things despite traits with GATs being not\n+    // object-safe currently.\n+    // FIXME: reconsider how to treat these invalid types.\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+\n+trait Trait {\n+    type Assoc<T>: Deref<Target = T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<'a>(v: &dyn Trait<Assoc<i32> = &'a i32>) {\n+    v.get::<i32>().deref();\n+}\n+    \"#,\n+        expect![[r#\"\n+            90..94 'self': &Self\n+            127..128 'v': &(dyn Trait<Assoc<i32> = &i32>)\n+            164..195 '{     ...f(); }': ()\n+            170..171 'v': &(dyn Trait<Assoc<i32> = &i32>)\n+            170..184 'v.get::<i32>()': &i32\n+            170..192 'v.get:...eref()': &i32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn gats_in_associated_type_binding() {\n+    check_infer_with_mismatches(\n+        r#\"\n+trait Trait {\n+    type Assoc<T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<T>(t: T)\n+where\n+    T: Trait<Assoc<i32> = u32>,\n+    T: Trait<Assoc<isize> = usize>,\n+{\n+    let a = t.get::<i32>();\n+    let a = t.get::<isize>();\n+    let a = t.get::<()>();\n+}\n+\n+    \"#,\n+        expect![[r#\"\n+            48..52 'self': &Self\n+            84..85 't': T\n+            164..252 '{     ...>(); }': ()\n+            174..175 'a': u32\n+            178..179 't': T\n+            178..192 't.get::<i32>()': u32\n+            202..203 'a': usize\n+            206..207 't': T\n+            206..222 't.get:...ize>()': usize\n+            232..233 'a': Trait::Assoc<(), T>\n+            236..237 't': T\n+            236..249 't.get::<()>()': Trait::Assoc<(), T>\n+        \"#]],\n+    )\n+}"}, {"sha": "92711a24fe39fdc317328f7c76894c859ef76e64", "filename": "crates/hir-ty/src/tls.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fhir-ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftls.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -5,7 +5,7 @@ use itertools::Itertools;\n \n use crate::{\n     chalk_db, db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, mapping::from_chalk,\n-    CallableDefId, Interner,\n+    CallableDefId, Interner, ProjectionTyExt,\n };\n use hir_def::{AdtId, ItemContainerId, Lookup, TypeAliasId};\n \n@@ -63,17 +63,31 @@ impl DebugContext<'_> {\n             ItemContainerId::TraitId(t) => t,\n             _ => panic!(\"associated type not in trait\"),\n         };\n-        let trait_data = self.0.trait_data(trait_);\n-        let params = projection_ty.substitution.as_slice(Interner);\n-        write!(fmt, \"<{:?} as {}\", &params[0], trait_data.name,)?;\n-        if params.len() > 1 {\n+        let trait_name = &self.0.trait_data(trait_).name;\n+        let trait_ref = projection_ty.trait_ref(self.0);\n+        let trait_params = trait_ref.substitution.as_slice(Interner);\n+        let self_ty = trait_ref.self_type_parameter(Interner);\n+        write!(fmt, \"<{:?} as {}\", self_ty, trait_name)?;\n+        if trait_params.len() > 1 {\n+            write!(\n+                fmt,\n+                \"<{}>\",\n+                trait_params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+            )?;\n+        }\n+        write!(fmt, \">::{}\", type_alias_data.name)?;\n+\n+        let proj_params_count = projection_ty.substitution.len(Interner) - trait_params.len();\n+        let proj_params = &projection_ty.substitution.as_slice(Interner)[..proj_params_count];\n+        if !proj_params.is_empty() {\n             write!(\n                 fmt,\n                 \"<{}>\",\n-                &params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+                proj_params.iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n             )?;\n         }\n-        write!(fmt, \">::{}\", type_alias_data.name)\n+\n+        Ok(())\n     }\n \n     pub(crate) fn debug_fn_def_id("}, {"sha": "5379732ac6c377d3e5fbf23d5c801afd2dd4c960", "filename": "crates/syntax/rust.ungram", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Frust.ungram?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -51,7 +51,7 @@ TypeArg =\n   Type\n \n AssocTypeArg =\n-  NameRef GenericParamList? (':' TypeBoundList | ('=' Type | ConstArg))\n+  NameRef GenericArgList? (':' TypeBoundList | ('=' Type | ConstArg))\n \n LifetimeArg =\n   Lifetime"}, {"sha": "6cfb98d92fcf289c5a69c4504e69f10e6d31202d", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e1e17a10f9a0c55dad34419403d1327680f240/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=c6e1e17a10f9a0c55dad34419403d1327680f240", "patch": "@@ -120,7 +120,7 @@ pub struct AssocTypeArg {\n impl ast::HasTypeBounds for AssocTypeArg {}\n impl AssocTypeArg {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n+    pub fn generic_arg_list(&self) -> Option<GenericArgList> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn const_arg(&self) -> Option<ConstArg> { support::child(&self.syntax) }\n@@ -142,16 +142,6 @@ impl ConstArg {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct GenericParamList {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl GenericParamList {\n-    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n-    pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n     pub(crate) syntax: SyntaxNode,\n@@ -527,6 +517,16 @@ impl Abi {\n     pub fn extern_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![extern]) }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct GenericParamList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl GenericParamList {\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n+    pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n     pub(crate) syntax: SyntaxNode,\n@@ -1834,17 +1834,6 @@ impl AstNode for ConstArg {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for GenericParamList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for TypeBoundList {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2153,6 +2142,17 @@ impl AstNode for Abi {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl AstNode for GenericParamList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl AstNode for WhereClause {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_CLAUSE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -4263,11 +4263,6 @@ impl std::fmt::Display for ConstArg {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for GenericParamList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for TypeBoundList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -4408,6 +4403,11 @@ impl std::fmt::Display for Abi {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for GenericParamList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for WhereClause {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}]}