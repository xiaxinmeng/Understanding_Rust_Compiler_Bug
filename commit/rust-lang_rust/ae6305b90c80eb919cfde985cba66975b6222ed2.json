{"sha": "ae6305b90c80eb919cfde985cba66975b6222ed2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNjMwNWI5MGM4MGViOTE5Y2ZkZTk4NWNiYTY2OTc1YjYyMjJlZDI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-05T14:25:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-05T14:25:59Z"}, "message": "Merge #1928\n\n1928: Support `#[cfg(..)]` r=matklad a=oxalica\n\nThis PR implement `#[cfg(..)]` conditional compilation. It read default cfg options from `rustc --print cfg` with also hard-coded `test` and `debug_assertion` enabled.\r\nFront-end settings are **not** included in this PR.\r\n\r\nThere is also a known issue that inner control attributes are totally ignored. I think it is **not** a part of `cfg` and create a separated issue for it. #1949\r\n\r\nFixes #1920 \r\n\r\nRelated: #1073 \r\n\n\nCo-authored-by: uHOOCCOOHu <hooccooh1896@gmail.com>\nCo-authored-by: oxalica <oxalicc@pm.me>", "tree": {"sha": "de601daf3714c4bda937e7cad05d048b69d16e71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de601daf3714c4bda937e7cad05d048b69d16e71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae6305b90c80eb919cfde985cba66975b6222ed2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdmKf3CRBK7hj4Ov3rIwAAdHIIAJmWmeZH5kgdCdKIB2b/J0Gt\ne9F30oQONcv9MkvMYfysIt4EJEQ2P6yNOZaVA4BXEWn/f8Y/jcPomMyKCud2gVPc\nBSbdQrGmgW3y8wwPWwGiKXgvTkmOXilHFXPFL+EegmvHyDBDMrF/+BHddkvpYBl2\nKH7B59b0NXg18wdiK16mRdiiqiLQZUWBDSZmCgDlT4joxybRBHnovg7SzDrFGTD/\nZCA5njuFRjjgcERgT2+yfo1WarVgDGGl/E/JnWVjV+V0m6o91vpaFJhyPpDkG6MD\ntojMtakQC1V44grrq/SK1L0Xy3RXmtbT6X8/Tuq/wx4cDNeJiub38SegxEsIJmU=\n=1Afe\n-----END PGP SIGNATURE-----\n", "payload": "tree de601daf3714c4bda937e7cad05d048b69d16e71\nparent dbf869b4d2dac09df17609edf6e67c1611b71dc5\nparent c6303d9fee98232ac83a77f943c39d65c9c6b6db\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1570285559 +0000\ncommitter GitHub <noreply@github.com> 1570285559 +0000\n\nMerge #1928\n\n1928: Support `#[cfg(..)]` r=matklad a=oxalica\n\nThis PR implement `#[cfg(..)]` conditional compilation. It read default cfg options from `rustc --print cfg` with also hard-coded `test` and `debug_assertion` enabled.\r\nFront-end settings are **not** included in this PR.\r\n\r\nThere is also a known issue that inner control attributes are totally ignored. I think it is **not** a part of `cfg` and create a separated issue for it. #1949\r\n\r\nFixes #1920 \r\n\r\nRelated: #1073 \r\n\n\nCo-authored-by: uHOOCCOOHu <hooccooh1896@gmail.com>\nCo-authored-by: oxalica <oxalicc@pm.me>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae6305b90c80eb919cfde985cba66975b6222ed2", "html_url": "https://github.com/rust-lang/rust/commit/ae6305b90c80eb919cfde985cba66975b6222ed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae6305b90c80eb919cfde985cba66975b6222ed2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbf869b4d2dac09df17609edf6e67c1611b71dc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf869b4d2dac09df17609edf6e67c1611b71dc5", "html_url": "https://github.com/rust-lang/rust/commit/dbf869b4d2dac09df17609edf6e67c1611b71dc5"}, {"sha": "c6303d9fee98232ac83a77f943c39d65c9c6b6db", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6303d9fee98232ac83a77f943c39d65c9c6b6db", "html_url": "https://github.com/rust-lang/rust/commit/c6303d9fee98232ac83a77f943c39d65c9c6b6db"}], "stats": {"total": 737, "additions": 671, "deletions": 66}, "files": [{"sha": "736f1994edfba0ad31dcd036107de289399bab7d", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -922,6 +922,16 @@ dependencies = [\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ra_cfg\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ra_mbe 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"ra_tt 0.1.0\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ra_cli\"\n version = \"0.1.0\"\n@@ -941,6 +951,7 @@ dependencies = [\n name = \"ra_db\"\n version = \"0.1.0\"\n dependencies = [\n+ \"ra_cfg 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -971,6 +982,7 @@ dependencies = [\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n+ \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_mbe 0.1.0\",\n  \"ra_prof 0.1.0\",\n@@ -993,6 +1005,7 @@ dependencies = [\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proptest 0.9.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_assists 0.1.0\",\n+ \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\",\n  \"ra_hir 0.1.0\",\n@@ -1019,6 +1032,7 @@ dependencies = [\n  \"lsp-server 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-types 0.61.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_ide_api 0.1.0\",\n  \"ra_prof 0.1.0\",\n@@ -1075,6 +1089,7 @@ dependencies = [\n  \"cargo_metadata 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n+ \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "a5fc2a23e16f0b7d3830168d2477e7b348e0e19a", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -7,7 +7,7 @@ use rustc_hash::FxHashMap;\n use crossbeam_channel::{unbounded, Receiver};\n use ra_db::{CrateGraph, FileId, SourceRootId};\n use ra_ide_api::{AnalysisChange, AnalysisHost, FeatureFlags};\n-use ra_project_model::{PackageRoot, ProjectWorkspace};\n+use ra_project_model::{get_rustc_cfg_options, PackageRoot, ProjectWorkspace};\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use ra_vfs_glob::RustPackageFilterBuilder;\n \n@@ -41,11 +41,17 @@ pub fn load_cargo(root: &Path) -> Result<(AnalysisHost, FxHashMap<SourceRootId,\n         sender,\n         Watch(false),\n     );\n-    let (crate_graph, _crate_names) = ws.to_crate_graph(&mut |path: &Path| {\n-        let vfs_file = vfs.load(path);\n-        log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n-        vfs_file.map(vfs_file_to_id)\n-    });\n+\n+    // FIXME: cfg options?\n+    let default_cfg_options =\n+        get_rustc_cfg_options().atom(\"test\".into()).atom(\"debug_assertion\".into());\n+\n+    let (crate_graph, _crate_names) =\n+        ws.to_crate_graph(&default_cfg_options, &mut |path: &Path| {\n+            let vfs_file = vfs.load(path);\n+            log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n+            vfs_file.map(vfs_file_to_id)\n+        });\n     log::debug!(\"crate graph: {:?}\", crate_graph);\n \n     let source_roots = roots"}, {"sha": "b28affc3a3d8ae4f10da6fbaf9bc73f025433fda", "filename": "crates/ra_cfg/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_cfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_cfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2FCargo.toml?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_cfg\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+rustc-hash = \"1.0.1\"\n+\n+ra_syntax = { path = \"../ra_syntax\" }\n+tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+\n+[dev-dependencies]\n+mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }"}, {"sha": "39d71851ca74c3f0faa4be537eddb7a3ee8f9ba1", "filename": "crates/ra_cfg/src/cfg_expr.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -0,0 +1,132 @@\n+//! The condition expression used in `#[cfg(..)]` attributes.\n+//!\n+//! See: https://doc.rust-lang.org/reference/conditional-compilation.html#conditional-compilation\n+\n+use std::slice::Iter as SliceIter;\n+\n+use ra_syntax::SmolStr;\n+use tt::{Leaf, Subtree, TokenTree};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum CfgExpr {\n+    Invalid,\n+    Atom(SmolStr),\n+    KeyValue { key: SmolStr, value: SmolStr },\n+    All(Vec<CfgExpr>),\n+    Any(Vec<CfgExpr>),\n+    Not(Box<CfgExpr>),\n+}\n+\n+impl CfgExpr {\n+    /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n+    pub fn fold(&self, query: &dyn Fn(&SmolStr, Option<&SmolStr>) -> bool) -> Option<bool> {\n+        match self {\n+            CfgExpr::Invalid => None,\n+            CfgExpr::Atom(name) => Some(query(name, None)),\n+            CfgExpr::KeyValue { key, value } => Some(query(key, Some(value))),\n+            CfgExpr::All(preds) => {\n+                preds.iter().try_fold(true, |s, pred| Some(s && pred.fold(query)?))\n+            }\n+            CfgExpr::Any(preds) => {\n+                preds.iter().try_fold(false, |s, pred| Some(s || pred.fold(query)?))\n+            }\n+            CfgExpr::Not(pred) => pred.fold(query).map(|s| !s),\n+        }\n+    }\n+}\n+\n+pub fn parse_cfg(tt: &Subtree) -> CfgExpr {\n+    next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n+}\n+\n+fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n+    let name = match it.next() {\n+        None => return None,\n+        Some(TokenTree::Leaf(Leaf::Ident(ident))) => ident.text.clone(),\n+        Some(_) => return Some(CfgExpr::Invalid),\n+    };\n+\n+    // Peek\n+    let ret = match it.as_slice().first() {\n+        Some(TokenTree::Leaf(Leaf::Punct(punct))) if punct.char == '=' => {\n+            match it.as_slice().get(1) {\n+                Some(TokenTree::Leaf(Leaf::Literal(literal))) => {\n+                    it.next();\n+                    it.next();\n+                    // FIXME: escape? raw string?\n+                    let value =\n+                        SmolStr::new(literal.text.trim_start_matches('\"').trim_end_matches('\"'));\n+                    CfgExpr::KeyValue { key: name, value }\n+                }\n+                _ => return Some(CfgExpr::Invalid),\n+            }\n+        }\n+        Some(TokenTree::Subtree(subtree)) => {\n+            it.next();\n+            let mut sub_it = subtree.token_trees.iter();\n+            let mut subs = std::iter::from_fn(|| next_cfg_expr(&mut sub_it)).collect();\n+            match name.as_str() {\n+                \"all\" => CfgExpr::All(subs),\n+                \"any\" => CfgExpr::Any(subs),\n+                \"not\" => CfgExpr::Not(Box::new(subs.pop().unwrap_or(CfgExpr::Invalid))),\n+                _ => CfgExpr::Invalid,\n+            }\n+        }\n+        _ => CfgExpr::Atom(name),\n+    };\n+\n+    // Eat comma separator\n+    if let Some(TokenTree::Leaf(Leaf::Punct(punct))) = it.as_slice().first() {\n+        if punct.char == ',' {\n+            it.next();\n+        }\n+    }\n+    Some(ret)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use mbe::ast_to_token_tree;\n+    use ra_syntax::ast::{self, AstNode};\n+\n+    fn assert_parse_result(input: &str, expected: CfgExpr) {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        let (tt, _) = ast_to_token_tree(&tt).unwrap();\n+        assert_eq!(parse_cfg(&tt), expected);\n+    }\n+\n+    #[test]\n+    fn test_cfg_expr_parser() {\n+        assert_parse_result(\"#![cfg(foo)]\", CfgExpr::Atom(\"foo\".into()));\n+        assert_parse_result(\"#![cfg(foo,)]\", CfgExpr::Atom(\"foo\".into()));\n+        assert_parse_result(\n+            \"#![cfg(not(foo))]\",\n+            CfgExpr::Not(Box::new(CfgExpr::Atom(\"foo\".into()))),\n+        );\n+        assert_parse_result(\"#![cfg(foo(bar))]\", CfgExpr::Invalid);\n+\n+        // Only take the first\n+        assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgExpr::Atom(\"foo\".into()));\n+\n+        assert_parse_result(\n+            r#\"#![cfg(all(foo, bar = \"baz\"))]\"#,\n+            CfgExpr::All(vec![\n+                CfgExpr::Atom(\"foo\".into()),\n+                CfgExpr::KeyValue { key: \"bar\".into(), value: \"baz\".into() },\n+            ]),\n+        );\n+\n+        assert_parse_result(\n+            r#\"#![cfg(any(not(), all(), , bar = \"baz\",))]\"#,\n+            CfgExpr::Any(vec![\n+                CfgExpr::Not(Box::new(CfgExpr::Invalid)),\n+                CfgExpr::All(vec![]),\n+                CfgExpr::Invalid,\n+                CfgExpr::KeyValue { key: \"bar\".into(), value: \"baz\".into() },\n+            ]),\n+        );\n+    }\n+}"}, {"sha": "e1c92fbba302e9133ff3b353a65319dde78906eb", "filename": "crates/ra_cfg/src/lib.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -0,0 +1,61 @@\n+//! ra_cfg defines conditional compiling options, `cfg` attibute parser and evaluator\n+use std::iter::IntoIterator;\n+\n+use ra_syntax::SmolStr;\n+use rustc_hash::FxHashSet;\n+\n+mod cfg_expr;\n+\n+pub use cfg_expr::{parse_cfg, CfgExpr};\n+\n+/// Configuration options used for conditional compilition on items with `cfg` attributes.\n+/// We have two kind of options in different namespaces: atomic options like `unix`, and\n+/// key-value options like `target_arch=\"x86\"`.\n+///\n+/// Note that for key-value options, one key can have multiple values (but not none).\n+/// `feature` is an example. We have both `feature=\"foo\"` and `feature=\"bar\"` if features\n+/// `foo` and `bar` are both enabled. And here, we store key-value options as a set of tuple\n+/// of key and value in `key_values`.\n+///\n+/// See: https://doc.rust-lang.org/reference/conditional-compilation.html#set-configuration-options\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+pub struct CfgOptions {\n+    atoms: FxHashSet<SmolStr>,\n+    key_values: FxHashSet<(SmolStr, SmolStr)>,\n+}\n+\n+impl CfgOptions {\n+    pub fn check(&self, cfg: &CfgExpr) -> Option<bool> {\n+        cfg.fold(&|key, value| match value {\n+            None => self.atoms.contains(key),\n+            Some(value) => self.key_values.contains(&(key.clone(), value.clone())),\n+        })\n+    }\n+\n+    pub fn is_cfg_enabled(&self, attr: &tt::Subtree) -> Option<bool> {\n+        self.check(&parse_cfg(attr))\n+    }\n+\n+    pub fn atom(mut self, name: SmolStr) -> CfgOptions {\n+        self.atoms.insert(name);\n+        self\n+    }\n+\n+    pub fn key_value(mut self, key: SmolStr, value: SmolStr) -> CfgOptions {\n+        self.key_values.insert((key, value));\n+        self\n+    }\n+\n+    /// Shortcut to set features\n+    pub fn features(mut self, iter: impl IntoIterator<Item = SmolStr>) -> CfgOptions {\n+        for feat in iter {\n+            self = self.key_value(\"feature\".into(), feat);\n+        }\n+        self\n+    }\n+\n+    pub fn remove_atom(mut self, name: &SmolStr) -> CfgOptions {\n+        self.atoms.remove(name);\n+        self\n+    }\n+}"}, {"sha": "c141f1a88dc9067773c6c8cbd4efcbf710d9c057", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -10,4 +10,5 @@ relative-path = \"0.4.0\"\n rustc-hash = \"1.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n ra_prof = { path = \"../ra_prof\" }"}, {"sha": "23148096cb1ccb3b99e6681a7e371bcdd57528f5", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -9,6 +9,7 @@\n use relative_path::{RelativePath, RelativePathBuf};\n use rustc_hash::FxHashMap;\n \n+use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n@@ -109,11 +110,12 @@ struct CrateData {\n     file_id: FileId,\n     edition: Edition,\n     dependencies: Vec<Dependency>,\n+    cfg_options: CfgOptions,\n }\n \n impl CrateData {\n-    fn new(file_id: FileId, edition: Edition) -> CrateData {\n-        CrateData { file_id, edition, dependencies: Vec::new() }\n+    fn new(file_id: FileId, edition: Edition, cfg_options: CfgOptions) -> CrateData {\n+        CrateData { file_id, edition, dependencies: Vec::new(), cfg_options }\n     }\n \n     fn add_dep(&mut self, name: SmolStr, crate_id: CrateId) {\n@@ -134,13 +136,22 @@ impl Dependency {\n }\n \n impl CrateGraph {\n-    pub fn add_crate_root(&mut self, file_id: FileId, edition: Edition) -> CrateId {\n+    pub fn add_crate_root(\n+        &mut self,\n+        file_id: FileId,\n+        edition: Edition,\n+        cfg_options: CfgOptions,\n+    ) -> CrateId {\n         let crate_id = CrateId(self.arena.len() as u32);\n-        let prev = self.arena.insert(crate_id, CrateData::new(file_id, edition));\n+        let prev = self.arena.insert(crate_id, CrateData::new(file_id, edition, cfg_options));\n         assert!(prev.is_none());\n         crate_id\n     }\n \n+    pub fn cfg_options(&self, crate_id: CrateId) -> &CfgOptions {\n+        &self.arena[&crate_id].cfg_options\n+    }\n+\n     pub fn add_dep(\n         &mut self,\n         from: CrateId,\n@@ -221,14 +232,14 @@ impl CrateGraph {\n \n #[cfg(test)]\n mod tests {\n-    use super::{CrateGraph, Edition::Edition2018, FileId, SmolStr};\n+    use super::{CfgOptions, CrateGraph, Edition::Edition2018, FileId, SmolStr};\n \n     #[test]\n     fn it_should_panic_because_of_cycle_dependencies() {\n         let mut graph = CrateGraph::default();\n-        let crate1 = graph.add_crate_root(FileId(1u32), Edition2018);\n-        let crate2 = graph.add_crate_root(FileId(2u32), Edition2018);\n-        let crate3 = graph.add_crate_root(FileId(3u32), Edition2018);\n+        let crate1 = graph.add_crate_root(FileId(1u32), Edition2018, CfgOptions::default());\n+        let crate2 = graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default());\n+        let crate3 = graph.add_crate_root(FileId(3u32), Edition2018, CfgOptions::default());\n         assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n         assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n         assert!(graph.add_dep(crate3, SmolStr::new(\"crate1\"), crate1).is_err());\n@@ -237,9 +248,9 @@ mod tests {\n     #[test]\n     fn it_works() {\n         let mut graph = CrateGraph::default();\n-        let crate1 = graph.add_crate_root(FileId(1u32), Edition2018);\n-        let crate2 = graph.add_crate_root(FileId(2u32), Edition2018);\n-        let crate3 = graph.add_crate_root(FileId(3u32), Edition2018);\n+        let crate1 = graph.add_crate_root(FileId(1u32), Edition2018, CfgOptions::default());\n+        let crate2 = graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default());\n+        let crate3 = graph.add_crate_root(FileId(3u32), Edition2018, CfgOptions::default());\n         assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n         assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n     }"}, {"sha": "cc117f84d17c2ad7fbaddfa49072757d28eb4cb2", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -15,6 +15,7 @@ once_cell = \"1.0.1\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_arena = { path = \"../ra_arena\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n ra_db = { path = \"../ra_db\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }"}, {"sha": "f67e80bfd153d4da7ebdf856ec723b001692ec0f", "filename": "crates/ra_hir/src/attr.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fattr.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -0,0 +1,80 @@\n+//! A higher level attributes based on TokenTree, with also some shortcuts.\n+\n+use std::sync::Arc;\n+\n+use mbe::ast_to_token_tree;\n+use ra_cfg::CfgOptions;\n+use ra_syntax::{\n+    ast::{self, AstNode, AttrsOwner},\n+    SmolStr,\n+};\n+use tt::Subtree;\n+\n+use crate::{db::AstDatabase, path::Path, HirFileId, Source};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct Attr {\n+    pub(crate) path: Path,\n+    pub(crate) input: Option<AttrInput>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum AttrInput {\n+    Literal(SmolStr),\n+    TokenTree(Subtree),\n+}\n+\n+impl Attr {\n+    pub(crate) fn from_src(\n+        Source { file_id, ast }: Source<ast::Attr>,\n+        db: &impl AstDatabase,\n+    ) -> Option<Attr> {\n+        let path = Path::from_src(Source { file_id, ast: ast.path()? }, db)?;\n+        let input = match ast.input() {\n+            None => None,\n+            Some(ast::AttrInput::Literal(lit)) => {\n+                // FIXME: escape? raw string?\n+                let value = lit.syntax().first_token()?.text().trim_matches('\"').into();\n+                Some(AttrInput::Literal(value))\n+            }\n+            Some(ast::AttrInput::TokenTree(tt)) => {\n+                Some(AttrInput::TokenTree(ast_to_token_tree(&tt)?.0))\n+            }\n+        };\n+\n+        Some(Attr { path, input })\n+    }\n+\n+    pub(crate) fn from_attrs_owner(\n+        file_id: HirFileId,\n+        owner: &dyn AttrsOwner,\n+        db: &impl AstDatabase,\n+    ) -> Option<Arc<[Attr]>> {\n+        let mut attrs = owner.attrs().peekable();\n+        if attrs.peek().is_none() {\n+            // Avoid heap allocation\n+            return None;\n+        }\n+        Some(attrs.flat_map(|ast| Attr::from_src(Source { file_id, ast }, db)).collect())\n+    }\n+\n+    pub(crate) fn is_simple_atom(&self, name: &str) -> bool {\n+        // FIXME: Avoid cloning\n+        self.path.as_ident().map_or(false, |s| s.to_string() == name)\n+    }\n+\n+    pub(crate) fn as_cfg(&self) -> Option<&Subtree> {\n+        if self.is_simple_atom(\"cfg\") {\n+            match &self.input {\n+                Some(AttrInput::TokenTree(subtree)) => Some(subtree),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Option<bool> {\n+        cfg_options.is_cfg_enabled(self.as_cfg()?)\n+    }\n+}"}, {"sha": "55dfc393b40d173ee322b8ff682e6b5a5dc87068", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -4,12 +4,14 @@ use rustc_hash::FxHashMap;\n use std::sync::Arc;\n \n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n+use ra_cfg::CfgOptions;\n use ra_syntax::{\n     ast::{self, AstNode},\n     AstPtr,\n };\n \n use crate::{\n+    attr::Attr,\n     code_model::{Module, ModuleSource},\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     generics::HasGenericParams,\n@@ -176,6 +178,7 @@ pub struct ModuleImplBlocks {\n impl ModuleImplBlocks {\n     fn collect(\n         db: &(impl DefDatabase + AstDatabase),\n+        cfg_options: &CfgOptions,\n         module: Module,\n         source_map: &mut ImplSourceMap,\n     ) -> Self {\n@@ -188,11 +191,11 @@ impl ModuleImplBlocks {\n         let src = m.module.definition_source(db);\n         match &src.ast {\n             ModuleSource::SourceFile(node) => {\n-                m.collect_from_item_owner(db, source_map, node, src.file_id)\n+                m.collect_from_item_owner(db, cfg_options, source_map, node, src.file_id)\n             }\n             ModuleSource::Module(node) => {\n                 let item_list = node.item_list().expect(\"inline module should have item list\");\n-                m.collect_from_item_owner(db, source_map, &item_list, src.file_id)\n+                m.collect_from_item_owner(db, cfg_options, source_map, &item_list, src.file_id)\n             }\n         };\n         m\n@@ -201,13 +204,21 @@ impl ModuleImplBlocks {\n     fn collect_from_item_owner(\n         &mut self,\n         db: &(impl DefDatabase + AstDatabase),\n+        cfg_options: &CfgOptions,\n         source_map: &mut ImplSourceMap,\n         owner: &dyn ast::ModuleItemOwner,\n         file_id: HirFileId,\n     ) {\n         for item in owner.items_with_macros() {\n             match item {\n                 ast::ItemOrMacro::Item(ast::ModuleItem::ImplBlock(impl_block_ast)) => {\n+                    let attrs = Attr::from_attrs_owner(file_id, &impl_block_ast, db);\n+                    if attrs.map_or(false, |attrs| {\n+                        attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n+                    }) {\n+                        continue;\n+                    }\n+\n                     let impl_block = ImplData::from_ast(db, file_id, self.module, &impl_block_ast);\n                     let id = self.impls.alloc(impl_block);\n                     for &impl_item in &self.impls[id].items {\n@@ -218,6 +229,13 @@ impl ModuleImplBlocks {\n                 }\n                 ast::ItemOrMacro::Item(_) => (),\n                 ast::ItemOrMacro::Macro(macro_call) => {\n+                    let attrs = Attr::from_attrs_owner(file_id, &macro_call, db);\n+                    if attrs.map_or(false, |attrs| {\n+                        attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n+                    }) {\n+                        continue;\n+                    }\n+\n                     //FIXME: we should really cut down on the boilerplate required to process a macro\n                     let ast_id = db.ast_id_map(file_id).ast_id(&macro_call).with_file_id(file_id);\n                     if let Some(path) = macro_call\n@@ -231,7 +249,13 @@ impl ModuleImplBlocks {\n                             if let Some(item_list) =\n                                 db.parse_or_expand(file_id).and_then(ast::MacroItems::cast)\n                             {\n-                                self.collect_from_item_owner(db, source_map, &item_list, file_id)\n+                                self.collect_from_item_owner(\n+                                    db,\n+                                    cfg_options,\n+                                    source_map,\n+                                    &item_list,\n+                                    file_id,\n+                                )\n                             }\n                         }\n                     }\n@@ -246,8 +270,10 @@ pub(crate) fn impls_in_module_with_source_map_query(\n     module: Module,\n ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n     let mut source_map = ImplSourceMap::default();\n+    let crate_graph = db.crate_graph();\n+    let cfg_options = crate_graph.cfg_options(module.krate.crate_id());\n \n-    let result = ModuleImplBlocks::collect(db, module, &mut source_map);\n+    let result = ModuleImplBlocks::collect(db, cfg_options, module, &mut source_map);\n     (Arc::new(result), Arc::new(source_map))\n }\n "}, {"sha": "4340e9d3484a0e5e3e906e7013ad91bfc409a41f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -44,6 +44,7 @@ mod traits;\n mod type_alias;\n mod type_ref;\n mod ty;\n+mod attr;\n mod impl_block;\n mod expr;\n mod lang_item;"}, {"sha": "f750986b8b325af1c046c5ad74de9a98b8f99f68", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -3,6 +3,7 @@\n use std::{panic, sync::Arc};\n \n use parking_lot::Mutex;\n+use ra_cfg::CfgOptions;\n use ra_db::{\n     salsa, CrateGraph, CrateId, Edition, FileId, FilePosition, SourceDatabase, SourceRoot,\n     SourceRootId,\n@@ -74,13 +75,13 @@ impl MockDatabase {\n     pub fn set_crate_graph_from_fixture(&mut self, graph: CrateGraphFixture) {\n         let mut ids = FxHashMap::default();\n         let mut crate_graph = CrateGraph::default();\n-        for (crate_name, (crate_root, edition, _)) in graph.0.iter() {\n+        for (crate_name, (crate_root, edition, cfg_options, _)) in graph.0.iter() {\n             let crate_root = self.file_id_of(&crate_root);\n-            let crate_id = crate_graph.add_crate_root(crate_root, *edition);\n+            let crate_id = crate_graph.add_crate_root(crate_root, *edition, cfg_options.clone());\n             Arc::make_mut(&mut self.crate_names).insert(crate_id, crate_name.clone());\n             ids.insert(crate_name, crate_id);\n         }\n-        for (crate_name, (_, _, deps)) in graph.0.iter() {\n+        for (crate_name, (_, _, _, deps)) in graph.0.iter() {\n             let from = ids[crate_name];\n             for dep in deps {\n                 let to = ids[dep];\n@@ -184,7 +185,7 @@ impl MockDatabase {\n \n         if is_crate_root {\n             let mut crate_graph = CrateGraph::default();\n-            crate_graph.add_crate_root(file_id, Edition::Edition2018);\n+            crate_graph.add_crate_root(file_id, Edition::Edition2018, CfgOptions::default());\n             self.set_crate_graph(Arc::new(crate_graph));\n         }\n         file_id\n@@ -268,19 +269,27 @@ impl MockDatabase {\n }\n \n #[derive(Default)]\n-pub struct CrateGraphFixture(pub Vec<(String, (String, Edition, Vec<String>))>);\n+pub struct CrateGraphFixture(pub Vec<(String, (String, Edition, CfgOptions, Vec<String>))>);\n \n #[macro_export]\n macro_rules! crate_graph {\n-    ($($crate_name:literal: ($crate_path:literal, $($edition:literal,)? [$($dep:literal),*]),)*) => {{\n+    ($(\n+        $crate_name:literal: (\n+            $crate_path:literal,\n+            $($edition:literal,)?\n+            [$($dep:literal),*]\n+            $(,$cfg:expr)?\n+        ),\n+    )*) => {{\n         let mut res = $crate::mock::CrateGraphFixture::default();\n         $(\n             #[allow(unused_mut, unused_assignments)]\n             let mut edition = ra_db::Edition::Edition2018;\n             $(edition = ra_db::Edition::from_string($edition);)?\n+            let cfg_options = { ::ra_cfg::CfgOptions::default() $(; $cfg)? };\n             res.0.push((\n                 $crate_name.to_string(),\n-                ($crate_path.to_string(), edition, vec![$($dep.to_string()),*])\n+                ($crate_path.to_string(), edition, cfg_options, vec![$($dep.to_string()),*])\n             ));\n         )*\n         res"}, {"sha": "cef2dc9d2877f054b65b1cdba8de1c03c6b2d8eb", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n \n+use ra_cfg::CfgOptions;\n use ra_db::FileId;\n use ra_syntax::{ast, SmolStr};\n use rustc_hash::FxHashMap;\n@@ -35,13 +36,17 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         }\n     }\n \n+    let crate_graph = db.crate_graph();\n+    let cfg_options = crate_graph.cfg_options(def_map.krate().crate_id());\n+\n     let mut collector = DefCollector {\n         db,\n         def_map,\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n         macro_stack_monitor: MacroStackMonitor::default(),\n+        cfg_options,\n     };\n     collector.collect();\n     collector.finish()\n@@ -76,8 +81,8 @@ impl MacroStackMonitor {\n }\n \n /// Walks the tree of module recursively\n-struct DefCollector<DB> {\n-    db: DB,\n+struct DefCollector<'a, DB> {\n+    db: &'a DB,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n@@ -86,9 +91,11 @@ struct DefCollector<DB> {\n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n     macro_stack_monitor: MacroStackMonitor,\n+\n+    cfg_options: &'a CfgOptions,\n }\n \n-impl<'a, DB> DefCollector<&'a DB>\n+impl<DB> DefCollector<'_, DB>\n where\n     DB: DefDatabase,\n {\n@@ -506,7 +513,7 @@ struct ModCollector<'a, D> {\n     parent_module: Option<ParentModule<'a>>,\n }\n \n-impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n+impl<DB> ModCollector<'_, &'_ mut DefCollector<'_, DB>>\n where\n     DB: DefDatabase,\n {\n@@ -523,24 +530,27 @@ where\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n         for item in items {\n-            if let raw::RawItem::Import(import_id) = *item {\n-                let import = self.raw_items[import_id].clone();\n-                if import.is_extern_crate && import.is_macro_use {\n-                    self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n+            if self.is_cfg_enabled(&item.attrs) {\n+                if let raw::RawItemKind::Import(import_id) = item.kind {\n+                    let import = self.raw_items[import_id].clone();\n+                    if import.is_extern_crate && import.is_macro_use {\n+                        self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n+                    }\n                 }\n             }\n         }\n \n         for item in items {\n-            match *item {\n-                raw::RawItem::Module(m) => self.collect_module(&self.raw_items[m]),\n-                raw::RawItem::Import(import_id) => self.def_collector.unresolved_imports.push((\n-                    self.module_id,\n-                    import_id,\n-                    self.raw_items[import_id].clone(),\n-                )),\n-                raw::RawItem::Def(def) => self.define_def(&self.raw_items[def]),\n-                raw::RawItem::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n+            if self.is_cfg_enabled(&item.attrs) {\n+                match item.kind {\n+                    raw::RawItemKind::Module(m) => self.collect_module(&self.raw_items[m]),\n+                    raw::RawItemKind::Import(import_id) => self\n+                        .def_collector\n+                        .unresolved_imports\n+                        .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n+                    raw::RawItemKind::Def(def) => self.define_def(&self.raw_items[def]),\n+                    raw::RawItemKind::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n+                }\n             }\n         }\n     }\n@@ -703,6 +713,14 @@ where\n             self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_);\n         }\n     }\n+\n+    fn is_cfg_enabled(&self, attrs: &raw::Attrs) -> bool {\n+        attrs.as_ref().map_or(true, |attrs| {\n+            attrs\n+                .iter()\n+                .all(|attr| attr.is_cfg_enabled(&self.def_collector.cfg_options) != Some(false))\n+        })\n+    }\n }\n \n fn is_macro_rules(path: &Path) -> bool {\n@@ -730,6 +748,7 @@ mod tests {\n             unresolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n             macro_stack_monitor: monitor,\n+            cfg_options: &CfgOptions::default(),\n         };\n         collector.collect();\n         collector.finish()"}, {"sha": "623b343c4fd6c417ba229f38093152a2f85e4832", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -10,6 +10,7 @@ use ra_syntax::{\n use test_utils::tested_by;\n \n use crate::{\n+    attr::Attr,\n     db::{AstDatabase, DefDatabase},\n     AsName, AstIdMap, Either, FileAstId, HirFileId, ModuleSource, Name, Path, Source,\n };\n@@ -119,8 +120,17 @@ impl Index<Macro> for RawItems {\n     }\n }\n \n+// Avoid heap allocation on items without attributes.\n+pub(super) type Attrs = Option<Arc<[Attr]>>;\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub(super) struct RawItem {\n+    pub(super) attrs: Attrs,\n+    pub(super) kind: RawItemKind,\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum RawItem {\n+pub(super) enum RawItemKind {\n     Module(Module),\n     Import(ImportId),\n     Def(Def),\n@@ -215,6 +225,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n     }\n \n     fn add_item(&mut self, current_module: Option<Module>, item: ast::ModuleItem) {\n+        let attrs = self.parse_attrs(&item);\n         let (kind, name) = match item {\n             ast::ModuleItem::Module(module) => {\n                 self.add_module(current_module, module);\n@@ -263,7 +274,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n         if let Some(name) = name {\n             let name = name.as_name();\n             let def = self.raw_items.defs.alloc(DefData { name, kind });\n-            self.push_item(current_module, RawItem::Def(def))\n+            self.push_item(current_module, attrs, RawItemKind::Def(def));\n         }\n     }\n \n@@ -272,8 +283,10 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n             Some(it) => it.as_name(),\n             None => return,\n         };\n+        let attrs = self.parse_attrs(&module);\n \n         let ast_id = self.source_ast_id_map.ast_id(&module);\n+        // FIXME: cfg_attr\n         let is_macro_use = module.has_atom_attr(\"macro_use\");\n         if module.has_semi() {\n             let attr_path = extract_mod_path_attribute(&module);\n@@ -283,7 +296,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n                 attr_path,\n                 is_macro_use,\n             });\n-            self.push_item(current_module, RawItem::Module(item));\n+            self.push_item(current_module, attrs, RawItemKind::Module(item));\n             return;\n         }\n \n@@ -297,14 +310,16 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n                 is_macro_use,\n             });\n             self.process_module(Some(item), item_list);\n-            self.push_item(current_module, RawItem::Module(item));\n+            self.push_item(current_module, attrs, RawItemKind::Module(item));\n             return;\n         }\n         tested_by!(name_res_works_for_broken_modules);\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {\n+        // FIXME: cfg_attr\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n+        let attrs = self.parse_attrs(&use_item);\n \n         Path::expand_use_item(\n             Source { ast: use_item, file_id: self.file_id },\n@@ -318,7 +333,12 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n                     is_extern_crate: false,\n                     is_macro_use: false,\n                 };\n-                self.push_import(current_module, import_data, Either::A(AstPtr::new(use_tree)));\n+                self.push_import(\n+                    current_module,\n+                    attrs.clone(),\n+                    import_data,\n+                    Either::A(AstPtr::new(use_tree)),\n+                );\n             },\n         )\n     }\n@@ -331,6 +351,8 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n         if let Some(name_ref) = extern_crate.name_ref() {\n             let path = Path::from_name_ref(&name_ref);\n             let alias = extern_crate.alias().and_then(|a| a.name()).map(|it| it.as_name());\n+            let attrs = self.parse_attrs(&extern_crate);\n+            // FIXME: cfg_attr\n             let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n             let import_data = ImportData {\n                 path,\n@@ -340,11 +362,17 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n                 is_extern_crate: true,\n                 is_macro_use,\n             };\n-            self.push_import(current_module, import_data, Either::B(AstPtr::new(&extern_crate)));\n+            self.push_import(\n+                current_module,\n+                attrs,\n+                import_data,\n+                Either::B(AstPtr::new(&extern_crate)),\n+            );\n         }\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n+        let attrs = self.parse_attrs(&m);\n         let path = match m\n             .path()\n             .and_then(|path| Path::from_src(Source { ast: path, file_id: self.file_id }, self.db))\n@@ -355,32 +383,38 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n \n         let name = m.name().map(|it| it.as_name());\n         let ast_id = self.source_ast_id_map.ast_id(&m);\n+        // FIXME: cfg_attr\n         let export = m.attrs().filter_map(|x| x.simple_name()).any(|name| name == \"macro_export\");\n \n         let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n-        self.push_item(current_module, RawItem::Macro(m));\n+        self.push_item(current_module, attrs, RawItemKind::Macro(m));\n     }\n \n     fn push_import(\n         &mut self,\n         current_module: Option<Module>,\n+        attrs: Attrs,\n         data: ImportData,\n         source: ImportSourcePtr,\n     ) {\n         let import = self.raw_items.imports.alloc(data);\n         self.source_map.insert(import, source);\n-        self.push_item(current_module, RawItem::Import(import))\n+        self.push_item(current_module, attrs, RawItemKind::Import(import))\n     }\n \n-    fn push_item(&mut self, current_module: Option<Module>, item: RawItem) {\n+    fn push_item(&mut self, current_module: Option<Module>, attrs: Attrs, kind: RawItemKind) {\n         match current_module {\n             Some(module) => match &mut self.raw_items.modules[module] {\n                 ModuleData::Definition { items, .. } => items,\n                 ModuleData::Declaration { .. } => unreachable!(),\n             },\n             None => &mut self.raw_items.items,\n         }\n-        .push(item)\n+        .push(RawItem { attrs, kind })\n+    }\n+\n+    fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n+        Attr::from_attrs_owner(self.file_id, item, self.db)\n     }\n }\n "}, {"sha": "34dd795743852cf954a0111a85140b652184b102", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -7,6 +7,7 @@ mod mod_resolution;\n use std::sync::Arc;\n \n use insta::assert_snapshot;\n+use ra_cfg::CfgOptions;\n use ra_db::SourceDatabase;\n use test_utils::covers;\n \n@@ -507,3 +508,72 @@ fn values_dont_shadow_extern_crates() {\n         \u22eefoo: v\n     \"###);\n }\n+\n+#[test]\n+fn cfg_not_test() {\n+    let map = def_map_with_crate_graph(\n+        r#\"\n+        //- /main.rs\n+        use {Foo, Bar, Baz};\n+        //- /lib.rs\n+        #[prelude_import]\n+        pub use self::prelude::*;\n+        mod prelude {\n+            #[cfg(test)]\n+            pub struct Foo;\n+            #[cfg(not(test))]\n+            pub struct Bar;\n+            #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n+            pub struct Baz;\n+        }\n+        \"#,\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"std\"]),\n+            \"std\": (\"/lib.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBar: t v\n+        \u22eeBaz: _\n+        \u22eeFoo: _\n+    \"###);\n+}\n+\n+#[test]\n+fn cfg_test() {\n+    let map = def_map_with_crate_graph(\n+        r#\"\n+        //- /main.rs\n+        use {Foo, Bar, Baz};\n+        //- /lib.rs\n+        #[prelude_import]\n+        pub use self::prelude::*;\n+        mod prelude {\n+            #[cfg(test)]\n+            pub struct Foo;\n+            #[cfg(not(test))]\n+            pub struct Bar;\n+            #[cfg(all(not(any()), feature = \"foo\", feature = \"bar\", opt = \"42\"))]\n+            pub struct Baz;\n+        }\n+        \"#,\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"std\"]),\n+            \"std\": (\"/lib.rs\", [], CfgOptions::default()\n+                .atom(\"test\".into())\n+                .key_value(\"feature\".into(), \"foo\".into())\n+                .key_value(\"feature\".into(), \"bar\".into())\n+                .key_value(\"opt\".into(), \"42\".into())\n+            ),\n+        },\n+    );\n+\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBar: _\n+        \u22eeBaz: t v\n+        \u22eeFoo: t v\n+    \"###);\n+}"}, {"sha": "25dad81eb7c8c6ac801fe1748515e94051c2b3ee", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -3,6 +3,7 @@ use std::sync::Arc;\n \n use insta::assert_snapshot;\n \n+use ra_cfg::CfgOptions;\n use ra_db::{salsa::Database, FilePosition, SourceDatabase};\n use ra_syntax::{\n     algo,\n@@ -23,6 +24,50 @@ use crate::{\n mod never_type;\n mod coercion;\n \n+#[test]\n+fn cfg_impl_block() {\n+    let (mut db, pos) = MockDatabase::with_position(\n+        r#\"\n+//- /main.rs\n+use foo::S as T;\n+struct S;\n+\n+#[cfg(test)]\n+impl S {\n+    fn foo1(&self) -> i32 { 0 }\n+}\n+\n+#[cfg(not(test))]\n+impl S {\n+    fn foo2(&self) -> i32 { 0 }\n+}\n+\n+fn test() {\n+    let t = (S.foo1(), S.foo2(), T.foo3(), T.foo4());\n+    t<|>;\n+}\n+\n+//- /foo.rs\n+struct S;\n+\n+#[cfg(not(test))]\n+impl S {\n+    fn foo3(&self) -> i32 { 0 }\n+}\n+\n+#[cfg(test)]\n+impl S {\n+    fn foo4(&self) -> i32 { 0 }\n+}\n+\"#,\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"foo\"], CfgOptions::default().atom(\"test\".into())),\n+        \"foo\": (\"/foo.rs\", []),\n+    });\n+    assert_eq!(\"(i32, {unknown}, i32, {unknown})\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn infer_await() {\n     let (mut db, pos) = MockDatabase::with_position("}, {"sha": "f919a2d615207df23eed33b8e9e29849296ba6b9", "filename": "crates/ra_ide_api/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_ide_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_ide_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2FCargo.toml?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -23,6 +23,7 @@ rand = { version = \"0.7.0\", features = [\"small_rng\"] }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_db = { path = \"../ra_db\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n ra_fmt = { path = \"../ra_fmt\" }\n ra_prof = { path = \"../ra_prof\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }"}, {"sha": "24f1b91f68c9710424426770798f3810b3a46f70", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -49,6 +49,7 @@ mod test_utils;\n \n use std::sync::Arc;\n \n+use ra_cfg::CfgOptions;\n use ra_db::{\n     salsa::{self, ParallelDatabase},\n     CheckCanceled, SourceDatabase,\n@@ -322,7 +323,10 @@ impl Analysis {\n         change.add_root(source_root, true);\n         let mut crate_graph = CrateGraph::default();\n         let file_id = FileId(0);\n-        crate_graph.add_crate_root(file_id, Edition::Edition2018);\n+        // FIXME: cfg options\n+        // Default to enable test for single file.\n+        let cfg_options = CfgOptions::default().atom(\"test\".into());\n+        crate_graph.add_crate_root(file_id, Edition::Edition2018, cfg_options);\n         change.add_file(source_root, file_id, \"main.rs\".into(), Arc::new(text));\n         change.set_crate_graph(crate_graph);\n         host.apply_change(change);"}, {"sha": "80b71894cdf64275918aa6f8801294396a0336c0", "filename": "crates/ra_ide_api/src/mock_analysis.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -2,6 +2,7 @@\n \n use std::sync::Arc;\n \n+use ra_cfg::CfgOptions;\n use relative_path::RelativePathBuf;\n use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n \n@@ -93,10 +94,11 @@ impl MockAnalysis {\n             assert!(path.starts_with('/'));\n             let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n             let file_id = FileId(i as u32 + 1);\n+            let cfg_options = CfgOptions::default();\n             if path == \"/lib.rs\" || path == \"/main.rs\" {\n-                root_crate = Some(crate_graph.add_crate_root(file_id, Edition2018));\n+                root_crate = Some(crate_graph.add_crate_root(file_id, Edition2018, cfg_options));\n             } else if path.ends_with(\"/lib.rs\") {\n-                let other_crate = crate_graph.add_crate_root(file_id, Edition2018);\n+                let other_crate = crate_graph.add_crate_root(file_id, Edition2018, cfg_options);\n                 let crate_name = path.parent().unwrap().file_name().unwrap();\n                 if let Some(root_crate) = root_crate {\n                     crate_graph.add_dep(root_crate, crate_name.into(), other_crate).unwrap();"}, {"sha": "56650984995b656d344f18a44793038495c64e6a", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -41,6 +41,7 @@ mod tests {\n         AnalysisChange, CrateGraph,\n         Edition::Edition2018,\n     };\n+    use ra_cfg::CfgOptions;\n \n     #[test]\n     fn test_resolve_parent_module() {\n@@ -88,7 +89,7 @@ mod tests {\n         assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n \n         let mut crate_graph = CrateGraph::default();\n-        let crate_id = crate_graph.add_crate_root(root_file, Edition2018);\n+        let crate_id = crate_graph.add_crate_root(root_file, Edition2018, CfgOptions::default());\n         let mut change = AnalysisChange::new();\n         change.set_crate_graph(crate_graph);\n         host.apply_change(change);"}, {"sha": "aedc55a95ce94c3bbee91c5fc9132f6dbc9926f8", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -19,6 +19,7 @@ jod-thread = \"0.1.0\"\n ra_vfs = \"0.4.0\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_db = { path = \"../ra_db\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_ide_api = { path = \"../ra_ide_api\" }\n lsp-server = \"0.2.0\""}, {"sha": "27da751ab4a357371ac148243872db0f89b5c623", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -13,7 +13,7 @@ use ra_ide_api::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FeatureFlags, FileId, LibraryData,\n     SourceRootId,\n };\n-use ra_project_model::ProjectWorkspace;\n+use ra_project_model::{get_rustc_cfg_options, ProjectWorkspace};\n use ra_vfs::{LineEndings, RootEntry, Vfs, VfsChange, VfsFile, VfsRoot, VfsTask, Watch};\n use ra_vfs_glob::{Glob, RustPackageFilterBuilder};\n use relative_path::RelativePathBuf;\n@@ -97,14 +97,18 @@ impl WorldState {\n             change.set_debug_root_path(SourceRootId(r.0), vfs_root_path.display().to_string());\n         }\n \n+        // FIXME: Read default cfgs from config\n+        let default_cfg_options =\n+            get_rustc_cfg_options().atom(\"test\".into()).atom(\"debug_assertion\".into());\n+\n         // Create crate graph from all the workspaces\n         let mut crate_graph = CrateGraph::default();\n         let mut load = |path: &std::path::Path| {\n             let vfs_file = vfs.load(path);\n             vfs_file.map(|f| FileId(f.0))\n         };\n         for ws in workspaces.iter() {\n-            let (graph, crate_names) = ws.to_crate_graph(&mut load);\n+            let (graph, crate_names) = ws.to_crate_graph(&default_cfg_options, &mut load);\n             let shift = crate_graph.extend(graph);\n             for (crate_id, name) in crate_names {\n                 change.set_debug_crate_name(crate_id.shift(shift), name)"}, {"sha": "2ba82ab051f96eee2da9a8599121dcc1c135e4ee", "filename": "crates/ra_lsp_server/tests/heavy_tests/main.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -286,7 +286,13 @@ fn test_missing_module_code_action_in_json_project() {\n \n     let project = json!({\n         \"roots\": [path],\n-        \"crates\": [ { \"root_module\": path.join(\"src/lib.rs\"), \"deps\": [], \"edition\": \"2015\" } ]\n+        \"crates\": [ {\n+            \"root_module\": path.join(\"src/lib.rs\"),\n+            \"deps\": [],\n+            \"edition\": \"2015\",\n+            \"atom_cfgs\": [],\n+            \"key_value_cfgs\": {}\n+        } ]\n     });\n \n     let code = format!("}, {"sha": "a651000315b9e8f93dca261e2a7976dd1412c4fc", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -12,6 +12,7 @@ cargo_metadata = \"0.8.2\"\n \n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n \n serde = { version = \"1.0.89\", features = [\"derive\"] }\n serde_json = \"1.0.39\""}, {"sha": "28dadea9d7e03a4cbbe70d149340f0d9e144f510", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -39,6 +39,7 @@ struct PackageData {\n     is_member: bool,\n     dependencies: Vec<PackageDependency>,\n     edition: Edition,\n+    features: Vec<String>,\n }\n \n #[derive(Debug, Clone)]\n@@ -91,6 +92,9 @@ impl Package {\n     pub fn edition(self, ws: &CargoWorkspace) -> Edition {\n         ws.packages[self].edition\n     }\n+    pub fn features(self, ws: &CargoWorkspace) -> &[String] {\n+        &ws.packages[self].features\n+    }\n     pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n         ws.packages[self].targets.iter().cloned()\n     }\n@@ -144,6 +148,7 @@ impl CargoWorkspace {\n                 is_member,\n                 edition: Edition::from_string(&meta_pkg.edition),\n                 dependencies: Vec::new(),\n+                features: Vec::new(),\n             });\n             let pkg_data = &mut packages[pkg];\n             pkg_by_id.insert(meta_pkg.id.clone(), pkg);\n@@ -164,6 +169,7 @@ impl CargoWorkspace {\n                 let dep = PackageDependency { name: dep_node.name, pkg: pkg_by_id[&dep_node.pkg] };\n                 packages[source].dependencies.push(dep);\n             }\n+            packages[source].features.extend(node.features);\n         }\n \n         Ok(CargoWorkspace { packages, targets, workspace_root: meta.workspace_root })"}, {"sha": "1bacb1d09a155cff835d5345c114c76083305a9e", "filename": "crates/ra_project_model/src/json_project.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -2,6 +2,7 @@\n \n use std::path::PathBuf;\n \n+use rustc_hash::{FxHashMap, FxHashSet};\n use serde::Deserialize;\n \n /// A root points to the directory which contains Rust crates. rust-analyzer watches all files in\n@@ -19,6 +20,8 @@ pub struct Crate {\n     pub(crate) root_module: PathBuf,\n     pub(crate) edition: Edition,\n     pub(crate) deps: Vec<Dep>,\n+    pub(crate) atom_cfgs: FxHashSet<String>,\n+    pub(crate) key_value_cfgs: FxHashMap<String, String>,\n }\n \n #[derive(Clone, Copy, Debug, Deserialize)]"}, {"sha": "640a5ebd3213c984954ac5ea2a32c92aefbd2c73", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -9,8 +9,10 @@ use std::{\n     fs::File,\n     io::BufReader,\n     path::{Path, PathBuf},\n+    process::Command,\n };\n \n+use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateId, Edition, FileId};\n use rustc_hash::FxHashMap;\n use serde_json::from_reader;\n@@ -117,6 +119,7 @@ impl ProjectWorkspace {\n \n     pub fn to_crate_graph(\n         &self,\n+        default_cfg_options: &CfgOptions,\n         load: &mut dyn FnMut(&Path) -> Option<FileId>,\n     ) -> (CrateGraph, FxHashMap<CrateId, String>) {\n         let mut crate_graph = CrateGraph::default();\n@@ -131,7 +134,17 @@ impl ProjectWorkspace {\n                             json_project::Edition::Edition2015 => Edition::Edition2015,\n                             json_project::Edition::Edition2018 => Edition::Edition2018,\n                         };\n-                        crates.insert(crate_id, crate_graph.add_crate_root(file_id, edition));\n+                        let mut cfg_options = default_cfg_options.clone();\n+                        for name in &krate.atom_cfgs {\n+                            cfg_options = cfg_options.atom(name.into());\n+                        }\n+                        for (key, value) in &krate.key_value_cfgs {\n+                            cfg_options = cfg_options.key_value(key.into(), value.into());\n+                        }\n+                        crates.insert(\n+                            crate_id,\n+                            crate_graph.add_crate_root(file_id, edition, cfg_options),\n+                        );\n                     }\n                 }\n \n@@ -157,7 +170,10 @@ impl ProjectWorkspace {\n                 let mut sysroot_crates = FxHashMap::default();\n                 for krate in sysroot.crates() {\n                     if let Some(file_id) = load(krate.root(&sysroot)) {\n-                        let crate_id = crate_graph.add_crate_root(file_id, Edition::Edition2018);\n+                        // Crates from sysroot have `cfg(test)` disabled\n+                        let cfg_options = default_cfg_options.clone().remove_atom(&\"test\".into());\n+                        let crate_id =\n+                            crate_graph.add_crate_root(file_id, Edition::Edition2018, cfg_options);\n                         sysroot_crates.insert(krate, crate_id);\n                         names.insert(crate_id, krate.name(&sysroot).to_string());\n                     }\n@@ -186,7 +202,11 @@ impl ProjectWorkspace {\n                         let root = tgt.root(&cargo);\n                         if let Some(file_id) = load(root) {\n                             let edition = pkg.edition(&cargo);\n-                            let crate_id = crate_graph.add_crate_root(file_id, edition);\n+                            let cfg_options = default_cfg_options\n+                                .clone()\n+                                .features(pkg.features(&cargo).iter().map(Into::into));\n+                            let crate_id =\n+                                crate_graph.add_crate_root(file_id, edition, cfg_options);\n                             names.insert(crate_id, pkg.name(&cargo).to_string());\n                             if tgt.kind(&cargo) == TargetKind::Lib {\n                                 lib_tgt = Some(crate_id);\n@@ -286,3 +306,32 @@ fn find_cargo_toml(path: &Path) -> Result<PathBuf> {\n     }\n     Err(format!(\"can't find Cargo.toml at {}\", path.display()))?\n }\n+\n+pub fn get_rustc_cfg_options() -> CfgOptions {\n+    let mut cfg_options = CfgOptions::default();\n+\n+    match (|| -> Result<_> {\n+        // `cfg(test)` and `cfg(debug_assertion)` are handled outside, so we suppress them here.\n+        let output = Command::new(\"rustc\").args(&[\"--print\", \"cfg\", \"-O\"]).output()?;\n+        if !output.status.success() {\n+            Err(\"failed to get rustc cfgs\")?;\n+        }\n+        Ok(String::from_utf8(output.stdout)?)\n+    })() {\n+        Ok(rustc_cfgs) => {\n+            for line in rustc_cfgs.lines() {\n+                match line.find('=') {\n+                    None => cfg_options = cfg_options.atom(line.into()),\n+                    Some(pos) => {\n+                        let key = &line[..pos];\n+                        let value = line[pos + 1..].trim_matches('\"');\n+                        cfg_options = cfg_options.key_value(key.into(), value.into());\n+                    }\n+                }\n+            }\n+        }\n+        Err(e) => log::error!(\"failed to get rustc cfgs: {}\", e),\n+    }\n+\n+    cfg_options\n+}"}, {"sha": "34b22c3e2ac93a752b2aeed5dc51decf9816d358", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -1962,6 +1962,7 @@ impl AstNode for ModuleItem {\n         }\n     }\n }\n+impl ast::AttrsOwner for ModuleItem {}\n impl ModuleItem {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {"}, {"sha": "25e6f64ce0e58340e0528fc288da10bdad4f661e", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -397,7 +397,8 @@ Grammar(\n         ),\n         \"ModuleItem\": (\n             enum: [\"StructDef\", \"EnumDef\", \"FnDef\", \"TraitDef\", \"TypeAliasDef\", \"ImplBlock\",\n-                   \"UseItem\", \"ExternCrateItem\", \"ConstDef\", \"StaticDef\", \"Module\" ]\n+                   \"UseItem\", \"ExternCrateItem\", \"ConstDef\", \"StaticDef\", \"Module\" ],\n+            traits: [\"AttrsOwner\"]\n         ),\n         \"ImplItem\": (\n             enum: [\"FnDef\", \"TypeAliasDef\", \"ConstDef\"]"}]}