{"sha": "686ad4da9ef71ae7df9d57a036e614b01fab8c59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NmFkNGRhOWVmNzFhZTdkZjlkNTdhMDM2ZTYxNGIwMWZhYjhjNTk=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-09-30T21:38:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-30T21:38:22Z"}, "message": "Rollup merge of #64828 - ecstatic-morse:generic-dataflow-graphviz, r=oli-obk\n\nGraphviz debug output for generic dataflow analysis\n\nA follow up to #64566.\n\nThis outputs graphviz diagrams in the generic dataflow engine when `#[rustc_mir(borrowck_graphviz_postflow=\"suffix.dot\")]` is set on an item. This code is based on [`dataflow/graphviz.rs`](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/dataflow/graphviz.rs), but displays different information since there are no \"gen\"/\"kill\" sets and transfer functions cannot be coalesced in the generic analysis. As a result, we show the dataflow state at the start and end of each block, as well as the changes resulting from each statement. I also render the state bitset in full  (`{_1,_2}`) instead of hex-encoded as the current renderer does (`06`).", "tree": {"sha": "18c3bee849d9248d14423ec20f307d8da29b843e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18c3bee849d9248d14423ec20f307d8da29b843e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/686ad4da9ef71ae7df9d57a036e614b01fab8c59", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdknXOCRBK7hj4Ov3rIwAAdHIIAIvkqQfBHCcOk6aL1WbV2A8O\nzle3rZxl16WA8wW/2vM2GYTVGLn6JKqJ9932WgfFZj6LsweCgfRjnlVK0F/553d8\ntS2xd31DU+KLDVg6fETX/T3K3tMAUgUJWZX9rqdLvlKjrPcXHHMKw6QW8OJMcOwI\njNi0mdKgXWYJbJLECfbzij+L5p24JHfMJUMuEVINlxI28VmEk9iV1eF5qaJlzie+\nbd17i8/P5qU1jUve/TtR4LhKZLNuMJswoQJUi99Qj4zLHRCYPTdnU8aM4RD+MLH4\n7EqXTDbJdnK1QKSVG8z4dnSsg6mxzAZHw08xL41S/lI8OOrnvzUWV+pPi98OZns=\n=v5+c\n-----END PGP SIGNATURE-----\n", "payload": "tree 18c3bee849d9248d14423ec20f307d8da29b843e\nparent fb8f9b47eb47e66f180e302c2ee40b6fe451e447\nparent 2b8e023b9d28f2f912ad21427b5266b62c007f11\nauthor Tyler Mandry <tmandry@gmail.com> 1569879502 -0700\ncommitter GitHub <noreply@github.com> 1569879502 -0700\n\nRollup merge of #64828 - ecstatic-morse:generic-dataflow-graphviz, r=oli-obk\n\nGraphviz debug output for generic dataflow analysis\n\nA follow up to #64566.\n\nThis outputs graphviz diagrams in the generic dataflow engine when `#[rustc_mir(borrowck_graphviz_postflow=\"suffix.dot\")]` is set on an item. This code is based on [`dataflow/graphviz.rs`](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/dataflow/graphviz.rs), but displays different information since there are no \"gen\"/\"kill\" sets and transfer functions cannot be coalesced in the generic analysis. As a result, we show the dataflow state at the start and end of each block, as well as the changes resulting from each statement. I also render the state bitset in full  (`{_1,_2}`) instead of hex-encoded as the current renderer does (`06`).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/686ad4da9ef71ae7df9d57a036e614b01fab8c59", "html_url": "https://github.com/rust-lang/rust/commit/686ad4da9ef71ae7df9d57a036e614b01fab8c59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/686ad4da9ef71ae7df9d57a036e614b01fab8c59/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb8f9b47eb47e66f180e302c2ee40b6fe451e447", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb8f9b47eb47e66f180e302c2ee40b6fe451e447", "html_url": "https://github.com/rust-lang/rust/commit/fb8f9b47eb47e66f180e302c2ee40b6fe451e447"}, {"sha": "2b8e023b9d28f2f912ad21427b5266b62c007f11", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8e023b9d28f2f912ad21427b5266b62c007f11", "html_url": "https://github.com/rust-lang/rust/commit/2b8e023b9d28f2f912ad21427b5266b62c007f11"}], "stats": {"total": 555, "additions": 535, "deletions": 20}, "files": [{"sha": "dd6238b80d1744115ea4615de706806a728afa48", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "modified", "additions": 115, "deletions": 14, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=686ad4da9ef71ae7df9d57a036e614b01fab8c59", "patch": "@@ -16,16 +16,24 @@\n //! [gk]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n //! [#64566]: https://github.com/rust-lang/rust/pull/64566\n \n+use std::borrow::Borrow;\n use std::cmp::Ordering;\n-use std::ops;\n+use std::ffi::OsString;\n+use std::path::{Path, PathBuf};\n+use std::{fs, io, ops};\n \n+use rustc::hir::def_id::DefId;\n use rustc::mir::{self, traversal, BasicBlock, Location};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::work_queue::WorkQueue;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_data_structures::work_queue::WorkQueue;\n+use syntax::symbol::sym;\n \n use crate::dataflow::BottomValue;\n \n+mod graphviz;\n+\n /// A specific kind of dataflow analysis.\n ///\n /// To run a dataflow analysis, one must set the initial state of the `START_BLOCK` via\n@@ -62,6 +70,13 @@ pub trait Analysis<'tcx>: BottomValue {\n     /// and try to keep it short.\n     const NAME: &'static str;\n \n+    /// How each element of your dataflow state will be displayed during debugging.\n+    ///\n+    /// By default, this is the `fmt::Debug` representation of `Self::Idx`.\n+    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n+        write!(w, \"{:?}\", idx)\n+    }\n+\n     /// The size of each bitvector allocated for each block.\n     fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n \n@@ -77,7 +92,7 @@ pub trait Analysis<'tcx>: BottomValue {\n         location: Location,\n     );\n \n-    /// Updates the current dataflow state with the effect of evaluating a statement.\n+    /// Updates the current dataflow state with the effect of evaluating a terminator.\n     ///\n     /// Note that the effect of a successful return from a `Call` terminator should **not** be\n     /// acounted for in this function. That should go in `apply_call_return_effect`. For example,\n@@ -180,17 +195,20 @@ impl CursorPosition {\n     }\n }\n \n+type ResultsRefCursor<'a, 'mir, 'tcx, A> =\n+    ResultsCursor<'mir, 'tcx, A, &'a Results<'tcx, A>>;\n+\n /// Inspect the results of dataflow analysis.\n ///\n /// This cursor has linear performance when visiting statements in a block in order. Visiting\n /// statements within a block in reverse order is `O(n^2)`, where `n` is the number of statements\n /// in that block.\n-pub struct ResultsCursor<'mir, 'tcx, A>\n+pub struct ResultsCursor<'mir, 'tcx, A, R = Results<'tcx, A>>\n where\n     A: Analysis<'tcx>,\n {\n     body: &'mir mir::Body<'tcx>,\n-    results: Results<'tcx, A>,\n+    results: R,\n     state: BitSet<A::Idx>,\n \n     pos: CursorPosition,\n@@ -202,24 +220,29 @@ where\n     is_call_return_effect_applied: bool,\n }\n \n-impl<'mir, 'tcx, A> ResultsCursor<'mir, 'tcx, A>\n+impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n where\n     A: Analysis<'tcx>,\n+    R: Borrow<Results<'tcx, A>>,\n {\n     /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n-    pub fn new(body: &'mir mir::Body<'tcx>, results: Results<'tcx, A>) -> Self {\n+    pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n         ResultsCursor {\n             body,\n             pos: CursorPosition::AtBlockStart(mir::START_BLOCK),\n             is_call_return_effect_applied: false,\n-            state: results.entry_sets[mir::START_BLOCK].clone(),\n+            state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n             results,\n         }\n     }\n \n+    pub fn analysis(&self) -> &A {\n+        &self.results.borrow().analysis\n+    }\n+\n     /// Resets the cursor to the start of the given `block`.\n     pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n-        self.state.overwrite(&self.results.entry_sets[block]);\n+        self.state.overwrite(&self.results.borrow().entry_sets[block]);\n         self.pos = CursorPosition::AtBlockStart(block);\n         self.is_call_return_effect_applied = false;\n     }\n@@ -275,7 +298,7 @@ where\n         } = &term.kind {\n             if !self.is_call_return_effect_applied {\n                 self.is_call_return_effect_applied = true;\n-                self.results.analysis.apply_call_return_effect(\n+                self.results.borrow().analysis.apply_call_return_effect(\n                     &mut self.state,\n                     target.block,\n                     func,\n@@ -316,7 +339,7 @@ where\n         };\n \n         let block_data = &self.body.basic_blocks()[target_block];\n-        self.results.analysis.apply_partial_block_effect(\n+        self.results.borrow().analysis.apply_partial_block_effect(\n             &mut self.state,\n             target_block,\n             block_data,\n@@ -349,7 +372,9 @@ where\n {\n     analysis: A,\n     bits_per_block: usize,\n+    tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n+    def_id: DefId,\n     dead_unwinds: &'a BitSet<BasicBlock>,\n     entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n }\n@@ -359,7 +384,9 @@ where\n     A: Analysis<'tcx>,\n {\n     pub fn new(\n+        tcx: TyCtxt<'tcx>,\n         body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n         dead_unwinds: &'a BitSet<BasicBlock>,\n         analysis: A,\n     ) -> Self {\n@@ -377,7 +404,9 @@ where\n         Engine {\n             analysis,\n             bits_per_block,\n+            tcx,\n             body,\n+            def_id,\n             dead_unwinds,\n             entry_sets,\n         }\n@@ -413,10 +442,26 @@ where\n             );\n         }\n \n-        Results {\n-            analysis: self.analysis,\n-            entry_sets: self.entry_sets,\n+        let Engine {\n+            tcx,\n+            body,\n+            def_id,\n+            analysis,\n+            entry_sets,\n+            ..\n+        } = self;\n+\n+        let results = Results { analysis, entry_sets };\n+\n+        let attrs = tcx.get_attrs(def_id);\n+        if let Some(path) = get_dataflow_graphviz_output_path(tcx, attrs, A::NAME) {\n+            let result = write_dataflow_graphviz_results(body, def_id, &path, &results);\n+            if let Err(e) = result {\n+                warn!(\"Failed to write dataflow results to {}: {}\", path.display(), e);\n+            }\n         }\n+\n+        results\n     }\n \n     fn propagate_bits_into_graph_successors_of(\n@@ -510,3 +555,59 @@ where\n         }\n     }\n }\n+\n+/// Looks for attributes like `#[rustc_mir(borrowck_graphviz_postflow=\"./path/to/suffix.dot\")]` and\n+/// extracts the path with the given analysis name prepended to the suffix.\n+///\n+/// Returns `None` if no such attribute exists.\n+fn get_dataflow_graphviz_output_path(\n+    tcx: TyCtxt<'tcx>,\n+    attrs: ty::Attributes<'tcx>,\n+    analysis: &str,\n+) -> Option<PathBuf> {\n+    let mut rustc_mir_attrs = attrs\n+        .into_iter()\n+        .filter(|attr| attr.check_name(sym::rustc_mir))\n+        .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n+\n+    let borrowck_graphviz_postflow = rustc_mir_attrs\n+        .find(|attr| attr.check_name(sym::borrowck_graphviz_postflow))?;\n+\n+    let path_and_suffix = match borrowck_graphviz_postflow.value_str() {\n+        Some(p) => p,\n+        None => {\n+            tcx.sess.span_err(\n+                borrowck_graphviz_postflow.span(),\n+                \"borrowck_graphviz_postflow requires a path\",\n+            );\n+\n+            return None;\n+        }\n+    };\n+\n+    // Change \"path/suffix.dot\" to \"path/analysis_name_suffix.dot\"\n+    let mut ret = PathBuf::from(path_and_suffix.to_string());\n+    let suffix = ret.file_name().unwrap();\n+\n+    let mut file_name: OsString = analysis.into();\n+    file_name.push(\"_\");\n+    file_name.push(suffix);\n+    ret.set_file_name(file_name);\n+\n+    Some(ret)\n+}\n+\n+fn write_dataflow_graphviz_results<A: Analysis<'tcx>>(\n+    body: &mir::Body<'tcx>,\n+    def_id: DefId,\n+    path: &Path,\n+    results: &Results<'tcx, A>\n+) -> io::Result<()> {\n+    debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n+\n+    let mut buf = Vec::new();\n+    let graphviz = graphviz::Formatter::new(body, def_id, results);\n+\n+    dot::render(&graphviz, &mut buf)?;\n+    fs::write(path, buf)\n+}"}, {"sha": "2a08feff9e77ab1bcb3a7708fbfe1a9086184d41", "filename": "src/librustc_mir/dataflow/generic/graphviz.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs?ref=686ad4da9ef71ae7df9d57a036e614b01fab8c59", "patch": "@@ -0,0 +1,412 @@\n+use std::cell::RefCell;\n+use std::io::{self, Write};\n+use std::{ops, str};\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::{self, BasicBlock, Body, Location};\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::vec::Idx;\n+\n+use crate::util::graphviz_safe_def_name;\n+use super::{Analysis, Results, ResultsRefCursor};\n+\n+pub struct Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    body: &'a Body<'tcx>,\n+    def_id: DefId,\n+\n+    // This must be behind a `RefCell` because `dot::Labeller` takes `&self`.\n+    block_formatter: RefCell<BlockFormatter<'a, 'tcx, A>>,\n+}\n+\n+impl<A> Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn new(\n+        body: &'a Body<'tcx>,\n+        def_id: DefId,\n+        results: &'a Results<'tcx, A>,\n+    ) -> Self {\n+        let block_formatter = BlockFormatter {\n+            bg: Background::Light,\n+            prev_state: BitSet::new_empty(results.analysis.bits_per_block(body)),\n+            results: ResultsRefCursor::new(body, results),\n+        };\n+\n+        Formatter {\n+            body,\n+            def_id,\n+            block_formatter: RefCell::new(block_formatter),\n+        }\n+    }\n+}\n+\n+/// A pair of a basic block and an index into that basic blocks `successors`.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct CfgEdge {\n+    source: BasicBlock,\n+    index: usize,\n+}\n+\n+fn outgoing_edges(body: &Body<'_>, bb: BasicBlock) -> Vec<CfgEdge> {\n+    body[bb]\n+        .terminator()\n+        .successors()\n+        .enumerate()\n+        .map(|(index, _)| CfgEdge { source: bb, index })\n+        .collect()\n+}\n+\n+impl<A> dot::Labeller<'_> for Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    type Node = BasicBlock;\n+    type Edge = CfgEdge;\n+\n+    fn graph_id(&self) -> dot::Id<'_> {\n+        let name = graphviz_safe_def_name(self.def_id);\n+        dot::Id::new(format!(\"graph_for_def_id_{}\", name)).unwrap()\n+    }\n+\n+    fn node_id(&self, n: &Self::Node) -> dot::Id<'_> {\n+        dot::Id::new(format!(\"bb_{}\", n.index())).unwrap()\n+    }\n+\n+    fn node_label(&self, block: &Self::Node) -> dot::LabelText<'_> {\n+        let mut label = Vec::new();\n+        self.block_formatter\n+            .borrow_mut()\n+            .write_node_label(&mut label, self.body, *block)\n+            .unwrap();\n+        dot::LabelText::html(String::from_utf8(label).unwrap())\n+    }\n+\n+    fn node_shape(&self, _n: &Self::Node) -> Option<dot::LabelText<'_>> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+\n+    fn edge_label(&self, e: &Self::Edge) -> dot::LabelText<'_> {\n+        let label = &self.body\n+            [e.source]\n+            .terminator()\n+            .kind\n+            .fmt_successor_labels()\n+            [e.index];\n+        dot::LabelText::label(label.clone())\n+    }\n+}\n+\n+impl<A> dot::GraphWalk<'a> for Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    type Node = BasicBlock;\n+    type Edge = CfgEdge;\n+\n+    fn nodes(&self) -> dot::Nodes<'_, Self::Node> {\n+        self.body\n+            .basic_blocks()\n+            .indices()\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+\n+    fn edges(&self) -> dot::Edges<'_, Self::Edge> {\n+        self.body\n+            .basic_blocks()\n+            .indices()\n+            .flat_map(|bb| outgoing_edges(self.body, bb))\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+\n+    fn source(&self, edge: &Self::Edge) -> Self::Node {\n+        edge.source\n+    }\n+\n+    fn target(&self, edge: &Self::Edge) -> Self::Node {\n+        self.body\n+            [edge.source]\n+            .terminator()\n+            .successors()\n+            .nth(edge.index)\n+            .copied()\n+            .unwrap()\n+    }\n+}\n+\n+struct BlockFormatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    prev_state: BitSet<A::Idx>,\n+    results: ResultsRefCursor<'a, 'a, 'tcx, A>,\n+    bg: Background,\n+}\n+\n+impl<A> BlockFormatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn toggle_background(&mut self) -> Background {\n+        let bg = self.bg;\n+        self.bg = !bg;\n+        bg\n+    }\n+\n+    fn write_node_label(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        body: &'a Body<'tcx>,\n+        block: BasicBlock,\n+    ) -> io::Result<()> {\n+        //   Sample output:\n+        //   +-+--------------------------------------------------+\n+        // A |                         bb4                        |\n+        //   +-+----------------------------------+---------------+\n+        // B |               MIR                  |     STATE     |\n+        //   +-+----------------------------------+---------------+\n+        // C | | (on entry)                       | {_0,_2,_3}    |\n+        //   +-+----------------------------------+---------------+\n+        // D |0|  0: StorageLive(_7)              |               |\n+        //   +-+----------------------------------+---------------+\n+        //   |1|  1: StorageLive(_8)              |               |\n+        //   +-+----------------------------------+---------------+\n+        //   |2|  2: _8 = &mut _1                 | +_8           |\n+        //   +-+----------------------------------+---------------+\n+        // E |T| _7 = const Foo::twiddle(move _8) | -_8           |\n+        //   +-+----------------------------------+---------------+\n+        // F | | (on unwind)                      | {_0,_2,_3,_7} |\n+        //   +-+----------------------------------+---------------+\n+        //   | | (on successful return)           | +_7           |\n+        //   +-+----------------------------------+---------------+\n+\n+        write!(\n+            w,\n+            r#\"<table border=\"1\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"3\" sides=\"rb\">\"#,\n+        )?;\n+\n+        // A: Block info\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td colspan=\"{num_headers}\" sides=\"tl\">bb{block_id}</td>\n+               </tr>\"#,\n+            num_headers = 3,\n+            block_id = block.index(),\n+        )?;\n+\n+        // B: Column headings\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td colspan=\"2\" {fmt}>MIR</td>\n+                 <td {fmt}>STATE</td>\n+               </tr>\"#,\n+            fmt = r##\"bgcolor=\"#a0a0a0\" sides=\"tl\"\"##,\n+        )?;\n+\n+        // C: Entry state\n+        self.results.seek_to_block_start(block);\n+        self.write_row_with_curr_state(w, \"\", \"(on entry)\")?;\n+        self.prev_state.overwrite(self.results.get());\n+\n+        // D: Statement transfer functions\n+        for (i, statement) in body[block].statements.iter().enumerate() {\n+            let location = Location { block, statement_index: i };\n+\n+            let mir_col = format!(\"{:?}\", statement);\n+            let i_col = i.to_string();\n+\n+            self.results.seek_after(location);\n+            self.write_row_with_curr_diff(w, &i_col, &mir_col)?;\n+            self.prev_state.overwrite(self.results.get());\n+        }\n+\n+        // E: Terminator transfer function\n+        let terminator = body[block].terminator();\n+        let location = body.terminator_loc(block);\n+\n+        let mut mir_col = String::new();\n+        terminator.kind.fmt_head(&mut mir_col).unwrap();\n+\n+        self.results.seek_after(location);\n+        self.write_row_with_curr_diff(w, \"T\", &mir_col)?;\n+        self.prev_state.overwrite(self.results.get());\n+\n+        // F: Exit state\n+        if let mir::TerminatorKind::Call { destination: Some(_), ..  } = &terminator.kind {\n+            self.write_row_with_curr_state(w, \"\", \"(on unwind)\")?;\n+\n+            self.results.seek_after_assume_call_returns(location);\n+            self.write_row_with_curr_diff(w, \"\", \"(on successful return)\")?;\n+        } else {\n+            self.write_row_with_curr_state(w, \"\", \"(on exit)\")?;\n+        }\n+\n+        write!(w, \"</table>\")\n+    }\n+\n+    fn write_row_with_curr_state(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+    ) -> io::Result<()> {\n+        let bg = self.toggle_background();\n+\n+        let mut out = Vec::new();\n+        write!(&mut out, \"{{\")?;\n+        pretty_print_state_elems(&mut out, self.results.analysis(), self.results.get().iter())?;\n+        write!(&mut out, \"}}\")?;\n+\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td {fmt} align=\"right\">{i}</td>\n+                 <td {fmt} align=\"left\">{mir}</td>\n+                 <td {fmt} align=\"left\">{state}</td>\n+               </tr>\"#,\n+            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n+            i = i,\n+            mir = dot::escape_html(mir),\n+            state = dot::escape_html(str::from_utf8(&out).unwrap()),\n+        )\n+    }\n+\n+    fn write_row_with_curr_diff(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+    ) -> io::Result<()> {\n+        let bg = self.toggle_background();\n+        let analysis = self.results.analysis();\n+\n+        let diff = BitSetDiff::compute(&self.prev_state, self.results.get());\n+\n+        let mut set = Vec::new();\n+        pretty_print_state_elems(&mut set, analysis, diff.set.iter())?;\n+\n+        let mut clear = Vec::new();\n+        pretty_print_state_elems(&mut clear, analysis, diff.clear.iter())?;\n+\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td {fmt} align=\"right\">{i}</td>\n+                 <td {fmt} align=\"left\">{mir}</td>\n+                 <td {fmt} align=\"left\">\"#,\n+            i = i,\n+            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n+            mir = dot::escape_html(mir),\n+        )?;\n+\n+        if !set.is_empty() {\n+            write!(\n+                w,\n+                r#\"<font color=\"darkgreen\">+{}</font>\"#,\n+                dot::escape_html(str::from_utf8(&set).unwrap()),\n+            )?;\n+        }\n+\n+        if !set.is_empty() && !clear.is_empty() {\n+            write!(w, \"  \")?;\n+        }\n+\n+        if !clear.is_empty() {\n+            write!(\n+                w,\n+                r#\"<font color=\"red\">-{}</font>\"#,\n+                dot::escape_html(str::from_utf8(&clear).unwrap()),\n+            )?;\n+        }\n+\n+        write!(w, \"</td></tr>\")\n+    }\n+}\n+\n+/// The operations required to transform one `BitSet` into another.\n+struct BitSetDiff<T: Idx> {\n+    set: HybridBitSet<T>,\n+    clear: HybridBitSet<T>,\n+}\n+\n+impl<T: Idx> BitSetDiff<T> {\n+    fn compute(from: &BitSet<T>, to: &BitSet<T>) -> Self {\n+        assert_eq!(from.domain_size(), to.domain_size());\n+        let len = from.domain_size();\n+\n+        let mut set = HybridBitSet::new_empty(len);\n+        let mut clear = HybridBitSet::new_empty(len);\n+\n+        // FIXME: This could be made faster if `BitSet::xor` were implemented.\n+        for i in (0..len).map(|i| T::new(i)) {\n+            match (from.contains(i), to.contains(i)) {\n+                (false, true) => set.insert(i),\n+                (true, false) => clear.insert(i),\n+                _ => continue,\n+            };\n+        }\n+\n+        BitSetDiff {\n+            set,\n+            clear,\n+        }\n+    }\n+}\n+\n+/// Formats each `elem` using the pretty printer provided by `analysis` into a comma-separated\n+/// list.\n+fn pretty_print_state_elems<A>(\n+    w: &mut impl io::Write,\n+    analysis: &A,\n+    elems: impl Iterator<Item = A::Idx>,\n+) -> io::Result<()>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    let mut first = true;\n+    for idx in elems {\n+        if first {\n+            first = false;\n+        } else {\n+            write!(w, \",\")?;\n+        }\n+\n+        analysis.pretty_print_idx(w, idx)?;\n+    }\n+\n+    Ok(())\n+}\n+\n+/// The background color used for zebra-striping the table.\n+#[derive(Clone, Copy)]\n+enum Background {\n+    Light,\n+    Dark,\n+}\n+\n+impl Background {\n+    fn attr(self) -> &'static str {\n+        match self {\n+            Self::Dark => \"bgcolor=\\\"#f0f0f0\\\"\",\n+            Self::Light => \"\",\n+        }\n+    }\n+}\n+\n+impl ops::Not for Background {\n+    type Output = Self;\n+\n+    fn not(self) -> Self {\n+        match self {\n+            Self::Light => Self::Dark,\n+            Self::Dark => Self::Light,\n+        }\n+    }\n+}"}, {"sha": "40007eb3c4a3ef71d4543c827a028b630ca8dcf8", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=686ad4da9ef71ae7df9d57a036e614b01fab8c59", "patch": "@@ -27,6 +27,9 @@ impl QualifSet {\n pub trait Qualif {\n     const IDX: usize;\n \n+    /// The name of the file used to debug the dataflow analysis that computes this qualif.\n+    const ANALYSIS_NAME: &'static str;\n+\n     /// Whether this `Qualif` is cleared when a local is moved from.\n     const IS_CLEARED_ON_MOVE: bool = false;\n \n@@ -207,6 +210,7 @@ pub struct HasMutInterior;\n \n impl Qualif for HasMutInterior {\n     const IDX: usize = 0;\n+    const ANALYSIS_NAME: &'static str = \"flow_has_mut_interior\";\n \n     fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n@@ -264,6 +268,7 @@ pub struct NeedsDrop;\n \n impl Qualif for NeedsDrop {\n     const IDX: usize = 1;\n+    const ANALYSIS_NAME: &'static str = \"flow_needs_drop\";\n     const IS_CLEARED_ON_MOVE: bool = true;\n \n     fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {"}, {"sha": "4fa4eba4c23b6ebca2ffdc5047ea95e4b0ba1e08", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=686ad4da9ef71ae7df9d57a036e614b01fab8c59", "patch": "@@ -208,7 +208,8 @@ where\n             _qualif: PhantomData,\n         };\n         let results =\n-            dataflow::Engine::new(item.body, dead_unwinds, analysis).iterate_to_fixpoint();\n+            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n+                .iterate_to_fixpoint();\n         let cursor = dataflow::ResultsCursor::new(item.body, results);\n \n         let mut qualifs_in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n@@ -308,7 +309,7 @@ where\n {\n     type Idx = Local;\n \n-    const NAME: &'static str = \"flow_sensitive_qualif\";\n+    const NAME: &'static str = Q::ANALYSIS_NAME;\n \n     fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n         body.local_decls.len()"}, {"sha": "3045239d7a7701ba9cdf5370961211085585d298", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ad4da9ef71ae7df9d57a036e614b01fab8c59/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=686ad4da9ef71ae7df9d57a036e614b01fab8c59", "patch": "@@ -467,8 +467,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         self.qualifs.needs_drop.visit_statement(statement, location);\n         self.qualifs.has_mut_interior.visit_statement(statement, location);\n-        debug!(\"needs_drop: {:?}\", self.qualifs.needs_drop.get());\n-        debug!(\"has_mut_interior: {:?}\", self.qualifs.has_mut_interior.get());\n \n         match statement.kind {\n             StatementKind::Assign(..) => {\n@@ -494,8 +492,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         self.qualifs.needs_drop.visit_terminator(terminator, location);\n         self.qualifs.has_mut_interior.visit_terminator(terminator, location);\n-        debug!(\"needs_drop: {:?}\", self.qualifs.needs_drop.get());\n-        debug!(\"has_mut_interior: {:?}\", self.qualifs.has_mut_interior.get());\n \n         self.super_terminator(terminator, location);\n     }"}]}