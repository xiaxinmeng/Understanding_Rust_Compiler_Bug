{"sha": "707494eca9527a47c84900ddcaac74b6006dc733", "node_id": "C_kwDOAAsO6NoAKDcwNzQ5NGVjYTk1MjdhNDdjODQ5MDBkZGNhYWM3NGI2MDA2ZGM3MzM", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-09-28T09:50:56Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-09-28T09:52:31Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "ff8a6ac9ac18aadcccac7f83400051672b169a84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff8a6ac9ac18aadcccac7f83400051672b169a84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/707494eca9527a47c84900ddcaac74b6006dc733", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmFS5d8ACgkQHKDfKvWd\naKW6ohAA28rmegGxg7ENRO8Oq63GJkHczEEGOZ8x1FKZk3gNd+7yysFZpILeXUOb\nD9UZ8+LXFiP7b0jxqDDha0Bm6y6tJeBhNcO1V2Eqo65r5tC6unErl9Suir9TQ35X\nD2qxVH/hPhewwMCAFIxMwF1+DclbOAkXUouXuxOSKdWJr+XPza/dwNnp2S2l9F3F\nc00CWS7HAD9i3/RVrmbo53pMosqQJjwGX3+YOIZ8Jjbz6sYPyi2toj6pGmUHYPu0\nzPo15vKNMz9AV283/rH/RgzBveTbnI26sRGuU7oHfln69DEVj/lvxKY+abmIxnzK\nxjAKtd4HYLRNkbI8pyclrCOjxetXAJnlelbDfXPKua5esKo89e6z2dM5gcaRyl3l\n4E1oS6Zu4rmNRMZxIgg6gpbwBzwnHBQR6892e48kxfxSG4pawOStACQEQ4Q3liSp\nG08zxLahhL0gOuixOD0ZIP/3hUYlk/LtPRSL7tLAgXAlpuvYmAhwKOBytOsK8yd3\nqgYSb0Ex73SrR+vCCTXcYEx3DFvf+2Z9vXfoBpnbz4i/72OFIcwNHk2ZEmndRHDM\ni6rQ5GRvIIdOrZ+9WHo3eLL080h21fawmQCikKBdRg7gKMJVx3Jx/T6qFw6hRaCw\nW0Z/JRNzZbUBHiUGj0O+Pvs7g5t+1hw01aSriQ+79TJqiQSCKq0=\n=6mtj\n-----END PGP SIGNATURE-----", "payload": "tree ff8a6ac9ac18aadcccac7f83400051672b169a84\nparent 067bfe3618f9c3e21723c5946e7302968b518d6e\nparent 0c8799da5aabf72aee26053075d2bd73ef9f7789\nauthor flip1995 <philipp.krones@embecosm.com> 1632822656 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1632822751 +0100\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/707494eca9527a47c84900ddcaac74b6006dc733", "html_url": "https://github.com/rust-lang/rust/commit/707494eca9527a47c84900ddcaac74b6006dc733", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/707494eca9527a47c84900ddcaac74b6006dc733/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "067bfe3618f9c3e21723c5946e7302968b518d6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/067bfe3618f9c3e21723c5946e7302968b518d6e", "html_url": "https://github.com/rust-lang/rust/commit/067bfe3618f9c3e21723c5946e7302968b518d6e"}, {"sha": "0c8799da5aabf72aee26053075d2bd73ef9f7789", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c8799da5aabf72aee26053075d2bd73ef9f7789", "html_url": "https://github.com/rust-lang/rust/commit/0c8799da5aabf72aee26053075d2bd73ef9f7789"}], "stats": {"total": 2887, "additions": 1979, "deletions": 908}, "files": [{"sha": "688473f2f9bfcee25d3d1f7484967cbcd1ec3154", "filename": ".cargo/config", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,9 +1,10 @@\n [alias]\n uitest = \"test --test compile-test\"\n-dev = \"run --target-dir clippy_dev/target --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n-lintcheck = \"run --target-dir lintcheck/target --package lintcheck --bin lintcheck --manifest-path lintcheck/Cargo.toml  -- \"\n+dev = \"run --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n+lintcheck = \"run --package lintcheck --bin lintcheck --manifest-path lintcheck/Cargo.toml  -- \"\n collect-metadata = \"test --test dogfood --features metadata-collector-lint -- run_metadata_collection_lint --ignored\"\n \n [build]\n # -Zbinary-dep-depinfo allows us to track which rlib files to use for compiling UI tests\n rustflags = [\"-Zunstable-options\", \"-Zbinary-dep-depinfo\"]\n+target-dir = \"target\""}, {"sha": "866303a1f9fd58d3a7e653237843ecc5dbd8db49", "filename": ".github/ISSUE_TEMPLATE/blank_issue.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -8,7 +8,7 @@ about: Create a blank issue.\n Additional labels can be added to this issue by including the following command\n (without the space after the @ symbol):\n \n-`@rustbot label +<label>`\n+@ rustbot label +<label>\n \n Common labels for this issue type are:\n * C-an-interesting-project"}, {"sha": "119a498fb99eb9fdee894f2d08b853701e5b60a0", "filename": ".github/ISSUE_TEMPLATE/bug_report.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -36,7 +36,7 @@ LLVM version: 10.0\n Additional labels can be added to this issue by including the following command\n (without the space after the @ symbol):\n \n-`@rustbot label +<label>`\n+@ rustbot label +<label>\n \n Common labels for this issue type are:\n * `I-suggestion-causes-error`"}, {"sha": "82158e02f085eacc65c248fb3e86e68a24f7aad7", "filename": ".github/ISSUE_TEMPLATE/false_positive.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -37,7 +37,7 @@ LLVM version: 10.0\n Additional labels can be added to this issue by including the following command\n (without the space after the @ symbol):\n \n-`@rustbot label +<label>`\n+@ rustbot label +<label>\n \n Common labels for this issue type are:\n * I-suggestion-causes-error"}, {"sha": "040c906a722b6b9e3cdea674d53216ed172184a4", "filename": "CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1050,7 +1050,7 @@ Released 2020-11-19\n   [#5913](https://github.com/rust-lang/rust-clippy/pull/5913)\n * Add example of false positive to [`ptr_arg`] docs.\n   [#5885](https://github.com/rust-lang/rust-clippy/pull/5885)\n-* [`box_vec`], [`vec_box`] and [`borrowed_box`]: add link to the documentation of `Box`\n+* [`box_vec`](https://rust-lang.github.io/rust-clippy/master/index.html#box_collection), [`vec_box`] and [`borrowed_box`]: add link to the documentation of `Box`\n   [#6023](https://github.com/rust-lang/rust-clippy/pull/6023)\n \n ## Rust 1.47\n@@ -2570,7 +2570,7 @@ Released 2018-09-13\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n [`borrowed_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrowed_box\n-[`box_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_vec\n+[`box_collection`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_collection\n [`boxed_local`]: https://rust-lang.github.io/rust-clippy/master/index.html#boxed_local\n [`branches_sharing_code`]: https://rust-lang.github.io/rust-clippy/master/index.html#branches_sharing_code\n [`builtin_type_shadow`]: https://rust-lang.github.io/rust-clippy/master/index.html#builtin_type_shadow\n@@ -2688,6 +2688,7 @@ Released 2018-09-13\n [`if_let_some_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_some_result\n [`if_not_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_not_else\n [`if_same_then_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_same_then_else\n+[`if_then_panic`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_then_panic\n [`if_then_some_else_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_then_some_else_none\n [`ifs_same_cond`]: https://rust-lang.github.io/rust-clippy/master/index.html#ifs_same_cond\n [`implicit_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_clone\n@@ -2722,6 +2723,7 @@ Released 2018-09-13\n [`iter_count`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_count\n [`iter_next_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_loop\n [`iter_next_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_slice\n+[`iter_not_returning_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_not_returning_iterator\n [`iter_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth\n [`iter_nth_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth_zero\n [`iter_skip_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_skip_next\n@@ -2905,6 +2907,7 @@ Released 2018-09-13\n [`reversed_empty_ranges`]: https://rust-lang.github.io/rust-clippy/master/index.html#reversed_empty_ranges\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n [`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n+[`same_name_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_name_method\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n [`self_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_assignment\n [`self_named_constructors`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_named_constructors"}, {"sha": "ba3ed3053ac743466be07b2fdf04c97911dcc0f1", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -8,7 +8,7 @@ license = \"MIT OR Apache-2.0\"\n keywords = [\"clippy\", \"lint\", \"plugin\"]\n categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n build = \"build.rs\"\n-edition = \"2018\"\n+edition = \"2021\"\n publish = false\n \n [[bin]]"}, {"sha": "822335fc65f13f1616203bb5b0a989efa80c5154", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -18,7 +18,7 @@ You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the\n | `clippy::style`       | code that should be written in a more idiomatic way                                 | **warn**      |\n | `clippy::complexity`  | code that does something simple but in a complex way                                | **warn**      |\n | `clippy::perf`        | code that can be written to run faster                                              | **warn**      |\n-| `clippy::pedantic`    | lints which are rather strict or might have false positives                         | allow         |\n+| `clippy::pedantic`    | lints which are rather strict or have occasional false positives                    | allow         |\n | `clippy::nursery`     | new lints that are still under development                                          | allow         |\n | `clippy::cargo`       | lints for the cargo manifest                                                        | allow         |\n "}, {"sha": "4a13a4524097601ffda40ce63349ca71fef9563e", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_dev\"\n version = \"0.0.1\"\n-edition = \"2018\"\n+edition = \"2021\"\n \n [dependencies]\n bytecount = \"0.6\""}, {"sha": "daf0fcc993bad320ff894014596fa13328ba0307", "filename": "clippy_dev/src/bless.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fbless.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,7 +1,6 @@\n //! `bless` updates the reference files in the repo with changed output files\n //! from the last test run.\n \n-use std::env;\n use std::ffi::OsStr;\n use std::fs;\n use std::lazy::SyncLazy;\n@@ -10,17 +9,9 @@ use walkdir::WalkDir;\n \n use crate::clippy_project_root;\n \n-// NOTE: this is duplicated with tests/cargo/mod.rs What to do?\n-pub static CARGO_TARGET_DIR: SyncLazy<PathBuf> = SyncLazy::new(|| match env::var_os(\"CARGO_TARGET_DIR\") {\n-    Some(v) => v.into(),\n-    None => env::current_dir().unwrap().join(\"target\"),\n-});\n-\n static CLIPPY_BUILD_TIME: SyncLazy<Option<std::time::SystemTime>> = SyncLazy::new(|| {\n-    let profile = env::var(\"PROFILE\").unwrap_or_else(|_| \"debug\".to_string());\n-    let mut path = PathBuf::from(&**CARGO_TARGET_DIR);\n-    path.push(profile);\n-    path.push(\"cargo-clippy\");\n+    let mut path = std::env::current_exe().unwrap();\n+    path.set_file_name(\"cargo-clippy\");\n     fs::metadata(path).ok()?.modified().ok()\n });\n \n@@ -94,10 +85,7 @@ fn updated_since_clippy_build(path: &Path) -> Option<bool> {\n }\n \n fn build_dir() -> PathBuf {\n-    let profile = env::var(\"PROFILE\").unwrap_or_else(|_| \"debug\".to_string());\n-    let mut path = PathBuf::new();\n-    path.push(CARGO_TARGET_DIR.clone());\n-    path.push(profile);\n-    path.push(\"test_build_base\");\n+    let mut path = std::env::current_exe().unwrap();\n+    path.set_file_name(\"test\");\n     path\n }"}, {"sha": "7900dc6d0414136a0ef27a74f787c7d97cd6fc05", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -6,7 +6,7 @@ repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n license = \"MIT OR Apache-2.0\"\n keywords = [\"clippy\", \"lint\", \"plugin\"]\n-edition = \"2018\"\n+edition = \"2021\"\n \n [dependencies]\n cargo_metadata = \"0.12\""}, {"sha": "15252ef96cd1d7fbaf5662eaf4615eafb54873c8", "filename": "clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -2,10 +2,9 @@ use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::{in_macro, is_automatically_derived, is_default_equivalent, remove_blocks};\n use rustc_hir::{\n     def::{DefKind, Res},\n-    Body, Expr, ExprKind, Impl, ImplItemKind, Item, ItemKind, Node, QPath,\n+    Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::TypeFoldable;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n \n@@ -68,6 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n             if let ItemKind::Impl(Impl {\n                 of_trait: Some(ref trait_ref),\n                 items: [child],\n+                self_ty,\n                 ..\n             }) = item.kind;\n             if let attrs = cx.tcx.hir().attrs(item.hir_id());\n@@ -80,9 +80,18 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n             if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n             if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n             if let Some(adt_def) = cx.tcx.type_of(item.def_id).ty_adt_def();\n+            if !attrs.iter().any(|attr| attr.doc_str().is_some());\n+            if let child_attrs = cx.tcx.hir().attrs(impl_item_hir);\n+            if !child_attrs.iter().any(|attr| attr.doc_str().is_some());\n             then {\n-                if cx.tcx.type_of(item.def_id).definitely_has_param_types_or_consts(cx.tcx) {\n-                    return;\n+                if let TyKind::Path(QPath::Resolved(_, p)) = self_ty.kind {\n+                    if let Some(PathSegment { args: Some(a), .. }) = p.segments.last() {\n+                        for arg in a.args {\n+                            if !matches!(arg, GenericArg::Lifetime(_)) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n                 let should_emit = match remove_blocks(func_expr).kind {\n                     ExprKind::Tup(fields) => fields.iter().all(|e| is_default_equivalent(cx, e)),"}, {"sha": "1167b26c8f15392727471040c614b556998fdd40", "filename": "clippy_lints/src/disallowed_method.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fdisallowed_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fdisallowed_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_method.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,33 +1,44 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::fn_def_id;\n \n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::{def::Res, def_id::DefId, Crate, Expr};\n+use rustc_hir::{def::Res, def_id::DefIdMap, Crate, Expr};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Symbol;\n+\n+use crate::utils::conf;\n \n declare_clippy_lint! {\n     /// ### What it does\n     /// Denies the configured methods and functions in clippy.toml\n     ///\n     /// ### Why is this bad?\n-    /// Some methods are undesirable in certain contexts,\n-    /// and it's beneficial to lint for them as needed.\n+    /// Some methods are undesirable in certain contexts, and it's beneficial to\n+    /// lint for them as needed.\n     ///\n     /// ### Example\n     /// An example clippy.toml configuration:\n     /// ```toml\n     /// # clippy.toml\n-    /// disallowed-methods = [\"std::vec::Vec::leak\", \"std::time::Instant::now\"]\n+    /// disallowed-methods = [\n+    ///     # Can use a string as the path of the disallowed method.\n+    ///     \"std::boxed::Box::new\",\n+    ///     # Can also use an inline table with a `path` key.\n+    ///     { path = \"std::time::Instant::now\" },\n+    ///     # When using an inline table, can add a `reason` for why the method\n+    ///     # is disallowed.\n+    ///     { path = \"std::vec::Vec::leak\", reason = \"no leaking memory\" },\n+    /// ]\n     /// ```\n     ///\n     /// ```rust,ignore\n     /// // Example code where clippy issues a warning\n     /// let xs = vec![1, 2, 3, 4];\n     /// xs.leak(); // Vec::leak is disallowed in the config.\n+    /// // The diagnostic contains the message \"no leaking memory\".\n     ///\n     /// let _now = Instant::now(); // Instant::now is disallowed in the config.\n+    ///\n+    /// let _box = Box::new(3); // Box::new is disallowed in the config.\n     /// ```\n     ///\n     /// Use instead:\n@@ -43,18 +54,15 @@ declare_clippy_lint! {\n \n #[derive(Clone, Debug)]\n pub struct DisallowedMethod {\n-    disallowed: FxHashSet<Vec<Symbol>>,\n-    def_ids: FxHashSet<(DefId, Vec<Symbol>)>,\n+    conf_disallowed: Vec<conf::DisallowedMethod>,\n+    disallowed: DefIdMap<Option<String>>,\n }\n \n impl DisallowedMethod {\n-    pub fn new(disallowed: &FxHashSet<String>) -> Self {\n+    pub fn new(conf_disallowed: Vec<conf::DisallowedMethod>) -> Self {\n         Self {\n-            disallowed: disallowed\n-                .iter()\n-                .map(|s| s.split(\"::\").map(|seg| Symbol::intern(seg)).collect::<Vec<_>>())\n-                .collect(),\n-            def_ids: FxHashSet::default(),\n+            conf_disallowed,\n+            disallowed: DefIdMap::default(),\n         }\n     }\n }\n@@ -63,32 +71,36 @@ impl_lint_pass!(DisallowedMethod => [DISALLOWED_METHOD]);\n \n impl<'tcx> LateLintPass<'tcx> for DisallowedMethod {\n     fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n-        for path in &self.disallowed {\n-            let segs = path.iter().map(ToString::to_string).collect::<Vec<_>>();\n-            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs.iter().map(String::as_str).collect::<Vec<_>>())\n-            {\n-                self.def_ids.insert((id, path.clone()));\n+        for conf in &self.conf_disallowed {\n+            let (path, reason) = match conf {\n+                conf::DisallowedMethod::Simple(path) => (path, None),\n+                conf::DisallowedMethod::WithReason { path, reason } => (\n+                    path,\n+                    reason.as_ref().map(|reason| format!(\"{} (from clippy.toml)\", reason)),\n+                ),\n+            };\n+            let segs: Vec<_> = path.split(\"::\").collect();\n+            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs) {\n+                self.disallowed.insert(id, reason);\n             }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(def_id) = fn_def_id(cx, expr) {\n-            if self.def_ids.iter().any(|(id, _)| def_id == *id) {\n-                let func_path = cx.get_def_path(def_id);\n-                let func_path_string = func_path\n-                    .into_iter()\n-                    .map(Symbol::to_ident_string)\n-                    .collect::<Vec<_>>()\n-                    .join(\"::\");\n-\n-                span_lint(\n-                    cx,\n-                    DISALLOWED_METHOD,\n-                    expr.span,\n-                    &format!(\"use of a disallowed method `{}`\", func_path_string),\n-                );\n+        let def_id = match fn_def_id(cx, expr) {\n+            Some(def_id) => def_id,\n+            None => return,\n+        };\n+        let reason = match self.disallowed.get(&def_id) {\n+            Some(reason) => reason,\n+            None => return,\n+        };\n+        let func_path = cx.tcx.def_path_str(def_id);\n+        let msg = format!(\"use of a disallowed method `{}`\", func_path);\n+        span_lint_and_then(cx, DISALLOWED_METHOD, expr.span, &msg, |diag| {\n+            if let Some(reason) = reason {\n+                diag.note(reason);\n             }\n-        }\n+        });\n     }\n }"}, {"sha": "6c861fb33a9787fa407b7b2d7cd536697a30b0bc", "filename": "clippy_lints/src/disallowed_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fdisallowed_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fdisallowed_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_type.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -48,7 +48,7 @@ impl DisallowedType {\n         Self {\n             disallowed: disallowed\n                 .iter()\n-                .map(|s| s.split(\"::\").map(|seg| Symbol::intern(seg)).collect::<Vec<_>>())\n+                .map(|s| s.split(\"::\").map(Symbol::intern).collect::<Vec<_>>())\n                 .collect(),\n             def_ids: FxHashSet::default(),\n             prim_tys: FxHashSet::default(),"}, {"sha": "090be73af3b7a9f073f6ced9cf7cb598d02f5c1b", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -91,8 +91,11 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n                     if trait_item.id.hir_id() == hir_id {\n                         // be sure we have `self` parameter in this function\n                         if let AssocItemKind::Fn { has_self: true } = trait_item.kind {\n-                            trait_self_ty =\n-                                Some(TraitRef::identity(cx.tcx, trait_item.id.def_id.to_def_id()).self_ty().skip_binder());\n+                            trait_self_ty = Some(\n+                                TraitRef::identity(cx.tcx, trait_item.id.def_id.to_def_id())\n+                                    .self_ty()\n+                                    .skip_binder(),\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "9df92cc5b640667faf06c1f63dcf3b3b634d7541", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 92, "deletions": 148, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,16 +1,16 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{implements_trait, type_is_unsafe_function};\n use clippy_utils::usage::UsedAfterExprVisitor;\n-use clippy_utils::{get_enclosing_loop_or_closure, higher};\n-use clippy_utils::{is_adjusted, iter_input_pats};\n+use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def_id, Expr, ExprKind, Param, PatKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, ClosureKind, Ty};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Expr, ExprKind, Param, PatKind, Unsafety};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::subst::Subst;\n+use rustc_middle::ty::{self, ClosureKind, Ty, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -52,12 +52,6 @@ declare_clippy_lint! {\n     /// ### Why is this bad?\n     /// It's unnecessary to create the closure.\n     ///\n-    /// ### Known problems\n-    /// [#3071](https://github.com/rust-lang/rust-clippy/issues/3071),\n-    /// [#3942](https://github.com/rust-lang/rust-clippy/issues/3942),\n-    /// [#4002](https://github.com/rust-lang/rust-clippy/issues/4002)\n-    ///\n-    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// Some('a').map(|s| s.to_uppercase());\n@@ -75,32 +69,16 @@ declare_lint_pass!(EtaReduction => [REDUNDANT_CLOSURE, REDUNDANT_CLOSURE_FOR_MET\n \n impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n-\n-        match expr.kind {\n-            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n-                for arg in args {\n-                    // skip `foo(macro!())`\n-                    if arg.span.ctxt() == expr.span.ctxt() {\n-                        check_closure(cx, arg);\n-                    }\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Closure(_, decl, eid, _, _) = expr.kind {\n-        let body = cx.tcx.hir().body(eid);\n-        let ex = &body.value;\n-\n-        if ex.span.ctxt() != expr.span.ctxt() {\n-            if decl.inputs.is_empty() {\n-                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, ex) {\n+        let body = match expr.kind {\n+            ExprKind::Closure(_, _, id, _, _) => cx.tcx.hir().body(id),\n+            _ => return,\n+        };\n+        if body.value.span.from_expansion() {\n+            if body.params.is_empty() {\n+                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, &body.value) {\n                     // replace `|| vec![]` with `Vec::new`\n                     span_lint_and_sugg(\n                         cx,\n@@ -117,33 +95,30 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n             return;\n         }\n \n-        if_chain!(\n-            if let ExprKind::Call(caller, args) = ex.kind;\n-\n-            if let ExprKind::Path(_) = caller.kind;\n-\n-            // Not the same number of arguments, there is no way the closure is the same as the function return;\n-            if args.len() == decl.inputs.len();\n-\n-            // Are the expression or the arguments type-adjusted? Then we need the closure\n-            if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n-\n-            let fn_ty = cx.typeck_results().expr_ty(caller);\n-\n-            if matches!(fn_ty.kind(), ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n-\n-            if !type_is_unsafe_function(cx, fn_ty);\n-\n-            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n+        let closure_ty = cx.typeck_results().expr_ty(expr);\n \n+        if_chain!(\n+            if let ExprKind::Call(callee, args) = body.value.kind;\n+            if let ExprKind::Path(_) = callee.kind;\n+            if check_inputs(cx, body.params, args);\n+            let callee_ty = cx.typeck_results().expr_ty_adjusted(callee);\n+            let call_ty = cx.typeck_results().type_dependent_def_id(body.value.hir_id)\n+                .map_or(callee_ty, |id| cx.tcx.type_of(id));\n+            if check_sig(cx, closure_ty, call_ty);\n+            let substs = cx.typeck_results().node_substs(callee.hir_id);\n+            // This fixes some false positives that I don't entirely understand\n+            if substs.is_empty() || !cx.typeck_results().expr_ty(expr).has_late_bound_regions();\n+            // A type param function ref like `T::f` is not 'static, however\n+            // it is if cast like `T::f as fn()`. This seems like a rustc bug.\n+            if !substs.types().any(|t| matches!(t.kind(), ty::Param(_)));\n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure\", |diag| {\n-                    if let Some(mut snippet) = snippet_opt(cx, caller.span) {\n+                    if let Some(mut snippet) = snippet_opt(cx, callee.span) {\n                         if_chain! {\n-                            if let ty::Closure(_, substs) = fn_ty.kind();\n+                            if let ty::Closure(_, substs) = callee_ty.peel_refs().kind();\n                             if let ClosureKind::FnMut = substs.as_closure().kind();\n-                            if UsedAfterExprVisitor::is_found(cx, caller)\n-                                || get_enclosing_loop_or_closure(cx.tcx, expr).is_some();\n+                            if get_enclosing_loop_or_closure(cx.tcx, expr).is_some()\n+                                || UsedAfterExprVisitor::is_found(cx, callee);\n \n                             then {\n                                 // Mutable closure is used after current expr; we cannot consume it.\n@@ -162,110 +137,79 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         );\n \n         if_chain!(\n-            if let ExprKind::MethodCall(path, _, args, _) = ex.kind;\n-\n-            // Not the same number of arguments, there is no way the closure is the same as the function return;\n-            if args.len() == decl.inputs.len();\n-\n-            // Are the expression or the arguments type-adjusted? Then we need the closure\n-            if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n-\n-            let method_def_id = cx.typeck_results().type_dependent_def_id(ex.hir_id).unwrap();\n-            if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n-\n-            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n-\n-            if let Some(name) = get_ufcs_type_name(cx, method_def_id, &args[0]);\n-\n+            if let ExprKind::MethodCall(path, _, args, _) = body.value.kind;\n+            if check_inputs(cx, body.params, args);\n+            let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n+            let substs = cx.typeck_results().node_substs(body.value.hir_id);\n+            let call_ty = cx.tcx.type_of(method_def_id).subst(cx.tcx, substs);\n+            if check_sig(cx, closure_ty, call_ty);\n             then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n-                    expr.span,\n-                    \"redundant closure\",\n-                    \"replace the closure with the method itself\",\n-                    format!(\"{}::{}\", name, path.ident.name),\n-                    Applicability::MachineApplicable,\n-                );\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE_FOR_METHOD_CALLS, expr.span, \"redundant closure\", |diag| {\n+                    let name = get_ufcs_type_name(cx, method_def_id);\n+                    diag.span_suggestion(\n+                        expr.span,\n+                        \"replace the closure with the method itself\",\n+                        format!(\"{}::{}\", name, path.ident.name),\n+                        Applicability::MachineApplicable,\n+                    );\n+                })\n             }\n         );\n     }\n }\n \n-/// Tries to determine the type for universal function call to be used instead of the closure\n-fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n-    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n-    let actual_type_of_self = &cx.typeck_results().node_type(self_arg.hir_id);\n-\n-    if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        if match_borrow_depth(expected_type_of_self, actual_type_of_self)\n-            && implements_trait(cx, actual_type_of_self, trait_id, &[])\n-        {\n-            return Some(cx.tcx.def_path_str(trait_id));\n-        }\n+fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_>]) -> bool {\n+    if params.len() != call_args.len() {\n+        return false;\n     }\n-\n-    cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n-        //a type may implicitly implement other type's methods (e.g. Deref)\n-        if match_types(expected_type_of_self, actual_type_of_self) {\n-            Some(get_type_name(cx, actual_type_of_self))\n-        } else {\n-            None\n+    std::iter::zip(params, call_args).all(|(param, arg)| {\n+        match param.pat.kind {\n+            PatKind::Binding(_, id, ..) if path_to_local_id(arg, id) => {},\n+            _ => return false,\n+        }\n+        match *cx.typeck_results().expr_adjustments(arg) {\n+            [] => true,\n+            [Adjustment {\n+                kind: Adjust::Deref(None),\n+                ..\n+            }, Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(_, mu2)),\n+                ..\n+            }] => {\n+                // re-borrow with the same mutability is allowed\n+                let ty = cx.typeck_results().expr_ty(arg);\n+                matches!(*ty.kind(), ty::Ref(.., mu1) if mu1 == mu2.into())\n+            },\n+            _ => false,\n         }\n     })\n }\n \n-fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind(), &rhs.kind()) {\n-        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(t1, t2),\n-        (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n-    }\n-}\n-\n-fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind(), &rhs.kind()) {\n-        (ty::Bool, ty::Bool)\n-        | (ty::Char, ty::Char)\n-        | (ty::Int(_), ty::Int(_))\n-        | (ty::Uint(_), ty::Uint(_))\n-        | (ty::Str, ty::Str) => true,\n-        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_types(t1, t2),\n-        (ty::Array(t1, _), ty::Array(t2, _)) | (ty::Slice(t1), ty::Slice(t2)) => match_types(t1, t2),\n-        (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n-        (_, _) => false,\n+fn check_sig<'tcx>(cx: &LateContext<'tcx>, closure_ty: Ty<'tcx>, call_ty: Ty<'tcx>) -> bool {\n+    let call_sig = call_ty.fn_sig(cx.tcx);\n+    if call_sig.unsafety() == Unsafety::Unsafe {\n+        return false;\n     }\n-}\n-\n-fn get_type_name(cx: &LateContext<'_>, ty: Ty<'_>) -> String {\n-    match ty.kind() {\n-        ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n-        ty::Ref(_, r, _) => get_type_name(cx, r),\n-        _ => ty.to_string(),\n+    if !closure_ty.has_late_bound_regions() {\n+        return true;\n     }\n+    let substs = match closure_ty.kind() {\n+        ty::Closure(_, substs) => substs,\n+        _ => return false,\n+    };\n+    let closure_sig = cx.tcx.signature_unclosure(substs.as_closure().sig(), Unsafety::Normal);\n+    cx.tcx.erase_late_bound_regions(closure_sig) == cx.tcx.erase_late_bound_regions(call_sig)\n }\n \n-fn compare_inputs(\n-    closure_inputs: &mut dyn Iterator<Item = &Param<'_>>,\n-    call_args: &mut dyn Iterator<Item = &Expr<'_>>,\n-) -> bool {\n-    for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n-        if let PatKind::Binding(_, _, ident, _) = closure_input.pat.kind {\n-            // XXXManishearth Should I be checking the binding mode here?\n-            if let ExprKind::Path(QPath::Resolved(None, p)) = function_arg.kind {\n-                if p.segments.len() != 1 {\n-                    // If it's a proper path, it can't be a local variable\n-                    return false;\n-                }\n-                if p.segments[0].ident.name != ident.name {\n-                    // The two idents should be the same\n-                    return false;\n-                }\n-            } else {\n-                return false;\n+fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: DefId) -> String {\n+    match cx.tcx.associated_item(method_def_id).container {\n+        ty::TraitContainer(def_id) => cx.tcx.def_path_str(def_id),\n+        ty::ImplContainer(def_id) => {\n+            let ty = cx.tcx.type_of(def_id);\n+            match ty.kind() {\n+                ty::Adt(adt, _) => cx.tcx.def_path_str(adt.did),\n+                _ => ty.to_string(),\n             }\n-        } else {\n-            return false;\n-        }\n+        },\n     }\n-    true\n }"}, {"sha": "1e8a5bd7d34453be68f0b322047f601ed1f789d6", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -111,7 +111,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n                             Applicability::MachineApplicable,\n                         );\n                     }\n-                } else if digits > max as usize && sym_str != float_str {\n+                } else if digits > max as usize && float_str.len() < sym_str.len() {\n                     span_lint_and_sugg(\n                         cx,\n                         EXCESSIVE_PRECISION,"}, {"sha": "508cac33848f76d0b081bbc5189c3882894c2fa3", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -69,8 +69,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n                     ty::Str => true,\n                     _ => false,\n                 };\n-                if format_args.args.iter().all(|e| is_display_arg(e));\n-                if format_args.fmt_expr.map_or(true, |e| check_unformatted(e));\n+                if format_args.args.iter().all(is_display_arg);\n+                if format_args.fmt_expr.map_or(true, check_unformatted);\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,"}, {"sha": "b4f186525c562ea4cd33c4dcdcf9bddd08ed1d92", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -286,34 +286,39 @@ fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n }\n \n fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n-    if !differing_macro_contexts(first.span, second.span)\n-        && !first.span.from_expansion()\n-        && is_if(first)\n-        && (is_block(second) || is_if(second))\n-    {\n-        // where the else would be\n-        let else_span = first.span.between(second.span);\n+    if_chain! {\n+        if !differing_macro_contexts(first.span, second.span);\n+        if !first.span.from_expansion();\n+        if let ExprKind::If(cond_expr, ..) = &first.kind;\n+        if is_block(second) || is_if(second);\n \n-        if let Some(else_snippet) = snippet_opt(cx, else_span) {\n-            if !else_snippet.contains('\\n') {\n-                let (looks_like, next_thing) = if is_if(second) {\n-                    (\"an `else if`\", \"the second `if`\")\n-                } else {\n-                    (\"an `else {..}`\", \"the next block\")\n-                };\n+        // Proc-macros can give weird spans. Make sure this is actually an `if`.\n+        if let Some(if_snip) = snippet_opt(cx, first.span.until(cond_expr.span));\n+        if if_snip.starts_with(\"if\");\n \n-                span_lint_and_note(\n-                    cx,\n-                    SUSPICIOUS_ELSE_FORMATTING,\n-                    else_span,\n-                    &format!(\"this looks like {} but the `else` is missing\", looks_like),\n-                    None,\n-                    &format!(\n-                        \"to remove this lint, add the missing `else` or add a new line before {}\",\n-                        next_thing,\n-                    ),\n-                );\n-            }\n+        // If there is a line break between the two expressions, don't lint.\n+        // If there is a non-whitespace character, this span came from a proc-macro.\n+        let else_span = first.span.between(second.span);\n+        if let Some(else_snippet) = snippet_opt(cx, else_span);\n+        if !else_snippet.chars().any(|c| c == '\\n' || !c.is_whitespace());\n+        then {\n+            let (looks_like, next_thing) = if is_if(second) {\n+                (\"an `else if`\", \"the second `if`\")\n+            } else {\n+                (\"an `else {..}`\", \"the next block\")\n+            };\n+\n+            span_lint_and_note(\n+                cx,\n+                SUSPICIOUS_ELSE_FORMATTING,\n+                else_span,\n+                &format!(\"this looks like {} but the `else` is missing\", looks_like),\n+                None,\n+                &format!(\n+                    \"to remove this lint, add the missing `else` or add a new line before {}\",\n+                    next_thing,\n+                ),\n+            );\n         }\n     }\n }"}, {"sha": "ee575c81a8b0b69061110b696db5fc9399c85de2", "filename": "clippy_lints/src/if_then_panic.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fif_then_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fif_then_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_panic.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,97 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::PanicExpn;\n+use clippy_utils::is_expn_of;\n+use clippy_utils::source::snippet_with_applicability;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Block, Expr, ExprKind, StmtKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects `if`-then-`panic!` that can be replaced with `assert!`.\n+    ///\n+    /// ### Why is this bad?\n+    /// `assert!` is simpler than `if`-then-`panic!`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let sad_people: Vec<&str> = vec![];\n+    /// if !sad_people.is_empty() {\n+    ///     panic!(\"there are sad people: {:?}\", sad_people);\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let sad_people: Vec<&str> = vec![];\n+    /// assert!(sad_people.is_empty(), \"there are sad people: {:?}\", sad_people);\n+    /// ```\n+    pub IF_THEN_PANIC,\n+    style,\n+    \"`panic!` and only a `panic!` in `if`-then statement\"\n+}\n+\n+declare_lint_pass!(IfThenPanic => [IF_THEN_PANIC]);\n+\n+impl LateLintPass<'_> for IfThenPanic {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if_chain! {\n+            if let Expr {\n+                kind: ExprKind:: If(cond, Expr {\n+                    kind: ExprKind::Block(\n+                        Block {\n+                            stmts: [stmt],\n+                            ..\n+                        },\n+                        _),\n+                    ..\n+                }, None),\n+                ..\n+            } = &expr;\n+            if is_expn_of(stmt.span, \"panic\").is_some();\n+            if !matches!(cond.kind, ExprKind::Let(_, _, _));\n+            if let StmtKind::Semi(semi) = stmt.kind;\n+            if !cx.tcx.sess.source_map().is_multiline(cond.span);\n+\n+            then {\n+                let span = if let Some(panic_expn) = PanicExpn::parse(semi) {\n+                    match *panic_expn.format_args.value_args {\n+                        [] => panic_expn.format_args.format_string_span,\n+                        [.., last] => panic_expn.format_args.format_string_span.to(last.span),\n+                    }\n+                } else {\n+                    if_chain! {\n+                        if let ExprKind::Block(block, _) = semi.kind;\n+                        if let Some(init) = block.expr;\n+                        if let ExprKind::Call(_, [format_args]) = init.kind;\n+\n+                        then {\n+                            format_args.span\n+                        } else {\n+                            return\n+                        }\n+                    }\n+                };\n+                let mut applicability = Applicability::MachineApplicable;\n+                let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+\n+                let cond_sugg =\n+                if let ExprKind::DropTemps(Expr{kind: ExprKind::Unary(UnOp::Not, not_expr), ..}) = cond.kind {\n+                    snippet_with_applicability(cx, not_expr.span, \"..\", &mut applicability).to_string()\n+                } else {\n+                    format!(\"!{}\", snippet_with_applicability(cx, cond.span, \"..\", &mut applicability))\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    IF_THEN_PANIC,\n+                    expr.span,\n+                    \"only a `panic!` in `if`-then statement\",\n+                    \"try\",\n+                    format!(\"assert!({}, {});\", cond_sugg, sugg),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "6c779348ca28a4f5e6484392c033350f31188747", "filename": "clippy_lints/src/iter_not_returning_iterator.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,64 @@\n+use clippy_utils::{diagnostics::span_lint, return_ty, ty::implements_trait};\n+use rustc_hir::{ImplItem, ImplItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::kw;\n+use rustc_span::symbol::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects methods named `iter` or `iter_mut` that do not have a return type that implements `Iterator`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Methods named `iter` or `iter_mut` conventionally return an `Iterator`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // `String` does not implement `Iterator`\n+    /// struct Data {}\n+    /// impl Data {\n+    ///     fn iter(&self) -> String {\n+    ///         todo!()\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::str::Chars;\n+    /// struct Data {}\n+    /// impl Data {\n+    ///    fn iter(&self) -> Chars<'static> {\n+    ///        todo!()\n+    ///    }\n+    /// }\n+    /// ```\n+    pub ITER_NOT_RETURNING_ITERATOR,\n+    pedantic,\n+    \"methods named `iter` or `iter_mut` that do not return an `Iterator`\"\n+}\n+\n+declare_lint_pass!(IterNotReturningIterator => [ITER_NOT_RETURNING_ITERATOR]);\n+\n+impl LateLintPass<'_> for IterNotReturningIterator {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'tcx>) {\n+        let name: &str = &impl_item.ident.name.as_str();\n+        if_chain! {\n+            if let ImplItemKind::Fn(fn_sig, _) = &impl_item.kind;\n+            let ret_ty = return_ty(cx, impl_item.hir_id());\n+            if matches!(name, \"iter\" | \"iter_mut\");\n+            if let [param] = cx.tcx.fn_arg_names(impl_item.def_id);\n+            if param.name == kw::SelfLower;\n+            if let Some(iter_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+            if !implements_trait(cx, ret_ty, iter_trait_id, &[]);\n+\n+            then {\n+                span_lint(\n+                    cx,\n+                    ITER_NOT_RETURNING_ITERATOR,\n+                    fn_sig.span,\n+                    &format!(\"this method is named `{}` but its return type does not implement `Iterator`\", name),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "792d4c7be53641de16c2482e1190959b81eef0fd", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -227,6 +227,7 @@ mod identity_op;\n mod if_let_mutex;\n mod if_let_some_result;\n mod if_not_else;\n+mod if_then_panic;\n mod if_then_some_else_none;\n mod implicit_hasher;\n mod implicit_return;\n@@ -241,6 +242,7 @@ mod int_plus_one;\n mod integer_division;\n mod invalid_upcast_comparisons;\n mod items_after_statements;\n+mod iter_not_returning_iterator;\n mod large_const_arrays;\n mod large_enum_variant;\n mod large_stack_arrays;\n@@ -330,6 +332,7 @@ mod reference;\n mod regex;\n mod repeat_once;\n mod returns;\n+mod same_name_method;\n mod self_assignment;\n mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n@@ -657,6 +660,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         if_let_mutex::IF_LET_MUTEX,\n         if_let_some_result::IF_LET_SOME_RESULT,\n         if_not_else::IF_NOT_ELSE,\n+        if_then_panic::IF_THEN_PANIC,\n         if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n         implicit_hasher::IMPLICIT_HASHER,\n         implicit_return::IMPLICIT_RETURN,\n@@ -674,6 +678,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         integer_division::INTEGER_DIVISION,\n         invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n+        iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR,\n         large_const_arrays::LARGE_CONST_ARRAYS,\n         large_enum_variant::LARGE_ENUM_VARIANT,\n         large_stack_arrays::LARGE_STACK_ARRAYS,\n@@ -908,6 +913,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         repeat_once::REPEAT_ONCE,\n         returns::LET_AND_RETURN,\n         returns::NEEDLESS_RETURN,\n+        same_name_method::SAME_NAME_METHOD,\n         self_assignment::SELF_ASSIGNMENT,\n         self_named_constructors::SELF_NAMED_CONSTRUCTORS,\n         semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED,\n@@ -952,7 +958,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         transmuting_null::TRANSMUTING_NULL,\n         try_err::TRY_ERR,\n         types::BORROWED_BOX,\n-        types::BOX_VEC,\n+        types::BOX_COLLECTION,\n         types::LINKEDLIST,\n         types::OPTION_OPTION,\n         types::RC_BUFFER,\n@@ -1051,6 +1057,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(panic_unimplemented::UNIMPLEMENTED),\n         LintId::of(panic_unimplemented::UNREACHABLE),\n         LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n+        LintId::of(same_name_method::SAME_NAME_METHOD),\n         LintId::of(shadow::SHADOW_REUSE),\n         LintId::of(shadow::SHADOW_SAME),\n         LintId::of(strings::STRING_ADD),\n@@ -1104,6 +1111,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(infinite_iter::MAYBE_INFINITE_ITER),\n         LintId::of(invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n         LintId::of(items_after_statements::ITEMS_AFTER_STATEMENTS),\n+        LintId::of(iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR),\n         LintId::of(large_stack_arrays::LARGE_STACK_ARRAYS),\n         LintId::of(let_underscore::LET_UNDERSCORE_DROP),\n         LintId::of(literal_representation::LARGE_DIGIT_GROUPS),\n@@ -1126,6 +1134,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::INEFFICIENT_TO_STRING),\n         LintId::of(methods::MAP_FLATTEN),\n         LintId::of(methods::MAP_UNWRAP_OR),\n+        LintId::of(misc::FLOAT_CMP),\n         LintId::of(misc::USED_UNDERSCORE_BINDING),\n         LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n         LintId::of(mut_mut::MUT_MUT),\n@@ -1134,6 +1143,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(needless_continue::NEEDLESS_CONTINUE),\n         LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n         LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n+        LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n         LintId::of(non_expressive_names::SIMILAR_NAMES),\n         LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n         LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n@@ -1250,6 +1260,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(identity_op::IDENTITY_OP),\n         LintId::of(if_let_mutex::IF_LET_MUTEX),\n         LintId::of(if_let_some_result::IF_LET_SOME_RESULT),\n+        LintId::of(if_then_panic::IF_THEN_PANIC),\n         LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n         LintId::of(infinite_iter::INFINITE_ITER),\n         LintId::of(inherent_to_string::INHERENT_TO_STRING),\n@@ -1358,7 +1369,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(minmax::MIN_MAX),\n         LintId::of(misc::CMP_NAN),\n         LintId::of(misc::CMP_OWNED),\n-        LintId::of(misc::FLOAT_CMP),\n         LintId::of(misc::MODULO_ONE),\n         LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n         LintId::of(misc::TOPLEVEL_REF_ARG),\n@@ -1390,7 +1400,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n         LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n         LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n-        LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n         LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n         LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n         LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n@@ -1448,7 +1457,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(transmuting_null::TRANSMUTING_NULL),\n         LintId::of(try_err::TRY_ERR),\n         LintId::of(types::BORROWED_BOX),\n-        LintId::of(types::BOX_VEC),\n+        LintId::of(types::BOX_COLLECTION),\n         LintId::of(types::REDUNDANT_ALLOCATION),\n         LintId::of(types::TYPE_COMPLEXITY),\n         LintId::of(types::VEC_BOX),\n@@ -1505,6 +1514,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(functions::MUST_USE_UNIT),\n         LintId::of(functions::RESULT_UNIT_ERR),\n         LintId::of(if_let_some_result::IF_LET_SOME_RESULT),\n+        LintId::of(if_then_panic::IF_THEN_PANIC),\n         LintId::of(inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(len_zero::COMPARISON_TO_EMPTY),\n         LintId::of(len_zero::LEN_WITHOUT_IS_EMPTY),\n@@ -1564,7 +1574,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n         LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n         LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n-        LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n         LintId::of(ptr::CMP_NULL),\n         LintId::of(ptr::PTR_ARG),\n         LintId::of(ptr_eq::PTR_EQ),\n@@ -1724,7 +1733,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::ZST_OFFSET),\n         LintId::of(minmax::MIN_MAX),\n         LintId::of(misc::CMP_NAN),\n-        LintId::of(misc::FLOAT_CMP),\n         LintId::of(misc::MODULO_ONE),\n         LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n         LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n@@ -1787,7 +1795,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(redundant_clone::REDUNDANT_CLONE),\n         LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n         LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n-        LintId::of(types::BOX_VEC),\n+        LintId::of(types::BOX_COLLECTION),\n         LintId::of(types::REDUNDANT_ALLOCATION),\n         LintId::of(vec::USELESS_VEC),\n         LintId::of(vec_init_then_push::VEC_INIT_THEN_PUSH),\n@@ -1920,6 +1928,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(unnested_or_patterns::UnnestedOrPatterns::new(msrv)));\n \n     store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n+    store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n     store.register_late_pass(|| Box::new(map_clone::MapClone));\n     store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n     store.register_late_pass(|| Box::new(shadow::Shadow));\n@@ -2105,8 +2114,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(float_equality_without_abs::FloatEqualityWithoutAbs));\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));\n-    let disallowed_methods = conf.disallowed_methods.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || Box::new(disallowed_method::DisallowedMethod::new(&disallowed_methods)));\n+    let disallowed_methods = conf.disallowed_methods.clone();\n+    store.register_late_pass(move || Box::new(disallowed_method::DisallowedMethod::new(disallowed_methods.clone())));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86AttSyntax));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86IntelSyntax));\n     store.register_late_pass(|| Box::new(undropped_manually_drops::UndroppedManuallyDrops));\n@@ -2131,6 +2140,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n     store.register_late_pass(move || Box::new(self_named_constructors::SelfNamedConstructors));\n     store.register_late_pass(move || Box::new(feature_name::FeatureName));\n+    store.register_late_pass(move || Box::new(iter_not_returning_iterator::IterNotReturningIterator));\n+    store.register_late_pass(move || Box::new(if_then_panic::IfThenPanic));\n }\n \n #[rustfmt::skip]\n@@ -2186,6 +2197,7 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::cyclomatic_complexity\", \"clippy::cognitive_complexity\");\n     ls.register_renamed(\"clippy::const_static_lifetime\", \"clippy::redundant_static_lifetimes\");\n     ls.register_renamed(\"clippy::option_and_then_some\", \"clippy::bind_instead_of_map\");\n+    ls.register_renamed(\"clippy::box_vec\", \"clippy::box_collection\");\n     ls.register_renamed(\"clippy::block_in_if_condition_expr\", \"clippy::blocks_in_if_conditions\");\n     ls.register_renamed(\"clippy::block_in_if_condition_stmt\", \"clippy::blocks_in_if_conditions\");\n     ls.register_renamed(\"clippy::option_map_unwrap_or\", \"clippy::map_unwrap_or\");"}, {"sha": "dd60e460d21fe3b9cfbac874120caa134f9f1c03", "filename": "clippy_lints/src/loops/for_kv_map.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -10,12 +10,7 @@ use rustc_middle::ty;\n use rustc_span::sym;\n \n /// Checks for the `FOR_KV_MAP` lint.\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    arg: &'tcx Expr<'_>,\n-    body: &'tcx Expr<'_>,\n-) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, arg: &'tcx Expr<'_>, body: &'tcx Expr<'_>) {\n     let pat_span = pat.span;\n \n     if let PatKind::Tuple(pat, _) = pat.kind {"}, {"sha": "df848e68802c552292a9147397fa313468d6d5de", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -204,11 +204,8 @@ struct MinifyingSugg<'a>(Sugg<'a>);\n \n impl<'a> MinifyingSugg<'a> {\n     fn as_str(&self) -> &str {\n-        // HACK: Don't sync to Clippy! Required because something with the `or_patterns` feature\n-        // changed and this would now require parentheses.\n-        match &self.0 {\n-            Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) => s.as_ref(),\n-        }\n+        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n+        s.as_ref()\n     }\n \n     fn into_sugg(self) -> Sugg<'a> {"}, {"sha": "4dcd5c87722eec0f8c9e43f0e4f9fa6a4efc0cc5", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -65,7 +65,7 @@ fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n+        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, is_simple_break_expr),\n         _ => false,\n     }\n }"}, {"sha": "b390476a664d9e54f4c4490df4763204cc9c3265", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -8,7 +8,7 @@ use clippy_utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{symbol::sym, Span, Symbol};\n \n@@ -47,13 +47,8 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     // If the iterator is a field or the iterator is accessed after the loop is complete it needs to be\n     // borrowed mutably. TODO: If the struct can be partially moved from and the struct isn't used\n     // afterwards a mutable borrow of a field isn't necessary.\n-    let ref_mut = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n-        if cx.typeck_results().node_type(iter_expr.hir_id).ref_mutability() == Some(Mutability::Mut) {\n-            // Reborrow for mutable references. It may not be possible to get a mutable reference here.\n-            \"&mut *\"\n-        } else {\n-            \"&mut \"\n-        }\n+    let by_ref = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n+        \".by_ref()\"\n     } else {\n         \"\"\n     };\n@@ -65,7 +60,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         expr.span.with_hi(scrutinee_expr.span.hi()),\n         \"this loop could be written as a `for` loop\",\n         \"try\",\n-        format!(\"for {} in {}{}\", loop_var, ref_mut, iterator),\n+        format!(\"for {} in {}{}\", loop_var, iterator, by_ref),\n         applicability,\n     );\n }\n@@ -74,8 +69,6 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n struct IterExpr {\n     /// The span of the whole expression, not just the path and fields stored here.\n     span: Span,\n-    /// The HIR id of the whole expression, not just the path and fields stored here.\n-    hir_id: HirId,\n     /// The fields used, in order of child to parent.\n     fields: Vec<Symbol>,\n     /// The path being used.\n@@ -86,14 +79,12 @@ struct IterExpr {\n /// the expression might have side effects.\n fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n     let span = e.span;\n-    let hir_id = e.hir_id;\n     let mut fields = Vec::new();\n     loop {\n         match e.kind {\n             ExprKind::Path(ref path) => {\n                 break Some(IterExpr {\n                     span,\n-                    hir_id,\n                     fields,\n                     path: cx.qpath_res(path, e.hir_id),\n                 });"}, {"sha": "0e682c5cded80a338065b66dd92a26507f56b104", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -35,7 +35,8 @@ struct PathAndSpan {\n     span: Span,\n }\n \n-/// `MacroRefData` includes the name of the macro.\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n pub struct MacroRefData {\n     name: String,\n@@ -63,29 +64,24 @@ impl MacroUseImports {\n     fn push_unique_macro(&mut self, cx: &LateContext<'_>, span: Span) {\n         let call_site = span.source_callsite();\n         let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-        if let Some(_callee) = span.source_callee() {\n-            if !self.collected.contains(&call_site) {\n-                let name = if name.contains(\"::\") {\n-                    name.split(\"::\").last().unwrap().to_string()\n-                } else {\n-                    name.to_string()\n-                };\n+        if span.source_callee().is_some() && !self.collected.contains(&call_site) {\n+            let name = if name.contains(\"::\") {\n+                name.split(\"::\").last().unwrap().to_string()\n+            } else {\n+                name.to_string()\n+            };\n \n-                self.mac_refs.push(MacroRefData::new(name));\n-                self.collected.insert(call_site);\n-            }\n+            self.mac_refs.push(MacroRefData::new(name));\n+            self.collected.insert(call_site);\n         }\n     }\n \n     fn push_unique_macro_pat_ty(&mut self, cx: &LateContext<'_>, span: Span) {\n         let call_site = span.source_callsite();\n         let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n-        if let Some(_callee) = span.source_callee() {\n-            if !self.collected.contains(&call_site) {\n-                self.mac_refs\n-                    .push(MacroRefData::new(name.to_string()));\n-                self.collected.insert(call_site);\n-            }\n+        if span.source_callee().is_some() && !self.collected.contains(&call_site) {\n+            self.mac_refs.push(MacroRefData::new(name.to_string()));\n+            self.collected.insert(call_site);\n         }\n     }\n }"}, {"sha": "d878fbc35fdc27cf6360cfc8f8cafee72522e469", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -183,8 +183,8 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let x = 5;\n     /// match x {\n-    ///     1...10 => println!(\"1 ... 10\"),\n-    ///     5...15 => println!(\"5 ... 15\"),\n+    ///     1..=10 => println!(\"1 ... 10\"),\n+    ///     5..=15 => println!(\"5 ... 15\"),\n     ///     _ => (),\n     /// }\n     /// ```"}, {"sha": "55688677e1d141d423d39ef222c1a0a964d006b8", "filename": "clippy_lints/src/methods/manual_split_once.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -17,32 +17,25 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n     }\n \n     let ctxt = expr.span.ctxt();\n-    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id)) {\n+    let (method_name, msg, reverse) = if method_name == \"splitn\" {\n+        (\"split_once\", \"manual implementation of `split_once`\", false)\n+    } else {\n+        (\"rsplit_once\", \"manual implementation of `rsplit_once`\", true)\n+    };\n+    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), reverse) {\n         Some(x) => x,\n         None => return,\n     };\n-    let (method_name, msg) = if method_name == \"splitn\" {\n-        (\"split_once\", \"manual implementation of `split_once`\")\n-    } else {\n-        (\"rsplit_once\", \"manual implementation of `rsplit_once`\")\n-    };\n \n     let mut app = Applicability::MachineApplicable;\n     let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n     let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n \n-    match usage.kind {\n+    let sugg = match usage.kind {\n         IterUsageKind::NextTuple => {\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_SPLIT_ONCE,\n-                usage.span,\n-                msg,\n-                \"try this\",\n-                format!(\"{}.{}({})\", self_snip, method_name, pat_snip),\n-                app,\n-            );\n+            format!(\"{}.{}({})\", self_snip, method_name, pat_snip)\n         },\n+        IterUsageKind::RNextTuple => format!(\"{}.{}({}).map(|(x, y)| (y, x))\", self_snip, method_name, pat_snip),\n         IterUsageKind::Next => {\n             let self_deref = {\n                 let adjust = cx.typeck_results().expr_adjustments(self_arg);\n@@ -58,7 +51,7 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n                     \"*\".repeat(adjust.len() - 2)\n                 }\n             };\n-            let sugg = if usage.unwrap_kind.is_some() {\n+            if usage.unwrap_kind.is_some() {\n                 format!(\n                     \"{}.{}({}).map_or({}{}, |x| x.0)\",\n                     &self_snip, method_name, pat_snip, self_deref, &self_snip\n@@ -68,33 +61,26 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n                     \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n                     &self_snip, method_name, pat_snip, self_deref, &self_snip\n                 )\n-            };\n-\n-            span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n+            }\n         },\n         IterUsageKind::Second => {\n             let access_str = match usage.unwrap_kind {\n                 Some(UnwrapKind::Unwrap) => \".unwrap().1\",\n                 Some(UnwrapKind::QuestionMark) => \"?.1\",\n                 None => \".map(|x| x.1)\",\n             };\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_SPLIT_ONCE,\n-                usage.span,\n-                msg,\n-                \"try this\",\n-                format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str),\n-                app,\n-            );\n+            format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str)\n         },\n-    }\n+    };\n+\n+    span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n }\n \n enum IterUsageKind {\n     Next,\n     Second,\n     NextTuple,\n+    RNextTuple,\n }\n \n enum UnwrapKind {\n@@ -108,10 +94,12 @@ struct IterUsage {\n     span: Span,\n }\n \n+#[allow(clippy::too_many_lines)]\n fn parse_iter_usage(\n     cx: &LateContext<'tcx>,\n     ctxt: SyntaxContext,\n     mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n+    reverse: bool,\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n@@ -124,20 +112,30 @@ fn parse_iter_usage(\n             let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n \n             match (&*name.ident.as_str(), args) {\n-                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Next, e.span),\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n+                    if reverse {\n+                        (IterUsageKind::Second, e.span)\n+                    } else {\n+                        (IterUsageKind::Next, e.span)\n+                    }\n+                },\n                 (\"next_tuple\", []) => {\n-                    if_chain! {\n+                    return if_chain! {\n                         if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n                         if let ty::Adt(adt_def, subs) = cx.typeck_results().expr_ty(e).kind();\n                         if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did);\n                         if let ty::Tuple(subs) = subs.type_at(0).kind();\n                         if subs.len() == 2;\n                         then {\n-                            return Some(IterUsage { kind: IterUsageKind::NextTuple, span: e.span, unwrap_kind: None });\n+                            Some(IterUsage {\n+                                kind: if reverse { IterUsageKind::RNextTuple } else { IterUsageKind::NextTuple },\n+                                span: e.span,\n+                                unwrap_kind: None\n+                            })\n                         } else {\n-                            return None;\n+                            None\n                         }\n-                    }\n+                    };\n                 },\n                 (\"nth\" | \"skip\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n                     if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n@@ -158,7 +156,7 @@ fn parse_iter_usage(\n                                 }\n                             }\n                         };\n-                        match idx {\n+                        match if reverse { idx ^ 1 } else { idx } {\n                             0 => (IterUsageKind::Next, span),\n                             1 => (IterUsageKind::Second, span),\n                             _ => return None,"}, {"sha": "2025056ac94c3365a398dfb22987be6513a47791", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -264,6 +264,8 @@ declare_clippy_lint! {\n     /// The method signature is controlled by the trait and often `&self` is required for all types that implement the trait\n     /// (see e.g. the `std::string::ToString` trait).\n     ///\n+    /// Clippy allows `Pin<&Self>` and `Pin<&mut Self>` if `&self` and `&mut self` is required.\n+    ///\n     /// Please find more info here:\n     /// https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n     ///"}, {"sha": "0f32cd9164e2d7ecf874923a3a5d7a299b19365a", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -113,7 +113,7 @@ declare_clippy_lint! {\n     /// if (y - x).abs() > error_margin { }\n     /// ```\n     pub FLOAT_CMP,\n-    correctness,\n+    pedantic,\n     \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n }\n "}, {"sha": "55d2e29e8bc1e89886496ca2177db3e4d9f0587f", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -7,7 +7,8 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -55,6 +56,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.kind;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.name == sym::include\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n@@ -80,7 +95,7 @@ impl MissingDoc {\n \n         let has_doc = attrs\n             .iter()\n-            .any(|a| a.doc_str().is_some());\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "cb17e4dbfd0da8cdcf3930b9b32b4e88e5174a78", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 61, "deletions": 20, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::trait_ref_of_method;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::TypeFoldable;\n-use rustc_middle::ty::{Adt, Array, RawPtr, Ref, Slice, Tuple, Ty, TypeAndMut};\n+use rustc_middle::ty::{Adt, Array, Ref, Slice, Tuple, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n@@ -19,10 +19,29 @@ declare_clippy_lint! {\n     /// so having types with interior mutability is a bad idea.\n     ///\n     /// ### Known problems\n-    /// It's correct to use a struct, that contains interior mutability\n-    /// as a key, when its `Hash` implementation doesn't access any of the interior mutable types.\n-    /// However, this lint is unable to recognize this, so it causes a false positive in theses cases.\n-    /// The `bytes` crate is a great example of this.\n+    ///\n+    /// #### False Positives\n+    /// It's correct to use a struct that contains interior mutability as a key, when its\n+    /// implementation of `Hash` or `Ord` doesn't access any of the interior mutable types.\n+    /// However, this lint is unable to recognize this, so it will often cause false positives in\n+    /// theses cases.  The `bytes` crate is a great example of this.\n+    ///\n+    /// #### False Negatives\n+    /// For custom `struct`s/`enum`s, this lint is unable to check for interior mutability behind\n+    /// indirection.  For example, `struct BadKey<'a>(&'a Cell<usize>)` will be seen as immutable\n+    /// and cause a false negative if its implementation of `Hash`/`Ord` accesses the `Cell`.\n+    ///\n+    /// This lint does check a few cases for indirection.  Firstly, using some standard library\n+    /// types (`Option`, `Result`, `Box`, `Rc`, `Arc`, `Vec`, `VecDeque`, `BTreeMap` and\n+    /// `BTreeSet`) directly as keys (e.g. in `HashMap<Box<Cell<usize>>, ()>`) **will** trigger the\n+    /// lint, because the impls of `Hash`/`Ord` for these types directly call `Hash`/`Ord` on their\n+    /// contained type.\n+    ///\n+    /// Secondly, the implementations of `Hash` and `Ord` for raw pointers (`*const T` or `*mut T`)\n+    /// apply only to the **address** of the contained value.  Therefore, interior mutability\n+    /// behind raw pointers (e.g. in `HashSet<*mut Cell<usize>>`) can't impact the value of `Hash`\n+    /// or `Ord`, and therefore will not trigger this link.  For more info, see issue\n+    /// [#6745](https://github.com/rust-lang/rust-clippy/issues/6745).\n     ///\n     /// ### Example\n     /// ```rust\n@@ -103,30 +122,52 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n     let ty = ty.peel_refs();\n     if let Adt(def, substs) = ty.kind() {\n-        if [sym::hashmap_type, sym::BTreeMap, sym::hashset_type, sym::BTreeMap]\n+        let is_keyed_type = [sym::hashmap_type, sym::BTreeMap, sym::hashset_type, sym::BTreeSet]\n             .iter()\n-            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did))\n-            && is_mutable_type(cx, substs.type_at(0), span)\n-        {\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did));\n+        if is_keyed_type && is_interior_mutable_type(cx, substs.type_at(0), span) {\n             span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n         }\n     }\n }\n \n-fn is_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n+/// Determines if a type contains interior mutability which would affect its implementation of\n+/// [`Hash`] or [`Ord`].\n+fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n     match *ty.kind() {\n-        RawPtr(TypeAndMut { ty: inner_ty, mutbl }) | Ref(_, inner_ty, mutbl) => {\n-            mutbl == hir::Mutability::Mut || is_mutable_type(cx, inner_ty, span)\n-        },\n-        Slice(inner_ty) => is_mutable_type(cx, inner_ty, span),\n+        Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span),\n+        Slice(inner_ty) => is_interior_mutable_type(cx, inner_ty, span),\n         Array(inner_ty, size) => {\n-            size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0) && is_mutable_type(cx, inner_ty, span)\n+            size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n+                && is_interior_mutable_type(cx, inner_ty, span)\n         },\n-        Tuple(..) => ty.tuple_fields().any(|ty| is_mutable_type(cx, ty, span)),\n-        Adt(..) => {\n-            !ty.has_escaping_bound_vars()\n-                && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+        Tuple(..) => ty.tuple_fields().any(|ty| is_interior_mutable_type(cx, ty, span)),\n+        Adt(def, substs) => {\n+            // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n+            // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n+            // because they have no impl for `Hash` or `Ord`.\n+            let is_std_collection = [\n+                sym::option_type,\n+                sym::result_type,\n+                sym::LinkedList,\n+                sym::vec_type,\n+                sym::vecdeque_type,\n+                sym::BTreeMap,\n+                sym::BTreeSet,\n+                sym::Rc,\n+                sym::Arc,\n+            ]\n+            .iter()\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did));\n+            let is_box = Some(def.did) == cx.tcx.lang_items().owned_box();\n+            if is_std_collection || is_box {\n+                // The type is mutable if any of its type parameters are\n+                substs.types().any(|ty| is_interior_mutable_type(cx, ty, span))\n+            } else {\n+                !ty.has_escaping_bound_vars()\n+                    && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n+                    && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+            }\n         },\n         _ => false,\n     }"}, {"sha": "ee50891cc3103b6903537bbcaf6bbe1ecb304b78", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -87,10 +87,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "1b2495d764d2a0c650f9f866a153252fa5288b5a", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = e.kind {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, mutability, inner) = e.kind {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(inner).kind() {\n                 for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n@@ -116,14 +116,20 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n                         ..\n                     }] = *adj3\n                     {\n+                        let help_msg_ty = if matches!(mutability, Mutability::Not) {\n+                            format!(\"&{}\", ty)\n+                        } else {\n+                            format!(\"&mut {}\", ty)\n+                        };\n+\n                         span_lint_and_then(\n                             cx,\n                             NEEDLESS_BORROW,\n                             e.span,\n                             &format!(\n-                                \"this expression borrows a reference (`&{}`) that is immediately dereferenced \\\n+                                \"this expression borrows a reference (`{}`) that is immediately dereferenced \\\n                              by the compiler\",\n-                                ty\n+                                help_msg_ty\n                             ),\n                             |diag| {\n                                 if let Some(snippet) = snippet_opt(cx, inner.span) {"}, {"sha": "5b254bc8133d2fecce4c6227b90d7c91e2206b6c", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -43,7 +43,7 @@ declare_clippy_lint! {\n     /// let (a, b, c, d, e, f, g) = (...);\n     /// ```\n     pub MANY_SINGLE_CHAR_NAMES,\n-    style,\n+    pedantic,\n     \"too many single character bindings\"\n }\n "}, {"sha": "d696e17d656d49fd2427762e37657ac864ea373e", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -372,7 +372,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n             for (_, ref mutbl, ref argspan) in decl\n                 .inputs\n                 .iter()\n-                .filter_map(|ty| get_rptr_lm(ty))\n+                .filter_map(get_rptr_lm)\n                 .filter(|&(lt, _, _)| lt.name == out.name)\n             {\n                 if *mutbl == Mutability::Mut {"}, {"sha": "87364a88ed0dcc8267c6e955c64e83874ab38aaf", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -337,7 +337,7 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n         if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n-        if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n         then {\n             span_lint(cx,\n                 RANGE_ZIP_WITH_LEN,"}, {"sha": "ae85b7087e7b5add94b7cea8939f20f304f82377", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n \n@@ -199,7 +200,9 @@ fn check_final_expr<'tcx>(\n                 check_block_return(cx, ifblock);\n             }\n             if let Some(else_clause) = else_clause_opt {\n-                check_final_expr(cx, else_clause, None, RetReplacement::Empty);\n+                if expr.span.desugaring_kind() != Some(DesugaringKind::LetElse) {\n+                    check_final_expr(cx, else_clause, None, RetReplacement::Empty);\n+                }\n             }\n         },\n         // a match expr, check all arms"}, {"sha": "014898e6dab11ce533cd4d84db40c3d795e460f3", "filename": "clippy_lints/src/same_name_method.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,160 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::{Crate, Impl, ItemKind, Node, Path, QPath, TraitRef, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::AssocKind;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+use std::collections::{BTreeMap, BTreeSet};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It lints if a struct has two method with same time:\n+    /// one from a trait, another not from trait.\n+    ///\n+    /// ### Why is this bad?\n+    /// Confusing.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// trait T {\n+    ///     fn foo(&self) {}\n+    /// }\n+    ///\n+    /// struct S;\n+    ///\n+    /// impl T for S {\n+    ///     fn foo(&self) {}\n+    /// }\n+    ///\n+    /// impl S {\n+    ///     fn foo(&self) {}\n+    /// }\n+    /// ```\n+    pub SAME_NAME_METHOD,\n+    restriction,\n+    \"two method with same name\"\n+}\n+\n+declare_lint_pass!(SameNameMethod => [SAME_NAME_METHOD]);\n+\n+struct ExistingName {\n+    impl_methods: BTreeMap<Symbol, Span>,\n+    trait_methods: BTreeMap<Symbol, Vec<Span>>,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>, krate: &'tcx Crate<'tcx>) {\n+        let mut map = FxHashMap::<Res, ExistingName>::default();\n+\n+        for item in krate.items() {\n+            if let ItemKind::Impl(Impl {\n+                items,\n+                of_trait,\n+                self_ty,\n+                ..\n+            }) = &item.kind\n+            {\n+                if let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind {\n+                    if !map.contains_key(res) {\n+                        map.insert(\n+                            *res,\n+                            ExistingName {\n+                                impl_methods: BTreeMap::new(),\n+                                trait_methods: BTreeMap::new(),\n+                            },\n+                        );\n+                    }\n+                    let existing_name = map.get_mut(res).unwrap();\n+\n+                    match of_trait {\n+                        Some(trait_ref) => {\n+                            let mut methods_in_trait: BTreeSet<Symbol> = if_chain! {\n+                                if let Some(Node::TraitRef(TraitRef { path, .. })) =\n+                                    cx.tcx.hir().find(trait_ref.hir_ref_id);\n+                                if let Res::Def(DefKind::Trait, did) = path.res;\n+                                then{\n+                                    // FIXME: if\n+                                    // `rustc_middle::ty::assoc::AssocItems::items` is public,\n+                                    // we can iterate its keys instead of `in_definition_order`,\n+                                    // which's more efficient\n+                                    cx.tcx\n+                                        .associated_items(did)\n+                                        .in_definition_order()\n+                                        .filter(|assoc_item| {\n+                                            matches!(assoc_item.kind, AssocKind::Fn)\n+                                        })\n+                                        .map(|assoc_item| assoc_item.ident.name)\n+                                        .collect()\n+                                }else{\n+                                    BTreeSet::new()\n+                                }\n+                            };\n+\n+                            let mut check_trait_method = |method_name: Symbol, trait_method_span: Span| {\n+                                if let Some(impl_span) = existing_name.impl_methods.get(&method_name) {\n+                                    span_lint_and_then(\n+                                        cx,\n+                                        SAME_NAME_METHOD,\n+                                        *impl_span,\n+                                        \"method's name is same to an existing method in a trait\",\n+                                        |diag| {\n+                                            diag.span_note(\n+                                                trait_method_span,\n+                                                &format!(\"existing `{}` defined here\", method_name),\n+                                            );\n+                                        },\n+                                    );\n+                                }\n+                                if let Some(v) = existing_name.trait_methods.get_mut(&method_name) {\n+                                    v.push(trait_method_span);\n+                                } else {\n+                                    existing_name.trait_methods.insert(method_name, vec![trait_method_span]);\n+                                }\n+                            };\n+\n+                            for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n+                                matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n+                            }) {\n+                                let method_name = impl_item_ref.ident.name;\n+                                methods_in_trait.remove(&method_name);\n+                                check_trait_method(method_name, impl_item_ref.span);\n+                            }\n+\n+                            for method_name in methods_in_trait {\n+                                check_trait_method(method_name, item.span);\n+                            }\n+                        },\n+                        None => {\n+                            for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n+                                matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n+                            }) {\n+                                let method_name = impl_item_ref.ident.name;\n+                                let impl_span = impl_item_ref.span;\n+                                if let Some(trait_spans) = existing_name.trait_methods.get(&method_name) {\n+                                    span_lint_and_then(\n+                                        cx,\n+                                        SAME_NAME_METHOD,\n+                                        impl_span,\n+                                        \"method's name is same to an existing method in a trait\",\n+                                        |diag| {\n+                                            // TODO should we `span_note` on every trait?\n+                                            // iterate on trait_spans?\n+                                            diag.span_note(\n+                                                trait_spans[0],\n+                                                &format!(\"existing `{}` defined here\", method_name),\n+                                            );\n+                                        },\n+                                    );\n+                                }\n+                                existing_name.impl_methods.insert(method_name, impl_span);\n+                            }\n+                        },\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "b28da29c91cef75203b9dde75562362c870d89fc", "filename": "clippy_lints/src/types/box_collection.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,50 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_ty_param_diagnostic_item;\n+use rustc_hir::{self as hir, def_id::DefId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::BOX_COLLECTION;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if_chain! {\n+        if Some(def_id) == cx.tcx.lang_items().owned_box();\n+        if let Some(item_type) = get_std_collection(cx, qpath);\n+        then {\n+            let generic = if item_type == \"String\" {\n+                \"\"\n+            } else {\n+                \"<..>\"\n+            };\n+            span_lint_and_help(\n+                cx,\n+                BOX_COLLECTION,\n+                hir_ty.span,\n+                &format!(\n+                    \"you seem to be trying to use `Box<{outer}{generic}>`. Consider using just `{outer}{generic}`\",\n+                    outer=item_type,\n+                    generic = generic),\n+                None,\n+                &format!(\n+                    \"`{outer}{generic}` is already on the heap, `Box<{outer}{generic}>` makes an extra allocation\",\n+                    outer=item_type,\n+                    generic = generic)\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+fn get_std_collection(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n+    if is_ty_param_diagnostic_item(cx, qpath, sym::vec_type).is_some() {\n+        Some(\"Vec\")\n+    } else if is_ty_param_diagnostic_item(cx, qpath, sym::string_type).is_some() {\n+        Some(\"String\")\n+    } else if is_ty_param_diagnostic_item(cx, qpath, sym::hashmap_type).is_some() {\n+        Some(\"HashMap\")\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "d8b1953457ccc961f4803370e7195540ee168ca3", "filename": "clippy_lints/src/types/box_vec.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/067bfe3618f9c3e21723c5946e7302968b518d6e/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/067bfe3618f9c3e21723c5946e7302968b518d6e/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs?ref=067bfe3618f9c3e21723c5946e7302968b518d6e", "patch": "@@ -1,25 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_ty_param_diagnostic_item;\n-use rustc_hir::{self as hir, def_id::DefId, QPath};\n-use rustc_lint::LateContext;\n-use rustc_span::symbol::sym;\n-\n-use super::BOX_VEC;\n-\n-pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n-    if Some(def_id) == cx.tcx.lang_items().owned_box()\n-        && is_ty_param_diagnostic_item(cx, qpath, sym::vec_type).is_some()\n-    {\n-        span_lint_and_help(\n-            cx,\n-            BOX_VEC,\n-            hir_ty.span,\n-            \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-            None,\n-            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\",\n-        );\n-        true\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "bbe07db5358cdc805be57a209fc87c22871b24ee", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n mod borrowed_box;\n-mod box_vec;\n+mod box_collection;\n mod linked_list;\n mod option_option;\n mod rc_buffer;\n@@ -21,12 +21,12 @@ use rustc_span::source_map::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for use of `Box<Vec<_>>` anywhere in the code.\n+    /// Checks for use of `Box<T>` where T is a collection such as Vec anywhere in the code.\n     /// Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n     ///\n     /// ### Why is this bad?\n-    /// `Vec` already keeps its contents in a separate area on\n-    /// the heap. So if you `Box` it, you just add another level of indirection\n+    /// Collections already keeps their contents in a separate area on\n+    /// the heap. So if you `Box` them, you just add another level of indirection\n     /// without any benefit whatsoever.\n     ///\n     /// ### Example\n@@ -43,7 +43,7 @@ declare_clippy_lint! {\n     ///     values: Vec<Foo>,\n     /// }\n     /// ```\n-    pub BOX_VEC,\n+    pub BOX_COLLECTION,\n     perf,\n     \"usage of `Box<Vec<T>>`, vector elements are already on the heap\"\n }\n@@ -298,7 +298,7 @@ pub struct Types {\n     avoid_breaking_exported_api: bool,\n }\n \n-impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, RC_MUTEX, TYPE_COMPLEXITY]);\n+impl_lint_pass!(Types => [BOX_COLLECTION, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, RC_MUTEX, TYPE_COMPLEXITY]);\n \n impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n@@ -447,7 +447,7 @@ impl Types {\n                         // in `clippy_lints::utils::conf.rs`\n \n                         let mut triggered = false;\n-                        triggered |= box_vec::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= box_collection::check(cx, hir_ty, qpath, def_id);\n                         triggered |= redundant_allocation::check(cx, hir_ty, qpath, def_id);\n                         triggered |= rc_buffer::check(cx, hir_ty, qpath, def_id);\n                         triggered |= vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);"}, {"sha": "1e0447239be99813cb7777c9e929fa600e86c71c", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -15,6 +15,14 @@ pub struct Rename {\n     pub rename: String,\n }\n \n+/// A single disallowed method, used by the `DISALLOWED_METHOD` lint.\n+#[derive(Clone, Debug, Deserialize)]\n+#[serde(untagged)]\n+pub enum DisallowedMethod {\n+    Simple(String),\n+    WithReason { path: String, reason: Option<String> },\n+}\n+\n /// Conf with parse errors\n #[derive(Default)]\n pub struct TryConf {\n@@ -128,7 +136,7 @@ macro_rules! define_Conf {\n }\n \n define_Conf! {\n-    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_VEC, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX.\n+    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_COLLECTION, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX.\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n@@ -243,7 +251,7 @@ define_Conf! {\n     /// Lint: DISALLOWED_METHOD.\n     ///\n     /// The list of disallowed methods, written as fully qualified paths.\n-    (disallowed_methods: Vec<String> = Vec::new()),\n+    (disallowed_methods: Vec<crate::utils::conf::DisallowedMethod> = Vec::new()),\n     /// Lint: DISALLOWED_TYPE.\n     ///\n     /// The list of disallowed types, written as fully qualified paths."}, {"sha": "b132bf93b5b87e996331738250aa8dbb21f666d2", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -561,9 +561,7 @@ declare_lint_pass!(ProduceIce => [PRODUCE_ICE]);\n \n impl EarlyLintPass for ProduceIce {\n     fn check_fn(&mut self, _: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n-        if is_trigger_fn(fn_kind) {\n-            panic!(\"Would you like some help with that?\");\n-        }\n+        assert!(!is_trigger_fn(fn_kind), \"Would you like some help with that?\");\n     }\n }\n \n@@ -1224,5 +1222,5 @@ fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: S\n     let sm = cx.sess().source_map();\n     let span = sm.span_extend_to_prev_str(span, \"let\", false);\n     let span = sm.span_extend_to_next_char(span, ';', false);\n-    Span::new(span.lo() - BytePos(3), span.hi() + BytePos(1), span.ctxt())\n+    Span::new(span.lo() - BytePos(3), span.hi() + BytePos(1), span.ctxt(), None)\n }"}, {"sha": "0d27874b7affb88d7a4dc16f119469919cbf23ef", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -298,6 +298,7 @@ pub struct ClippyConfiguration {\n     default: String,\n     lints: Vec<String>,\n     doc: String,\n+    #[allow(dead_code)]\n     deprecation_reason: Option<&'static str>,\n }\n "}, {"sha": "e7fca3ae5d401b8b3f84c4c71c340145a95d27cb", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_utils\"\n version = \"0.1.57\"\n-edition = \"2018\"\n+edition = \"2021\"\n publish = false\n \n [dependencies]"}, {"sha": "2fa98831c7740aa31e7765ddf463cb36eba3d658", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -46,15 +46,12 @@ pub fn eq_pat(l: &Pat, r: &Pat) -> bool {\n         | (Ref(l, Mutability::Not), Ref(r, Mutability::Not))\n         | (Ref(l, Mutability::Mut), Ref(r, Mutability::Mut)) => eq_pat(l, r),\n         (Tuple(l), Tuple(r)) | (Slice(l), Slice(r)) => over(l, r, |l, r| eq_pat(l, r)),\n-        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, eq_qself) && eq_path(lp, rp),\n         (TupleStruct(lqself, lp, lfs), TupleStruct(rqself, rp, rfs)) => {\n             eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r))\n         },\n         (Struct(lqself, lp, lfs, lr), Struct(rqself, rp, rfs, rr)) => {\n-            lr == rr\n-                && eq_maybe_qself(lqself, rqself)\n-                && eq_path(lp, rp)\n-                && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n+            lr == rr && eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && unordered_over(lfs, rfs, eq_field_pat)\n         },\n         (Or(ls), Or(rs)) => unordered_over(ls, rs, |l, r| eq_pat(l, r)),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -76,7 +73,7 @@ pub fn eq_field_pat(l: &PatField, r: &PatField) -> bool {\n     l.is_placeholder == r.is_placeholder\n         && eq_id(l.ident, r.ident)\n         && eq_pat(&l.pat, &r.pat)\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n pub fn eq_qself(l: &QSelf, r: &QSelf) -> bool {\n@@ -92,7 +89,7 @@ pub fn eq_maybe_qself(l: &Option<QSelf>, r: &Option<QSelf>) -> bool {\n }\n \n pub fn eq_path(l: &Path, r: &Path) -> bool {\n-    over(&l.segments, &r.segments, |l, r| eq_path_seg(l, r))\n+    over(&l.segments, &r.segments, eq_path_seg)\n }\n \n pub fn eq_path_seg(l: &PathSegment, r: &PathSegment) -> bool {\n@@ -101,9 +98,7 @@ pub fn eq_path_seg(l: &PathSegment, r: &PathSegment) -> bool {\n \n pub fn eq_generic_args(l: &GenericArgs, r: &GenericArgs) -> bool {\n     match (l, r) {\n-        (GenericArgs::AngleBracketed(l), GenericArgs::AngleBracketed(r)) => {\n-            over(&l.args, &r.args, |l, r| eq_angle_arg(l, r))\n-        },\n+        (GenericArgs::AngleBracketed(l), GenericArgs::AngleBracketed(r)) => over(&l.args, &r.args, eq_angle_arg),\n         (GenericArgs::Parenthesized(l), GenericArgs::Parenthesized(r)) => {\n             over(&l.inputs, &r.inputs, |l, r| eq_ty(l, r)) && eq_fn_ret_ty(&l.output, &r.output)\n         },\n@@ -142,7 +137,7 @@ pub fn eq_struct_rest(l: &StructRest, r: &StructRest) -> bool {\n \n pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n     use ExprKind::*;\n-    if !over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r)) {\n+    if !over(&l.attrs, &r.attrs, eq_attr) {\n         return false;\n     }\n     match (&l.kind, &r.kind) {\n@@ -173,20 +168,20 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Assign(l1, l2, _), Assign(r1, r2, _)) | (Index(l1, l2), Index(r1, r2)) => eq_expr(l1, r1) && eq_expr(l2, r2),\n         (AssignOp(lo, lp, lv), AssignOp(ro, rp, rv)) => lo.node == ro.node && eq_expr(lp, rp) && eq_expr(lv, rv),\n         (Field(lp, lf), Field(rp, rf)) => eq_id(*lf, *rf) && eq_expr(lp, rp),\n-        (Match(ls, la), Match(rs, ra)) => eq_expr(ls, rs) && over(la, ra, |l, r| eq_arm(l, r)),\n+        (Match(ls, la), Match(rs, ra)) => eq_expr(ls, rs) && over(la, ra, eq_arm),\n         (Closure(lc, la, lm, lf, lb, _), Closure(rc, ra, rm, rf, rb, _)) => {\n             lc == rc && la.is_async() == ra.is_async() && lm == rm && eq_fn_decl(lf, rf) && eq_expr(lb, rb)\n         },\n         (Async(lc, _, lb), Async(rc, _, rb)) => lc == rc && eq_block(lb, rb),\n         (Range(lf, lt, ll), Range(rf, rt, rl)) => ll == rl && eq_expr_opt(lf, rf) && eq_expr_opt(lt, rt),\n         (AddrOf(lbk, lm, le), AddrOf(rbk, rm, re)) => lbk == rbk && lm == rm && eq_expr(le, re),\n-        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, eq_qself) && eq_path(lp, rp),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         (Struct(lse), Struct(rse)) => {\n             eq_maybe_qself(&lse.qself, &rse.qself)\n                 && eq_path(&lse.path, &rse.path)\n                 && eq_struct_rest(&lse.rest, &rse.rest)\n-                && unordered_over(&lse.fields, &rse.fields, |l, r| eq_field(l, r))\n+                && unordered_over(&lse.fields, &rse.fields, eq_field)\n         },\n         _ => false,\n     }\n@@ -196,23 +191,23 @@ pub fn eq_field(l: &ExprField, r: &ExprField) -> bool {\n     l.is_placeholder == r.is_placeholder\n         && eq_id(l.ident, r.ident)\n         && eq_expr(&l.expr, &r.expr)\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n pub fn eq_arm(l: &Arm, r: &Arm) -> bool {\n     l.is_placeholder == r.is_placeholder\n         && eq_pat(&l.pat, &r.pat)\n         && eq_expr(&l.body, &r.body)\n         && eq_expr_opt(&l.guard, &r.guard)\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n pub fn eq_label(l: &Option<Label>, r: &Option<Label>) -> bool {\n     both(l, r, |l, r| eq_id(l.ident, r.ident))\n }\n \n pub fn eq_block(l: &Block, r: &Block) -> bool {\n-    l.rules == r.rules && over(&l.stmts, &r.stmts, |l, r| eq_stmt(l, r))\n+    l.rules == r.rules && over(&l.stmts, &r.stmts, eq_stmt)\n }\n \n pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n@@ -222,13 +217,13 @@ pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n             eq_pat(&l.pat, &r.pat)\n                 && both(&l.ty, &r.ty, |l, r| eq_ty(l, r))\n                 && eq_local_kind(&l.kind, &r.kind)\n-                && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+                && over(&l.attrs, &r.attrs, eq_attr)\n         },\n         (Item(l), Item(r)) => eq_item(l, r, eq_item_kind),\n         (Expr(l), Expr(r)) | (Semi(l), Semi(r)) => eq_expr(l, r),\n         (Empty, Empty) => true,\n         (MacCall(l), MacCall(r)) => {\n-            l.style == r.style && eq_mac_call(&l.mac, &r.mac) && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+            l.style == r.style && eq_mac_call(&l.mac, &r.mac) && over(&l.attrs, &r.attrs, eq_attr)\n         },\n         _ => false,\n     }\n@@ -245,10 +240,7 @@ pub fn eq_local_kind(l: &LocalKind, r: &LocalKind) -> bool {\n }\n \n pub fn eq_item<K>(l: &Item<K>, r: &Item<K>, mut eq_kind: impl FnMut(&K, &K) -> bool) -> bool {\n-    eq_id(l.ident, r.ident)\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n-        && eq_vis(&l.vis, &r.vis)\n-        && eq_kind(&l.kind, &r.kind)\n+    eq_id(l.ident, r.ident) && over(&l.attrs, &r.attrs, eq_attr) && eq_vis(&l.vis, &r.vis) && eq_kind(&l.kind, &r.kind)\n }\n \n pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n@@ -272,29 +264,26 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 }\n         },\n         (ForeignMod(l), ForeignMod(r)) => {\n-            both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n-                && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n+            both(&l.abi, &r.abi, eq_str_lit) && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n         },\n         (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n-                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(lb, rb, eq_generic_bound)\n                 && both(lt, rt, |l, r| eq_ty(l, r))\n         },\n-        (Enum(le, lg), Enum(re, rg)) => {\n-            over(&le.variants, &re.variants, |l, r| eq_variant(l, r)) && eq_generics(lg, rg)\n-        },\n+        (Enum(le, lg), Enum(re, rg)) => over(&le.variants, &re.variants, eq_variant) && eq_generics(lg, rg),\n         (Struct(lv, lg), Struct(rv, rg)) | (Union(lv, lg), Union(rv, rg)) => {\n             eq_variant_data(lv, rv) && eq_generics(lg, rg)\n         },\n         (Trait(box TraitKind(la, lu, lg, lb, li)), Trait(box TraitKind(ra, ru, rg, rb, ri))) => {\n             la == ra\n                 && matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n                 && eq_generics(lg, rg)\n-                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(lb, rb, eq_generic_bound)\n                 && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n         },\n-        (TraitAlias(lg, lb), TraitAlias(rg, rb)) => eq_generics(lg, rg) && over(lb, rb, |l, r| eq_generic_bound(l, r)),\n+        (TraitAlias(lg, lb), TraitAlias(rg, rb)) => eq_generics(lg, rg) && over(lb, rb, eq_generic_bound),\n         (\n             Impl(box ImplKind {\n                 unsafety: lu,\n@@ -342,7 +331,7 @@ pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n         (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n-                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(lb, rb, eq_generic_bound)\n                 && both(lt, rt, |l, r| eq_ty(l, r))\n         },\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -360,7 +349,7 @@ pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n         (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n-                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(lb, rb, eq_generic_bound)\n                 && both(lt, rt, |l, r| eq_ty(l, r))\n         },\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -370,7 +359,7 @@ pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n \n pub fn eq_variant(l: &Variant, r: &Variant) -> bool {\n     l.is_placeholder == r.is_placeholder\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n         && eq_vis(&l.vis, &r.vis)\n         && eq_id(l.ident, r.ident)\n         && eq_variant_data(&l.data, &r.data)\n@@ -381,14 +370,14 @@ pub fn eq_variant_data(l: &VariantData, r: &VariantData) -> bool {\n     use VariantData::*;\n     match (l, r) {\n         (Unit(_), Unit(_)) => true,\n-        (Struct(l, _), Struct(r, _)) | (Tuple(l, _), Tuple(r, _)) => over(l, r, |l, r| eq_struct_field(l, r)),\n+        (Struct(l, _), Struct(r, _)) | (Tuple(l, _), Tuple(r, _)) => over(l, r, eq_struct_field),\n         _ => false,\n     }\n }\n \n pub fn eq_struct_field(l: &FieldDef, r: &FieldDef) -> bool {\n     l.is_placeholder == r.is_placeholder\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n         && eq_vis(&l.vis, &r.vis)\n         && both(&l.ident, &r.ident, |l, r| eq_id(*l, *r))\n         && eq_ty(&l.ty, &r.ty)\n@@ -406,7 +395,7 @@ pub fn eq_fn_header(l: &FnHeader, r: &FnHeader) -> bool {\n }\n \n pub fn eq_generics(l: &Generics, r: &Generics) -> bool {\n-    over(&l.params, &r.params, |l, r| eq_generic_param(l, r))\n+    over(&l.params, &r.params, eq_generic_param)\n         && over(&l.where_clause.predicates, &r.where_clause.predicates, |l, r| {\n             eq_where_predicate(l, r)\n         })\n@@ -419,10 +408,10 @@ pub fn eq_where_predicate(l: &WherePredicate, r: &WherePredicate) -> bool {\n             over(&l.bound_generic_params, &r.bound_generic_params, |l, r| {\n                 eq_generic_param(l, r)\n             }) && eq_ty(&l.bounded_ty, &r.bounded_ty)\n-                && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+                && over(&l.bounds, &r.bounds, eq_generic_bound)\n         },\n         (RegionPredicate(l), RegionPredicate(r)) => {\n-            eq_id(l.lifetime.ident, r.lifetime.ident) && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+            eq_id(l.lifetime.ident, r.lifetime.ident) && over(&l.bounds, &r.bounds, eq_generic_bound)\n         },\n         (EqPredicate(l), EqPredicate(r)) => eq_ty(&l.lhs_ty, &r.lhs_ty) && eq_ty(&l.rhs_ty, &r.rhs_ty),\n         _ => false,\n@@ -469,7 +458,7 @@ pub fn eq_fn_decl(l: &FnDecl, r: &FnDecl) -> bool {\n             l.is_placeholder == r.is_placeholder\n                 && eq_pat(&l.pat, &r.pat)\n                 && eq_ty(&l.ty, &r.ty)\n-                && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+                && over(&l.attrs, &r.attrs, eq_attr)\n         })\n }\n \n@@ -496,13 +485,13 @@ pub fn eq_ty(l: &Ty, r: &Ty) -> bool {\n         (BareFn(l), BareFn(r)) => {\n             l.unsafety == r.unsafety\n                 && eq_ext(&l.ext, &r.ext)\n-                && over(&l.generic_params, &r.generic_params, |l, r| eq_generic_param(l, r))\n+                && over(&l.generic_params, &r.generic_params, eq_generic_param)\n                 && eq_fn_decl(&l.decl, &r.decl)\n         },\n         (Tup(l), Tup(r)) => over(l, r, |l, r| eq_ty(l, r)),\n-        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n-        (TraitObject(lg, ls), TraitObject(rg, rs)) => ls == rs && over(lg, rg, |l, r| eq_generic_bound(l, r)),\n-        (ImplTrait(_, lg), ImplTrait(_, rg)) => over(lg, rg, |l, r| eq_generic_bound(l, r)),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, eq_qself) && eq_path(lp, rp),\n+        (TraitObject(lg, ls), TraitObject(rg, rs)) => ls == rs && over(lg, rg, eq_generic_bound),\n+        (ImplTrait(_, lg), ImplTrait(_, rg)) => over(lg, rg, eq_generic_bound),\n         (Typeof(l), Typeof(r)) => eq_expr(&l.value, &r.value),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         _ => false,\n@@ -533,7 +522,7 @@ pub fn eq_generic_param(l: &GenericParam, r: &GenericParam) -> bool {\n     use GenericParamKind::*;\n     l.is_placeholder == r.is_placeholder\n         && eq_id(l.ident, r.ident)\n-        && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+        && over(&l.bounds, &r.bounds, eq_generic_bound)\n         && match (&l.kind, &r.kind) {\n             (Lifetime, Lifetime) => true,\n             (Type { default: l }, Type { default: r }) => both(l, r, |l, r| eq_ty(l, r)),\n@@ -548,10 +537,10 @@ pub fn eq_generic_param(l: &GenericParam, r: &GenericParam) -> bool {\n                     kw_span: _,\n                     default: rd,\n                 },\n-            ) => eq_ty(lt, rt) && both(ld, rd, |ld, rd| eq_anon_const(ld, rd)),\n+            ) => eq_ty(lt, rt) && both(ld, rd, eq_anon_const),\n             _ => false,\n         }\n-        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n pub fn eq_generic_bound(l: &GenericBound, r: &GenericBound) -> bool {\n@@ -568,7 +557,7 @@ pub fn eq_assoc_constraint(l: &AssocTyConstraint, r: &AssocTyConstraint) -> bool\n     eq_id(l.ident, r.ident)\n         && match (&l.kind, &r.kind) {\n             (Equality { ty: l }, Equality { ty: r }) => eq_ty(l, r),\n-            (Bound { bounds: l }, Bound { bounds: r }) => over(l, r, |l, r| eq_generic_bound(l, r)),\n+            (Bound { bounds: l }, Bound { bounds: r }) => over(l, r, eq_generic_bound),\n             _ => false,\n         }\n }"}, {"sha": "9650294fc7b879f93450bbf5da74bc64da5abda2", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -27,10 +27,9 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Lit(..) | ExprKind::ConstBlock(..) | ExprKind::Path(..) | ExprKind::Field(..) => true,\n         ExprKind::AddrOf(_, _, addr_of_expr) => identify_some_pure_patterns(addr_of_expr),\n-        ExprKind::Tup(tup_exprs) => tup_exprs.iter().all(|expr| identify_some_pure_patterns(expr)),\n+        ExprKind::Tup(tup_exprs) => tup_exprs.iter().all(identify_some_pure_patterns),\n         ExprKind::Struct(_, fields, expr) => {\n-            fields.iter().all(|f| identify_some_pure_patterns(f.expr))\n-                && expr.map_or(true, |e| identify_some_pure_patterns(e))\n+            fields.iter().all(|f| identify_some_pure_patterns(f.expr)) && expr.map_or(true, identify_some_pure_patterns)\n         },\n         ExprKind::Call(\n             &Expr {\n@@ -45,7 +44,7 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n                 ..\n             },\n             args,\n-        ) => args.iter().all(|expr| identify_some_pure_patterns(expr)),\n+        ) => args.iter().all(identify_some_pure_patterns),\n         ExprKind::Block(\n             &Block {\n                 stmts,"}, {"sha": "ba4d50bf74469307cbfedc51e1c979c532c74d4e", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -602,3 +602,33 @@ pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n \n     false\n }\n+\n+/// A parsed `panic!` expansion\n+pub struct PanicExpn<'tcx> {\n+    /// Span of `panic!(..)`\n+    pub call_site: Span,\n+    /// Inner `format_args!` expansion\n+    pub format_args: FormatArgsExpn<'tcx>,\n+}\n+\n+impl PanicExpn<'tcx> {\n+    /// Parses an expanded `panic!` invocation\n+    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let ExprKind::Block(block, _) = expr.kind;\n+            if let Some(init) = block.expr;\n+            if let ExprKind::Call(_, [format_args]) = init.kind;\n+            let expn_data = expr.span.ctxt().outer_expn_data();\n+            if let ExprKind::AddrOf(_, _, format_args) = format_args.kind;\n+            if let Some(format_args) = FormatArgsExpn::parse(format_args);\n+            then {\n+                Some(PanicExpn {\n+                    call_site: expn_data.call_site,\n+                    format_args,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "7438b6eabf9e61f267670b1c3df24b4018414ebd", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         std::mem::discriminant(&b.rules).hash(&mut self.s);\n     }\n \n-    #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n+    #[allow(clippy::too_many_lines)]\n     pub fn hash_expr(&mut self, e: &Expr<'_>) {\n         let simple_const = self\n             .maybe_typeck_results"}, {"sha": "238728f090f56aba3b5500f3545ee8177f0570d6", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -192,9 +192,8 @@ fn check_rvalue(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, rvalue: &Rv\n                 ))\n             }\n         },\n-        Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => Ok(()),\n+        Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) | Rvalue::ShallowInitBox(_, _) => Ok(()),\n         Rvalue::NullaryOp(NullOp::Box, _) => Err((span, \"heap allocations are not allowed in const fn\".into())),\n-        Rvalue::ShallowInitBox(_, _) => Ok(()),\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {"}, {"sha": "97d3794fb84f0a951de6acd2e8a0e3eced02d357", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -15,6 +15,8 @@ use std::{\n     env, fmt,\n     fs::write,\n     path::{Path, PathBuf},\n+    thread,\n+    time::Duration,\n };\n \n use clap::{App, Arg, ArgMatches};\n@@ -109,6 +111,22 @@ impl std::fmt::Display for ClippyWarning {\n     }\n }\n \n+fn get(path: &str) -> Result<ureq::Response, ureq::Error> {\n+    const MAX_RETRIES: u8 = 4;\n+    let mut retries = 0;\n+    loop {\n+        match ureq::get(path).call() {\n+            Ok(res) => return Ok(res),\n+            Err(e) if retries >= MAX_RETRIES => return Err(e),\n+            Err(ureq::Error::Transport(e)) => eprintln!(\"Error: {}\", e),\n+            Err(e) => return Err(e),\n+        }\n+        eprintln!(\"retrying in {} seconds...\", retries);\n+        thread::sleep(Duration::from_secs(retries as u64));\n+        retries += 1;\n+    }\n+}\n+\n impl CrateSource {\n     /// Makes the sources available on the disk for clippy to check.\n     /// Clones a git repo and checks out the specified commit or downloads a crate from crates.io or\n@@ -129,7 +147,7 @@ impl CrateSource {\n                 if !krate_file_path.is_file() {\n                     // create a file path to download and write the crate data into\n                     let mut krate_dest = std::fs::File::create(&krate_file_path).unwrap();\n-                    let mut krate_req = ureq::get(&url).call().unwrap().into_reader();\n+                    let mut krate_req = get(&url).unwrap().into_reader();\n                     // copy the crate into the file\n                     std::io::copy(&mut krate_req, &mut krate_dest).unwrap();\n "}, {"sha": "7ebdd947893e9e1570ed1fe8d31ba32b2b4ffefd", "filename": "src/main.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -4,7 +4,6 @@\n \n use rustc_tools_util::VersionInfo;\n use std::env;\n-use std::ffi::OsString;\n use std::path::PathBuf;\n use std::process::{self, Command};\n \n@@ -14,7 +13,7 @@ Usage:\n     cargo clippy [options] [--] [<opts>...]\n \n Common options:\n-    --no-deps                Run Clippy only on the given crate, without linting the dependencies \n+    --no-deps                Run Clippy only on the given crate, without linting the dependencies\n     --fix                    Automatically apply lint suggestions. This flag implies `--no-deps`\n     -h, --help               Print this message\n     -V, --version            Print version info and exit\n@@ -116,22 +115,6 @@ impl ClippyCmd {\n         path\n     }\n \n-    fn target_dir() -> Option<(&'static str, OsString)> {\n-        env::var_os(\"CLIPPY_DOGFOOD\")\n-            .map(|_| {\n-                env::var_os(\"CARGO_MANIFEST_DIR\").map_or_else(\n-                    || std::ffi::OsString::from(\"clippy_dogfood\"),\n-                    |d| {\n-                        std::path::PathBuf::from(d)\n-                            .join(\"target\")\n-                            .join(\"dogfood\")\n-                            .into_os_string()\n-                    },\n-                )\n-            })\n-            .map(|p| (\"CARGO_TARGET_DIR\", p))\n-    }\n-\n     fn into_std_cmd(self) -> Command {\n         let mut cmd = Command::new(\"cargo\");\n         let clippy_args: String = self\n@@ -141,7 +124,6 @@ impl ClippyCmd {\n             .collect();\n \n         cmd.env(\"RUSTC_WORKSPACE_WRAPPER\", Self::path())\n-            .envs(ClippyCmd::target_dir())\n             .env(\"CLIPPY_ARGS\", clippy_args)\n             .arg(self.cargo_subcommand)\n             .args(&self.args);"}, {"sha": "4dbe71e4b6ad6ae032be2c43649c6deba8aecf37", "filename": "tests/cargo/mod.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fcargo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fcargo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcargo%2Fmod.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,25 +1,3 @@\n-use std::env;\n-use std::lazy::SyncLazy;\n-use std::path::PathBuf;\n-\n-pub static CARGO_TARGET_DIR: SyncLazy<PathBuf> = SyncLazy::new(|| match env::var_os(\"CARGO_TARGET_DIR\") {\n-    Some(v) => v.into(),\n-    None => env::current_dir().unwrap().join(\"target\"),\n-});\n-\n-pub static TARGET_LIB: SyncLazy<PathBuf> = SyncLazy::new(|| {\n-    if let Some(path) = option_env!(\"TARGET_LIBS\") {\n-        path.into()\n-    } else {\n-        let mut dir = CARGO_TARGET_DIR.clone();\n-        if let Some(target) = env::var_os(\"CARGO_BUILD_TARGET\") {\n-            dir.push(target);\n-        }\n-        dir.push(env!(\"PROFILE\"));\n-        dir\n-    }\n-});\n-\n #[must_use]\n pub fn is_rustc_test_suite() -> bool {\n     option_env!(\"RUSTC_TEST_SUITE\").is_some()"}, {"sha": "d7596f6ff0cae9e7e78f9c72b438ebb55da6e2e5", "filename": "tests/compile-test.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,4 @@\n #![feature(test)] // compiletest_rs requires this attribute\n-#![feature(once_cell)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n@@ -46,14 +45,6 @@ extern crate quote;\n #[allow(unused_extern_crates)]\n extern crate syn;\n \n-fn host_lib() -> PathBuf {\n-    option_env!(\"HOST_LIBS\").map_or(cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\")), PathBuf::from)\n-}\n-\n-fn clippy_driver_path() -> PathBuf {\n-    option_env!(\"CLIPPY_DRIVER_PATH\").map_or(cargo::TARGET_LIB.join(\"clippy-driver\"), PathBuf::from)\n-}\n-\n /// Produces a string with an `--extern` flag for all UI test crate\n /// dependencies.\n ///\n@@ -99,12 +90,14 @@ fn extern_flags() -> String {\n         .copied()\n         .filter(|n| !crates.contains_key(n))\n         .collect();\n-    if !not_found.is_empty() {\n-        panic!(\"dependencies not found in depinfo: {:?}\", not_found);\n-    }\n+    assert!(\n+        not_found.is_empty(),\n+        \"dependencies not found in depinfo: {:?}\",\n+        not_found\n+    );\n     crates\n         .into_iter()\n-        .map(|(name, path)| format!(\"--extern {}={} \", name, path))\n+        .map(|(name, path)| format!(\" --extern {}={}\", name, path))\n         .collect()\n }\n \n@@ -120,19 +113,29 @@ fn default_config() -> compiletest::Config {\n         config.run_lib_path = path.clone();\n         config.compile_lib_path = path;\n     }\n+    let current_exe_path = std::env::current_exe().unwrap();\n+    let deps_path = current_exe_path.parent().unwrap();\n+    let profile_path = deps_path.parent().unwrap();\n \n     // Using `-L dependency={}` enforces that external dependencies are added with `--extern`.\n     // This is valuable because a) it allows us to monitor what external dependencies are used\n     // and b) it ensures that conflicting rlibs are resolved properly.\n+    let host_libs = option_env!(\"HOST_LIBS\")\n+        .map(|p| format!(\" -L dependency={}\", Path::new(p).join(\"deps\").display()))\n+        .unwrap_or_default();\n     config.target_rustcflags = Some(format!(\n-        \"--emit=metadata -L dependency={} -L dependency={} -Dwarnings -Zui-testing {}\",\n-        host_lib().join(\"deps\").display(),\n-        cargo::TARGET_LIB.join(\"deps\").display(),\n+        \"--emit=metadata -Dwarnings -Zui-testing -L dependency={}{}{}\",\n+        deps_path.display(),\n+        host_libs,\n         extern_flags(),\n     ));\n \n-    config.build_base = host_lib().join(\"test_build_base\");\n-    config.rustc_path = clippy_driver_path();\n+    config.build_base = profile_path.join(\"test\");\n+    config.rustc_path = profile_path.join(if cfg!(windows) {\n+        \"clippy-driver.exe\"\n+    } else {\n+        \"clippy-driver\"\n+    });\n     config\n }\n "}, {"sha": "a37cdfed126f6cea9c46d063abf01ac7ff801e5f", "filename": "tests/dogfood.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -15,7 +15,12 @@ use std::process::Command;\n \n mod cargo;\n \n-static CLIPPY_PATH: SyncLazy<PathBuf> = SyncLazy::new(|| cargo::TARGET_LIB.join(\"cargo-clippy\"));\n+static CLIPPY_PATH: SyncLazy<PathBuf> = SyncLazy::new(|| {\n+    let mut path = std::env::current_exe().unwrap();\n+    assert!(path.pop()); // deps\n+    path.set_file_name(\"cargo-clippy\");\n+    path\n+});\n \n #[test]\n fn dogfood_clippy() {\n@@ -28,7 +33,6 @@ fn dogfood_clippy() {\n     let mut command = Command::new(&*CLIPPY_PATH);\n     command\n         .current_dir(root_dir)\n-        .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n         .arg(\"clippy\")\n         .arg(\"--all-targets\")\n@@ -74,7 +78,6 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n     // Make sure that with the `--no-deps` argument Clippy does not run on `path_dep`.\n     let output = Command::new(&*CLIPPY_PATH)\n         .current_dir(&cwd)\n-        .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n         .arg(\"clippy\")\n         .args(&[\"-p\", \"subcrate\"])\n@@ -94,7 +97,6 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n         // Test that without the `--no-deps` argument, `path_dep` is linted.\n         let output = Command::new(&*CLIPPY_PATH)\n             .current_dir(&cwd)\n-            .env(\"CLIPPY_DOGFOOD\", \"1\")\n             .env(\"CARGO_INCREMENTAL\", \"0\")\n             .arg(\"clippy\")\n             .args(&[\"-p\", \"subcrate\"])\n@@ -121,7 +123,6 @@ fn test_no_deps_ignores_path_deps_in_workspaces() {\n     let successful_build = || {\n         let output = Command::new(&*CLIPPY_PATH)\n             .current_dir(&cwd)\n-            .env(\"CLIPPY_DOGFOOD\", \"1\")\n             .env(\"CARGO_INCREMENTAL\", \"0\")\n             .arg(\"clippy\")\n             .args(&[\"-p\", \"subcrate\"])\n@@ -223,7 +224,6 @@ fn run_clippy_for_project(project: &str) {\n \n     command\n         .current_dir(root_dir.join(project))\n-        .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n         .arg(\"clippy\")\n         .arg(\"--all-targets\")"}, {"sha": "c64425fa01a42a36b8351e934ae81523d75b7129", "filename": "tests/integration.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fintegration.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -74,8 +74,11 @@ fn integration_test() {\n         panic!(\"incompatible crate versions\");\n     } else if stderr.contains(\"failed to run `rustc` to learn about target-specific information\") {\n         panic!(\"couldn't find librustc_driver, consider setting `LD_LIBRARY_PATH`\");\n-    } else if stderr.contains(\"toolchain\") && stderr.contains(\"is not installed\") {\n-        panic!(\"missing required toolchain\");\n+    } else {\n+        assert!(\n+            !stderr.contains(\"toolchain\") || !stderr.contains(\"is not installed\"),\n+            \"missing required toolchain\"\n+        );\n     }\n \n     match output.status.code() {"}, {"sha": "f1d4a4619c5dc995105fd11715f4d422e5c4bec9", "filename": "tests/ui-toml/toml_disallowed_method/clippy.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,8 @@\n disallowed-methods = [\n+    # just a string is shorthand for path only\n     \"std::iter::Iterator::sum\",\n-    \"regex::Regex::is_match\",\n-    \"regex::Regex::new\"\n+    # can give path and reason with an inline table\n+    { path = \"regex::Regex::is_match\", reason = \"no matching allowed\" },\n+    # can use an inline table but omit reason\n+    { path = \"regex::Regex::new\" },\n ]"}, {"sha": "38123220a4320e5ceb5dd0137cc4d08b3e761d89", "filename": "tests/ui-toml/toml_disallowed_method/conf_disallowed_method.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui-toml%2Ftoml_disallowed_method%2Fconf_disallowed_method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui-toml%2Ftoml_disallowed_method%2Fconf_disallowed_method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_method%2Fconf_disallowed_method.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,18 +1,20 @@\n-error: use of a disallowed method `regex::re_unicode::Regex::new`\n+error: use of a disallowed method `regex::Regex::new`\n   --> $DIR/conf_disallowed_method.rs:7:14\n    |\n LL |     let re = Regex::new(r\"ab.*c\").unwrap();\n    |              ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::disallowed-method` implied by `-D warnings`\n \n-error: use of a disallowed method `regex::re_unicode::Regex::is_match`\n+error: use of a disallowed method `regex::Regex::is_match`\n   --> $DIR/conf_disallowed_method.rs:8:5\n    |\n LL |     re.is_match(\"abc\");\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: no matching allowed (from clippy.toml)\n \n-error: use of a disallowed method `core::iter::traits::iterator::Iterator::sum`\n+error: use of a disallowed method `std::iter::Iterator::sum`\n   --> $DIR/conf_disallowed_method.rs:11:5\n    |\n LL |     a.iter().sum::<i32>();"}, {"sha": "fb0e226f3aa40b0ed32d63646b4e1b494740ac24", "filename": "tests/ui-toml/toml_trivially_copy/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -2,7 +2,6 @@\n // normalize-stderr-test \"\\(limit: \\d+ byte\\)\" -> \"(limit: N byte)\"\n \n #![deny(clippy::trivially_copy_pass_by_ref)]\n-#![allow(clippy::many_single_char_names)]\n \n #[derive(Copy, Clone)]\n struct Foo(u8);"}, {"sha": "b3ef5928e8ea22302017c8ea3c2d79e238916570", "filename": "tests/ui-toml/toml_trivially_copy/test.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_trivially_copy%2Ftest.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/test.rs:15:11\n+  --> $DIR/test.rs:14:11\n    |\n LL | fn bad(x: &u16, y: &Foo) {}\n    |           ^^^^ help: consider passing by value instead: `u16`\n@@ -11,7 +11,7 @@ LL | #![deny(clippy::trivially_copy_pass_by_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/test.rs:15:20\n+  --> $DIR/test.rs:14:20\n    |\n LL | fn bad(x: &u16, y: &Foo) {}\n    |                    ^^^^ help: consider passing by value instead: `Foo`"}, {"sha": "26c88489b03cb4d9e75b7880ce19d3c9720ea082", "filename": "tests/ui/auxiliary/proc_macro_suspicious_else_formatting.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fauxiliary%2Fproc_macro_suspicious_else_formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fauxiliary%2Fproc_macro_suspicious_else_formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_suspicious_else_formatting.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,75 @@\n+// compile-flags: --emit=link\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::{token_stream, Delimiter, Group, Ident, Span, TokenStream, TokenTree};\n+use std::iter::FromIterator;\n+\n+fn read_ident(iter: &mut token_stream::IntoIter) -> Ident {\n+    match iter.next() {\n+        Some(TokenTree::Ident(i)) => i,\n+        _ => panic!(\"expected ident\"),\n+    }\n+}\n+\n+#[proc_macro_derive(DeriveBadSpan)]\n+pub fn derive_bad_span(input: TokenStream) -> TokenStream {\n+    let mut input = input.into_iter();\n+    assert_eq!(read_ident(&mut input).to_string(), \"struct\");\n+    let ident = read_ident(&mut input);\n+    let mut tys = match input.next() {\n+        Some(TokenTree::Group(g)) if g.delimiter() == Delimiter::Parenthesis => g.stream().into_iter(),\n+        _ => panic!(),\n+    };\n+    let field1 = read_ident(&mut tys);\n+    tys.next();\n+    let field2 = read_ident(&mut tys);\n+\n+    <TokenStream as FromIterator<TokenTree>>::from_iter(\n+        [\n+            Ident::new(\"impl\", Span::call_site()).into(),\n+            ident.into(),\n+            Group::new(\n+                Delimiter::Brace,\n+                <TokenStream as FromIterator<TokenTree>>::from_iter(\n+                    [\n+                        Ident::new(\"fn\", Span::call_site()).into(),\n+                        Ident::new(\"_foo\", Span::call_site()).into(),\n+                        Group::new(Delimiter::Parenthesis, TokenStream::new()).into(),\n+                        Group::new(\n+                            Delimiter::Brace,\n+                            <TokenStream as FromIterator<TokenTree>>::from_iter(\n+                                [\n+                                    Ident::new(\"if\", field1.span()).into(),\n+                                    Ident::new(\"true\", field1.span()).into(),\n+                                    {\n+                                        let mut group = Group::new(Delimiter::Brace, TokenStream::new());\n+                                        group.set_span(field1.span());\n+                                        group.into()\n+                                    },\n+                                    Ident::new(\"if\", field2.span()).into(),\n+                                    Ident::new(\"true\", field2.span()).into(),\n+                                    {\n+                                        let mut group = Group::new(Delimiter::Brace, TokenStream::new());\n+                                        group.set_span(field2.span());\n+                                        group.into()\n+                                    },\n+                                ]\n+                                .iter()\n+                                .cloned(),\n+                            ),\n+                        )\n+                        .into(),\n+                    ]\n+                    .iter()\n+                    .cloned(),\n+                ),\n+            )\n+            .into(),\n+        ]\n+        .iter()\n+        .cloned(),\n+    )\n+}"}, {"sha": "e00f061f28a94b67a91f87d105b43a4131d68bc0", "filename": "tests/ui/box_collection.rs", "status": "renamed", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fbox_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fbox_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_collection.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -6,6 +6,8 @@\n     unused\n )]\n \n+use std::collections::HashMap;\n+\n macro_rules! boxit {\n     ($init:expr, $x:ty) => {\n         let _: Box<$x> = Box::new($init);\n@@ -15,20 +17,26 @@ macro_rules! boxit {\n fn test_macro() {\n     boxit!(Vec::new(), Vec<u8>);\n }\n+\n fn test(foo: Box<Vec<bool>>) {}\n \n fn test2(foo: Box<dyn Fn(Vec<u32>)>) {\n     // pass if #31 is fixed\n     foo(vec![1, 2, 3])\n }\n \n+fn test3(foo: Box<String>) {}\n+\n+fn test4(foo: Box<HashMap<String, String>>) {}\n+\n fn test_local_not_linted() {\n     let _: Box<Vec<bool>>;\n }\n \n // All of these test should be allowed because they are part of the\n // public api and `avoid_breaking_exported_api` is `false` by default.\n pub fn pub_test(foo: Box<Vec<bool>>) {}\n+\n pub fn pub_test_ret() -> Box<Vec<bool>> {\n     Box::new(Vec::new())\n }", "previous_filename": "tests/ui/box_vec.rs"}, {"sha": "6de85d05a99f32b59eac0905a7f19967d8419f6e", "filename": "tests/ui/box_collection.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fbox_collection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fbox_collection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_collection.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,27 @@\n+error: you seem to be trying to use `Box<Vec<..>>`. Consider using just `Vec<..>`\n+  --> $DIR/box_collection.rs:21:14\n+   |\n+LL | fn test(foo: Box<Vec<bool>>) {}\n+   |              ^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::box-collection` implied by `-D warnings`\n+   = help: `Vec<..>` is already on the heap, `Box<Vec<..>>` makes an extra allocation\n+\n+error: you seem to be trying to use `Box<String>`. Consider using just `String`\n+  --> $DIR/box_collection.rs:28:15\n+   |\n+LL | fn test3(foo: Box<String>) {}\n+   |               ^^^^^^^^^^^\n+   |\n+   = help: `String` is already on the heap, `Box<String>` makes an extra allocation\n+\n+error: you seem to be trying to use `Box<HashMap<..>>`. Consider using just `HashMap<..>`\n+  --> $DIR/box_collection.rs:30:15\n+   |\n+LL | fn test4(foo: Box<HashMap<String, String>>) {}\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `HashMap<..>` is already on the heap, `Box<HashMap<..>>` makes an extra allocation\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "58c1f13fb877b1ba77deda63048b0ed41bf36314", "filename": "tests/ui/box_vec.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/067bfe3618f9c3e21723c5946e7302968b518d6e/tests%2Fui%2Fbox_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/067bfe3618f9c3e21723c5946e7302968b518d6e/tests%2Fui%2Fbox_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_vec.stderr?ref=067bfe3618f9c3e21723c5946e7302968b518d6e", "patch": "@@ -1,11 +0,0 @@\n-error: you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\n-  --> $DIR/box_vec.rs:18:14\n-   |\n-LL | fn test(foo: Box<Vec<bool>>) {}\n-   |              ^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::box-vec` implied by `-D warnings`\n-   = help: `Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\n-\n-error: aborting due to previous error\n-"}, {"sha": "9114d8754dcc8f4b0ad598aa2b0faaaeecd882fb", "filename": "tests/ui/default_trait_access.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fdefault_trait_access.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fdefault_trait_access.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports,dead_code)]\n+#![allow(unused_imports, dead_code)]\n #![deny(clippy::default_trait_access)]\n \n use std::default;"}, {"sha": "8a5f0d6a74976665c8181638cde258c82ab50716", "filename": "tests/ui/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports,dead_code)]\n+#![allow(unused_imports, dead_code)]\n #![deny(clippy::default_trait_access)]\n \n use std::default;"}, {"sha": "d4832daa6895970746de537909bb6339af07331e", "filename": "tests/ui/deref_addrof.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fderef_addrof.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fderef_addrof.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -9,7 +9,7 @@ fn get_reference(n: &usize) -> &usize {\n     n\n }\n \n-#[allow(clippy::many_single_char_names, clippy::double_parens)]\n+#[allow(clippy::double_parens)]\n #[allow(unused_variables, unused_parens)]\n fn main() {\n     let a = 10;"}, {"sha": "be7cc669b5b6daf3c0cb855d6fe861e7920e943e", "filename": "tests/ui/deref_addrof.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fderef_addrof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fderef_addrof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -9,7 +9,7 @@ fn get_reference(n: &usize) -> &usize {\n     n\n }\n \n-#[allow(clippy::many_single_char_names, clippy::double_parens)]\n+#[allow(clippy::double_parens)]\n #[allow(unused_variables, unused_parens)]\n fn main() {\n     let a = 10;"}, {"sha": "ebbc0c77e32656caae3a17245d8042c2de0f6af3", "filename": "tests/ui/derivable_impls.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderivable_impls.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -167,4 +167,44 @@ impl Default for WithoutSelfParan {\n     }\n }\n \n+// https://github.com/rust-lang/rust-clippy/issues/7655\n+\n+pub struct SpecializedImpl2<T> {\n+    v: Vec<T>,\n+}\n+\n+impl Default for SpecializedImpl2<String> {\n+    fn default() -> Self {\n+        Self { v: Vec::new() }\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/7654\n+\n+pub struct Color {\n+    pub r: u8,\n+    pub g: u8,\n+    pub b: u8,\n+}\n+\n+/// `#000000`\n+impl Default for Color {\n+    fn default() -> Self {\n+        Color { r: 0, g: 0, b: 0 }\n+    }\n+}\n+\n+pub struct Color2 {\n+    pub r: u8,\n+    pub g: u8,\n+    pub b: u8,\n+}\n+\n+impl Default for Color2 {\n+    /// `#000000`\n+    fn default() -> Self {\n+        Self { r: 0, g: 0, b: 0 }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "707b449f82e4f04ea4e85b4efeb76b17820aaa33", "filename": "tests/ui/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -2,7 +2,7 @@\n \n #[rustfmt::skip]\n #[warn(clippy::eq_op)]\n-#[allow(clippy::identity_op, clippy::double_parens, clippy::many_single_char_names)]\n+#[allow(clippy::identity_op, clippy::double_parens)]\n #[allow(clippy::no_effect, unused_variables, clippy::unnecessary_operation, clippy::short_circuit_statement)]\n #[allow(clippy::nonminimal_bool)]\n #[allow(unused)]"}, {"sha": "1de79667f55fb51132117565b5197338612f4b73", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -4,7 +4,6 @@\n     unused,\n     clippy::no_effect,\n     clippy::redundant_closure_call,\n-    clippy::many_single_char_names,\n     clippy::needless_pass_by_value,\n     clippy::option_map_unit_fn\n )]\n@@ -14,7 +13,7 @@\n     clippy::needless_borrow\n )]\n \n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n macro_rules! mac {\n     () => {\n@@ -30,19 +29,18 @@ macro_rules! closure_mac {\n \n fn main() {\n     let a = Some(1u8).map(foo);\n-    meta(foo);\n     let c = Some(1u8).map(|a| {1+2; foo}(a));\n     true.then(|| mac!()); // don't lint function in macro expansion\n     Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n     let _: Option<Vec<u8>> = true.then(std::vec::Vec::new); // special case vec!\n-    let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n-    all(&[1, 2, 3], &2, |x, y| below(x, y)); //is adjusted\n+    let d = Some(1u8).map(|a| foo(foo2(a))); //is adjusted?\n+    all(&[1, 2, 3], &2, below); //is adjusted\n     unsafe {\n         Some(1u8).map(|a| unsafe_fn(a)); // unsafe fn\n     }\n \n     // See #815\n-    let e = Some(1u8).map(|a| divergent(a));\n+    let e = Some(1u8).map(divergent);\n     let e = Some(1u8).map(generic);\n     let e = Some(1u8).map(generic);\n     // See #515\n@@ -90,24 +88,17 @@ impl<'a> std::ops::Deref for TestStruct<'a> {\n fn test_redundant_closures_containing_method_calls() {\n     let i = 10;\n     let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n-    let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n     let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo_ref());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n-    let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     unsafe {\n         let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo_unsafe());\n     }\n     let e = Some(\"str\").map(std::string::ToString::to_string);\n-    let e = Some(\"str\").map(str::to_string);\n-    let e = Some('a').map(char::to_uppercase);\n     let e = Some('a').map(char::to_uppercase);\n     let e: std::vec::Vec<usize> = vec!['a', 'b', 'c'].iter().map(|c| c.len_utf8()).collect();\n     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let p = Some(PathBuf::new());\n-    let e = p.as_ref().and_then(|s| s.to_str());\n+    let e = Some(PathBuf::new()).as_ref().and_then(|s| s.to_str());\n     let c = Some(TestStruct { some_ref: &i })\n         .as_ref()\n         .map(|c| c.to_ascii_uppercase());\n@@ -119,10 +110,6 @@ fn test_redundant_closures_containing_method_calls() {\n         t.iter().filter(|x| x.trait_foo_ref());\n         t.iter().map(|x| x.trait_foo_ref());\n     }\n-\n-    let mut some = Some(|x| x * x);\n-    let arr = [Ok(1), Err(2)];\n-    let _: Vec<_> = arr.iter().map(|x| x.map_err(|e| some.take().unwrap()(e))).collect();\n }\n \n struct Thunk<T>(Box<dyn FnMut() -> T>);\n@@ -145,13 +132,6 @@ fn foobar() {\n     thunk.unwrap()\n }\n \n-fn meta<F>(f: F)\n-where\n-    F: Fn(u8),\n-{\n-    f(1u8)\n-}\n-\n fn foo(_: u8) {}\n \n fn foo2(_: u8) -> u8 {\n@@ -180,7 +160,7 @@ fn generic<T>(_: T) -> u8 {\n }\n \n fn passes_fn_mut(mut x: Box<dyn FnMut()>) {\n-    requires_fn_once(|| x());\n+    requires_fn_once(x);\n }\n fn requires_fn_once<T: FnOnce()>(_: T) {}\n \n@@ -236,3 +216,35 @@ fn mutable_closure_in_loop() {\n         Some(1).map(&mut closure);\n     }\n }\n+\n+fn late_bound_lifetimes() {\n+    fn take_asref_path<P: AsRef<Path>>(path: P) {}\n+\n+    fn map_str<F>(thunk: F)\n+    where\n+        F: FnOnce(&str),\n+    {\n+    }\n+\n+    fn map_str_to_path<F>(thunk: F)\n+    where\n+        F: FnOnce(&str) -> &Path,\n+    {\n+    }\n+    map_str(|s| take_asref_path(s));\n+    map_str_to_path(std::convert::AsRef::as_ref);\n+}\n+\n+mod type_param_bound {\n+    trait Trait {\n+        fn fun();\n+    }\n+\n+    fn take<T: 'static>(_: T) {}\n+\n+    fn test<X: Trait>() {\n+        // don't lint, but it's questionable that rust requires a cast\n+        take(|| X::fun());\n+        take(X::fun as fn());\n+    }\n+}"}, {"sha": "86abd347baa7885645fed4ebefe3f7d2d985d1ce", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -4,7 +4,6 @@\n     unused,\n     clippy::no_effect,\n     clippy::redundant_closure_call,\n-    clippy::many_single_char_names,\n     clippy::needless_pass_by_value,\n     clippy::option_map_unit_fn\n )]\n@@ -14,7 +13,7 @@\n     clippy::needless_borrow\n )]\n \n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n macro_rules! mac {\n     () => {\n@@ -30,7 +29,6 @@ macro_rules! closure_mac {\n \n fn main() {\n     let a = Some(1u8).map(|a| foo(a));\n-    meta(|a| foo(a));\n     let c = Some(1u8).map(|a| {1+2; foo}(a));\n     true.then(|| mac!()); // don't lint function in macro expansion\n     Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n@@ -90,24 +88,17 @@ impl<'a> std::ops::Deref for TestStruct<'a> {\n fn test_redundant_closures_containing_method_calls() {\n     let i = 10;\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo_ref());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n-    let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     unsafe {\n         let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo_unsafe());\n     }\n     let e = Some(\"str\").map(|s| s.to_string());\n-    let e = Some(\"str\").map(str::to_string);\n     let e = Some('a').map(|s| s.to_uppercase());\n-    let e = Some('a').map(char::to_uppercase);\n     let e: std::vec::Vec<usize> = vec!['a', 'b', 'c'].iter().map(|c| c.len_utf8()).collect();\n     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n-    let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let p = Some(PathBuf::new());\n-    let e = p.as_ref().and_then(|s| s.to_str());\n+    let e = Some(PathBuf::new()).as_ref().and_then(|s| s.to_str());\n     let c = Some(TestStruct { some_ref: &i })\n         .as_ref()\n         .map(|c| c.to_ascii_uppercase());\n@@ -119,10 +110,6 @@ fn test_redundant_closures_containing_method_calls() {\n         t.iter().filter(|x| x.trait_foo_ref());\n         t.iter().map(|x| x.trait_foo_ref());\n     }\n-\n-    let mut some = Some(|x| x * x);\n-    let arr = [Ok(1), Err(2)];\n-    let _: Vec<_> = arr.iter().map(|x| x.map_err(|e| some.take().unwrap()(e))).collect();\n }\n \n struct Thunk<T>(Box<dyn FnMut() -> T>);\n@@ -145,13 +132,6 @@ fn foobar() {\n     thunk.unwrap()\n }\n \n-fn meta<F>(f: F)\n-where\n-    F: Fn(u8),\n-{\n-    f(1u8)\n-}\n-\n fn foo(_: u8) {}\n \n fn foo2(_: u8) -> u8 {\n@@ -236,3 +216,35 @@ fn mutable_closure_in_loop() {\n         Some(1).map(|n| closure(n));\n     }\n }\n+\n+fn late_bound_lifetimes() {\n+    fn take_asref_path<P: AsRef<Path>>(path: P) {}\n+\n+    fn map_str<F>(thunk: F)\n+    where\n+        F: FnOnce(&str),\n+    {\n+    }\n+\n+    fn map_str_to_path<F>(thunk: F)\n+    where\n+        F: FnOnce(&str) -> &Path,\n+    {\n+    }\n+    map_str(|s| take_asref_path(s));\n+    map_str_to_path(|s| s.as_ref());\n+}\n+\n+mod type_param_bound {\n+    trait Trait {\n+        fn fun();\n+    }\n+\n+    fn take<T: 'static>(_: T) {}\n+\n+    fn test<X: Trait>() {\n+        // don't lint, but it's questionable that rust requires a cast\n+        take(|| X::fun());\n+        take(X::fun as fn());\n+    }\n+}"}, {"sha": "8092f04c3fc3d28215844fdb850e19196da77bd3", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,110 +1,134 @@\n error: redundant closure\n-  --> $DIR/eta.rs:32:27\n+  --> $DIR/eta.rs:31:27\n    |\n LL |     let a = Some(1u8).map(|a| foo(a));\n    |                           ^^^^^^^^^^ help: replace the closure with the function itself: `foo`\n    |\n    = note: `-D clippy::redundant-closure` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:33:10\n+  --> $DIR/eta.rs:35:40\n    |\n-LL |     meta(|a| foo(a));\n-   |          ^^^^^^^^^^ help: replace the closure with the function itself: `foo`\n+LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n+   |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n \n error: redundant closure\n-  --> $DIR/eta.rs:37:40\n+  --> $DIR/eta.rs:36:35\n    |\n-LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n-   |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n+LL |     let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n+   |                                   ^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo2`\n \n error: this expression borrows a reference (`&u8`) that is immediately dereferenced by the compiler\n-  --> $DIR/eta.rs:39:21\n+  --> $DIR/eta.rs:37:21\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                     ^^^ help: change this to: `&2`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:46:27\n+  --> $DIR/eta.rs:37:26\n+   |\n+LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n+   |                          ^^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `below`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:43:27\n+   |\n+LL |     let e = Some(1u8).map(|a| divergent(a));\n+   |                           ^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `divergent`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:44:27\n    |\n LL |     let e = Some(1u8).map(|a| generic(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `generic`\n \n error: redundant closure\n-  --> $DIR/eta.rs:92:51\n+  --> $DIR/eta.rs:90:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n    |                                                   ^^^^^^^^^^^ help: replace the closure with the method itself: `TestStruct::foo`\n    |\n    = note: `-D clippy::redundant-closure-for-method-calls` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:94:51\n+  --> $DIR/eta.rs:91:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n    |                                                   ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `TestTrait::trait_foo`\n \n error: redundant closure\n-  --> $DIR/eta.rs:97:42\n+  --> $DIR/eta.rs:93:42\n    |\n LL |     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n    |                                          ^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::vec::Vec::clear`\n \n error: redundant closure\n-  --> $DIR/eta.rs:102:29\n+  --> $DIR/eta.rs:97:29\n    |\n LL |     let e = Some(\"str\").map(|s| s.to_string());\n    |                             ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::string::ToString::to_string`\n \n error: redundant closure\n-  --> $DIR/eta.rs:104:27\n+  --> $DIR/eta.rs:98:27\n    |\n LL |     let e = Some('a').map(|s| s.to_uppercase());\n    |                           ^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:107:65\n+  --> $DIR/eta.rs:100:65\n    |\n LL |     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n    |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_ascii_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:190:27\n+  --> $DIR/eta.rs:163:22\n+   |\n+LL |     requires_fn_once(|| x());\n+   |                      ^^^^^^ help: replace the closure with the function itself: `x`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:170:27\n    |\n LL |     let a = Some(1u8).map(|a| foo_ptr(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo_ptr`\n \n error: redundant closure\n-  --> $DIR/eta.rs:195:27\n+  --> $DIR/eta.rs:175:27\n    |\n LL |     let a = Some(1u8).map(|a| closure(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `closure`\n \n error: redundant closure\n-  --> $DIR/eta.rs:227:28\n+  --> $DIR/eta.rs:207:28\n    |\n LL |     x.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:228:28\n+  --> $DIR/eta.rs:208:28\n    |\n LL |     y.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:229:28\n+  --> $DIR/eta.rs:209:28\n    |\n LL |     z.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:236:21\n+  --> $DIR/eta.rs:216:21\n    |\n LL |         Some(1).map(|n| closure(n));\n    |                     ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut closure`\n \n-error: aborting due to 17 previous errors\n+error: redundant closure\n+  --> $DIR/eta.rs:235:21\n+   |\n+LL |     map_str_to_path(|s| s.as_ref());\n+   |                     ^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::convert::AsRef::as_ref`\n+\n+error: aborting due to 21 previous errors\n "}, {"sha": "8e6a32b7be33d2eccde04199653c2d467942f3c0", "filename": "tests/ui/eval_order_dependence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feval_order_dependence.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -4,7 +4,6 @@\n #[allow(\n     unused_assignments,\n     unused_variables,\n-    clippy::many_single_char_names,\n     clippy::no_effect,\n     dead_code,\n     clippy::blacklisted_name"}, {"sha": "4f611e308e18619e50f0b408ed7c07f60c28b47d", "filename": "tests/ui/eval_order_dependence.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feval_order_dependence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Feval_order_dependence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feval_order_dependence.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,48 +1,48 @@\n error: unsequenced read of `x`\n-  --> $DIR/eval_order_dependence.rs:17:9\n+  --> $DIR/eval_order_dependence.rs:16:9\n    |\n LL |     } + x;\n    |         ^\n    |\n    = note: `-D clippy::eval-order-dependence` implied by `-D warnings`\n note: whether read occurs before this write depends on evaluation order\n-  --> $DIR/eval_order_dependence.rs:15:9\n+  --> $DIR/eval_order_dependence.rs:14:9\n    |\n LL |         x = 1;\n    |         ^^^^^\n \n error: unsequenced read of `x`\n-  --> $DIR/eval_order_dependence.rs:20:5\n+  --> $DIR/eval_order_dependence.rs:19:5\n    |\n LL |     x += {\n    |     ^\n    |\n note: whether read occurs before this write depends on evaluation order\n-  --> $DIR/eval_order_dependence.rs:21:9\n+  --> $DIR/eval_order_dependence.rs:20:9\n    |\n LL |         x = 20;\n    |         ^^^^^^\n \n error: unsequenced read of `x`\n-  --> $DIR/eval_order_dependence.rs:33:12\n+  --> $DIR/eval_order_dependence.rs:32:12\n    |\n LL |         a: x,\n    |            ^\n    |\n note: whether read occurs before this write depends on evaluation order\n-  --> $DIR/eval_order_dependence.rs:35:13\n+  --> $DIR/eval_order_dependence.rs:34:13\n    |\n LL |             x = 6;\n    |             ^^^^^\n \n error: unsequenced read of `x`\n-  --> $DIR/eval_order_dependence.rs:42:9\n+  --> $DIR/eval_order_dependence.rs:41:9\n    |\n LL |         x += {\n    |         ^\n    |\n note: whether read occurs before this write depends on evaluation order\n-  --> $DIR/eval_order_dependence.rs:43:13\n+  --> $DIR/eval_order_dependence.rs:42:13\n    |\n LL |             x = 20;\n    |             ^^^^^^"}, {"sha": "90376620a9fd835d867fbe9b7bdc8538321628cc", "filename": "tests/ui/excessive_precision.fixed", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fexcessive_precision.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fexcessive_precision.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -17,8 +17,8 @@ fn main() {\n     const BAD32_3: f32 = 0.1;\n     const BAD32_EDGE: f32 = 1.000_001;\n \n-    const BAD64_1: f64 = 0.123_456_789_012_345_66_f64;\n-    const BAD64_2: f64 = 0.123_456_789_012_345_66;\n+    const BAD64_1: f64 = 0.123_456_789_012_345_67f64;\n+    const BAD64_2: f64 = 0.123_456_789_012_345_67;\n     const BAD64_3: f64 = 0.1;\n \n     // Literal as param\n@@ -37,9 +37,9 @@ fn main() {\n     let bad32_suf: f32 = 1.123_456_8_f32;\n     let bad32_inf = 1.123_456_8_f32;\n \n-    let bad64: f64 = 0.123_456_789_012_345_66;\n-    let bad64_suf: f64 = 0.123_456_789_012_345_66_f64;\n-    let bad64_inf = 0.123_456_789_012_345_66;\n+    let bad64: f64 = 0.123_456_789_012_345_67;\n+    let bad64_suf: f64 = 0.123_456_789_012_345_67f64;\n+    let bad64_inf = 0.123_456_789_012_345_67;\n \n     // Vectors\n     let good_vec32: Vec<f32> = vec![0.123_456];"}, {"sha": "e59c20c30b4fda7bbfcceb15b60f2ceff69d9cb4", "filename": "tests/ui/excessive_precision.stderr", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fexcessive_precision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fexcessive_precision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -24,18 +24,6 @@ error: float has excessive precision\n LL |     const BAD32_EDGE: f32 = 1.000_000_9;\n    |                             ^^^^^^^^^^^ help: consider changing the type or truncating it to: `1.000_001`\n \n-error: float has excessive precision\n-  --> $DIR/excessive_precision.rs:20:26\n-   |\n-LL |     const BAD64_1: f64 = 0.123_456_789_012_345_67f64;\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66_f64`\n-\n-error: float has excessive precision\n-  --> $DIR/excessive_precision.rs:21:26\n-   |\n-LL |     const BAD64_2: f64 = 0.123_456_789_012_345_67;\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66`\n-\n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:22:26\n    |\n@@ -66,24 +54,6 @@ error: float has excessive precision\n LL |     let bad32_inf = 1.123_456_789_f32;\n    |                     ^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `1.123_456_8_f32`\n \n-error: float has excessive precision\n-  --> $DIR/excessive_precision.rs:40:22\n-   |\n-LL |     let bad64: f64 = 0.123_456_789_012_345_67;\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66`\n-\n-error: float has excessive precision\n-  --> $DIR/excessive_precision.rs:41:26\n-   |\n-LL |     let bad64_suf: f64 = 0.123_456_789_012_345_67f64;\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66_f64`\n-\n-error: float has excessive precision\n-  --> $DIR/excessive_precision.rs:42:21\n-   |\n-LL |     let bad64_inf = 0.123_456_789_012_345_67;\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.123_456_789_012_345_66`\n-\n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:48:36\n    |\n@@ -108,5 +78,5 @@ error: float has excessive precision\n LL |     let bad_bige32: f32 = 1.123_456_788_888E-10;\n    |                           ^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `1.123_456_8E-10`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "48e2aae75d0bf62893c56b4a375d7f9054e5f6c9", "filename": "tests/ui/explicit_deref_methods.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fexplicit_deref_methods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fexplicit_deref_methods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_variables, clippy::many_single_char_names, clippy::clone_double_ref)]\n+#![allow(unused_variables, clippy::clone_double_ref)]\n #![warn(clippy::explicit_deref_methods)]\n \n use std::ops::{Deref, DerefMut};"}, {"sha": "d8c8c0c5ca329c52d703180117d472391d1888b0", "filename": "tests/ui/explicit_deref_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fexplicit_deref_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fexplicit_deref_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_variables, clippy::many_single_char_names, clippy::clone_double_ref)]\n+#![allow(unused_variables, clippy::clone_double_ref)]\n #![warn(clippy::explicit_deref_methods)]\n \n use std::ops::{Deref, DerefMut};"}, {"sha": "495cd97e05e15d472bef961da5a2e9eab1573814", "filename": "tests/ui/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffallible_impl_from.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,4 +1,5 @@\n #![deny(clippy::fallible_impl_from)]\n+#![allow(clippy::if_then_panic)]\n \n // docs example\n struct Foo(i32);"}, {"sha": "8b8054586e690ecef0fd4f0b794494d1005616b7", "filename": "tests/ui/fallible_impl_from.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffallible_impl_from.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffallible_impl_from.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffallible_impl_from.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n error: consider implementing `TryFrom` instead\n-  --> $DIR/fallible_impl_from.rs:5:1\n+  --> $DIR/fallible_impl_from.rs:6:1\n    |\n LL | / impl From<String> for Foo {\n LL | |     fn from(s: String) -> Self {\n@@ -15,13 +15,13 @@ LL | #![deny(clippy::fallible_impl_from)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail\n note: potential failure(s)\n-  --> $DIR/fallible_impl_from.rs:7:13\n+  --> $DIR/fallible_impl_from.rs:8:13\n    |\n LL |         Foo(s.parse().unwrap())\n    |             ^^^^^^^^^^^^^^^^^^\n \n error: consider implementing `TryFrom` instead\n-  --> $DIR/fallible_impl_from.rs:26:1\n+  --> $DIR/fallible_impl_from.rs:27:1\n    |\n LL | / impl From<usize> for Invalid {\n LL | |     fn from(i: usize) -> Invalid {\n@@ -34,14 +34,14 @@ LL | | }\n    |\n    = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail\n note: potential failure(s)\n-  --> $DIR/fallible_impl_from.rs:29:13\n+  --> $DIR/fallible_impl_from.rs:30:13\n    |\n LL |             panic!();\n    |             ^^^^^^^^^\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: consider implementing `TryFrom` instead\n-  --> $DIR/fallible_impl_from.rs:35:1\n+  --> $DIR/fallible_impl_from.rs:36:1\n    |\n LL | / impl From<Option<String>> for Invalid {\n LL | |     fn from(s: Option<String>) -> Invalid {\n@@ -54,7 +54,7 @@ LL | | }\n    |\n    = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail\n note: potential failure(s)\n-  --> $DIR/fallible_impl_from.rs:37:17\n+  --> $DIR/fallible_impl_from.rs:38:17\n    |\n LL |         let s = s.unwrap();\n    |                 ^^^^^^^^^^\n@@ -68,7 +68,7 @@ LL |             panic!(\"{:?}\", s);\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: consider implementing `TryFrom` instead\n-  --> $DIR/fallible_impl_from.rs:53:1\n+  --> $DIR/fallible_impl_from.rs:54:1\n    |\n LL | / impl<'a> From<&'a mut <Box<u32> as ProjStrTrait>::ProjString> for Invalid {\n LL | |     fn from(s: &'a mut <Box<u32> as ProjStrTrait>::ProjString) -> Invalid {\n@@ -81,7 +81,7 @@ LL | | }\n    |\n    = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail\n note: potential failure(s)\n-  --> $DIR/fallible_impl_from.rs:55:12\n+  --> $DIR/fallible_impl_from.rs:56:12\n    |\n LL |         if s.parse::<u32>().ok().unwrap() != 42 {\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "a34458b9419516964d651f7fb281bec654d01604", "filename": "tests/ui/float_cmp.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -4,8 +4,7 @@\n     clippy::no_effect,\n     clippy::op_ref,\n     clippy::unnecessary_operation,\n-    clippy::cast_lossless,\n-    clippy::many_single_char_names\n+    clippy::cast_lossless\n )]\n \n use std::ops::Add;"}, {"sha": "9cc1f1b75ed4492d679c55b200117670e7a61f9d", "filename": "tests/ui/float_cmp.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffloat_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffloat_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:58:5\n+  --> $DIR/float_cmp.rs:57:5\n    |\n LL |     ONE as f64 != 2.0;\n    |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(ONE as f64 - 2.0).abs() > error_margin`\n@@ -8,39 +8,39 @@ LL |     ONE as f64 != 2.0;\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:63:5\n+  --> $DIR/float_cmp.rs:62:5\n    |\n LL |     x == 1.0;\n    |     ^^^^^^^^ help: consider comparing them within some margin of error: `(x - 1.0).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:66:5\n+  --> $DIR/float_cmp.rs:65:5\n    |\n LL |     twice(x) != twice(ONE as f64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(twice(x) - twice(ONE as f64)).abs() > error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:86:5\n+  --> $DIR/float_cmp.rs:85:5\n    |\n LL |     NON_ZERO_ARRAY[i] == NON_ZERO_ARRAY[j];\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(NON_ZERO_ARRAY[i] - NON_ZERO_ARRAY[j]).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` arrays\n-  --> $DIR/float_cmp.rs:91:5\n+  --> $DIR/float_cmp.rs:90:5\n    |\n LL |     a1 == a2;\n    |     ^^^^^^^^\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:92:5\n+  --> $DIR/float_cmp.rs:91:5\n    |\n LL |     a1[0] == a2[0];\n    |     ^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(a1[0] - a2[0]).abs() < error_margin`"}, {"sha": "f0e4835415f306411b1a6d97049e9abc361194af", "filename": "tests/ui/for_loop_fixable.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffor_loop_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffor_loop_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -29,7 +29,7 @@ impl Unrelated {\n     clippy::unnecessary_mut_passed,\n     clippy::similar_names\n )]\n-#[allow(clippy::many_single_char_names, unused_variables)]\n+#[allow(unused_variables)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n "}, {"sha": "1edef175fb9833e297a91c5c7d550e2884e57e49", "filename": "tests/ui/for_loop_fixable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffor_loop_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ffor_loop_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -29,7 +29,7 @@ impl Unrelated {\n     clippy::unnecessary_mut_passed,\n     clippy::similar_names\n )]\n-#[allow(clippy::many_single_char_names, unused_variables)]\n+#[allow(unused_variables)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n "}, {"sha": "fc57ae0dfa5ee0a50a919966ebff18bcc03878ad", "filename": "tests/ui/if_then_panic.fixed", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fif_then_panic.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fif_then_panic.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_then_panic.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+#![warn(clippy::if_then_panic)]\n+\n+fn main() {\n+    let a = vec![1, 2, 3];\n+    let c = Some(2);\n+    if !a.is_empty()\n+        && a.len() == 3\n+        && c != None\n+        && !a.is_empty()\n+        && a.len() == 3\n+        && !a.is_empty()\n+        && a.len() == 3\n+        && !a.is_empty()\n+        && a.len() == 3\n+    {\n+        panic!(\"qaqaq{:?}\", a);\n+    }\n+    assert!(a.is_empty(), \"qaqaq{:?}\", a);\n+    assert!(a.is_empty(), \"qwqwq\");\n+    if a.len() == 3 {\n+        println!(\"qwq\");\n+        println!(\"qwq\");\n+        println!(\"qwq\");\n+    }\n+    if let Some(b) = c {\n+        panic!(\"orz {}\", b);\n+    }\n+    if a.len() == 3 {\n+        panic!(\"qaqaq\");\n+    } else {\n+        println!(\"qwq\");\n+    }\n+}"}, {"sha": "d1ac93d8d413ccedbb5208f38e47c47c7b449b10", "filename": "tests/ui/if_then_panic.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fif_then_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fif_then_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_then_panic.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,38 @@\n+// run-rustfix\n+#![warn(clippy::if_then_panic)]\n+\n+fn main() {\n+    let a = vec![1, 2, 3];\n+    let c = Some(2);\n+    if !a.is_empty()\n+        && a.len() == 3\n+        && c != None\n+        && !a.is_empty()\n+        && a.len() == 3\n+        && !a.is_empty()\n+        && a.len() == 3\n+        && !a.is_empty()\n+        && a.len() == 3\n+    {\n+        panic!(\"qaqaq{:?}\", a);\n+    }\n+    if !a.is_empty() {\n+        panic!(\"qaqaq{:?}\", a);\n+    }\n+    if !a.is_empty() {\n+        panic!(\"qwqwq\");\n+    }\n+    if a.len() == 3 {\n+        println!(\"qwq\");\n+        println!(\"qwq\");\n+        println!(\"qwq\");\n+    }\n+    if let Some(b) = c {\n+        panic!(\"orz {}\", b);\n+    }\n+    if a.len() == 3 {\n+        panic!(\"qaqaq\");\n+    } else {\n+        println!(\"qwq\");\n+    }\n+}"}, {"sha": "b92c9bdf67430872509c0da4429b0d04dde498e1", "filename": "tests/ui/if_then_panic.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fif_then_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fif_then_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_then_panic.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,20 @@\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/if_then_panic.rs:19:5\n+   |\n+LL | /     if !a.is_empty() {\n+LL | |         panic!(\"qaqaq{:?}\", a);\n+LL | |     }\n+   | |_____^ help: try: `assert!(a.is_empty(), \"qaqaq{:?}\", a);`\n+   |\n+   = note: `-D clippy::if-then-panic` implied by `-D warnings`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/if_then_panic.rs:22:5\n+   |\n+LL | /     if !a.is_empty() {\n+LL | |         panic!(\"qwqwq\");\n+LL | |     }\n+   | |_____^ help: try: `assert!(a.is_empty(), \"qwqwq\");`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e86bd7bcf4faf0e5ed40c749fd0383b60fba22bc", "filename": "tests/ui/infinite_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -16,7 +16,6 @@ fn foob() -> bool {\n     unimplemented!()\n }\n \n-#[allow(clippy::many_single_char_names)]\n fn immutable_condition() {\n     // Should warn when all vars mentioned are immutable\n     let y = 0;"}, {"sha": "69309b0da877cdbbd6c6ae2cf85749f56e2fdfb0", "filename": "tests/ui/infinite_loop.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:23:11\n+  --> $DIR/infinite_loop.rs:22:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^\n@@ -8,71 +8,71 @@ LL |     while y < 10 {\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:28:11\n+  --> $DIR/infinite_loop.rs:27:11\n    |\n LL |     while y < 10 && x < 3 {\n    |           ^^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:35:11\n+  --> $DIR/infinite_loop.rs:34:11\n    |\n LL |     while !cond {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:79:11\n+  --> $DIR/infinite_loop.rs:78:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:84:11\n+  --> $DIR/infinite_loop.rs:83:11\n    |\n LL |     while i < 3 && j > 0 {\n    |           ^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:88:11\n+  --> $DIR/infinite_loop.rs:87:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:103:11\n+  --> $DIR/infinite_loop.rs:102:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:108:11\n+  --> $DIR/infinite_loop.rs:107:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:174:15\n+  --> $DIR/infinite_loop.rs:173:15\n    |\n LL |         while self.count < n {\n    |               ^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:182:11\n+  --> $DIR/infinite_loop.rs:181:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^\n@@ -82,7 +82,7 @@ LL |     while y < 10 {\n    = help: rewrite it as `if cond { loop { } }`\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:189:11\n+  --> $DIR/infinite_loop.rs:188:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^"}, {"sha": "aeb0a0c1e2e841814d5168ee241db632caae43ef", "filename": "tests/ui/inherent_to_string.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finherent_to_string.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,5 @@\n #![warn(clippy::inherent_to_string)]\n #![deny(clippy::inherent_to_string_shadow_display)]\n-#![allow(clippy::many_single_char_names)]\n \n use std::fmt;\n "}, {"sha": "4f331f5bec9e6fe87073d1cdb63991862db4bf28", "filename": "tests/ui/inherent_to_string.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Finherent_to_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Finherent_to_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finherent_to_string.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n error: implementation of inherent method `to_string(&self) -> String` for type `A`\n-  --> $DIR/inherent_to_string.rs:21:5\n+  --> $DIR/inherent_to_string.rs:20:5\n    |\n LL | /     fn to_string(&self) -> String {\n LL | |         \"A.to_string()\".to_string()\n@@ -10,7 +10,7 @@ LL | |     }\n    = help: implement trait `Display` for type `A` instead\n \n error: type `C` implements inherent method `to_string(&self) -> String` which shadows the implementation of `Display`\n-  --> $DIR/inherent_to_string.rs:45:5\n+  --> $DIR/inherent_to_string.rs:44:5\n    |\n LL | /     fn to_string(&self) -> String {\n LL | |         \"C.to_string()\".to_string()"}, {"sha": "377f760b3c4b20c26ad51cb0d3d1b5dd8169aa01", "filename": "tests/ui/iter_not_returning_iterator.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_not_returning_iterator.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,47 @@\n+#![warn(clippy::iter_not_returning_iterator)]\n+\n+struct Data {\n+    begin: u32,\n+}\n+\n+struct Counter {\n+    count: u32,\n+}\n+\n+impl Data {\n+    fn iter(&self) -> Counter {\n+        todo!()\n+    }\n+\n+    fn iter_mut(&self) -> Counter {\n+        todo!()\n+    }\n+}\n+\n+struct Data2 {\n+    begin: u32,\n+}\n+\n+struct Counter2 {\n+    count: u32,\n+}\n+\n+impl Data2 {\n+    fn iter(&self) -> Counter2 {\n+        todo!()\n+    }\n+\n+    fn iter_mut(&self) -> Counter2 {\n+        todo!()\n+    }\n+}\n+\n+impl Iterator for Counter {\n+    type Item = u32;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        todo!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2273cd0be66ffe2c11562a78733726214feb951e", "filename": "tests/ui/iter_not_returning_iterator.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fiter_not_returning_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fiter_not_returning_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_not_returning_iterator.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,16 @@\n+error: this method is named `iter` but its return type does not implement `Iterator`\n+  --> $DIR/iter_not_returning_iterator.rs:30:5\n+   |\n+LL |     fn iter(&self) -> Counter2 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::iter-not-returning-iterator` implied by `-D warnings`\n+\n+error: this method is named `iter_mut` but its return type does not implement `Iterator`\n+  --> $DIR/iter_not_returning_iterator.rs:34:5\n+   |\n+LL |     fn iter_mut(&self) -> Counter2 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4eaa2dd98eb2e386ae21e4bed3695a74a63b8896", "filename": "tests/ui/logic_bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Flogic_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Flogic_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flogic_bug.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused, clippy::many_single_char_names, clippy::diverging_sub_expression)]\n+#![allow(unused, clippy::diverging_sub_expression)]\n #![warn(clippy::logic_bug)]\n \n fn main() {"}, {"sha": "992baf1f185a710ae1d7d3ba70207821ee9044b0", "filename": "tests/ui/manual_split_once.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -36,6 +36,12 @@ fn main() {\n \n     // Don't lint, slices don't have `split_once`\n     let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+\n+    // `rsplitn` gives the results in the reverse order of `rsplit_once`\n+    let _ = \"key=value\".rsplit_once('=').unwrap().1;\n+    let _ = \"key=value\".rsplit_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".rsplit_once('=').map(|x| x.1);\n+    let (_, _) = \"key=value\".rsplit_once('=').map(|(x, y)| (y, x)).unwrap();\n }\n \n fn _msrv_1_51() {"}, {"sha": "4f92ab6b812bd87fe642d43e2fceff2d963e8116", "filename": "tests/ui/manual_split_once.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -36,6 +36,12 @@ fn main() {\n \n     // Don't lint, slices don't have `split_once`\n     let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+\n+    // `rsplitn` gives the results in the reverse order of `rsplit_once`\n+    let _ = \"key=value\".rsplitn(2, '=').next().unwrap();\n+    let _ = \"key=value\".rsplitn(2, '=').nth(1).unwrap();\n+    let _ = \"key=value\".rsplitn(2, '=').nth(0);\n+    let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n }\n \n fn _msrv_1_51() {"}, {"sha": "7bea2303d9213ab9d49c0d7cae676ce730738f60", "filename": "tests/ui/manual_split_once.stderr", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -72,11 +72,35 @@ error: manual implementation of `split_once`\n LL |         let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n \n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:41:13\n+   |\n+LL |     let _ = \"key=value\".rsplitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').unwrap().1`\n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:42:13\n+   |\n+LL |     let _ = \"key=value\".rsplitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:43:13\n+   |\n+LL |     let _ = \"key=value\".rsplitn(2, '=').nth(0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|x| x.1)`\n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:44:18\n+   |\n+LL |     let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|(x, y)| (y, x))`\n+\n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:49:13\n+  --> $DIR/manual_split_once.rs:55:13\n    |\n LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "65769819110eb6f00b05332c7ae0b54c6ba8fa2b", "filename": "tests/ui/many_single_char_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmany_single_char_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmany_single_char_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmany_single_char_names.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,4 +1,4 @@\n-#[warn(clippy::many_single_char_names)]\n+#![warn(clippy::many_single_char_names)]\n \n fn bla() {\n     let a: i32;"}, {"sha": "fec3a95edd62da54cddde339c8566e0fa56656e9", "filename": "tests/ui/map_flatten.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -4,6 +4,7 @@\n #![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n+#![allow(clippy::redundant_closure)]\n #![allow(clippy::unnecessary_wraps)]\n #![feature(result_flattening)]\n "}, {"sha": "aa1f76e335af0dad3a395921b3e25e6fbf82b6a4", "filename": "tests/ui/map_flatten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -4,6 +4,7 @@\n #![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n+#![allow(clippy::redundant_closure)]\n #![allow(clippy::unnecessary_wraps)]\n #![feature(result_flattening)]\n "}, {"sha": "bcd2047e6faa3d3683b11f396e6a818855c94d21", "filename": "tests/ui/map_flatten.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,43 +1,43 @@\n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:17:46\n+  --> $DIR/map_flatten.rs:18:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:18:46\n+  --> $DIR/map_flatten.rs:19:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_ref)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:19:46\n+  --> $DIR/map_flatten.rs:20:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_closure)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:20:46\n+  --> $DIR/map_flatten.rs:21:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(|x| x.checked_add(1))`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:23:46\n+  --> $DIR/map_flatten.rs:24:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `.flat_map(|x| 0..x)`\n \n error: called `map(..).flatten()` on an `Option`\n-  --> $DIR/map_flatten.rs:26:39\n+  --> $DIR/map_flatten.rs:27:39\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n    |                                       ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n \n error: called `map(..).flatten()` on an `Result`\n-  --> $DIR/map_flatten.rs:29:41\n+  --> $DIR/map_flatten.rs:30:41\n    |\n LL |     let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n    |                                         ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`"}, {"sha": "b4ec525ada09a763059d8837fc06d572051f1a4b", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::match_single_binding)]\n-#![allow(unused_variables, clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n+#![allow(unused_variables, clippy::toplevel_ref_arg)]\n \n struct Point {\n     x: i32,"}, {"sha": "e04c4018b98ddbb52e282768d113bb7e25ab4f63", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::match_single_binding)]\n-#![allow(unused_variables, clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n+#![allow(unused_variables, clippy::toplevel_ref_arg)]\n \n struct Point {\n     x: i32,"}, {"sha": "1c0ba664580a40d253923a2ec937db47efac8049", "filename": "tests/ui/mut_key.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_key.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,9 @@\n-use std::collections::{HashMap, HashSet};\n+use std::cell::Cell;\n+use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::hash::{Hash, Hasher};\n+use std::rc::Rc;\n use std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n+use std::sync::Arc;\n \n struct Key(AtomicUsize);\n \n@@ -31,11 +34,19 @@ fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<K\n \n fn this_is_ok(_m: &mut HashMap<usize, Key>) {}\n \n+// Raw pointers are hashed by the address they point to, so it doesn't matter if they point to a\n+// type with interior mutability.  See:\n+// - clippy issue: https://github.com/rust-lang/rust-clippy/issues/6745\n+// - std lib: https://github.com/rust-lang/rust/blob/1.54.0/library/core/src/hash/mod.rs#L717-L736\n+// So these are OK:\n+fn raw_ptr_is_ok(_m: &mut HashMap<*const Key, ()>) {}\n+fn raw_mut_ptr_is_ok(_m: &mut HashMap<*mut Key, ()>) {}\n+\n #[allow(unused)]\n trait Trait {\n     type AssociatedType;\n \n-    fn trait_fn(&self, set: std::collections::HashSet<Self::AssociatedType>);\n+    fn trait_fn(&self, set: HashSet<Self::AssociatedType>);\n }\n \n fn generics_are_ok_too<K>(_m: &mut HashSet<K>) {\n@@ -52,4 +63,23 @@ fn main() {\n     tuples::<Key>(&mut HashMap::new());\n     tuples::<()>(&mut HashMap::new());\n     tuples_bad::<()>(&mut HashMap::new());\n+\n+    raw_ptr_is_ok(&mut HashMap::new());\n+    raw_mut_ptr_is_ok(&mut HashMap::new());\n+\n+    let _map = HashMap::<Cell<usize>, usize>::new();\n+    let _map = HashMap::<&mut Cell<usize>, usize>::new();\n+    let _map = HashMap::<&mut usize, usize>::new();\n+    // Collection types from `std` who's impl of `Hash` or `Ord` delegate their type parameters\n+    let _map = HashMap::<Vec<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<BTreeMap<Cell<usize>, ()>, usize>::new();\n+    let _map = HashMap::<BTreeMap<(), Cell<usize>>, usize>::new();\n+    let _map = HashMap::<BTreeSet<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Option<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Option<Vec<Cell<usize>>>, usize>::new();\n+    let _map = HashMap::<Result<&mut usize, ()>, usize>::new();\n+    // Smart pointers from `std` who's impl of `Hash` or `Ord` delegate their type parameters\n+    let _map = HashMap::<Box<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Rc<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Arc<Cell<usize>>, usize>::new();\n }"}, {"sha": "25dd029b16eeea1e13b5e773613ddf27e106bd4e", "filename": "tests/ui/mut_key.stderr", "status": "modified", "additions": 83, "deletions": 5, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmut_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fmut_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_key.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,28 +1,106 @@\n error: mutable key type\n-  --> $DIR/mut_key.rs:27:32\n+  --> $DIR/mut_key.rs:30:32\n    |\n LL | fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<Key> {\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutable-key-type` implied by `-D warnings`\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:27:72\n+  --> $DIR/mut_key.rs:30:72\n    |\n LL | fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<Key> {\n    |                                                                        ^^^^^^^^^^^^\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:28:5\n+  --> $DIR/mut_key.rs:31:5\n    |\n LL |     let _other: HashMap<Key, bool> = HashMap::new();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:47:22\n+  --> $DIR/mut_key.rs:58:22\n    |\n LL | fn tuples_bad<U>(_m: &mut HashMap<(Key, U), bool>) {}\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: mutable key type\n+  --> $DIR/mut_key.rs:70:5\n+   |\n+LL |     let _map = HashMap::<Cell<usize>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:71:5\n+   |\n+LL |     let _map = HashMap::<&mut Cell<usize>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:72:5\n+   |\n+LL |     let _map = HashMap::<&mut usize, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:74:5\n+   |\n+LL |     let _map = HashMap::<Vec<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:75:5\n+   |\n+LL |     let _map = HashMap::<BTreeMap<Cell<usize>, ()>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:76:5\n+   |\n+LL |     let _map = HashMap::<BTreeMap<(), Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:77:5\n+   |\n+LL |     let _map = HashMap::<BTreeSet<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:78:5\n+   |\n+LL |     let _map = HashMap::<Option<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:79:5\n+   |\n+LL |     let _map = HashMap::<Option<Vec<Cell<usize>>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:80:5\n+   |\n+LL |     let _map = HashMap::<Result<&mut usize, ()>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:82:5\n+   |\n+LL |     let _map = HashMap::<Box<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:83:5\n+   |\n+LL |     let _map = HashMap::<Rc<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:84:5\n+   |\n+LL |     let _map = HashMap::<Arc<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "42c2bb9f4149eb48bbf2f777e859adcc88623ee0", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,17 +1,16 @@\n // run-rustfix\n \n-#![allow(clippy::needless_borrowed_reference)]\n-\n-fn x(y: &i32) -> i32 {\n-    *y\n-}\n-\n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables)]\n fn main() {\n     let a = 5;\n-    let b = x(&a);\n-    let c = x(&a);\n+    let _ = x(&a); // no warning\n+    let _ = x(&a); // warn\n+\n+    let mut b = 5;\n+    mut_ref(&mut b); // no warning\n+    mut_ref(&mut b); // warn\n+\n     let s = &String::from(\"hi\");\n     let s_ident = f(&s); // should not error, because `&String` implements Copy, but `String` does not\n     let g_val = g(&Vec::new()); // should not error, because `&Vec<T>` derefs to `&[T]`\n@@ -29,6 +28,15 @@ fn main() {\n     };\n }\n \n+#[allow(clippy::needless_borrowed_reference)]\n+fn x(y: &i32) -> i32 {\n+    *y\n+}\n+\n+fn mut_ref(y: &mut i32) {\n+    *y = 5;\n+}\n+\n fn f<T: Copy>(y: &T) -> T {\n     *y\n }"}, {"sha": "31977416bc7028738fb91c94c0a3d6dd0af4c9f9", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,17 +1,16 @@\n // run-rustfix\n \n-#![allow(clippy::needless_borrowed_reference)]\n-\n-fn x(y: &i32) -> i32 {\n-    *y\n-}\n-\n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables)]\n fn main() {\n     let a = 5;\n-    let b = x(&a);\n-    let c = x(&&a);\n+    let _ = x(&a); // no warning\n+    let _ = x(&&a); // warn\n+\n+    let mut b = 5;\n+    mut_ref(&mut b); // no warning\n+    mut_ref(&mut &mut b); // warn\n+\n     let s = &String::from(\"hi\");\n     let s_ident = f(&s); // should not error, because `&String` implements Copy, but `String` does not\n     let g_val = g(&Vec::new()); // should not error, because `&Vec<T>` derefs to `&[T]`\n@@ -29,6 +28,15 @@ fn main() {\n     };\n }\n \n+#[allow(clippy::needless_borrowed_reference)]\n+fn x(y: &i32) -> i32 {\n+    *y\n+}\n+\n+fn mut_ref(y: &mut i32) {\n+    *y = 5;\n+}\n+\n fn f<T: Copy>(y: &T) -> T {\n     *y\n }"}, {"sha": "012d62e287156f850f02871bba101d930a9bbdb7", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,16 +1,22 @@\n error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:14:15\n+  --> $DIR/needless_borrow.rs:8:15\n    |\n-LL |     let c = x(&&a);\n+LL |     let _ = x(&&a); // warn\n    |               ^^^ help: change this to: `&a`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n+error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:12:13\n+   |\n+LL |     mut_ref(&mut &mut b); // warn\n+   |             ^^^^^^^^^^^ help: change this to: `&mut b`\n+\n error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:27:15\n+  --> $DIR/needless_borrow.rs:26:15\n    |\n LL |         46 => &&a,\n    |               ^^^ help: change this to: `&a`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "5a35b100afe07620e234479856f2ccae4500cf1e", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -3,7 +3,6 @@\n     dead_code,\n     clippy::single_match,\n     clippy::redundant_pattern_matching,\n-    clippy::many_single_char_names,\n     clippy::option_option,\n     clippy::redundant_clone\n )]"}, {"sha": "d960c86a9f0ef257e1bc27ca0ae63d9335d14c5f", "filename": "tests/ui/needless_pass_by_value.stderr", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_pass_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_pass_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,61 +1,61 @@\n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:18:23\n+  --> $DIR/needless_pass_by_value.rs:17:23\n    |\n LL | fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n    |                       ^^^^^^ help: consider changing the type to: `&[T]`\n    |\n    = note: `-D clippy::needless-pass-by-value` implied by `-D warnings`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:32:11\n+  --> $DIR/needless_pass_by_value.rs:31:11\n    |\n LL | fn bar(x: String, y: Wrapper) {\n    |           ^^^^^^ help: consider changing the type to: `&str`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:32:22\n+  --> $DIR/needless_pass_by_value.rs:31:22\n    |\n LL | fn bar(x: String, y: Wrapper) {\n    |                      ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:38:71\n+  --> $DIR/needless_pass_by_value.rs:37:71\n    |\n LL | fn test_borrow_trait<T: Borrow<str>, U: AsRef<str>, V>(t: T, u: U, v: V) {\n    |                                                                       ^ help: consider taking a reference instead: `&V`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:50:18\n+  --> $DIR/needless_pass_by_value.rs:49:18\n    |\n LL | fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n    |                  ^^^^^^^^^^^^^^^^^^^^^^ help: consider taking a reference instead: `&Option<Option<String>>`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:63:24\n+  --> $DIR/needless_pass_by_value.rs:62:24\n    |\n LL | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                        ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:63:36\n+  --> $DIR/needless_pass_by_value.rs:62:36\n    |\n LL | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                                    ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:79:49\n+  --> $DIR/needless_pass_by_value.rs:78:49\n    |\n LL | fn test_blanket_ref<T: Foo, S: Serialize>(_foo: T, _serializable: S) {}\n    |                                                 ^ help: consider taking a reference instead: `&T`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:81:18\n+  --> $DIR/needless_pass_by_value.rs:80:18\n    |\n LL | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n    |                  ^^^^^^ help: consider taking a reference instead: `&String`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:81:29\n+  --> $DIR/needless_pass_by_value.rs:80:29\n    |\n LL | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n    |                             ^^^^^^\n@@ -70,13 +70,13 @@ LL |     let _ = t.to_string();\n    |             ~~~~~~~~~~~~~\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:81:40\n+  --> $DIR/needless_pass_by_value.rs:80:40\n    |\n LL | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n    |                                        ^^^^^^^^ help: consider taking a reference instead: `&Vec<i32>`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:81:53\n+  --> $DIR/needless_pass_by_value.rs:80:53\n    |\n LL | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n    |                                                     ^^^^^^^^\n@@ -91,85 +91,85 @@ LL |     let _ = v.to_owned();\n    |             ~~~~~~~~~~~~\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:94:12\n+  --> $DIR/needless_pass_by_value.rs:93:12\n    |\n LL |         s: String,\n    |            ^^^^^^ help: consider changing the type to: `&str`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:95:12\n+  --> $DIR/needless_pass_by_value.rs:94:12\n    |\n LL |         t: String,\n    |            ^^^^^^ help: consider taking a reference instead: `&String`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:104:23\n+  --> $DIR/needless_pass_by_value.rs:103:23\n    |\n LL |     fn baz(&self, _u: U, _s: Self) {}\n    |                       ^ help: consider taking a reference instead: `&U`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:104:30\n+  --> $DIR/needless_pass_by_value.rs:103:30\n    |\n LL |     fn baz(&self, _u: U, _s: Self) {}\n    |                              ^^^^ help: consider taking a reference instead: `&Self`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:126:24\n+  --> $DIR/needless_pass_by_value.rs:125:24\n    |\n LL | fn bar_copy(x: u32, y: CopyWrapper) {\n    |                        ^^^^^^^^^^^ help: consider taking a reference instead: `&CopyWrapper`\n    |\n help: consider marking this type as `Copy`\n-  --> $DIR/needless_pass_by_value.rs:124:1\n+  --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:132:29\n+  --> $DIR/needless_pass_by_value.rs:131:29\n    |\n LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: CopyWrapper) {\n    |                             ^^^^^^^^^^^ help: consider taking a reference instead: `&CopyWrapper`\n    |\n help: consider marking this type as `Copy`\n-  --> $DIR/needless_pass_by_value.rs:124:1\n+  --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:132:45\n+  --> $DIR/needless_pass_by_value.rs:131:45\n    |\n LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: CopyWrapper) {\n    |                                             ^^^^^^^^^^^ help: consider taking a reference instead: `&CopyWrapper`\n    |\n help: consider marking this type as `Copy`\n-  --> $DIR/needless_pass_by_value.rs:124:1\n+  --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:132:61\n+  --> $DIR/needless_pass_by_value.rs:131:61\n    |\n LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: CopyWrapper) {\n    |                                                             ^^^^^^^^^^^ help: consider taking a reference instead: `&CopyWrapper`\n    |\n help: consider marking this type as `Copy`\n-  --> $DIR/needless_pass_by_value.rs:124:1\n+  --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:144:40\n+  --> $DIR/needless_pass_by_value.rs:143:40\n    |\n LL | fn some_fun<'b, S: Bar<'b, ()>>(_item: S) {}\n    |                                        ^ help: consider taking a reference instead: `&S`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:149:20\n+  --> $DIR/needless_pass_by_value.rs:148:20\n    |\n LL | fn more_fun(_item: impl Club<'static, i32>) {}\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^ help: consider taking a reference instead: `&impl Club<'static, i32>`"}, {"sha": "37efa6274df7aa904b65fc99b458ad60acc4dfef", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,13 +1,9 @@\n // run-rustfix\n // edition:2018\n \n+#![feature(let_else)]\n #![allow(unused)]\n-#![allow(\n-    clippy::if_same_then_else,\n-    clippy::single_match,\n-    clippy::branches_sharing_code,\n-    clippy::needless_bool\n-)]\n+#![allow(clippy::if_same_then_else, clippy::single_match, clippy::needless_bool)]\n #![warn(clippy::needless_return)]\n \n macro_rules! the_answer {\n@@ -207,4 +203,8 @@ async fn async_test_return_in_macro() {\n     needed_return!(0);\n }\n \n+fn let_else() {\n+    let Some(1) = Some(1) else { return };\n+}\n+\n fn main() {}"}, {"sha": "cbf384ac9e4356a21548e5181947da79a0b95ad2", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,13 +1,9 @@\n // run-rustfix\n // edition:2018\n \n+#![feature(let_else)]\n #![allow(unused)]\n-#![allow(\n-    clippy::if_same_then_else,\n-    clippy::single_match,\n-    clippy::branches_sharing_code,\n-    clippy::needless_bool\n-)]\n+#![allow(clippy::if_same_then_else, clippy::single_match, clippy::needless_bool)]\n #![warn(clippy::needless_return)]\n \n macro_rules! the_answer {\n@@ -207,4 +203,8 @@ async fn async_test_return_in_macro() {\n     needed_return!(0);\n }\n \n+fn let_else() {\n+    let Some(1) = Some(1) else { return };\n+}\n+\n fn main() {}"}, {"sha": "7ce7028bbae4b1defd812911afb7a4a540d8b7fe", "filename": "tests/ui/needless_return.stderr", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,193 +1,193 @@\n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:24:5\n+  --> $DIR/needless_return.rs:20:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n    |\n    = note: `-D clippy::needless-return` implied by `-D warnings`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:28:5\n+  --> $DIR/needless_return.rs:24:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:33:9\n+  --> $DIR/needless_return.rs:29:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:35:9\n+  --> $DIR/needless_return.rs:31:9\n    |\n LL |         return false;\n    |         ^^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:41:17\n+  --> $DIR/needless_return.rs:37:17\n    |\n LL |         true => return false,\n    |                 ^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:43:13\n+  --> $DIR/needless_return.rs:39:13\n    |\n LL |             return true;\n    |             ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:50:9\n+  --> $DIR/needless_return.rs:46:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:52:16\n+  --> $DIR/needless_return.rs:48:16\n    |\n LL |     let _ = || return true;\n    |                ^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:60:5\n+  --> $DIR/needless_return.rs:56:5\n    |\n LL |     return;\n    |     ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:65:9\n+  --> $DIR/needless_return.rs:61:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:67:9\n+  --> $DIR/needless_return.rs:63:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:74:14\n+  --> $DIR/needless_return.rs:70:14\n    |\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:89:9\n+  --> $DIR/needless_return.rs:85:9\n    |\n LL |         return String::from(\"test\");\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:91:9\n+  --> $DIR/needless_return.rs:87:9\n    |\n LL |         return String::new();\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:112:32\n+  --> $DIR/needless_return.rs:108:32\n    |\n LL |         bar.unwrap_or_else(|_| return)\n    |                                ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:117:13\n+  --> $DIR/needless_return.rs:113:13\n    |\n LL |             return;\n    |             ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:119:20\n+  --> $DIR/needless_return.rs:115:20\n    |\n LL |         let _ = || return;\n    |                    ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:125:32\n+  --> $DIR/needless_return.rs:121:32\n    |\n LL |         res.unwrap_or_else(|_| return Foo)\n    |                                ^^^^^^^^^^ help: remove `return`: `Foo`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:134:5\n+  --> $DIR/needless_return.rs:130:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:138:5\n+  --> $DIR/needless_return.rs:134:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:143:9\n+  --> $DIR/needless_return.rs:139:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:145:9\n+  --> $DIR/needless_return.rs:141:9\n    |\n LL |         return false;\n    |         ^^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:151:17\n+  --> $DIR/needless_return.rs:147:17\n    |\n LL |         true => return false,\n    |                 ^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:153:13\n+  --> $DIR/needless_return.rs:149:13\n    |\n LL |             return true;\n    |             ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:160:9\n+  --> $DIR/needless_return.rs:156:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:162:16\n+  --> $DIR/needless_return.rs:158:16\n    |\n LL |     let _ = || return true;\n    |                ^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:170:5\n+  --> $DIR/needless_return.rs:166:5\n    |\n LL |     return;\n    |     ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:175:9\n+  --> $DIR/needless_return.rs:171:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:177:9\n+  --> $DIR/needless_return.rs:173:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:184:14\n+  --> $DIR/needless_return.rs:180:14\n    |\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:199:9\n+  --> $DIR/needless_return.rs:195:9\n    |\n LL |         return String::from(\"test\");\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:201:9\n+  --> $DIR/needless_return.rs:197:9\n    |\n LL |         return String::new();\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`"}, {"sha": "fa5743c11557722fecbf1216143d3b8e58b9dd20", "filename": "tests/ui/nonminimal_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fnonminimal_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fnonminimal_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnonminimal_bool.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused, clippy::many_single_char_names, clippy::diverging_sub_expression)]\n+#![allow(unused, clippy::diverging_sub_expression)]\n #![warn(clippy::nonminimal_bool)]\n \n fn main() {"}, {"sha": "d0a289b7ea43e1f88ec324c33cdbd9f11c61a406", "filename": "tests/ui/nonminimal_bool_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fnonminimal_bool_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fnonminimal_bool_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnonminimal_bool_methods.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused, clippy::many_single_char_names, clippy::diverging_sub_expression)]\n+#![allow(unused, clippy::diverging_sub_expression)]\n #![warn(clippy::nonminimal_bool)]\n \n fn methods_with_negation() {"}, {"sha": "ab9c4d34c88f6200faf8db7ed94946b7d9b724f0", "filename": "tests/ui/op_ref.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,5 @@\n #![allow(unused_variables, clippy::blacklisted_name)]\n #![warn(clippy::op_ref)]\n-#![allow(clippy::many_single_char_names)]\n use std::collections::HashSet;\n use std::ops::BitAnd;\n "}, {"sha": "992417084bda29499222b3036bcb8a8ca86dd029", "filename": "tests/ui/op_ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n error: needlessly taken reference of both operands\n-  --> $DIR/op_ref.rs:12:15\n+  --> $DIR/op_ref.rs:11:15\n    |\n LL |     let foo = &5 - &6;\n    |               ^^^^^^^\n@@ -11,7 +11,7 @@ LL |     let foo = 5 - 6;\n    |               ~   ~\n \n error: taken reference of right operand\n-  --> $DIR/op_ref.rs:57:13\n+  --> $DIR/op_ref.rs:56:13\n    |\n LL |     let z = x & &y;\n    |             ^^^^--"}, {"sha": "5db75f5291becdaa4d517874db275aa5d6cb4973", "filename": "tests/ui/overflow_check_conditional.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foverflow_check_conditional.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,4 +1,3 @@\n-#![allow(clippy::many_single_char_names)]\n #![warn(clippy::overflow_check_conditional)]\n \n fn main() {"}, {"sha": "1b8b146b60ae72558f14c5a2cb34d0272ad39276", "filename": "tests/ui/overflow_check_conditional.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Foverflow_check_conditional.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Foverflow_check_conditional.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foverflow_check_conditional.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,49 +1,49 @@\n error: you are trying to use classic C overflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:8:8\n+  --> $DIR/overflow_check_conditional.rs:7:8\n    |\n LL |     if a + b < a {}\n    |        ^^^^^^^^^\n    |\n    = note: `-D clippy::overflow-check-conditional` implied by `-D warnings`\n \n error: you are trying to use classic C overflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:9:8\n+  --> $DIR/overflow_check_conditional.rs:8:8\n    |\n LL |     if a > a + b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C overflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:10:8\n+  --> $DIR/overflow_check_conditional.rs:9:8\n    |\n LL |     if a + b < b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C overflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:11:8\n+  --> $DIR/overflow_check_conditional.rs:10:8\n    |\n LL |     if b > a + b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C underflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:12:8\n+  --> $DIR/overflow_check_conditional.rs:11:8\n    |\n LL |     if a - b > b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C underflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:13:8\n+  --> $DIR/overflow_check_conditional.rs:12:8\n    |\n LL |     if b < a - b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C underflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:14:8\n+  --> $DIR/overflow_check_conditional.rs:13:8\n    |\n LL |     if a - b > a {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C underflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:15:8\n+  --> $DIR/overflow_check_conditional.rs:14:8\n    |\n LL |     if a < a - b {}\n    |        ^^^^^^^^^"}, {"sha": "99e6d2aad8dd6b46ac5229da0866d36218688f0a", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,4 +1,9 @@\n-#![allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n+#![allow(\n+    unused,\n+    clippy::many_single_char_names,\n+    clippy::redundant_clone,\n+    clippy::if_then_panic\n+)]\n #![warn(clippy::ptr_arg)]\n \n use std::borrow::Cow;"}, {"sha": "42183447ead737cf34275a3fe9be5edf01a406c4", "filename": "tests/ui/ptr_arg.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,31 +1,31 @@\n error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:7:14\n+  --> $DIR/ptr_arg.rs:12:14\n    |\n LL | fn do_vec(x: &Vec<i64>) {\n    |              ^^^^^^^^^ help: change this to: `&[i64]`\n    |\n    = note: `-D clippy::ptr-arg` implied by `-D warnings`\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:16:14\n+  --> $DIR/ptr_arg.rs:21:14\n    |\n LL | fn do_str(x: &String) {\n    |              ^^^^^^^ help: change this to: `&str`\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:25:15\n+  --> $DIR/ptr_arg.rs:30:15\n    |\n LL | fn do_path(x: &PathBuf) {\n    |               ^^^^^^^^ help: change this to: `&Path`\n \n error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:38:18\n+  --> $DIR/ptr_arg.rs:43:18\n    |\n LL |     fn do_vec(x: &Vec<i64>);\n    |                  ^^^^^^^^^ help: change this to: `&[i64]`\n \n error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:51:14\n+  --> $DIR/ptr_arg.rs:56:14\n    |\n LL | fn cloned(x: &Vec<u8>) -> Vec<u8> {\n    |              ^^^^^^^^\n@@ -44,7 +44,7 @@ LL |     x.to_owned()\n    |\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:60:18\n+  --> $DIR/ptr_arg.rs:65:18\n    |\n LL | fn str_cloned(x: &String) -> String {\n    |                  ^^^^^^^\n@@ -67,7 +67,7 @@ LL |     x.to_string()\n    |\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:68:19\n+  --> $DIR/ptr_arg.rs:73:19\n    |\n LL | fn path_cloned(x: &PathBuf) -> PathBuf {\n    |                   ^^^^^^^^\n@@ -90,7 +90,7 @@ LL |     x.to_path_buf()\n    |\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:76:44\n+  --> $DIR/ptr_arg.rs:81:44\n    |\n LL | fn false_positive_capacity(x: &Vec<u8>, y: &String) {\n    |                                            ^^^^^^^\n@@ -109,13 +109,13 @@ LL |     let c = y;\n    |             ~\n \n error: using a reference to `Cow` is not recommended\n-  --> $DIR/ptr_arg.rs:90:25\n+  --> $DIR/ptr_arg.rs:95:25\n    |\n LL | fn test_cow_with_ref(c: &Cow<[i32]>) {}\n    |                         ^^^^^^^^^^^ help: change this to: `&[i32]`\n \n error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n-  --> $DIR/ptr_arg.rs:143:21\n+  --> $DIR/ptr_arg.rs:148:21\n    |\n LL |     fn foo_vec(vec: &Vec<u8>) {\n    |                     ^^^^^^^^\n@@ -134,7 +134,7 @@ LL |         let _ = vec.to_owned().clone();\n    |                 ~~~~~~~~~~~~~~\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:148:23\n+  --> $DIR/ptr_arg.rs:153:23\n    |\n LL |     fn foo_path(path: &PathBuf) {\n    |                       ^^^^^^^^\n@@ -153,7 +153,7 @@ LL |         let _ = path.to_path_buf().clone();\n    |                 ~~~~~~~~~~~~~~~~~~\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:153:21\n+  --> $DIR/ptr_arg.rs:158:21\n    |\n LL |     fn foo_str(str: &PathBuf) {\n    |                     ^^^^^^^^"}, {"sha": "dc197e50300d8b11939db42d3ee7738bdb9fa9f7", "filename": "tests/ui/repeat_once.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Frepeat_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Frepeat_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frepeat_once.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n #![warn(clippy::repeat_once)]\n-#[allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n+#[allow(unused, clippy::redundant_clone)]\n fn main() {\n     const N: usize = 1;\n     let s = \"str\";"}, {"sha": "0ec5127117c6efab7484649994c9775cb68105e6", "filename": "tests/ui/repeat_once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frepeat_once.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n #![warn(clippy::repeat_once)]\n-#[allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n+#[allow(unused, clippy::redundant_clone)]\n fn main() {\n     const N: usize = 1;\n     let s = \"str\";"}, {"sha": "12e10ba6c493b8c9e539ce2b1e7b33faa4d285e8", "filename": "tests/ui/same_name_method.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_name_method.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,111 @@\n+#![warn(clippy::same_name_method)]\n+#![allow(dead_code, non_camel_case_types)]\n+\n+trait T1 {\n+    fn foo() {}\n+}\n+\n+trait T2 {\n+    fn foo() {}\n+}\n+\n+mod should_lint {\n+\n+    mod test_basic_case {\n+        use crate::T1;\n+\n+        struct S;\n+\n+        impl S {\n+            fn foo() {}\n+        }\n+\n+        impl T1 for S {\n+            fn foo() {}\n+        }\n+    }\n+\n+    mod test_derive {\n+\n+        #[derive(Clone)]\n+        struct S;\n+\n+        impl S {\n+            fn clone() {}\n+        }\n+    }\n+\n+    mod with_generic {\n+        use crate::T1;\n+\n+        struct S<U>(U);\n+\n+        impl<U> S<U> {\n+            fn foo() {}\n+        }\n+\n+        impl<U: Copy> T1 for S<U> {\n+            fn foo() {}\n+        }\n+    }\n+\n+    mod default_method {\n+        use crate::T1;\n+\n+        struct S;\n+\n+        impl S {\n+            fn foo() {}\n+        }\n+\n+        impl T1 for S {}\n+    }\n+\n+    mod mulitply_conflicit_trait {\n+        use crate::{T1, T2};\n+\n+        struct S;\n+\n+        impl S {\n+            fn foo() {}\n+        }\n+\n+        impl T1 for S {}\n+\n+        impl T2 for S {}\n+    }\n+}\n+\n+mod should_not_lint {\n+\n+    mod not_lint_two_trait_method {\n+        use crate::{T1, T2};\n+\n+        struct S;\n+\n+        impl T1 for S {\n+            fn foo() {}\n+        }\n+\n+        impl T2 for S {\n+            fn foo() {}\n+        }\n+    }\n+\n+    mod only_lint_on_method {\n+        trait T3 {\n+            type foo;\n+        }\n+\n+        struct S;\n+\n+        impl S {\n+            fn foo() {}\n+        }\n+        impl T3 for S {\n+            type foo = usize;\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0f9139b41b99dae76e7d06f5d1f8d900ec82b784", "filename": "tests/ui/same_name_method.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsame_name_method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsame_name_method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_name_method.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -0,0 +1,64 @@\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:20:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::same-name-method` implied by `-D warnings`\n+note: existing `foo` defined here\n+  --> $DIR/same_name_method.rs:24:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:44:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+   |\n+note: existing `foo` defined here\n+  --> $DIR/same_name_method.rs:48:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:58:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+   |\n+note: existing `foo` defined here\n+  --> $DIR/same_name_method.rs:61:9\n+   |\n+LL |         impl T1 for S {}\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:70:13\n+   |\n+LL |             fn foo() {}\n+   |             ^^^^^^^^^^^\n+   |\n+note: existing `foo` defined here\n+  --> $DIR/same_name_method.rs:73:9\n+   |\n+LL |         impl T1 for S {}\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: method's name is same to an existing method in a trait\n+  --> $DIR/same_name_method.rs:34:13\n+   |\n+LL |             fn clone() {}\n+   |             ^^^^^^^^^^^^^\n+   |\n+note: existing `clone` defined here\n+  --> $DIR/same_name_method.rs:30:18\n+   |\n+LL |         #[derive(Clone)]\n+   |                  ^^^^^\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "9644a23296831bf1a67092feecba921180aa3ba7", "filename": "tests/ui/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::semicolon_if_nothing_returned)]\n+#![allow(clippy::redundant_closure)]\n #![feature(label_break_value)]\n \n fn get_unit() {}\n@@ -30,8 +31,8 @@ fn unsafe_checks_error() {\n     use std::ptr;\n \n     let mut s = MaybeUninit::<String>::uninit();\n-    let _d = || unsafe { \n-        ptr::drop_in_place(s.as_mut_ptr()) \n+    let _d = || unsafe {\n+        ptr::drop_in_place(s.as_mut_ptr())\n     };\n }\n "}, {"sha": "78813e7cc1c39c5aa294f08db14ca9cfe0688a50", "filename": "tests/ui/semicolon_if_nothing_returned.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,33 +1,33 @@\n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:8:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:9:5\n    |\n LL |     println!(\"Hello\")\n    |     ^^^^^^^^^^^^^^^^^ help: add a `;` here: `println!(\"Hello\");`\n    |\n    = note: `-D clippy::semicolon-if-nothing-returned` implied by `-D warnings`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:12:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:13:5\n    |\n LL |     get_unit()\n    |     ^^^^^^^^^^ help: add a `;` here: `get_unit();`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:17:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:18:5\n    |\n LL |     y = x + 1\n    |     ^^^^^^^^^ help: add a `;` here: `y = x + 1;`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:23:9\n+  --> $DIR/semicolon_if_nothing_returned.rs:24:9\n    |\n LL |         hello()\n    |         ^^^^^^^ help: add a `;` here: `hello();`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:34:9\n+  --> $DIR/semicolon_if_nothing_returned.rs:35:9\n    |\n-LL |         ptr::drop_in_place(s.as_mut_ptr()) \n+LL |         ptr::drop_in_place(s.as_mut_ptr())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add a `;` here: `ptr::drop_in_place(s.as_mut_ptr());`\n \n error: aborting due to 5 previous errors"}, {"sha": "be8bc22bf98a05d062caff083c4c6e1d1d903c85", "filename": "tests/ui/suspicious_else_formatting.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsuspicious_else_formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsuspicious_else_formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_else_formatting.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,10 @@\n+// aux-build:proc_macro_suspicious_else_formatting.rs\n+\n #![warn(clippy::suspicious_else_formatting)]\n \n+extern crate proc_macro_suspicious_else_formatting;\n+use proc_macro_suspicious_else_formatting::DeriveBadSpan;\n+\n fn foo() -> bool {\n     true\n }\n@@ -103,3 +108,7 @@ fn main() {\n     {\n     }\n }\n+\n+// #7650 - Don't lint. Proc-macro using bad spans for `if` expressions.\n+#[derive(DeriveBadSpan)]\n+struct _Foo(u32, u32);"}, {"sha": "d1db195cbb8787bc0003738f2f2c1e37adbf7fe3", "filename": "tests/ui/suspicious_else_formatting.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsuspicious_else_formatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fsuspicious_else_formatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_else_formatting.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n error: this looks like an `else {..}` but the `else` is missing\n-  --> $DIR/suspicious_else_formatting.rs:11:6\n+  --> $DIR/suspicious_else_formatting.rs:16:6\n    |\n LL |     } {\n    |      ^\n@@ -8,31 +8,31 @@ LL |     } {\n    = note: to remove this lint, add the missing `else` or add a new line before the next block\n \n error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/suspicious_else_formatting.rs:15:6\n+  --> $DIR/suspicious_else_formatting.rs:20:6\n    |\n LL |     } if foo() {\n    |      ^\n    |\n    = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n \n error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/suspicious_else_formatting.rs:22:10\n+  --> $DIR/suspicious_else_formatting.rs:27:10\n    |\n LL |         } if foo() {\n    |          ^\n    |\n    = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n \n error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/suspicious_else_formatting.rs:30:10\n+  --> $DIR/suspicious_else_formatting.rs:35:10\n    |\n LL |         } if foo() {\n    |          ^\n    |\n    = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n \n error: this is an `else {..}` but the formatting might hide it\n-  --> $DIR/suspicious_else_formatting.rs:39:6\n+  --> $DIR/suspicious_else_formatting.rs:44:6\n    |\n LL |       } else\n    |  ______^\n@@ -42,7 +42,7 @@ LL | |     {\n    = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n \n error: this is an `else if` but the formatting might hide it\n-  --> $DIR/suspicious_else_formatting.rs:51:6\n+  --> $DIR/suspicious_else_formatting.rs:56:6\n    |\n LL |       } else\n    |  ______^\n@@ -52,7 +52,7 @@ LL | |     if foo() { // the span of the above error should continue here\n    = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n \n error: this is an `else if` but the formatting might hide it\n-  --> $DIR/suspicious_else_formatting.rs:56:6\n+  --> $DIR/suspicious_else_formatting.rs:61:6\n    |\n LL |       }\n    |  ______^\n@@ -63,7 +63,7 @@ LL | |     if foo() { // the span of the above error should continue here\n    = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n \n error: this is an `else {..}` but the formatting might hide it\n-  --> $DIR/suspicious_else_formatting.rs:83:6\n+  --> $DIR/suspicious_else_formatting.rs:88:6\n    |\n LL |       }\n    |  ______^\n@@ -75,7 +75,7 @@ LL | |     {\n    = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n \n error: this is an `else {..}` but the formatting might hide it\n-  --> $DIR/suspicious_else_formatting.rs:91:6\n+  --> $DIR/suspicious_else_formatting.rs:96:6\n    |\n LL |       }\n    |  ______^"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "ea3dce17081b1a5cee5b00cbe39de303ec03ed7b", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -2,11 +2,7 @@\n // normalize-stderr-test \"\\(limit: \\d+ byte\\)\" -> \"(limit: N byte)\"\n \n #![deny(clippy::trivially_copy_pass_by_ref)]\n-#![allow(\n-    clippy::many_single_char_names,\n-    clippy::blacklisted_name,\n-    clippy::redundant_field_names\n-)]\n+#![allow(clippy::blacklisted_name, clippy::redundant_field_names)]\n \n #[derive(Copy, Clone)]\n struct Foo(u32);"}, {"sha": "a88d35f3ea5a96f643e4031b3a66563ef49cb1d2", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -1,5 +1,5 @@\n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:51:11\n+  --> $DIR/trivially_copy_pass_by_ref.rs:47:11\n    |\n LL | fn bad(x: &u32, y: &Foo, z: &Baz) {}\n    |           ^^^^ help: consider passing by value instead: `u32`\n@@ -11,97 +11,97 @@ LL | #![deny(clippy::trivially_copy_pass_by_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:51:20\n+  --> $DIR/trivially_copy_pass_by_ref.rs:47:20\n    |\n LL | fn bad(x: &u32, y: &Foo, z: &Baz) {}\n    |                    ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:51:29\n+  --> $DIR/trivially_copy_pass_by_ref.rs:47:29\n    |\n LL | fn bad(x: &u32, y: &Foo, z: &Baz) {}\n    |                             ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:58:12\n+  --> $DIR/trivially_copy_pass_by_ref.rs:54:12\n    |\n LL |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n    |            ^^^^^ help: consider passing by value instead: `self`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:58:22\n+  --> $DIR/trivially_copy_pass_by_ref.rs:54:22\n    |\n LL |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n    |                      ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:58:31\n+  --> $DIR/trivially_copy_pass_by_ref.rs:54:31\n    |\n LL |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n    |                               ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:58:40\n+  --> $DIR/trivially_copy_pass_by_ref.rs:54:40\n    |\n LL |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n    |                                        ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:60:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:56:16\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:60:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:56:25\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:60:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:56:34\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:62:35\n+  --> $DIR/trivially_copy_pass_by_ref.rs:58:35\n    |\n LL |     fn bad_issue7518(self, other: &Self) {}\n    |                                   ^^^^^ help: consider passing by value instead: `Self`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:74:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:70:16\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:74:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:70:25\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:74:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:70:34\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:78:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:74:34\n    |\n LL |     fn trait_method(&self, _foo: &Foo);\n    |                                  ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:110:21\n+  --> $DIR/trivially_copy_pass_by_ref.rs:106:21\n    |\n LL |     fn foo_never(x: &i32) {\n    |                     ^^^^ help: consider passing by value instead: `i32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:115:15\n+  --> $DIR/trivially_copy_pass_by_ref.rs:111:15\n    |\n LL |     fn foo(x: &i32) {\n    |               ^^^^ help: consider passing by value instead: `i32`"}, {"sha": "f5a341909023ee3429e902862b3344c4e1cdc050", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -188,7 +188,7 @@ fn issue6491() {\n     // Used in outer loop, needs &mut\n     let mut it = 1..40;\n     while let Some(n) = it.next() {\n-        for m in &mut it {\n+        for m in it.by_ref() {\n             if m % 10 == 0 {\n                 break;\n             }\n@@ -219,7 +219,7 @@ fn issue6491() {\n \n         // Used after the loop, needs &mut.\n         let mut it = 1..40;\n-        for m in &mut it {\n+        for m in it.by_ref() {\n             if m % 10 == 0 {\n                 break;\n             }\n@@ -236,7 +236,7 @@ fn issue6231() {\n     let mut it = 1..40;\n     let mut opt = Some(0);\n     while let Some(n) = opt.take().or_else(|| it.next()) {\n-        for m in &mut it {\n+        for m in it.by_ref() {\n             if n % 10 == 0 {\n                 break;\n             }\n@@ -251,7 +251,7 @@ fn issue1924() {\n     impl<T: Iterator<Item = u32>> S<T> {\n         fn f(&mut self) -> Option<u32> {\n             // Used as a field.\n-            for i in &mut self.0 {\n+            for i in self.0.by_ref() {\n                 if !(3..=7).contains(&i) {\n                     return Some(i);\n                 }\n@@ -283,7 +283,7 @@ fn issue1924() {\n                 }\n             }\n             // This one is fine, a different field is borrowed\n-            for i in &mut self.0.0.0 {\n+            for i in self.0.0.0.by_ref() {\n                 if i == 1 {\n                     return self.0.1.take();\n                 } else {\n@@ -312,7 +312,7 @@ fn issue1924() {\n \n     // Needs &mut, field of the iterator is accessed after the loop\n     let mut it = S2(1..40, 0);\n-    for n in &mut it {\n+    for n in it.by_ref() {\n         if n == 0 {\n             break;\n         }\n@@ -324,7 +324,7 @@ fn issue7249() {\n     let mut it = 0..10;\n     let mut x = || {\n         // Needs &mut, the closure can be called multiple times\n-        for x in &mut it {\n+        for x in it.by_ref() {\n             if x % 2 == 0 {\n                 break;\n             }\n@@ -338,7 +338,7 @@ fn issue7510() {\n     let mut it = 0..10;\n     let it = &mut it;\n     // Needs to reborrow `it` as the binding isn't mutable\n-    for x in &mut *it {\n+    for x in it.by_ref() {\n         if x % 2 == 0 {\n             break;\n         }\n@@ -349,7 +349,7 @@ fn issue7510() {\n     let mut it = 0..10;\n     let it = S(&mut it);\n     // Needs to reborrow `it.0` as the binding isn't mutable\n-    for x in &mut *it.0 {\n+    for x in it.0.by_ref() {\n         if x % 2 == 0 {\n             break;\n         }"}, {"sha": "5e2fce4491af0956ff4ba97e6b96f9a85c230c35", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -46,7 +46,7 @@ error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:191:9\n    |\n LL |         while let Some(m) = it.next() {\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:202:5\n@@ -70,19 +70,19 @@ error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:222:9\n    |\n LL |         while let Some(m) = it.next() {\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:239:9\n    |\n LL |         while let Some(m) = it.next() {\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:254:13\n    |\n LL |             while let Some(i) = self.0.next() {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in &mut self.0`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in self.0.by_ref()`\n \n error: manual `!RangeInclusive::contains` implementation\n   --> $DIR/while_let_on_iterator.rs:255:20\n@@ -96,31 +96,31 @@ error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:286:13\n    |\n LL |             while let Some(i) = self.0.0.0.next() {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in &mut self.0.0.0`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in self.0.0.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:315:5\n    |\n LL |     while let Some(n) = it.next() {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in &mut it`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:327:9\n    |\n LL |         while let Some(x) = it.next() {\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in &mut it`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:341:5\n    |\n LL |     while let Some(x) = it.next() {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in &mut *it`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:352:5\n    |\n LL |     while let Some(x) = it.0.next() {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in &mut *it.0`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n   --> $DIR/while_let_on_iterator.rs:371:5"}, {"sha": "0d827c1feb3e722c4842684a441f6386ee2f2eb5", "filename": "tests/ui/wrong_self_convention2.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fwrong_self_convention2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707494eca9527a47c84900ddcaac74b6006dc733/tests%2Fui%2Fwrong_self_convention2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention2.rs?ref=707494eca9527a47c84900ddcaac74b6006dc733", "patch": "@@ -68,3 +68,40 @@ mod issue7179 {\n         fn as_byte_slice(slice: &[Self]) -> &[u8];\n     }\n }\n+\n+mod issue3414 {\n+    struct CellLikeThing<T>(T);\n+\n+    impl<T> CellLikeThing<T> {\n+        // don't trigger\n+        fn into_inner(this: Self) -> T {\n+            this.0\n+        }\n+    }\n+\n+    impl<T> std::ops::Deref for CellLikeThing<T> {\n+        type Target = T;\n+\n+        fn deref(&self) -> &T {\n+            &self.0\n+        }\n+    }\n+}\n+\n+// don't trigger\n+mod issue4546 {\n+    use std::pin::Pin;\n+\n+    struct S;\n+    impl S {\n+        pub fn as_mut(self: Pin<&mut Self>) {}\n+\n+        pub fn as_other_thingy(self: Pin<&Self>) {}\n+\n+        pub fn is_other_thingy(self: Pin<&Self>) {}\n+\n+        pub fn to_mut(self: Pin<&mut Self>) {}\n+\n+        pub fn to_other_thingy(self: Pin<&Self>) {}\n+    }\n+}"}]}