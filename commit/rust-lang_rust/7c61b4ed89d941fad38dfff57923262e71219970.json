{"sha": "7c61b4ed89d941fad38dfff57923262e71219970", "node_id": "C_kwDOAAsO6NoAKDdjNjFiNGVkODlkOTQxZmFkMzhkZmZmNTc5MjMyNjJlNzEyMTk5NzA", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2023-02-10T10:33:45Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2023-02-10T10:33:45Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "c07fc60b0a69be7cf5eaf435e635036dc066b2c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c07fc60b0a69be7cf5eaf435e635036dc066b2c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c61b4ed89d941fad38dfff57923262e71219970", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmPmHYsACgkQHKDfKvWd\naKXpWg//WcbK2WxCkSe4EAo1VY7K8WPBwnVUEuzmOKSLClyucMQx+n0SwaSDNM6/\n9wjHrPC/n2xqIujmtis+Bnwo+GQ1yQxc9Ctad+BB/nLNPKfdheAAR85KxT/tlbx4\nQB18JQdALs1ZvytyK9GPid8B4OTkN442QXwnu5xzcZaSY2CPKGR+ImZi/P/AZy9o\no9ZSGB+s1rs77qjHglkoqePKseN9ajlXvzAuvvV9WR+6KYHGivoKWw1R6guqNKE6\nbgipsg7dBDYub8GL6nhMET8IOqWHijd2ZvMyY2HiH151/nvzxkP576QFZn14CXAk\npcsKgJGtZp5YIvcn03df6vm+ZlQUYNUfEKjPD3Ayb1rnPUfZ8PXLshri8gfijAw4\ngvBsf1OIZ0+ZlhPGeoMgIfQojxd1DWkzQMWRTCxFogX1jNnsR5EZEqUzkY5T48Al\nwTPLS6s9yRKXRDBSF7cn9dwFwhEGN3AVFaoot1hRb7n2jWBH5P9KjYytdAVVPrSu\nHmN5N06HjKs1u4WLLZbbUs9cSu/sKjZBgW8SFm/RXRVEJez+bzX81Jx8fXnWV4L+\nZWZSr3vzz5mC+r2Y/7ym1y8Vv3/0MtkvdUKdgWg9lYh8QaTCx/xzl7z7T8rnsqJX\nSFfYTp0K/gpEKTkMPKjWWZ8pV6S2apiQv2t4qLKQAk2SaEjAu5c=\n=RSA5\n-----END PGP SIGNATURE-----", "payload": "tree c07fc60b0a69be7cf5eaf435e635036dc066b2c4\nparent 821199c885b4e3648682ac41c1d32b832407112f\nparent 5adeebf92fd5a639d2cb51c7374fc212e5de568f\nauthor Philipp Krones <hello@philkrones.com> 1676025225 +0100\ncommitter Philipp Krones <hello@philkrones.com> 1676025225 +0100\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c61b4ed89d941fad38dfff57923262e71219970", "html_url": "https://github.com/rust-lang/rust/commit/7c61b4ed89d941fad38dfff57923262e71219970", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c61b4ed89d941fad38dfff57923262e71219970/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "821199c885b4e3648682ac41c1d32b832407112f", "url": "https://api.github.com/repos/rust-lang/rust/commits/821199c885b4e3648682ac41c1d32b832407112f", "html_url": "https://github.com/rust-lang/rust/commit/821199c885b4e3648682ac41c1d32b832407112f"}, {"sha": "5adeebf92fd5a639d2cb51c7374fc212e5de568f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5adeebf92fd5a639d2cb51c7374fc212e5de568f", "html_url": "https://github.com/rust-lang/rust/commit/5adeebf92fd5a639d2cb51c7374fc212e5de568f"}], "stats": {"total": 2807, "additions": 2218, "deletions": 589}, "files": [{"sha": "659e8aebcd5799a12ecfcf3099fb6672a22a9b01", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -4383,6 +4383,7 @@ Released 2018-09-13\n [`extend_from_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#extend_from_slice\n [`extend_with_drain`]: https://rust-lang.github.io/rust-clippy/master/index.html#extend_with_drain\n [`extra_unused_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#extra_unused_lifetimes\n+[`extra_unused_type_parameters`]: https://rust-lang.github.io/rust-clippy/master/index.html#extra_unused_type_parameters\n [`fallible_impl_from`]: https://rust-lang.github.io/rust-clippy/master/index.html#fallible_impl_from\n [`field_reassign_with_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#field_reassign_with_default\n [`filetype_is_file`]: https://rust-lang.github.io/rust-clippy/master/index.html#filetype_is_file"}, {"sha": "70d1268090f6e5dca8f3fc87333f7f95a7be3d00", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -42,6 +42,7 @@ filetime = \"0.2\"\n rustc-workspace-hack = \"1.0\"\n \n # UI test dependencies\n+clap = { version = \"4.1.4\", features = [\"derive\"] }\n clippy_utils = { path = \"clippy_utils\" }\n derive-new = \"0.5\"\n if_chain = \"1.0\""}, {"sha": "95f6d2cc45c83ca291f14d6f2796740192ba2239", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -5,7 +5,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 550 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are over 600 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n Lints are divided into categories, each with a default [lint level](https://doc.rust-lang.org/rustc/lints/levels.html).\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category."}, {"sha": "df4a1f2702e47f9528ec4e41f6d1cb29d9a877ec", "filename": "book/src/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/book%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/book%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FREADME.md?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -6,7 +6,7 @@\n A collection of lints to catch common mistakes and improve your\n [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 550 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are over 600 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n Lints are divided into categories, each with a default [lint\n level](https://doc.rust-lang.org/rustc/lints/levels.html). You can choose how"}, {"sha": "32e8e218c40554462d28c7e0e31dec6f5d2e2a4c", "filename": "book/src/lint_configuration.md", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/book%2Fsrc%2Flint_configuration.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/book%2Fsrc%2Flint_configuration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flint_configuration.md?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -43,6 +43,7 @@ Please use that command to update the file and do not edit it by hand.\n | [allowed-scripts](#allowed-scripts) | `[\"Latin\"]` |\n | [enable-raw-pointer-heuristic-for-send](#enable-raw-pointer-heuristic-for-send) | `true` |\n | [max-suggested-slice-pattern-length](#max-suggested-slice-pattern-length) | `3` |\n+| [await-holding-invalid-types](#await-holding-invalid-types) | `[]` |\n | [max-include-file-size](#max-include-file-size) | `1000000` |\n | [allow-expect-in-tests](#allow-expect-in-tests) | `false` |\n | [allow-unwrap-in-tests](#allow-unwrap-in-tests) | `false` |\n@@ -167,6 +168,17 @@ The minimum rust version that the project supports\n * [manual_clamp](https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp)\n * [manual_let_else](https://rust-lang.github.io/rust-clippy/master/index.html#manual_let_else)\n * [unchecked_duration_subtraction](https://rust-lang.github.io/rust-clippy/master/index.html#unchecked_duration_subtraction)\n+* [collapsible_str_replace](https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_str_replace)\n+* [seek_from_current](https://rust-lang.github.io/rust-clippy/master/index.html#seek_from_current)\n+* [seek_rewind](https://rust-lang.github.io/rust-clippy/master/index.html#seek_rewind)\n+* [unnecessary_lazy_evaluations](https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations)\n+* [transmute_ptr_to_ref](https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref)\n+* [almost_complete_range](https://rust-lang.github.io/rust-clippy/master/index.html#almost_complete_range)\n+* [needless_borrow](https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow)\n+* [derivable_impls](https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls)\n+* [manual_is_ascii_check](https://rust-lang.github.io/rust-clippy/master/index.html#manual_is_ascii_check)\n+* [manual_rem_euclid](https://rust-lang.github.io/rust-clippy/master/index.html#manual_rem_euclid)\n+* [manual_retain](https://rust-lang.github.io/rust-clippy/master/index.html#manual_retain)\n \n \n ### cognitive-complexity-threshold\n@@ -279,7 +291,7 @@ The minimum size (in bytes) to consider a type for passing by reference instead\n \n **Default Value:** `256` (`u64`)\n \n-* [large_type_pass_by_move](https://rust-lang.github.io/rust-clippy/master/index.html#large_type_pass_by_move)\n+* [large_types_passed_by_value](https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value)\n \n \n ### too-many-lines-threshold\n@@ -442,6 +454,14 @@ For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n * [index_refutable_slice](https://rust-lang.github.io/rust-clippy/master/index.html#index_refutable_slice)\n \n \n+### await-holding-invalid-types\n+\n+\n+**Default Value:** `[]` (`Vec<crate::utils::conf::DisallowedPath>`)\n+\n+* [await_holding_invalid_type](https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_invalid_type)\n+\n+\n ### max-include-file-size\n The maximum size of a file included via `include_bytes!()` or `include_str!()`, in bytes\n \n@@ -497,7 +517,7 @@ for the generic parameters for determining interior mutability\n \n **Default Value:** `[\"bytes::Bytes\"]` (`Vec<String>`)\n \n-* [mutable_key](https://rust-lang.github.io/rust-clippy/master/index.html#mutable_key)\n+* [mutable_key_type](https://rust-lang.github.io/rust-clippy/master/index.html#mutable_key_type)\n \n \n ### allow-mixed-uninlined-format-args\n@@ -509,7 +529,7 @@ Whether to allow mixed uninlined format args, e.g. `format!(\"{} {}\", a, foo.bar)\n \n \n ### suppress-restriction-lint-in-const\n-In same\n+Whether to suppress a restriction lint in constant code. In same\n cases the restructured operation might not be unavoidable, as the\n suggested counterparts are unavailable in constant code. This\n configuration will cause restriction lints to trigger even"}, {"sha": "c3f8a782d273a01556bca0e7a34f7ec2e7f2aec8", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -5,7 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n aho-corasick = \"0.7\"\n-clap = \"3.2\"\n+clap = \"4.1.4\"\n indoc = \"1.0\"\n itertools = \"0.10.1\"\n opener = \"0.5\""}, {"sha": "b2d67a72fd2b8aa99425a7430af6eec1adf92593", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 55, "deletions": 44, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -2,7 +2,7 @@\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n-use clap::{Arg, ArgAction, ArgMatches, Command, PossibleValue};\n+use clap::{Arg, ArgAction, ArgMatches, Command};\n use clippy_dev::{bless, dogfood, fmt, lint, new_lint, serve, setup, update_lints};\n use indoc::indoc;\n \n@@ -110,24 +110,37 @@ fn get_clap_config() -> ArgMatches {\n             Command::new(\"bless\").about(\"bless the test output changes\").arg(\n                 Arg::new(\"ignore-timestamp\")\n                     .long(\"ignore-timestamp\")\n+                    .action(ArgAction::SetTrue)\n                     .help(\"Include files updated before clippy was built\"),\n             ),\n             Command::new(\"dogfood\").about(\"Runs the dogfood test\").args([\n-                Arg::new(\"fix\").long(\"fix\").help(\"Apply the suggestions when possible\"),\n+                Arg::new(\"fix\")\n+                    .long(\"fix\")\n+                    .action(ArgAction::SetTrue)\n+                    .help(\"Apply the suggestions when possible\"),\n                 Arg::new(\"allow-dirty\")\n                     .long(\"allow-dirty\")\n+                    .action(ArgAction::SetTrue)\n                     .help(\"Fix code even if the working directory has changes\")\n                     .requires(\"fix\"),\n                 Arg::new(\"allow-staged\")\n                     .long(\"allow-staged\")\n+                    .action(ArgAction::SetTrue)\n                     .help(\"Fix code even if the working directory has staged changes\")\n                     .requires(\"fix\"),\n             ]),\n             Command::new(\"fmt\")\n                 .about(\"Run rustfmt on all projects and tests\")\n                 .args([\n-                    Arg::new(\"check\").long(\"check\").help(\"Use the rustfmt --check option\"),\n-                    Arg::new(\"verbose\").short('v').long(\"verbose\").help(\"Echo commands run\"),\n+                    Arg::new(\"check\")\n+                        .long(\"check\")\n+                        .action(ArgAction::SetTrue)\n+                        .help(\"Use the rustfmt --check option\"),\n+                    Arg::new(\"verbose\")\n+                        .short('v')\n+                        .long(\"verbose\")\n+                        .action(ArgAction::SetTrue)\n+                        .help(\"Echo commands run\"),\n                 ]),\n             Command::new(\"update_lints\")\n                 .about(\"Updates lint registration and information from the source code\")\n@@ -140,13 +153,17 @@ fn get_clap_config() -> ArgMatches {\n                     * all lints are registered in the lint store\",\n                 )\n                 .args([\n-                    Arg::new(\"print-only\").long(\"print-only\").help(\n-                        \"Print a table of lints to STDOUT. \\\n-                        This does not include deprecated and internal lints. \\\n-                        (Does not modify any files)\",\n-                    ),\n+                    Arg::new(\"print-only\")\n+                        .long(\"print-only\")\n+                        .action(ArgAction::SetTrue)\n+                        .help(\n+                            \"Print a table of lints to STDOUT. \\\n+                            This does not include deprecated and internal lints. \\\n+                            (Does not modify any files)\",\n+                        ),\n                     Arg::new(\"check\")\n                         .long(\"check\")\n+                        .action(ArgAction::SetTrue)\n                         .help(\"Checks that `cargo dev update_lints` has been run. Used on CI.\"),\n                 ]),\n             Command::new(\"new_lint\")\n@@ -156,41 +173,37 @@ fn get_clap_config() -> ArgMatches {\n                         .short('p')\n                         .long(\"pass\")\n                         .help(\"Specify whether the lint runs during the early or late pass\")\n-                        .takes_value(true)\n-                        .value_parser([PossibleValue::new(\"early\"), PossibleValue::new(\"late\")])\n+                        .value_parser([\"early\", \"late\"])\n                         .conflicts_with(\"type\")\n                         .required_unless_present(\"type\"),\n                     Arg::new(\"name\")\n                         .short('n')\n                         .long(\"name\")\n                         .help(\"Name of the new lint in snake case, ex: fn_too_long\")\n-                        .takes_value(true)\n                         .required(true),\n                     Arg::new(\"category\")\n                         .short('c')\n                         .long(\"category\")\n                         .help(\"What category the lint belongs to\")\n                         .default_value(\"nursery\")\n                         .value_parser([\n-                            PossibleValue::new(\"style\"),\n-                            PossibleValue::new(\"correctness\"),\n-                            PossibleValue::new(\"suspicious\"),\n-                            PossibleValue::new(\"complexity\"),\n-                            PossibleValue::new(\"perf\"),\n-                            PossibleValue::new(\"pedantic\"),\n-                            PossibleValue::new(\"restriction\"),\n-                            PossibleValue::new(\"cargo\"),\n-                            PossibleValue::new(\"nursery\"),\n-                            PossibleValue::new(\"internal\"),\n-                            PossibleValue::new(\"internal_warn\"),\n-                        ])\n-                        .takes_value(true),\n-                    Arg::new(\"type\")\n-                        .long(\"type\")\n-                        .help(\"What directory the lint belongs in\")\n-                        .takes_value(true)\n-                        .required(false),\n-                    Arg::new(\"msrv\").long(\"msrv\").help(\"Add MSRV config code to the lint\"),\n+                            \"style\",\n+                            \"correctness\",\n+                            \"suspicious\",\n+                            \"complexity\",\n+                            \"perf\",\n+                            \"pedantic\",\n+                            \"restriction\",\n+                            \"cargo\",\n+                            \"nursery\",\n+                            \"internal\",\n+                            \"internal_warn\",\n+                        ]),\n+                    Arg::new(\"type\").long(\"type\").help(\"What directory the lint belongs in\"),\n+                    Arg::new(\"msrv\")\n+                        .long(\"msrv\")\n+                        .action(ArgAction::SetTrue)\n+                        .help(\"Add MSRV config code to the lint\"),\n                 ]),\n             Command::new(\"setup\")\n                 .about(\"Support for setting up your personal development environment\")\n@@ -201,13 +214,12 @@ fn get_clap_config() -> ArgMatches {\n                         .args([\n                             Arg::new(\"remove\")\n                                 .long(\"remove\")\n-                                .help(\"Remove the dependencies added with 'cargo dev setup intellij'\")\n-                                .required(false),\n+                                .action(ArgAction::SetTrue)\n+                                .help(\"Remove the dependencies added with 'cargo dev setup intellij'\"),\n                             Arg::new(\"rustc-repo-path\")\n                                 .long(\"repo-path\")\n                                 .short('r')\n                                 .help(\"The path to a rustc repo that will be used for setting the dependencies\")\n-                                .takes_value(true)\n                                 .value_name(\"path\")\n                                 .conflicts_with(\"remove\")\n                                 .required(true),\n@@ -217,26 +229,26 @@ fn get_clap_config() -> ArgMatches {\n                         .args([\n                             Arg::new(\"remove\")\n                                 .long(\"remove\")\n-                                .help(\"Remove the pre-commit hook added with 'cargo dev setup git-hook'\")\n-                                .required(false),\n+                                .action(ArgAction::SetTrue)\n+                                .help(\"Remove the pre-commit hook added with 'cargo dev setup git-hook'\"),\n                             Arg::new(\"force-override\")\n                                 .long(\"force-override\")\n                                 .short('f')\n-                                .help(\"Forces the override of an existing git pre-commit hook\")\n-                                .required(false),\n+                                .action(ArgAction::SetTrue)\n+                                .help(\"Forces the override of an existing git pre-commit hook\"),\n                         ]),\n                     Command::new(\"vscode-tasks\")\n                         .about(\"Add several tasks to vscode for formatting, validation and testing\")\n                         .args([\n                             Arg::new(\"remove\")\n                                 .long(\"remove\")\n-                                .help(\"Remove the tasks added with 'cargo dev setup vscode-tasks'\")\n-                                .required(false),\n+                                .action(ArgAction::SetTrue)\n+                                .help(\"Remove the tasks added with 'cargo dev setup vscode-tasks'\"),\n                             Arg::new(\"force-override\")\n                                 .long(\"force-override\")\n                                 .short('f')\n-                                .help(\"Forces the override of existing vscode tasks\")\n-                                .required(false),\n+                                .action(ArgAction::SetTrue)\n+                                .help(\"Forces the override of existing vscode tasks\"),\n                         ]),\n                 ]),\n             Command::new(\"remove\")\n@@ -295,6 +307,7 @@ fn get_clap_config() -> ArgMatches {\n                     .help(\"The new name of the lint\"),\n                 Arg::new(\"uplift\")\n                     .long(\"uplift\")\n+                    .action(ArgAction::SetTrue)\n                     .help(\"This lint will be uplifted into rustc\"),\n             ]),\n             Command::new(\"deprecate\").about(\"Deprecates the given lint\").args([\n@@ -305,8 +318,6 @@ fn get_clap_config() -> ArgMatches {\n                 Arg::new(\"reason\")\n                     .long(\"reason\")\n                     .short('r')\n-                    .required(false)\n-                    .takes_value(true)\n                     .help(\"The reason for deprecation\"),\n             ]),\n         ])"}, {"sha": "989e4d3fa56c545d67e4666f9a61685c7b08205f", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -9,7 +9,7 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n edition = \"2021\"\n \n [dependencies]\n-cargo_metadata = \"0.14\"\n+cargo_metadata = \"0.15.3\"\n clippy_utils = { path = \"../clippy_utils\" }\n declare_clippy_lint = { path = \"../declare_clippy_lint\" }\n if_chain = \"1.0\"\n@@ -19,7 +19,7 @@ quine-mc_cluskey = \"0.2\"\n regex-syntax = \"0.6\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = { version = \"1.0\", optional = true }\n-tempfile = { version = \"3.2\", optional = true }\n+tempfile = { version = \"3.3.0\", optional = true }\n toml = \"0.5\"\n unicode-normalization = \"0.1\"\n unicode-script = { version = \"0.5\", default-features = false }"}, {"sha": "569bf27c3e716e13e3802e7e4cd6fe8bab627135", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -85,8 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                             );\n                         }\n                     } else {\n-                        let span =\n-                            block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n+                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n                         if span.from_expansion() || expr.span.from_expansion() {\n                             return;\n                         }"}, {"sha": "1d9096ea64d1c3fa261073102b1eff52fdb52209", "filename": "clippy_lints/src/bool_assert_comparison.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::macros::{find_assert_eq_args, root_macro_call_first_node};\n+use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_copy};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -34,14 +35,16 @@ declare_clippy_lint! {\n \n declare_lint_pass!(BoolAssertComparison => [BOOL_ASSERT_COMPARISON]);\n \n-fn is_bool_lit(e: &Expr<'_>) -> bool {\n-    matches!(\n-        e.kind,\n-        ExprKind::Lit(Lit {\n-            node: LitKind::Bool(_),\n-            ..\n-        })\n-    ) && !e.span.from_expansion()\n+fn extract_bool_lit(e: &Expr<'_>) -> Option<bool> {\n+    if let ExprKind::Lit(Lit {\n+        node: LitKind::Bool(b), ..\n+    }) = e.kind\n+        && !e.span.from_expansion()\n+    {\n+        Some(b)\n+    } else {\n+        None\n+    }\n }\n \n fn is_impl_not_trait_with_bool_out<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -69,24 +72,23 @@ impl<'tcx> LateLintPass<'tcx> for BoolAssertComparison {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n         let macro_name = cx.tcx.item_name(macro_call.def_id);\n-        if !matches!(\n-            macro_name.as_str(),\n-            \"assert_eq\" | \"debug_assert_eq\" | \"assert_ne\" | \"debug_assert_ne\"\n-        ) {\n-            return;\n-        }\n+        let eq_macro = match macro_name.as_str() {\n+            \"assert_eq\" | \"debug_assert_eq\" => true,\n+            \"assert_ne\" | \"debug_assert_ne\" => false,\n+            _ => return,\n+        };\n         let Some ((a, b, _)) = find_assert_eq_args(cx, expr, macro_call.expn) else { return };\n \n         let a_span = a.span.source_callsite();\n         let b_span = b.span.source_callsite();\n \n-        let (lit_span, non_lit_expr) = match (is_bool_lit(a), is_bool_lit(b)) {\n-            // assert_eq!(true, b)\n-            //            ^^^^^^\n-            (true, false) => (a_span.until(b_span), b),\n-            // assert_eq!(a, true)\n-            //             ^^^^^^\n-            (false, true) => (b_span.with_lo(a_span.hi()), a),\n+        let (lit_span, bool_value, non_lit_expr) = match (extract_bool_lit(a), extract_bool_lit(b)) {\n+            // assert_eq!(true/false, b)\n+            //            ^^^^^^^^^^^^\n+            (Some(bool_value), None) => (a_span.until(b_span), bool_value, b),\n+            // assert_eq!(a, true/false)\n+            //             ^^^^^^^^^^^^\n+            (None, Some(bool_value)) => (b_span.with_lo(a_span.hi()), bool_value, a),\n             // If there are two boolean arguments, we definitely don't understand\n             // what's going on, so better leave things as is...\n             //\n@@ -121,9 +123,16 @@ impl<'tcx> LateLintPass<'tcx> for BoolAssertComparison {\n                 // ^^^^^^^^^\n                 let name_span = cx.sess().source_map().span_until_char(macro_call.span, '!');\n \n+                let mut suggestions = vec![(name_span, non_eq_mac.to_string()), (lit_span, String::new())];\n+\n+                if bool_value ^ eq_macro {\n+                    let Some(sugg) = Sugg::hir_opt(cx, non_lit_expr) else { return };\n+                    suggestions.push((non_lit_expr.span, (!sugg).to_string()));\n+                }\n+\n                 diag.multipart_suggestion(\n                     format!(\"replace it with `{non_eq_mac}!(..)`\"),\n-                    vec![(name_span, non_eq_mac.to_string()), (lit_span, String::new())],\n+                    suggestions,\n                     Applicability::MachineApplicable,\n                 );\n             },"}, {"sha": "457a25826e7997764107ca49d9a7c22ce652b99c", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -156,6 +156,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::exhaustive_items::EXHAUSTIVE_STRUCTS_INFO,\n     crate::exit::EXIT_INFO,\n     crate::explicit_write::EXPLICIT_WRITE_INFO,\n+    crate::extra_unused_type_parameters::EXTRA_UNUSED_TYPE_PARAMETERS_INFO,\n     crate::fallible_impl_from::FALLIBLE_IMPL_FROM_INFO,\n     crate::float_literal::EXCESSIVE_PRECISION_INFO,\n     crate::float_literal::LOSSY_FLOAT_LITERAL_INFO,"}, {"sha": "aef2db38583ee24e3eae3c6c9cb37c0c112896cc", "filename": "clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -4,8 +4,8 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, Item, ItemKind, TraitFn, TraitItem, TraitItemKind, Ty};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n use rustc_span::def_id::LocalDefId;\n+use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n declare_clippy_lint! {"}, {"sha": "2fdd8a71466c07512ba3368312333b616151a6d1", "filename": "clippy_lints/src/extra_unused_type_parameters.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -0,0 +1,178 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::trait_ref_of_method;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::MultiSpan;\n+use rustc_hir::intravisit::{walk_impl_item, walk_item, walk_param_bound, walk_ty, Visitor};\n+use rustc_hir::{\n+    GenericParamKind, Generics, ImplItem, ImplItemKind, Item, ItemKind, PredicateOrigin, Ty, TyKind, WherePredicate,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{def_id::DefId, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for type parameters in generics that are never used anywhere else.\n+    ///\n+    /// ### Why is this bad?\n+    /// Functions cannot infer the value of unused type parameters; therefore, calling them\n+    /// requires using a turbofish, which serves no purpose but to satisfy the compiler.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // unused type parameters\n+    /// fn unused_ty<T>(x: u8) {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn no_unused_ty(x: u8) {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.69.0\"]\n+    pub EXTRA_UNUSED_TYPE_PARAMETERS,\n+    complexity,\n+    \"unused type parameters in function definitions\"\n+}\n+declare_lint_pass!(ExtraUnusedTypeParameters => [EXTRA_UNUSED_TYPE_PARAMETERS]);\n+\n+/// A visitor struct that walks a given function and gathers generic type parameters, plus any\n+/// trait bounds those parameters have.\n+struct TypeWalker<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    /// Collection of all the type parameters and their spans.\n+    ty_params: FxHashMap<DefId, Span>,\n+    /// Collection of any (inline) trait bounds corresponding to each type parameter.\n+    bounds: FxHashMap<DefId, Span>,\n+    /// The entire `Generics` object of the function, useful for querying purposes.\n+    generics: &'tcx Generics<'tcx>,\n+    /// The value of this will remain `true` if *every* parameter:\n+    ///   1. Is a type parameter, and\n+    ///   2. Goes unused in the function.\n+    /// Otherwise, if any type parameters end up being used, or if any lifetime or const-generic\n+    /// parameters are present, this will be set to `false`.\n+    all_params_unused: bool,\n+}\n+\n+impl<'cx, 'tcx> TypeWalker<'cx, 'tcx> {\n+    fn new(cx: &'cx LateContext<'tcx>, generics: &'tcx Generics<'tcx>) -> Self {\n+        let mut all_params_unused = true;\n+        let ty_params = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| {\n+                if let GenericParamKind::Type { .. } = param.kind {\n+                    Some((param.def_id.into(), param.span))\n+                } else {\n+                    if !param.is_elided_lifetime() {\n+                        all_params_unused = false;\n+                    }\n+                    None\n+                }\n+            })\n+            .collect();\n+        Self {\n+            cx,\n+            ty_params,\n+            bounds: FxHashMap::default(),\n+            generics,\n+            all_params_unused,\n+        }\n+    }\n+\n+    fn emit_lint(&self) {\n+        let (msg, help) = match self.ty_params.len() {\n+            0 => return,\n+            1 => (\n+                \"type parameter goes unused in function definition\",\n+                \"consider removing the parameter\",\n+            ),\n+            _ => (\n+                \"type parameters go unused in function definition\",\n+                \"consider removing the parameters\",\n+            ),\n+        };\n+\n+        let source_map = self.cx.tcx.sess.source_map();\n+        let span = if self.all_params_unused {\n+            self.generics.span.into() // Remove the entire list of generics\n+        } else {\n+            MultiSpan::from_spans(\n+                self.ty_params\n+                    .iter()\n+                    .map(|(def_id, &span)| {\n+                        // Extend the span past any trait bounds, and include the comma at the end.\n+                        let span_to_extend = self.bounds.get(def_id).copied().map_or(span, Span::shrink_to_hi);\n+                        let comma_range = source_map.span_extend_to_next_char(span_to_extend, '>', false);\n+                        let comma_span = source_map.span_through_char(comma_range, ',');\n+                        span.with_hi(comma_span.hi())\n+                    })\n+                    .collect(),\n+            )\n+        };\n+\n+        span_lint_and_help(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, span, msg, None, help);\n+    }\n+}\n+\n+impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn visit_ty(&mut self, t: &'tcx Ty<'tcx>) {\n+        if let Some((def_id, _)) = t.peel_refs().as_generic_param() {\n+            if self.ty_params.remove(&def_id).is_some() {\n+                self.all_params_unused = false;\n+            }\n+        } else if let TyKind::OpaqueDef(id, _, _) = t.kind {\n+            // Explicitly walk OpaqueDef. Normally `walk_ty` would do the job, but it calls\n+            // `visit_nested_item`, which checks that `Self::NestedFilter::INTER` is set. We're\n+            // using `OnlyBodies`, so the check ends up failing and the type isn't fully walked.\n+            let item = self.nested_visit_map().item(id);\n+            walk_item(self, item);\n+        } else {\n+            walk_ty(self, t);\n+        }\n+    }\n+\n+    fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate<'tcx>) {\n+        if let WherePredicate::BoundPredicate(predicate) = predicate {\n+            // Collect spans for bounds that appear in the list of generics (not in a where-clause)\n+            // for use in forming the help message\n+            if let Some((def_id, _)) = predicate.bounded_ty.peel_refs().as_generic_param()\n+                && let PredicateOrigin::GenericParam = predicate.origin\n+            {\n+                self.bounds.insert(def_id, predicate.span);\n+            }\n+            // Only walk the right-hand side of where-bounds\n+            for bound in predicate.bounds {\n+                walk_param_bound(self, bound);\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for ExtraUnusedTypeParameters {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if let ItemKind::Fn(_, generics, _) = item.kind {\n+            let mut walker = TypeWalker::new(cx, generics);\n+            walk_item(&mut walker, item);\n+            walker.emit_lint();\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'tcx>) {\n+        // Only lint on inherent methods, not trait methods.\n+        if let ImplItemKind::Fn(..) = item.kind && trait_ref_of_method(cx, item.owner_id.def_id).is_none() {\n+            let mut walker = TypeWalker::new(cx, item.generics);\n+            walk_impl_item(&mut walker, item);\n+            walker.emit_lint();\n+        }\n+    }\n+}"}, {"sha": "92238d557e9d2debaa2763402d852b4cf2812155", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -125,7 +125,7 @@ declare_clippy_lint! {\n     /// nothing will be suggested, e.g. `println!(\"{0}={1}\", var, 1+2)`.\n     #[clippy::version = \"1.66.0\"]\n     pub UNINLINED_FORMAT_ARGS,\n-    style,\n+    pedantic,\n     \"using non-inlined variables in `format!` calls\"\n }\n \n@@ -366,12 +366,7 @@ fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n     }\n }\n \n-fn check_format_in_format_args(\n-    cx: &LateContext<'_>,\n-    call_site: Span,\n-    name: Symbol,\n-    arg: &Expr<'_>,\n-) {\n+fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &Expr<'_>) {\n     let expn_data = arg.span.ctxt().outer_expn_data();\n     if expn_data.call_site.from_expansion() {\n         return;\n@@ -444,7 +439,10 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n \n /// Returns true if `hir_id` is referred to by multiple format params\n fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n-    args.params().filter(|param| param.value.hir_id == hir_id).at_most_one().is_err()\n+    args.params()\n+        .filter(|param| param.value.hir_id == hir_id)\n+        .at_most_one()\n+        .is_err()\n }\n \n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n@@ -454,7 +452,11 @@ where\n     let mut n_total = 0;\n     let mut n_needed = 0;\n     loop {\n-        if let Some(Adjustment { kind: Adjust::Deref(overloaded_deref), target }) = iter.next() {\n+        if let Some(Adjustment {\n+            kind: Adjust::Deref(overloaded_deref),\n+            target,\n+        }) = iter.next()\n+        {\n             n_total += 1;\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;"}, {"sha": "8b53ee68ebdfb2bd8efb5f92dcd364768c5c535e", "filename": "clippy_lints/src/functions/misnamed_getters.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Ffunctions%2Fmisnamed_getters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Ffunctions%2Fmisnamed_getters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmisnamed_getters.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -10,13 +10,7 @@ use std::iter;\n \n use super::MISNAMED_GETTERS;\n \n-pub fn check_fn(\n-    cx: &LateContext<'_>,\n-    kind: FnKind<'_>,\n-    decl: &FnDecl<'_>,\n-    body: &Body<'_>,\n-    span: Span,\n-) {\n+pub fn check_fn(cx: &LateContext<'_>, kind: FnKind<'_>, decl: &FnDecl<'_>, body: &Body<'_>, span: Span) {\n     let FnKind::Method(ref ident, sig) = kind else {\n             return;\n         };"}, {"sha": "f2aa7b597a79b047754438082d3f4d7c64cea563", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -25,7 +25,7 @@ pub(super) fn check_fn<'tcx>(\n         intravisit::FnKind::Closure => return,\n     };\n \n-    check_raw_ptr(cx, unsafety, decl, body, def_id)\n+    check_raw_ptr(cx, unsafety, decl, body, def_id);\n }\n \n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {"}, {"sha": "c924d7361ce3bc2da460b2cbce993544a2ac1018", "filename": "clippy_lints/src/iter_not_returning_iterator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -66,7 +66,9 @@ impl<'tcx> LateLintPass<'tcx> for IterNotReturningIterator {\n \n fn check_sig(cx: &LateContext<'_>, name: &str, sig: &FnSig<'_>, fn_id: LocalDefId) {\n     if sig.decl.implicit_self.has_implicit_self() {\n-        let ret_ty = cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(fn_id).subst_identity().output());\n+        let ret_ty = cx\n+            .tcx\n+            .erase_late_bound_regions(cx.tcx.fn_sig(fn_id).subst_identity().output());\n         let ret_ty = cx\n             .tcx\n             .try_normalize_erasing_regions(cx.param_env, ret_ty)"}, {"sha": "e13bc47973b105430c99aa6038649aa8ea96787d", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -135,6 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if item.ident.name == sym::len;\n             if let ImplItemKind::Fn(sig, _) = &item.kind;\n             if sig.decl.implicit_self.has_implicit_self();\n+            if sig.decl.inputs.len() == 1;\n             if cx.effective_visibilities.is_exported(item.owner_id.def_id);\n             if matches!(sig.decl.output, FnRetTy::Return(_));\n             if let Some(imp) = get_parent_as_impl(cx.tcx, item.hir_id());\n@@ -196,7 +197,15 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     fn is_named_self(cx: &LateContext<'_>, item: &TraitItemRef, name: Symbol) -> bool {\n         item.ident.name == name\n             && if let AssocItemKind::Fn { has_self } = item.kind {\n-                has_self && { cx.tcx.fn_sig(item.id.owner_id).skip_binder().inputs().skip_binder().len() == 1 }\n+                has_self && {\n+                    cx.tcx\n+                        .fn_sig(item.id.owner_id)\n+                        .skip_binder()\n+                        .inputs()\n+                        .skip_binder()\n+                        .len()\n+                        == 1\n+                }\n             } else {\n                 false\n             }\n@@ -342,7 +351,11 @@ fn check_for_is_empty<'tcx>(\n         ),\n         Some(is_empty)\n             if !(is_empty.fn_has_self_parameter\n-                && check_is_empty_sig(cx.tcx.fn_sig(is_empty.def_id).subst_identity().skip_binder(), self_kind, output)) =>\n+                && check_is_empty_sig(\n+                    cx.tcx.fn_sig(is_empty.def_id).subst_identity().skip_binder(),\n+                    self_kind,\n+                    output,\n+                )) =>\n         {\n             (\n                 format!("}, {"sha": "565c5b7af006812306d4fd273239e619d2e9f90c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -121,6 +121,7 @@ mod excessive_bools;\n mod exhaustive_items;\n mod exit;\n mod explicit_write;\n+mod extra_unused_type_parameters;\n mod fallible_impl_from;\n mod float_literal;\n mod floating_point_arithmetic;\n@@ -909,6 +910,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(permissions_set_readonly_false::PermissionsSetReadonlyFalse));\n     store.register_late_pass(|_| Box::new(size_of_ref::SizeOfRef));\n     store.register_late_pass(|_| Box::new(multiple_unsafe_ops_per_block::MultipleUnsafeOpsPerBlock));\n+    store.register_late_pass(|_| Box::new(extra_unused_type_parameters::ExtraUnusedTypeParameters));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "43a1a65a43a9d0bf5d099b1b2f07188d74908f62", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 147, "deletions": 106, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,20 +1,21 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::nested_filter::{self as hir_nested_filter, NestedFilter};\n use rustc_hir::intravisit::{\n-    walk_fn_decl, walk_generic_arg, walk_generic_param, walk_generics, walk_impl_item_ref, walk_item, walk_param_bound,\n+    walk_fn_decl, walk_generic_param, walk_generics, walk_impl_item_ref, walk_item, walk_param_bound,\n     walk_poly_trait_ref, walk_trait_ref, walk_ty, Visitor,\n };\n-use rustc_hir::lang_items;\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n-    BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, LifetimeParamKind, PolyTraitRef, PredicateOrigin, TraitFn,\n-    TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n+    lang_items, BareFnTy, BodyId, FnDecl, FnSig, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics,\n+    Impl, ImplItem, ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, LifetimeParamKind, Node, PolyTraitRef,\n+    PredicateOrigin, TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n@@ -33,8 +34,6 @@ declare_clippy_lint! {\n     /// ### Known problems\n     /// - We bail out if the function has a `where` clause where lifetimes\n     /// are mentioned due to potential false positives.\n-    /// - Lifetime bounds such as `impl Foo + 'a` and `T: 'a` must be elided with the\n-    /// placeholder notation `'_` because the fully elided notation leaves the type bound to `'static`.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -92,7 +91,7 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, generics, id) = item.kind {\n-            check_fn_inner(cx, sig.decl, Some(id), None, generics, item.span, true);\n+            check_fn_inner(cx, sig, Some(id), None, generics, item.span, true);\n         } else if let ItemKind::Impl(impl_) = item.kind {\n             if !item.span.from_expansion() {\n                 report_extra_impl_lifetimes(cx, impl_);\n@@ -105,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n             let report_extra_lifetimes = trait_ref_of_method(cx, item.owner_id.def_id).is_none();\n             check_fn_inner(\n                 cx,\n-                sig.decl,\n+                sig,\n                 Some(id),\n                 None,\n                 item.generics,\n@@ -121,29 +120,21 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 TraitFn::Required(sig) => (None, Some(sig)),\n                 TraitFn::Provided(id) => (Some(id), None),\n             };\n-            check_fn_inner(cx, sig.decl, body, trait_sig, item.generics, item.span, true);\n+            check_fn_inner(cx, sig, body, trait_sig, item.generics, item.span, true);\n         }\n     }\n }\n \n-/// The lifetime of a &-reference.\n-#[derive(PartialEq, Eq, Hash, Debug, Clone)]\n-enum RefLt {\n-    Unnamed,\n-    Static,\n-    Named(LocalDefId),\n-}\n-\n fn check_fn_inner<'tcx>(\n     cx: &LateContext<'tcx>,\n-    decl: &'tcx FnDecl<'_>,\n+    sig: &'tcx FnSig<'_>,\n     body: Option<BodyId>,\n     trait_sig: Option<&[Ident]>,\n     generics: &'tcx Generics<'_>,\n     span: Span,\n     report_extra_lifetimes: bool,\n ) {\n-    if span.from_expansion() || has_where_lifetimes(cx, generics) {\n+    if in_external_macro(cx.sess(), span) || has_where_lifetimes(cx, generics) {\n         return;\n     }\n \n@@ -162,7 +153,7 @@ fn check_fn_inner<'tcx>(\n             for bound in pred.bounds {\n                 let mut visitor = RefVisitor::new(cx);\n                 walk_param_bound(&mut visitor, bound);\n-                if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n+                if visitor.lts.iter().any(|lt| matches!(lt.res, LifetimeName::Param(_))) {\n                     return;\n                 }\n                 if let GenericBound::Trait(ref trait_ref, _) = *bound {\n@@ -189,34 +180,112 @@ fn check_fn_inner<'tcx>(\n         }\n     }\n \n-    if let Some(elidable_lts) = could_use_elision(cx, decl, body, trait_sig, generics.params) {\n+    if let Some((elidable_lts, usages)) = could_use_elision(cx, sig.decl, body, trait_sig, generics.params) {\n         let lts = elidable_lts\n             .iter()\n             // In principle, the result of the call to `Node::ident` could be `unwrap`ped, as `DefId` should refer to a\n             // `Node::GenericParam`.\n-            .filter_map(|&(def_id, _)| cx.tcx.hir().get_by_def_id(def_id).ident())\n+            .filter_map(|&def_id| cx.tcx.hir().get_by_def_id(def_id).ident())\n             .map(|ident| ident.to_string())\n             .collect::<Vec<_>>()\n             .join(\", \");\n \n         span_lint_and_then(\n             cx,\n             NEEDLESS_LIFETIMES,\n-            span.with_hi(decl.output.span().hi()),\n+            span.with_hi(sig.decl.output.span().hi()),\n             &format!(\"the following explicit lifetimes could be elided: {lts}\"),\n             |diag| {\n-                if let Some(span) = elidable_lts.iter().find_map(|&(_, span)| span) {\n-                    diag.span_help(span, \"replace with `'_` in generic arguments such as here\");\n+                if sig.header.is_async() {\n+                    // async functions have usages whose spans point at the lifetime declaration which messes up\n+                    // suggestions\n+                    return;\n+                };\n+\n+                if let Some(suggestions) = elision_suggestions(cx, generics, &elidable_lts, &usages) {\n+                    diag.multipart_suggestion(\"elide the lifetimes\", suggestions, Applicability::MachineApplicable);\n                 }\n             },\n         );\n     }\n \n     if report_extra_lifetimes {\n-        self::report_extra_lifetimes(cx, decl, generics);\n+        self::report_extra_lifetimes(cx, sig.decl, generics);\n     }\n }\n \n+fn elision_suggestions(\n+    cx: &LateContext<'_>,\n+    generics: &Generics<'_>,\n+    elidable_lts: &[LocalDefId],\n+    usages: &[Lifetime],\n+) -> Option<Vec<(Span, String)>> {\n+    let explicit_params = generics\n+        .params\n+        .iter()\n+        .filter(|param| !param.is_elided_lifetime() && !param.is_impl_trait())\n+        .collect::<Vec<_>>();\n+\n+    let mut suggestions = if elidable_lts.len() == explicit_params.len() {\n+        // if all the params are elided remove the whole generic block\n+        //\n+        // fn x<'a>() {}\n+        //     ^^^^\n+        vec![(generics.span, String::new())]\n+    } else {\n+        elidable_lts\n+            .iter()\n+            .map(|&id| {\n+                let pos = explicit_params.iter().position(|param| param.def_id == id)?;\n+                let param = explicit_params.get(pos)?;\n+\n+                let span = if let Some(next) = explicit_params.get(pos + 1) {\n+                    // fn x<'prev, 'a, 'next>() {}\n+                    //             ^^^^\n+                    param.span.until(next.span)\n+                } else {\n+                    // `pos` should be at least 1 here, because the param in position 0 would either have a `next`\n+                    // param or would have taken the `elidable_lts.len() == explicit_params.len()` branch.\n+                    let prev = explicit_params.get(pos - 1)?;\n+\n+                    // fn x<'prev, 'a>() {}\n+                    //           ^^^^\n+                    param.span.with_lo(prev.span.hi())\n+                };\n+\n+                Some((span, String::new()))\n+            })\n+            .collect::<Option<Vec<_>>>()?\n+    };\n+\n+    suggestions.extend(\n+        usages\n+            .iter()\n+            .filter(|usage| named_lifetime(usage).map_or(false, |id| elidable_lts.contains(&id)))\n+            .map(|usage| {\n+                match cx.tcx.hir().get_parent(usage.hir_id) {\n+                    Node::Ty(Ty {\n+                        kind: TyKind::Ref(..), ..\n+                    }) => {\n+                        // expand `&'a T` to `&'a T`\n+                        //          ^^         ^^^\n+                        let span = cx\n+                            .sess()\n+                            .source_map()\n+                            .span_extend_while(usage.ident.span, |ch| ch.is_ascii_whitespace())\n+                            .unwrap_or(usage.ident.span);\n+\n+                        (span, String::new())\n+                    },\n+                    // `T<'a>` and `impl Foo + 'a` should be replaced by `'_`\n+                    _ => (usage.ident.span, String::from(\"'_\")),\n+                }\n+            }),\n+    );\n+\n+    Some(suggestions)\n+}\n+\n // elision doesn't work for explicit self types, see rust-lang/rust#69064\n fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident: Option<Ident>) -> bool {\n     if_chain! {\n@@ -236,13 +305,20 @@ fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident:\n     }\n }\n \n+fn named_lifetime(lt: &Lifetime) -> Option<LocalDefId> {\n+    match lt.res {\n+        LifetimeName::Param(id) if !lt.is_anonymous() => Some(id),\n+        _ => None,\n+    }\n+}\n+\n fn could_use_elision<'tcx>(\n     cx: &LateContext<'tcx>,\n     func: &'tcx FnDecl<'_>,\n     body: Option<BodyId>,\n     trait_sig: Option<&[Ident]>,\n     named_generics: &'tcx [GenericParam<'_>],\n-) -> Option<Vec<(LocalDefId, Option<Span>)>> {\n+) -> Option<(Vec<LocalDefId>, Vec<Lifetime>)> {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -300,32 +376,24 @@ fn could_use_elision<'tcx>(\n \n     // check for lifetimes from higher scopes\n     for lt in input_lts.iter().chain(output_lts.iter()) {\n-        if !allowed_lts.contains(lt) {\n+        if let Some(id) = named_lifetime(lt)\n+            && !allowed_lts.contains(&id)\n+        {\n             return None;\n         }\n     }\n \n     // check for higher-ranked trait bounds\n     if !input_visitor.nested_elision_site_lts.is_empty() || !output_visitor.nested_elision_site_lts.is_empty() {\n-        let allowed_lts: FxHashSet<_> = allowed_lts\n-            .iter()\n-            .filter_map(|lt| match lt {\n-                RefLt::Named(def_id) => Some(cx.tcx.item_name(def_id.to_def_id())),\n-                _ => None,\n-            })\n-            .collect();\n+        let allowed_lts: FxHashSet<_> = allowed_lts.iter().map(|id| cx.tcx.item_name(id.to_def_id())).collect();\n         for lt in input_visitor.nested_elision_site_lts {\n-            if let RefLt::Named(def_id) = lt {\n-                if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n-                    return None;\n-                }\n+            if allowed_lts.contains(&lt.ident.name) {\n+                return None;\n             }\n         }\n         for lt in output_visitor.nested_elision_site_lts {\n-            if let RefLt::Named(def_id) = lt {\n-                if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n-                    return None;\n-                }\n+            if allowed_lts.contains(&lt.ident.name) {\n+                return None;\n             }\n         }\n     }\n@@ -337,47 +405,45 @@ fn could_use_elision<'tcx>(\n     let elidable_lts = named_lifetime_occurrences(&input_lts)\n         .into_iter()\n         .filter_map(|(def_id, occurrences)| {\n-            if occurrences == 1 && (input_lts.len() == 1 || !output_lts.contains(&RefLt::Named(def_id))) {\n-                Some((\n-                    def_id,\n-                    input_visitor\n-                        .lifetime_generic_arg_spans\n-                        .get(&def_id)\n-                        .or_else(|| output_visitor.lifetime_generic_arg_spans.get(&def_id))\n-                        .copied(),\n-                ))\n+            if occurrences == 1\n+                && (input_lts.len() == 1 || !output_lts.iter().any(|lt| named_lifetime(lt) == Some(def_id)))\n+            {\n+                Some(def_id)\n             } else {\n                 None\n             }\n         })\n         .collect::<Vec<_>>();\n \n     if elidable_lts.is_empty() {\n-        None\n-    } else {\n-        Some(elidable_lts)\n+        return None;\n     }\n+\n+    let usages = itertools::chain(input_lts, output_lts).collect();\n+\n+    Some((elidable_lts, usages))\n }\n \n-fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n-    let mut allowed_lts = FxHashSet::default();\n-    for par in named_generics.iter() {\n-        if let GenericParamKind::Lifetime { .. } = par.kind {\n-            allowed_lts.insert(RefLt::Named(par.def_id));\n-        }\n-    }\n-    allowed_lts.insert(RefLt::Unnamed);\n-    allowed_lts.insert(RefLt::Static);\n-    allowed_lts\n+fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<LocalDefId> {\n+    named_generics\n+        .iter()\n+        .filter_map(|par| {\n+            if let GenericParamKind::Lifetime { .. } = par.kind {\n+                Some(par.def_id)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect()\n }\n \n /// Number of times each named lifetime occurs in the given slice. Returns a vector to preserve\n /// relative order.\n #[must_use]\n-fn named_lifetime_occurrences(lts: &[RefLt]) -> Vec<(LocalDefId, usize)> {\n+fn named_lifetime_occurrences(lts: &[Lifetime]) -> Vec<(LocalDefId, usize)> {\n     let mut occurrences = Vec::new();\n     for lt in lts {\n-        if let &RefLt::Named(curr_def_id) = lt {\n+        if let Some(curr_def_id) = named_lifetime(lt) {\n             if let Some(pair) = occurrences\n                 .iter_mut()\n                 .find(|(prev_def_id, _)| *prev_def_id == curr_def_id)\n@@ -391,12 +457,10 @@ fn named_lifetime_occurrences(lts: &[RefLt]) -> Vec<(LocalDefId, usize)> {\n     occurrences\n }\n \n-/// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    lts: Vec<RefLt>,\n-    lifetime_generic_arg_spans: FxHashMap<LocalDefId, Span>,\n-    nested_elision_site_lts: Vec<RefLt>,\n+    lts: Vec<Lifetime>,\n+    nested_elision_site_lts: Vec<Lifetime>,\n     unelided_trait_object_lifetime: bool,\n }\n \n@@ -405,32 +469,16 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         Self {\n             cx,\n             lts: Vec::new(),\n-            lifetime_generic_arg_spans: FxHashMap::default(),\n             nested_elision_site_lts: Vec::new(),\n             unelided_trait_object_lifetime: false,\n         }\n     }\n \n-    fn record(&mut self, lifetime: &Option<Lifetime>) {\n-        if let Some(ref lt) = *lifetime {\n-            if lt.is_static() {\n-                self.lts.push(RefLt::Static);\n-            } else if lt.is_anonymous() {\n-                // Fresh lifetimes generated should be ignored.\n-                self.lts.push(RefLt::Unnamed);\n-            } else if let LifetimeName::Param(def_id) = lt.res {\n-                self.lts.push(RefLt::Named(def_id));\n-            }\n-        } else {\n-            self.lts.push(RefLt::Unnamed);\n-        }\n-    }\n-\n-    fn all_lts(&self) -> Vec<RefLt> {\n+    fn all_lts(&self) -> Vec<Lifetime> {\n         self.lts\n             .iter()\n             .chain(self.nested_elision_site_lts.iter())\n-            .cloned()\n+            .copied()\n             .collect::<Vec<_>>()\n     }\n \n@@ -442,7 +490,7 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        self.record(&Some(*lifetime));\n+        self.lts.push(*lifetime);\n     }\n \n     fn visit_poly_trait_ref(&mut self, poly_tref: &'tcx PolyTraitRef<'tcx>) {\n@@ -467,11 +515,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 walk_item(self, item);\n                 self.lts.truncate(len);\n                 self.lts.extend(bounds.iter().filter_map(|bound| match bound {\n-                    GenericArg::Lifetime(l) => Some(if let LifetimeName::Param(def_id) = l.res {\n-                        RefLt::Named(def_id)\n-                    } else {\n-                        RefLt::Unnamed\n-                    }),\n+                    GenericArg::Lifetime(&l) => Some(l),\n                     _ => None,\n                 }));\n             },\n@@ -491,13 +535,6 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             _ => walk_ty(self, ty),\n         }\n     }\n-\n-    fn visit_generic_arg(&mut self, generic_arg: &'tcx GenericArg<'tcx>) {\n-        if let GenericArg::Lifetime(l) = generic_arg && let LifetimeName::Param(def_id) = l.res {\n-            self.lifetime_generic_arg_spans.entry(def_id).or_insert(l.ident.span);\n-        }\n-        walk_generic_arg(self, generic_arg);\n-    }\n }\n \n /// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n@@ -521,8 +558,12 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, generics: &'tcx Generics<'_\n                     walk_param_bound(&mut visitor, bound);\n                 }\n                 // and check that all lifetimes are allowed\n-                if visitor.all_lts().iter().any(|it| !allowed_lts.contains(it)) {\n-                    return true;\n+                for lt in visitor.all_lts() {\n+                    if let Some(id) = named_lifetime(&lt)\n+                        && !allowed_lts.contains(&id)\n+                    {\n+                        return true;\n+                    }\n                 }\n             },\n             WherePredicate::EqPredicate(ref pred) => {"}, {"sha": "610a0233eee15b4564002c5420bb466cc2873c5a", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -61,7 +61,8 @@ declare_clippy_lint! {\n     ///\n     /// ### Why is this bad?\n     /// Just iterating the collection itself makes the intent\n-    /// more clear and is probably faster.\n+    /// more clear and is probably faster because it eliminates\n+    /// the bounds check that is done when indexing.\n     ///\n     /// ### Example\n     /// ```rust"}, {"sha": "25a1a5842f77bb15d4f8442af812105c38bc3643", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -149,7 +149,7 @@ pub(super) fn check<'tcx>(\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n-                                \"consider using an iterator\",\n+                                \"consider using an iterator and enumerate()\",\n                                 vec![\n                                     (pat.span, format!(\"({}, <item>)\", ident.name)),\n                                     ("}, {"sha": "26ae4b409c79570d116147e24477ee335bda9c3f", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -35,7 +35,8 @@ struct PathAndSpan {\n     span: Span,\n }\n \n-/// `MacroRefData` includes the name of the macro.\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n pub struct MacroRefData {\n     name: String,"}, {"sha": "ce5d657bcf0e3cff6e44a6a65410d471e7a62852", "filename": "clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_assert.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,7 +1,6 @@\n use crate::rustc_lint::LintContext;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::macros::{root_macro_call, FormatArgsExpn};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::macros::root_macro_call;\n use clippy_utils::{is_else_clause, peel_blocks_with_stmt, span_extract_comment, sugg};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, UnOp};\n@@ -38,57 +37,57 @@ declare_lint_pass!(ManualAssert => [MANUAL_ASSERT]);\n \n impl<'tcx> LateLintPass<'tcx> for ManualAssert {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if_chain! {\n-            if let ExprKind::If(cond, then, None) = expr.kind;\n-            if !matches!(cond.kind, ExprKind::Let(_));\n-            if !expr.span.from_expansion();\n-            let then = peel_blocks_with_stmt(then);\n-            if let Some(macro_call) = root_macro_call(then.span);\n-            if cx.tcx.item_name(macro_call.def_id) == sym::panic;\n-            if !cx.tcx.sess.source_map().is_multiline(cond.span);\n-            if let Some(format_args) = FormatArgsExpn::find_nested(cx, then, macro_call.expn);\n+        if let ExprKind::If(cond, then, None) = expr.kind\n+            && !matches!(cond.kind, ExprKind::Let(_))\n+            && !expr.span.from_expansion()\n+            && let then = peel_blocks_with_stmt(then)\n+            && let Some(macro_call) = root_macro_call(then.span)\n+            && cx.tcx.item_name(macro_call.def_id) == sym::panic\n+            && !cx.tcx.sess.source_map().is_multiline(cond.span)\n+            && let Ok(panic_snippet) = cx.sess().source_map().span_to_snippet(macro_call.span)\n+            && let Some(panic_snippet) = panic_snippet.strip_suffix(')')\n+            && let Some((_, format_args_snip)) = panic_snippet.split_once('(')\n             // Don't change `else if foo { panic!(..) }` to `else { assert!(foo, ..) }` as it just\n             // shuffles the condition around.\n             // Should this have a config value?\n-            if !is_else_clause(cx.tcx, expr);\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let format_args_snip = snippet_with_applicability(cx, format_args.inputs_span(), \"..\", &mut applicability);\n-                let cond = cond.peel_drop_temps();\n-                let mut comments = span_extract_comment(cx.sess().source_map(), expr.span);\n-                if !comments.is_empty() {\n-                    comments += \"\\n\";\n-                }\n-                let (cond, not) = match cond.kind {\n-                    ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n-                    _ => (cond, \"!\"),\n-                };\n-                let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n-                let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n-                // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_ASSERT,\n-                    expr.span,\n-                    \"only a `panic!` in `if`-then statement\",\n-                    |diag| {\n-                        // comments can be noisy, do not show them to the user\n-                        if !comments.is_empty() {\n-                            diag.tool_only_span_suggestion(\n-                                        expr.span.shrink_to_lo(),\n-                                        \"add comments back\",\n-                                        comments,\n-                                        applicability);\n-                        }\n-                        diag.span_suggestion(\n-                                    expr.span,\n-                                    \"try instead\",\n-                                    sugg,\n-                                    applicability);\n-                                     }\n-\n-                );\n+            && !is_else_clause(cx.tcx, expr)\n+        {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let cond = cond.peel_drop_temps();\n+            let mut comments = span_extract_comment(cx.sess().source_map(), expr.span);\n+            if !comments.is_empty() {\n+                comments += \"\\n\";\n             }\n+            let (cond, not) = match cond.kind {\n+                ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n+                _ => (cond, \"!\"),\n+            };\n+            let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n+            let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n+            // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_ASSERT,\n+                expr.span,\n+                \"only a `panic!` in `if`-then statement\",\n+                |diag| {\n+                    // comments can be noisy, do not show them to the user\n+                    if !comments.is_empty() {\n+                        diag.tool_only_span_suggestion(\n+                            expr.span.shrink_to_lo(),\n+                            \"add comments back\",\n+                            comments,\n+                            applicability\n+                        );\n+                    }\n+                    diag.span_suggestion(\n+                        expr.span,\n+                        \"try instead\",\n+                        sugg,\n+                        applicability\n+                    );\n+                }\n+            );\n         }\n     }\n }"}, {"sha": "3126b590180e67621371c3dc30088c40dba31c3e", "filename": "clippy_lints/src/matches/match_wild_enum.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -45,8 +45,13 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n \n     // Accumulate the variants which should be put in place of the wildcard because they're not\n     // already covered.\n-    let has_hidden = adt_def.variants().iter().any(|x| is_hidden(cx, x));\n-    let mut missing_variants: Vec<_> = adt_def.variants().iter().filter(|x| !is_hidden(cx, x)).collect();\n+    let is_external = adt_def.did().as_local().is_none();\n+    let has_external_hidden = is_external && adt_def.variants().iter().any(|x| is_hidden(cx, x));\n+    let mut missing_variants: Vec<_> = adt_def\n+        .variants()\n+        .iter()\n+        .filter(|x| !(is_external && is_hidden(cx, x)))\n+        .collect();\n \n     let mut path_prefix = CommonPrefixSearcher::None;\n     for arm in arms {\n@@ -133,7 +138,7 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n \n     match missing_variants.as_slice() {\n         [] => (),\n-        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n+        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_external_hidden => span_lint_and_sugg(\n             cx,\n             MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n             wildcard_span,\n@@ -144,7 +149,7 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n         ),\n         variants => {\n             let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n-            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n+            let message = if adt_def.is_variant_list_non_exhaustive() || has_external_hidden {\n                 suggestions.push(\"_\".into());\n                 \"wildcard matches known variants and will also match future added variants\"\n             } else {"}, {"sha": "122088f4857cd5925b37b8c744fecaf34b3578ed", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::symbol::{Symbol, sym};\n+use rustc_span::symbol::{sym, Symbol};\n \n use super::INEFFICIENT_TO_STRING;\n "}, {"sha": "f1e8be7f2b87f4b117e361a69cb9b9444ea60d18", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1818,6 +1818,7 @@ declare_clippy_lint! {\n     ///  - `or_else` to `or`\n     ///  - `get_or_insert_with` to `get_or_insert`\n     ///  - `ok_or_else` to `ok_or`\n+    ///  - `then` to `then_some` (for msrv >= 1.62.0)\n     ///\n     /// ### Why is this bad?\n     /// Using eager evaluation is shorter and simpler in some cases."}, {"sha": "e818f1892e510a9a2decbbc4d95ea1d6247492e4", "filename": "clippy_lints/src/methods/suspicious_to_owned.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_to_owned.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::is_diag_trait_item;\n use clippy_utils::source::snippet_with_context;\n use if_chain::if_chain;\n@@ -17,19 +17,31 @@ pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) -\n         let input_type = cx.typeck_results().expr_ty(expr);\n         if let ty::Adt(adt, _) = cx.typeck_results().expr_ty(expr).kind();\n         if cx.tcx.is_diagnostic_item(sym::Cow, adt.did());\n+\n         then {\n             let mut app = Applicability::MaybeIncorrect;\n             let recv_snip = snippet_with_context(cx, recv.span, expr.span.ctxt(), \"..\", &mut app).0;\n-            span_lint_and_sugg(\n+            span_lint_and_then(\n                 cx,\n                 SUSPICIOUS_TO_OWNED,\n                 expr.span,\n                 &with_forced_trimmed_paths!(format!(\n                     \"this `to_owned` call clones the {input_type} itself and does not cause the {input_type} contents to become owned\"\n                 )),\n-                \"consider using, depending on intent\",\n-                format!(\"{recv_snip}.clone()` or `{recv_snip}.into_owned()\"),\n-                app,\n+                |diag| {\n+                    diag.span_suggestion(\n+                        expr.span,\n+                        \"depending on intent, either make the Cow an Owned variant\",\n+                        format!(\"{recv_snip}.into_owned()\"),\n+                        app\n+                    );\n+                    diag.span_suggestion(\n+                        expr.span,\n+                        \"or clone the Cow itself\",\n+                        format!(\"{recv_snip}.clone()\"),\n+                        app\n+                    );\n+                }\n             );\n             return true;\n         }"}, {"sha": "9942e8115b7f87b4c439fc9e1bc2bea6d1bbca75", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -8,6 +8,7 @@\n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::is_from_proc_macro;\n+use if_chain::if_chain;\n use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};"}, {"sha": "63c575fca30ba17b2fecc1bf616e564345f6c10f", "filename": "clippy_lints/src/multiple_unsafe_ops_per_block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_unsafe_ops_per_block.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -10,6 +10,7 @@ use hir::{\n use rustc_ast::Mutability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n \n@@ -66,7 +67,7 @@ declare_lint_pass!(MultipleUnsafeOpsPerBlock => [MULTIPLE_UNSAFE_OPS_PER_BLOCK])\n \n impl<'tcx> LateLintPass<'tcx> for MultipleUnsafeOpsPerBlock {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n-        if !matches!(block.rules, BlockCheckMode::UnsafeBlock(_)) {\n+        if !matches!(block.rules, BlockCheckMode::UnsafeBlock(_)) || in_external_macro(cx.tcx.sess, block.span) {\n             return;\n         }\n         let mut unsafe_ops = vec![];"}, {"sha": "3ef0c6634598474189ba0b5415d733304b2d2671", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -92,10 +92,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "c5ea09590d3df40218dada8bb8417d92bd138010", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -25,11 +25,11 @@ declare_clippy_lint! {\n     /// Using the dedicated functions of the `Option` type is clearer and\n     /// more concise than an `if let` expression.\n     ///\n-    /// ### Known problems\n-    /// This lint uses a deliberately conservative metric for checking\n-    /// if the inside of either body contains breaks or continues which will\n-    /// cause it to not suggest a fix if either block contains a loop with\n-    /// continues or breaks contained within the loop.\n+    /// ### Notes\n+    /// This lint uses a deliberately conservative metric for checking if the\n+    /// inside of either body contains loop control expressions `break` or\n+    /// `continue` (which cannot be used within closures). If these are found,\n+    /// this lint will not be raised.\n     ///\n     /// ### Example\n     /// ```rust"}, {"sha": "d88409c356e913e3cc8268208a7a502ec29bf723", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -624,7 +624,10 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             return;\n                         };\n \n-                        match *self.cx.tcx.fn_sig(id).subst_identity().skip_binder().inputs()[i].peel_refs().kind() {\n+                        match *self.cx.tcx.fn_sig(id).subst_identity().skip_binder().inputs()[i]\n+                            .peel_refs()\n+                            .kind()\n+                        {\n                             ty::Dynamic(preds, _, _) if !matches_preds(self.cx, args.deref_ty.ty(self.cx), preds) => {\n                                 set_skip_flag();\n                             },"}, {"sha": "9e6c6c73d4fe74cc3b351e03fa50f346bee79497", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,5 +1,8 @@\n+use std::fmt::Display;\n+\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n+use clippy_utils::source::snippet_opt;\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{LitKind, StrStyle};\n@@ -77,13 +80,45 @@ impl<'tcx> LateLintPass<'tcx> for Regex {\n     }\n }\n \n-#[must_use]\n-fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u8) -> Span {\n-    let offset = u32::from(offset);\n-    let end = base.lo() + BytePos(u32::try_from(c.end.offset).expect(\"offset too large\") + offset);\n-    let start = base.lo() + BytePos(u32::try_from(c.start.offset).expect(\"offset too large\") + offset);\n-    assert!(start <= end);\n-    Span::new(start, end, base.ctxt(), base.parent())\n+fn lint_syntax_error(cx: &LateContext<'_>, error: &regex_syntax::Error, unescaped: &str, base: Span, offset: u8) {\n+    let parts: Option<(_, _, &dyn Display)> = match &error {\n+        regex_syntax::Error::Parse(e) => Some((e.span(), e.auxiliary_span(), e.kind())),\n+        regex_syntax::Error::Translate(e) => Some((e.span(), None, e.kind())),\n+        _ => None,\n+    };\n+\n+    let convert_span = |regex_span: &regex_syntax::ast::Span| {\n+        let offset = u32::from(offset);\n+        let start = base.lo() + BytePos(u32::try_from(regex_span.start.offset).expect(\"offset too large\") + offset);\n+        let end = base.lo() + BytePos(u32::try_from(regex_span.end.offset).expect(\"offset too large\") + offset);\n+\n+        Span::new(start, end, base.ctxt(), base.parent())\n+    };\n+\n+    if let Some((primary, auxiliary, kind)) = parts\n+        && let Some(literal_snippet) = snippet_opt(cx, base)\n+        && let Some(inner) = literal_snippet.get(offset as usize..)\n+        // Only convert to native rustc spans if the parsed regex matches the\n+        // source snippet exactly, to ensure the span offsets are correct\n+        && inner.get(..unescaped.len()) == Some(unescaped)\n+    {\n+        let spans = if let Some(auxiliary) = auxiliary {\n+            vec![convert_span(primary), convert_span(auxiliary)]\n+        } else {\n+            vec![convert_span(primary)]\n+        };\n+\n+        span_lint(cx, INVALID_REGEX, spans, &format!(\"regex syntax error: {kind}\"));\n+    } else {\n+        span_lint_and_help(\n+            cx,\n+            INVALID_REGEX,\n+            base,\n+            &error.to_string(),\n+            None,\n+            \"consider using a raw string literal: `r\\\"..\\\"`\",\n+        );\n+    }\n }\n \n fn const_str<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n@@ -155,25 +190,7 @@ fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n                         span_lint_and_help(cx, TRIVIAL_REGEX, expr.span, \"trivial regex\", None, repl);\n                     }\n                 },\n-                Err(regex_syntax::Error::Parse(e)) => {\n-                    span_lint(\n-                        cx,\n-                        INVALID_REGEX,\n-                        str_span(expr.span, *e.span(), offset),\n-                        &format!(\"regex syntax error: {}\", e.kind()),\n-                    );\n-                },\n-                Err(regex_syntax::Error::Translate(e)) => {\n-                    span_lint(\n-                        cx,\n-                        INVALID_REGEX,\n-                        str_span(expr.span, *e.span(), offset),\n-                        &format!(\"regex syntax error: {}\", e.kind()),\n-                    );\n-                },\n-                Err(e) => {\n-                    span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {e}\"));\n-                },\n+                Err(e) => lint_syntax_error(cx, &e, r, expr.span, offset),\n             }\n         }\n     } else if let Some(r) = const_str(cx, expr) {\n@@ -183,25 +200,7 @@ fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n                     span_lint_and_help(cx, TRIVIAL_REGEX, expr.span, \"trivial regex\", None, repl);\n                 }\n             },\n-            Err(regex_syntax::Error::Parse(e)) => {\n-                span_lint(\n-                    cx,\n-                    INVALID_REGEX,\n-                    expr.span,\n-                    &format!(\"regex syntax error on position {}: {}\", e.span().start.offset, e.kind()),\n-                );\n-            },\n-            Err(regex_syntax::Error::Translate(e)) => {\n-                span_lint(\n-                    cx,\n-                    INVALID_REGEX,\n-                    expr.span,\n-                    &format!(\"regex syntax error on position {}: {}\", e.span().start.offset, e.kind()),\n-                );\n-            },\n-            Err(e) => {\n-                span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {e}\"));\n-            },\n+            Err(e) => span_lint(cx, INVALID_REGEX, expr.span, &e.to_string()),\n         }\n     }\n }"}, {"sha": "bccf421e8f3bfc5ec32b0c41c06c8d3035de1ea8", "filename": "clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -78,8 +78,8 @@ fn check_method(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_def: LocalDefId, spa\n         // We don't want to emit this lint if the `#[must_use]` attribute is already there.\n         if !cx.tcx.hir().attrs(owner_id.into()).iter().any(|attr| attr.has_name(sym::must_use));\n         if cx.tcx.visibility(fn_def.to_def_id()).is_public();\n-        let ret_ty = return_ty(cx, owner_id.into());\n-        let self_arg = nth_arg(cx, owner_id.into(), 0);\n+        let ret_ty = return_ty(cx, owner_id);\n+        let self_arg = nth_arg(cx, owner_id, 0);\n         // If `Self` has the same type as the returned type, then we want to warn.\n         //\n         // For this check, we don't want to remove the reference on the returned type because if"}, {"sha": "f35bfb0b4ed884c01f8a1641e8a0e71e31c783f1", "filename": "clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -55,11 +55,11 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n             if matches!(cx.tcx.def_kind(id.owner_id), DefKind::Impl)\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n-                  items,\n-                  of_trait,\n-                  self_ty,\n-                  ..\n-                                      }) = &item.kind\n+                    items,\n+                    of_trait,\n+                    self_ty,\n+                    ..\n+                }) = &item.kind\n                 && let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind\n             {\n                 if !map.contains_key(res) {"}, {"sha": "34a3e5ddf4f6b371ad51ddee014e27a9120b58d6", "filename": "clippy_lints/src/semicolon_block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fsemicolon_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Fsemicolon_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsemicolon_block.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -30,7 +30,7 @@ declare_clippy_lint! {\n     /// # let x = 0;\n     /// unsafe { f(x); }\n     /// ```\n-    #[clippy::version = \"1.66.0\"]\n+    #[clippy::version = \"1.68.0\"]\n     pub SEMICOLON_INSIDE_BLOCK,\n     restriction,\n     \"add a semicolon inside the block\"\n@@ -59,7 +59,7 @@ declare_clippy_lint! {\n     /// # let x = 0;\n     /// unsafe { f(x) };\n     /// ```\n-    #[clippy::version = \"1.66.0\"]\n+    #[clippy::version = \"1.68.0\"]\n     pub SEMICOLON_OUTSIDE_BLOCK,\n     restriction,\n     \"add a semicolon outside the block\""}, {"sha": "c1f228d5f90a916fd44cb4cfd578cf15b445a345", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -392,9 +392,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        let is_exported = cx\n-            .effective_visibilities\n-            .is_exported(field.def_id);\n+        let is_exported = cx.effective_visibilities.is_exported(field.def_id);\n \n         self.check_ty(\n             cx,"}, {"sha": "0e526c216beeadda0306b2ffdc825bbfdedea4f0", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -65,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n                 }\n             },\n             hir::ExprKind::MethodCall(path, arg_0, ..) => match path.ident.as_str() {\n-                \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n+                \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" | \"is_ok\" | \"is_err\" => {\n                     check_map_error(cx, arg_0, expr);\n                 },\n                 _ => (),"}, {"sha": "1d78c7cfae0dfc6e74dea3b7b7f37ec9cc6f97b1", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -253,7 +253,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP, MANUAL_LET_ELSE, UNCHECKED_DURATION_SUBTRACTION.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP, MANUAL_LET_ELSE, UNCHECKED_DURATION_SUBTRACTION, COLLAPSIBLE_STR_REPLACE, SEEK_FROM_CURRENT, SEEK_REWIND, UNNECESSARY_LAZY_EVALUATIONS, TRANSMUTE_PTR_TO_REF, ALMOST_COMPLETE_RANGE, NEEDLESS_BORROW, DERIVABLE_IMPLS, MANUAL_IS_ASCII_CHECK, MANUAL_REM_EUCLID, MANUAL_RETAIN.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n@@ -323,7 +323,7 @@ define_Conf! {\n     ///\n     /// The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n     (trivial_copy_size_limit: Option<u64> = None),\n-    /// Lint: LARGE_TYPE_PASS_BY_MOVE.\n+    /// Lint: LARGE_TYPES_PASSED_BY_VALUE.\n     ///\n     /// The minimum size (in bytes) to consider a type for passing by reference instead of by value.\n     (pass_by_value_size_limit: u64 = 256),\n@@ -411,7 +411,7 @@ define_Conf! {\n     /// the slice pattern that is suggested. If more elements would be necessary, the lint is suppressed.\n     /// For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n     (max_suggested_slice_pattern_length: u64 = 3),\n-    /// Lint: AWAIT_HOLDING_INVALID_TYPE\n+    /// Lint: AWAIT_HOLDING_INVALID_TYPE.\n     (await_holding_invalid_types: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: LARGE_INCLUDE_FILE.\n     ///\n@@ -437,7 +437,7 @@ define_Conf! {\n     ///\n     /// The maximum size of the `Err`-variant in a `Result` returned from a function\n     (large_error_threshold: u64 = 128),\n-    /// Lint: MUTABLE_KEY.\n+    /// Lint: MUTABLE_KEY_TYPE.\n     ///\n     /// A list of paths to types that should be treated like `Arc`, i.e. ignored but\n     /// for the generic parameters for determining interior mutability\n@@ -446,7 +446,7 @@ define_Conf! {\n     ///\n     /// Whether to allow mixed uninlined format args, e.g. `format!(\"{} {}\", a, foo.bar)`\n     (allow_mixed_uninlined_format_args: bool = true),\n-    /// Lint: INDEXING_SLICING\n+    /// Lint: INDEXING_SLICING.\n     ///\n     /// Whether to suppress a restriction lint in constant code. In same\n     /// cases the restructured operation might not be unavoidable, as the"}, {"sha": "092041aecf29c6e6da64eea6b578b8910c440738", "filename": "clippy_lints/src/utils/dump_hir.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::get_attr;\n+use hir::TraitItem;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -47,6 +48,18 @@ impl<'tcx> LateLintPass<'tcx> for DumpHir {\n             println!(\"{stmt:#?}\");\n         }\n     }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n+        if has_attr(cx, item.hir_id()) {\n+            println!(\"{item:#?}\");\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, item: &hir::ImplItem<'_>) {\n+        if has_attr(cx, item.hir_id()) {\n+            println!(\"{item:#?}\");\n+        }\n+    }\n }\n \n fn has_attr(cx: &LateContext<'_>, hir_id: hir::HirId) -> bool {"}, {"sha": "f718207654f44d836172a74dfbe81bc47a72d20e", "filename": "clippy_lints/src/utils/internal_lints/lint_without_lint_pass.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -215,14 +215,13 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n                     cx,\n                 };\n                 let body_id = cx.tcx.hir().body_owned_by(\n-                    cx.tcx.hir().local_def_id(\n-                        impl_item_refs\n-                            .iter()\n-                            .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n-                            .expect(\"LintPass needs to implement get_lints\")\n-                            .id\n-                            .hir_id(),\n-                    ),\n+                    impl_item_refs\n+                        .iter()\n+                        .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n+                        .expect(\"LintPass needs to implement get_lints\")\n+                        .id\n+                        .owner_id\n+                        .def_id,\n                 );\n                 collector.visit_expr(cx.tcx.hir().body(body_id).value);\n             }"}, {"sha": "63dccbf697c2de049c3ffca7bb8379fb578b9df3", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -770,10 +770,7 @@ impl<'tcx> FormatSpec<'tcx> {\n     /// Has no other formatting specifiers than setting the format trait. returns true for `{}`,\n     /// `{foo}`, `{:?}`, but false for `{foo:5}`, `{3:.5?}`\n     pub fn is_default_for_trait(&self) -> bool {\n-        self.width.is_implied()\n-            && self.precision.is_implied()\n-            && self.align == Alignment::AlignUnknown\n-            && self.no_flags\n+        self.width.is_implied() && self.precision.is_implied() && self.align == Alignment::AlignUnknown && self.no_flags\n     }\n }\n "}, {"sha": "78fb2e0eb7e6885da01b365998f4bb55c6b0a84c", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -809,7 +809,10 @@ pub struct DerefClosure {\n ///\n /// note: this only works on single line immutable closures with exactly one input parameter.\n pub fn deref_closure_args(cx: &LateContext<'_>, closure: &hir::Expr<'_>) -> Option<DerefClosure> {\n-    if let hir::ExprKind::Closure(&Closure { fn_decl, def_id, body, .. }) = closure.kind {\n+    if let hir::ExprKind::Closure(&Closure {\n+        fn_decl, def_id, body, ..\n+    }) = closure.kind\n+    {\n         let closure_body = cx.tcx.hir().body(body);\n         // is closure arg a type annotated double reference (i.e.: `|x: &&i32| ...`)\n         // a type annotation is present if param `kind` is different from `TyKind::Infer`"}, {"sha": "00073bcd82affcc3584b4908547e14ce798aade0", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -392,12 +392,16 @@ pub fn is_expr_unsafe<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n                         .cx\n                         .typeck_results()\n                         .type_dependent_def_id(e.hir_id)\n-                        .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().unsafety() == Unsafety::Unsafe) =>\n+                        .map_or(false, |id| {\n+                            self.cx.tcx.fn_sig(id).skip_binder().unsafety() == Unsafety::Unsafe\n+                        }) =>\n                 {\n                     self.is_unsafe = true;\n                 },\n                 ExprKind::Call(func, _) => match *self.cx.typeck_results().expr_ty(func).peel_refs().kind() {\n-                    ty::FnDef(id, _) if self.cx.tcx.fn_sig(id).skip_binder().unsafety() == Unsafety::Unsafe => self.is_unsafe = true,\n+                    ty::FnDef(id, _) if self.cx.tcx.fn_sig(id).skip_binder().unsafety() == Unsafety::Unsafe => {\n+                        self.is_unsafe = true;\n+                    },\n                     ty::FnPtr(sig) if sig.unsafety() == Unsafety::Unsafe => self.is_unsafe = true,\n                     _ => walk_expr(self, e),\n                 },"}, {"sha": "653121af54dc356ab1d07077ae09b561a3adda59", "filename": "lintcheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/lintcheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/lintcheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FCargo.toml?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -10,8 +10,8 @@ edition = \"2021\"\n publish = false\n \n [dependencies]\n-cargo_metadata = \"0.14\"\n-clap = \"3.2\"\n+cargo_metadata = \"0.15.3\"\n+clap = \"4.1.4\"\n crossbeam-channel = \"0.5.6\"\n flate2 = \"1.0\"\n rayon = \"1.5.1\""}, {"sha": "c1a10ba55ef880dac092b9e6fa968f37a3448948", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,19 +1,19 @@\n error: hardcoded path to a diagnostic item\n-  --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:12:43\n    |\n-LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: convert all references to use `sym::Deref`\n+   = help: convert all references to use `sym::deref_method`\n    = note: `-D clippy::unnecessary-def-path` implied by `-D warnings`\n \n error: hardcoded path to a diagnostic item\n-  --> $DIR/unnecessary_def_path_hardcoded_path.rs:12:43\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n    |\n-LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n-   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: convert all references to use `sym::deref_method`\n+   = help: convert all references to use `sym::Deref`\n \n error: hardcoded path to a language item\n   --> $DIR/unnecessary_def_path_hardcoded_path.rs:11:40"}, {"sha": "a13af5652038939fa32c398796dd377eef7babe4", "filename": "tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -149,3 +149,22 @@ macro_rules! almost_complete_range {\n         let _ = '0'..'9';\n     };\n }\n+\n+#[macro_export]\n+macro_rules! unsafe_macro {\n+    () => {\n+        unsafe {\n+            *core::ptr::null::<()>();\n+            *core::ptr::null::<()>();\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! needless_lifetime {\n+    () => {\n+        fn needless_lifetime<'a>(x: &'a u8) -> &'a u8 {\n+            unimplemented!()\n+        }\n+    };\n+}"}, {"sha": "b8dd92906c8db229ad0cdef1d91e4dc7f54463f4", "filename": "tests/ui/bool_assert_comparison.fixed", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fbool_assert_comparison.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fbool_assert_comparison.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_assert_comparison.fixed?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -86,7 +86,7 @@ fn main() {\n     let b = ImplNotTraitWithBool;\n \n     assert_eq!(\"a\".len(), 1);\n-    assert!(\"a\".is_empty());\n+    assert!(!\"a\".is_empty());\n     assert!(\"\".is_empty());\n     assert!(\"\".is_empty());\n     assert_eq!(a!(), b!());\n@@ -97,16 +97,16 @@ fn main() {\n \n     assert_ne!(\"a\".len(), 1);\n     assert!(\"a\".is_empty());\n-    assert!(\"\".is_empty());\n-    assert!(\"\".is_empty());\n+    assert!(!\"\".is_empty());\n+    assert!(!\"\".is_empty());\n     assert_ne!(a!(), b!());\n     assert_ne!(a!(), \"\".is_empty());\n     assert_ne!(\"\".is_empty(), b!());\n     assert_ne!(a, true);\n-    assert!(b);\n+    assert!(!b);\n \n     debug_assert_eq!(\"a\".len(), 1);\n-    debug_assert!(\"a\".is_empty());\n+    debug_assert!(!\"a\".is_empty());\n     debug_assert!(\"\".is_empty());\n     debug_assert!(\"\".is_empty());\n     debug_assert_eq!(a!(), b!());\n@@ -117,27 +117,27 @@ fn main() {\n \n     debug_assert_ne!(\"a\".len(), 1);\n     debug_assert!(\"a\".is_empty());\n-    debug_assert!(\"\".is_empty());\n-    debug_assert!(\"\".is_empty());\n+    debug_assert!(!\"\".is_empty());\n+    debug_assert!(!\"\".is_empty());\n     debug_assert_ne!(a!(), b!());\n     debug_assert_ne!(a!(), \"\".is_empty());\n     debug_assert_ne!(\"\".is_empty(), b!());\n     debug_assert_ne!(a, true);\n-    debug_assert!(b);\n+    debug_assert!(!b);\n \n     // assert with error messages\n     assert_eq!(\"a\".len(), 1, \"tadam {}\", 1);\n     assert_eq!(\"a\".len(), 1, \"tadam {}\", true);\n-    assert!(\"a\".is_empty(), \"tadam {}\", 1);\n-    assert!(\"a\".is_empty(), \"tadam {}\", true);\n-    assert!(\"a\".is_empty(), \"tadam {}\", true);\n+    assert!(!\"a\".is_empty(), \"tadam {}\", 1);\n+    assert!(!\"a\".is_empty(), \"tadam {}\", true);\n+    assert!(!\"a\".is_empty(), \"tadam {}\", true);\n     assert_eq!(a, true, \"tadam {}\", false);\n \n     debug_assert_eq!(\"a\".len(), 1, \"tadam {}\", 1);\n     debug_assert_eq!(\"a\".len(), 1, \"tadam {}\", true);\n-    debug_assert!(\"a\".is_empty(), \"tadam {}\", 1);\n-    debug_assert!(\"a\".is_empty(), \"tadam {}\", true);\n-    debug_assert!(\"a\".is_empty(), \"tadam {}\", true);\n+    debug_assert!(!\"a\".is_empty(), \"tadam {}\", 1);\n+    debug_assert!(!\"a\".is_empty(), \"tadam {}\", true);\n+    debug_assert!(!\"a\".is_empty(), \"tadam {}\", true);\n     debug_assert_eq!(a, true, \"tadam {}\", false);\n \n     assert!(a!());\n@@ -158,4 +158,14 @@ fn main() {\n         }};\n     }\n     in_macro!(a);\n+\n+    assert!(\"\".is_empty());\n+    assert!(\"\".is_empty());\n+    assert!(!\"requires negation\".is_empty());\n+    assert!(!\"requires negation\".is_empty());\n+\n+    debug_assert!(\"\".is_empty());\n+    debug_assert!(\"\".is_empty());\n+    debug_assert!(!\"requires negation\".is_empty());\n+    debug_assert!(!\"requires negation\".is_empty());\n }"}, {"sha": "0a8ad34fda52a925d541a9fc4ce98b139948890c", "filename": "tests/ui/bool_assert_comparison.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_assert_comparison.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -158,4 +158,14 @@ fn main() {\n         }};\n     }\n     in_macro!(a);\n+\n+    assert_eq!(\"\".is_empty(), true);\n+    assert_ne!(\"\".is_empty(), false);\n+    assert_ne!(\"requires negation\".is_empty(), true);\n+    assert_eq!(\"requires negation\".is_empty(), false);\n+\n+    debug_assert_eq!(\"\".is_empty(), true);\n+    debug_assert_ne!(\"\".is_empty(), false);\n+    debug_assert_ne!(\"requires negation\".is_empty(), true);\n+    debug_assert_eq!(\"requires negation\".is_empty(), false);\n }"}, {"sha": "89cefc95a9f69a845f76b3c193541c8407cfbb57", "filename": "tests/ui/bool_assert_comparison.stderr", "status": "modified", "additions": 111, "deletions": 15, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fbool_assert_comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fbool_assert_comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_assert_comparison.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -8,7 +8,7 @@ LL |     assert_eq!(\"a\".is_empty(), false);\n help: replace it with `assert!(..)`\n    |\n LL -     assert_eq!(\"a\".is_empty(), false);\n-LL +     assert!(\"a\".is_empty());\n+LL +     assert!(!\"a\".is_empty());\n    |\n \n error: used `assert_eq!` with a literal bool\n@@ -68,7 +68,7 @@ LL |     assert_ne!(\"\".is_empty(), true);\n help: replace it with `assert!(..)`\n    |\n LL -     assert_ne!(\"\".is_empty(), true);\n-LL +     assert!(\"\".is_empty());\n+LL +     assert!(!\"\".is_empty());\n    |\n \n error: used `assert_ne!` with a literal bool\n@@ -80,7 +80,7 @@ LL |     assert_ne!(true, \"\".is_empty());\n help: replace it with `assert!(..)`\n    |\n LL -     assert_ne!(true, \"\".is_empty());\n-LL +     assert!(\"\".is_empty());\n+LL +     assert!(!\"\".is_empty());\n    |\n \n error: used `assert_ne!` with a literal bool\n@@ -92,7 +92,7 @@ LL |     assert_ne!(b, true);\n help: replace it with `assert!(..)`\n    |\n LL -     assert_ne!(b, true);\n-LL +     assert!(b);\n+LL +     assert!(!b);\n    |\n \n error: used `debug_assert_eq!` with a literal bool\n@@ -104,7 +104,7 @@ LL |     debug_assert_eq!(\"a\".is_empty(), false);\n help: replace it with `debug_assert!(..)`\n    |\n LL -     debug_assert_eq!(\"a\".is_empty(), false);\n-LL +     debug_assert!(\"a\".is_empty());\n+LL +     debug_assert!(!\"a\".is_empty());\n    |\n \n error: used `debug_assert_eq!` with a literal bool\n@@ -164,7 +164,7 @@ LL |     debug_assert_ne!(\"\".is_empty(), true);\n help: replace it with `debug_assert!(..)`\n    |\n LL -     debug_assert_ne!(\"\".is_empty(), true);\n-LL +     debug_assert!(\"\".is_empty());\n+LL +     debug_assert!(!\"\".is_empty());\n    |\n \n error: used `debug_assert_ne!` with a literal bool\n@@ -176,7 +176,7 @@ LL |     debug_assert_ne!(true, \"\".is_empty());\n help: replace it with `debug_assert!(..)`\n    |\n LL -     debug_assert_ne!(true, \"\".is_empty());\n-LL +     debug_assert!(\"\".is_empty());\n+LL +     debug_assert!(!\"\".is_empty());\n    |\n \n error: used `debug_assert_ne!` with a literal bool\n@@ -188,7 +188,7 @@ LL |     debug_assert_ne!(b, true);\n help: replace it with `debug_assert!(..)`\n    |\n LL -     debug_assert_ne!(b, true);\n-LL +     debug_assert!(b);\n+LL +     debug_assert!(!b);\n    |\n \n error: used `assert_eq!` with a literal bool\n@@ -200,7 +200,7 @@ LL |     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n help: replace it with `assert!(..)`\n    |\n LL -     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n-LL +     assert!(\"a\".is_empty(), \"tadam {}\", 1);\n+LL +     assert!(!\"a\".is_empty(), \"tadam {}\", 1);\n    |\n \n error: used `assert_eq!` with a literal bool\n@@ -212,7 +212,7 @@ LL |     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n help: replace it with `assert!(..)`\n    |\n LL -     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n-LL +     assert!(\"a\".is_empty(), \"tadam {}\", true);\n+LL +     assert!(!\"a\".is_empty(), \"tadam {}\", true);\n    |\n \n error: used `assert_eq!` with a literal bool\n@@ -224,7 +224,7 @@ LL |     assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n help: replace it with `assert!(..)`\n    |\n LL -     assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n-LL +     assert!(\"a\".is_empty(), \"tadam {}\", true);\n+LL +     assert!(!\"a\".is_empty(), \"tadam {}\", true);\n    |\n \n error: used `debug_assert_eq!` with a literal bool\n@@ -236,7 +236,7 @@ LL |     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n help: replace it with `debug_assert!(..)`\n    |\n LL -     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n-LL +     debug_assert!(\"a\".is_empty(), \"tadam {}\", 1);\n+LL +     debug_assert!(!\"a\".is_empty(), \"tadam {}\", 1);\n    |\n \n error: used `debug_assert_eq!` with a literal bool\n@@ -248,7 +248,7 @@ LL |     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n help: replace it with `debug_assert!(..)`\n    |\n LL -     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n-LL +     debug_assert!(\"a\".is_empty(), \"tadam {}\", true);\n+LL +     debug_assert!(!\"a\".is_empty(), \"tadam {}\", true);\n    |\n \n error: used `debug_assert_eq!` with a literal bool\n@@ -260,7 +260,7 @@ LL |     debug_assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n help: replace it with `debug_assert!(..)`\n    |\n LL -     debug_assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n-LL +     debug_assert!(\"a\".is_empty(), \"tadam {}\", true);\n+LL +     debug_assert!(!\"a\".is_empty(), \"tadam {}\", true);\n    |\n \n error: used `assert_eq!` with a literal bool\n@@ -299,5 +299,101 @@ LL -     renamed!(b, true);\n LL +     debug_assert!(b);\n    |\n \n-error: aborting due to 25 previous errors\n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:162:5\n+   |\n+LL |     assert_eq!(\"\".is_empty(), true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace it with `assert!(..)`\n+   |\n+LL -     assert_eq!(\"\".is_empty(), true);\n+LL +     assert!(\"\".is_empty());\n+   |\n+\n+error: used `assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:163:5\n+   |\n+LL |     assert_ne!(\"\".is_empty(), false);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace it with `assert!(..)`\n+   |\n+LL -     assert_ne!(\"\".is_empty(), false);\n+LL +     assert!(\"\".is_empty());\n+   |\n+\n+error: used `assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:164:5\n+   |\n+LL |     assert_ne!(\"requires negation\".is_empty(), true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace it with `assert!(..)`\n+   |\n+LL -     assert_ne!(\"requires negation\".is_empty(), true);\n+LL +     assert!(!\"requires negation\".is_empty());\n+   |\n+\n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:165:5\n+   |\n+LL |     assert_eq!(\"requires negation\".is_empty(), false);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace it with `assert!(..)`\n+   |\n+LL -     assert_eq!(\"requires negation\".is_empty(), false);\n+LL +     assert!(!\"requires negation\".is_empty());\n+   |\n+\n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:167:5\n+   |\n+LL |     debug_assert_eq!(\"\".is_empty(), true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace it with `debug_assert!(..)`\n+   |\n+LL -     debug_assert_eq!(\"\".is_empty(), true);\n+LL +     debug_assert!(\"\".is_empty());\n+   |\n+\n+error: used `debug_assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:168:5\n+   |\n+LL |     debug_assert_ne!(\"\".is_empty(), false);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace it with `debug_assert!(..)`\n+   |\n+LL -     debug_assert_ne!(\"\".is_empty(), false);\n+LL +     debug_assert!(\"\".is_empty());\n+   |\n+\n+error: used `debug_assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:169:5\n+   |\n+LL |     debug_assert_ne!(\"requires negation\".is_empty(), true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace it with `debug_assert!(..)`\n+   |\n+LL -     debug_assert_ne!(\"requires negation\".is_empty(), true);\n+LL +     debug_assert!(!\"requires negation\".is_empty());\n+   |\n+\n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:170:5\n+   |\n+LL |     debug_assert_eq!(\"requires negation\".is_empty(), false);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace it with `debug_assert!(..)`\n+   |\n+LL -     debug_assert_eq!(\"requires negation\".is_empty(), false);\n+LL +     debug_assert!(!\"requires negation\".is_empty());\n+   |\n+\n+error: aborting due to 33 previous errors\n "}, {"sha": "c5ea0b16d1be472b035885bf1d13201ae42bd4d8", "filename": "tests/ui/crashes/ice-2774.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fcrashes%2Fice-2774.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fcrashes%2Fice-2774.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-2774.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -5,6 +5,11 @@ LL | pub fn add_barfoos_to_foos<'a>(bars: &HashSet<&'a Bar>) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::needless-lifetimes` implied by `-D warnings`\n+help: elide the lifetimes\n+   |\n+LL - pub fn add_barfoos_to_foos<'a>(bars: &HashSet<&'a Bar>) {\n+LL + pub fn add_barfoos_to_foos(bars: &HashSet<&Bar>) {\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "0b0e0ad2684a902adc90a854f25345394ec4ea14", "filename": "tests/ui/crashes/needless_lifetimes_impl_trait.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -9,6 +9,11 @@ note: the lint level is defined here\n    |\n LL | #![deny(clippy::needless_lifetimes)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: elide the lifetimes\n+   |\n+LL -     fn baz<'a>(&'a self) -> impl Foo + 'a {\n+LL +     fn baz(&self) -> impl Foo + '_ {\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "843e1df8bc6bbf77d73c70f67e0f8ca45948ad6e", "filename": "tests/ui/derive.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,7 +1,6 @@\n #![allow(dead_code)]\n #![warn(clippy::expl_impl_clone_on_copy)]\n \n-\n #[derive(Copy)]\n struct Qux;\n "}, {"sha": "d37f7fa73319679e97a2c61f67cfae6cd3eee762", "filename": "tests/ui/derive.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fderive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fderive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,5 +1,5 @@\n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:8:1\n+  --> $DIR/derive.rs:7:1\n    |\n LL | / impl Clone for Qux {\n LL | |     fn clone(&self) -> Self {\n@@ -9,7 +9,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:8:1\n+  --> $DIR/derive.rs:7:1\n    |\n LL | / impl Clone for Qux {\n LL | |     fn clone(&self) -> Self {\n@@ -20,7 +20,7 @@ LL | | }\n    = note: `-D clippy::expl-impl-clone-on-copy` implied by `-D warnings`\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:32:1\n+  --> $DIR/derive.rs:31:1\n    |\n LL | / impl<'a> Clone for Lt<'a> {\n LL | |     fn clone(&self) -> Self {\n@@ -30,7 +30,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:32:1\n+  --> $DIR/derive.rs:31:1\n    |\n LL | / impl<'a> Clone for Lt<'a> {\n LL | |     fn clone(&self) -> Self {\n@@ -40,7 +40,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:43:1\n+  --> $DIR/derive.rs:42:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -50,7 +50,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:43:1\n+  --> $DIR/derive.rs:42:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -60,7 +60,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:54:1\n+  --> $DIR/derive.rs:53:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -70,7 +70,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:54:1\n+  --> $DIR/derive.rs:53:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -80,7 +80,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:74:1\n+  --> $DIR/derive.rs:73:1\n    |\n LL | / impl<T: Clone> Clone for Generic2<T> {\n LL | |     fn clone(&self) -> Self {\n@@ -90,7 +90,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:74:1\n+  --> $DIR/derive.rs:73:1\n    |\n LL | / impl<T: Clone> Clone for Generic2<T> {\n LL | |     fn clone(&self) -> Self {"}, {"sha": "018f875d60bfa24ec5fd1a625b84d7cb9c457e66", "filename": "tests/ui/expect_tool_lint_rfc_2383.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -22,9 +22,9 @@ mod rustc_ok {\n \n         #[expect(illegal_floating_point_literal_pattern)]\n         match x {\n-            5.0 => {}\n-            6.0 => {}\n-            _ => {}\n+            5.0 => {},\n+            6.0 => {},\n+            _ => {},\n         }\n     }\n }\n@@ -38,9 +38,9 @@ mod rustc_warn {\n \n         #[expect(illegal_floating_point_literal_pattern)]\n         match x {\n-            5 => {}\n-            6 => {}\n-            _ => {}\n+            5 => {},\n+            6 => {},\n+            _ => {},\n         }\n     }\n }"}, {"sha": "5cb80cb6233f73d9f601458d302374ea1a1fef15", "filename": "tests/ui/extra_unused_type_parameters.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -0,0 +1,69 @@\n+#![allow(unused, clippy::needless_lifetimes)]\n+#![warn(clippy::extra_unused_type_parameters)]\n+\n+fn unused_ty<T>(x: u8) {}\n+\n+fn unused_multi<T, U>(x: u8) {}\n+\n+fn unused_with_lt<'a, T>(x: &'a u8) {}\n+\n+fn used_ty<T>(x: T, y: u8) {}\n+\n+fn used_ref<'a, T>(x: &'a T) {}\n+\n+fn used_ret<T: Default>(x: u8) -> T {\n+    T::default()\n+}\n+\n+fn unused_bounded<T: Default, U>(x: U) {}\n+\n+fn unused_where_clause<T, U>(x: U)\n+where\n+    T: Default,\n+{\n+}\n+\n+fn some_unused<A, B, C, D: Iterator<Item = (B, C)>, E>(b: B, c: C) {}\n+\n+fn used_opaque<A>(iter: impl Iterator<Item = A>) -> usize {\n+    iter.count()\n+}\n+\n+fn used_ret_opaque<A>() -> impl Iterator<Item = A> {\n+    std::iter::empty()\n+}\n+\n+fn used_vec_box<T>(x: Vec<Box<T>>) {}\n+\n+fn used_body<T: Default + ToString>() -> String {\n+    T::default().to_string()\n+}\n+\n+fn used_closure<T: Default + ToString>() -> impl Fn() {\n+    || println!(\"{}\", T::default().to_string())\n+}\n+\n+struct S;\n+\n+impl S {\n+    fn unused_ty_impl<T>(&self) {}\n+}\n+\n+// Don't lint on trait methods\n+trait Foo {\n+    fn bar<T>(&self);\n+}\n+\n+impl Foo for S {\n+    fn bar<T>(&self) {}\n+}\n+\n+fn skip_index<A, Iter>(iter: Iter, index: usize) -> impl Iterator<Item = A>\n+where\n+    Iter: Iterator<Item = A>,\n+{\n+    iter.enumerate()\n+        .filter_map(move |(i, a)| if i == index { None } else { Some(a) })\n+}\n+\n+fn main() {}"}, {"sha": "1c8dd53e6385970ad947dc4eceef68b5be6a4d3e", "filename": "tests/ui/extra_unused_type_parameters.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fextra_unused_type_parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fextra_unused_type_parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -0,0 +1,59 @@\n+error: type parameter goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:4:13\n+   |\n+LL | fn unused_ty<T>(x: u8) {}\n+   |             ^^^\n+   |\n+   = help: consider removing the parameter\n+   = note: `-D clippy::extra-unused-type-parameters` implied by `-D warnings`\n+\n+error: type parameters go unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:6:16\n+   |\n+LL | fn unused_multi<T, U>(x: u8) {}\n+   |                ^^^^^^\n+   |\n+   = help: consider removing the parameters\n+\n+error: type parameter goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:8:23\n+   |\n+LL | fn unused_with_lt<'a, T>(x: &'a u8) {}\n+   |                       ^\n+   |\n+   = help: consider removing the parameter\n+\n+error: type parameter goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:18:19\n+   |\n+LL | fn unused_bounded<T: Default, U>(x: U) {}\n+   |                   ^^^^^^^^^^^\n+   |\n+   = help: consider removing the parameter\n+\n+error: type parameter goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:20:24\n+   |\n+LL | fn unused_where_clause<T, U>(x: U)\n+   |                        ^^\n+   |\n+   = help: consider removing the parameter\n+\n+error: type parameters go unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:26:16\n+   |\n+LL | fn some_unused<A, B, C, D: Iterator<Item = (B, C)>, E>(b: B, c: C) {}\n+   |                ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^\n+   |\n+   = help: consider removing the parameters\n+\n+error: type parameter goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:49:22\n+   |\n+LL |     fn unused_ty_impl<T>(&self) {}\n+   |                      ^^^\n+   |\n+   = help: consider removing the parameter\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "b5dec6c46bdddac2685705a76fc541c71671d4da", "filename": "tests/ui/len_without_is_empty.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Flen_without_is_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Flen_without_is_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -282,4 +282,50 @@ impl AsyncLen {\n     }\n }\n \n+// issue #9520\n+pub struct NonStandardLenAndIsEmptySignature;\n+impl NonStandardLenAndIsEmptySignature {\n+    // don't lint\n+    pub fn len(&self, something: usize) -> usize {\n+        something\n+    }\n+\n+    pub fn is_empty(&self, something: usize) -> bool {\n+        something == 0\n+    }\n+}\n+\n+// test case for #9520 with generics in the function signature\n+pub trait TestResource {\n+    type NonStandardSignatureWithGenerics: Copy;\n+    fn lookup_content(&self, item: Self::NonStandardSignatureWithGenerics) -> Result<Option<&[u8]>, String>;\n+}\n+pub struct NonStandardSignatureWithGenerics(u32);\n+impl NonStandardSignatureWithGenerics {\n+    pub fn is_empty<T, U>(self, resource: &T) -> bool\n+    where\n+        T: TestResource<NonStandardSignatureWithGenerics = U>,\n+        U: Copy + From<NonStandardSignatureWithGenerics>,\n+    {\n+        if let Ok(Some(content)) = resource.lookup_content(self.into()) {\n+            content.is_empty()\n+        } else {\n+            true\n+        }\n+    }\n+\n+    // test case for #9520 with generics in the function signature\n+    pub fn len<T, U>(self, resource: &T) -> usize\n+    where\n+        T: TestResource<NonStandardSignatureWithGenerics = U>,\n+        U: Copy + From<NonStandardSignatureWithGenerics>,\n+    {\n+        if let Ok(Some(content)) = resource.lookup_content(self.into()) {\n+            content.len()\n+        } else {\n+            0_usize\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "8c7e919bf62a10d52bc6a343454b438f89c8857b", "filename": "tests/ui/manual_assert.edition2018.fixed", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmanual_assert.edition2018.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmanual_assert.edition2018.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.fixed?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -29,9 +29,7 @@ fn main() {\n         panic!(\"qaqaq{:?}\", a);\n     }\n     assert!(a.is_empty(), \"qaqaq{:?}\", a);\n-    if !a.is_empty() {\n-        panic!(\"qwqwq\");\n-    }\n+    assert!(a.is_empty(), \"qwqwq\");\n     if a.len() == 3 {\n         println!(\"qwq\");\n         println!(\"qwq\");\n@@ -46,21 +44,11 @@ fn main() {\n         println!(\"qwq\");\n     }\n     let b = vec![1, 2, 3];\n-    if b.is_empty() {\n-        panic!(\"panic1\");\n-    }\n-    if b.is_empty() && a.is_empty() {\n-        panic!(\"panic2\");\n-    }\n-    if a.is_empty() && !b.is_empty() {\n-        panic!(\"panic3\");\n-    }\n-    if b.is_empty() || a.is_empty() {\n-        panic!(\"panic4\");\n-    }\n-    if a.is_empty() || !b.is_empty() {\n-        panic!(\"panic5\");\n-    }\n+    assert!(!b.is_empty(), \"panic1\");\n+    assert!(!(b.is_empty() && a.is_empty()), \"panic2\");\n+    assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n+    assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n+    assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n     assert!(!a.is_empty(), \"with expansion {}\", one!());\n     if a.is_empty() {\n         let _ = 0;\n@@ -71,12 +59,11 @@ fn main() {\n \n fn issue7730(a: u8) {\n     // Suggestion should preserve comment\n-    if a > 2 {\n-        // comment\n-        /* this is a\n+    // comment\n+/* this is a\n         multiline\n         comment */\n-        /// Doc comment\n-        panic!(\"panic with comment\") // comment after `panic!`\n-    }\n+/// Doc comment\n+// comment after `panic!`\n+assert!(!(a > 2), \"panic with comment\");\n }"}, {"sha": "3555ac29243a1cb0d819a368d8bb22bf02aea2de", "filename": "tests/ui/manual_assert.edition2018.stderr", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmanual_assert.edition2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmanual_assert.edition2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -8,6 +8,54 @@ LL | |     }\n    |\n    = note: `-D clippy::manual-assert` implied by `-D warnings`\n \n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:34:5\n+   |\n+LL | /     if !a.is_empty() {\n+LL | |         panic!(\"qwqwq\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(a.is_empty(), \"qwqwq\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:51:5\n+   |\n+LL | /     if b.is_empty() {\n+LL | |         panic!(\"panic1\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!b.is_empty(), \"panic1\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:54:5\n+   |\n+LL | /     if b.is_empty() && a.is_empty() {\n+LL | |         panic!(\"panic2\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!(b.is_empty() && a.is_empty()), \"panic2\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:57:5\n+   |\n+LL | /     if a.is_empty() && !b.is_empty() {\n+LL | |         panic!(\"panic3\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:60:5\n+   |\n+LL | /     if b.is_empty() || a.is_empty() {\n+LL | |         panic!(\"panic4\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!(b.is_empty() || a.is_empty()), \"panic4\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:63:5\n+   |\n+LL | /     if a.is_empty() || !b.is_empty() {\n+LL | |         panic!(\"panic5\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");`\n+\n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:66:5\n    |\n@@ -16,5 +64,22 @@ LL | |         panic!(\"with expansion {}\", one!())\n LL | |     }\n    | |_____^ help: try instead: `assert!(!a.is_empty(), \"with expansion {}\", one!());`\n \n-error: aborting due to 2 previous errors\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:78:5\n+   |\n+LL | /     if a > 2 {\n+LL | |         // comment\n+LL | |         /* this is a\n+LL | |         multiline\n+...  |\n+LL | |         panic!(\"panic with comment\") // comment after `panic!`\n+LL | |     }\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(a > 2), \"panic with comment\");\n+   |\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "9fd3739b69c2cd7720da4cee815a39980e7915b4", "filename": "tests/ui/match_wildcard_for_single_variants.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -123,7 +123,7 @@ fn main() {\n             Enum::A => (),\n             Enum::B => (),\n             Enum::C => (),\n-            _ => (),\n+            Enum::__Private => (),\n         }\n         match Enum::A {\n             Enum::A => (),"}, {"sha": "105b4c4b41d1e9ca107906e2cc3a638c0508e307", "filename": "tests/ui/match_wildcard_for_single_variants.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -48,11 +48,17 @@ error: wildcard matches only a single variant and will also match any future add\n LL |         _ => (),\n    |         ^ help: try this: `Color::Blue`\n \n+error: wildcard matches only a single variant and will also match any future added variants\n+  --> $DIR/match_wildcard_for_single_variants.rs:126:13\n+   |\n+LL |             _ => (),\n+   |             ^ help: try this: `Enum::__Private`\n+\n error: wildcard matches only a single variant and will also match any future added variants\n   --> $DIR/match_wildcard_for_single_variants.rs:153:13\n    |\n LL |             _ => 2,\n    |             ^ help: try this: `Foo::B`\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n "}, {"sha": "4511bc99c3c71a92c63a641cb45c12b850ac58e3", "filename": "tests/ui/multiple_unsafe_ops_per_block.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmultiple_unsafe_ops_per_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmultiple_unsafe_ops_per_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmultiple_unsafe_ops_per_block.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,9 +1,13 @@\n+// aux-build:macro_rules.rs\n #![allow(unused)]\n #![allow(deref_nullptr)]\n #![allow(clippy::unnecessary_operation)]\n #![allow(clippy::drop_copy)]\n #![warn(clippy::multiple_unsafe_ops_per_block)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n use core::arch::asm;\n \n fn raw_ptr() -> *const () {\n@@ -107,4 +111,9 @@ unsafe fn read_char_good(ptr: *const u8) -> char {\n     unsafe { core::char::from_u32_unchecked(int_value) }\n }\n \n+// no lint\n+fn issue10259() {\n+    unsafe_macro!();\n+}\n+\n fn main() {}"}, {"sha": "303aeb7aee0c569e721df718eb05719bad372718", "filename": "tests/ui/multiple_unsafe_ops_per_block.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmultiple_unsafe_ops_per_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fmultiple_unsafe_ops_per_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmultiple_unsafe_ops_per_block.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,5 +1,5 @@\n error: this `unsafe` block contains 2 unsafe operations, expected only one\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:32:5\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:36:5\n    |\n LL | /     unsafe {\n LL | |         STATIC += 1;\n@@ -8,19 +8,19 @@ LL | |     }\n    | |_____^\n    |\n note: modification of a mutable static occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:33:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:37:9\n    |\n LL |         STATIC += 1;\n    |         ^^^^^^^^^^^\n note: unsafe function call occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:34:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:38:9\n    |\n LL |         not_very_safe();\n    |         ^^^^^^^^^^^^^^^\n    = note: `-D clippy::multiple-unsafe-ops-per-block` implied by `-D warnings`\n \n error: this `unsafe` block contains 2 unsafe operations, expected only one\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:41:5\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:45:5\n    |\n LL | /     unsafe {\n LL | |         drop(u.u);\n@@ -29,18 +29,18 @@ LL | |     }\n    | |_____^\n    |\n note: union field access occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:42:14\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:46:14\n    |\n LL |         drop(u.u);\n    |              ^^^\n note: raw pointer dereference occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:43:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:47:9\n    |\n LL |         *raw_ptr();\n    |         ^^^^^^^^^^\n \n error: this `unsafe` block contains 3 unsafe operations, expected only one\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:48:5\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:52:5\n    |\n LL | /     unsafe {\n LL | |         asm!(\"nop\");\n@@ -50,23 +50,23 @@ LL | |     }\n    | |_____^\n    |\n note: inline assembly used here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:49:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:53:9\n    |\n LL |         asm!(\"nop\");\n    |         ^^^^^^^^^^^\n note: unsafe method call occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:50:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:54:9\n    |\n LL |         sample.not_very_safe();\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n note: modification of a mutable static occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:51:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:55:9\n    |\n LL |         STATIC = 0;\n    |         ^^^^^^^^^^\n \n error: this `unsafe` block contains 6 unsafe operations, expected only one\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:57:5\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:61:5\n    |\n LL | /     unsafe {\n LL | |         drop(u.u);\n@@ -78,49 +78,49 @@ LL | |     }\n    | |_____^\n    |\n note: union field access occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:58:14\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:62:14\n    |\n LL |         drop(u.u);\n    |              ^^^\n note: access of a mutable static occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:59:14\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:63:14\n    |\n LL |         drop(STATIC);\n    |              ^^^^^^\n note: unsafe method call occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:60:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:64:9\n    |\n LL |         sample.not_very_safe();\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n note: unsafe function call occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:61:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:65:9\n    |\n LL |         not_very_safe();\n    |         ^^^^^^^^^^^^^^^\n note: raw pointer dereference occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:62:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:66:9\n    |\n LL |         *raw_ptr();\n    |         ^^^^^^^^^^\n note: inline assembly used here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:63:9\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:67:9\n    |\n LL |         asm!(\"nop\");\n    |         ^^^^^^^^^^^\n \n error: this `unsafe` block contains 2 unsafe operations, expected only one\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:101:5\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:105:5\n    |\n LL |     unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: unsafe function call occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:101:14\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:105:14\n    |\n LL |     unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: raw pointer dereference occurs here\n-  --> $DIR/multiple_unsafe_ops_per_block.rs:101:39\n+  --> $DIR/multiple_unsafe_ops_per_block.rs:105:39\n    |\n LL |     unsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n    |                                       ^^^^^^^^^^^^^^^^^^"}, {"sha": "d286ef4ba378878e74540cca4528709cd3785bd9", "filename": "tests/ui/needless_lifetimes.fixed", "status": "added", "additions": 538, "deletions": 0, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fneedless_lifetimes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fneedless_lifetimes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.fixed?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -0,0 +1,538 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::needless_lifetimes)]\n+#![allow(\n+    unused,\n+    clippy::boxed_local,\n+    clippy::extra_unused_type_parameters,\n+    clippy::needless_pass_by_value,\n+    clippy::unnecessary_wraps,\n+    dyn_drop,\n+    clippy::get_first\n+)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+fn distinct_lifetimes(_x: &u8, _y: &u8, _z: u8) {}\n+\n+fn distinct_and_static(_x: &u8, _y: &u8, _z: &'static u8) {}\n+\n+// No error; same lifetime on two params.\n+fn same_lifetime_on_input<'a>(_x: &'a u8, _y: &'a u8) {}\n+\n+// No error; static involved.\n+fn only_static_on_input(_x: &u8, _y: &u8, _z: &'static u8) {}\n+\n+fn mut_and_static_input(_x: &mut u8, _y: &'static str) {}\n+\n+fn in_and_out(x: &u8, _y: u8) -> &u8 {\n+    x\n+}\n+\n+// No error; multiple input refs.\n+fn multiple_in_and_out_1<'a>(x: &'a u8, _y: &'a u8) -> &'a u8 {\n+    x\n+}\n+\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn multiple_in_and_out_2a<'a>(x: &'a u8, _y: &u8) -> &'a u8\n+//                                                ^^^\n+fn multiple_in_and_out_2a<'a>(x: &'a u8, _y: &u8) -> &'a u8 {\n+    x\n+}\n+\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn multiple_in_and_out_2b<'b>(_x: &u8, y: &'b u8) -> &'b u8\n+//                                     ^^^\n+fn multiple_in_and_out_2b<'b>(_x: &u8, y: &'b u8) -> &'b u8 {\n+    y\n+}\n+\n+// No error; multiple input refs\n+async fn func<'a>(args: &[&'a str]) -> Option<&'a str> {\n+    args.get(0).cloned()\n+}\n+\n+// No error; static involved.\n+fn in_static_and_out<'a>(x: &'a u8, _y: &'static u8) -> &'a u8 {\n+    x\n+}\n+\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn deep_reference_1a<'a>(x: &'a u8, _y: &u8) -> Result<&'a u8, ()>\n+//                                           ^^^\n+fn deep_reference_1a<'a>(x: &'a u8, _y: &u8) -> Result<&'a u8, ()> {\n+    Ok(x)\n+}\n+\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn deep_reference_1b<'b>(_x: &u8, y: &'b u8) -> Result<&'b u8, ()>\n+//                                ^^^\n+fn deep_reference_1b<'b>(_x: &u8, y: &'b u8) -> Result<&'b u8, ()> {\n+    Ok(y)\n+}\n+\n+// No error; two input refs.\n+fn deep_reference_2<'a>(x: Result<&'a u8, &'a u8>) -> &'a u8 {\n+    x.unwrap()\n+}\n+\n+fn deep_reference_3(x: &u8, _y: u8) -> Result<&u8, ()> {\n+    Ok(x)\n+}\n+\n+// Where-clause, but without lifetimes.\n+fn where_clause_without_lt<T>(x: &u8, _y: u8) -> Result<&u8, ()>\n+where\n+    T: Copy,\n+{\n+    Ok(x)\n+}\n+\n+type Ref<'r> = &'r u8;\n+\n+// No error; same lifetime on two params.\n+fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) {}\n+\n+fn lifetime_param_2(_x: Ref<'_>, _y: &u8) {}\n+\n+// No error; bounded lifetime.\n+fn lifetime_param_3<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) {}\n+\n+// No error; bounded lifetime.\n+fn lifetime_param_4<'a, 'b>(_x: Ref<'a>, _y: &'b u8)\n+where\n+    'b: 'a,\n+{\n+}\n+\n+struct Lt<'a, I: 'static> {\n+    x: &'a I,\n+}\n+\n+// No error; fn bound references `'a`.\n+fn fn_bound<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n+where\n+    F: Fn(Lt<'a, I>) -> Lt<'a, I>,\n+{\n+    unreachable!()\n+}\n+\n+fn fn_bound_2<F, I>(_m: Lt<'_, I>, _f: F) -> Lt<'_, I>\n+where\n+    for<'x> F: Fn(Lt<'x, I>) -> Lt<'x, I>,\n+{\n+    unreachable!()\n+}\n+\n+// No error; see below.\n+fn fn_bound_3<'a, F: FnOnce(&'a i32)>(x: &'a i32, f: F) {\n+    f(x);\n+}\n+\n+fn fn_bound_3_cannot_elide() {\n+    let x = 42;\n+    let p = &x;\n+    let mut q = &x;\n+    // This will fail if we elide lifetimes of `fn_bound_3`.\n+    fn_bound_3(p, |y| q = y);\n+}\n+\n+// No error; multiple input refs.\n+fn fn_bound_4<'a, F: FnOnce() -> &'a ()>(cond: bool, x: &'a (), f: F) -> &'a () {\n+    if cond { x } else { f() }\n+}\n+\n+struct X {\n+    x: u8,\n+}\n+\n+impl X {\n+    fn self_and_out(&self) -> &u8 {\n+        &self.x\n+    }\n+\n+    // Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+    //   fn self_and_in_out_1<'s>(&'s self, _x: &u8) -> &'s u8\n+    //                                          ^^^\n+    fn self_and_in_out_1<'s>(&'s self, _x: &u8) -> &'s u8 {\n+        &self.x\n+    }\n+\n+    // Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+    //   fn self_and_in_out_2<'t>(&self, x: &'t u8) -> &'t u8\n+    //                            ^^^^^\n+    fn self_and_in_out_2<'t>(&self, x: &'t u8) -> &'t u8 {\n+        x\n+    }\n+\n+    fn distinct_self_and_in(&self, _x: &u8) {}\n+\n+    // No error; same lifetimes on two params.\n+    fn self_and_same_in<'s>(&'s self, _x: &'s u8) {}\n+}\n+\n+struct Foo<'a>(&'a u8);\n+\n+impl<'a> Foo<'a> {\n+    // No error; lifetime `'a` not defined in method.\n+    fn self_shared_lifetime(&self, _: &'a u8) {}\n+    // No error; bounds exist.\n+    fn self_bound_lifetime<'b: 'a>(&self, _: &'b u8) {}\n+}\n+\n+fn already_elided<'a>(_: &u8, _: &'a u8) -> &'a u8 {\n+    unimplemented!()\n+}\n+\n+fn struct_with_lt(_foo: Foo<'_>) -> &str {\n+    unimplemented!()\n+}\n+\n+// No warning; two input lifetimes (named on the reference, anonymous on `Foo`).\n+fn struct_with_lt2<'a>(_foo: &'a Foo) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// No warning; two input lifetimes (anonymous on the reference, named on `Foo`).\n+fn struct_with_lt3<'a>(_foo: &Foo<'a>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn struct_with_lt4a<'a>(_foo: &'a Foo<'_>) -> &'a str\n+//                                         ^^\n+fn struct_with_lt4a<'a>(_foo: &'a Foo<'_>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str\n+//                                 ^^^^\n+fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str {\n+    unimplemented!()\n+}\n+\n+trait WithLifetime<'a> {}\n+\n+type WithLifetimeAlias<'a> = dyn WithLifetime<'a>;\n+\n+// Should not warn because it won't build without the lifetime.\n+fn trait_obj_elided<'a>(_arg: &'a dyn WithLifetime) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Should warn because there is no lifetime on `Drop`, so this would be\n+// unambiguous if we elided the lifetime.\n+fn trait_obj_elided2(_arg: &dyn Drop) -> &str {\n+    unimplemented!()\n+}\n+\n+type FooAlias<'a> = Foo<'a>;\n+\n+fn alias_with_lt(_foo: FooAlias<'_>) -> &str {\n+    unimplemented!()\n+}\n+\n+// No warning; two input lifetimes (named on the reference, anonymous on `FooAlias`).\n+fn alias_with_lt2<'a>(_foo: &'a FooAlias) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// No warning; two input lifetimes (anonymous on the reference, named on `FooAlias`).\n+fn alias_with_lt3<'a>(_foo: &FooAlias<'a>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str\n+//                                             ^^\n+fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn alias_with_lt4b<'b>(_foo: &FooAlias<'b>) -> &'b str\n+//                                ^^^^^^^^^\n+fn alias_with_lt4b<'b>(_foo: &FooAlias<'b>) -> &'b str {\n+    unimplemented!()\n+}\n+\n+fn named_input_elided_output(_arg: &str) -> &str {\n+    unimplemented!()\n+}\n+\n+fn elided_input_named_output<'a>(_arg: &str) -> &'a str {\n+    unimplemented!()\n+}\n+\n+fn trait_bound_ok<T: WithLifetime<'static>>(_: &u8, _: T) {\n+    unimplemented!()\n+}\n+fn trait_bound<'a, T: WithLifetime<'a>>(_: &'a u8, _: T) {\n+    unimplemented!()\n+}\n+\n+// Don't warn on these; see issue #292.\n+fn trait_bound_bug<'a, T: WithLifetime<'a>>() {\n+    unimplemented!()\n+}\n+\n+// See issue #740.\n+struct Test {\n+    vec: Vec<usize>,\n+}\n+\n+impl Test {\n+    fn iter<'a>(&'a self) -> Box<dyn Iterator<Item = usize> + 'a> {\n+        unimplemented!()\n+    }\n+}\n+\n+trait LintContext<'a> {}\n+\n+fn f<'a, T: LintContext<'a>>(_: &T) {}\n+\n+fn test<'a>(x: &'a [u8]) -> u8 {\n+    let y: &'a u8 = &x[5];\n+    *y\n+}\n+\n+// Issue #3284: give hint regarding lifetime in return type.\n+struct Cow<'a> {\n+    x: &'a str,\n+}\n+fn out_return_type_lts(e: &str) -> Cow<'_> {\n+    unimplemented!()\n+}\n+\n+// Make sure we still warn on implementations\n+mod issue4291 {\n+    trait BadTrait {\n+        fn needless_lt(x: &u8) {}\n+    }\n+\n+    impl BadTrait for () {\n+        fn needless_lt(_x: &u8) {}\n+    }\n+}\n+\n+mod issue2944 {\n+    trait Foo {}\n+    struct Bar;\n+    struct Baz<'a> {\n+        bar: &'a Bar,\n+    }\n+\n+    impl<'a> Foo for Baz<'a> {}\n+    impl Bar {\n+        fn baz(&self) -> impl Foo + '_ {\n+            Baz { bar: self }\n+        }\n+    }\n+}\n+\n+mod nested_elision_sites {\n+    // issue #issue2944\n+\n+    // closure trait bounds subject to nested elision\n+    // don't lint because they refer to outer lifetimes\n+    fn trait_fn<'a>(i: &'a i32) -> impl Fn() -> &'a i32 {\n+        move || i\n+    }\n+    fn trait_fn_mut<'a>(i: &'a i32) -> impl FnMut() -> &'a i32 {\n+        move || i\n+    }\n+    fn trait_fn_once<'a>(i: &'a i32) -> impl FnOnce() -> &'a i32 {\n+        move || i\n+    }\n+\n+    // don't lint\n+    fn impl_trait_in_input_position<'a>(f: impl Fn() -> &'a i32) -> &'a i32 {\n+        f()\n+    }\n+    fn impl_trait_in_output_position<'a>(i: &'a i32) -> impl Fn() -> &'a i32 {\n+        move || i\n+    }\n+    // lint\n+    fn impl_trait_elidable_nested_named_lifetimes<'a>(i: &'a i32, f: impl for<'b> Fn(&'b i32) -> &'b i32) -> &'a i32 {\n+        f(i)\n+    }\n+    fn impl_trait_elidable_nested_anonymous_lifetimes(i: &i32, f: impl Fn(&i32) -> &i32) -> &i32 {\n+        f(i)\n+    }\n+\n+    // don't lint\n+    fn generics_not_elidable<'a, T: Fn() -> &'a i32>(f: T) -> &'a i32 {\n+        f()\n+    }\n+    // lint\n+    fn generics_elidable<T: Fn(&i32) -> &i32>(i: &i32, f: T) -> &i32 {\n+        f(i)\n+    }\n+\n+    // don't lint\n+    fn where_clause_not_elidable<'a, T>(f: T) -> &'a i32\n+    where\n+        T: Fn() -> &'a i32,\n+    {\n+        f()\n+    }\n+    // lint\n+    fn where_clause_elidadable<T>(i: &i32, f: T) -> &i32\n+    where\n+        T: Fn(&i32) -> &i32,\n+    {\n+        f(i)\n+    }\n+\n+    // don't lint\n+    fn pointer_fn_in_input_position<'a>(f: fn(&'a i32) -> &'a i32, i: &'a i32) -> &'a i32 {\n+        f(i)\n+    }\n+    fn pointer_fn_in_output_position<'a>(_: &'a i32) -> fn(&'a i32) -> &'a i32 {\n+        |i| i\n+    }\n+    // lint\n+    fn pointer_fn_elidable(i: &i32, f: fn(&i32) -> &i32) -> &i32 {\n+        f(i)\n+    }\n+\n+    // don't lint\n+    fn nested_fn_pointer_1<'a>(_: &'a i32) -> fn(fn(&'a i32) -> &'a i32) -> i32 {\n+        |f| 42\n+    }\n+    fn nested_fn_pointer_2<'a>(_: &'a i32) -> impl Fn(fn(&'a i32)) {\n+        |f| ()\n+    }\n+\n+    // lint\n+    fn nested_fn_pointer_3(_: &i32) -> fn(fn(&i32) -> &i32) -> i32 {\n+        |f| 42\n+    }\n+    fn nested_fn_pointer_4(_: &i32) -> impl Fn(fn(&i32)) {\n+        |f| ()\n+    }\n+}\n+\n+mod issue6159 {\n+    use std::ops::Deref;\n+    pub fn apply_deref<'a, T, F, R>(x: &'a T, f: F) -> R\n+    where\n+        T: Deref,\n+        F: FnOnce(&'a T::Target) -> R,\n+    {\n+        f(x.deref())\n+    }\n+}\n+\n+mod issue7296 {\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    struct Foo;\n+    impl Foo {\n+        fn implicit(&self) -> &() {\n+            &()\n+        }\n+        fn implicit_mut(&mut self) -> &() {\n+            &()\n+        }\n+\n+        fn explicit<'a>(self: &'a Arc<Self>) -> &'a () {\n+            &()\n+        }\n+        fn explicit_mut<'a>(self: &'a mut Rc<Self>) -> &'a () {\n+            &()\n+        }\n+\n+        fn lifetime_elsewhere(self: Box<Self>, here: &()) -> &() {\n+            &()\n+        }\n+    }\n+\n+    trait Bar {\n+        fn implicit(&self) -> &();\n+        fn implicit_provided(&self) -> &() {\n+            &()\n+        }\n+\n+        fn explicit<'a>(self: &'a Arc<Self>) -> &'a ();\n+        fn explicit_provided<'a>(self: &'a Arc<Self>) -> &'a () {\n+            &()\n+        }\n+\n+        fn lifetime_elsewhere(self: Box<Self>, here: &()) -> &();\n+        fn lifetime_elsewhere_provided(self: Box<Self>, here: &()) -> &() {\n+            &()\n+        }\n+    }\n+}\n+\n+mod pr_9743_false_negative_fix {\n+    #![allow(unused)]\n+\n+    fn foo(x: &u8, y: &'_ u8) {}\n+\n+    fn bar(x: &u8, y: &'_ u8, z: &'_ u8) {}\n+}\n+\n+mod pr_9743_output_lifetime_checks {\n+    #![allow(unused)]\n+\n+    // lint: only one input\n+    fn one_input(x: &u8) -> &u8 {\n+        unimplemented!()\n+    }\n+\n+    // lint: multiple inputs, output would not be elided\n+    fn multiple_inputs_output_not_elided<'b>(x: &u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n+        unimplemented!()\n+    }\n+\n+    // don't lint: multiple inputs, output would be elided (which would create an ambiguity)\n+    fn multiple_inputs_output_would_be_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'a u8 {\n+        unimplemented!()\n+    }\n+}\n+\n+mod in_macro {\n+    macro_rules! local_one_input_macro {\n+        () => {\n+            fn one_input(x: &u8) -> &u8 {\n+                unimplemented!()\n+            }\n+        };\n+    }\n+\n+    // lint local macro expands to function with needless lifetimes\n+    local_one_input_macro!();\n+\n+    // no lint on external macro\n+    macro_rules::needless_lifetime!();\n+}\n+\n+mod issue5787 {\n+    use std::sync::MutexGuard;\n+\n+    struct Foo;\n+\n+    impl Foo {\n+        // doesn't get linted without async\n+        pub async fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> MutexGuard<'a, T> {\n+            guard\n+        }\n+    }\n+\n+    async fn foo<'a>(_x: &i32, y: &'a str) -> &'a str {\n+        y\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "409528b291db19d7e480f61161888ee6c47f0413", "filename": "tests/ui/needless_lifetimes.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fneedless_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fneedless_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,13 +1,20 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n #![warn(clippy::needless_lifetimes)]\n #![allow(\n-    dead_code,\n+    unused,\n     clippy::boxed_local,\n+    clippy::extra_unused_type_parameters,\n     clippy::needless_pass_by_value,\n     clippy::unnecessary_wraps,\n     dyn_drop,\n     clippy::get_first\n )]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n \n fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n@@ -495,4 +502,37 @@ mod pr_9743_output_lifetime_checks {\n     }\n }\n \n+mod in_macro {\n+    macro_rules! local_one_input_macro {\n+        () => {\n+            fn one_input<'a>(x: &'a u8) -> &'a u8 {\n+                unimplemented!()\n+            }\n+        };\n+    }\n+\n+    // lint local macro expands to function with needless lifetimes\n+    local_one_input_macro!();\n+\n+    // no lint on external macro\n+    macro_rules::needless_lifetime!();\n+}\n+\n+mod issue5787 {\n+    use std::sync::MutexGuard;\n+\n+    struct Foo;\n+\n+    impl Foo {\n+        // doesn't get linted without async\n+        pub async fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> MutexGuard<'a, T> {\n+            guard\n+        }\n+    }\n+\n+    async fn foo<'a>(_x: &i32, y: &'a str) -> &'a str {\n+        y\n+    }\n+}\n+\n fn main() {}"}, {"sha": "4e3c8f20d8c5238c2da9deaa6a83d085d6c94a42", "filename": "tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 317, "deletions": 74, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,316 +1,559 @@\n error: the following explicit lifetimes could be elided: 'a, 'b\n-  --> $DIR/needless_lifetimes.rs:11:1\n+  --> $DIR/needless_lifetimes.rs:18:1\n    |\n LL | fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::needless-lifetimes` implied by `-D warnings`\n+help: elide the lifetimes\n+   |\n+LL - fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n+LL + fn distinct_lifetimes(_x: &u8, _y: &u8, _z: u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a, 'b\n-  --> $DIR/needless_lifetimes.rs:13:1\n+  --> $DIR/needless_lifetimes.rs:20:1\n    |\n LL | fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n+LL + fn distinct_and_static(_x: &u8, _y: &u8, _z: &'static u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:23:1\n+  --> $DIR/needless_lifetimes.rs:30:1\n    |\n LL | fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n+LL + fn in_and_out(x: &u8, _y: u8) -> &u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'b\n-  --> $DIR/needless_lifetimes.rs:35:1\n+  --> $DIR/needless_lifetimes.rs:42:1\n    |\n LL | fn multiple_in_and_out_2a<'a, 'b>(x: &'a u8, _y: &'b u8) -> &'a u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn multiple_in_and_out_2a<'a, 'b>(x: &'a u8, _y: &'b u8) -> &'a u8 {\n+LL + fn multiple_in_and_out_2a<'a>(x: &'a u8, _y: &u8) -> &'a u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:42:1\n+  --> $DIR/needless_lifetimes.rs:49:1\n    |\n LL | fn multiple_in_and_out_2b<'a, 'b>(_x: &'a u8, y: &'b u8) -> &'b u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn multiple_in_and_out_2b<'a, 'b>(_x: &'a u8, y: &'b u8) -> &'b u8 {\n+LL + fn multiple_in_and_out_2b<'b>(_x: &u8, y: &'b u8) -> &'b u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'b\n-  --> $DIR/needless_lifetimes.rs:59:1\n+  --> $DIR/needless_lifetimes.rs:66:1\n    |\n LL | fn deep_reference_1a<'a, 'b>(x: &'a u8, _y: &'b u8) -> Result<&'a u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn deep_reference_1a<'a, 'b>(x: &'a u8, _y: &'b u8) -> Result<&'a u8, ()> {\n+LL + fn deep_reference_1a<'a>(x: &'a u8, _y: &u8) -> Result<&'a u8, ()> {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:66:1\n+  --> $DIR/needless_lifetimes.rs:73:1\n    |\n LL | fn deep_reference_1b<'a, 'b>(_x: &'a u8, y: &'b u8) -> Result<&'b u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn deep_reference_1b<'a, 'b>(_x: &'a u8, y: &'b u8) -> Result<&'b u8, ()> {\n+LL + fn deep_reference_1b<'b>(_x: &u8, y: &'b u8) -> Result<&'b u8, ()> {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:75:1\n+  --> $DIR/needless_lifetimes.rs:82:1\n    |\n LL | fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n+LL + fn deep_reference_3(x: &u8, _y: u8) -> Result<&u8, ()> {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:80:1\n+  --> $DIR/needless_lifetimes.rs:87:1\n    |\n LL | fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n+LL + fn where_clause_without_lt<T>(x: &u8, _y: u8) -> Result<&u8, ()>\n+   |\n \n error: the following explicit lifetimes could be elided: 'a, 'b\n-  --> $DIR/needless_lifetimes.rs:92:1\n+  --> $DIR/needless_lifetimes.rs:99:1\n    |\n LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:92:37\n+help: elide the lifetimes\n+   |\n+LL - fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n+LL + fn lifetime_param_2(_x: Ref<'_>, _y: &u8) {}\n    |\n-LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n-   |                                     ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:116:1\n+  --> $DIR/needless_lifetimes.rs:123:1\n    |\n LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:116:32\n+help: elide the lifetimes\n+   |\n+LL - fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n+LL + fn fn_bound_2<F, I>(_m: Lt<'_, I>, _f: F) -> Lt<'_, I>\n    |\n-LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n-   |                                ^^\n \n error: the following explicit lifetimes could be elided: 's\n-  --> $DIR/needless_lifetimes.rs:146:5\n+  --> $DIR/needless_lifetimes.rs:153:5\n    |\n LL |     fn self_and_out<'s>(&'s self) -> &'s u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn self_and_out<'s>(&'s self) -> &'s u8 {\n+LL +     fn self_and_out(&self) -> &u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 't\n-  --> $DIR/needless_lifetimes.rs:153:5\n+  --> $DIR/needless_lifetimes.rs:160:5\n    |\n LL |     fn self_and_in_out_1<'s, 't>(&'s self, _x: &'t u8) -> &'s u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn self_and_in_out_1<'s, 't>(&'s self, _x: &'t u8) -> &'s u8 {\n+LL +     fn self_and_in_out_1<'s>(&'s self, _x: &u8) -> &'s u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 's\n-  --> $DIR/needless_lifetimes.rs:160:5\n+  --> $DIR/needless_lifetimes.rs:167:5\n    |\n LL |     fn self_and_in_out_2<'s, 't>(&'s self, x: &'t u8) -> &'t u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn self_and_in_out_2<'s, 't>(&'s self, x: &'t u8) -> &'t u8 {\n+LL +     fn self_and_in_out_2<'t>(&self, x: &'t u8) -> &'t u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 's, 't\n-  --> $DIR/needless_lifetimes.rs:164:5\n+  --> $DIR/needless_lifetimes.rs:171:5\n    |\n LL |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n+LL +     fn distinct_self_and_in(&self, _x: &u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:183:1\n+  --> $DIR/needless_lifetimes.rs:190:1\n    |\n LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:183:33\n+help: elide the lifetimes\n+   |\n+LL - fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n+LL + fn struct_with_lt(_foo: Foo<'_>) -> &str {\n    |\n-LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n-   |                                 ^^\n \n error: the following explicit lifetimes could be elided: 'b\n-  --> $DIR/needless_lifetimes.rs:201:1\n+  --> $DIR/needless_lifetimes.rs:208:1\n    |\n LL | fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:201:43\n+help: elide the lifetimes\n+   |\n+LL - fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n+LL + fn struct_with_lt4a<'a>(_foo: &'a Foo<'_>) -> &'a str {\n    |\n-LL | fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n-   |                                           ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:209:1\n+  --> $DIR/needless_lifetimes.rs:216:1\n    |\n LL | fn struct_with_lt4b<'a, 'b>(_foo: &'a Foo<'b>) -> &'b str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn struct_with_lt4b<'a, 'b>(_foo: &'a Foo<'b>) -> &'b str {\n+LL + fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:224:1\n+  --> $DIR/needless_lifetimes.rs:231:1\n    |\n LL | fn trait_obj_elided2<'a>(_arg: &'a dyn Drop) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn trait_obj_elided2<'a>(_arg: &'a dyn Drop) -> &'a str {\n+LL + fn trait_obj_elided2(_arg: &dyn Drop) -> &str {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:230:1\n+  --> $DIR/needless_lifetimes.rs:237:1\n    |\n LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:230:37\n+help: elide the lifetimes\n+   |\n+LL - fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n+LL + fn alias_with_lt(_foo: FooAlias<'_>) -> &str {\n    |\n-LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n-   |                                     ^^\n \n error: the following explicit lifetimes could be elided: 'b\n-  --> $DIR/needless_lifetimes.rs:248:1\n+  --> $DIR/needless_lifetimes.rs:255:1\n    |\n LL | fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:248:47\n+help: elide the lifetimes\n+   |\n+LL - fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n+LL + fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str {\n    |\n-LL | fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n-   |                                               ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:256:1\n+  --> $DIR/needless_lifetimes.rs:263:1\n    |\n LL | fn alias_with_lt4b<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'b str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn alias_with_lt4b<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'b str {\n+LL + fn alias_with_lt4b<'b>(_foo: &FooAlias<'b>) -> &'b str {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:260:1\n+  --> $DIR/needless_lifetimes.rs:267:1\n    |\n LL | fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n+LL + fn named_input_elided_output(_arg: &str) -> &str {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:268:1\n+  --> $DIR/needless_lifetimes.rs:275:1\n    |\n LL | fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL - fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n+LL + fn trait_bound_ok<T: WithLifetime<'static>>(_: &u8, _: T) {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:304:1\n+  --> $DIR/needless_lifetimes.rs:311:1\n    |\n LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:304:47\n+help: elide the lifetimes\n+   |\n+LL - fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n+LL + fn out_return_type_lts(e: &str) -> Cow<'_> {\n    |\n-LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n-   |                                               ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:311:9\n+  --> $DIR/needless_lifetimes.rs:318:9\n    |\n LL |         fn needless_lt<'a>(x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn needless_lt<'a>(x: &'a u8) {}\n+LL +         fn needless_lt(x: &u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:315:9\n+  --> $DIR/needless_lifetimes.rs:322:9\n    |\n LL |         fn needless_lt<'a>(_x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn needless_lt<'a>(_x: &'a u8) {}\n+LL +         fn needless_lt(_x: &u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:328:9\n+  --> $DIR/needless_lifetimes.rs:335:9\n    |\n LL |         fn baz<'a>(&'a self) -> impl Foo + 'a {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn baz<'a>(&'a self) -> impl Foo + 'a {\n+LL +         fn baz(&self) -> impl Foo + '_ {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:360:5\n+  --> $DIR/needless_lifetimes.rs:367:5\n    |\n LL |     fn impl_trait_elidable_nested_anonymous_lifetimes<'a>(i: &'a i32, f: impl Fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn impl_trait_elidable_nested_anonymous_lifetimes<'a>(i: &'a i32, f: impl Fn(&i32) -> &i32) -> &'a i32 {\n+LL +     fn impl_trait_elidable_nested_anonymous_lifetimes(i: &i32, f: impl Fn(&i32) -> &i32) -> &i32 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:369:5\n+  --> $DIR/needless_lifetimes.rs:376:5\n    |\n LL |     fn generics_elidable<'a, T: Fn(&i32) -> &i32>(i: &'a i32, f: T) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn generics_elidable<'a, T: Fn(&i32) -> &i32>(i: &'a i32, f: T) -> &'a i32 {\n+LL +     fn generics_elidable<T: Fn(&i32) -> &i32>(i: &i32, f: T) -> &i32 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:381:5\n+  --> $DIR/needless_lifetimes.rs:388:5\n    |\n LL |     fn where_clause_elidadable<'a, T>(i: &'a i32, f: T) -> &'a i32\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn where_clause_elidadable<'a, T>(i: &'a i32, f: T) -> &'a i32\n+LL +     fn where_clause_elidadable<T>(i: &i32, f: T) -> &i32\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:396:5\n+  --> $DIR/needless_lifetimes.rs:403:5\n    |\n LL |     fn pointer_fn_elidable<'a>(i: &'a i32, f: fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn pointer_fn_elidable<'a>(i: &'a i32, f: fn(&i32) -> &i32) -> &'a i32 {\n+LL +     fn pointer_fn_elidable(i: &i32, f: fn(&i32) -> &i32) -> &i32 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:409:5\n+  --> $DIR/needless_lifetimes.rs:416:5\n    |\n LL |     fn nested_fn_pointer_3<'a>(_: &'a i32) -> fn(fn(&i32) -> &i32) -> i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn nested_fn_pointer_3<'a>(_: &'a i32) -> fn(fn(&i32) -> &i32) -> i32 {\n+LL +     fn nested_fn_pointer_3(_: &i32) -> fn(fn(&i32) -> &i32) -> i32 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:412:5\n+  --> $DIR/needless_lifetimes.rs:419:5\n    |\n LL |     fn nested_fn_pointer_4<'a>(_: &'a i32) -> impl Fn(fn(&i32)) {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn nested_fn_pointer_4<'a>(_: &'a i32) -> impl Fn(fn(&i32)) {\n+LL +     fn nested_fn_pointer_4(_: &i32) -> impl Fn(fn(&i32)) {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:434:9\n+  --> $DIR/needless_lifetimes.rs:441:9\n    |\n LL |         fn implicit<'a>(&'a self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn implicit<'a>(&'a self) -> &'a () {\n+LL +         fn implicit(&self) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:437:9\n+  --> $DIR/needless_lifetimes.rs:444:9\n    |\n LL |         fn implicit_mut<'a>(&'a mut self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn implicit_mut<'a>(&'a mut self) -> &'a () {\n+LL +         fn implicit_mut(&mut self) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:448:9\n+  --> $DIR/needless_lifetimes.rs:455:9\n    |\n LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n+LL +         fn lifetime_elsewhere(self: Box<Self>, here: &()) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:454:9\n+  --> $DIR/needless_lifetimes.rs:461:9\n    |\n LL |         fn implicit<'a>(&'a self) -> &'a ();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn implicit<'a>(&'a self) -> &'a ();\n+LL +         fn implicit(&self) -> &();\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:455:9\n+  --> $DIR/needless_lifetimes.rs:462:9\n    |\n LL |         fn implicit_provided<'a>(&'a self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn implicit_provided<'a>(&'a self) -> &'a () {\n+LL +         fn implicit_provided(&self) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:464:9\n+  --> $DIR/needless_lifetimes.rs:471:9\n    |\n LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a ();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a ();\n+LL +         fn lifetime_elsewhere(self: Box<Self>, here: &()) -> &();\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:465:9\n+  --> $DIR/needless_lifetimes.rs:472:9\n    |\n LL |         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n+LL +         fn lifetime_elsewhere_provided(self: Box<Self>, here: &()) -> &() {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:474:5\n+  --> $DIR/needless_lifetimes.rs:481:5\n    |\n LL |     fn foo<'a>(x: &'a u8, y: &'_ u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn foo<'a>(x: &'a u8, y: &'_ u8) {}\n+LL +     fn foo(x: &u8, y: &'_ u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:476:5\n+  --> $DIR/needless_lifetimes.rs:483:5\n    |\n LL |     fn bar<'a>(x: &'a u8, y: &'_ u8, z: &'_ u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn bar<'a>(x: &'a u8, y: &'_ u8, z: &'_ u8) {}\n+LL +     fn bar(x: &u8, y: &'_ u8, z: &'_ u8) {}\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:483:5\n+  --> $DIR/needless_lifetimes.rs:490:5\n    |\n LL |     fn one_input<'a>(x: &'a u8) -> &'a u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn one_input<'a>(x: &'a u8) -> &'a u8 {\n+LL +     fn one_input(x: &u8) -> &u8 {\n+   |\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:488:5\n+  --> $DIR/needless_lifetimes.rs:495:5\n    |\n LL |     fn multiple_inputs_output_not_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: elide the lifetimes\n+   |\n+LL -     fn multiple_inputs_output_not_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n+LL +     fn multiple_inputs_output_not_elided<'b>(x: &u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n+   |\n+\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:508:13\n+   |\n+LL |             fn one_input<'a>(x: &'a u8) -> &'a u8 {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     local_one_input_macro!();\n+   |     ------------------------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `local_one_input_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: elide the lifetimes\n+   |\n+LL -             fn one_input<'a>(x: &'a u8) -> &'a u8 {\n+LL +             fn one_input(x: &u8) -> &u8 {\n+   |\n \n-error: aborting due to 45 previous errors\n+error: aborting due to 46 previous errors\n "}, {"sha": "cffa19bec3a6661b9e8c1a7ad648d2254174319b", "filename": "tests/ui/needless_range_loop.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fneedless_range_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fneedless_range_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -49,7 +49,7 @@ error: the loop variable `i` is used to index `vec`\n LL |     for i in 0..vec.len() {\n    |              ^^^^^^^^^^^^\n    |\n-help: consider using an iterator\n+help: consider using an iterator and enumerate()\n    |\n LL |     for (i, <item>) in vec.iter().enumerate() {\n    |         ~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~\n@@ -126,7 +126,7 @@ error: the loop variable `i` is used to index `vec`\n LL |     for i in 5..vec.len() {\n    |              ^^^^^^^^^^^^\n    |\n-help: consider using an iterator\n+help: consider using an iterator and enumerate()\n    |\n LL |     for (i, <item>) in vec.iter().enumerate().skip(5) {\n    |         ~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -137,7 +137,7 @@ error: the loop variable `i` is used to index `vec`\n LL |     for i in 5..10 {\n    |              ^^^^^\n    |\n-help: consider using an iterator\n+help: consider using an iterator and enumerate()\n    |\n LL |     for (i, <item>) in vec.iter().enumerate().take(10).skip(5) {\n    |         ~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -148,7 +148,7 @@ error: the loop variable `i` is used to index `vec`\n LL |     for i in 0..vec.len() {\n    |              ^^^^^^^^^^^^\n    |\n-help: consider using an iterator\n+help: consider using an iterator and enumerate()\n    |\n LL |     for (i, <item>) in vec.iter_mut().enumerate() {\n    |         ~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~"}, {"sha": "7803418cb047dbd0ff25c097d68ebfe9d8b8567b", "filename": "tests/ui/new_without_default.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_without_default.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,4 +1,9 @@\n-#![allow(dead_code, clippy::missing_safety_doc, clippy::extra_unused_lifetimes)]\n+#![allow(\n+    dead_code,\n+    clippy::missing_safety_doc,\n+    clippy::extra_unused_lifetimes,\n+    clippy::extra_unused_type_parameters\n+)]\n #![warn(clippy::new_without_default)]\n \n pub struct Foo;"}, {"sha": "583dd327d6a5d8856b2cae4eadd2efef217d9b82", "filename": "tests/ui/new_without_default.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fnew_without_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fnew_without_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_without_default.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,5 +1,5 @@\n error: you should consider adding a `Default` implementation for `Foo`\n-  --> $DIR/new_without_default.rs:7:5\n+  --> $DIR/new_without_default.rs:12:5\n    |\n LL | /     pub fn new() -> Foo {\n LL | |         Foo\n@@ -17,7 +17,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `Bar`\n-  --> $DIR/new_without_default.rs:15:5\n+  --> $DIR/new_without_default.rs:20:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         Bar\n@@ -34,7 +34,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `LtKo<'c>`\n-  --> $DIR/new_without_default.rs:79:5\n+  --> $DIR/new_without_default.rs:84:5\n    |\n LL | /     pub fn new() -> LtKo<'c> {\n LL | |         unimplemented!()\n@@ -51,7 +51,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `NewNotEqualToDerive`\n-  --> $DIR/new_without_default.rs:172:5\n+  --> $DIR/new_without_default.rs:177:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         NewNotEqualToDerive { foo: 1 }\n@@ -68,7 +68,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `FooGenerics<T>`\n-  --> $DIR/new_without_default.rs:180:5\n+  --> $DIR/new_without_default.rs:185:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         Self(Default::default())\n@@ -85,7 +85,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `BarGenerics<T>`\n-  --> $DIR/new_without_default.rs:187:5\n+  --> $DIR/new_without_default.rs:192:5\n    |\n LL | /     pub fn new() -> Self {\n LL | |         Self(Default::default())\n@@ -102,7 +102,7 @@ LL + }\n    |\n \n error: you should consider adding a `Default` implementation for `Foo<T>`\n-  --> $DIR/new_without_default.rs:198:9\n+  --> $DIR/new_without_default.rs:203:9\n    |\n LL | /         pub fn new() -> Self {\n LL | |             todo!()"}, {"sha": "276266a2dd80358b1af6d47a1d8b5e7a6a6b60b5", "filename": "tests/ui/redundant_field_names.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fredundant_field_names.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fredundant_field_names.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_field_names.fixed?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::redundant_field_names)]\n-#![allow(clippy::no_effect, dead_code, unused_variables)]\n+#![allow(clippy::extra_unused_type_parameters, clippy::no_effect, dead_code, unused_variables)]\n \n #[macro_use]\n extern crate derive_new;"}, {"sha": "f674141c138e1283912809b8f1863a86d1d4b51d", "filename": "tests/ui/redundant_field_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_field_names.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::redundant_field_names)]\n-#![allow(clippy::no_effect, dead_code, unused_variables)]\n+#![allow(clippy::extra_unused_type_parameters, clippy::no_effect, dead_code, unused_variables)]\n \n #[macro_use]\n extern crate derive_new;"}, {"sha": "ab8ac97a0e7071575e1361ddb5f07477e22335e5", "filename": "tests/ui/regex.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregex.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -36,6 +36,10 @@ fn syntax_error() {\n \n     let raw_string_error = Regex::new(r\"[...\\/...]\");\n     let raw_string_error = Regex::new(r#\"[...\\/...]\"#);\n+\n+    let escaped_string_span = Regex::new(\"\\\\b\\\\c\");\n+\n+    let aux_span = Regex::new(\"(?ixi)\");\n }\n \n fn trivial_regex() {"}, {"sha": "c2440f39e0a032229db7de11998f1e8bc1cc4f23", "filename": "tests/ui/regex.stderr", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fregex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fregex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregex.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -29,7 +29,10 @@ error: regex syntax error: invalid character class range, the start must be <= t\n LL |     let some_unicode = Regex::new(\"[\u00e9-\u00e8]\");\n    |                                     ^^^\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:18:33\n    |\n LL |     let some_regex = Regex::new(OPENING_PAREN);\n@@ -43,25 +46,37 @@ LL |     let binary_pipe_in_wrong_position = BRegex::new(\"|\");\n    |\n    = help: the regex is unlikely to be useful as it is\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:21:41\n    |\n LL |     let some_binary_regex = BRegex::new(OPENING_PAREN);\n    |                                         ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:22:56\n    |\n LL |     let some_binary_regex_builder = BRegexBuilder::new(OPENING_PAREN);\n    |                                                        ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:34:37\n    |\n LL |     let set_error = RegexSet::new(&[OPENING_PAREN, r\"[a-z]+/.(com|org|net)\"]);\n    |                                     ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:35:39\n    |\n LL |     let bset_error = BRegexSet::new(&[OPENING_PAREN, r\"[a-z]+/.(com|org|net)\"]);\n@@ -79,93 +94,110 @@ error: regex syntax error: unrecognized escape sequence\n LL |     let raw_string_error = Regex::new(r#\"[...//...]\"#);\n    |                                              ^^\n \n+error: regex parse error:\n+           /b/c\n+             ^^\n+       error: unrecognized escape sequence\n+  --> $DIR/regex.rs:40:42\n+   |\n+LL |     let escaped_string_span = Regex::new(\"/b/c\");\n+   |                                          ^^^^^^^^\n+   |\n+   = help: consider using a raw string literal: `r\"..\"`\n+\n+error: regex syntax error: duplicate flag\n+  --> $DIR/regex.rs:42:34\n+   |\n+LL |     let aux_span = Regex::new(\"(?ixi)\");\n+   |                                  ^ ^\n+\n error: trivial regex\n-  --> $DIR/regex.rs:42:33\n+  --> $DIR/regex.rs:46:33\n    |\n LL |     let trivial_eq = Regex::new(\"^foobar$\");\n    |                                 ^^^^^^^^^^\n    |\n    = help: consider using `==` on `str`s\n \n error: trivial regex\n-  --> $DIR/regex.rs:44:48\n+  --> $DIR/regex.rs:48:48\n    |\n LL |     let trivial_eq_builder = RegexBuilder::new(\"^foobar$\");\n    |                                                ^^^^^^^^^^\n    |\n    = help: consider using `==` on `str`s\n \n error: trivial regex\n-  --> $DIR/regex.rs:46:42\n+  --> $DIR/regex.rs:50:42\n    |\n LL |     let trivial_starts_with = Regex::new(\"^foobar\");\n    |                                          ^^^^^^^^^\n    |\n    = help: consider using `str::starts_with`\n \n error: trivial regex\n-  --> $DIR/regex.rs:48:40\n+  --> $DIR/regex.rs:52:40\n    |\n LL |     let trivial_ends_with = Regex::new(\"foobar$\");\n    |                                        ^^^^^^^^^\n    |\n    = help: consider using `str::ends_with`\n \n error: trivial regex\n-  --> $DIR/regex.rs:50:39\n+  --> $DIR/regex.rs:54:39\n    |\n LL |     let trivial_contains = Regex::new(\"foobar\");\n    |                                       ^^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:52:39\n+  --> $DIR/regex.rs:56:39\n    |\n LL |     let trivial_contains = Regex::new(NOT_A_REAL_REGEX);\n    |                                       ^^^^^^^^^^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:54:40\n+  --> $DIR/regex.rs:58:40\n    |\n LL |     let trivial_backslash = Regex::new(\"a/.b\");\n    |                                        ^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:57:36\n+  --> $DIR/regex.rs:61:36\n    |\n LL |     let trivial_empty = Regex::new(\"\");\n    |                                    ^^\n    |\n    = help: the regex is unlikely to be useful as it is\n \n error: trivial regex\n-  --> $DIR/regex.rs:59:36\n+  --> $DIR/regex.rs:63:36\n    |\n LL |     let trivial_empty = Regex::new(\"^\");\n    |                                    ^^^\n    |\n    = help: the regex is unlikely to be useful as it is\n \n error: trivial regex\n-  --> $DIR/regex.rs:61:36\n+  --> $DIR/regex.rs:65:36\n    |\n LL |     let trivial_empty = Regex::new(\"^$\");\n    |                                    ^^^^\n    |\n    = help: consider using `str::is_empty`\n \n error: trivial regex\n-  --> $DIR/regex.rs:63:44\n+  --> $DIR/regex.rs:67:44\n    |\n LL |     let binary_trivial_empty = BRegex::new(\"^$\");\n    |                                            ^^^^\n    |\n    = help: consider using `str::is_empty`\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 25 previous errors\n "}, {"sha": "dc24d447c6075a427beddcbf9481ea3dd8b642ff", "filename": "tests/ui/seek_to_start_instead_of_rewind.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fseek_to_start_instead_of_rewind.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fseek_to_start_instead_of_rewind.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fseek_to_start_instead_of_rewind.fixed?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -26,7 +26,7 @@ fn seek_to_start_false_method(t: &mut StructWithSeekMethod) {\n \n // This should NOT trigger clippy warning because\n // StructWithSeekMethod does not implement std::io::Seek;\n-fn seek_to_start_method_owned_false<T>(mut t: StructWithSeekMethod) {\n+fn seek_to_start_method_owned_false(mut t: StructWithSeekMethod) {\n     t.seek(SeekFrom::Start(0));\n }\n \n@@ -38,7 +38,7 @@ fn seek_to_start_false_trait(t: &mut StructWithSeekTrait) {\n \n // This should NOT trigger clippy warning because\n // StructWithSeekMethod does not implement std::io::Seek;\n-fn seek_to_start_false_trait_owned<T>(mut t: StructWithSeekTrait) {\n+fn seek_to_start_false_trait_owned(mut t: StructWithSeekTrait) {\n     t.seek(SeekFrom::Start(0));\n }\n "}, {"sha": "4adde2c40182d957f90b216dcb8ee00e1d91a035", "filename": "tests/ui/seek_to_start_instead_of_rewind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fseek_to_start_instead_of_rewind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fseek_to_start_instead_of_rewind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fseek_to_start_instead_of_rewind.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -26,7 +26,7 @@ fn seek_to_start_false_method(t: &mut StructWithSeekMethod) {\n \n // This should NOT trigger clippy warning because\n // StructWithSeekMethod does not implement std::io::Seek;\n-fn seek_to_start_method_owned_false<T>(mut t: StructWithSeekMethod) {\n+fn seek_to_start_method_owned_false(mut t: StructWithSeekMethod) {\n     t.seek(SeekFrom::Start(0));\n }\n \n@@ -38,7 +38,7 @@ fn seek_to_start_false_trait(t: &mut StructWithSeekTrait) {\n \n // This should NOT trigger clippy warning because\n // StructWithSeekMethod does not implement std::io::Seek;\n-fn seek_to_start_false_trait_owned<T>(mut t: StructWithSeekTrait) {\n+fn seek_to_start_false_trait_owned(mut t: StructWithSeekTrait) {\n     t.seek(SeekFrom::Start(0));\n }\n "}, {"sha": "c4ec7aa88a2a358e6f77e2a0d21ffd987d6c7324", "filename": "tests/ui/suspicious_to_owned.stderr", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fsuspicious_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fsuspicious_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_to_owned.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -2,27 +2,62 @@ error: this `to_owned` call clones the Cow<'_, str> itself and does not cause th\n   --> $DIR/suspicious_to_owned.rs:16:13\n    |\n LL |     let _ = cow.to_owned();\n-   |             ^^^^^^^^^^^^^^ help: consider using, depending on intent: `cow.clone()` or `cow.into_owned()`\n+   |             ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::suspicious-to-owned` implied by `-D warnings`\n+help: depending on intent, either make the Cow an Owned variant\n+   |\n+LL |     let _ = cow.into_owned();\n+   |             ~~~~~~~~~~~~~~~~\n+help: or clone the Cow itself\n+   |\n+LL |     let _ = cow.clone();\n+   |             ~~~~~~~~~~~\n \n error: this `to_owned` call clones the Cow<'_, [char; 3]> itself and does not cause the Cow<'_, [char; 3]> contents to become owned\n   --> $DIR/suspicious_to_owned.rs:26:13\n    |\n LL |     let _ = cow.to_owned();\n-   |             ^^^^^^^^^^^^^^ help: consider using, depending on intent: `cow.clone()` or `cow.into_owned()`\n+   |             ^^^^^^^^^^^^^^\n+   |\n+help: depending on intent, either make the Cow an Owned variant\n+   |\n+LL |     let _ = cow.into_owned();\n+   |             ~~~~~~~~~~~~~~~~\n+help: or clone the Cow itself\n+   |\n+LL |     let _ = cow.clone();\n+   |             ~~~~~~~~~~~\n \n error: this `to_owned` call clones the Cow<'_, Vec<char>> itself and does not cause the Cow<'_, Vec<char>> contents to become owned\n   --> $DIR/suspicious_to_owned.rs:36:13\n    |\n LL |     let _ = cow.to_owned();\n-   |             ^^^^^^^^^^^^^^ help: consider using, depending on intent: `cow.clone()` or `cow.into_owned()`\n+   |             ^^^^^^^^^^^^^^\n+   |\n+help: depending on intent, either make the Cow an Owned variant\n+   |\n+LL |     let _ = cow.into_owned();\n+   |             ~~~~~~~~~~~~~~~~\n+help: or clone the Cow itself\n+   |\n+LL |     let _ = cow.clone();\n+   |             ~~~~~~~~~~~\n \n error: this `to_owned` call clones the Cow<'_, str> itself and does not cause the Cow<'_, str> contents to become owned\n   --> $DIR/suspicious_to_owned.rs:46:13\n    |\n LL |     let _ = cow.to_owned();\n-   |             ^^^^^^^^^^^^^^ help: consider using, depending on intent: `cow.clone()` or `cow.into_owned()`\n+   |             ^^^^^^^^^^^^^^\n+   |\n+help: depending on intent, either make the Cow an Owned variant\n+   |\n+LL |     let _ = cow.into_owned();\n+   |             ~~~~~~~~~~~~~~~~\n+help: or clone the Cow itself\n+   |\n+LL |     let _ = cow.clone();\n+   |             ~~~~~~~~~~~\n \n error: implicitly cloning a `String` by calling `to_owned` on its dereferenced type\n   --> $DIR/suspicious_to_owned.rs:60:13"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "8b4613b3f6ec73f3c7072ce8a20583f5463ccd02", "filename": "tests/ui/type_repetition_in_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Ftype_repetition_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Ftype_repetition_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,4 +1,5 @@\n #![deny(clippy::type_repetition_in_bounds)]\n+#![allow(clippy::extra_unused_type_parameters)]\n \n use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n "}, {"sha": "a90df03c04ffc2738fe848edd8023803d988e577", "filename": "tests/ui/type_repetition_in_bounds.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -1,5 +1,5 @@\n error: this type has already been used as a bound predicate\n-  --> $DIR/type_repetition_in_bounds.rs:8:5\n+  --> $DIR/type_repetition_in_bounds.rs:9:5\n    |\n LL |     T: Clone,\n    |     ^^^^^^^^\n@@ -12,23 +12,23 @@ LL | #![deny(clippy::type_repetition_in_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this type has already been used as a bound predicate\n-  --> $DIR/type_repetition_in_bounds.rs:25:5\n+  --> $DIR/type_repetition_in_bounds.rs:26:5\n    |\n LL |     Self: Copy + Default + Ord,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider combining the bounds: `Self: Clone + Copy + Default + Ord`\n \n error: this type has already been used as a bound predicate\n-  --> $DIR/type_repetition_in_bounds.rs:85:5\n+  --> $DIR/type_repetition_in_bounds.rs:86:5\n    |\n LL |     T: Clone,\n    |     ^^^^^^^^\n    |\n    = help: consider combining the bounds: `T: ?Sized + Clone`\n \n error: this type has already been used as a bound predicate\n-  --> $DIR/type_repetition_in_bounds.rs:90:5\n+  --> $DIR/type_repetition_in_bounds.rs:91:5\n    |\n LL |     T: ?Sized,\n    |     ^^^^^^^^^"}, {"sha": "8d3e094b75967bf6741d58d38f4df882b3fb42be", "filename": "tests/ui/unused_io_amount.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_io_amount.rs?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -63,6 +63,14 @@ fn combine_or(file: &str) -> Result<(), Error> {\n     Ok(())\n }\n \n+fn is_ok_err<T: io::Read + io::Write>(s: &mut T) {\n+    s.write(b\"ok\").is_ok();\n+    s.write(b\"err\").is_err();\n+    let mut buf = [0u8; 0];\n+    s.read(&mut buf).is_ok();\n+    s.read(&mut buf).is_err();\n+}\n+\n async fn bad_async_write<W: AsyncWrite + Unpin>(w: &mut W) {\n     w.write(b\"hello world\").await.unwrap();\n }"}, {"sha": "0865c5213f6873e94cc8dfa3eb5b1e0e5fe48ae7", "filename": "tests/ui/unused_io_amount.stderr", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Funused_io_amount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Funused_io_amount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_io_amount.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -82,50 +82,82 @@ LL | |         .expect(\"error\");\n error: written amount is not handled\n   --> $DIR/unused_io_amount.rs:67:5\n    |\n+LL |     s.write(b\"ok\").is_ok();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Write::write_all` instead, or handle partial writes\n+\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:68:5\n+   |\n+LL |     s.write(b\"err\").is_err();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Write::write_all` instead, or handle partial writes\n+\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:70:5\n+   |\n+LL |     s.read(&mut buf).is_ok();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n+\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:71:5\n+   |\n+LL |     s.read(&mut buf).is_err();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n+\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:75:5\n+   |\n LL |     w.write(b\"hello world\").await.unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n \n error: read amount is not handled\n-  --> $DIR/unused_io_amount.rs:72:5\n+  --> $DIR/unused_io_amount.rs:80:5\n    |\n LL |     r.read(&mut buf[..]).await.unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n \n error: written amount is not handled\n-  --> $DIR/unused_io_amount.rs:85:9\n+  --> $DIR/unused_io_amount.rs:93:9\n    |\n LL |         w.write(b\"hello world\").await?;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n \n error: read amount is not handled\n-  --> $DIR/unused_io_amount.rs:93:9\n+  --> $DIR/unused_io_amount.rs:101:9\n    |\n LL |         r.read(&mut buf[..]).await.or(Err(Error::Kind))?;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n \n error: written amount is not handled\n-  --> $DIR/unused_io_amount.rs:101:5\n+  --> $DIR/unused_io_amount.rs:109:5\n    |\n LL |     w.write(b\"hello world\").await.unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n \n error: read amount is not handled\n-  --> $DIR/unused_io_amount.rs:106:5\n+  --> $DIR/unused_io_amount.rs:114:5\n    |\n LL |     r.read(&mut buf[..]).await.unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "293bf75a717627b9b48b949ba925b38ae51f74c0", "filename": "tests/ui/wildcard_enum_match_arm.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.fixed?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -96,7 +96,7 @@ fn main() {\n         }\n         match Enum::A {\n             Enum::A => (),\n-            Enum::B | _ => (),\n+            Enum::B | Enum::__Private => (),\n         }\n     }\n }"}, {"sha": "30d29aa4e77a1cccde389f57fa0dac1cad717993", "filename": "tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c61b4ed89d941fad38dfff57923262e71219970/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=7c61b4ed89d941fad38dfff57923262e71219970", "patch": "@@ -34,11 +34,11 @@ error: wildcard matches known variants and will also match future added variants\n LL |         _ => {},\n    |         ^ help: try this: `ErrorKind::PermissionDenied | _`\n \n-error: wildcard matches known variants and will also match future added variants\n+error: wildcard match will also match any future added variants\n   --> $DIR/wildcard_enum_match_arm.rs:99:13\n    |\n LL |             _ => (),\n-   |             ^ help: try this: `Enum::B | _`\n+   |             ^ help: try this: `Enum::B | Enum::__Private`\n \n error: aborting due to 6 previous errors\n "}]}