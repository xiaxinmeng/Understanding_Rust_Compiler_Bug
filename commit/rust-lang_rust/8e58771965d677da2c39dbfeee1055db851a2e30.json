{"sha": "8e58771965d677da2c39dbfeee1055db851a2e30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNTg3NzE5NjVkNjc3ZGEyYzM5ZGJmZWVlMTA1NWRiODUxYTJlMzA=", "commit": {"author": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2014-10-06T03:08:35Z"}, "committer": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2014-10-06T03:43:34Z"}, "message": "Remove the #[allow(non_uppercase_statics)] attr from bitflags!", "tree": {"sha": "3c67fba6d2d23a463f01bbfcd0bee34761518e18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c67fba6d2d23a463f01bbfcd0bee34761518e18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e58771965d677da2c39dbfeee1055db851a2e30", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e58771965d677da2c39dbfeee1055db851a2e30", "html_url": "https://github.com/rust-lang/rust/commit/8e58771965d677da2c39dbfeee1055db851a2e30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e58771965d677da2c39dbfeee1055db851a2e30/comments", "author": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3ca987f7485c7a43f13980cbce34d98689ac3f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ca987f7485c7a43f13980cbce34d98689ac3f4", "html_url": "https://github.com/rust-lang/rust/commit/e3ca987f7485c7a43f13980cbce34d98689ac3f4"}], "stats": {"total": 79, "additions": 37, "deletions": 42}, "files": [{"sha": "7966040ed7bc666c879f9e78585d4188dc73c822", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8e58771965d677da2c39dbfeee1055db851a2e30/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58771965d677da2c39dbfeee1055db851a2e30/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=8e58771965d677da2c39dbfeee1055db851a2e30", "patch": "@@ -24,22 +24,22 @@\n /// ```{.rust}\n /// bitflags! {\n ///     flags Flags: u32 {\n-///         static FlagA       = 0x00000001,\n-///         static FlagB       = 0x00000010,\n-///         static FlagC       = 0x00000100,\n-///         static FlagABC     = FlagA.bits\n-///                            | FlagB.bits\n-///                            | FlagC.bits,\n+///         static FLAG_A       = 0x00000001,\n+///         static FLAG_B       = 0x00000010,\n+///         static FLAG_C       = 0x00000100,\n+///         static FLAG_ABC     = FLAG_A.bits\n+///                             | FLAG_B.bits\n+///                             | FLAG_C.bits,\n ///     }\n /// }\n ///\n /// fn main() {\n-///     let e1 = FlagA | FlagC;\n-///     let e2 = FlagB | FlagC;\n-///     assert!((e1 | e2) == FlagABC);   // union\n-///     assert!((e1 & e2) == FlagC);     // intersection\n-///     assert!((e1 - e2) == FlagA);     // set difference\n-///     assert!(!e2 == FlagA);           // set complement\n+///     let e1 = FLAG_A | FLAG_C;\n+///     let e2 = FLAG_B | FLAG_C;\n+///     assert!((e1 | e2) == FLAG_ABC);   // union\n+///     assert!((e1 & e2) == FLAG_C);     // intersection\n+///     assert!((e1 - e2) == FLAG_A);     // set difference\n+///     assert!(!e2 == FLAG_A);           // set complement\n /// }\n /// ```\n ///\n@@ -50,8 +50,8 @@\n ///\n /// bitflags! {\n ///     flags Flags: u32 {\n-///         static FlagA   = 0x00000001,\n-///         static FlagB   = 0x00000010,\n+///         static FLAG_A   = 0x00000001,\n+///         static FLAG_B   = 0x00000010,\n ///     }\n /// }\n ///\n@@ -69,7 +69,7 @@\n /// }\n ///\n /// fn main() {\n-///     let mut flags = FlagA | FlagB;\n+///     let mut flags = FLAG_A | FLAG_B;\n ///     flags.clear();\n ///     assert!(flags.is_empty());\n ///     assert_eq!(format!(\"{}\", flags).as_slice(), \"hi!\");\n@@ -123,10 +123,7 @@ macro_rules! bitflags {\n             bits: $T,\n         }\n \n-        $(\n-            #[allow(non_uppercase_statics)]\n-            $(#[$Flag_attr])* pub static $Flag: $BitFlags = $BitFlags { bits: $value };\n-         )+\n+        $($(#[$Flag_attr])* pub static $Flag: $BitFlags = $BitFlags { bits: $value };)+\n \n         impl $BitFlags {\n             /// Returns an empty set of flags.\n@@ -243,16 +240,14 @@ macro_rules! bitflags {\n         bitflags! {\n             $(#[$attr])*\n             flags $BitFlags: $T {\n-                $(\n-                    #[allow(non_uppercase_statics)]\n-                    $(#[$Flag_attr])* static $Flag = $value\n-                 ),+\n+                $($(#[$Flag_attr])* static $Flag = $value),+\n             }\n         }\n     };\n }\n \n #[cfg(test)]\n+#[allow(non_uppercase_statics)]\n mod tests {\n     use hash;\n     use option::{Some, None};"}, {"sha": "6ab14417265c83967ce7d77c9533c05651ff4545", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8e58771965d677da2c39dbfeee1055db851a2e30/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58771965d677da2c39dbfeee1055db851a2e30/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8e58771965d677da2c39dbfeee1055db851a2e30", "patch": "@@ -91,10 +91,10 @@ use std::iter;\n \n bitflags! {\n     flags Restrictions: u8 {\n-        static Unrestricted               = 0b0000,\n-        static RestrictionStmtExpr        = 0b0001,\n-        static RestrictionNoBarOp         = 0b0010,\n-        static RestrictionNoStructLiteral = 0b0100\n+        static UNRESTRICTED                  = 0b0000,\n+        static RESTRICTION_STMT_EXPR         = 0b0001,\n+        static RESTRICTION_NO_BAR_OP         = 0b0010,\n+        static RESTRICTION_NO_STRUCT_LITERAL = 0b0100\n     }\n }\n \n@@ -383,7 +383,7 @@ impl<'a> Parser<'a> {\n             buffer_start: 0,\n             buffer_end: 0,\n             tokens_consumed: 0,\n-            restrictions: Unrestricted,\n+            restrictions: UNRESTRICTED,\n             quote_depth: 0,\n             obsolete_set: HashSet::new(),\n             mod_path_stack: Vec::new(),\n@@ -2242,7 +2242,7 @@ impl<'a> Parser<'a> {\n                     if self.token == token::LBRACE {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n-                        if !self.restrictions.contains(RestrictionNoStructLiteral) {\n+                        if !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL) {\n                             // It's a struct literal.\n                             self.bump();\n                             let mut fields = Vec::new();\n@@ -2771,7 +2771,7 @@ impl<'a> Parser<'a> {\n         // Prevent dynamic borrow errors later on by limiting the\n         // scope of the borrows.\n         if self.token == token::BINOP(token::OR) &&\n-            self.restrictions.contains(RestrictionNoBarOp) {\n+            self.restrictions.contains(RESTRICTION_NO_BAR_OP) {\n             return lhs;\n         }\n \n@@ -2812,7 +2812,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_assign_expr(&mut self) -> P<Expr> {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n-        let restrictions = self.restrictions & RestrictionNoStructLiteral;\n+        let restrictions = self.restrictions & RESTRICTION_NO_STRUCT_LITERAL;\n         match self.token {\n           token::EQ => {\n               self.bump();\n@@ -2850,7 +2850,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_let_expr();\n         }\n         let lo = self.last_span.lo;\n-        let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let thn = self.parse_block();\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n@@ -2868,7 +2868,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let);\n         let pat = self.parse_pat();\n         self.expect(&token::EQ);\n-        let expr = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let thn = self.parse_block();\n         let (hi, els) = if self.eat_keyword(keywords::Else) {\n             let expr = self.parse_else_expr();\n@@ -2928,7 +2928,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let pat = self.parse_pat();\n         self.expect_keyword(keywords::In);\n-        let expr = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let loop_block = self.parse_block();\n         let hi = self.span.hi;\n \n@@ -2937,7 +2937,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident));\n@@ -2952,7 +2952,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_match_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let discriminant = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let discriminant = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         self.commit_expr_expecting(&*discriminant, token::LBRACE);\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::RBRACE {\n@@ -2971,7 +2971,7 @@ impl<'a> Parser<'a> {\n             guard = Some(self.parse_expr());\n         }\n         self.expect(&token::FAT_ARROW);\n-        let expr = self.parse_expr_res(RestrictionStmtExpr);\n+        let expr = self.parse_expr_res(RESTRICTION_STMT_EXPR);\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n@@ -2993,7 +2993,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr(&mut self) -> P<Expr> {\n-        return self.parse_expr_res(Unrestricted);\n+        return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     /// Parse an expression, subject to the given restrictions\n@@ -3290,9 +3290,9 @@ impl<'a> Parser<'a> {\n                     self.look_ahead(2, |t| {\n                         *t != token::COMMA && *t != token::RBRACKET\n                     }) {\n-                let start = self.parse_expr_res(RestrictionNoBarOp);\n+                let start = self.parse_expr_res(RESTRICTION_NO_BAR_OP);\n                 self.eat(&token::DOTDOTDOT);\n-                let end = self.parse_expr_res(RestrictionNoBarOp);\n+                let end = self.parse_expr_res(RESTRICTION_NO_BAR_OP);\n                 pat = PatRange(start, end);\n             } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {\n                 let id = self.parse_ident();\n@@ -3593,7 +3593,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     // Remainder are line-expr stmts.\n-                    let e = self.parse_expr_res(RestrictionStmtExpr);\n+                    let e = self.parse_expr_res(RESTRICTION_STMT_EXPR);\n                     P(spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID)))\n                 }\n             }\n@@ -3602,7 +3602,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restrictions.contains(RestrictionStmtExpr) &&\n+        self.restrictions.contains(RESTRICTION_STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}]}