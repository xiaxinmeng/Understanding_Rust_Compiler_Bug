{"sha": "31e4087b9098c6174a22b294bea960d54013fe22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZTQwODdiOTA5OGM2MTc0YTIyYjI5NGJlYTk2MGQ1NDAxM2ZlMjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-14T02:48:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-14T02:48:05Z"}, "message": "Auto merge of #77926 - Dylan-DPC:rollup-wttr8a1, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #77765 (Add LLVM flags to limit DWARF version to 2 on BSD)\n - #77788 (BTreeMap: fix gdb provider on BTreeMap with ZST keys or values)\n - #77795 (Codegen backend interface refactor)\n - #77808 (Moved the main `impl` for FnCtxt to its own file.)\n - #77817 (Switch rustdoc from `clean::Stability` to `rustc_attr::Stability`)\n - #77829 (bootstrap: only use compiler-builtins-c if they exist)\n - #77870 (Use intra-doc links for links to module-level docs)\n - #77897 (Move `Strip` into a separate rustdoc pass)\n\nFailed merges:\n\n - #77879 (Provide better documentation and help messages for x.py setup)\n - #77902 (Include aarch64-pc-windows-msvc in the dist manifests)\n\nr? `@ghost`", "tree": {"sha": "25be91294c8440c4c633661b4afde3a149a55fbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25be91294c8440c4c633661b4afde3a149a55fbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e4087b9098c6174a22b294bea960d54013fe22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e4087b9098c6174a22b294bea960d54013fe22", "html_url": "https://github.com/rust-lang/rust/commit/31e4087b9098c6174a22b294bea960d54013fe22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e4087b9098c6174a22b294bea960d54013fe22/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ba5068815137eef403383582d3f17f3b6802217", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba5068815137eef403383582d3f17f3b6802217", "html_url": "https://github.com/rust-lang/rust/commit/4ba5068815137eef403383582d3f17f3b6802217"}, {"sha": "54151a6afc1e3e5b7894da0635084ad35fc7d3c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/54151a6afc1e3e5b7894da0635084ad35fc7d3c2", "html_url": "https://github.com/rust-lang/rust/commit/54151a6afc1e3e5b7894da0635084ad35fc7d3c2"}], "stats": {"total": 7334, "additions": 3697, "deletions": 3637}, "files": [{"sha": "9c309345000bbe2b96f601b7b9e91c29df6f99a1", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -154,7 +154,7 @@ pub struct ConstStability {\n }\n \n /// The available stability levels.\n-#[derive(Encodable, Decodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n+#[derive(Encodable, Decodable, PartialEq, Copy, Clone, Debug, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub enum StabilityLevel {\n     // Reason for the current stability level and the relevant rust-lang issue"}, {"sha": "f1fa9864616a84079b2a1aac16bb7da3fdf6cae6", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -6,7 +6,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::query::Providers;\n@@ -367,23 +367,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    use rustc_codegen_ssa::target_features::{all_known_features, supported_target_features};\n-    providers.supported_target_features = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        if tcx.sess.opts.actually_rustdoc {\n-            // rustdoc needs to be able to document functions that use all the features, so\n-            // provide them all.\n-            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n-        } else {\n-            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n-        }\n-    };\n-\n-    provide_extern(providers);\n-}\n-\n-pub fn provide_extern(providers: &mut Providers) {\n+pub fn provide_both(providers: &mut Providers) {\n     providers.wasm_import_module_map = |tcx, cnum| {\n         // Build up a map from DefId to a `NativeLib` structure, where\n         // `NativeLib` internally contains information about"}, {"sha": "6516869e47b6f594496d17828abd72a44a389df6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -120,10 +120,8 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n         // for macOS to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n         // Android has the same issue (#22398)\n-        if cx.sess().target.target.options.is_like_osx\n-            || cx.sess().target.target.options.is_like_android\n-        {\n-            llvm::LLVMRustAddModuleFlag(cx.llmod, \"Dwarf Version\\0\".as_ptr().cast(), 2)\n+        if let Some(version) = cx.sess().target.target.options.dwarf_version {\n+            llvm::LLVMRustAddModuleFlag(cx.llmod, \"Dwarf Version\\0\".as_ptr().cast(), version)\n         }\n \n         // Indicate that we want CodeView debug information on MSVC"}, {"sha": "5974b59d39e4290c6ec4f27f79cd70bcee4c51ed", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 12, "deletions": 43, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -23,18 +23,17 @@ use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{ErrorReported, FatalError, Handler};\n-use rustc_middle::dep_graph::{DepGraph, WorkProduct};\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_serialize::json;\n-use rustc_session::config::{self, OptLevel, OutputFilenames, PrintRequest};\n+use rustc_session::config::{OptLevel, OutputFilenames, PrintRequest};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n \n use std::any::Any;\n use std::ffi::CStr;\n-use std::fs;\n use std::sync::Arc;\n \n mod back {\n@@ -252,11 +251,11 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn provide(&self, providers: &mut ty::query::Providers) {\n-        attributes::provide(providers);\n+        attributes::provide_both(providers);\n     }\n \n     fn provide_extern(&self, providers: &mut ty::query::Providers) {\n-        attributes::provide_extern(providers);\n+        attributes::provide_both(providers);\n     }\n \n     fn codegen_crate<'tcx>(\n@@ -277,47 +276,27 @@ impl CodegenBackend for LlvmCodegenBackend {\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n         sess: &Session,\n-        dep_graph: &DepGraph,\n-    ) -> Result<Box<dyn Any>, ErrorReported> {\n+    ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorReported> {\n         let (codegen_results, work_products) = ongoing_codegen\n             .downcast::<rustc_codegen_ssa::back::write::OngoingCodegen<LlvmCodegenBackend>>()\n             .expect(\"Expected LlvmCodegenBackend's OngoingCodegen, found Box<Any>\")\n             .join(sess);\n-        if sess.opts.debugging_opts.incremental_info {\n-            rustc_codegen_ssa::back::write::dump_incremental_data(&codegen_results);\n-        }\n \n-        sess.time(\"serialize_work_products\", move || {\n-            rustc_incremental::save_work_product_index(sess, &dep_graph, work_products)\n+        sess.time(\"llvm_dump_timing_file\", || {\n+            if sess.opts.debugging_opts.llvm_time_trace {\n+                llvm_util::time_trace_profiler_finish(\"llvm_timings.json\");\n+            }\n         });\n \n-        sess.compile_status()?;\n-\n-        Ok(Box::new(codegen_results))\n+        Ok((codegen_results, work_products))\n     }\n \n     fn link(\n         &self,\n         sess: &Session,\n-        codegen_results: Box<dyn Any>,\n+        codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported> {\n-        let codegen_results = codegen_results\n-            .downcast::<CodegenResults>()\n-            .expect(\"Expected CodegenResults, found Box<Any>\");\n-\n-        if sess.opts.debugging_opts.no_link {\n-            // FIXME: use a binary format to encode the `.rlink` file\n-            let rlink_data = json::encode(&codegen_results).map_err(|err| {\n-                sess.fatal(&format!(\"failed to encode rlink: {}\", err));\n-            })?;\n-            let rlink_file = outputs.with_extension(config::RLINK_EXT);\n-            fs::write(&rlink_file, rlink_data).map_err(|err| {\n-                sess.fatal(&format!(\"failed to write file {}: {}\", rlink_file.display(), err));\n-            })?;\n-            return Ok(());\n-        }\n-\n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n         sess.time(\"link_crate\", || {\n@@ -334,16 +313,6 @@ impl CodegenBackend for LlvmCodegenBackend {\n             );\n         });\n \n-        // Now that we won't touch anything in the incremental compilation directory\n-        // any more, we can finalize it (which involves renaming it)\n-        rustc_incremental::finalize_session_directory(sess, codegen_results.crate_hash);\n-\n-        sess.time(\"llvm_dump_timing_file\", || {\n-            if sess.opts.debugging_opts.llvm_time_trace {\n-                llvm_util::time_trace_profiler_finish(\"llvm_timings.json\");\n-            }\n-        });\n-\n         Ok(())\n     }\n }"}, {"sha": "3a7676d30bba007e66b0bd75a0addd1d34821e35", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -13,7 +13,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n-use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n use rustc_errors::{DiagnosticId, FatalError, Handler, Level};\n@@ -414,7 +413,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let no_builtins = tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n     let is_compiler_builtins =\n         tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n@@ -463,7 +461,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     OngoingCodegen {\n         backend,\n         crate_name,\n-        crate_hash,\n         metadata,\n         windows_subsystem,\n         linker_info,\n@@ -658,15 +655,6 @@ fn produce_final_output_artifacts(\n     // These are used in linking steps and will be cleaned up afterward.\n }\n \n-pub fn dump_incremental_data(_codegen_results: &CodegenResults) {\n-    // FIXME(mw): This does not work at the moment because the situation has\n-    //            become more complicated due to incremental LTO. Now a CGU\n-    //            can have more than two caching states.\n-    // println!(\"[incremental] Re-using {} out of {} modules\",\n-    //           codegen_results.modules.iter().filter(|m| m.pre_existing).count(),\n-    //           codegen_results.modules.len());\n-}\n-\n pub enum WorkItem<B: WriteBackendMethods> {\n     /// Optimize a newly codegened, totally unoptimized module.\n     Optimize(ModuleCodegen<B::Module>),\n@@ -1720,7 +1708,6 @@ impl SharedEmitterMain {\n pub struct OngoingCodegen<B: ExtraBackendMethods> {\n     pub backend: B,\n     pub crate_name: Symbol,\n-    pub crate_hash: Svh,\n     pub metadata: EncodedMetadata,\n     pub windows_subsystem: Option<String>,\n     pub linker_info: LinkerInfo,\n@@ -1766,7 +1753,6 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         (\n             CodegenResults {\n                 crate_name: self.crate_name,\n-                crate_hash: self.crate_hash,\n                 metadata: self.metadata,\n                 windows_subsystem: self.windows_subsystem,\n                 linker_info: self.linker_info,"}, {"sha": "70b92b234e94c10803ab30e6514348481197d53d", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -21,7 +21,6 @@ extern crate tracing;\n extern crate rustc_middle;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::LangItem;\n@@ -134,7 +133,6 @@ pub struct CodegenResults {\n     pub modules: Vec<CompiledModule>,\n     pub allocator_module: Option<CompiledModule>,\n     pub metadata_module: Option<CompiledModule>,\n-    pub crate_hash: Svh,\n     pub metadata: rustc_middle::middle::cstore::EncodedMetadata,\n     pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo,\n@@ -144,6 +142,7 @@ pub struct CodegenResults {\n pub fn provide(providers: &mut Providers) {\n     crate::back::symbol_export::provide(providers);\n     crate::base::provide_both(providers);\n+    crate::target_features::provide(providers);\n }\n \n pub fn provide_extern(providers: &mut Providers) {"}, {"sha": "24cd27cf3cf89198a6f8bbd95312c6ae85392772", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -1,3 +1,5 @@\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::ty::query::Providers;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n@@ -148,3 +150,16 @@ pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Opt\n         _ => &[],\n     }\n }\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    providers.supported_target_features = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        if tcx.sess.opts.actually_rustdoc {\n+            // rustdoc needs to be able to document functions that use all the features, so\n+            // whitelist them all\n+            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n+        } else {\n+            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n+        }\n+    };\n+}"}, {"sha": "3fb189e19844deb826543d23def23cd0c57e7101", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -1,10 +1,11 @@\n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n-use crate::ModuleCodegen;\n+use crate::{CodegenResults, ModuleCodegen};\n \n use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::ErrorReported;\n-use rustc_middle::dep_graph::DepGraph;\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::query::Providers;\n@@ -80,8 +81,7 @@ pub trait CodegenBackend {\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n         sess: &Session,\n-        dep_graph: &DepGraph,\n-    ) -> Result<Box<dyn Any>, ErrorReported>;\n+    ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorReported>;\n \n     /// This is called on the returned `Box<dyn Any>` from `join_codegen`\n     ///\n@@ -91,7 +91,7 @@ pub trait CodegenBackend {\n     fn link(\n         &self,\n         sess: &Session,\n-        codegen_results: Box<dyn Any>,\n+        codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported>;\n }"}, {"sha": "c7fb6a55d5ae04bdc7e4a057fa6de66a2ecc977a", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -642,7 +642,7 @@ impl RustcDefaultCalls {\n             let codegen_results: CodegenResults = json::decode(&rlink_data).unwrap_or_else(|err| {\n                 sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n             });\n-            compiler.codegen_backend().link(&sess, Box::new(codegen_results), &outputs)\n+            compiler.codegen_backend().link(&sess, codegen_results, &outputs)\n         } else {\n             sess.fatal(\"rlink must be a file\")\n         }"}, {"sha": "1de7350a3e21c5d333320954f26871221f04ca2d", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -3,6 +3,7 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -13,7 +14,8 @@ use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::steal::Steal;\n use rustc_middle::ty::{GlobalCtxt, ResolverOutputs, TyCtxt};\n-use rustc_session::config::{OutputFilenames, OutputType};\n+use rustc_serialize::json;\n+use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n use std::any::Any;\n@@ -331,6 +333,7 @@ impl<'tcx> Queries<'tcx> {\n     pub fn linker(&'tcx self) -> Result<Linker> {\n         let dep_graph = self.dep_graph()?;\n         let prepare_outputs = self.prepare_outputs()?;\n+        let crate_hash = self.global_ctxt()?.peek_mut().enter(|tcx| tcx.crate_hash(LOCAL_CRATE));\n         let ongoing_codegen = self.ongoing_codegen()?;\n \n         let sess = self.session().clone();\n@@ -340,6 +343,7 @@ impl<'tcx> Queries<'tcx> {\n             sess,\n             dep_graph: dep_graph.peek().clone(),\n             prepare_outputs: prepare_outputs.take(),\n+            crate_hash,\n             ongoing_codegen: ongoing_codegen.take(),\n             codegen_backend,\n         })\n@@ -350,18 +354,31 @@ pub struct Linker {\n     sess: Lrc<Session>,\n     dep_graph: DepGraph,\n     prepare_outputs: OutputFilenames,\n+    crate_hash: Svh,\n     ongoing_codegen: Box<dyn Any>,\n     codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n }\n \n impl Linker {\n     pub fn link(self) -> Result<()> {\n-        let codegen_results =\n-            self.codegen_backend.join_codegen(self.ongoing_codegen, &self.sess, &self.dep_graph)?;\n-        let prof = self.sess.prof.clone();\n+        let (codegen_results, work_products) =\n+            self.codegen_backend.join_codegen(self.ongoing_codegen, &self.sess)?;\n+\n+        self.sess.compile_status()?;\n+\n+        let sess = &self.sess;\n         let dep_graph = self.dep_graph;\n+        sess.time(\"serialize_work_products\", || {\n+            rustc_incremental::save_work_product_index(&sess, &dep_graph, work_products)\n+        });\n+\n+        let prof = self.sess.prof.clone();\n         prof.generic_activity(\"drop_dep_graph\").run(move || drop(dep_graph));\n \n+        // Now that we won't touch anything in the incremental compilation directory\n+        // any more, we can finalize it (which involves renaming it)\n+        rustc_incremental::finalize_session_directory(&self.sess, self.crate_hash);\n+\n         if !self\n             .sess\n             .opts\n@@ -371,6 +388,19 @@ impl Linker {\n         {\n             return Ok(());\n         }\n+\n+        if sess.opts.debugging_opts.no_link {\n+            // FIXME: use a binary format to encode the `.rlink` file\n+            let rlink_data = json::encode(&codegen_results).map_err(|err| {\n+                sess.fatal(&format!(\"failed to encode rlink: {}\", err));\n+            })?;\n+            let rlink_file = self.prepare_outputs.with_extension(config::RLINK_EXT);\n+            std::fs::write(&rlink_file, rlink_data).map_err(|err| {\n+                sess.fatal(&format!(\"failed to write file {}: {}\", rlink_file.display(), err));\n+            })?;\n+            return Ok(());\n+        }\n+\n         self.codegen_backend.link(&self.sess, codegen_results, &self.prepare_outputs)\n     }\n }"}, {"sha": "0824bc3035828b048b1220a97c9016119350376b", "filename": "compiler/rustc_target/src/spec/android_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -9,6 +9,7 @@ pub fn opts() -> TargetOptions {\n         .unwrap()\n         .push(\"-Wl,--allow-multiple-definition\".to_string());\n     base.is_like_android = true;\n+    base.dwarf_version = Some(2);\n     base.position_independent_executables = true;\n     base.has_elf_tls = false;\n     base.requires_uwtable = true;"}, {"sha": "2e3c835c0e5ec28054d87012e216218136631f2d", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -23,6 +23,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         target_family: Some(\"unix\".to_string()),\n         is_like_osx: true,\n+        dwarf_version: Some(2),\n         has_rpath: true,\n         dll_prefix: \"lib\".to_string(),\n         dll_suffix: \".dylib\".to_string(),"}, {"sha": "82dc5f5465921e981b41d7e717928ada25078584", "filename": "compiler/rustc_target/src/spec/dragonfly_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -24,6 +24,7 @@ pub fn opts() -> TargetOptions {\n         pre_link_args: args,\n         position_independent_executables: true,\n         relro_level: RelroLevel::Full,\n+        dwarf_version: Some(2),\n         ..Default::default()\n     }\n }"}, {"sha": "051325a8df6878f2e1972ed53063c05db9618f46", "filename": "compiler/rustc_target/src/spec/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -26,6 +26,7 @@ pub fn opts() -> TargetOptions {\n         eliminate_frame_pointer: false, // FIXME 43575\n         relro_level: RelroLevel::Full,\n         abi_return_struct_as_int: true,\n+        dwarf_version: Some(2),\n         ..Default::default()\n     }\n }"}, {"sha": "6f400854ec6808ec69edfd494bed942191dda6a6", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -816,6 +816,9 @@ pub struct TargetOptions {\n     pub is_like_emscripten: bool,\n     /// Whether the target toolchain is like Fuchsia's.\n     pub is_like_fuchsia: bool,\n+    /// Version of DWARF to use if not using the default.\n+    /// Useful because some platforms (osx, bsd) only want up to DWARF2.\n+    pub dwarf_version: Option<u32>,\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n     pub linker_is_gnu: bool,\n     /// The MinGW toolchain has a known issue that prevents it from correctly\n@@ -1012,6 +1015,7 @@ impl Default for TargetOptions {\n             is_like_emscripten: false,\n             is_like_msvc: false,\n             is_like_fuchsia: false,\n+            dwarf_version: None,\n             linker_is_gnu: false,\n             allows_weak_linkage: true,\n             has_rpath: false,\n@@ -1165,6 +1169,15 @@ impl Target {\n                     base.options.$key_name = s;\n                 }\n             } );\n+            ($key_name:ident, Option<u32>) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                if let Some(s) = obj.find(&name).and_then(Json::as_u64) {\n+                    if s < 1 || s > 5 {\n+                        return Err(\"Not a valid DWARF version number\".to_string());\n+                    }\n+                    base.options.$key_name = Some(s as u32);\n+                }\n+            } );\n             ($key_name:ident, Option<u64>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 if let Some(s) = obj.find(&name).and_then(Json::as_u64) {\n@@ -1417,6 +1430,7 @@ impl Target {\n         key!(is_like_emscripten, bool);\n         key!(is_like_android, bool);\n         key!(is_like_fuchsia, bool);\n+        key!(dwarf_version, Option<u32>);\n         key!(linker_is_gnu, bool);\n         key!(allows_weak_linkage, bool);\n         key!(has_rpath, bool);\n@@ -1654,6 +1668,7 @@ impl ToJson for Target {\n         target_option_val!(is_like_emscripten);\n         target_option_val!(is_like_android);\n         target_option_val!(is_like_fuchsia);\n+        target_option_val!(dwarf_version);\n         target_option_val!(linker_is_gnu);\n         target_option_val!(allows_weak_linkage);\n         target_option_val!(has_rpath);"}, {"sha": "d7baf81fce36caa6265a356540d98de7189722b0", "filename": "compiler/rustc_target/src/spec/netbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -24,6 +24,7 @@ pub fn opts() -> TargetOptions {\n         position_independent_executables: true,\n         relro_level: RelroLevel::Full,\n         use_ctors_section: true,\n+        dwarf_version: Some(2),\n         ..Default::default()\n     }\n }"}, {"sha": "92a382e826b999088941156c3202b8a6659d7a07", "filename": "compiler/rustc_target/src/spec/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -26,6 +26,7 @@ pub fn opts() -> TargetOptions {\n         position_independent_executables: true,\n         eliminate_frame_pointer: false, // FIXME 43575\n         relro_level: RelroLevel::Full,\n+        dwarf_version: Some(2),\n         ..Default::default()\n     }\n }"}, {"sha": "79d6c7dbfdae264e980b88b96c498bb6fb5e4ddf", "filename": "compiler/rustc_typeck/src/check/fn_ctxt.rs", "status": "removed", "additions": 0, "deletions": 3200, "changes": 3200, "blob_url": "https://github.com/rust-lang/rust/blob/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba5068815137eef403383582d3f17f3b6802217/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs?ref=4ba5068815137eef403383582d3f17f3b6802217"}, {"sha": "017b0abd1d607533be4475d7003e75172e2ce383", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "added", "additions": 1469, "deletions": 0, "changes": 1469, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -0,0 +1,1469 @@\n+use crate::astconv::{\n+    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, PathSeg,\n+};\n+use crate::check::callee::{self, DeferredCallResolution};\n+use crate::check::method::{self, MethodCallee, SelfSource};\n+use crate::check::{BreakableCtxt, Diverges, Expectation, FallbackMode, FnCtxt, LocalTy};\n+\n+use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorReported};\n+use rustc_hir as hir;\n+use rustc_hir::def::{CtorOf, DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n+use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n+use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n+use rustc_infer::infer::{InferOk, InferResult};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::subst::{\n+    self, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSelfTy, UserSubsts,\n+};\n+use rustc_middle::ty::{\n+    self, AdtKind, CanonicalUserType, DefIdTree, GenericParamDefKind, ToPolyTraitRef, ToPredicate,\n+    Ty, UserType,\n+};\n+use rustc_session::lint;\n+use rustc_span::hygiene::DesugaringKind;\n+use rustc_span::source_map::{original_sp, DUMMY_SP};\n+use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::{self, BytePos, MultiSpan, Span};\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, TraitEngine, TraitEngineExt};\n+\n+use std::collections::hash_map::Entry;\n+use std::slice;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Produces warning on the given node, if the current point in the\n+    /// function is unreachable, and there hasn't been another warning.\n+    pub(in super::super) fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n+        // FIXME: Combine these two 'if' expressions into one once\n+        // let chains are implemented\n+        if let Diverges::Always { span: orig_span, custom_note } = self.diverges.get() {\n+            // If span arose from a desugaring of `if` or `while`, then it is the condition itself,\n+            // which diverges, that we are about to lint on. This gives suboptimal diagnostics.\n+            // Instead, stop here so that the `if`- or `while`-expression's block is linted instead.\n+            if !span.is_desugaring(DesugaringKind::CondTemporary)\n+                && !span.is_desugaring(DesugaringKind::Async)\n+                && !orig_span.is_desugaring(DesugaringKind::Await)\n+            {\n+                self.diverges.set(Diverges::WarnedAlways);\n+\n+                debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n+\n+                self.tcx().struct_span_lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, |lint| {\n+                    let msg = format!(\"unreachable {}\", kind);\n+                    lint.build(&msg)\n+                        .span_label(span, &msg)\n+                        .span_label(\n+                            orig_span,\n+                            custom_note\n+                                .unwrap_or(\"any code following this expression is unreachable\"),\n+                        )\n+                        .emit();\n+                })\n+            }\n+        }\n+    }\n+\n+    /// Resolves type and const variables in `ty` if possible. Unlike the infcx\n+    /// version (resolve_vars_if_possible), this version will\n+    /// also select obligations if it seems useful, in an effort\n+    /// to get more type information.\n+    pub(in super::super) fn resolve_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        debug!(\"resolve_vars_with_obligations(ty={:?})\", ty);\n+\n+        // No Infer()? Nothing needs doing.\n+        if !ty.has_infer_types_or_consts() {\n+            debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n+            return ty;\n+        }\n+\n+        // If `ty` is a type variable, see whether we already know what it is.\n+        ty = self.resolve_vars_if_possible(&ty);\n+        if !ty.has_infer_types_or_consts() {\n+            debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n+            return ty;\n+        }\n+\n+        // If not, try resolving pending obligations as much as\n+        // possible. This can help substantially when there are\n+        // indirect dependencies that don't seem worth tracking\n+        // precisely.\n+        self.select_obligations_where_possible(false, |_| {});\n+        ty = self.resolve_vars_if_possible(&ty);\n+\n+        debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n+        ty\n+    }\n+\n+    pub(in super::super) fn record_deferred_call_resolution(\n+        &self,\n+        closure_def_id: DefId,\n+        r: DeferredCallResolution<'tcx>,\n+    ) {\n+        let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n+        deferred_call_resolutions.entry(closure_def_id).or_default().push(r);\n+    }\n+\n+    pub(in super::super) fn remove_deferred_call_resolutions(\n+        &self,\n+        closure_def_id: DefId,\n+    ) -> Vec<DeferredCallResolution<'tcx>> {\n+        let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n+        deferred_call_resolutions.remove(&closure_def_id).unwrap_or(vec![])\n+    }\n+\n+    pub fn tag(&self) -> String {\n+        format!(\"{:p}\", self)\n+    }\n+\n+    pub fn local_ty(&self, span: Span, nid: hir::HirId) -> LocalTy<'tcx> {\n+        self.locals.borrow().get(&nid).cloned().unwrap_or_else(|| {\n+            span_bug!(span, \"no type for local variable {}\", self.tcx.hir().node_to_string(nid))\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n+        debug!(\n+            \"write_ty({:?}, {:?}) in fcx {}\",\n+            id,\n+            self.resolve_vars_if_possible(&ty),\n+            self.tag()\n+        );\n+        self.typeck_results.borrow_mut().node_types_mut().insert(id, ty);\n+\n+        if ty.references_error() {\n+            self.has_errors.set(true);\n+            self.set_tainted_by_errors();\n+        }\n+    }\n+\n+    pub fn write_field_index(&self, hir_id: hir::HirId, index: usize) {\n+        self.typeck_results.borrow_mut().field_indices_mut().insert(hir_id, index);\n+    }\n+\n+    pub(in super::super) fn write_resolution(\n+        &self,\n+        hir_id: hir::HirId,\n+        r: Result<(DefKind, DefId), ErrorReported>,\n+    ) {\n+        self.typeck_results.borrow_mut().type_dependent_defs_mut().insert(hir_id, r);\n+    }\n+\n+    pub fn write_method_call(&self, hir_id: hir::HirId, method: MethodCallee<'tcx>) {\n+        debug!(\"write_method_call(hir_id={:?}, method={:?})\", hir_id, method);\n+        self.write_resolution(hir_id, Ok((DefKind::AssocFn, method.def_id)));\n+        self.write_substs(hir_id, method.substs);\n+\n+        // When the method is confirmed, the `method.substs` includes\n+        // parameters from not just the method, but also the impl of\n+        // the method -- in particular, the `Self` type will be fully\n+        // resolved. However, those are not something that the \"user\n+        // specified\" -- i.e., those types come from the inferred type\n+        // of the receiver, not something the user wrote. So when we\n+        // create the user-substs, we want to replace those earlier\n+        // types with just the types that the user actually wrote --\n+        // that is, those that appear on the *method itself*.\n+        //\n+        // As an example, if the user wrote something like\n+        // `foo.bar::<u32>(...)` -- the `Self` type here will be the\n+        // type of `foo` (possibly adjusted), but we don't want to\n+        // include that. We want just the `[_, u32]` part.\n+        if !method.substs.is_noop() {\n+            let method_generics = self.tcx.generics_of(method.def_id);\n+            if !method_generics.params.is_empty() {\n+                let user_type_annotation = self.infcx.probe(|_| {\n+                    let user_substs = UserSubsts {\n+                        substs: InternalSubsts::for_item(self.tcx, method.def_id, |param, _| {\n+                            let i = param.index as usize;\n+                            if i < method_generics.parent_count {\n+                                self.infcx.var_for_def(DUMMY_SP, param)\n+                            } else {\n+                                method.substs[i]\n+                            }\n+                        }),\n+                        user_self_ty: None, // not relevant here\n+                    };\n+\n+                    self.infcx.canonicalize_user_type_annotation(&UserType::TypeOf(\n+                        method.def_id,\n+                        user_substs,\n+                    ))\n+                });\n+\n+                debug!(\"write_method_call: user_type_annotation={:?}\", user_type_annotation);\n+                self.write_user_type_annotation(hir_id, user_type_annotation);\n+            }\n+        }\n+    }\n+\n+    pub fn write_substs(&self, node_id: hir::HirId, substs: SubstsRef<'tcx>) {\n+        if !substs.is_noop() {\n+            debug!(\"write_substs({:?}, {:?}) in fcx {}\", node_id, substs, self.tag());\n+\n+            self.typeck_results.borrow_mut().node_substs_mut().insert(node_id, substs);\n+        }\n+    }\n+\n+    /// Given the substs that we just converted from the HIR, try to\n+    /// canonicalize them and store them as user-given substitutions\n+    /// (i.e., substitutions that must be respected by the NLL check).\n+    ///\n+    /// This should be invoked **before any unifications have\n+    /// occurred**, so that annotations like `Vec<_>` are preserved\n+    /// properly.\n+    pub fn write_user_type_annotation_from_substs(\n+        &self,\n+        hir_id: hir::HirId,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+        user_self_ty: Option<UserSelfTy<'tcx>>,\n+    ) {\n+        debug!(\n+            \"write_user_type_annotation_from_substs: hir_id={:?} def_id={:?} substs={:?} \\\n+             user_self_ty={:?} in fcx {}\",\n+            hir_id,\n+            def_id,\n+            substs,\n+            user_self_ty,\n+            self.tag(),\n+        );\n+\n+        if Self::can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n+            let canonicalized = self.infcx.canonicalize_user_type_annotation(&UserType::TypeOf(\n+                def_id,\n+                UserSubsts { substs, user_self_ty },\n+            ));\n+            debug!(\"write_user_type_annotation_from_substs: canonicalized={:?}\", canonicalized);\n+            self.write_user_type_annotation(hir_id, canonicalized);\n+        }\n+    }\n+\n+    pub fn write_user_type_annotation(\n+        &self,\n+        hir_id: hir::HirId,\n+        canonical_user_type_annotation: CanonicalUserType<'tcx>,\n+    ) {\n+        debug!(\n+            \"write_user_type_annotation: hir_id={:?} canonical_user_type_annotation={:?} tag={}\",\n+            hir_id,\n+            canonical_user_type_annotation,\n+            self.tag(),\n+        );\n+\n+        if !canonical_user_type_annotation.is_identity() {\n+            self.typeck_results\n+                .borrow_mut()\n+                .user_provided_types_mut()\n+                .insert(hir_id, canonical_user_type_annotation);\n+        } else {\n+            debug!(\"write_user_type_annotation: skipping identity substs\");\n+        }\n+    }\n+\n+    pub fn apply_adjustments(&self, expr: &hir::Expr<'_>, adj: Vec<Adjustment<'tcx>>) {\n+        debug!(\"apply_adjustments(expr={:?}, adj={:?})\", expr, adj);\n+\n+        if adj.is_empty() {\n+            return;\n+        }\n+\n+        let autoborrow_mut = adj.iter().any(|adj| {\n+            matches!(adj, &Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(_, AutoBorrowMutability::Mut { .. })),\n+                ..\n+            })\n+        });\n+\n+        match self.typeck_results.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n+            Entry::Vacant(entry) => {\n+                entry.insert(adj);\n+            }\n+            Entry::Occupied(mut entry) => {\n+                debug!(\" - composing on top of {:?}\", entry.get());\n+                match (&entry.get()[..], &adj[..]) {\n+                    // Applying any adjustment on top of a NeverToAny\n+                    // is a valid NeverToAny adjustment, because it can't\n+                    // be reached.\n+                    (&[Adjustment { kind: Adjust::NeverToAny, .. }], _) => return,\n+                    (&[\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. },\n+                    ], &[\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        .. // Any following adjustments are allowed.\n+                    ]) => {\n+                        // A reborrow has no effect before a dereference.\n+                    }\n+                    // FIXME: currently we never try to compose autoderefs\n+                    // and ReifyFnPointer/UnsafeFnPointer, but we could.\n+                    _ =>\n+                        bug!(\"while adjusting {:?}, can't compose {:?} and {:?}\",\n+                             expr, entry.get(), adj)\n+                };\n+                *entry.get_mut() = adj;\n+            }\n+        }\n+\n+        // If there is an mutable auto-borrow, it is equivalent to `&mut <expr>`.\n+        // In this case implicit use of `Deref` and `Index` within `<expr>` should\n+        // instead be `DerefMut` and `IndexMut`, so fix those up.\n+        if autoborrow_mut {\n+            self.convert_place_derefs_to_mutable(expr);\n+        }\n+    }\n+\n+    /// Basically whenever we are converting from a type scheme into\n+    /// the fn body space, we always want to normalize associated\n+    /// types as well. This function combines the two.\n+    fn instantiate_type_scheme<T>(&self, span: Span, substs: SubstsRef<'tcx>, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let value = value.subst(self.tcx, substs);\n+        let result = self.normalize_associated_types_in(span, &value);\n+        debug!(\"instantiate_type_scheme(value={:?}, substs={:?}) = {:?}\", value, substs, result);\n+        result\n+    }\n+\n+    /// As `instantiate_type_scheme`, but for the bounds found in a\n+    /// generic type scheme.\n+    pub(in super::super) fn instantiate_bounds(\n+        &self,\n+        span: Span,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> (ty::InstantiatedPredicates<'tcx>, Vec<Span>) {\n+        let bounds = self.tcx.predicates_of(def_id);\n+        let spans: Vec<Span> = bounds.predicates.iter().map(|(_, span)| *span).collect();\n+        let result = bounds.instantiate(self.tcx, substs);\n+        let result = self.normalize_associated_types_in(span, &result);\n+        debug!(\n+            \"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}, {:?}\",\n+            bounds, substs, result, spans,\n+        );\n+        (result, spans)\n+    }\n+\n+    /// Replaces the opaque types from the given value with type variables,\n+    /// and records the `OpaqueTypeMap` for later use during writeback. See\n+    /// `InferCtxt::instantiate_opaque_types` for more details.\n+    pub(in super::super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n+        &self,\n+        parent_id: hir::HirId,\n+        value: &T,\n+        value_span: Span,\n+    ) -> T {\n+        let parent_def_id = self.tcx.hir().local_def_id(parent_id);\n+        debug!(\n+            \"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n+            parent_def_id, value\n+        );\n+\n+        let (value, opaque_type_map) =\n+            self.register_infer_ok_obligations(self.instantiate_opaque_types(\n+                parent_def_id,\n+                self.body_id,\n+                self.param_env,\n+                value,\n+                value_span,\n+            ));\n+\n+        let mut opaque_types = self.opaque_types.borrow_mut();\n+        let mut opaque_types_vars = self.opaque_types_vars.borrow_mut();\n+        for (ty, decl) in opaque_type_map {\n+            let _ = opaque_types.insert(ty, decl);\n+            let _ = opaque_types_vars.insert(decl.concrete_ty, decl.opaque_type);\n+        }\n+\n+        value\n+    }\n+\n+    pub(in super::super) fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.inh.normalize_associated_types_in(span, self.body_id, self.param_env, value)\n+    }\n+\n+    pub(in super::super) fn normalize_associated_types_in_as_infer_ok<T>(\n+        &self,\n+        span: Span,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.inh.partially_normalize_associated_types_in(span, self.body_id, self.param_env, value)\n+    }\n+\n+    pub fn require_type_meets(\n+        &self,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        code: traits::ObligationCauseCode<'tcx>,\n+        def_id: DefId,\n+    ) {\n+        self.register_bound(ty, def_id, traits::ObligationCause::new(span, self.body_id, code));\n+    }\n+\n+    pub fn require_type_is_sized(\n+        &self,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        code: traits::ObligationCauseCode<'tcx>,\n+    ) {\n+        if !ty.references_error() {\n+            let lang_item = self.tcx.require_lang_item(LangItem::Sized, None);\n+            self.require_type_meets(ty, span, code, lang_item);\n+        }\n+    }\n+\n+    pub fn require_type_is_sized_deferred(\n+        &self,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        code: traits::ObligationCauseCode<'tcx>,\n+    ) {\n+        if !ty.references_error() {\n+            self.deferred_sized_obligations.borrow_mut().push((ty, span, code));\n+        }\n+    }\n+\n+    pub fn register_bound(\n+        &self,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        cause: traits::ObligationCause<'tcx>,\n+    ) {\n+        if !ty.references_error() {\n+            self.fulfillment_cx.borrow_mut().register_bound(\n+                self,\n+                self.param_env,\n+                ty,\n+                def_id,\n+                cause,\n+            );\n+        }\n+    }\n+\n+    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> Ty<'tcx> {\n+        let t = AstConv::ast_ty_to_ty(self, ast_t);\n+        self.register_wf_obligation(t.into(), ast_t.span, traits::MiscObligation);\n+        t\n+    }\n+\n+    pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n+        let ty = self.to_ty(ast_ty);\n+        debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n+\n+        if Self::can_contain_user_lifetime_bounds(ty) {\n+            let c_ty = self.infcx.canonicalize_response(&UserType::Ty(ty));\n+            debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n+            self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n+        }\n+\n+        ty\n+    }\n+\n+    pub fn to_const(&self, ast_c: &hir::AnonConst) -> &'tcx ty::Const<'tcx> {\n+        let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id);\n+        let c = ty::Const::from_anon_const(self.tcx, const_def_id);\n+        self.register_wf_obligation(\n+            c.into(),\n+            self.tcx.hir().span(ast_c.hir_id),\n+            ObligationCauseCode::MiscObligation,\n+        );\n+        c\n+    }\n+\n+    pub fn const_arg_to_const(\n+        &self,\n+        ast_c: &hir::AnonConst,\n+        param_def_id: DefId,\n+    ) -> &'tcx ty::Const<'tcx> {\n+        let const_def = ty::WithOptConstParam {\n+            did: self.tcx.hir().local_def_id(ast_c.hir_id),\n+            const_param_did: Some(param_def_id),\n+        };\n+        let c = ty::Const::from_opt_const_arg_anon_const(self.tcx, const_def);\n+        self.register_wf_obligation(\n+            c.into(),\n+            self.tcx.hir().span(ast_c.hir_id),\n+            ObligationCauseCode::MiscObligation,\n+        );\n+        c\n+    }\n+\n+    // If the type given by the user has free regions, save it for later, since\n+    // NLL would like to enforce those. Also pass in types that involve\n+    // projections, since those can resolve to `'static` bounds (modulo #54940,\n+    // which hopefully will be fixed by the time you see this comment, dear\n+    // reader, although I have my doubts). Also pass in types with inference\n+    // types, because they may be repeated. Other sorts of things are already\n+    // sufficiently enforced with erased regions. =)\n+    fn can_contain_user_lifetime_bounds<T>(t: T) -> bool\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        t.has_free_regions() || t.has_projections() || t.has_infer_types()\n+    }\n+\n+    pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n+        match self.typeck_results.borrow().node_types().get(id) {\n+            Some(&t) => t,\n+            None if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            None => {\n+                bug!(\n+                    \"no type for node {}: {} in fcx {}\",\n+                    id,\n+                    self.tcx.hir().node_to_string(id),\n+                    self.tag()\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Registers an obligation for checking later, during regionck, that `arg` is well-formed.\n+    pub fn register_wf_obligation(\n+        &self,\n+        arg: subst::GenericArg<'tcx>,\n+        span: Span,\n+        code: traits::ObligationCauseCode<'tcx>,\n+    ) {\n+        // WF obligations never themselves fail, so no real need to give a detailed cause:\n+        let cause = traits::ObligationCause::new(span, self.body_id, code);\n+        self.register_predicate(traits::Obligation::new(\n+            cause,\n+            self.param_env,\n+            ty::PredicateAtom::WellFormed(arg).to_predicate(self.tcx),\n+        ));\n+    }\n+\n+    /// Registers obligations that all `substs` are well-formed.\n+    pub fn add_wf_bounds(&self, substs: SubstsRef<'tcx>, expr: &hir::Expr<'_>) {\n+        for arg in substs.iter().filter(|arg| {\n+            matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n+        }) {\n+            self.register_wf_obligation(arg, expr.span, traits::MiscObligation);\n+        }\n+    }\n+\n+    /// Given a fully substituted set of bounds (`generic_bounds`), and the values with which each\n+    /// type/region parameter was instantiated (`substs`), creates and registers suitable\n+    /// trait/region obligations.\n+    ///\n+    /// For example, if there is a function:\n+    ///\n+    /// ```\n+    /// fn foo<'a,T:'a>(...)\n+    /// ```\n+    ///\n+    /// and a reference:\n+    ///\n+    /// ```\n+    /// let f = foo;\n+    /// ```\n+    ///\n+    /// Then we will create a fresh region variable `'$0` and a fresh type variable `$1` for `'a`\n+    /// and `T`. This routine will add a region obligation `$1:'$0` and register it locally.\n+    pub fn add_obligations_for_parameters(\n+        &self,\n+        cause: traits::ObligationCause<'tcx>,\n+        predicates: ty::InstantiatedPredicates<'tcx>,\n+    ) {\n+        assert!(!predicates.has_escaping_bound_vars());\n+\n+        debug!(\"add_obligations_for_parameters(predicates={:?})\", predicates);\n+\n+        for obligation in traits::predicates_for_generics(cause, self.param_env, predicates) {\n+            self.register_predicate(obligation);\n+        }\n+    }\n+\n+    // FIXME(arielb1): use this instead of field.ty everywhere\n+    // Only for fields! Returns <none> for methods>\n+    // Indifferent to privacy flags\n+    pub fn field_ty(\n+        &self,\n+        span: Span,\n+        field: &'tcx ty::FieldDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Ty<'tcx> {\n+        self.normalize_associated_types_in(span, &field.ty(self.tcx, substs))\n+    }\n+\n+    pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n+        let mut generators = self.deferred_generator_interiors.borrow_mut();\n+        for (body_id, interior, kind) in generators.drain(..) {\n+            self.select_obligations_where_possible(false, |_| {});\n+            crate::check::generator_interior::resolve_interior(\n+                self, def_id, body_id, interior, kind,\n+            );\n+        }\n+    }\n+\n+    // Tries to apply a fallback to `ty` if it is an unsolved variable.\n+    //\n+    // - Unconstrained ints are replaced with `i32`.\n+    //\n+    // - Unconstrained floats are replaced with with `f64`.\n+    //\n+    // - Non-numerics get replaced with `!` when `#![feature(never_type_fallback)]`\n+    //   is enabled. Otherwise, they are replaced with `()`.\n+    //\n+    // Fallback becomes very dubious if we have encountered type-checking errors.\n+    // In that case, fallback to Error.\n+    // The return value indicates whether fallback has occurred.\n+    pub(in super::super) fn fallback_if_possible(&self, ty: Ty<'tcx>, mode: FallbackMode) -> bool {\n+        use rustc_middle::ty::error::UnconstrainedNumeric::Neither;\n+        use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n+\n+        assert!(ty.is_ty_infer());\n+        let fallback = match self.type_is_unconstrained_numeric(ty) {\n+            _ if self.is_tainted_by_errors() => self.tcx().ty_error(),\n+            UnconstrainedInt => self.tcx.types.i32,\n+            UnconstrainedFloat => self.tcx.types.f64,\n+            Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n+            Neither => {\n+                // This type variable was created from the instantiation of an opaque\n+                // type. The fact that we're attempting to perform fallback for it\n+                // means that the function neither constrained it to a concrete\n+                // type, nor to the opaque type itself.\n+                //\n+                // For example, in this code:\n+                //\n+                //```\n+                // type MyType = impl Copy;\n+                // fn defining_use() -> MyType { true }\n+                // fn other_use() -> MyType { defining_use() }\n+                // ```\n+                //\n+                // `defining_use` will constrain the instantiated inference\n+                // variable to `bool`, while `other_use` will constrain\n+                // the instantiated inference variable to `MyType`.\n+                //\n+                // When we process opaque types during writeback, we\n+                // will handle cases like `other_use`, and not count\n+                // them as defining usages\n+                //\n+                // However, we also need to handle cases like this:\n+                //\n+                // ```rust\n+                // pub type Foo = impl Copy;\n+                // fn produce() -> Option<Foo> {\n+                //     None\n+                //  }\n+                //  ```\n+                //\n+                // In the above snippet, the inference variable created by\n+                // instantiating `Option<Foo>` will be completely unconstrained.\n+                // We treat this as a non-defining use by making the inference\n+                // variable fall back to the opaque type itself.\n+                if let FallbackMode::All = mode {\n+                    if let Some(opaque_ty) = self.opaque_types_vars.borrow().get(ty) {\n+                        debug!(\n+                            \"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n+                            ty, opaque_ty\n+                        );\n+                        *opaque_ty\n+                    } else {\n+                        return false;\n+                    }\n+                } else {\n+                    return false;\n+                }\n+            }\n+        };\n+        debug!(\"fallback_if_possible: defaulting `{:?}` to `{:?}`\", ty, fallback);\n+        self.demand_eqtype(rustc_span::DUMMY_SP, ty, fallback);\n+        true\n+    }\n+\n+    pub(in super::super) fn select_all_obligations_or_error(&self) {\n+        debug!(\"select_all_obligations_or_error\");\n+        if let Err(errors) = self.fulfillment_cx.borrow_mut().select_all_or_error(&self) {\n+            self.report_fulfillment_errors(&errors, self.inh.body_id, false);\n+        }\n+    }\n+\n+    /// Select as many obligations as we can at present.\n+    pub(in super::super) fn select_obligations_where_possible(\n+        &self,\n+        fallback_has_occurred: bool,\n+        mutate_fullfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n+    ) {\n+        let result = self.fulfillment_cx.borrow_mut().select_where_possible(self);\n+        if let Err(mut errors) = result {\n+            mutate_fullfillment_errors(&mut errors);\n+            self.report_fulfillment_errors(&errors, self.inh.body_id, fallback_has_occurred);\n+        }\n+    }\n+\n+    /// For the overloaded place expressions (`*x`, `x[3]`), the trait\n+    /// returns a type of `&T`, but the actual type we assign to the\n+    /// *expression* is `T`. So this function just peels off the return\n+    /// type by one layer to yield `T`.\n+    pub(in super::super) fn make_overloaded_place_return_type(\n+        &self,\n+        method: MethodCallee<'tcx>,\n+    ) -> ty::TypeAndMut<'tcx> {\n+        // extract method return type, which will be &T;\n+        let ret_ty = method.sig.output();\n+\n+        // method returns &T, but the type as visible to user is T, so deref\n+        ret_ty.builtin_deref(true).unwrap()\n+    }\n+\n+    fn self_type_matches_expected_vid(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        expected_vid: ty::TyVid,\n+    ) -> bool {\n+        let self_ty = self.shallow_resolve(trait_ref.skip_binder().self_ty());\n+        debug!(\n+            \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?}, expected_vid={:?})\",\n+            trait_ref, self_ty, expected_vid\n+        );\n+        match *self_ty.kind() {\n+            ty::Infer(ty::TyVar(found_vid)) => {\n+                // FIXME: consider using `sub_root_var` here so we\n+                // can see through subtyping.\n+                let found_vid = self.root_var(found_vid);\n+                debug!(\"self_type_matches_expected_vid - found_vid={:?}\", found_vid);\n+                expected_vid == found_vid\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    pub(in super::super) fn obligations_for_self_ty<'b>(\n+        &'b self,\n+        self_ty: ty::TyVid,\n+    ) -> impl Iterator<Item = (ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n+    + Captures<'tcx>\n+    + 'b {\n+        // FIXME: consider using `sub_root_var` here so we\n+        // can see through subtyping.\n+        let ty_var_root = self.root_var(self_ty);\n+        debug!(\n+            \"obligations_for_self_ty: self_ty={:?} ty_var_root={:?} pending_obligations={:?}\",\n+            self_ty,\n+            ty_var_root,\n+            self.fulfillment_cx.borrow().pending_obligations()\n+        );\n+\n+        self.fulfillment_cx\n+            .borrow()\n+            .pending_obligations()\n+            .into_iter()\n+            .filter_map(move |obligation| {\n+                match obligation.predicate.skip_binders() {\n+                    ty::PredicateAtom::Projection(data) => {\n+                        Some((ty::Binder::bind(data).to_poly_trait_ref(self.tcx), obligation))\n+                    }\n+                    ty::PredicateAtom::Trait(data, _) => {\n+                        Some((ty::Binder::bind(data).to_poly_trait_ref(), obligation))\n+                    }\n+                    ty::PredicateAtom::Subtype(..) => None,\n+                    ty::PredicateAtom::RegionOutlives(..) => None,\n+                    ty::PredicateAtom::TypeOutlives(..) => None,\n+                    ty::PredicateAtom::WellFormed(..) => None,\n+                    ty::PredicateAtom::ObjectSafe(..) => None,\n+                    ty::PredicateAtom::ConstEvaluatable(..) => None,\n+                    ty::PredicateAtom::ConstEquate(..) => None,\n+                    // N.B., this predicate is created by breaking down a\n+                    // `ClosureType: FnFoo()` predicate, where\n+                    // `ClosureType` represents some `Closure`. It can't\n+                    // possibly be referring to the current closure,\n+                    // because we haven't produced the `Closure` for\n+                    // this closure yet; this is exactly why the other\n+                    // code is looking for a self type of a unresolved\n+                    // inference variable.\n+                    ty::PredicateAtom::ClosureKind(..) => None,\n+                    ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+                }\n+            })\n+            .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n+    }\n+\n+    pub(in super::super) fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n+        self.obligations_for_self_ty(self_ty)\n+            .any(|(tr, _)| Some(tr.def_id()) == self.tcx.lang_items().sized_trait())\n+    }\n+\n+    pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n+        vec![self.tcx.ty_error(); len]\n+    }\n+\n+    /// Unifies the output type with the expected type early, for more coercions\n+    /// and forward type information on the input expressions.\n+    pub(in super::super) fn expected_inputs_for_expected_output(\n+        &self,\n+        call_span: Span,\n+        expected_ret: Expectation<'tcx>,\n+        formal_ret: Ty<'tcx>,\n+        formal_args: &[Ty<'tcx>],\n+    ) -> Vec<Ty<'tcx>> {\n+        let formal_ret = self.resolve_vars_with_obligations(formal_ret);\n+        let ret_ty = match expected_ret.only_has_type(self) {\n+            Some(ret) => ret,\n+            None => return Vec::new(),\n+        };\n+        let expect_args = self\n+            .fudge_inference_if_ok(|| {\n+                // Attempt to apply a subtyping relationship between the formal\n+                // return type (likely containing type variables if the function\n+                // is polymorphic) and the expected return type.\n+                // No argument expectations are produced if unification fails.\n+                let origin = self.misc(call_span);\n+                let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n+\n+                // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n+                // to identity so the resulting type is not constrained.\n+                match ures {\n+                    Ok(ok) => {\n+                        // Process any obligations locally as much as\n+                        // we can.  We don't care if some things turn\n+                        // out unconstrained or ambiguous, as we're\n+                        // just trying to get hints here.\n+                        self.save_and_restore_in_snapshot_flag(|_| {\n+                            let mut fulfill = TraitEngine::new(self.tcx);\n+                            for obligation in ok.obligations {\n+                                fulfill.register_predicate_obligation(self, obligation);\n+                            }\n+                            fulfill.select_where_possible(self)\n+                        })\n+                        .map_err(|_| ())?;\n+                    }\n+                    Err(_) => return Err(()),\n+                }\n+\n+                // Record all the argument types, with the substitutions\n+                // produced from the above subtyping unification.\n+                Ok(formal_args.iter().map(|ty| self.resolve_vars_if_possible(ty)).collect())\n+            })\n+            .unwrap_or_default();\n+        debug!(\n+            \"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n+            formal_args, formal_ret, expect_args, expected_ret\n+        );\n+        expect_args\n+    }\n+\n+    pub(in super::super) fn resolve_lang_item_path(\n+        &self,\n+        lang_item: hir::LangItem,\n+        span: Span,\n+        hir_id: hir::HirId,\n+    ) -> (Res, Ty<'tcx>) {\n+        let def_id = self.tcx.require_lang_item(lang_item, Some(span));\n+        let def_kind = self.tcx.def_kind(def_id);\n+\n+        let item_ty = if let DefKind::Variant = def_kind {\n+            self.tcx.type_of(self.tcx.parent(def_id).expect(\"variant w/out parent\"))\n+        } else {\n+            self.tcx.type_of(def_id)\n+        };\n+        let substs = self.infcx.fresh_substs_for_item(span, def_id);\n+        let ty = item_ty.subst(self.tcx, substs);\n+\n+        self.write_resolution(hir_id, Ok((def_kind, def_id)));\n+        self.add_required_obligations(span, def_id, &substs);\n+        (Res::Def(def_kind, def_id), ty)\n+    }\n+\n+    /// Resolves an associated value path into a base type and associated constant, or method\n+    /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n+    pub fn resolve_ty_and_res_ufcs<'b>(\n+        &self,\n+        qpath: &'b QPath<'b>,\n+        hir_id: hir::HirId,\n+        span: Span,\n+    ) -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]) {\n+        debug!(\"resolve_ty_and_res_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n+        let (ty, qself, item_segment) = match *qpath {\n+            QPath::Resolved(ref opt_qself, ref path) => {\n+                return (\n+                    path.res,\n+                    opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n+                    &path.segments[..],\n+                );\n+            }\n+            QPath::TypeRelative(ref qself, ref segment) => (self.to_ty(qself), qself, segment),\n+            QPath::LangItem(..) => bug!(\"`resolve_ty_and_res_ufcs` called on `LangItem`\"),\n+        };\n+        if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n+        {\n+            // Return directly on cache hit. This is useful to avoid doubly reporting\n+            // errors with default match binding modes. See #44614.\n+            let def =\n+                cached_result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err);\n+            return (def, Some(ty), slice::from_ref(&**item_segment));\n+        }\n+        let item_name = item_segment.ident;\n+        let result = self.resolve_ufcs(span, item_name, ty, hir_id).or_else(|error| {\n+            let result = match error {\n+                method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n+                _ => Err(ErrorReported),\n+            };\n+            if item_name.name != kw::Invalid {\n+                if let Some(mut e) = self.report_method_error(\n+                    span,\n+                    ty,\n+                    item_name,\n+                    SelfSource::QPath(qself),\n+                    error,\n+                    None,\n+                ) {\n+                    e.emit();\n+                }\n+            }\n+            result\n+        });\n+\n+        // Write back the new resolution.\n+        self.write_resolution(hir_id, result);\n+        (\n+            result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err),\n+            Some(ty),\n+            slice::from_ref(&**item_segment),\n+        )\n+    }\n+\n+    /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n+    pub(in super::super) fn get_node_fn_decl(\n+        &self,\n+        node: Node<'tcx>,\n+    ) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident, bool)> {\n+        match node {\n+            Node::Item(&hir::Item { ident, kind: hir::ItemKind::Fn(ref sig, ..), .. }) => {\n+                // This is less than ideal, it will not suggest a return type span on any\n+                // method called `main`, regardless of whether it is actually the entry point,\n+                // but it will still present it as the reason for the expected type.\n+                Some((&sig.decl, ident, ident.name != sym::main))\n+            }\n+            Node::TraitItem(&hir::TraitItem {\n+                ident,\n+                kind: hir::TraitItemKind::Fn(ref sig, ..),\n+                ..\n+            }) => Some((&sig.decl, ident, true)),\n+            Node::ImplItem(&hir::ImplItem {\n+                ident,\n+                kind: hir::ImplItemKind::Fn(ref sig, ..),\n+                ..\n+            }) => Some((&sig.decl, ident, false)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Given a `HirId`, return the `FnDecl` of the method it is enclosed by and whether a\n+    /// suggestion can be made, `None` otherwise.\n+    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, bool)> {\n+        // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n+        // `while` before reaching it, as block tail returns are not available in them.\n+        self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {\n+            let parent = self.tcx.hir().get(blk_id);\n+            self.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n+        })\n+    }\n+\n+    pub(in super::super) fn note_internal_mutation_in_method(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if found != self.tcx.types.unit {\n+            return;\n+        }\n+        if let ExprKind::MethodCall(path_segment, _, [rcvr, ..], _) = expr.kind {\n+            if self\n+                .typeck_results\n+                .borrow()\n+                .expr_ty_adjusted_opt(rcvr)\n+                .map_or(true, |ty| expected.peel_refs() != ty.peel_refs())\n+            {\n+                return;\n+            }\n+            let mut sp = MultiSpan::from_span(path_segment.ident.span);\n+            sp.push_span_label(\n+                path_segment.ident.span,\n+                format!(\n+                    \"this call modifies {} in-place\",\n+                    match rcvr.kind {\n+                        ExprKind::Path(QPath::Resolved(\n+                            None,\n+                            hir::Path { segments: [segment], .. },\n+                        )) => format!(\"`{}`\", segment.ident),\n+                        _ => \"its receiver\".to_string(),\n+                    }\n+                ),\n+            );\n+            sp.push_span_label(\n+                rcvr.span,\n+                \"you probably want to use this value after calling the method...\".to_string(),\n+            );\n+            err.span_note(\n+                sp,\n+                &format!(\"method `{}` modifies its receiver in-place\", path_segment.ident),\n+            );\n+            err.note(&format!(\"...instead of the `()` output of method `{}`\", path_segment.ident));\n+        }\n+    }\n+\n+    pub(in super::super) fn note_need_for_fn_pointer(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        let (sig, did, substs) = match (&expected.kind(), &found.kind()) {\n+            (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n+                let sig1 = self.tcx.fn_sig(*did1).subst(self.tcx, substs1);\n+                let sig2 = self.tcx.fn_sig(*did2).subst(self.tcx, substs2);\n+                if sig1 != sig2 {\n+                    return;\n+                }\n+                err.note(\n+                    \"different `fn` items always have unique types, even if their signatures are \\\n+                     the same\",\n+                );\n+                (sig1, *did1, substs1)\n+            }\n+            (ty::FnDef(did, substs), ty::FnPtr(sig2)) => {\n+                let sig1 = self.tcx.fn_sig(*did).subst(self.tcx, substs);\n+                if sig1 != *sig2 {\n+                    return;\n+                }\n+                (sig1, *did, substs)\n+            }\n+            _ => return,\n+        };\n+        err.help(&format!(\"change the expected type to be function pointer `{}`\", sig));\n+        err.help(&format!(\n+            \"if the expected type is due to type inference, cast the expected `fn` to a function \\\n+             pointer: `{} as {}`\",\n+            self.tcx.def_path_str_with_substs(did, substs),\n+            sig\n+        ));\n+    }\n+\n+    pub(in super::super) fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<Span> {\n+        // Be helpful when the user wrote `{... expr;}` and\n+        // taking the `;` off is enough to fix the error.\n+        let last_stmt = blk.stmts.last()?;\n+        let last_expr = match last_stmt.kind {\n+            hir::StmtKind::Semi(ref e) => e,\n+            _ => return None,\n+        };\n+        let last_expr_ty = self.node_ty(last_expr.hir_id);\n+        if matches!(last_expr_ty.kind(), ty::Error(_))\n+            || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err()\n+        {\n+            return None;\n+        }\n+        let original_span = original_sp(last_stmt.span, blk.span);\n+        Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n+    }\n+\n+    // Instantiates the given path, which must refer to an item with the given\n+    // number of type parameters and type.\n+    pub fn instantiate_value_path(\n+        &self,\n+        segments: &[hir::PathSegment<'_>],\n+        self_ty: Option<Ty<'tcx>>,\n+        res: Res,\n+        span: Span,\n+        hir_id: hir::HirId,\n+    ) -> (Ty<'tcx>, Res) {\n+        debug!(\n+            \"instantiate_value_path(segments={:?}, self_ty={:?}, res={:?}, hir_id={})\",\n+            segments, self_ty, res, hir_id,\n+        );\n+\n+        let tcx = self.tcx;\n+\n+        let path_segs = match res {\n+            Res::Local(_) | Res::SelfCtor(_) => vec![],\n+            Res::Def(kind, def_id) => {\n+                AstConv::def_ids_for_value_path_segments(self, segments, self_ty, kind, def_id)\n+            }\n+            _ => bug!(\"instantiate_value_path on {:?}\", res),\n+        };\n+\n+        let mut user_self_ty = None;\n+        let mut is_alias_variant_ctor = false;\n+        match res {\n+            Res::Def(DefKind::Ctor(CtorOf::Variant, _), _) => {\n+                if let Some(self_ty) = self_ty {\n+                    let adt_def = self_ty.ty_adt_def().unwrap();\n+                    user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did, self_ty });\n+                    is_alias_variant_ctor = true;\n+                }\n+            }\n+            Res::Def(DefKind::AssocFn | DefKind::AssocConst, def_id) => {\n+                let container = tcx.associated_item(def_id).container;\n+                debug!(\"instantiate_value_path: def_id={:?} container={:?}\", def_id, container);\n+                match container {\n+                    ty::TraitContainer(trait_did) => {\n+                        callee::check_legal_trait_for_method_call(tcx, span, None, trait_did)\n+                    }\n+                    ty::ImplContainer(impl_def_id) => {\n+                        if segments.len() == 1 {\n+                            // `<T>::assoc` will end up here, and so\n+                            // can `T::assoc`. It this came from an\n+                            // inherent impl, we need to record the\n+                            // `T` for posterity (see `UserSelfTy` for\n+                            // details).\n+                            let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\");\n+                            user_self_ty = Some(UserSelfTy { impl_def_id, self_ty });\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // Now that we have categorized what space the parameters for each\n+        // segment belong to, let's sort out the parameters that the user\n+        // provided (if any) into their appropriate spaces. We'll also report\n+        // errors if type parameters are provided in an inappropriate place.\n+\n+        let generic_segs: FxHashSet<_> = path_segs.iter().map(|PathSeg(_, index)| index).collect();\n+        let generics_has_err = AstConv::prohibit_generics(\n+            self,\n+            segments.iter().enumerate().filter_map(|(index, seg)| {\n+                if !generic_segs.contains(&index) || is_alias_variant_ctor {\n+                    Some(seg)\n+                } else {\n+                    None\n+                }\n+            }),\n+        );\n+\n+        if let Res::Local(hid) = res {\n+            let ty = self.local_ty(span, hid).decl_ty;\n+            let ty = self.normalize_associated_types_in(span, &ty);\n+            self.write_ty(hir_id, ty);\n+            return (ty, res);\n+        }\n+\n+        if generics_has_err {\n+            // Don't try to infer type parameters when prohibited generic arguments were given.\n+            user_self_ty = None;\n+        }\n+\n+        // Now we have to compare the types that the user *actually*\n+        // provided against the types that were *expected*. If the user\n+        // did not provide any types, then we want to substitute inference\n+        // variables. If the user provided some types, we may still need\n+        // to add defaults. If the user provided *too many* types, that's\n+        // a problem.\n+\n+        let mut infer_args_for_err = FxHashSet::default();\n+        for &PathSeg(def_id, index) in &path_segs {\n+            let seg = &segments[index];\n+            let generics = tcx.generics_of(def_id);\n+            // Argument-position `impl Trait` is treated as a normal generic\n+            // parameter internally, but we don't allow users to specify the\n+            // parameter's value explicitly, so we have to do some error-\n+            // checking here.\n+            if let GenericArgCountResult {\n+                correct: Err(GenericArgCountMismatch { reported: Some(ErrorReported), .. }),\n+                ..\n+            } = AstConv::check_generic_arg_count_for_call(\n+                tcx, span, &generics, &seg, false, // `is_method_call`\n+            ) {\n+                infer_args_for_err.insert(index);\n+                self.set_tainted_by_errors(); // See issue #53251.\n+            }\n+        }\n+\n+        let has_self = path_segs\n+            .last()\n+            .map(|PathSeg(def_id, _)| tcx.generics_of(*def_id).has_self)\n+            .unwrap_or(false);\n+\n+        let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n+            let ty = self.normalize_ty(span, tcx.at(span).type_of(impl_def_id));\n+            match *ty.kind() {\n+                ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n+                    let variant = adt_def.non_enum_variant();\n+                    let ctor_def_id = variant.ctor_def_id.unwrap();\n+                    (\n+                        Res::Def(DefKind::Ctor(CtorOf::Struct, variant.ctor_kind), ctor_def_id),\n+                        Some(substs),\n+                    )\n+                }\n+                _ => {\n+                    let mut err = tcx.sess.struct_span_err(\n+                        span,\n+                        \"the `Self` constructor can only be used with tuple or unit structs\",\n+                    );\n+                    if let Some(adt_def) = ty.ty_adt_def() {\n+                        match adt_def.adt_kind() {\n+                            AdtKind::Enum => {\n+                                err.help(\"did you mean to use one of the enum's variants?\");\n+                            }\n+                            AdtKind::Struct | AdtKind::Union => {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use curly brackets\",\n+                                    String::from(\"Self { /* fields */ }\"),\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    err.emit();\n+\n+                    return (tcx.ty_error(), res);\n+                }\n+            }\n+        } else {\n+            (res, None)\n+        };\n+        let def_id = res.def_id();\n+\n+        // The things we are substituting into the type should not contain\n+        // escaping late-bound regions, and nor should the base type scheme.\n+        let ty = tcx.type_of(def_id);\n+\n+        let arg_count = GenericArgCountResult {\n+            explicit_late_bound: ExplicitLateBound::No,\n+            correct: if infer_args_for_err.is_empty() {\n+                Ok(())\n+            } else {\n+                Err(GenericArgCountMismatch::default())\n+            },\n+        };\n+\n+        let substs = self_ctor_substs.unwrap_or_else(|| {\n+            AstConv::create_substs_for_generic_args(\n+                tcx,\n+                def_id,\n+                &[][..],\n+                has_self,\n+                self_ty,\n+                arg_count,\n+                // Provide the generic args, and whether types should be inferred.\n+                |def_id| {\n+                    if let Some(&PathSeg(_, index)) =\n+                        path_segs.iter().find(|&PathSeg(did, _)| *did == def_id)\n+                    {\n+                        // If we've encountered an `impl Trait`-related error, we're just\n+                        // going to infer the arguments for better error messages.\n+                        if !infer_args_for_err.contains(&index) {\n+                            // Check whether the user has provided generic arguments.\n+                            if let Some(ref data) = segments[index].args {\n+                                return (Some(data), segments[index].infer_args);\n+                            }\n+                        }\n+                        return (None, segments[index].infer_args);\n+                    }\n+\n+                    (None, true)\n+                },\n+                // Provide substitutions for parameters for which (valid) arguments have been provided.\n+                |param, arg| match (&param.kind, arg) {\n+                    (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n+                        AstConv::ast_region_to_region(self, lt, Some(param)).into()\n+                    }\n+                    (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n+                        self.to_ty(ty).into()\n+                    }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        self.const_arg_to_const(&ct.value, param.def_id).into()\n+                    }\n+                    _ => unreachable!(),\n+                },\n+                // Provide substitutions for parameters for which arguments are inferred.\n+                |substs, param, infer_args| {\n+                    match param.kind {\n+                        GenericParamDefKind::Lifetime => {\n+                            self.re_infer(Some(param), span).unwrap().into()\n+                        }\n+                        GenericParamDefKind::Type { has_default, .. } => {\n+                            if !infer_args && has_default {\n+                                // If we have a default, then we it doesn't matter that we're not\n+                                // inferring the type arguments: we provide the default where any\n+                                // is missing.\n+                                let default = tcx.type_of(param.def_id);\n+                                self.normalize_ty(\n+                                    span,\n+                                    default.subst_spanned(tcx, substs.unwrap(), Some(span)),\n+                                )\n+                                .into()\n+                            } else {\n+                                // If no type arguments were provided, we have to infer them.\n+                                // This case also occurs as a result of some malformed input, e.g.\n+                                // a lifetime argument being given instead of a type parameter.\n+                                // Using inference instead of `Error` gives better error messages.\n+                                self.var_for_def(span, param)\n+                            }\n+                        }\n+                        GenericParamDefKind::Const => {\n+                            // FIXME(const_generics:defaults)\n+                            // No const parameters were provided, we have to infer them.\n+                            self.var_for_def(span, param)\n+                        }\n+                    }\n+                },\n+            )\n+        });\n+        assert!(!substs.has_escaping_bound_vars());\n+        assert!(!ty.has_escaping_bound_vars());\n+\n+        // First, store the \"user substs\" for later.\n+        self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n+\n+        self.add_required_obligations(span, def_id, &substs);\n+\n+        // Substitute the values for the type parameters into the type of\n+        // the referenced item.\n+        let ty_substituted = self.instantiate_type_scheme(span, &substs, &ty);\n+\n+        if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+            // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n+            // is inherent, there is no `Self` parameter; instead, the impl needs\n+            // type parameters, which we can infer by unifying the provided `Self`\n+            // with the substituted impl type.\n+            // This also occurs for an enum variant on a type alias.\n+            let ty = tcx.type_of(impl_def_id);\n+\n+            let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n+            match self.at(&self.misc(span), self.param_env).sup(impl_ty, self_ty) {\n+                Ok(ok) => self.register_infer_ok_obligations(ok),\n+                Err(_) => {\n+                    self.tcx.sess.delay_span_bug(\n+                        span,\n+                        &format!(\n+                        \"instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n+                        self_ty,\n+                        impl_ty,\n+                    ),\n+                    );\n+                }\n+            }\n+        }\n+\n+        self.check_rustc_args_require_const(def_id, hir_id, span);\n+\n+        debug!(\"instantiate_value_path: type of {:?} is {:?}\", hir_id, ty_substituted);\n+        self.write_substs(hir_id, substs);\n+\n+        (ty_substituted, res)\n+    }\n+\n+    /// Add all the obligations that are required, substituting and normalized appropriately.\n+    fn add_required_obligations(&self, span: Span, def_id: DefId, substs: &SubstsRef<'tcx>) {\n+        let (bounds, spans) = self.instantiate_bounds(span, def_id, &substs);\n+\n+        for (i, mut obligation) in traits::predicates_for_generics(\n+            traits::ObligationCause::new(span, self.body_id, traits::ItemObligation(def_id)),\n+            self.param_env,\n+            bounds,\n+        )\n+        .enumerate()\n+        {\n+            // This makes the error point at the bound, but we want to point at the argument\n+            if let Some(span) = spans.get(i) {\n+                obligation.cause.make_mut().code = traits::BindingObligation(def_id, *span);\n+            }\n+            self.register_predicate(obligation);\n+        }\n+    }\n+\n+    /// Resolves `typ` by a single level if `typ` is a type variable.\n+    /// If no resolution is possible, then an error is reported.\n+    /// Numeric inference variables may be left unresolved.\n+    pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let ty = self.resolve_vars_with_obligations(ty);\n+        if !ty.is_ty_var() {\n+            ty\n+        } else {\n+            if !self.is_tainted_by_errors() {\n+                self.emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282)\n+                    .note(\"type must be known at this point\")\n+                    .emit();\n+            }\n+            let err = self.tcx.ty_error();\n+            self.demand_suptype(sp, err, ty);\n+            err\n+        }\n+    }\n+\n+    pub(in super::super) fn with_breakable_ctxt<F: FnOnce() -> R, R>(\n+        &self,\n+        id: hir::HirId,\n+        ctxt: BreakableCtxt<'tcx>,\n+        f: F,\n+    ) -> (BreakableCtxt<'tcx>, R) {\n+        let index;\n+        {\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            index = enclosing_breakables.stack.len();\n+            enclosing_breakables.by_id.insert(id, index);\n+            enclosing_breakables.stack.push(ctxt);\n+        }\n+        let result = f();\n+        let ctxt = {\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            debug_assert!(enclosing_breakables.stack.len() == index + 1);\n+            enclosing_breakables.by_id.remove(&id).expect(\"missing breakable context\");\n+            enclosing_breakables.stack.pop().expect(\"missing breakable context\")\n+        };\n+        (ctxt, result)\n+    }\n+\n+    /// Instantiate a QueryResponse in a probe context, without a\n+    /// good ObligationCause.\n+    pub(in super::super) fn probe_instantiate_query_response(\n+        &self,\n+        span: Span,\n+        original_values: &OriginalQueryValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+    ) -> InferResult<'tcx, Ty<'tcx>> {\n+        self.instantiate_query_response_and_region_obligations(\n+            &traits::ObligationCause::misc(span, self.body_id),\n+            self.param_env,\n+            original_values,\n+            query_result,\n+        )\n+    }\n+\n+    /// Returns `true` if an expression is contained inside the LHS of an assignment expression.\n+    pub(in super::super) fn expr_in_place(&self, mut expr_id: hir::HirId) -> bool {\n+        let mut contained_in_place = false;\n+\n+        while let hir::Node::Expr(parent_expr) =\n+            self.tcx.hir().get(self.tcx.hir().get_parent_node(expr_id))\n+        {\n+            match &parent_expr.kind {\n+                hir::ExprKind::Assign(lhs, ..) | hir::ExprKind::AssignOp(_, lhs, ..) => {\n+                    if lhs.hir_id == expr_id {\n+                        contained_in_place = true;\n+                        break;\n+                    }\n+                }\n+                _ => (),\n+            }\n+            expr_id = parent_expr.hir_id;\n+        }\n+\n+        contained_in_place\n+    }\n+}"}, {"sha": "3224e04ee49fa1dce60741295105ca69ca1a2624", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "added", "additions": 979, "deletions": 0, "changes": 979, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -0,0 +1,979 @@\n+use crate::astconv::AstConv;\n+use crate::check::coercion::CoerceMany;\n+use crate::check::method::MethodCallee;\n+use crate::check::Expectation::*;\n+use crate::check::TupleArgumentsFlag::*;\n+use crate::check::{\n+    potentially_plural_count, struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt,\n+    LocalTy, Needs, TupleArgumentsFlag,\n+};\n+\n+use rustc_ast as ast;\n+use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{ExprKind, Node, QPath};\n+use rustc_middle::ty::adjustment::AllowTwoPhase;\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_session::Session;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{self, Span};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode};\n+\n+use std::mem::replace;\n+use std::slice;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(in super::super) fn check_casts(&self) {\n+        let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+        for cast in deferred_cast_checks.drain(..) {\n+            cast.check(self);\n+        }\n+    }\n+\n+    pub(in super::super) fn check_method_argument_types(\n+        &self,\n+        sp: Span,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        method: Result<MethodCallee<'tcx>, ()>,\n+        args_no_rcvr: &'tcx [hir::Expr<'tcx>],\n+        tuple_arguments: TupleArgumentsFlag,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let has_error = match method {\n+            Ok(method) => method.substs.references_error() || method.sig.references_error(),\n+            Err(_) => true,\n+        };\n+        if has_error {\n+            let err_inputs = self.err_args(args_no_rcvr.len());\n+\n+            let err_inputs = match tuple_arguments {\n+                DontTupleArguments => err_inputs,\n+                TupleArguments => vec![self.tcx.intern_tup(&err_inputs[..])],\n+            };\n+\n+            self.check_argument_types(\n+                sp,\n+                expr,\n+                &err_inputs[..],\n+                &[],\n+                args_no_rcvr,\n+                false,\n+                tuple_arguments,\n+                None,\n+            );\n+            return self.tcx.ty_error();\n+        }\n+\n+        let method = method.unwrap();\n+        // HACK(eddyb) ignore self in the definition (see above).\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+            sp,\n+            expected,\n+            method.sig.output(),\n+            &method.sig.inputs()[1..],\n+        );\n+        self.check_argument_types(\n+            sp,\n+            expr,\n+            &method.sig.inputs()[1..],\n+            &expected_arg_tys[..],\n+            args_no_rcvr,\n+            method.sig.c_variadic,\n+            tuple_arguments,\n+            self.tcx.hir().span_if_local(method.def_id),\n+        );\n+        method.sig.output()\n+    }\n+\n+    /// Generic function that factors out common logic from function calls,\n+    /// method calls and overloaded operators.\n+    pub(in super::super) fn check_argument_types(\n+        &self,\n+        sp: Span,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        fn_inputs: &[Ty<'tcx>],\n+        expected_arg_tys: &[Ty<'tcx>],\n+        args: &'tcx [hir::Expr<'tcx>],\n+        c_variadic: bool,\n+        tuple_arguments: TupleArgumentsFlag,\n+        def_span: Option<Span>,\n+    ) {\n+        let tcx = self.tcx;\n+        // Grab the argument types, supplying fresh type variables\n+        // if the wrong number of arguments were supplied\n+        let supplied_arg_count = if tuple_arguments == DontTupleArguments { args.len() } else { 1 };\n+\n+        // All the input types from the fn signature must outlive the call\n+        // so as to validate implied bounds.\n+        for (&fn_input_ty, arg_expr) in fn_inputs.iter().zip(args.iter()) {\n+            self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n+        }\n+\n+        let expected_arg_count = fn_inputs.len();\n+\n+        let param_count_error = |expected_count: usize,\n+                                 arg_count: usize,\n+                                 error_code: &str,\n+                                 c_variadic: bool,\n+                                 sugg_unit: bool| {\n+            let (span, start_span, args) = match &expr.kind {\n+                hir::ExprKind::Call(hir::Expr { span, .. }, args) => (*span, *span, &args[..]),\n+                hir::ExprKind::MethodCall(path_segment, span, args, _) => (\n+                    *span,\n+                    // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n+                    path_segment\n+                        .args\n+                        .and_then(|args| args.args.iter().last())\n+                        // Account for `foo.bar::<T>()`.\n+                        .map(|arg| {\n+                            // Skip the closing `>`.\n+                            tcx.sess\n+                                .source_map()\n+                                .next_point(tcx.sess.source_map().next_point(arg.span()))\n+                        })\n+                        .unwrap_or(*span),\n+                    &args[1..], // Skip the receiver.\n+                ),\n+                k => span_bug!(sp, \"checking argument types on a non-call: `{:?}`\", k),\n+            };\n+            let arg_spans = if args.is_empty() {\n+                // foo()\n+                // ^^^-- supplied 0 arguments\n+                // |\n+                // expected 2 arguments\n+                vec![tcx.sess.source_map().next_point(start_span).with_hi(sp.hi())]\n+            } else {\n+                // foo(1, 2, 3)\n+                // ^^^ -  -  - supplied 3 arguments\n+                // |\n+                // expected 2 arguments\n+                args.iter().map(|arg| arg.span).collect::<Vec<Span>>()\n+            };\n+\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                span,\n+                &format!(\n+                    \"this function takes {}{} but {} {} supplied\",\n+                    if c_variadic { \"at least \" } else { \"\" },\n+                    potentially_plural_count(expected_count, \"argument\"),\n+                    potentially_plural_count(arg_count, \"argument\"),\n+                    if arg_count == 1 { \"was\" } else { \"were\" }\n+                ),\n+                DiagnosticId::Error(error_code.to_owned()),\n+            );\n+            let label = format!(\"supplied {}\", potentially_plural_count(arg_count, \"argument\"));\n+            for (i, span) in arg_spans.into_iter().enumerate() {\n+                err.span_label(\n+                    span,\n+                    if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n+                );\n+            }\n+\n+            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().guess_head_span(sp)) {\n+                err.span_label(def_s, \"defined here\");\n+            }\n+            if sugg_unit {\n+                let sugg_span = tcx.sess.source_map().end_point(expr.span);\n+                // remove closing `)` from the span\n+                let sugg_span = sugg_span.shrink_to_lo();\n+                err.span_suggestion(\n+                    sugg_span,\n+                    \"expected the unit value `()`; create it with empty parentheses\",\n+                    String::from(\"()\"),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    span,\n+                    format!(\n+                        \"expected {}{}\",\n+                        if c_variadic { \"at least \" } else { \"\" },\n+                        potentially_plural_count(expected_count, \"argument\")\n+                    ),\n+                );\n+            }\n+            err.emit();\n+        };\n+\n+        let mut expected_arg_tys = expected_arg_tys.to_vec();\n+\n+        let formal_tys = if tuple_arguments == TupleArguments {\n+            let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n+            match tuple_type.kind() {\n+                ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n+                    param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n+                    expected_arg_tys = vec![];\n+                    self.err_args(args.len())\n+                }\n+                ty::Tuple(arg_types) => {\n+                    expected_arg_tys = match expected_arg_tys.get(0) {\n+                        Some(&ty) => match ty.kind() {\n+                            ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n+                            _ => vec![],\n+                        },\n+                        None => vec![],\n+                    };\n+                    arg_types.iter().map(|k| k.expect_ty()).collect()\n+                }\n+                _ => {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        sp,\n+                        E0059,\n+                        \"cannot use call notation; the first type parameter \\\n+                         for the function trait is neither a tuple nor unit\"\n+                    )\n+                    .emit();\n+                    expected_arg_tys = vec![];\n+                    self.err_args(args.len())\n+                }\n+            }\n+        } else if expected_arg_count == supplied_arg_count {\n+            fn_inputs.to_vec()\n+        } else if c_variadic {\n+            if supplied_arg_count >= expected_arg_count {\n+                fn_inputs.to_vec()\n+            } else {\n+                param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n+                expected_arg_tys = vec![];\n+                self.err_args(supplied_arg_count)\n+            }\n+        } else {\n+            // is the missing argument of type `()`?\n+            let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(&expected_arg_tys[0]).is_unit()\n+            } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(&fn_inputs[0]).is_unit()\n+            } else {\n+                false\n+            };\n+            param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n+\n+            expected_arg_tys = vec![];\n+            self.err_args(supplied_arg_count)\n+        };\n+\n+        debug!(\n+            \"check_argument_types: formal_tys={:?}\",\n+            formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n+        );\n+\n+        // If there is no expectation, expect formal_tys.\n+        let expected_arg_tys =\n+            if !expected_arg_tys.is_empty() { expected_arg_tys } else { formal_tys.clone() };\n+\n+        let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n+\n+        // Check the arguments.\n+        // We do this in a pretty awful way: first we type-check any arguments\n+        // that are not closures, then we type-check the closures. This is so\n+        // that we have more information about the types of arguments when we\n+        // type-check the functions. This isn't really the right way to do this.\n+        for &check_closures in &[false, true] {\n+            debug!(\"check_closures={}\", check_closures);\n+\n+            // More awful hacks: before we check argument types, try to do\n+            // an \"opportunistic\" trait resolution of any trait bounds on\n+            // the call. This helps coercions.\n+            if check_closures {\n+                self.select_obligations_where_possible(false, |errors| {\n+                    self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n+                    self.point_at_arg_instead_of_call_if_possible(\n+                        errors,\n+                        &final_arg_types[..],\n+                        sp,\n+                        &args,\n+                    );\n+                })\n+            }\n+\n+            // For C-variadic functions, we don't have a declared type for all of\n+            // the arguments hence we only do our usual type checking with\n+            // the arguments who's types we do know.\n+            let t = if c_variadic {\n+                expected_arg_count\n+            } else if tuple_arguments == TupleArguments {\n+                args.len()\n+            } else {\n+                supplied_arg_count\n+            };\n+            for (i, arg) in args.iter().take(t).enumerate() {\n+                // Warn only for the first loop (the \"no closures\" one).\n+                // Closure arguments themselves can't be diverging, but\n+                // a previous argument can, e.g., `foo(panic!(), || {})`.\n+                if !check_closures {\n+                    self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n+                }\n+\n+                let is_closure = match arg.kind {\n+                    ExprKind::Closure(..) => true,\n+                    _ => false,\n+                };\n+\n+                if is_closure != check_closures {\n+                    continue;\n+                }\n+\n+                debug!(\"checking the argument\");\n+                let formal_ty = formal_tys[i];\n+\n+                // The special-cased logic below has three functions:\n+                // 1. Provide as good of an expected type as possible.\n+                let expected = Expectation::rvalue_hint(self, expected_arg_tys[i]);\n+\n+                let checked_ty = self.check_expr_with_expectation(&arg, expected);\n+\n+                // 2. Coerce to the most detailed type that could be coerced\n+                //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n+                // We're processing function arguments so we definitely want to use\n+                // two-phase borrows.\n+                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n+                final_arg_types.push((i, checked_ty, coerce_ty));\n+\n+                // 3. Relate the expected type and the formal one,\n+                //    if the expected type was used for the coercion.\n+                self.demand_suptype(arg.span, formal_ty, coerce_ty);\n+            }\n+        }\n+\n+        // We also need to make sure we at least write the ty of the other\n+        // arguments which we skipped above.\n+        if c_variadic {\n+            fn variadic_error<'tcx>(s: &Session, span: Span, t: Ty<'tcx>, cast_ty: &str) {\n+                use crate::structured_errors::{StructuredDiagnostic, VariadicError};\n+                VariadicError::new(s, span, t, cast_ty).diagnostic().emit();\n+            }\n+\n+            for arg in args.iter().skip(expected_arg_count) {\n+                let arg_ty = self.check_expr(&arg);\n+\n+                // There are a few types which get autopromoted when passed via varargs\n+                // in C but we just error out instead and require explicit casts.\n+                let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n+                match arg_ty.kind() {\n+                    ty::Float(ast::FloatTy::F32) => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n+                    }\n+                    ty::Int(ast::IntTy::I8 | ast::IntTy::I16) | ty::Bool => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n+                    }\n+                    ty::Uint(ast::UintTy::U8 | ast::UintTy::U16) => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n+                    }\n+                    ty::FnDef(..) => {\n+                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n+                        let ptr_ty = self.resolve_vars_if_possible(&ptr_ty);\n+                        variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    // AST fragment checking\n+    pub(in super::super) fn check_lit(\n+        &self,\n+        lit: &hir::Lit,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+\n+        match lit.node {\n+            ast::LitKind::Str(..) => tcx.mk_static_str(),\n+            ast::LitKind::ByteStr(ref v) => {\n+                tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.u8, v.len() as u64))\n+            }\n+            ast::LitKind::Byte(_) => tcx.types.u8,\n+            ast::LitKind::Char(_) => tcx.types.char,\n+            ast::LitKind::Int(_, ast::LitIntType::Signed(t)) => tcx.mk_mach_int(t),\n+            ast::LitKind::Int(_, ast::LitIntType::Unsigned(t)) => tcx.mk_mach_uint(t),\n+            ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n+                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n+                    ty::Int(_) | ty::Uint(_) => Some(ty),\n+                    ty::Char => Some(tcx.types.u8),\n+                    ty::RawPtr(..) => Some(tcx.types.usize),\n+                    ty::FnDef(..) | ty::FnPtr(_) => Some(tcx.types.usize),\n+                    _ => None,\n+                });\n+                opt_ty.unwrap_or_else(|| self.next_int_var())\n+            }\n+            ast::LitKind::Float(_, ast::LitFloatType::Suffixed(t)) => tcx.mk_mach_float(t),\n+            ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n+                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n+                    ty::Float(_) => Some(ty),\n+                    _ => None,\n+                });\n+                opt_ty.unwrap_or_else(|| self.next_float_var())\n+            }\n+            ast::LitKind::Bool(_) => tcx.types.bool,\n+            ast::LitKind::Err(_) => tcx.ty_error(),\n+        }\n+    }\n+\n+    pub fn check_struct_path(\n+        &self,\n+        qpath: &QPath<'_>,\n+        hir_id: hir::HirId,\n+    ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n+        let path_span = qpath.qself_span();\n+        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n+        let variant = match def {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                return None;\n+            }\n+            Res::Def(DefKind::Variant, _) => match ty.kind() {\n+                ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did, substs)),\n+                _ => bug!(\"unexpected type: {:?}\", ty),\n+            },\n+            Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n+            | Res::SelfTy(..) => match ty.kind() {\n+                ty::Adt(adt, substs) if !adt.is_enum() => {\n+                    Some((adt.non_enum_variant(), adt.did, substs))\n+                }\n+                _ => None,\n+            },\n+            _ => bug!(\"unexpected definition: {:?}\", def),\n+        };\n+\n+        if let Some((variant, did, substs)) = variant {\n+            debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n+            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n+\n+            // Check bounds on type arguments used in the path.\n+            let (bounds, _) = self.instantiate_bounds(path_span, did, substs);\n+            let cause =\n+                traits::ObligationCause::new(path_span, self.body_id, traits::ItemObligation(did));\n+            self.add_obligations_for_parameters(cause, bounds);\n+\n+            Some((variant, ty))\n+        } else {\n+            struct_span_err!(\n+                self.tcx.sess,\n+                path_span,\n+                E0071,\n+                \"expected struct, variant or union type, found {}\",\n+                ty.sort_string(self.tcx)\n+            )\n+            .span_label(path_span, \"not a struct\")\n+            .emit();\n+            None\n+        }\n+    }\n+\n+    pub fn check_decl_initializer(\n+        &self,\n+        local: &'tcx hir::Local<'tcx>,\n+        init: &'tcx hir::Expr<'tcx>,\n+    ) -> Ty<'tcx> {\n+        // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n+        // for #42640 (default match binding modes).\n+        //\n+        // See #44848.\n+        let ref_bindings = local.pat.contains_explicit_ref_binding();\n+\n+        let local_ty = self.local_ty(init.span, local.hir_id).revealed_ty;\n+        if let Some(m) = ref_bindings {\n+            // Somewhat subtle: if we have a `ref` binding in the pattern,\n+            // we want to avoid introducing coercions for the RHS. This is\n+            // both because it helps preserve sanity and, in the case of\n+            // ref mut, for soundness (issue #23116). In particular, in\n+            // the latter case, we need to be clear that the type of the\n+            // referent for the reference that results is *equal to* the\n+            // type of the place it is referencing, and not some\n+            // supertype thereof.\n+            let init_ty = self.check_expr_with_needs(init, Needs::maybe_mut_place(m));\n+            self.demand_eqtype(init.span, local_ty, init_ty);\n+            init_ty\n+        } else {\n+            self.check_expr_coercable_to_type(init, local_ty, None)\n+        }\n+    }\n+\n+    /// Type check a `let` statement.\n+    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n+        // Determine and write the type which we'll check the pattern against.\n+        let ty = self.local_ty(local.span, local.hir_id).decl_ty;\n+        self.write_ty(local.hir_id, ty);\n+\n+        // Type check the initializer.\n+        if let Some(ref init) = local.init {\n+            let init_ty = self.check_decl_initializer(local, &init);\n+            self.overwrite_local_ty_if_err(local, ty, init_ty);\n+        }\n+\n+        // Does the expected pattern type originate from an expression and what is the span?\n+        let (origin_expr, ty_span) = match (local.ty, local.init) {\n+            (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n+            (_, Some(init)) => (true, Some(init.span)), // No explicit type; so use the scrutinee.\n+            _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n+        };\n+\n+        // Type check the pattern. Override if necessary to avoid knock-on errors.\n+        self.check_pat_top(&local.pat, ty, ty_span, origin_expr);\n+        let pat_ty = self.node_ty(local.pat.hir_id);\n+        self.overwrite_local_ty_if_err(local, ty, pat_ty);\n+    }\n+\n+    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>) {\n+        // Don't do all the complex logic below for `DeclItem`.\n+        match stmt.kind {\n+            hir::StmtKind::Item(..) => return,\n+            hir::StmtKind::Local(..) | hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n+        }\n+\n+        self.warn_if_unreachable(stmt.hir_id, stmt.span, \"statement\");\n+\n+        // Hide the outer diverging and `has_errors` flags.\n+        let old_diverges = self.diverges.replace(Diverges::Maybe);\n+        let old_has_errors = self.has_errors.replace(false);\n+\n+        match stmt.kind {\n+            hir::StmtKind::Local(ref l) => {\n+                self.check_decl_local(&l);\n+            }\n+            // Ignore for now.\n+            hir::StmtKind::Item(_) => {}\n+            hir::StmtKind::Expr(ref expr) => {\n+                // Check with expected type of `()`.\n+                self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit(), |err| {\n+                    self.suggest_semicolon_at_end(expr.span, err);\n+                });\n+            }\n+            hir::StmtKind::Semi(ref expr) => {\n+                self.check_expr(&expr);\n+            }\n+        }\n+\n+        // Combine the diverging and `has_error` flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n+    }\n+\n+    pub fn check_block_no_value(&self, blk: &'tcx hir::Block<'tcx>) {\n+        let unit = self.tcx.mk_unit();\n+        let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n+\n+        // if the block produces a `!` value, that can always be\n+        // (effectively) coerced to unit.\n+        if !ty.is_never() {\n+            self.demand_suptype(blk.span, unit, ty);\n+        }\n+    }\n+\n+    pub(in super::super) fn check_block_with_expected(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let prev = {\n+            let mut fcx_ps = self.ps.borrow_mut();\n+            let unsafety_state = fcx_ps.recurse(blk);\n+            replace(&mut *fcx_ps, unsafety_state)\n+        };\n+\n+        // In some cases, blocks have just one exit, but other blocks\n+        // can be targeted by multiple breaks. This can happen both\n+        // with labeled blocks as well as when we desugar\n+        // a `try { ... }` expression.\n+        //\n+        // Example 1:\n+        //\n+        //    'a: { if true { break 'a Err(()); } Ok(()) }\n+        //\n+        // Here we would wind up with two coercions, one from\n+        // `Err(())` and the other from the tail expression\n+        // `Ok(())`. If the tail expression is omitted, that's a\n+        // \"forced unit\" -- unless the block diverges, in which\n+        // case we can ignore the tail expression (e.g., `'a: {\n+        // break 'a 22; }` would not force the type of the block\n+        // to be `()`).\n+        let tail_expr = blk.expr.as_ref();\n+        let coerce_to_ty = expected.coercion_target_type(self, blk.span);\n+        let coerce = if blk.targeted_by_break {\n+            CoerceMany::new(coerce_to_ty)\n+        } else {\n+            let tail_expr: &[&hir::Expr<'_>] = match tail_expr {\n+                Some(e) => slice::from_ref(e),\n+                None => &[],\n+            };\n+            CoerceMany::with_coercion_sites(coerce_to_ty, tail_expr)\n+        };\n+\n+        let prev_diverges = self.diverges.get();\n+        let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n+\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n+            for s in blk.stmts {\n+                self.check_stmt(s);\n+            }\n+\n+            // check the tail expression **without** holding the\n+            // `enclosing_breakables` lock below.\n+            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n+\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n+            let coerce = ctxt.coerce.as_mut().unwrap();\n+            if let Some(tail_expr_ty) = tail_expr_ty {\n+                let tail_expr = tail_expr.unwrap();\n+                let span = self.get_expr_coercion_span(tail_expr);\n+                let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n+                coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n+            } else {\n+                // Subtle: if there is no explicit tail expression,\n+                // that is typically equivalent to a tail expression\n+                // of `()` -- except if the block diverges. In that\n+                // case, there is no value supplied from the tail\n+                // expression (assuming there are no other breaks,\n+                // this implies that the type of the block will be\n+                // `!`).\n+                //\n+                // #41425 -- label the implicit `()` as being the\n+                // \"found type\" here, rather than the \"expected type\".\n+                if !self.diverges.get().is_always() {\n+                    // #50009 -- Do not point at the entire fn block span, point at the return type\n+                    // span, as it is the cause of the requirement, and\n+                    // `consider_hint_about_removing_semicolon` will point at the last expression\n+                    // if it were a relevant part of the error. This improves usability in editors\n+                    // that highlight errors inline.\n+                    let mut sp = blk.span;\n+                    let mut fn_span = None;\n+                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n+                        let ret_sp = decl.output.span();\n+                        if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n+                            // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n+                            // output would otherwise be incorrect and even misleading. Make sure\n+                            // the span we're aiming at correspond to a `fn` body.\n+                            if block_sp == blk.span {\n+                                sp = ret_sp;\n+                                fn_span = Some(ident.span);\n+                            }\n+                        }\n+                    }\n+                    coerce.coerce_forced_unit(\n+                        self,\n+                        &self.misc(sp),\n+                        &mut |err| {\n+                            if let Some(expected_ty) = expected.only_has_type(self) {\n+                                self.consider_hint_about_removing_semicolon(blk, expected_ty, err);\n+                            }\n+                            if let Some(fn_span) = fn_span {\n+                                err.span_label(\n+                                    fn_span,\n+                                    \"implicitly returns `()` as its body has no tail or `return` \\\n+                                     expression\",\n+                                );\n+                            }\n+                        },\n+                        false,\n+                    );\n+                }\n+            }\n+        });\n+\n+        if ctxt.may_break {\n+            // If we can break from the block, then the block's exit is always reachable\n+            // (... as long as the entry is reachable) - regardless of the tail of the block.\n+            self.diverges.set(prev_diverges);\n+        }\n+\n+        let mut ty = ctxt.coerce.unwrap().complete(self);\n+\n+        if self.has_errors.get() || ty.references_error() {\n+            ty = self.tcx.ty_error()\n+        }\n+\n+        self.write_ty(blk.hir_id, ty);\n+\n+        *self.ps.borrow_mut() = prev;\n+        ty\n+    }\n+\n+    pub(in super::super) fn check_rustc_args_require_const(\n+        &self,\n+        def_id: DefId,\n+        hir_id: hir::HirId,\n+        span: Span,\n+    ) {\n+        // We're only interested in functions tagged with\n+        // #[rustc_args_required_const], so ignore anything that's not.\n+        if !self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n+            return;\n+        }\n+\n+        // If our calling expression is indeed the function itself, we're good!\n+        // If not, generate an error that this can only be called directly.\n+        if let Node::Expr(expr) = self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id)) {\n+            if let ExprKind::Call(ref callee, ..) = expr.kind {\n+                if callee.hir_id == hir_id {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.span_err(\n+            span,\n+            \"this function can only be invoked directly, not through a function pointer\",\n+        );\n+    }\n+\n+    /// A common error is to add an extra semicolon:\n+    ///\n+    /// ```\n+    /// fn foo() -> usize {\n+    ///     22;\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the final statement in a block is an\n+    /// expression with an explicit semicolon whose type is compatible\n+    /// with `expected_ty`. If so, it suggests removing the semicolon.\n+    fn consider_hint_about_removing_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n+            err.span_suggestion(\n+                span_semi,\n+                \"consider removing this semicolon\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    fn parent_item_span(&self, id: hir::HirId) -> Option<Span> {\n+        let node = self.tcx.hir().get(self.tcx.hir().get_parent_item(id));\n+        match node {\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })\n+            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body_id), .. }) => {\n+                let body = self.tcx.hir().body(body_id);\n+                if let ExprKind::Block(block, _) = &body.value.kind {\n+                    return Some(block.span);\n+                }\n+            }\n+            _ => {}\n+        }\n+        None\n+    }\n+\n+    /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n+    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident)> {\n+        let parent = self.tcx.hir().get(self.tcx.hir().get_parent_item(blk_id));\n+        self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n+    }\n+\n+    /// If `expr` is a `match` expression that has only one non-`!` arm, use that arm's tail\n+    /// expression's `Span`, otherwise return `expr.span`. This is done to give better errors\n+    /// when given code like the following:\n+    /// ```text\n+    /// if false { return 0i32; } else { 1u32 }\n+    /// //                               ^^^^ point at this instead of the whole `if` expression\n+    /// ```\n+    fn get_expr_coercion_span(&self, expr: &hir::Expr<'_>) -> rustc_span::Span {\n+        if let hir::ExprKind::Match(_, arms, _) = &expr.kind {\n+            let arm_spans: Vec<Span> = arms\n+                .iter()\n+                .filter_map(|arm| {\n+                    self.in_progress_typeck_results\n+                        .and_then(|typeck_results| {\n+                            typeck_results.borrow().node_type_opt(arm.body.hir_id)\n+                        })\n+                        .and_then(|arm_ty| {\n+                            if arm_ty.is_never() {\n+                                None\n+                            } else {\n+                                Some(match &arm.body.kind {\n+                                    // Point at the tail expression when possible.\n+                                    hir::ExprKind::Block(block, _) => {\n+                                        block.expr.as_ref().map(|e| e.span).unwrap_or(block.span)\n+                                    }\n+                                    _ => arm.body.span,\n+                                })\n+                            }\n+                        })\n+                })\n+                .collect();\n+            if arm_spans.len() == 1 {\n+                return arm_spans[0];\n+            }\n+        }\n+        expr.span\n+    }\n+\n+    fn overwrite_local_ty_if_err(\n+        &self,\n+        local: &'tcx hir::Local<'tcx>,\n+        decl_ty: Ty<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) {\n+        if ty.references_error() {\n+            // Override the types everywhere with `err()` to avoid knock on errors.\n+            self.write_ty(local.hir_id, ty);\n+            self.write_ty(local.pat.hir_id, ty);\n+            let local_ty = LocalTy { decl_ty, revealed_ty: ty };\n+            self.locals.borrow_mut().insert(local.hir_id, local_ty);\n+            self.locals.borrow_mut().insert(local.pat.hir_id, local_ty);\n+        }\n+    }\n+\n+    // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n+    // The newly resolved definition is written into `type_dependent_defs`.\n+    fn finish_resolving_struct_path(\n+        &self,\n+        qpath: &QPath<'_>,\n+        path_span: Span,\n+        hir_id: hir::HirId,\n+    ) -> (Res, Ty<'tcx>) {\n+        match *qpath {\n+            QPath::Resolved(ref maybe_qself, ref path) => {\n+                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n+                let ty = AstConv::res_to_ty(self, self_ty, path, true);\n+                (path.res, ty)\n+            }\n+            QPath::TypeRelative(ref qself, ref segment) => {\n+                let ty = self.to_ty(qself);\n+\n+                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.kind {\n+                    path.res\n+                } else {\n+                    Res::Err\n+                };\n+                let result =\n+                    AstConv::associated_path_to_ty(self, hir_id, path_span, ty, res, segment, true);\n+                let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n+                let result = result.map(|(_, kind, def_id)| (kind, def_id));\n+\n+                // Write back the new resolution.\n+                self.write_resolution(hir_id, result);\n+\n+                (result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err), ty)\n+            }\n+            QPath::LangItem(lang_item, span) => {\n+                self.resolve_lang_item_path(lang_item, span, hir_id)\n+            }\n+        }\n+    }\n+\n+    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call argument expressions, we walk\n+    /// the checked and coerced types for each argument to see if any of the `FulfillmentError`s\n+    /// reference a type argument. The reason to walk also the checked type is that the coerced type\n+    /// can be not easily comparable with predicate type (because of coercion). If the types match\n+    /// for either checked or coerced type, and there's only *one* argument that does, we point at\n+    /// the corresponding argument's expression span instead of the `fn` call path span.\n+    fn point_at_arg_instead_of_call_if_possible(\n+        &self,\n+        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n+        final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n+        call_sp: Span,\n+        args: &'tcx [hir::Expr<'tcx>],\n+    ) {\n+        // We *do not* do this for desugared call spans to keep good diagnostics when involving\n+        // the `?` operator.\n+        if call_sp.desugaring_kind().is_some() {\n+            return;\n+        }\n+\n+        for error in errors {\n+            // Only if the cause is somewhere inside the expression we want try to point at arg.\n+            // Otherwise, it means that the cause is somewhere else and we should not change\n+            // anything because we can break the correct span.\n+            if !call_sp.contains(error.obligation.cause.span) {\n+                continue;\n+            }\n+\n+            if let ty::PredicateAtom::Trait(predicate, _) =\n+                error.obligation.predicate.skip_binders()\n+            {\n+                // Collect the argument position for all arguments that could have caused this\n+                // `FulfillmentError`.\n+                let mut referenced_in = final_arg_types\n+                    .iter()\n+                    .map(|&(i, checked_ty, _)| (i, checked_ty))\n+                    .chain(final_arg_types.iter().map(|&(i, _, coerced_ty)| (i, coerced_ty)))\n+                    .flat_map(|(i, ty)| {\n+                        let ty = self.resolve_vars_if_possible(&ty);\n+                        // We walk the argument type because the argument's type could have\n+                        // been `Option<T>`, but the `FulfillmentError` references `T`.\n+                        if ty.walk().any(|arg| arg == predicate.self_ty().into()) {\n+                            Some(i)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .collect::<Vec<usize>>();\n+\n+                // Both checked and coerced types could have matched, thus we need to remove\n+                // duplicates.\n+\n+                // We sort primitive type usize here and can use unstable sort\n+                referenced_in.sort_unstable();\n+                referenced_in.dedup();\n+\n+                if let (Some(ref_in), None) = (referenced_in.pop(), referenced_in.pop()) {\n+                    // We make sure that only *one* argument matches the obligation failure\n+                    // and we assign the obligation's span to its expression's.\n+                    error.obligation.cause.make_mut().span = args[ref_in].span;\n+                    error.points_at_arg_span = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call expression, we walk the\n+    /// `PathSegment`s and resolve their type parameters to see if any of the `FulfillmentError`s\n+    /// were caused by them. If they were, we point at the corresponding type argument's span\n+    /// instead of the `fn` call path span.\n+    fn point_at_type_arg_instead_of_call_if_possible(\n+        &self,\n+        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+    ) {\n+        if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n+            if let hir::ExprKind::Path(qpath) = &path.kind {\n+                if let hir::QPath::Resolved(_, path) = &qpath {\n+                    for error in errors {\n+                        if let ty::PredicateAtom::Trait(predicate, _) =\n+                            error.obligation.predicate.skip_binders()\n+                        {\n+                            // If any of the type arguments in this path segment caused the\n+                            // `FullfillmentError`, point at its span (#61860).\n+                            for arg in path\n+                                .segments\n+                                .iter()\n+                                .filter_map(|seg| seg.args.as_ref())\n+                                .flat_map(|a| a.args.iter())\n+                            {\n+                                if let hir::GenericArg::Type(hir_ty) = &arg {\n+                                    if let hir::TyKind::Path(hir::QPath::TypeRelative(..)) =\n+                                        &hir_ty.kind\n+                                    {\n+                                        // Avoid ICE with associated types. As this is best\n+                                        // effort only, it's ok to ignore the case. It\n+                                        // would trigger in `is_send::<T::AssocType>();`\n+                                        // from `typeck-default-trait-impl-assoc-type.rs`.\n+                                    } else {\n+                                        let ty = AstConv::ast_ty_to_ty(self, hir_ty);\n+                                        let ty = self.resolve_vars_if_possible(&ty);\n+                                        if ty == predicate.self_ty() {\n+                                            error.obligation.cause.make_mut().span = hir_ty.span;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "72c3b233ed934be694e3cf5f6ad2a2a22fdfcdf0", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -0,0 +1,295 @@\n+mod _impl;\n+mod checks;\n+mod suggestions;\n+\n+pub use _impl::*;\n+pub use checks::*;\n+pub use suggestions::*;\n+\n+use crate::astconv::AstConv;\n+use crate::check::coercion::DynamicCoerceMany;\n+use crate::check::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n+\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::hir::map::blocks::FnLikeNode;\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n+use rustc_session::Session;\n+use rustc_span::{self, Span};\n+use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode};\n+\n+use std::cell::{Cell, RefCell};\n+use std::ops::Deref;\n+\n+pub struct FnCtxt<'a, 'tcx> {\n+    pub(super) body_id: hir::HirId,\n+\n+    /// The parameter environment used for proving trait obligations\n+    /// in this function. This can change when we descend into\n+    /// closures (as they bring new things into scope), hence it is\n+    /// not part of `Inherited` (as of the time of this writing,\n+    /// closures do not yet change the environment, but they will\n+    /// eventually).\n+    pub(super) param_env: ty::ParamEnv<'tcx>,\n+\n+    /// Number of errors that had been reported when we started\n+    /// checking this function. On exit, if we find that *more* errors\n+    /// have been reported, we will skip regionck and other work that\n+    /// expects the types within the function to be consistent.\n+    // FIXME(matthewjasper) This should not exist, and it's not correct\n+    // if type checking is run in parallel.\n+    err_count_on_creation: usize,\n+\n+    /// If `Some`, this stores coercion information for returned\n+    /// expressions. If `None`, this is in a context where return is\n+    /// inappropriate, such as a const expression.\n+    ///\n+    /// This is a `RefCell<DynamicCoerceMany>`, which means that we\n+    /// can track all the return expressions and then use them to\n+    /// compute a useful coercion from the set, similar to a match\n+    /// expression or other branching context. You can use methods\n+    /// like `expected_ty` to access the declared return type (if\n+    /// any).\n+    pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n+\n+    pub(super) ret_coercion_impl_trait: Option<Ty<'tcx>>,\n+\n+    pub(super) ret_type_span: Option<Span>,\n+\n+    /// Used exclusively to reduce cost of advanced evaluation used for\n+    /// more helpful diagnostics.\n+    pub(super) in_tail_expr: bool,\n+\n+    /// First span of a return site that we find. Used in error messages.\n+    pub(super) ret_coercion_span: RefCell<Option<Span>>,\n+\n+    pub(super) resume_yield_tys: Option<(Ty<'tcx>, Ty<'tcx>)>,\n+\n+    pub(super) ps: RefCell<UnsafetyState>,\n+\n+    /// Whether the last checked node generates a divergence (e.g.,\n+    /// `return` will set this to `Always`). In general, when entering\n+    /// an expression or other node in the tree, the initial value\n+    /// indicates whether prior parts of the containing expression may\n+    /// have diverged. It is then typically set to `Maybe` (and the\n+    /// old value remembered) for processing the subparts of the\n+    /// current expression. As each subpart is processed, they may set\n+    /// the flag to `Always`, etc. Finally, at the end, we take the\n+    /// result and \"union\" it with the original value, so that when we\n+    /// return the flag indicates if any subpart of the parent\n+    /// expression (up to and including this part) has diverged. So,\n+    /// if you read it after evaluating a subexpression `X`, the value\n+    /// you get indicates whether any subexpression that was\n+    /// evaluating up to and including `X` diverged.\n+    ///\n+    /// We currently use this flag only for diagnostic purposes:\n+    ///\n+    /// - To warn about unreachable code: if, after processing a\n+    ///   sub-expression but before we have applied the effects of the\n+    ///   current node, we see that the flag is set to `Always`, we\n+    ///   can issue a warning. This corresponds to something like\n+    ///   `foo(return)`; we warn on the `foo()` expression. (We then\n+    ///   update the flag to `WarnedAlways` to suppress duplicate\n+    ///   reports.) Similarly, if we traverse to a fresh statement (or\n+    ///   tail expression) from a `Always` setting, we will issue a\n+    ///   warning. This corresponds to something like `{return;\n+    ///   foo();}` or `{return; 22}`, where we would warn on the\n+    ///   `foo()` or `22`.\n+    ///\n+    /// An expression represents dead code if, after checking it,\n+    /// the diverges flag is set to something other than `Maybe`.\n+    pub(super) diverges: Cell<Diverges>,\n+\n+    /// Whether any child nodes have any type errors.\n+    pub(super) has_errors: Cell<bool>,\n+\n+    pub(super) enclosing_breakables: RefCell<EnclosingBreakables<'tcx>>,\n+\n+    pub(super) inh: &'a Inherited<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn new(\n+        inh: &'a Inherited<'a, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+    ) -> FnCtxt<'a, 'tcx> {\n+        FnCtxt {\n+            body_id,\n+            param_env,\n+            err_count_on_creation: inh.tcx.sess.err_count(),\n+            ret_coercion: None,\n+            ret_coercion_impl_trait: None,\n+            ret_type_span: None,\n+            in_tail_expr: false,\n+            ret_coercion_span: RefCell::new(None),\n+            resume_yield_tys: None,\n+            ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n+            diverges: Cell::new(Diverges::Maybe),\n+            has_errors: Cell::new(false),\n+            enclosing_breakables: RefCell::new(EnclosingBreakables {\n+                stack: Vec::new(),\n+                by_id: Default::default(),\n+            }),\n+            inh,\n+        }\n+    }\n+\n+    pub fn cause(&self, span: Span, code: ObligationCauseCode<'tcx>) -> ObligationCause<'tcx> {\n+        ObligationCause::new(span, self.body_id, code)\n+    }\n+\n+    pub fn misc(&self, span: Span) -> ObligationCause<'tcx> {\n+        self.cause(span, ObligationCauseCode::MiscObligation)\n+    }\n+\n+    pub fn sess(&self) -> &Session {\n+        &self.tcx.sess\n+    }\n+\n+    pub fn errors_reported_since_creation(&self) -> bool {\n+        self.tcx.sess.err_count() > self.err_count_on_creation\n+    }\n+}\n+\n+impl<'a, 'tcx> Deref for FnCtxt<'a, 'tcx> {\n+    type Target = Inherited<'a, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.inh\n+    }\n+}\n+\n+impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn item_def_id(&self) -> Option<DefId> {\n+        None\n+    }\n+\n+    fn default_constness_for_trait_bounds(&self) -> hir::Constness {\n+        // FIXME: refactor this into a method\n+        let node = self.tcx.hir().get(self.body_id);\n+        if let Some(fn_like) = FnLikeNode::from_node(node) {\n+            fn_like.constness()\n+        } else {\n+            hir::Constness::NotConst\n+        }\n+    }\n+\n+    fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n+        let tcx = self.tcx;\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+        let item_id = tcx.hir().ty_param_owner(hir_id);\n+        let item_def_id = tcx.hir().local_def_id(item_id);\n+        let generics = tcx.generics_of(item_def_id);\n+        let index = generics.param_def_id_to_index[&def_id];\n+        ty::GenericPredicates {\n+            parent: None,\n+            predicates: tcx.arena.alloc_from_iter(\n+                self.param_env.caller_bounds().iter().filter_map(|predicate| {\n+                    match predicate.skip_binders() {\n+                        ty::PredicateAtom::Trait(data, _) if data.self_ty().is_param(index) => {\n+                            // HACK(eddyb) should get the original `Span`.\n+                            let span = tcx.def_span(def_id);\n+                            Some((predicate, span))\n+                        }\n+                        _ => None,\n+                    }\n+                }),\n+            ),\n+        }\n+    }\n+\n+    fn re_infer(&self, def: Option<&ty::GenericParamDef>, span: Span) -> Option<ty::Region<'tcx>> {\n+        let v = match def {\n+            Some(def) => infer::EarlyBoundRegion(span, def.name),\n+            None => infer::MiscVariable(span),\n+        };\n+        Some(self.next_region_var(v))\n+    }\n+\n+    fn allow_ty_infer(&self) -> bool {\n+        true\n+    }\n+\n+    fn ty_infer(&self, param: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n+        if let Some(param) = param {\n+            if let GenericArgKind::Type(ty) = self.var_for_def(span, param).unpack() {\n+                return ty;\n+            }\n+            unreachable!()\n+        } else {\n+            self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span,\n+            })\n+        }\n+    }\n+\n+    fn ct_infer(\n+        &self,\n+        ty: Ty<'tcx>,\n+        param: Option<&ty::GenericParamDef>,\n+        span: Span,\n+    ) -> &'tcx Const<'tcx> {\n+        if let Some(param) = param {\n+            if let GenericArgKind::Const(ct) = self.var_for_def(span, param).unpack() {\n+                return ct;\n+            }\n+            unreachable!()\n+        } else {\n+            self.next_const_var(\n+                ty,\n+                ConstVariableOrigin { kind: ConstVariableOriginKind::ConstInference, span },\n+            )\n+        }\n+    }\n+\n+    fn projected_ty_from_poly_trait_ref(\n+        &self,\n+        span: Span,\n+        item_def_id: DefId,\n+        item_segment: &hir::PathSegment<'_>,\n+        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let (trait_ref, _) = self.replace_bound_vars_with_fresh_vars(\n+            span,\n+            infer::LateBoundRegionConversionTime::AssocTypeProjection(item_def_id),\n+            &poly_trait_ref,\n+        );\n+\n+        let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n+            self,\n+            self.tcx,\n+            span,\n+            item_def_id,\n+            item_segment,\n+            trait_ref.substs,\n+        );\n+\n+        self.tcx().mk_projection(item_def_id, item_substs)\n+    }\n+\n+    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if ty.has_escaping_bound_vars() {\n+            ty // FIXME: normalization and escaping regions\n+        } else {\n+            self.normalize_associated_types_in(span, &ty)\n+        }\n+    }\n+\n+    fn set_tainted_by_errors(&self) {\n+        self.infcx.set_tainted_by_errors()\n+    }\n+\n+    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, _span: Span) {\n+        self.write_ty(hir_id, ty)\n+    }\n+}"}, {"sha": "9bad02c41b4b1fa2e7574eb604c72a3fe918f7a3", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "added", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -0,0 +1,528 @@\n+use super::FnCtxt;\n+use crate::astconv::AstConv;\n+\n+use rustc_ast::util::parser::ExprPrecedence;\n+use rustc_span::{self, Span};\n+use rustc_trait_selection::traits;\n+\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def::{CtorOf, DefKind};\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{ExprKind, ItemKind, Node};\n+use rustc_infer::infer;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::kw;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n+\n+use std::iter;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(in super::super) fn suggest_semicolon_at_end(\n+        &self,\n+        span: Span,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        err.span_suggestion_short(\n+            span.shrink_to_hi(),\n+            \"consider using a semicolon here\",\n+            \";\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    /// On implicit return expressions with mismatched types, provides the following suggestions:\n+    ///\n+    /// - Points out the method's return type as the reason for the expected type.\n+    /// - Possible missing semicolon.\n+    /// - Possible missing return type if the return type is the default, and not `fn main()`.\n+    pub fn suggest_mismatched_types_on_tail(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        cause_span: Span,\n+        blk_id: hir::HirId,\n+    ) -> bool {\n+        let expr = expr.peel_drop_temps();\n+        self.suggest_missing_semicolon(err, expr, expected, cause_span);\n+        let mut pointing_at_return_type = false;\n+        if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n+            pointing_at_return_type =\n+                self.suggest_missing_return_type(err, &fn_decl, expected, found, can_suggest);\n+        }\n+        pointing_at_return_type\n+    }\n+\n+    /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n+    /// the ctor would successfully solve the type mismatch and if so, suggest it:\n+    /// ```\n+    /// fn foo(x: usize) -> usize { x }\n+    /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n+    /// ```\n+    fn suggest_fn_call(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        let hir = self.tcx.hir();\n+        let (def_id, sig) = match *found.kind() {\n+            ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n+            ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig()),\n+            _ => return false,\n+        };\n+\n+        let sig = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig).0;\n+        let sig = self.normalize_associated_types_in(expr.span, &sig);\n+        if self.can_coerce(sig.output(), expected) {\n+            let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n+                (String::new(), Applicability::MachineApplicable)\n+            } else {\n+                (\"...\".to_string(), Applicability::HasPlaceholders)\n+            };\n+            let mut msg = \"call this function\";\n+            match hir.get_if_local(def_id) {\n+                Some(\n+                    Node::Item(hir::Item { kind: ItemKind::Fn(.., body_id), .. })\n+                    | Node::ImplItem(hir::ImplItem {\n+                        kind: hir::ImplItemKind::Fn(_, body_id), ..\n+                    })\n+                    | Node::TraitItem(hir::TraitItem {\n+                        kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Provided(body_id)),\n+                        ..\n+                    }),\n+                ) => {\n+                    let body = hir.body(*body_id);\n+                    sugg_call = body\n+                        .params\n+                        .iter()\n+                        .map(|param| match &param.pat.kind {\n+                            hir::PatKind::Binding(_, _, ident, None)\n+                                if ident.name != kw::SelfLower =>\n+                            {\n+                                ident.to_string()\n+                            }\n+                            _ => \"_\".to_string(),\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \");\n+                }\n+                Some(Node::Expr(hir::Expr {\n+                    kind: ExprKind::Closure(_, _, body_id, _, _),\n+                    span: full_closure_span,\n+                    ..\n+                })) => {\n+                    if *full_closure_span == expr.span {\n+                        return false;\n+                    }\n+                    msg = \"call this closure\";\n+                    let body = hir.body(*body_id);\n+                    sugg_call = body\n+                        .params\n+                        .iter()\n+                        .map(|param| match &param.pat.kind {\n+                            hir::PatKind::Binding(_, _, ident, None)\n+                                if ident.name != kw::SelfLower =>\n+                            {\n+                                ident.to_string()\n+                            }\n+                            _ => \"_\".to_string(),\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \");\n+                }\n+                Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n+                    sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                    match def_id.as_local().map(|def_id| hir.def_kind(def_id)) {\n+                        Some(DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n+                            msg = \"instantiate this tuple variant\";\n+                        }\n+                        Some(DefKind::Ctor(CtorOf::Struct, _)) => {\n+                            msg = \"instantiate this tuple struct\";\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                Some(Node::ForeignItem(hir::ForeignItem {\n+                    kind: hir::ForeignItemKind::Fn(_, idents, _),\n+                    ..\n+                })) => {\n+                    sugg_call = idents\n+                        .iter()\n+                        .map(|ident| {\n+                            if ident.name != kw::SelfLower {\n+                                ident.to_string()\n+                            } else {\n+                                \"_\".to_string()\n+                            }\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                }\n+                Some(Node::TraitItem(hir::TraitItem {\n+                    kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Required(idents)),\n+                    ..\n+                })) => {\n+                    sugg_call = idents\n+                        .iter()\n+                        .map(|ident| {\n+                            if ident.name != kw::SelfLower {\n+                                ident.to_string()\n+                            } else {\n+                                \"_\".to_string()\n+                            }\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                }\n+                _ => {}\n+            }\n+            err.span_suggestion_verbose(\n+                expr.span.shrink_to_hi(),\n+                &format!(\"use parentheses to {}\", msg),\n+                format!(\"({})\", sugg_call),\n+                applicability,\n+            );\n+            return true;\n+        }\n+        false\n+    }\n+\n+    pub fn suggest_deref_ref_or_into(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+    ) {\n+        if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n+            err.span_suggestion(sp, msg, suggestion, applicability);\n+        } else if let (ty::FnDef(def_id, ..), true) =\n+            (&found.kind(), self.suggest_fn_call(err, expr, expected, found))\n+        {\n+            if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n+                let sp = self.sess().source_map().guess_head_span(sp);\n+                err.span_label(sp, &format!(\"{} defined here\", found));\n+            }\n+        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n+            let is_struct_pat_shorthand_field =\n+                self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n+            let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n+            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n+                let mut suggestions = iter::repeat(&expr_text)\n+                    .zip(methods.iter())\n+                    .filter_map(|(receiver, method)| {\n+                        let method_call = format!(\".{}()\", method.ident);\n+                        if receiver.ends_with(&method_call) {\n+                            None // do not suggest code that is already there (#53348)\n+                        } else {\n+                            let method_call_list = [\".to_vec()\", \".to_string()\"];\n+                            let sugg = if receiver.ends_with(\".clone()\")\n+                                && method_call_list.contains(&method_call.as_str())\n+                            {\n+                                let max_len = receiver.rfind('.').unwrap();\n+                                format!(\"{}{}\", &receiver[..max_len], method_call)\n+                            } else {\n+                                if expr.precedence().order() < ExprPrecedence::MethodCall.order() {\n+                                    format!(\"({}){}\", receiver, method_call)\n+                                } else {\n+                                    format!(\"{}{}\", receiver, method_call)\n+                                }\n+                            };\n+                            Some(if is_struct_pat_shorthand_field {\n+                                format!(\"{}: {}\", receiver, sugg)\n+                            } else {\n+                                sugg\n+                            })\n+                        }\n+                    })\n+                    .peekable();\n+                if suggestions.peek().is_some() {\n+                    err.span_suggestions(\n+                        expr.span,\n+                        \"try using a conversion method\",\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n+    /// in the heap by calling `Box::new()`.\n+    pub(in super::super) fn suggest_boxing_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return;\n+        }\n+        if !expected.is_box() || found.is_box() {\n+            return;\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(boxed_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            err.span_suggestion(\n+                expr.span,\n+                \"store this in the heap by calling `Box::new`\",\n+                format!(\"Box::new({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(\n+                \"for more on the distinction between the stack and the heap, read \\\n+                 https://doc.rust-lang.org/book/ch15-01-box.html, \\\n+                 https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n+                 https://doc.rust-lang.org/std/boxed/index.html\",\n+            );\n+        }\n+    }\n+\n+    /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n+    pub(in super::super) fn suggest_calling_boxed_future_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        // Handle #68197.\n+\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return false;\n+        }\n+        let pin_did = self.tcx.lang_items().pin_type();\n+        match expected.kind() {\n+            ty::Adt(def, _) if Some(def.did) != pin_did => return false,\n+            // This guards the `unwrap` and `mk_box` below.\n+            _ if pin_did.is_none() || self.tcx.lang_items().owned_box().is_none() => return false,\n+            _ => {}\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        let new_found = self.tcx.mk_lang_item(boxed_found, LangItem::Pin).unwrap();\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(new_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            match found.kind() {\n+                ty::Adt(def, _) if def.is_box() => {\n+                    err.help(\"use `Box::pin`\");\n+                }\n+                _ => {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        \"you need to pin and box this expression\",\n+                        format!(\"Box::pin({})\", snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n+    ///\n+    /// ```\n+    /// fn foo() {\n+    ///     bar_that_returns_u32()\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the return expression in a block would make sense on its own as a\n+    /// statement and the return type has been left as default or has been specified as `()`. If so,\n+    /// it suggests adding a semicolon.\n+    fn suggest_missing_semicolon(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expression: &'tcx hir::Expr<'tcx>,\n+        expected: Ty<'tcx>,\n+        cause_span: Span,\n+    ) {\n+        if expected.is_unit() {\n+            // `BlockTailExpression` only relevant if the tail expr would be\n+            // useful on its own.\n+            match expression.kind {\n+                ExprKind::Call(..)\n+                | ExprKind::MethodCall(..)\n+                | ExprKind::Loop(..)\n+                | ExprKind::Match(..)\n+                | ExprKind::Block(..) => {\n+                    err.span_suggestion(\n+                        cause_span.shrink_to_hi(),\n+                        \"try adding a semicolon\",\n+                        \";\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    /// A possible error is to forget to add a return type that is needed:\n+    ///\n+    /// ```\n+    /// fn foo() {\n+    ///     bar_that_returns_u32()\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the return type is left as default, the method is not part of an\n+    /// `impl` block and that it isn't the `main` method. If so, it suggests setting the return\n+    /// type.\n+    pub(in super::super) fn suggest_missing_return_type(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        fn_decl: &hir::FnDecl<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        can_suggest: bool,\n+    ) -> bool {\n+        // Only suggest changing the return type for methods that\n+        // haven't set a return type at all (and aren't `fn main()` or an impl).\n+        match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_unit()) {\n+            (&hir::FnRetTy::DefaultReturn(span), true, true, true) => {\n+                err.span_suggestion(\n+                    span,\n+                    \"try adding a return type\",\n+                    format!(\"-> {} \", self.resolve_vars_with_obligations(found)),\n+                    Applicability::MachineApplicable,\n+                );\n+                true\n+            }\n+            (&hir::FnRetTy::DefaultReturn(span), false, true, true) => {\n+                err.span_label(span, \"possibly return type missing here?\");\n+                true\n+            }\n+            (&hir::FnRetTy::DefaultReturn(span), _, false, true) => {\n+                // `fn main()` must return `()`, do not suggest changing return type\n+                err.span_label(span, \"expected `()` because of default return type\");\n+                true\n+            }\n+            // expectation was caused by something else, not the default return\n+            (&hir::FnRetTy::DefaultReturn(_), _, _, false) => false,\n+            (&hir::FnRetTy::Return(ref ty), _, _, _) => {\n+                // Only point to return type if the expected type is the return type, as if they\n+                // are not, the expectation must have been caused by something else.\n+                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n+                let sp = ty.span;\n+                let ty = AstConv::ast_ty_to_ty(self, ty);\n+                debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n+                debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n+                if ty.kind() == expected.kind() {\n+                    err.span_label(sp, format!(\"expected `{}` because of return type\", expected));\n+                    return true;\n+                }\n+                false\n+            }\n+        }\n+    }\n+\n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n+    pub(in super::super) fn suggest_missing_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        debug!(\"suggest_missing_await: expr={:?} expected={:?}, found={:?}\", expr, expected, found);\n+        // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n+        // body isn't `async`.\n+        let item_id = self.tcx().hir().get_parent_node(self.body_id);\n+        if let Some(body_id) = self.tcx().hir().maybe_body_owned_by(item_id) {\n+            let body = self.tcx().hir().body(body_id);\n+            if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n+                let sp = expr.span;\n+                // Check for `Future` implementations by constructing a predicate to\n+                // prove: `<T as Future>::Output == U`\n+                let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(sp));\n+                let item_def_id = self\n+                    .tcx\n+                    .associated_items(future_trait)\n+                    .in_definition_order()\n+                    .next()\n+                    .unwrap()\n+                    .def_id;\n+                // `<T as Future>::Output`\n+                let projection_ty = ty::ProjectionTy {\n+                    // `T`\n+                    substs: self\n+                        .tcx\n+                        .mk_substs_trait(found, self.fresh_substs_for_item(sp, item_def_id)),\n+                    // `Future::Output`\n+                    item_def_id,\n+                };\n+\n+                let predicate = ty::PredicateAtom::Projection(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    ty: expected,\n+                })\n+                .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n+                let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n+\n+                debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n+\n+                if self.infcx.predicate_may_hold(&obligation) {\n+                    debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n+                    if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider using `.await` here\",\n+                            format!(\"{}.await\", code),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        debug!(\"suggest_missing_await: no snippet for {:?}\", sp);\n+                    }\n+                } else {\n+                    debug!(\"suggest_missing_await: obligation did not hold: {:?}\", obligation)\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(in super::super) fn suggest_missing_parentheses(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+    ) {\n+        let sp = self.tcx.sess.source_map().start_point(expr.span);\n+        if let Some(sp) = self.tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+            // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n+            self.tcx.sess.parse_sess.expr_parentheses_needed(err, *sp, None);\n+        }\n+    }\n+}"}, {"sha": "24ffe944128c93880fa03f045a11f75b3be125cf", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -96,7 +96,7 @@ use check::{\n pub use check::{check_item_type, check_wf_new};\n pub use diverges::Diverges;\n pub use expectation::Expectation;\n-pub use fn_ctxt::FnCtxt;\n+pub use fn_ctxt::*;\n pub use inherited::{Inherited, InheritedBuilder};\n \n use crate::astconv::AstConv;"}, {"sha": "109c3a0e68302338b0a5e133e9c7371c91e3f989", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -14,9 +14,9 @@ mod tests;\n \n extern \"Rust\" {\n     // These are the magic symbols to call the global allocator.  rustc generates\n-    // them to call `__rg_alloc` etc if there is a `#[global_allocator]` attribute\n+    // them to call `__rg_alloc` etc. if there is a `#[global_allocator]` attribute\n     // (the code expanding that attribute macro generates those functions), or to call\n-    // the default implementations in libstd (`__rdl_alloc` etc in `src/libstd/alloc.rs`)\n+    // the default implementations in libstd (`__rdl_alloc` etc. in `library/std/src/alloc.rs`)\n     // otherwise.\n     #[rustc_allocator]\n     #[rustc_allocator_nounwind]\n@@ -36,7 +36,7 @@ extern \"Rust\" {\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// Note: while this type is unstable, the functionality it provides can be\n-/// accessed through the [free functions in `alloc`](index.html#functions).\n+/// accessed through the [free functions in `alloc`](self#functions).\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;"}, {"sha": "7140218fa9101fbb4faa06a4ab29963fbcda6794", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -226,7 +226,7 @@ use crate::ptr;\n /// assert_eq!(my_struct.special_field.get(), new_value);\n /// ```\n ///\n-/// See the [module-level documentation](index.html) for more.\n+/// See the [module-level documentation](self) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(transparent)]\n pub struct Cell<T: ?Sized> {\n@@ -566,7 +566,7 @@ impl<T> Cell<[T]> {\n \n /// A mutable memory location with dynamically checked borrow rules\n ///\n-/// See the [module-level documentation](index.html) for more.\n+/// See the [module-level documentation](self) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T: ?Sized> {\n     borrow: Cell<BorrowFlag>,\n@@ -1203,7 +1203,7 @@ impl Clone for BorrowRef<'_> {\n /// Wraps a borrowed reference to a value in a `RefCell` box.\n /// A wrapper type for an immutably borrowed value from a `RefCell<T>`.\n ///\n-/// See the [module-level documentation](index.html) for more.\n+/// See the [module-level documentation](self) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ref<'b, T: ?Sized + 'b> {\n     value: &'b T,\n@@ -1493,7 +1493,7 @@ impl<'b> BorrowRefMut<'b> {\n \n /// A wrapper type for a mutably borrowed value from a `RefCell<T>`.\n ///\n-/// See the [module-level documentation](index.html) for more.\n+/// See the [module-level documentation](self) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefMut<'b, T: ?Sized + 'b> {\n     value: &'b mut T,"}, {"sha": "44da8f4715c88d371066860a3927cae255bcf4fb", "filename": "library/core/src/iter/sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -501,9 +501,9 @@ pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n ///\n /// # Examples\n ///\n-/// Let\u2019s re-implement the counter iterator from [module-level documentation]:\n+/// Let\u2019s re-implement the counter iterator from the [module-level documentation]:\n ///\n-/// [module-level documentation]: index.html\n+/// [module-level documentation]: super\n ///\n /// ```\n /// let mut count = 0;"}, {"sha": "1ae6d15c12dd97a4407a1366dc4f34449ff0ac5e", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -94,7 +94,7 @@ pub trait FromIterator<A>: Sized {\n     ///\n     /// See the [module-level documentation] for more.\n     ///\n-    /// [module-level documentation]: index.html\n+    /// [module-level documentation]: crate::iter\n     ///\n     /// # Examples\n     ///\n@@ -120,7 +120,7 @@ pub trait FromIterator<A>: Sized {\n /// collection of some kind.\n ///\n /// One benefit of implementing `IntoIterator` is that your type will [work\n-/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n+/// with Rust's `for` loop syntax](crate::iter#for-loops-and-intoiterator).\n ///\n /// See also: [`FromIterator`].\n ///\n@@ -212,7 +212,7 @@ pub trait IntoIterator {\n     ///\n     /// See the [module-level documentation] for more.\n     ///\n-    /// [module-level documentation]: index.html\n+    /// [module-level documentation]: crate::iter\n     ///\n     /// # Examples\n     ///"}, {"sha": "eadbdf45c7c6ff43740c23f0dae7765a6737208e", "filename": "library/core/src/iter/traits/exact_size.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fexact_size.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -26,10 +26,10 @@\n /// assert_eq!(5, five.len());\n /// ```\n ///\n-/// In the [module level docs][moddocs], we implemented an [`Iterator`],\n-/// `Counter`. Let's implement `ExactSizeIterator` for it as well:\n+/// In the [module-level docs], we implemented an [`Iterator`], `Counter`.\n+/// Let's implement `ExactSizeIterator` for it as well:\n ///\n-/// [moddocs]: index.html\n+/// [module-level docs]: crate::iter\n ///\n /// ```\n /// # struct Counter {"}, {"sha": "b6d9f13d881e321ce6fbc5e916c29688d5dcd62b", "filename": "library/core/src/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -233,7 +233,7 @@ use crate::{convert, fmt};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n ///\n-/// See the [`std::result`](index.html) module documentation for details.\n+/// See the [module documentation](self) for details.\n #[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[must_use = \"this `Result` may be an `Err` variant, which should be handled\"]\n #[rustc_diagnostic_item = \"result_type\"]"}, {"sha": "7e7a28be2b0e577fd434a8ca634b5cdef70bce80", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -69,7 +69,7 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// [`&OsStr`]: OsStr\n /// [`&str`]: str\n /// [`CStr`]: crate::ffi::CStr\n-/// [conversions]: index.html#conversions\n+/// [conversions]: super#conversions\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OsString {\n@@ -88,7 +88,7 @@ pub struct OsString {\n /// the traits which `OsStr` implements for [conversions] from/to native representations.\n ///\n /// [`&str`]: str\n-/// [conversions]: index.html#conversions\n+/// [conversions]: super#conversions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n // `OsStr::from_inner` current implementation relies"}, {"sha": "50bd2a03b62b04cd5b998d0e0c075e4695324b18", "filename": "library/std/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -1009,7 +1009,7 @@ impl FusedIterator for Ancestors<'_> {}\n /// [`set_extension`]: PathBuf::set_extension\n ///\n /// More details about the overall approach can be found in\n-/// the [module documentation](index.html).\n+/// the [module documentation](self).\n ///\n /// # Examples\n ///\n@@ -1655,7 +1655,7 @@ impl AsRef<OsStr> for PathBuf {\n /// see [`PathBuf`].\n ///\n /// More details about the overall approach can be found in\n-/// the [module documentation](index.html).\n+/// the [module documentation](self).\n ///\n /// # Examples\n ///"}, {"sha": "5215ab3dd4f9bbe077f9013ddb8e7967aa31a25e", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -234,25 +234,25 @@ pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, car\n         // Note that `libprofiler_builtins/build.rs` also computes this so if\n         // you're changing something here please also change that.\n         cargo.env(\"RUST_COMPILER_RT_ROOT\", &compiler_builtins_root);\n-        \" compiler-builtins-c\".to_string()\n+        \" compiler-builtins-c\"\n     } else {\n-        String::new()\n+        \"\"\n     };\n \n     if builder.no_std(target) == Some(true) {\n         let mut features = \"compiler-builtins-mem\".to_string();\n-        features.push_str(&compiler_builtins_c_feature);\n+        features.push_str(compiler_builtins_c_feature);\n \n         // for no-std targets we only compile a few no_std crates\n         cargo\n             .args(&[\"-p\", \"alloc\"])\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(\"library/alloc/Cargo.toml\"))\n             .arg(\"--features\")\n-            .arg(\"compiler-builtins-mem compiler-builtins-c\");\n+            .arg(features);\n     } else {\n         let mut features = builder.std_features();\n-        features.push_str(&compiler_builtins_c_feature);\n+        features.push_str(compiler_builtins_c_feature);\n \n         cargo\n             .arg(\"--features\")"}, {"sha": "b2d343fd7af6a7105198d6120e643457fcd31f2c", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -207,30 +207,46 @@ def children(self):\n         yield \"borrow\", self.borrow\n \n \n-# Yield each key (and optionally value) from a BoxedNode.\n-def children_of_node(boxed_node, height, want_values):\n+# Yields children (in a provider's sense of the word) for a tree headed by a BoxedNode.\n+# In particular, yields each key/value pair in the node and in any child nodes.\n+def children_of_node(boxed_node, height):\n     def cast_to_internal(node):\n-        internal_type_name = str(node.type.target()).replace(\"LeafNode\", \"InternalNode\", 1)\n+        internal_type_name = node.type.target().name.replace(\"LeafNode\", \"InternalNode\", 1)\n         internal_type = lookup_type(internal_type_name)\n         return node.cast(internal_type.pointer())\n \n     node_ptr = unwrap_unique_or_non_null(boxed_node[\"ptr\"])\n-    node_ptr = cast_to_internal(node_ptr) if height > 0 else node_ptr\n-    leaf = node_ptr[\"data\"] if height > 0 else node_ptr.dereference()\n+    leaf = node_ptr.dereference()\n     keys = leaf[\"keys\"]\n-    values = leaf[\"vals\"]\n+    vals = leaf[\"vals\"]\n+    edges = cast_to_internal(node_ptr)[\"edges\"] if height > 0 else None\n     length = int(leaf[\"len\"])\n \n     for i in xrange(0, length + 1):\n         if height > 0:\n-            child_ptr = node_ptr[\"edges\"][i][\"value\"][\"value\"]\n-            for child in children_of_node(child_ptr, height - 1, want_values):\n+            boxed_child_node = edges[i][\"value\"][\"value\"]\n+            for child in children_of_node(boxed_child_node, height - 1):\n                 yield child\n         if i < length:\n-            if want_values:\n-                yield keys[i][\"value\"][\"value\"], values[i][\"value\"][\"value\"]\n-            else:\n-                yield keys[i][\"value\"][\"value\"]\n+            # Avoid \"Cannot perform pointer math on incomplete type\" on zero-sized arrays.\n+            key = keys[i][\"value\"][\"value\"] if keys.type.sizeof > 0 else None\n+            val = vals[i][\"value\"][\"value\"] if vals.type.sizeof > 0 else None\n+            yield key, val\n+\n+\n+# Yields children for a BTreeMap.\n+def children_of_map(map):\n+    if map[\"length\"] > 0:\n+        root = map[\"root\"]\n+        if root.type.name.startswith(\"core::option::Option<\"):\n+            root = root.cast(gdb.lookup_type(root.type.name[21:-1]))\n+        boxed_root_node = root[\"node\"]\n+        height = root[\"height\"]\n+        for i, (key, val) in enumerate(children_of_node(boxed_root_node, height)):\n+            if key is not None:\n+                yield \"key{}\".format(i), key\n+            if val is not None:\n+                yield \"val{}\".format(i), val\n \n \n class StdBTreeSetProvider:\n@@ -242,15 +258,8 @@ def to_string(self):\n \n     def children(self):\n         inner_map = self.valobj[\"map\"]\n-        if inner_map[\"length\"] > 0:\n-            root = inner_map[\"root\"]\n-            if \"core::option::Option<\" in root.type.name:\n-                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n-                root = root.cast(gdb.lookup_type(type_name))\n-\n-            node_ptr = root[\"node\"]\n-            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], False)):\n-                yield \"[{}]\".format(i), child\n+        for child in children_of_map(inner_map):\n+            yield child\n \n     @staticmethod\n     def display_hint():\n@@ -265,16 +274,8 @@ def to_string(self):\n         return \"BTreeMap(size={})\".format(self.valobj[\"length\"])\n \n     def children(self):\n-        if self.valobj[\"length\"] > 0:\n-            root = self.valobj[\"root\"]\n-            if \"core::option::Option<\" in root.type.name:\n-                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n-                root = root.cast(gdb.lookup_type(type_name))\n-\n-            node_ptr = root[\"node\"]\n-            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], True)):\n-                yield \"key{}\".format(i), child[0]\n-                yield \"val{}\".format(i), child[1]\n+        for child in children_of_map(self.valobj):\n+            yield child\n \n     @staticmethod\n     def display_hint():"}, {"sha": "6267b02e5d2c48c10ae6aa7bdb5b252bf5ed7a05", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -130,7 +130,7 @@ pub fn try_inline(\n         attrs,\n         inner,\n         visibility: clean::Public,\n-        stability: cx.tcx.lookup_stability(did).clean(cx),\n+        stability: cx.tcx.lookup_stability(did).cloned(),\n         deprecation: cx.tcx.lookup_deprecation(did).clean(cx),\n         def_id: did,\n     });\n@@ -461,7 +461,7 @@ pub fn build_impl(\n         name: None,\n         attrs,\n         visibility: clean::Inherited,\n-        stability: tcx.lookup_stability(did).clean(cx),\n+        stability: tcx.lookup_stability(did).cloned(),\n         deprecation: tcx.lookup_deprecation(did).clean(cx),\n         def_id: did,\n     });"}, {"sha": "776b131a076110c4c6a381493acd488feaab2579", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -19,7 +19,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n use rustc_middle::bug;\n use rustc_middle::middle::resolve_lifetime as rl;\n-use rustc_middle::middle::stability;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{self, AdtKind, Lift, Ty, TyCtxt};\n@@ -274,7 +273,7 @@ impl Clean<Item> for doctree::Module<'_> {\n             attrs,\n             source: span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: ModuleItem(Module { is_crate: self.is_crate, items }),\n@@ -914,7 +913,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: did.to_def_id(),\n             inner: FunctionItem(Function {\n@@ -1023,7 +1022,7 @@ impl Clean<Item> for doctree::Trait<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: TraitItem(Trait {\n                 auto: self.is_auto.clean(cx),\n@@ -1047,7 +1046,7 @@ impl Clean<Item> for doctree::TraitAlias<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: TraitAliasItem(TraitAlias {\n                 generics: self.generics.clean(cx),\n@@ -1832,7 +1831,7 @@ impl Clean<Item> for doctree::Struct<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: StructItem(Struct {\n                 struct_type: self.struct_type,\n@@ -1852,7 +1851,7 @@ impl Clean<Item> for doctree::Union<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: UnionItem(Union {\n                 struct_type: self.struct_type,\n@@ -1882,7 +1881,7 @@ impl Clean<Item> for doctree::Enum<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: EnumItem(Enum {\n                 variants: self.variants.iter().map(|v| v.clean(cx)).collect(),\n@@ -1900,7 +1899,7 @@ impl Clean<Item> for doctree::Variant<'_> {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: Inherited,\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: VariantItem(Variant { kind: self.def.clean(cx) }),\n@@ -2049,7 +2048,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n         }\n@@ -2064,7 +2063,7 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: OpaqueTyItem(OpaqueTy {\n                 bounds: self.opaque_ty.bounds.clean(cx),\n@@ -2092,7 +2091,7 @@ impl Clean<Item> for doctree::Static<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(cx),\n@@ -2113,7 +2112,7 @@ impl Clean<Item> for doctree::Constant<'_> {\n             source: self.span.clean(cx),\n             def_id: def_id.to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n@@ -2167,7 +2166,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             source: self.span.clean(cx),\n             def_id: def_id.to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n@@ -2349,7 +2348,7 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             inner,\n         }\n@@ -2364,7 +2363,7 @@ impl Clean<Item> for doctree::Macro<'_> {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: Public,\n-            stability: cx.stability(self.hid).clean(cx),\n+            stability: cx.stability(self.hid),\n             deprecation: cx.deprecation(self.hid).clean(cx),\n             def_id: self.def_id,\n             inner: MacroItem(Macro {\n@@ -2389,35 +2388,14 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: Public,\n-            stability: cx.stability(self.id).clean(cx),\n+            stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             inner: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n         }\n     }\n }\n \n-impl Clean<Stability> for attr::Stability {\n-    fn clean(&self, _: &DocContext<'_>) -> Stability {\n-        Stability {\n-            level: stability::StabilityLevel::from_attr_level(&self.level),\n-            feature: self.feature.to_string(),\n-            since: match self.level {\n-                attr::Stable { ref since } => since.to_string(),\n-                _ => String::new(),\n-            },\n-            unstable_reason: match self.level {\n-                attr::Unstable { reason: Some(ref reason), .. } => Some(reason.to_string()),\n-                _ => None,\n-            },\n-            issue: match self.level {\n-                attr::Unstable { issue, .. } => issue,\n-                _ => None,\n-            },\n-        }\n-    }\n-}\n-\n impl Clean<Deprecation> for attr::Deprecation {\n     fn clean(&self, _: &DocContext<'_>) -> Deprecation {\n         Deprecation {"}, {"sha": "3b72cf5c4f97a8a48f467bebf887ca3b1f5fbe5b", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -4,7 +4,6 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n use std::lazy::SyncOnceCell as OnceCell;\n-use std::num::NonZeroU32;\n use std::rc::Rc;\n use std::sync::Arc;\n use std::{slice, vec};\n@@ -13,18 +12,18 @@ use rustc_ast::attr;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast::{self as ast, AttrStyle};\n use rustc_ast::{FloatTy, IntTy, UintTy};\n+use rustc_attr::{Stability, StabilityLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::stability;\n use rustc_middle::ty::{AssocKind, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol, SymbolStr};\n use rustc_span::{self, FileName};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n@@ -197,7 +196,7 @@ impl Item {\n         self.stability.as_ref().and_then(|ref s| {\n             let mut classes = Vec::with_capacity(2);\n \n-            if s.level == stability::Unstable {\n+            if s.level.is_unstable() {\n                 classes.push(\"unstable\");\n             }\n \n@@ -210,8 +209,11 @@ impl Item {\n         })\n     }\n \n-    pub fn stable_since(&self) -> Option<&str> {\n-        self.stability.as_ref().map(|s| &s.since[..])\n+    pub fn stable_since(&self) -> Option<SymbolStr> {\n+        match self.stability?.level {\n+            StabilityLevel::Stable { since, .. } => Some(since.as_str()),\n+            StabilityLevel::Unstable { .. } => None,\n+        }\n     }\n \n     pub fn is_non_exhaustive(&self) -> bool {\n@@ -1698,15 +1700,6 @@ pub struct ProcMacro {\n     pub helpers: Vec<String>,\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Stability {\n-    pub level: stability::StabilityLevel,\n-    pub feature: String,\n-    pub since: String,\n-    pub unstable_reason: Option<String>,\n-    pub issue: Option<NonZeroU32>,\n-}\n-\n #[derive(Clone, Debug)]\n pub struct Deprecation {\n     pub since: Option<String>,"}, {"sha": "9a7f1964a1157de8fe4c33067aae93aa04f83b25", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -3,12 +3,13 @@ use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, Deprecation, ExternalCrate, FnDecl, FnRetTy, Generic, GenericArg,\n     GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemEnum, Lifetime,\n-    MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Stability, Type,\n-    TypeBinding, TypeKind, Visibility, WherePredicate,\n+    MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Type, TypeBinding,\n+    TypeKind, Visibility, WherePredicate,\n };\n use crate::core::DocContext;\n \n use itertools::Itertools;\n+use rustc_attr::Stability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -102,7 +103,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n \n // extract the stability index for a node from tcx, if possible\n pub fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n-    cx.tcx.lookup_stability(def_id).clean(cx)\n+    cx.tcx.lookup_stability(def_id).cloned()\n }\n \n pub fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {"}, {"sha": "f81ea0f6d46ac89904c66bb4d13befea2ffdebd4", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -49,6 +49,7 @@ use std::sync::Arc;\n \n use itertools::Itertools;\n use rustc_ast_pretty::pprust;\n+use rustc_attr::StabilityLevel;\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_feature::UnstableFeatures;\n@@ -1983,10 +1984,12 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n         }\n         let s1 = i1.stability.as_ref().map(|s| s.level);\n         let s2 = i2.stability.as_ref().map(|s| s.level);\n-        match (s1, s2) {\n-            (Some(stability::Unstable), Some(stability::Stable)) => return Ordering::Greater,\n-            (Some(stability::Stable), Some(stability::Unstable)) => return Ordering::Less,\n-            _ => {}\n+        if let (Some(a), Some(b)) = (s1, s2) {\n+            match (a.is_stable(), b.is_stable()) {\n+                (true, true) | (false, false) => {}\n+                (false, true) => return Ordering::Less,\n+                (true, false) => return Ordering::Greater,\n+            }\n         }\n         let lhs = i1.name.as_ref().map_or(\"\", |s| &**s);\n         let rhs = i2.name.as_ref().map_or(\"\", |s| &**s);\n@@ -2150,10 +2153,7 @@ fn stability_tags(item: &clean::Item) -> String {\n \n     // The \"rustc_private\" crates are permanently unstable so it makes no sense\n     // to render \"unstable\" everywhere.\n-    if item\n-        .stability\n-        .as_ref()\n-        .map(|s| s.level == stability::Unstable && s.feature != \"rustc_private\")\n+    if item.stability.as_ref().map(|s| s.level.is_unstable() && s.feature != sym::rustc_private)\n         == Some(true)\n     {\n         tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n@@ -2204,16 +2204,17 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n \n     // Render unstable items. But don't render \"rustc_private\" crates (internal compiler crates).\n     // Those crates are permanently unstable so it makes no sense to render \"unstable\" everywhere.\n-    if let Some(stab) = item\n+    if let Some((StabilityLevel::Unstable { reason, issue, .. }, feature)) = item\n         .stability\n         .as_ref()\n-        .filter(|stab| stab.level == stability::Unstable && stab.feature != \"rustc_private\")\n+        .filter(|stab| stab.feature != sym::rustc_private)\n+        .map(|stab| (stab.level, stab.feature))\n     {\n         let mut message =\n             \"<span class='emoji'>\ud83d\udd2c</span> This is a nightly-only experimental API.\".to_owned();\n \n-        let mut feature = format!(\"<code>{}</code>\", Escape(&stab.feature));\n-        if let (Some(url), Some(issue)) = (&cx.shared.issue_tracker_base_url, stab.issue) {\n+        let mut feature = format!(\"<code>{}</code>\", Escape(&feature.as_str()));\n+        if let (Some(url), Some(issue)) = (&cx.shared.issue_tracker_base_url, issue) {\n             feature.push_str(&format!(\n                 \"&nbsp;<a href=\\\"{url}{issue}\\\">#{issue}</a>\",\n                 url = url,\n@@ -2223,13 +2224,13 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n \n         message.push_str(&format!(\" ({})\", feature));\n \n-        if let Some(unstable_reason) = &stab.unstable_reason {\n+        if let Some(unstable_reason) = reason {\n             let mut ids = cx.id_map.borrow_mut();\n             message = format!(\n                 \"<details><summary>{}</summary>{}</details>\",\n                 message,\n                 MarkdownHtml(\n-                    &unstable_reason,\n+                    &unstable_reason.as_str(),\n                     &mut ids,\n                     error_codes,\n                     cx.shared.edition,\n@@ -2355,7 +2356,7 @@ fn render_implementor(\n         implementor,\n         AssocItemLink::Anchor(None),\n         RenderMode::Normal,\n-        implementor.impl_item.stable_since(),\n+        implementor.impl_item.stable_since().as_deref(),\n         false,\n         Some(use_absolute),\n         false,\n@@ -2384,7 +2385,7 @@ fn render_impls(\n                 i,\n                 assoc_link,\n                 RenderMode::Normal,\n-                containing_item.stable_since(),\n+                containing_item.stable_since().as_deref(),\n                 true,\n                 None,\n                 false,\n@@ -2629,7 +2630,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n                     &implementor,\n                     assoc_link,\n                     RenderMode::Normal,\n-                    implementor.impl_item.stable_since(),\n+                    implementor.impl_item.stable_since().as_deref(),\n                     false,\n                     None,\n                     true,\n@@ -2780,7 +2781,11 @@ fn render_stability_since_raw(w: &mut Buffer, ver: Option<&str>, containing_ver:\n }\n \n fn render_stability_since(w: &mut Buffer, item: &clean::Item, containing_item: &clean::Item) {\n-    render_stability_since_raw(w, item.stable_since(), containing_item.stable_since())\n+    render_stability_since_raw(\n+        w,\n+        item.stable_since().as_deref(),\n+        containing_item.stable_since().as_deref(),\n+    )\n }\n \n fn render_assoc_item(\n@@ -3324,7 +3329,7 @@ fn render_assoc_items(\n                 i,\n                 AssocItemLink::Anchor(None),\n                 render_mode,\n-                containing_item.stable_since(),\n+                containing_item.stable_since().as_deref(),\n                 true,\n                 None,\n                 false,\n@@ -3564,8 +3569,11 @@ fn render_impl(\n             );\n         }\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id);\n-        let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n-        render_stability_since_raw(w, since, outer_version);\n+        let since = i.impl_item.stability.as_ref().and_then(|s| match s.level {\n+            StabilityLevel::Stable { since } => Some(since.as_str()),\n+            StabilityLevel::Unstable { .. } => None,\n+        });\n+        render_stability_since_raw(w, since.as_deref(), outer_version);\n         if let Some(l) = cx.src_href(&i.impl_item, cache) {\n             write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\", l, \"goto source code\");\n         }\n@@ -3626,7 +3634,7 @@ fn render_impl(\n                     write!(w, \"<code>\");\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n                     write!(w, \"</code>\");\n-                    render_stability_since_raw(w, item.stable_since(), outer_version);\n+                    render_stability_since_raw(w, item.stable_since().as_deref(), outer_version);\n                     if let Some(l) = cx.src_href(item, cache) {\n                         write!(\n                             w,\n@@ -3648,7 +3656,7 @@ fn render_impl(\n                 write!(w, \"<h4 id='{}' class=\\\"{}{}\\\"><code>\", id, item_type, extra_class);\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\");\n                 write!(w, \"</code>\");\n-                render_stability_since_raw(w, item.stable_since(), outer_version);\n+                render_stability_since_raw(w, item.stable_since().as_deref(), outer_version);\n                 if let Some(l) = cx.src_href(item, cache) {\n                     write!(\n                         w,"}, {"sha": "2591650e3f97fa5359f75e99501b84638e81cd28", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 4, "deletions": 170, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -1,16 +1,15 @@\n //! Contains information about \"passes\", used to modify crate information during the documentation\n //! process.\n \n-use rustc_hir::def_id::{DefId, DefIdSet};\n-use rustc_middle::middle::privacy::AccessLevels;\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n-use std::mem;\n use std::ops::Range;\n \n use self::Condition::*;\n-use crate::clean::{self, DocFragmentKind, GetDefId, Item};\n+use crate::clean::{self, DocFragmentKind};\n use crate::core::DocContext;\n-use crate::fold::{DocFolder, StripItem};\n+\n+mod stripper;\n+pub use stripper::*;\n \n mod collapse_docs;\n pub use self::collapse_docs::COLLAPSE_DOCS;\n@@ -149,171 +148,6 @@ pub fn find_pass(pass_name: &str) -> Option<Pass> {\n     PASSES.iter().find(|p| p.name == pass_name).copied()\n }\n \n-struct Stripper<'a> {\n-    retained: &'a mut DefIdSet,\n-    access_levels: &'a AccessLevels<DefId>,\n-    update_retained: bool,\n-}\n-\n-impl<'a> DocFolder for Stripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::StrippedItem(..) => {\n-                // We need to recurse into stripped modules to strip things\n-                // like impl methods but when doing so we must not add any\n-                // items to the `retained` set.\n-                debug!(\"Stripper: recursing into stripped {:?} {:?}\", i.type_(), i.name);\n-                let old = mem::replace(&mut self.update_retained, false);\n-                let ret = self.fold_item_recur(i);\n-                self.update_retained = old;\n-                return ret;\n-            }\n-            // These items can all get re-exported\n-            clean::OpaqueTyItem(..)\n-            | clean::TypedefItem(..)\n-            | clean::StaticItem(..)\n-            | clean::StructItem(..)\n-            | clean::EnumItem(..)\n-            | clean::TraitItem(..)\n-            | clean::FunctionItem(..)\n-            | clean::VariantItem(..)\n-            | clean::MethodItem(..)\n-            | clean::ForeignFunctionItem(..)\n-            | clean::ForeignStaticItem(..)\n-            | clean::ConstantItem(..)\n-            | clean::UnionItem(..)\n-            | clean::AssocConstItem(..)\n-            | clean::TraitAliasItem(..)\n-            | clean::ForeignTypeItem => {\n-                if i.def_id.is_local() {\n-                    if !self.access_levels.is_exported(i.def_id) {\n-                        debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n-                        return None;\n-                    }\n-                }\n-            }\n-\n-            clean::StructFieldItem(..) => {\n-                if i.visibility != clean::Public {\n-                    return StripItem(i).strip();\n-                }\n-            }\n-\n-            clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != clean::Public {\n-                    debug!(\"Stripper: stripping module {:?}\", i.name);\n-                    let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n-                    self.update_retained = old;\n-                    return ret;\n-                }\n-            }\n-\n-            // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n-\n-            clean::ImplItem(..) => {}\n-\n-            // tymethods/macros have no control over privacy\n-            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n-\n-            // Proc-macros are always public\n-            clean::ProcMacroItem(..) => {}\n-\n-            // Primitives are never stripped\n-            clean::PrimitiveItem(..) => {}\n-\n-            // Associated types are never stripped\n-            clean::AssocTypeItem(..) => {}\n-\n-            // Keywords are never stripped\n-            clean::KeywordItem(..) => {}\n-        }\n-\n-        let fastreturn = match i.inner {\n-            // nothing left to do for traits (don't want to filter their\n-            // methods out, visibility controlled by the trait)\n-            clean::TraitItem(..) => true,\n-\n-            // implementations of traits are always public.\n-            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-            // Struct variant fields have inherited visibility\n-            clean::VariantItem(clean::Variant { kind: clean::VariantKind::Struct(..) }) => true,\n-            _ => false,\n-        };\n-\n-        let i = if fastreturn {\n-            if self.update_retained {\n-                self.retained.insert(i.def_id);\n-            }\n-            return Some(i);\n-        } else {\n-            self.fold_item_recur(i)\n-        };\n-\n-        if let Some(ref i) = i {\n-            if self.update_retained {\n-                self.retained.insert(i.def_id);\n-            }\n-        }\n-        i\n-    }\n-}\n-\n-// This stripper discards all impls which reference stripped items\n-struct ImplStripper<'a> {\n-    retained: &'a DefIdSet,\n-}\n-\n-impl<'a> DocFolder for ImplStripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if let clean::ImplItem(ref imp) = i.inner {\n-            // emptied none trait impls can be stripped\n-            if imp.trait_.is_none() && imp.items.is_empty() {\n-                return None;\n-            }\n-            if let Some(did) = imp.for_.def_id() {\n-                if did.is_local() && !imp.for_.is_generic() && !self.retained.contains(&did) {\n-                    debug!(\"ImplStripper: impl item for stripped type; removing\");\n-                    return None;\n-                }\n-            }\n-            if let Some(did) = imp.trait_.def_id() {\n-                if did.is_local() && !self.retained.contains(&did) {\n-                    debug!(\"ImplStripper: impl item for stripped trait; removing\");\n-                    return None;\n-                }\n-            }\n-            if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n-                for typaram in generics {\n-                    if let Some(did) = typaram.def_id() {\n-                        if did.is_local() && !self.retained.contains(&did) {\n-                            debug!(\n-                                \"ImplStripper: stripped item in trait's generics; removing impl\"\n-                            );\n-                            return None;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        self.fold_item_recur(i)\n-    }\n-}\n-\n-// This stripper discards all private import statements (`use`, `extern crate`)\n-struct ImportStripper;\n-impl DocFolder for ImportStripper {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::ExternCrateItem(..) | clean::ImportItem(..) if i.visibility != clean::Public => {\n-                None\n-            }\n-            _ => self.fold_item_recur(i),\n-        }\n-    }\n-}\n-\n /// Returns a span encompassing all the given attributes.\n crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n     if attrs.doc_strings.is_empty() {"}, {"sha": "9b4f62235f5e8c3457e12a31f62f76077409c936", "filename": "src/librustdoc/passes/stripper.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -0,0 +1,172 @@\n+use rustc_hir::def_id::{DefId, DefIdSet};\n+use rustc_middle::middle::privacy::AccessLevels;\n+use std::mem;\n+\n+use crate::clean::{self, GetDefId, Item};\n+use crate::fold::{DocFolder, StripItem};\n+\n+pub struct Stripper<'a> {\n+    pub retained: &'a mut DefIdSet,\n+    pub access_levels: &'a AccessLevels<DefId>,\n+    pub update_retained: bool,\n+}\n+\n+impl<'a> DocFolder for Stripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::StrippedItem(..) => {\n+                // We need to recurse into stripped modules to strip things\n+                // like impl methods but when doing so we must not add any\n+                // items to the `retained` set.\n+                debug!(\"Stripper: recursing into stripped {:?} {:?}\", i.type_(), i.name);\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = self.fold_item_recur(i);\n+                self.update_retained = old;\n+                return ret;\n+            }\n+            // These items can all get re-exported\n+            clean::OpaqueTyItem(..)\n+            | clean::TypedefItem(..)\n+            | clean::StaticItem(..)\n+            | clean::StructItem(..)\n+            | clean::EnumItem(..)\n+            | clean::TraitItem(..)\n+            | clean::FunctionItem(..)\n+            | clean::VariantItem(..)\n+            | clean::MethodItem(..)\n+            | clean::ForeignFunctionItem(..)\n+            | clean::ForeignStaticItem(..)\n+            | clean::ConstantItem(..)\n+            | clean::UnionItem(..)\n+            | clean::AssocConstItem(..)\n+            | clean::TraitAliasItem(..)\n+            | clean::ForeignTypeItem => {\n+                if i.def_id.is_local() {\n+                    if !self.access_levels.is_exported(i.def_id) {\n+                        debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n+                        return None;\n+                    }\n+                }\n+            }\n+\n+            clean::StructFieldItem(..) => {\n+                if i.visibility != clean::Public {\n+                    return StripItem(i).strip();\n+                }\n+            }\n+\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != clean::Public {\n+                    debug!(\"Stripper: stripping module {:?}\", i.name);\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n+                    self.update_retained = old;\n+                    return ret;\n+                }\n+            }\n+\n+            // handled in the `strip-priv-imports` pass\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n+\n+            clean::ImplItem(..) => {}\n+\n+            // tymethods/macros have no control over privacy\n+            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n+\n+            // Proc-macros are always public\n+            clean::ProcMacroItem(..) => {}\n+\n+            // Primitives are never stripped\n+            clean::PrimitiveItem(..) => {}\n+\n+            // Associated types are never stripped\n+            clean::AssocTypeItem(..) => {}\n+\n+            // Keywords are never stripped\n+            clean::KeywordItem(..) => {}\n+        }\n+\n+        let fastreturn = match i.inner {\n+            // nothing left to do for traits (don't want to filter their\n+            // methods out, visibility controlled by the trait)\n+            clean::TraitItem(..) => true,\n+\n+            // implementations of traits are always public.\n+            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n+            // Struct variant fields have inherited visibility\n+            clean::VariantItem(clean::Variant { kind: clean::VariantKind::Struct(..) }) => true,\n+            _ => false,\n+        };\n+\n+        let i = if fastreturn {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+            return Some(i);\n+        } else {\n+            self.fold_item_recur(i)\n+        };\n+\n+        if let Some(ref i) = i {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+        }\n+        i\n+    }\n+}\n+\n+/// This stripper discards all impls which reference stripped items\n+pub struct ImplStripper<'a> {\n+    pub retained: &'a DefIdSet,\n+}\n+\n+impl<'a> DocFolder for ImplStripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        if let clean::ImplItem(ref imp) = i.inner {\n+            // emptied none trait impls can be stripped\n+            if imp.trait_.is_none() && imp.items.is_empty() {\n+                return None;\n+            }\n+            if let Some(did) = imp.for_.def_id() {\n+                if did.is_local() && !imp.for_.is_generic() && !self.retained.contains(&did) {\n+                    debug!(\"ImplStripper: impl item for stripped type; removing\");\n+                    return None;\n+                }\n+            }\n+            if let Some(did) = imp.trait_.def_id() {\n+                if did.is_local() && !self.retained.contains(&did) {\n+                    debug!(\"ImplStripper: impl item for stripped trait; removing\");\n+                    return None;\n+                }\n+            }\n+            if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n+                for typaram in generics {\n+                    if let Some(did) = typaram.def_id() {\n+                        if did.is_local() && !self.retained.contains(&did) {\n+                            debug!(\n+                                \"ImplStripper: stripped item in trait's generics; removing impl\"\n+                            );\n+                            return None;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+/// This stripper discards all private import statements (`use`, `extern crate`)\n+pub struct ImportStripper;\n+\n+impl DocFolder for ImportStripper {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) if i.visibility != clean::Public => {\n+                None\n+            }\n+            _ => self.fold_item_recur(i),\n+        }\n+    }\n+}"}, {"sha": "c6d2090759ff2248f226aa495ee3a3c19ccb6263", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -34,17 +34,20 @@\n // gdb-check:$6 = BTreeMap(size=15) = {[0] = pretty_std_collections::MyLeafNode (0), [...]}\n // (abbreviated because it's boring but we need enough elements to include internal nodes)\n \n+// gdb-command: print zst_btree_map\n+// gdb-check:$7 = BTreeMap(size=1)\n+\n // gdb-command: print vec_deque\n-// gdb-check:$7 = VecDeque(size=3) = {5, 3, 7}\n+// gdb-check:$8 = VecDeque(size=3) = {5, 3, 7}\n \n // gdb-command: print vec_deque2\n-// gdb-check:$8 = VecDeque(size=7) = {2, 3, 4, 5, 6, 7, 8}\n+// gdb-check:$9 = VecDeque(size=7) = {2, 3, 4, 5, 6, 7, 8}\n \n // gdb-command: print hash_map\n-// gdb-check:$9 = HashMap(size=4) = {[1] = 10, [2] = 20, [3] = 30, [4] = 40}\n+// gdb-check:$10 = HashMap(size=4) = {[1] = 10, [2] = 20, [3] = 30, [4] = 40}\n \n // gdb-command: print hash_set\n-// gdb-check:$10 = HashSet(size=4) = {1, 2, 3, 4}\n+// gdb-check:$11 = HashSet(size=4) = {1, 2, 3, 4}\n \n // === LLDB TESTS ==================================================================================\n \n@@ -69,9 +72,9 @@\n #![allow(unused_variables)]\n use std::collections::BTreeMap;\n use std::collections::BTreeSet;\n-use std::collections::VecDeque;\n use std::collections::HashMap;\n use std::collections::HashSet;\n+use std::collections::VecDeque;\n use std::hash::{BuildHasherDefault, Hasher};\n \n struct MyLeafNode(i32); // helps to ensure we don't blindly replace substring \"LeafNode\"\n@@ -111,6 +114,9 @@ fn main() {\n         nasty_btree_map.insert(i, MyLeafNode(i));\n     }\n \n+    let mut zst_btree_map: BTreeMap<(), ()> = BTreeMap::new();\n+    zst_btree_map.insert((), ());\n+\n     // VecDeque\n     let mut vec_deque = VecDeque::new();\n     vec_deque.push_back(5);"}, {"sha": "0e1bef6f68d53c8da40cce74c2fbe1bd07bf2e5a", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/31e4087b9098c6174a22b294bea960d54013fe22/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e4087b9098c6174a22b294bea960d54013fe22/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=31e4087b9098c6174a22b294bea960d54013fe22", "patch": "@@ -3,7 +3,6 @@\n extern crate rustc_codegen_ssa;\n extern crate rustc_errors;\n extern crate rustc_middle;\n-#[macro_use]\n extern crate rustc_data_structures;\n extern crate rustc_driver;\n extern crate rustc_hir;\n@@ -12,17 +11,19 @@ extern crate rustc_span;\n extern crate rustc_symbol_mangling;\n extern crate rustc_target;\n \n+use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::traits::CodegenBackend;\n-use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_codegen_ssa::{CodegenResults, CrateInfo};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_errors::ErrorReported;\n use rustc_middle::dep_graph::DepGraph;\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader, MetadataLoaderDyn};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::OutputFilenames;\n use rustc_session::Session;\n-use rustc_span::symbol::Symbol;\n use rustc_target::spec::Target;\n use std::any::Any;\n use std::path::Path;\n@@ -31,14 +32,11 @@ pub struct NoLlvmMetadataLoader;\n \n impl MetadataLoader for NoLlvmMetadataLoader {\n     fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        let buf =\n-            std::fs::read(filename).map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n-        let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n-        Ok(rustc_erase_owner!(buf.map_owner_box()))\n+        unreachable!(\"some_crate.rs shouldn't depend on any external crates\");\n     }\n \n     fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        self.get_rlib_metadata(target, filename)\n+        unreachable!(\"some_crate.rs shouldn't depend on any external crates\");\n     }\n }\n \n@@ -49,53 +47,49 @@ impl CodegenBackend for TheBackend {\n         Box::new(NoLlvmMetadataLoader)\n     }\n \n-    fn provide(&self, providers: &mut Providers) {\n-        rustc_symbol_mangling::provide(providers);\n-\n-        providers.supported_target_features = |tcx, _cnum| {\n-            Default::default() // Just a dummy\n-        };\n-        providers.is_reachable_non_generic = |_tcx, _defid| true;\n-        providers.exported_symbols = |_tcx, _crate| &[];\n-    }\n-\n-    fn provide_extern(&self, providers: &mut Providers) {\n-        providers.is_reachable_non_generic = |_tcx, _defid| true;\n-    }\n+    fn provide(&self, providers: &mut Providers) {}\n+    fn provide_extern(&self, providers: &mut Providers) {}\n \n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        _metadata: EncodedMetadata,\n+        metadata: EncodedMetadata,\n         _need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n         use rustc_hir::def_id::LOCAL_CRATE;\n \n-        Box::new(tcx.crate_name(LOCAL_CRATE) as Symbol)\n+        Box::new(CodegenResults {\n+            crate_name: tcx.crate_name(LOCAL_CRATE),\n+            modules: vec![],\n+            allocator_module: None,\n+            metadata_module: None,\n+            metadata,\n+            windows_subsystem: None,\n+            linker_info: LinkerInfo::new(tcx),\n+            crate_info: CrateInfo::new(tcx),\n+        })\n     }\n \n     fn join_codegen(\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n         _sess: &Session,\n-        _dep_graph: &DepGraph,\n-    ) -> Result<Box<dyn Any>, ErrorReported> {\n-        let crate_name = ongoing_codegen\n-            .downcast::<Symbol>()\n-            .expect(\"in join_codegen: ongoing_codegen is not a Symbol\");\n-        Ok(crate_name)\n+    ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorReported> {\n+        let codegen_results = ongoing_codegen\n+            .downcast::<CodegenResults>()\n+            .expect(\"in join_codegen: ongoing_codegen is not a CodegenResults\");\n+        Ok((*codegen_results, FxHashMap::default()))\n     }\n \n     fn link(\n         &self,\n         sess: &Session,\n-        codegen_results: Box<dyn Any>,\n+        codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported> {\n         use rustc_session::{config::CrateType, output::out_filename};\n         use std::io::Write;\n-        let crate_name =\n-            codegen_results.downcast::<Symbol>().expect(\"in link: codegen_results is not a Symbol\");\n+        let crate_name = codegen_results.crate_name;\n         for &crate_type in sess.opts.crate_types.iter() {\n             if crate_type != CrateType::Rlib {\n                 sess.fatal(&format!(\"Crate type is {:?}\", crate_type));"}]}