{"sha": "4667c492b539e3abd046007f904c9395ef22310e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NjdjNDkyYjUzOWUzYWJkMDQ2MDA3ZjkwNGM5Mzk1ZWYyMjMxMGU=", "commit": {"author": {"name": "Yehuda Katz", "email": "wycats@gmail.com", "date": "2014-02-13T05:28:58Z"}, "committer": {"name": "Yehuda Katz", "email": "wycats@gmail.com", "date": "2014-02-13T05:28:58Z"}, "message": "Adds support for working with URL Paths\n\nIt is sometimes useful to parse just the path portion of a URL (path,\nquery string and fragment) rather than the entire URL.", "tree": {"sha": "49d8f21f2b2cfdb594fea648393e025f0b38585f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49d8f21f2b2cfdb594fea648393e025f0b38585f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4667c492b539e3abd046007f904c9395ef22310e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4667c492b539e3abd046007f904c9395ef22310e", "html_url": "https://github.com/rust-lang/rust/commit/4667c492b539e3abd046007f904c9395ef22310e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4667c492b539e3abd046007f904c9395ef22310e/comments", "author": {"login": "wycats", "id": 4, "node_id": "MDQ6VXNlcjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wycats", "html_url": "https://github.com/wycats", "followers_url": "https://api.github.com/users/wycats/followers", "following_url": "https://api.github.com/users/wycats/following{/other_user}", "gists_url": "https://api.github.com/users/wycats/gists{/gist_id}", "starred_url": "https://api.github.com/users/wycats/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wycats/subscriptions", "organizations_url": "https://api.github.com/users/wycats/orgs", "repos_url": "https://api.github.com/users/wycats/repos", "events_url": "https://api.github.com/users/wycats/events{/privacy}", "received_events_url": "https://api.github.com/users/wycats/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wycats", "id": 4, "node_id": "MDQ6VXNlcjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wycats", "html_url": "https://github.com/wycats", "followers_url": "https://api.github.com/users/wycats/followers", "following_url": "https://api.github.com/users/wycats/following{/other_user}", "gists_url": "https://api.github.com/users/wycats/gists{/gist_id}", "starred_url": "https://api.github.com/users/wycats/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wycats/subscriptions", "organizations_url": "https://api.github.com/users/wycats/orgs", "repos_url": "https://api.github.com/users/wycats/repos", "events_url": "https://api.github.com/users/wycats/events{/privacy}", "received_events_url": "https://api.github.com/users/wycats/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58eeb07c2a128cbba403d6204c2f291af4ddf938", "url": "https://api.github.com/repos/rust-lang/rust/commits/58eeb07c2a128cbba403d6204c2f291af4ddf938", "html_url": "https://github.com/rust-lang/rust/commit/58eeb07c2a128cbba403d6204c2f291af4ddf938"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "580e11b1158740c2d2ec7241eb515bcf0dcf76be", "filename": "src/libextra/url.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/4667c492b539e3abd046007f904c9395ef22310e/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4667c492b539e3abd046007f904c9395ef22310e/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=4667c492b539e3abd046007f904c9395ef22310e", "patch": "@@ -55,6 +55,17 @@ pub struct Url {\n     fragment: Option<~str>\n }\n \n+#[deriving(Clone, Eq)]\n+pub struct Path {\n+    /// The path component of a URL, for example `/foo/bar`.\n+    path: ~str,\n+    /// The query component of a URL.  `~[(~\"baz\", ~\"qux\")]` represents the\n+    /// fragment `baz=qux` in the above example.\n+    query: Query,\n+    /// The fragment component, such as `quz`.  Doesn't include the leading `#` character.\n+    fragment: Option<~str>\n+}\n+\n /// An optional subcomponent of a URI authority component.\n #[deriving(Clone, Eq)]\n pub struct UserInfo {\n@@ -88,6 +99,19 @@ impl Url {\n     }\n }\n \n+impl Path {\n+    pub fn new(path: ~str,\n+               query: Query,\n+               fragment: Option<~str>)\n+               -> Path {\n+        Path {\n+            path: path,\n+            query: query,\n+            fragment: fragment,\n+        }\n+    }\n+}\n+\n impl UserInfo {\n     #[inline]\n     pub fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n@@ -695,6 +719,21 @@ pub fn from_str(rawurl: &str) -> Result<Url, ~str> {\n     Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n }\n \n+pub fn path_from_str(rawpath: &str) -> Result<Path, ~str> {\n+    let (path, rest) = match get_path(rawpath, false) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e)\n+    };\n+\n+    // query and fragment\n+    let (query, fragment) = match get_query_fragment(rest) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n+\n+    Ok(Path{ path: path, query: query, fragment: fragment })\n+}\n+\n impl FromStr for Url {\n     fn from_str(s: &str) -> Option<Url> {\n         match from_str(s) {\n@@ -704,6 +743,15 @@ impl FromStr for Url {\n     }\n }\n \n+impl FromStr for Path {\n+    fn from_str(s: &str) -> Option<Path> {\n+        match path_from_str(s) {\n+            Ok(path) => Some(path),\n+            Err(_) => None\n+        }\n+    }\n+}\n+\n /**\n  * Format a `url` as a string\n  *\n@@ -749,18 +797,45 @@ pub fn to_str(url: &Url) -> ~str {\n     format!(\"{}:{}{}{}{}\", url.scheme, authority, url.path, query, fragment)\n }\n \n+pub fn path_to_str(path: &Path) -> ~str {\n+    let query = if path.query.is_empty() {\n+        ~\"\"\n+    } else {\n+        format!(\"?{}\", query_to_str(&path.query))\n+    };\n+\n+    let fragment = match path.fragment {\n+        Some(ref fragment) => format!(\"\\\\#{}\", encode_component(*fragment)),\n+        None => ~\"\",\n+    };\n+\n+    format!(\"{}{}{}\", path.path, query, fragment)\n+}\n+\n impl ToStr for Url {\n     fn to_str(&self) -> ~str {\n         to_str(self)\n     }\n }\n \n+impl ToStr for Path {\n+    fn to_str(&self) -> ~str {\n+        path_to_str(self)\n+    }\n+}\n+\n impl IterBytes for Url {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         self.to_str().iter_bytes(lsb0, f)\n     }\n }\n \n+impl IterBytes for Path {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_str().iter_bytes(lsb0, f)\n+    }\n+}\n+\n // Put a few tests outside of the 'test' module so they can test the internal\n // functions and those functions don't need 'pub'\n \n@@ -868,6 +943,17 @@ mod tests {\n         assert_eq!(&u.fragment, &Some(~\"something\"));\n     }\n \n+    #[test]\n+    fn test_path_parse() {\n+        let path = ~\"/doc/~u?s=v#something\";\n+\n+        let up = path_from_str(path);\n+        let u = up.unwrap();\n+        assert_eq!(&u.path, &~\"/doc/~u\");\n+        assert_eq!(&u.query, &~[(~\"s\", ~\"v\")]);\n+        assert_eq!(&u.fragment, &Some(~\"something\"));\n+    }\n+\n     #[test]\n     fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n@@ -876,6 +962,13 @@ mod tests {\n         assert!(url.path == ~\"/\");\n     }\n \n+    #[test]\n+    fn test_path_parse_host_slash() {\n+        let pathstr = ~\"/\";\n+        let path = path_from_str(pathstr).unwrap();\n+        assert!(path.path == ~\"/\");\n+    }\n+\n     #[test]\n     fn test_url_host_with_port() {\n         let urlstr = ~\"scheme://host:1234\";\n@@ -899,13 +992,27 @@ mod tests {\n         assert!(url.path == ~\"/file_name.html\");\n     }\n \n+    #[test]\n+    fn test_path_with_underscores() {\n+        let pathstr = ~\"/file_name.html\";\n+        let path = path_from_str(pathstr).unwrap();\n+        assert!(path.path == ~\"/file_name.html\");\n+    }\n+\n     #[test]\n     fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n         assert!(url.path == ~\"/file-name.html\");\n     }\n \n+    #[test]\n+    fn test_path_with_dashes() {\n+        let pathstr = ~\"/file-name.html\";\n+        let path = path_from_str(pathstr).unwrap();\n+        assert!(path.path == ~\"/file-name.html\");\n+    }\n+\n     #[test]\n     fn test_no_scheme() {\n         assert!(get_scheme(\"noschemehere.html\").is_err());\n@@ -986,6 +1093,14 @@ mod tests {\n         assert!(u.query == ~[(~\"ba%d \", ~\"#&+\")]);\n     }\n \n+    #[test]\n+    fn test_path_component_encoding() {\n+        let path = ~\"/doc%20uments?ba%25d%20=%23%26%2B\";\n+        let p = path_from_str(path).unwrap();\n+        assert!(p.path == ~\"/doc uments\");\n+        assert!(p.query == ~[(~\"ba%d \", ~\"#&+\")]);\n+    }\n+\n     #[test]\n     fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";"}]}