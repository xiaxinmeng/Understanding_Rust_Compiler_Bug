{"sha": "7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNzExNGZlMmUyNmM1Y2NkNmViYmQ1Njg2NDEwYjYxYTQ3ODIwZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-25T23:46:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-25T23:46:37Z"}, "message": "Auto merge of #41332 - petrochenkov:privti, r=eddyb\n\nCheck privacy of trait items in all contexts\n\nFixes https://github.com/rust-lang/rust/issues/28514\n\nThis is a sufficiently rare scenario and it's currently guarded by `private_in_public` lint, so it shouldn't be a [breaking-change] in practice.", "tree": {"sha": "b31783085bda75ccfc84928e0f63eb5bc83b508e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b31783085bda75ccfc84928e0f63eb5bc83b508e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "html_url": "https://github.com/rust-lang/rust/commit/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b4c911581099e247a68b3a8adc782d778f5190b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4c911581099e247a68b3a8adc782d778f5190b", "html_url": "https://github.com/rust-lang/rust/commit/2b4c911581099e247a68b3a8adc782d778f5190b"}, {"sha": "4bd417e4389e9d1c4b589d6f36911e8e05224904", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd417e4389e9d1c4b589d6f36911e8e05224904", "html_url": "https://github.com/rust-lang/rust/commit/4bd417e4389e9d1c4b589d6f36911e8e05224904"}], "stats": {"total": 475, "additions": 227, "deletions": 248}, "files": [{"sha": "6a00586a01f82ad1bf6fea2f77cae58f1f7fdff2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "patch": "@@ -2156,6 +2156,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn associated_item_from_trait_item_ref(self,\n                                            parent_def_id: DefId,\n+                                           parent_vis: &hir::Visibility,\n                                            trait_item_ref: &hir::TraitItemRef)\n                                            -> AssociatedItem {\n         let def_id = self.hir.local_def_id(trait_item_ref.id.node_id);\n@@ -2170,7 +2171,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         AssociatedItem {\n             name: trait_item_ref.name,\n             kind: kind,\n-            vis: Visibility::from_hir(&hir::Inherited, trait_item_ref.id.node_id, self),\n+            // Visibility of trait items is inherited from their traits.\n+            vis: Visibility::from_hir(parent_vis, trait_item_ref.id.node_id, self),\n             defaultness: trait_item_ref.defaultness,\n             def_id: def_id,\n             container: TraitContainer(parent_def_id),\n@@ -2180,7 +2182,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn associated_item_from_impl_item_ref(self,\n                                           parent_def_id: DefId,\n-                                          from_trait_impl: bool,\n                                           impl_item_ref: &hir::ImplItemRef)\n                                           -> AssociatedItem {\n         let def_id = self.hir.local_def_id(impl_item_ref.id.node_id);\n@@ -2192,14 +2193,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir::AssociatedItemKind::Type => (ty::AssociatedKind::Type, false),\n         };\n \n-        // Trait impl items are always public.\n-        let public = hir::Public;\n-        let vis = if from_trait_impl { &public } else { &impl_item_ref.vis };\n-\n         ty::AssociatedItem {\n             name: impl_item_ref.name,\n             kind: kind,\n-            vis: ty::Visibility::from_hir(vis, impl_item_ref.id.node_id, self),\n+            // Visibility of trait impl items doesn't matter.\n+            vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.node_id, self),\n             defaultness: impl_item_ref.defaultness,\n             def_id: def_id,\n             container: ImplContainer(parent_def_id),\n@@ -2639,21 +2637,20 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     let parent_def_id = tcx.hir.local_def_id(parent_id);\n     let parent_item = tcx.hir.expect_item(parent_id);\n     match parent_item.node {\n-        hir::ItemImpl(.., ref impl_trait_ref, _, ref impl_item_refs) => {\n+        hir::ItemImpl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.node_id == id) {\n-                let assoc_item =\n-                    tcx.associated_item_from_impl_item_ref(parent_def_id,\n-                                                            impl_trait_ref.is_some(),\n-                                                            impl_item_ref);\n+                let assoc_item = tcx.associated_item_from_impl_item_ref(parent_def_id,\n+                                                                        impl_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n                 return assoc_item;\n             }\n         }\n \n         hir::ItemTrait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.node_id == id) {\n-                let assoc_item =\n-                    tcx.associated_item_from_trait_item_ref(parent_def_id, trait_item_ref);\n+                let assoc_item = tcx.associated_item_from_trait_item_ref(parent_def_id,\n+                                                                         &parent_item.vis,\n+                                                                         trait_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n                 return assoc_item;\n             }"}, {"sha": "f7155f219a828a78b1dbc4929b0dd46cf0ab1ed0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 38, "deletions": 97, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "patch": "@@ -13,8 +13,8 @@\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n #![feature(rustc_diagnostic_macros)]\n@@ -30,7 +30,6 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n-use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n@@ -415,97 +414,69 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-/// The privacy visitor, where privacy checks take place (violations reported)\n-////////////////////////////////////////////////////////////////////////////////\n+//////////////////////////////////////////////////////////////////////////////////////\n+/// Name privacy visitor, checks privacy and reports violations.\n+/// Most of name privacy checks are performed during the main resolution phase,\n+/// or later in type checking when field accesses and associated items are resolved.\n+/// This pass performs remaining checks for fields in struct expressions and patterns.\n+//////////////////////////////////////////////////////////////////////////////////////\n \n-struct PrivacyVisitor<'a, 'tcx: 'a> {\n+struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    curitem: DefId,\n-    in_foreign: bool,\n     tables: &'a ty::TypeckTables<'tcx>,\n+    current_item: DefId,\n }\n \n-impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    fn item_is_accessible(&self, did: DefId) -> bool {\n-        match self.tcx.hir.as_local_node_id(did) {\n-            Some(node_id) =>\n-                ty::Visibility::from_hir(&self.tcx.hir.expect_item(node_id).vis, node_id, self.tcx),\n-            None => self.tcx.sess.cstore.visibility(did),\n-        }.is_accessible_from(self.curitem, self.tcx)\n-    }\n-\n-    // Checks that a field is in scope.\n+impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n+    // Checks that a field is accessible.\n     fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n-        if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, self.tcx) {\n+        if !def.is_enum() && !field.vis.is_accessible_from(self.current_item, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n-                      field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n+                             field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n                 .span_label(span, &format!(\"field `{}` is private\", field.name))\n                 .emit();\n         }\n     }\n-\n-    // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, method_def_id: DefId) {\n-        match self.tcx.associated_item(method_def_id).container {\n-            // Trait methods are always all public. The only controlling factor\n-            // is whether the trait itself is accessible or not.\n-            ty::TraitContainer(trait_def_id) if !self.item_is_accessible(trait_def_id) => {\n-                let msg = format!(\"source trait `{}` is private\",\n-                                  self.tcx.item_path_str(trait_def_id));\n-                self.tcx.sess.span_err(span, &msg);\n-            }\n-            _ => {}\n-        }\n-    }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body);\n+        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n         let body = self.tcx.hir.body(body);\n         self.visit_body(body);\n-        self.tables = old_tables;\n+        self.tables = orig_tables;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_curitem = replace(&mut self.curitem, self.tcx.hir.local_def_id(item.id));\n+        let orig_current_item = replace(&mut self.current_item, self.tcx.hir.local_def_id(item.id));\n         intravisit::walk_item(self, item);\n-        self.curitem = orig_curitem;\n+        self.current_item = orig_current_item;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprMethodCall(..) => {\n-                let method_call = ty::MethodCall::expr(expr.id);\n-                let method = self.tables.method_map[&method_call];\n-                self.check_method(expr.span, method.def_id);\n-            }\n-            hir::ExprStruct(ref qpath, ref expr_fields, _) => {\n+            hir::ExprStruct(ref qpath, ref fields, ref base) => {\n                 let def = self.tables.qpath_def(qpath, expr.id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n-                // RFC 736: ensure all unmentioned fields are visible.\n-                // Rather than computing the set of unmentioned fields\n-                // (i.e. `all_fields - fields`), just check them all,\n-                // unless the ADT is a union, then unmentioned fields\n-                // are not checked.\n-                if adt.is_union() {\n-                    for expr_field in expr_fields {\n-                        self.check_field(expr.span, adt, variant.field_named(expr_field.name.node));\n+                if let Some(ref base) = *base {\n+                    // If the expression uses FRU we need to make sure all the unmentioned fields\n+                    // are checked for privacy (RFC 736). Rather than computing the set of\n+                    // unmentioned fields, just check them all.\n+                    for variant_field in &variant.fields {\n+                        let field = fields.iter().find(|f| f.name.node == variant_field.name);\n+                        let span = if let Some(f) = field { f.span } else { base.span };\n+                        self.check_field(span, adt, variant_field);\n                     }\n                 } else {\n-                    for field in &variant.fields {\n-                        let expr_field = expr_fields.iter().find(|f| f.name.node == field.name);\n-                        let span = if let Some(f) = expr_field { f.span } else { expr.span };\n-                        self.check_field(span, adt, field);\n+                    for field in fields {\n+                        self.check_field(field.span, adt, variant.field_named(field.name.node));\n                     }\n                 }\n             }\n@@ -515,47 +486,20 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n-        // Foreign functions do not have their patterns mapped in the def_map,\n-        // and there's nothing really relevant there anyway, so don't bother\n-        // checking privacy. If you can name the type then you can pass it to an\n-        // external C function anyway.\n-        if self.in_foreign { return }\n-\n-        match pattern.node {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+        match pat.node {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pattern.id);\n-                let adt = self.tables.pat_ty(pattern).ty_adt_def().unwrap();\n+                let def = self.tables.qpath_def(qpath, pat.id);\n+                let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n-            PatKind::TupleStruct(_, ref fields, ddpos) => {\n-                match self.tables.pat_ty(pattern).sty {\n-                    // enum fields have no privacy at this time\n-                    ty::TyAdt(def, _) if !def.is_enum() => {\n-                        let expected_len = def.struct_variant().fields.len();\n-                        for (i, field) in fields.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                            if let PatKind::Wild = field.node {\n-                                continue\n-                            }\n-                            self.check_field(field.span, def, &def.struct_variant().fields[i]);\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n             _ => {}\n         }\n \n-        intravisit::walk_pat(self, pattern);\n-    }\n-\n-    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n-        self.in_foreign = true;\n-        intravisit::walk_foreign_item(self, fi);\n-        self.in_foreign = false;\n+        intravisit::walk_pat(self, pat);\n     }\n }\n \n@@ -1233,17 +1177,14 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let krate = tcx.hir.krate();\n \n-    // Use the parent map to check the privacy of everything\n-    let mut visitor = PrivacyVisitor {\n-        curitem: DefId::local(CRATE_DEF_INDEX),\n-        in_foreign: false,\n+    // Check privacy of names not checked in previous compilation stages.\n+    let mut visitor = NamePrivacyVisitor {\n         tcx: tcx,\n         tables: &ty::TypeckTables::empty(),\n+        current_item: DefId::local(CRATE_DEF_INDEX),\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n-    tcx.sess.abort_if_errors();\n-\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {"}, {"sha": "e0c67c1456d02a70224d9ec3329d701a30792088", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "patch": "@@ -903,10 +903,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let ty = self.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n         let ty = self.normalize_ty(span, ty);\n \n-        let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name);\n-        let def_id = item.expect(\"missing associated type\").def_id;\n-        tcx.check_stability(def_id, ref_id, span);\n-        (ty, Def::AssociatedTy(def_id))\n+        let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name)\n+                                                  .expect(\"missing associated type\");\n+        let def = Def::AssociatedTy(item.def_id);\n+        if !tcx.vis_is_accessible_from(item.vis, ref_id) {\n+            let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_name);\n+            tcx.sess.span_err(span, &msg);\n+        }\n+        tcx.check_stability(item.def_id, ref_id, span);\n+\n+        (ty, def)\n     }\n \n     fn qpath_to_ty(&self,"}, {"sha": "72fba1ef6ecca825c9fbf279e63170e0da18d947", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "patch": "@@ -349,15 +349,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let def = pick.item.def();\n-\n         self.tcx.check_stability(def.def_id(), expr_id, span);\n \n-        if let probe::InherentImplPick = pick.kind {\n-            if !self.tcx.vis_is_accessible_from(pick.item.vis, self.body_id) {\n-                let msg = format!(\"{} `{}` is private\", def.kind_name(), method_name);\n-                self.tcx.sess.span_err(span, &msg);\n-            }\n-        }\n         Ok(def)\n     }\n "}, {"sha": "26e8693d3b2aa441eb6a6e7fabb3471e5b0d0db0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 30, "deletions": 48, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "patch": "@@ -369,6 +369,24 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n \n+    fn push_inherent_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n+                               kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n+        if self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n+            self.inherent_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n+        } else if self.private_candidate.is_none() {\n+            self.private_candidate = Some(item.def());\n+        }\n+    }\n+\n+    fn push_extension_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n+                               kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n+        if self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n+            self.extension_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n+        } else if self.private_candidate.is_none() {\n+            self.private_candidate = Some(item.def());\n+        }\n+    }\n+\n     fn assemble_inherent_candidates(&mut self) {\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n@@ -499,11 +517,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue\n             }\n \n-            if !self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n-                self.private_candidate = Some(item.def());\n-                continue\n-            }\n-\n             let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n             let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n@@ -519,12 +532,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n                    xform_self_ty);\n \n-            self.inherent_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item,\n-                kind: InherentImplCandidate(impl_substs, obligations),\n-                import_id: None,\n-            });\n+            self.push_inherent_candidate(xform_self_ty, item,\n+                                         InherentImplCandidate(impl_substs, obligations), None);\n         }\n     }\n \n@@ -548,12 +557,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let xform_self_ty =\n                 this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n \n-            this.inherent_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item,\n-                kind: ObjectCandidate,\n-                import_id: None,\n-            });\n+            this.push_inherent_candidate(xform_self_ty, item, ObjectCandidate, None);\n         });\n     }\n \n@@ -599,12 +603,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // `WhereClausePick`.\n             assert!(!trait_ref.substs.needs_infer());\n \n-            this.inherent_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item,\n-                kind: WhereClauseCandidate(poly_trait_ref),\n-                import_id: None,\n-            });\n+            this.push_inherent_candidate(xform_self_ty, item,\n+                                         WhereClauseCandidate(poly_trait_ref), None);\n         });\n     }\n \n@@ -743,12 +743,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             debug!(\"xform_self_ty={:?}\", xform_self_ty);\n \n-            self.extension_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id, impl_substs, obligations),\n-                import_id: import_id,\n-            });\n+            self.push_extension_candidate(xform_self_ty, item,\n+                        ExtensionImplCandidate(impl_def_id, impl_substs, obligations), import_id);\n         });\n     }\n \n@@ -833,12 +829,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             });\n \n             let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n-            self.inherent_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item.clone(),\n-                kind: TraitCandidate,\n-                import_id: import_id,\n-            });\n+            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n         }\n \n         Ok(())\n@@ -854,7 +845,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                trait_def_id,\n                item);\n \n-        for step in self.steps.iter() {\n+        for step in Rc::clone(&self.steps).iter() {\n             debug!(\"assemble_projection_candidates: step={:?}\", step);\n \n             let (def_id, substs) = match step.self_ty.sty {\n@@ -889,12 +880,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                            bound,\n                            xform_self_ty);\n \n-                    self.extension_candidates.push(Candidate {\n-                        xform_self_ty: xform_self_ty,\n-                        item: item.clone(),\n-                        kind: TraitCandidate,\n-                        import_id: import_id,\n-                    });\n+                    self.push_extension_candidate(xform_self_ty, item, TraitCandidate, import_id);\n                 }\n             }\n         }\n@@ -918,12 +904,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                    bound,\n                    xform_self_ty);\n \n-            self.extension_candidates.push(Candidate {\n-                xform_self_ty: xform_self_ty,\n-                item: item.clone(),\n-                kind: WhereClauseCandidate(poly_bound),\n-                import_id: import_id,\n-            });\n+            self.push_extension_candidate(xform_self_ty, item,\n+                                          WhereClauseCandidate(poly_bound), import_id);\n         }\n     }\n "}, {"sha": "3488310b128834dbbd866cbb4fa43e06addcf8a3", "filename": "src/test/compile-fail/issue-28514.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2b4c911581099e247a68b3a8adc782d778f5190b/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4c911581099e247a68b3a8adc782d778f5190b/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs?ref=2b4c911581099e247a68b3a8adc782d778f5190b", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![deny(private_in_public)]\n-\n-pub use inner::C;\n-\n-mod inner {\n-    trait A {\n-        fn a(&self) { }\n-    }\n-\n-    pub trait B {\n-        fn b(&self) { }\n-    }\n-\n-    pub trait C: A + B { //~ ERROR private trait `inner::A` in public interface\n-                         //~^ WARN will become a hard error\n-        fn c(&self) { }\n-    }\n-\n-    impl A for i32 {}\n-    impl B for i32 {}\n-    impl C for i32 {}\n-\n-}\n-\n-fn main() {\n-    // A is private\n-    // B is pub, not reexported\n-    // C : A + B is pub, reexported\n-\n-    // 0.a(); // can't call\n-    // 0.b(); // can't call\n-    0.c(); // ok\n-\n-    C::a(&0); // can call\n-    C::b(&0); // can call\n-    C::c(&0); // ok\n-}"}, {"sha": "a8d97d4674cbb4450f89bbc0c73332fd44e1c4e6", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "patch": "@@ -16,7 +16,7 @@ struct Foo;\n enum Bar { X }\n \n mod foo {\n-    trait Bar {\n+    pub trait Bar {\n         fn method(&self) {}\n \n         fn method2(&self) {}"}, {"sha": "807be619f6c5f6ee71bfac6ffe4076ea7198d3b3", "filename": "src/test/compile-fail/privacy/union-field-privacy-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs?ref=7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "patch": "@@ -18,12 +18,12 @@ mod m {\n     }\n }\n \n-fn main() {\n+fn main() { unsafe {\n     let u = m::U { a: 0 }; // OK\n     let u = m::U { b: 0 }; // OK\n     let u = m::U { c: 0 }; //~ ERROR field `c` of union `m::U` is private\n \n     let m::U { a } = u; // OK\n     let m::U { b } = u; // OK\n     let m::U { c } = u; //~ ERROR field `c` of union `m::U` is private\n-}\n+}}"}, {"sha": "721d7583230a7f7cfb0751f571e571edfec1777b", "filename": "src/test/compile-fail/trait-item-privacy.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Ftest%2Fcompile-fail%2Ftrait-item-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7114fe2e26c5ccd6ebbd5686410b61a47820dc/src%2Ftest%2Fcompile-fail%2Ftrait-item-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-item-privacy.rs?ref=7e7114fe2e26c5ccd6ebbd5686410b61a47820dc", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+#![feature(associated_type_defaults)]\n+\n+struct S;\n+\n+mod method {\n+    trait A {\n+        fn a(&self) { }\n+    }\n+\n+    pub trait B {\n+        fn b(&self) { }\n+    }\n+\n+    pub trait C: A + B {\n+        fn c(&self) { }\n+    }\n+\n+    impl A for ::S {}\n+    impl B for ::S {}\n+    impl C for ::S {}\n+}\n+\n+mod assoc_const {\n+    trait A {\n+        const A: u8 = 0;\n+    }\n+\n+    pub trait B {\n+        const B: u8 = 0;\n+    }\n+\n+    pub trait C: A + B {\n+        const C: u8 = 0;\n+    }\n+\n+    impl A for ::S {}\n+    impl B for ::S {}\n+    impl C for ::S {}\n+}\n+\n+mod assoc_ty {\n+    trait A {\n+        type A = u8;\n+    }\n+\n+    pub trait B {\n+        type B = u8;\n+    }\n+\n+    pub trait C: A + B {\n+        type C = u8;\n+    }\n+\n+    impl A for ::S {}\n+    impl B for ::S {}\n+    impl C for ::S {}\n+}\n+\n+fn check_method() {\n+    // A is private\n+    // B is pub, not in scope\n+    // C : A + B is pub, in scope\n+    use method::C;\n+\n+    // Methods, method call\n+    // a, b, c are resolved as trait items, their traits need to be in scope\n+    S.a(); //~ ERROR no method named `a` found for type `S` in the current scope\n+    S.b(); //~ ERROR no method named `b` found for type `S` in the current scope\n+    S.c(); // OK\n+    // a, b, c are resolved as inherent items, their traits don't need to be in scope\n+    let c = &S as &C;\n+    c.a(); //~ ERROR method `a` is private\n+    c.b(); // OK\n+    c.c(); // OK\n+\n+    // Methods, UFCS\n+    // a, b, c are resolved as trait items, their traits need to be in scope\n+    S::a(&S); //~ ERROR no associated item named `a` found for type `S` in the current scope\n+    S::b(&S); //~ ERROR no associated item named `b` found for type `S` in the current scope\n+    S::c(&S); // OK\n+    // a, b, c are resolved as inherent items, their traits don't need to be in scope\n+    C::a(&S); //~ ERROR method `a` is private\n+    C::b(&S); // OK\n+    C::c(&S); // OK\n+}\n+\n+fn check_assoc_const() {\n+    // A is private\n+    // B is pub, not in scope\n+    // C : A + B is pub, in scope\n+    use assoc_const::C;\n+\n+    // Associated constants\n+    // A, B, C are resolved as trait items, their traits need to be in scope\n+    S::A; //~ ERROR no associated item named `A` found for type `S` in the current scope\n+    S::B; //~ ERROR no associated item named `B` found for type `S` in the current scope\n+    S::C; // OK\n+    // A, B, C are resolved as inherent items, their traits don't need to be in scope\n+    C::A; //~ ERROR associated constant `A` is private\n+          //~^ ERROR the trait `assoc_const::C` cannot be made into an object\n+          //~| ERROR the trait bound `assoc_const::C: assoc_const::A` is not satisfied\n+    C::B; // ERROR the trait `assoc_const::C` cannot be made into an object\n+          //~^ ERROR the trait bound `assoc_const::C: assoc_const::B` is not satisfied\n+    C::C; // OK\n+}\n+\n+fn check_assoc_ty<T: assoc_ty::C>() {\n+    // A is private\n+    // B is pub, not in scope\n+    // C : A + B is pub, in scope\n+    use assoc_ty::C;\n+\n+    // Associated types\n+    // A, B, C are resolved as trait items, their traits need to be in scope, not implemented yet\n+    let _: S::A; //~ ERROR ambiguous associated type\n+    let _: S::B; //~ ERROR ambiguous associated type\n+    let _: S::C; //~ ERROR ambiguous associated type\n+    // A, B, C are resolved as inherent items, their traits don't need to be in scope\n+    let _: T::A; //~ ERROR associated type `A` is private\n+    let _: T::B; // OK\n+    let _: T::C; // OK\n+}\n+\n+fn main() {}"}, {"sha": "5feef0a24eb0e93a717f61d52b5608410a97ef03", "filename": "src/test/compile-fail/trait-not-accessible.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b4c911581099e247a68b3a8adc782d778f5190b/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4c911581099e247a68b3a8adc782d778f5190b/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-not-accessible.rs?ref=2b4c911581099e247a68b3a8adc782d778f5190b", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod m {\n-    trait Priv {\n-        fn f(&self) {}\n-    }\n-    impl Priv for super::S {}\n-    pub trait Pub: Priv {}\n-}\n-\n-struct S;\n-impl m::Pub for S {}\n-\n-fn g<T: m::Pub>(arg: T) {\n-    arg.f(); //~ ERROR: source trait `m::Priv` is private\n-}\n-\n-fn main() {\n-    g(S);\n-}"}]}