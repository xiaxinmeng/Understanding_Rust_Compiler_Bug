{"sha": "9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNWU4NmQwY2QwMTg1YmIxMDMwYjk1MTk2Mzk0YWRiNmMyYzdhN2E=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-11-30T17:12:03Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-01-03T07:33:31Z"}, "message": "More pattern matching for empty types changes\n\nFix is_uninhabited for enum types. It used to assume that an enums variant's\nfields were all private.\n\nFix MIR generation for irrefutable Variant pattern matches. This allows code\nlike this to work:\n\n    let x: Result<32, !> = Ok(123);\n    let Ok(y) = x;\n\nCarry type information on dummy wildcard patterns. Sometimes we need to expand\nthese patterns into their constructors and we don't want to be expanding a\nTyError into a Constructor::Single.", "tree": {"sha": "401280705091d3b8ab5f80f4a0e75774aee33408", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/401280705091d3b8ab5f80f4a0e75774aee33408"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "html_url": "https://github.com/rust-lang/rust/commit/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcdbe942e108e47ffa712fa44ad9b251c53c105b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcdbe942e108e47ffa712fa44ad9b251c53c105b", "html_url": "https://github.com/rust-lang/rust/commit/bcdbe942e108e47ffa712fa44ad9b251c53c105b"}], "stats": {"total": 333, "additions": 237, "deletions": 96}, "files": [{"sha": "f244306a0cf4f63584b77beed1a393d4474a55f7", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "patch": "@@ -888,6 +888,10 @@ impl<'tcx> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Deref)\n     }\n \n+    pub fn downcast(self, adt_def: AdtDef<'tcx>, variant_index: usize) -> Lvalue<'tcx> {\n+        self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n+    }\n+\n     pub fn index(self, index: Operand<'tcx>) -> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Index(index))\n     }"}, {"sha": "ba389b98b8c4cfde4b7d1b46d793b70226449729", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "patch": "@@ -1416,7 +1416,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             return false;\n         };\n         self.variants.iter().all(|v| {\n-            v.is_uninhabited_recurse(visited, block, tcx, substs, self.is_union())\n+            v.is_uninhabited_recurse(visited, block, tcx, substs, self.adt_kind())\n         })\n     }\n \n@@ -1761,11 +1761,23 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n                                   block: Option<NodeId>,\n                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   substs: &'tcx Substs<'tcx>,\n-                                  is_union: bool) -> bool {\n-        if is_union {\n-            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n-        } else {\n-            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n+                                  adt_kind: AdtKind) -> bool {\n+        match adt_kind {\n+            AdtKind::Union => {\n+                self.fields.iter().all(|f| {\n+                    f.is_uninhabited_recurse(visited, block, tcx, substs, false)\n+                })\n+            },\n+            AdtKind::Struct => {\n+                self.fields.iter().any(|f| {\n+                    f.is_uninhabited_recurse(visited, block, tcx, substs, false)\n+                })\n+            },\n+            AdtKind::Enum => {\n+                self.fields.iter().any(|f| {\n+                    f.is_uninhabited_recurse(visited, block, tcx, substs, true)\n+                })\n+            },\n         }\n     }\n }\n@@ -1780,9 +1792,12 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n                                   visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                                   block: Option<NodeId>,\n                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>) -> bool {\n-        block.map_or(true, |b| tcx.vis_is_accessible_from(self.vis, b)) &&\n-        self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n+                                  substs: &'tcx Substs<'tcx>,\n+                                  is_enum: bool) -> bool {\n+        let visible = is_enum || block.map_or(true, |b| {\n+            tcx.vis_is_accessible_from(self.vis, b)\n+        });\n+        visible && self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n     }\n }\n "}, {"sha": "1577e87049cc384cf8e0c472c3225a4dc63c954e", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 92, "deletions": 51, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "patch": "@@ -24,7 +24,7 @@ use pattern::{FieldPattern, Pattern, PatternKind};\n use pattern::{PatternFoldable, PatternFolder};\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n@@ -153,9 +153,6 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     /// can not be seen to be empty outside it's module and should not\n     /// be matchable with an empty match statement.\n     pub node: NodeId,\n-    /// A wild pattern with an error type - it exists to avoid having to normalize\n-    /// associated types to get field types.\n-    pub wild_pattern: &'a Pattern<'tcx>,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n     pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n@@ -167,25 +164,20 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         f: F) -> R\n         where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n     {\n-        let wild_pattern = Pattern {\n-            ty: tcx.types.err,\n-            span: DUMMY_SP,\n-            kind: box PatternKind::Wild\n-        };\n-\n         let pattern_arena = TypedArena::new();\n \n         f(MatchCheckCtxt {\n             tcx: tcx,\n             node: node,\n-            wild_pattern: &wild_pattern,\n             pattern_arena: &pattern_arena,\n             byte_array_map: FxHashMap(),\n         })\n     }\n \n     // convert a byte-string pattern to a list of u8 patterns.\n-    fn lower_byte_str_pattern(&mut self, pat: &'a Pattern<'tcx>) -> Vec<&'a Pattern<'tcx>> {\n+    fn lower_byte_str_pattern<'p>(&mut self, pat: &'p Pattern<'tcx>) -> Vec<&'p Pattern<'tcx>>\n+            where 'a: 'p\n+    {\n         let pattern_arena = &*self.pattern_arena;\n         let tcx = self.tcx;\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n@@ -401,6 +393,7 @@ fn missing_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>) -> Vec<Constructor>\n {\n+    debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n@@ -421,7 +414,10 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter().filter_map(|v| {\n                 let mut visited = FxHashSet::default();\n-                if v.is_uninhabited_recurse(&mut visited, Some(cx.node), cx.tcx, substs, false) {\n+                if v.is_uninhabited_recurse(&mut visited,\n+                                            Some(cx.node),\n+                                            cx.tcx, substs,\n+                                            AdtKind::Enum) {\n                     None\n                 } else {\n                     Some(Variant(v.did))\n@@ -438,10 +434,10 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn max_slice_length<'a, 'tcx, I>(\n+fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     patterns: I) -> usize\n-    where I: Iterator<Item=&'a Pattern<'tcx>>\n+    where I: Iterator<Item=&'p Pattern<'tcx>>\n {\n     // The exhaustiveness-checking paper does not include any details on\n     // checking variable-length slice patterns. However, they are matched\n@@ -532,6 +528,12 @@ fn max_slice_length<'a, 'tcx, I>(\n }\n \n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n+/// The algorithm from the paper has been modified to correctly handle empty\n+/// types. The changes are:\n+///   (0) We don't exit early if the pattern matrix has zero rows. We just\n+///       continue to recurse over columns.\n+///   (1) all_constructors will only return constructors that are statically\n+///       possible. eg. it will only return Ok for Result<T, !>\n ///\n /// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n /// vectors `m` is defined as there being a set of inputs that will match `v`\n@@ -541,12 +543,9 @@ fn max_slice_length<'a, 'tcx, I>(\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n-///\n-/// Note: is_useful doesn't work on empty types, as the paper notes.\n-/// So it assumes that v is non-empty.\n-pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                           matrix: &Matrix<'a, 'tcx>,\n-                           v: &[&'a Pattern<'tcx>],\n+pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                           matrix: &Matrix<'p, 'tcx>,\n+                           v: &[&'p Pattern<'tcx>],\n                            witness: WitnessPreference)\n                            -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n@@ -616,19 +615,27 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn is_useful_specialized<'a, 'tcx>(\n+fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    &Matrix(ref m): &Matrix<'a, 'tcx>,\n-    v: &[&'a Pattern<'tcx>],\n+    &Matrix(ref m): &Matrix<'p, 'tcx>,\n+    v: &[&'p Pattern<'tcx>],\n     ctor: Constructor,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n-    let arity = constructor_arity(cx, &ctor, lty);\n+    let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n+    let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n+        Pattern {\n+            ty: ty,\n+            span: DUMMY_SP,\n+            kind: box PatternKind::Wild,\n+        }\n+    }).collect();\n+    let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n     let matrix = Matrix(m.iter().flat_map(|r| {\n-        specialize(cx, &r[..], &ctor, 0, arity)\n+        specialize(cx, &r[..], &ctor, &wild_patterns)\n     }).collect());\n-    match specialize(cx, v, &ctor, 0, arity) {\n+    match specialize(cx, v, &ctor, &wild_patterns) {\n         Some(v) => match is_useful(cx, &matrix, &v[..], witness) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses.into_iter()\n@@ -703,6 +710,33 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize\n     }\n }\n \n+/// This computes the types of the sub patterns that a constructor should be\n+/// expanded to.\n+///\n+/// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n+fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                                             ctor: &Constructor,\n+                                             ty: Ty<'tcx>) -> Vec<Ty<'tcx>>\n+{\n+    debug!(\"constructor_sub_pattern_tys({:?}, {:?})\", ctor, ty);\n+    match ty.sty {\n+        ty::TyTuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n+        ty::TyBox(ty) => vec![ty],\n+        ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n+            Slice(length) => repeat(ty).take(length).collect(),\n+            ConstantValue(_) => vec![],\n+            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n+        },\n+        ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n+        ty::TyAdt(adt, substs) => {\n+            ctor.variant_for_adt(adt).fields.iter().map(|field| {\n+                field.ty(cx.tcx, substs)\n+            }).collect()\n+        }\n+        _ => vec![],\n+    }\n+}\n+\n fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n                                     ctor: &Constructor,\n                                     prefix: &[Pattern],\n@@ -754,19 +788,18 @@ fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n     Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n }\n \n-fn patterns_for_variant<'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    subpatterns: &'a [FieldPattern<'tcx>],\n-    arity: usize)\n-    -> Vec<&'a Pattern<'tcx>>\n+fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n+    subpatterns: &'p [FieldPattern<'tcx>],\n+    wild_patterns: &[&'p Pattern<'tcx>])\n+    -> Vec<&'p Pattern<'tcx>>\n {\n-    let mut result = vec![cx.wild_pattern; arity];\n+    let mut result = wild_patterns.to_owned();\n \n     for subpat in subpatterns {\n         result[subpat.field.index()] = &subpat.pattern;\n     }\n \n-    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, arity, result);\n+    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, wild_patterns, result);\n     result\n }\n \n@@ -778,35 +811,41 @@ fn patterns_for_variant<'a, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize<'a, 'tcx>(\n+fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    r: &[&'a Pattern<'tcx>],\n-    constructor: &Constructor, col: usize, arity: usize)\n-    -> Option<Vec<&'a Pattern<'tcx>>>\n+    r: &[&'p Pattern<'tcx>],\n+    constructor: &Constructor,\n+    wild_patterns: &[&'p Pattern<'tcx>])\n+    -> Option<Vec<&'p Pattern<'tcx>>>\n {\n-    let pat = &r[col];\n+    let pat = &r[0];\n \n     let head: Option<Vec<&Pattern>> = match *pat.kind {\n-        PatternKind::Binding { .. } | PatternKind::Wild =>\n-            Some(vec![cx.wild_pattern; arity]),\n+        PatternKind::Binding { .. } | PatternKind::Wild => {\n+            Some(wild_patterns.to_owned())\n+        },\n \n-        PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n+        PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n             if *constructor == Variant(variant.did) {\n-                Some(patterns_for_variant(cx, subpatterns, arity))\n+                Some(patterns_for_variant(subpatterns, wild_patterns))\n             } else {\n                 None\n             }\n         }\n \n-        PatternKind::Leaf { ref subpatterns } => Some(patterns_for_variant(cx, subpatterns, arity)),\n-        PatternKind::Deref { ref subpattern } => Some(vec![subpattern]),\n+        PatternKind::Leaf { ref subpatterns } => {\n+            Some(patterns_for_variant(subpatterns, wild_patterns))\n+        }\n+        PatternKind::Deref { ref subpattern } => {\n+            Some(vec![subpattern])\n+        }\n \n         PatternKind::Constant { ref value } => {\n             match *constructor {\n                 Slice(..) => match *value {\n                     ConstVal::ByteStr(ref data) => {\n-                        if arity == data.len() {\n+                        if wild_patterns.len() == data.len() {\n                             Some(cx.lower_byte_str_pattern(pat))\n                         } else {\n                             None\n@@ -842,11 +881,14 @@ fn specialize<'a, 'tcx>(\n             match *constructor {\n                 Slice(..) => {\n                     let pat_len = prefix.len() + suffix.len();\n-                    if let Some(slice_count) = arity.checked_sub(pat_len) {\n+                    if let Some(slice_count) = wild_patterns.len().checked_sub(pat_len) {\n                         if slice_count == 0 || slice.is_some() {\n                             Some(\n                                 prefix.iter().chain(\n-                                repeat(cx.wild_pattern).take(slice_count).chain(\n+                                wild_patterns.iter().map(|p| *p)\n+                                                    .skip(prefix.len())\n+                                                    .take(slice_count)\n+                                                    .chain(\n                                 suffix.iter()\n                             )).collect())\n                         } else {\n@@ -870,11 +912,10 @@ fn specialize<'a, 'tcx>(\n             }\n         }\n     };\n-    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n+    debug!(\"specialize({:?}, {:?}) = {:?}\", r[0], wild_patterns, head);\n \n     head.map(|mut head| {\n-        head.extend_from_slice(&r[..col]);\n-        head.extend_from_slice(&r[col + 1..]);\n+        head.extend_from_slice(&r[1 ..]);\n         head\n     })\n }"}, {"sha": "c3a033f4aa79355210812bff8cca032af22c503e", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "patch": "@@ -24,7 +24,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::session::Session;\n use rustc::traits::Reveal;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::lint;\n use rustc_errors::DiagnosticBuilder;\n \n@@ -36,7 +36,7 @@ use rustc_back::slice;\n \n use syntax::ast;\n use syntax::ptr::P;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n@@ -81,7 +81,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n \n         match ex.node {\n             hir::ExprMatch(ref scrut, ref arms, source) => {\n-                self.check_match(scrut, arms, source, ex.span);\n+                self.check_match(scrut, arms, source);\n             }\n             _ => {}\n         }\n@@ -132,8 +132,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         &self,\n         scrut: &hir::Expr,\n         arms: &[hir::Arm],\n-        source: hir::MatchSource,\n-        span: Span)\n+        source: hir::MatchSource)\n     {\n         for arm in arms {\n             // First, check legality of move bindings.\n@@ -175,32 +174,14 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Fourth, check for unreachable arms.\n             check_arms(cx, &inlined_arms, source);\n \n-            // Finally, check if the whole match expression is exhaustive.\n-            // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n-            if inlined_arms.is_empty() {\n-                if !pat_ty.is_uninhabited(Some(scrut.id), self.tcx) {\n-                    // We know the type is inhabited, so this must be wrong\n-                    let mut err = create_e0004(self.tcx.sess, span,\n-                                               format!(\"non-exhaustive patterns: type {} \\\n-                                                        is non-empty\",\n-                                                       pat_ty));\n-                    span_help!(&mut err, span,\n-                               \"Please ensure that all possible cases are being handled; \\\n-                                possibly adding wildcards or more match arms.\");\n-                    err.emit();\n-                }\n-                // If the type *is* uninhabited, it's vacuously exhaustive\n-                return;\n-            }\n-\n             let matrix: Matrix = inlined_arms\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![pat.0])\n                 .collect();\n-            check_exhaustive(cx, scrut.span, &matrix, source);\n+            let scrut_ty = cx.tcx.tables().node_id_to_type(scrut.id);\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, source);\n         })\n     }\n \n@@ -213,11 +194,18 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n         MatchCheckCtxt::create_and_enter(self.tcx, pat.id, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx);\n+            let pattern = patcx.lower_pattern(pat);\n+            let pattern_ty = pattern.ty;\n             let pats : Matrix = vec![vec![\n-                expand_pattern(cx, patcx.lower_pattern(pat))\n+                expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let witness = match is_useful(cx, &pats, &[cx.wild_pattern], ConstructWitness) {\n+            let wild_pattern = Pattern {\n+                ty: pattern_ty,\n+                span: DUMMY_SP,\n+                kind: box PatternKind::Wild,\n+            };\n+            let witness = match is_useful(cx, &pats, &[&wild_pattern], ConstructWitness) {\n                 UsefulWithWitness(witness) => witness,\n                 NotUseful => return,\n                 Useful => bug!()\n@@ -359,10 +347,16 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n }\n \n fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                              scrut_ty: Ty<'tcx>,\n                               sp: Span,\n                               matrix: &Matrix<'a, 'tcx>,\n                               source: hir::MatchSource) {\n-    match is_useful(cx, matrix, &[cx.wild_pattern], ConstructWitness) {\n+    let wild_pattern = Pattern {\n+        ty: scrut_ty,\n+        span: DUMMY_SP,\n+        kind: box PatternKind::Wild,\n+    };\n+    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n                 vec![cx.wild_pattern]"}, {"sha": "ce2cd47572f5d9f9259f00c3f20fa1b9559f22aa", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "patch": "@@ -13,7 +13,8 @@ use eval;\n use rustc::lint;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{Field, BorrowKind, Mutability};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, TypeVariants, Region};\n+use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -67,6 +68,7 @@ pub enum PatternKind<'tcx> {\n     /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n         adt_def: &'tcx AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         variant_index: usize,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n@@ -534,11 +536,15 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     {\n         match def {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n-                let adt_def = self.tcx.lookup_adt_def(enum_id);\n+                let ty = self.tcx.tables().node_id_to_type(pat.id);\n+                let (adt_def, substs) = match ty.sty {\n+                    TypeVariants::TyAdt(adt_def, substs) => (adt_def, substs),\n+                    _ => span_bug!(pat.span, \"inappropriate type for def\"),\n+                };\n                 if adt_def.variants.len() > 1 {\n                     PatternKind::Variant {\n                         adt_def: adt_def,\n+                        substs: substs,\n                         variant_index: adt_def.variant_index_with_id(variant_id),\n                         subpatterns: subpatterns,\n                     }\n@@ -776,8 +782,9 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal,\n-    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal, Region,\n+    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n@@ -828,10 +835,12 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             },\n             PatternKind::Variant {\n                 adt_def,\n+                substs,\n                 variant_index,\n                 ref subpatterns,\n             } => PatternKind::Variant {\n                 adt_def: adt_def.fold_with(folder),\n+                substs: substs.fold_with(folder),\n                 variant_index: variant_index.fold_with(folder),\n                 subpatterns: subpatterns.fold_with(folder)\n             },"}, {"sha": "c3414c591abb25357a46ba7773e5eb11c46a4076", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "patch": "@@ -26,6 +26,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n+use rustc_data_structures::fx::FxHashSet;\n \n use std::mem;\n \n@@ -93,11 +94,28 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Range { .. } |\n-            PatternKind::Variant { .. } |\n             PatternKind::Slice { .. } => {\n                 Err(match_pair)\n             }\n \n+            PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n+                let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n+                    let mut visited = FxHashSet::default();\n+                    i == variant_index || v.is_uninhabited_recurse(&mut visited,\n+                                                                   None,\n+                                                                   self.hir.tcx(),\n+                                                                   substs,\n+                                                                   adt_def.adt_kind())\n+                });\n+                if irrefutable {\n+                    let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n+                    candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n+                    Ok(())\n+                } else {\n+                    Err(match_pair)\n+                }\n+            },\n+\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n                 self.prefix_slice_suffix(&mut candidate.match_pairs,\n                                          &match_pair.lvalue,"}, {"sha": "8b4a013bad0a369be8bbc4c7b488bf1d3122dcae", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// It is a bug to call this with a simplifyable pattern.\n     pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n-            PatternKind::Variant { ref adt_def, variant_index: _, subpatterns: _ } => {\n+            PatternKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n@@ -451,7 +451,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (&TestKind::Switch { adt_def: tested_adt_def, .. },\n-             &PatternKind::Variant { adt_def, variant_index, ref subpatterns }) => {\n+             &PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n                 assert_eq!(adt_def, tested_adt_def);\n                 let new_candidate =\n                     self.candidate_after_variant_switch(match_pair_index,"}, {"sha": "23705d36e3de2fc87c4b80371ddd1b27bdc0f858", "filename": "src/test/run-pass/empty-types-in-patterns.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Ftest%2Frun-pass%2Fempty-types-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e86d0cd0185bb1030b95196394adb6c2c7a7a/src%2Ftest%2Frun-pass%2Fempty-types-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-types-in-patterns.rs?ref=9c5e86d0cd0185bb1030b95196394adb6c2c7a7a", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+#![feature(slice_patterns)]\n+#![allow(unreachable_patterns)]\n+#![allow(unreachable_code)]\n+\n+#[allow(dead_code)]\n+fn foo(z: !) {\n+    let x: Result<!, !> = Ok(z);\n+\n+    let Ok(_y) = x;\n+    let Err(_y) = x;\n+\n+    let x = [z; 1];\n+\n+    match x {};\n+    match x {\n+        [q] => q,\n+    };\n+}\n+\n+fn bar(nevers: &[!]) {\n+    match nevers {\n+        &[]  => (),\n+    };\n+\n+    match nevers {\n+        &[]  => (),\n+        &[_]  => (),\n+        &[_, _, _, ..]  => (),\n+    };\n+}\n+\n+fn main() {\n+    let x: Result<u32, !> = Ok(123);\n+    let Ok(y) = x;\n+\n+    assert_eq!(123, y);\n+\n+    match x {\n+        Ok(y) => y,\n+    };\n+\n+    match x {\n+        Ok(y) => y,\n+        Err(e) => match e {},\n+    };\n+\n+    bar(&[]);\n+}\n+"}]}