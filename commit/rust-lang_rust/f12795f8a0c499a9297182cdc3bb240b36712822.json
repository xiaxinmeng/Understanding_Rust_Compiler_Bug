{"sha": "f12795f8a0c499a9297182cdc3bb240b36712822", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMjc5NWY4YTBjNDk5YTkyOTcxODJjZGMzYmIyNDBiMzY3MTI4MjI=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-26T23:27:54Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-29T03:27:27Z"}, "message": "More improvements to macro coverage", "tree": {"sha": "60c59ebb9368edeb343b35997f030c0296953290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60c59ebb9368edeb343b35997f030c0296953290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f12795f8a0c499a9297182cdc3bb240b36712822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f12795f8a0c499a9297182cdc3bb240b36712822", "html_url": "https://github.com/rust-lang/rust/commit/f12795f8a0c499a9297182cdc3bb240b36712822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f12795f8a0c499a9297182cdc3bb240b36712822/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c26afb765cb3047f2fa83b21739d9211af39f7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/c26afb765cb3047f2fa83b21739d9211af39f7ce", "html_url": "https://github.com/rust-lang/rust/commit/c26afb765cb3047f2fa83b21739d9211af39f7ce"}], "stats": {"total": 521, "additions": 366, "deletions": 155}, "files": [{"sha": "e1db5191c896da6f8172a3b37e3b54050306a2e5", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 110, "deletions": 49, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/f12795f8a0c499a9297182cdc3bb240b36712822/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12795f8a0c499a9297182cdc3bb240b36712822/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=f12795f8a0c499a9297182cdc3bb240b36712822", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::TyCtxt;\n \n use rustc_span::source_map::original_sp;\n-use rustc_span::{BytePos, ExpnKind, MacroKind, Span};\n+use rustc_span::{BytePos, ExpnKind, MacroKind, Span, Symbol};\n \n use std::cmp::Ordering;\n \n@@ -67,20 +67,17 @@ impl CoverageStatement {\n #[derive(Debug, Clone)]\n pub(super) struct CoverageSpan {\n     pub span: Span,\n-    pub is_macro_expansion: bool,\n+    pub expn_span: Span,\n     pub bcb: BasicCoverageBlock,\n     pub coverage_statements: Vec<CoverageStatement>,\n     pub is_closure: bool,\n }\n \n impl CoverageSpan {\n     pub fn for_fn_sig(fn_sig_span: Span) -> Self {\n-        // Whether the function signature is from a macro or not, it should not be treated like\n-        // macro-expanded statements and terminators.\n-        let is_macro_expansion = false;\n         Self {\n             span: fn_sig_span,\n-            is_macro_expansion,\n+            expn_span: fn_sig_span,\n             bcb: START_BCB,\n             coverage_statements: vec![],\n             is_closure: false,\n@@ -90,7 +87,7 @@ impl CoverageSpan {\n     pub fn for_statement(\n         statement: &Statement<'tcx>,\n         span: Span,\n-        is_macro_expansion: bool,\n+        expn_span: Span,\n         bcb: BasicCoverageBlock,\n         bb: BasicBlock,\n         stmt_index: usize,\n@@ -105,7 +102,7 @@ impl CoverageSpan {\n \n         Self {\n             span,\n-            is_macro_expansion,\n+            expn_span,\n             bcb,\n             coverage_statements: vec![CoverageStatement::Statement(bb, span, stmt_index)],\n             is_closure,\n@@ -114,13 +111,13 @@ impl CoverageSpan {\n \n     pub fn for_terminator(\n         span: Span,\n-        is_macro_expansion: bool,\n+        expn_span: Span,\n         bcb: BasicCoverageBlock,\n         bb: BasicBlock,\n     ) -> Self {\n         Self {\n             span,\n-            is_macro_expansion,\n+            expn_span,\n             bcb,\n             coverage_statements: vec![CoverageStatement::Terminator(bb, span)],\n             is_closure: false,\n@@ -176,6 +173,34 @@ impl CoverageSpan {\n             .collect::<Vec<_>>()\n             .join(\"\\n\")\n     }\n+\n+    /// If the span is part of a macro, and the macro is visible (expands directly to the given\n+    /// body_span), returns the macro name symbol.\n+    pub fn current_macro(&self) -> Option<Symbol> {\n+        if let ExpnKind::Macro(MacroKind::Bang, current_macro) =\n+            self.expn_span.ctxt().outer_expn_data().kind\n+        {\n+            return Some(current_macro);\n+        }\n+        None\n+    }\n+\n+    /// If the span is part of a macro, and the macro is visible (expands directly to the given\n+    /// body_span), returns the macro name symbol.\n+    pub fn visible_macro(&self, body_span: Span) -> Option<Symbol> {\n+        if let Some(current_macro) = self.current_macro() {\n+            if self.expn_span.parent().unwrap_or_else(|| bug!(\"macro must have a parent\")).ctxt()\n+                == body_span.ctxt()\n+            {\n+                return Some(current_macro);\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn is_macro_expansion(&self) -> bool {\n+        self.current_macro().is_some()\n+    }\n }\n \n /// Converts the initial set of `CoverageSpan`s (one per MIR `Statement` or `Terminator`) into a\n@@ -219,6 +244,9 @@ pub struct CoverageSpans<'a, 'tcx> {\n     /// Assigned from `curr_original_span` from the previous iteration.\n     prev_original_span: Span,\n \n+    /// A copy of the expn_span from the prior iteration.\n+    prev_expn_span: Option<Span>,\n+\n     /// One or more `CoverageSpan`s with the same `Span` but different `BasicCoverageBlock`s, and\n     /// no `BasicCoverageBlock` in this list dominates another `BasicCoverageBlock` in the list.\n     /// If a new `curr` span also fits this criteria (compared to an existing list of\n@@ -273,15 +301,13 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             curr_original_span: Span::with_root_ctxt(BytePos(0), BytePos(0)),\n             some_prev: None,\n             prev_original_span: Span::with_root_ctxt(BytePos(0), BytePos(0)),\n+            prev_expn_span: None,\n             pending_dups: Vec::new(),\n         };\n \n         let sorted_spans = coverage_spans.mir_to_initial_sorted_coverage_spans();\n \n         coverage_spans.sorted_spans_iter = Some(sorted_spans.into_iter());\n-        coverage_spans.some_prev = coverage_spans.sorted_spans_iter.as_mut().unwrap().next();\n-        coverage_spans.prev_original_span =\n-            coverage_spans.some_prev.as_ref().expect(\"at least one span\").span;\n \n         coverage_spans.to_refined_spans()\n     }\n@@ -335,10 +361,14 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// de-duplicated `CoverageSpan`s.\n     fn to_refined_spans(mut self) -> Vec<CoverageSpan> {\n         while self.next_coverage_span() {\n-            if self.curr().is_mergeable(self.prev()) {\n+            if self.some_prev.is_none() {\n+                debug!(\"  initial span\");\n+                self.check_invoked_macro_name_span();\n+            } else if self.curr().is_mergeable(self.prev()) {\n                 debug!(\"  same bcb (and neither is a closure), merge with prev={:?}\", self.prev());\n                 let prev = self.take_prev();\n                 self.curr_mut().merge_from(prev);\n+                self.check_invoked_macro_name_span();\n             // Note that curr.span may now differ from curr_original_span\n             } else if self.prev_ends_before_curr() {\n                 debug!(\n@@ -347,7 +377,8 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     self.prev()\n                 );\n                 let prev = self.take_prev();\n-                self.refined_spans.push(prev);\n+                self.push_refined_span(prev);\n+                self.check_invoked_macro_name_span();\n             } else if self.prev().is_closure {\n                 // drop any equal or overlapping span (`curr`) and keep `prev` to test again in the\n                 // next iter\n@@ -362,7 +393,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             } else if self.prev_original_span == self.curr().span {\n                 // Note that this compares the new span to `prev_original_span`, which may not\n                 // be the full `prev.span` (if merged during the previous iteration).\n-                if self.prev().is_macro_expansion && self.curr().is_macro_expansion {\n+                if self.prev().is_macro_expansion() && self.curr().is_macro_expansion() {\n                     // Macros that expand to include branching (such as\n                     // `assert_eq!()`, `assert_ne!()`, `info!()`, `debug!()`, or\n                     // `trace!()) typically generate callee spans with identical\n@@ -385,15 +416,16 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                 }\n             } else {\n                 self.cutoff_prev_at_overlapping_curr();\n+                self.check_invoked_macro_name_span();\n             }\n         }\n \n         debug!(\"    AT END, adding last prev={:?}\", self.prev());\n         let prev = self.take_prev();\n-        let CoverageSpans { pending_dups, mut refined_spans, .. } = self;\n+        let pending_dups = self.pending_dups.split_off(0);\n         for dup in pending_dups {\n             debug!(\"    ...adding at least one pending dup={:?}\", dup);\n-            refined_spans.push(dup);\n+            self.push_refined_span(dup);\n         }\n \n         // Async functions wrap a closure that implements the body to be executed. The enclosing\n@@ -403,21 +435,60 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n         // excluded. The closure's `Return` is the only one that will be counted. This provides\n         // adequate coverage, and more intuitive counts. (Avoids double-counting the closing brace\n         // of the function body.)\n-        let body_ends_with_closure = if let Some(last_covspan) = refined_spans.last() {\n+        let body_ends_with_closure = if let Some(last_covspan) = self.refined_spans.last() {\n             last_covspan.is_closure && last_covspan.span.hi() == self.body_span.hi()\n         } else {\n             false\n         };\n \n         if !body_ends_with_closure {\n-            refined_spans.push(prev);\n+            self.push_refined_span(prev);\n         }\n \n         // Remove `CoverageSpan`s derived from closures, originally added to ensure the coverage\n         // regions for the current function leave room for the closure's own coverage regions\n         // (injected separately, from the closure's own MIR).\n-        refined_spans.retain(|covspan| !covspan.is_closure);\n-        refined_spans\n+        self.refined_spans.retain(|covspan| !covspan.is_closure);\n+        self.refined_spans\n+    }\n+\n+    fn push_refined_span(&mut self, covspan: CoverageSpan) {\n+        let len = self.refined_spans.len();\n+        if len > 0 {\n+            let last = &mut self.refined_spans[len - 1];\n+            if last.is_mergeable(&covspan) {\n+                debug!(\n+                    \"merging new refined span with last refined span, last={:?}, covspan={:?}\",\n+                    last, covspan\n+                );\n+                last.merge_from(covspan);\n+                return;\n+            }\n+        }\n+        self.refined_spans.push(covspan)\n+    }\n+\n+    fn check_invoked_macro_name_span(&mut self) {\n+        if let Some(visible_macro) = self.curr().visible_macro(self.body_span) {\n+            if self.prev_expn_span.map_or(true, |prev_expn_span| {\n+                self.curr().expn_span.ctxt() != prev_expn_span.ctxt()\n+            }) {\n+                let merged_prefix_len = self.curr_original_span.lo() - self.curr().span.lo();\n+                let after_macro_bang = merged_prefix_len\n+                    + BytePos(visible_macro.to_string().bytes().count() as u32 + 1);\n+                let mut macro_name_cov = self.curr().clone();\n+                self.curr_mut().span =\n+                    self.curr().span.with_lo(self.curr().span.lo() + after_macro_bang);\n+                macro_name_cov.span =\n+                    macro_name_cov.span.with_hi(macro_name_cov.span.lo() + after_macro_bang);\n+                debug!(\n+                    \"  and curr starts a new macro expansion, so add a new span just for \\\n+                            the macro `{}!`, new span={:?}\",\n+                    visible_macro, macro_name_cov\n+                );\n+                self.push_refined_span(macro_name_cov);\n+            }\n+        }\n     }\n \n     // Generate a set of `CoverageSpan`s from the filtered set of `Statement`s and `Terminator`s of\n@@ -440,22 +511,15 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     .enumerate()\n                     .filter_map(move |(index, statement)| {\n                         filtered_statement_span(statement, self.body_span).map(\n-                            |(span, is_macro_expansion)| {\n+                            |(span, expn_span)| {\n                                 CoverageSpan::for_statement(\n-                                    statement,\n-                                    span,\n-                                    is_macro_expansion,\n-                                    bcb,\n-                                    bb,\n-                                    index,\n+                                    statement, span, expn_span, bcb, bb, index,\n                                 )\n                             },\n                         )\n                     })\n                     .chain(filtered_terminator_span(data.terminator(), self.body_span).map(\n-                        |(span, is_macro_expansion)| {\n-                            CoverageSpan::for_terminator(span, is_macro_expansion, bcb, bb)\n-                        },\n+                        |(span, expn_span)| CoverageSpan::for_terminator(span, expn_span, bcb, bb),\n                     ))\n             })\n             .collect()\n@@ -509,7 +573,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     let pending_dups = self.pending_dups.split_off(0);\n                     for dup in pending_dups.into_iter() {\n                         debug!(\"    ...adding at least one pending={:?}\", dup);\n-                        self.refined_spans.push(dup);\n+                        self.push_refined_span(dup);\n                     }\n                 } else {\n                     self.pending_dups.clear();\n@@ -521,12 +585,13 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// Advance `prev` to `curr` (if any), and `curr` to the next `CoverageSpan` in sorted order.\n     fn next_coverage_span(&mut self) -> bool {\n         if let Some(curr) = self.some_curr.take() {\n+            self.prev_expn_span = Some(curr.expn_span);\n             self.some_prev = Some(curr);\n             self.prev_original_span = self.curr_original_span;\n         }\n         while let Some(curr) = self.sorted_spans_iter.as_mut().unwrap().next() {\n             debug!(\"FOR curr={:?}\", curr);\n-            if self.prev_starts_after_next(&curr) {\n+            if self.some_prev.is_some() && self.prev_starts_after_next(&curr) {\n                 debug!(\n                     \"  prev.span starts after curr.span, so curr will be dropped (skipping past \\\n                     closure?); prev={:?}\",\n@@ -583,10 +648,10 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                 for mut dup in pending_dups.iter().cloned() {\n                     dup.span = dup.span.with_hi(left_cutoff);\n                     debug!(\"    ...and at least one pre_closure dup={:?}\", dup);\n-                    self.refined_spans.push(dup);\n+                    self.push_refined_span(dup);\n                 }\n             }\n-            self.refined_spans.push(pre_closure);\n+            self.push_refined_span(pre_closure);\n         }\n         if has_post_closure_span {\n             // Update prev.span to start after the closure (and discard curr)\n@@ -597,7 +662,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             }\n             self.pending_dups.append(&mut pending_dups);\n             let closure_covspan = self.take_curr();\n-            self.refined_spans.push(closure_covspan); // since self.prev() was already updated\n+            self.push_refined_span(closure_covspan); // since self.prev() was already updated\n         } else {\n             pending_dups.clear();\n         }\n@@ -688,7 +753,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             } else {\n                 debug!(\"  ... adding modified prev={:?}\", self.prev());\n                 let prev = self.take_prev();\n-                self.refined_spans.push(prev);\n+                self.push_refined_span(prev);\n             }\n         } else {\n             // with `pending_dups`, `prev` cannot have any statements that don't overlap\n@@ -704,7 +769,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n pub(super) fn filtered_statement_span(\n     statement: &'a Statement<'tcx>,\n     body_span: Span,\n-) -> Option<(Span, bool)> {\n+) -> Option<(Span, Span)> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -749,7 +814,7 @@ pub(super) fn filtered_statement_span(\n pub(super) fn filtered_terminator_span(\n     terminator: &'a Terminator<'tcx>,\n     body_span: Span,\n-) -> Option<(Span, bool)> {\n+) -> Option<(Span, Span)> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from\n@@ -789,14 +854,10 @@ pub(super) fn filtered_terminator_span(\n     }\n }\n \n+/// Returns the span within the function source body, and the given span, which will be different\n+/// if the given span is an expansion (macro, syntactic sugar, etc.).\n #[inline]\n-fn function_source_span(span: Span, body_span: Span) -> (Span, bool) {\n-    let is_macro_expansion = span.ctxt() != body_span.ctxt()\n-        && if let ExpnKind::Macro(MacroKind::Bang, _) = span.ctxt().outer_expn_data().kind {\n-            true\n-        } else {\n-            false\n-        };\n-    let span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n-    (if body_span.contains(span) { span } else { body_span }, is_macro_expansion)\n+fn function_source_span(span: Span, body_span: Span) -> (Span, Span) {\n+    let original_span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n+    (if body_span.contains(original_span) { original_span } else { body_span }, span)\n }"}, {"sha": "9b84173c8a29307ba11ed5b15a007c11e8e22177", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f12795f8a0c499a9297182cdc3bb240b36712822/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12795f8a0c499a9297182cdc3bb240b36712822/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=f12795f8a0c499a9297182cdc3bb240b36712822", "patch": "@@ -683,12 +683,12 @@ fn test_make_bcb_counters() {\n         let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n         let mut coverage_spans = Vec::new();\n         for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n-            if let Some((span, is_macro_expansion)) =\n+            if let Some((span, expn_span)) =\n                 spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n             {\n                 coverage_spans.push(spans::CoverageSpan::for_terminator(\n                     span,\n-                    is_macro_expansion,\n+                    expn_span,\n                     bcb,\n                     data.last_bb(),\n                 ));"}, {"sha": "883254a09ba7d64edeac10c5c96dbe7a6abf453c", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.inner_items.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inner_items.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inner_items.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inner_items.txt?ref=f12795f8a0c499a9297182cdc3bb240b36712822", "patch": "@@ -1,9 +1,9 @@\n     1|       |#![allow(unused_assignments, unused_variables, dead_code)]\n     2|       |\n     3|      1|fn main() {\n-    4|       |    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n-    5|       |    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n-    6|       |    // dependent conditions.\n+    4|      1|    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n+    5|      1|    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n+    6|      1|    // dependent conditions.\n     7|      1|    let is_true = std::env::args().len() == 1;\n     8|      1|\n     9|      1|    let mut countdown = 0;"}, {"sha": "5d266b5db15f2f86c47432a8586f91a16dbe48af", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-84561.txt", "status": "modified", "additions": 157, "deletions": 79, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt?ref=f12795f8a0c499a9297182cdc3bb240b36712822", "patch": "@@ -1,17 +1,17 @@\n-    1|       |// FIXME(#84561): function-like macros produce unintuitive coverage results.\n-    2|       |// This test demonstrates some of the problems.\n-    3|       |\n-    4|     18|#[derive(Debug, PartialEq, Eq)]\n-                       ^5                ^0\n+    1|       |// This demonstrated Issue #84561: function-like macros produce unintuitive coverage results.\n+    2|       |\n+    3|       |// expect-exit-status-101\n+    4|     21|#[derive(PartialEq, Eq)]\n+                                  ^0\n   ------------------\n   | <issue_84561::Foo as core::cmp::PartialEq>::eq:\n-  |    4|     18|#[derive(Debug, PartialEq, Eq)]\n+  |    4|     21|#[derive(PartialEq, Eq)]\n   ------------------\n   | Unexecuted instantiation: <issue_84561::Foo as core::cmp::PartialEq>::ne\n   ------------------\n     5|       |struct Foo(u32);\n-    6|       |\n-    7|      1|fn main() {\n+    6|      1|fn test2() {\n+    7|      1|    let is_true = std::env::args().len() == 1;\n     8|      1|    let bar = Foo(1);\n     9|      1|    assert_eq!(bar, Foo(1));\n    10|      1|    let baz = Foo(0);\n@@ -23,80 +23,158 @@\n    16|      1|    assert_eq!(Foo(1), Foo(1));\n    17|      1|    assert_ne!(Foo(0), Foo(1));\n    18|      1|    assert_eq!(Foo(2), Foo(2));\n-   19|      1|    let bar = Foo(1);\n-   20|      1|    assert_ne!(Foo(0), Foo(3));\n+   19|      1|    let bar = Foo(0);\n+   20|      1|    assert_ne!(bar, Foo(3));\n    21|      1|    assert_ne!(Foo(0), Foo(4));\n-   22|      1|    assert_eq!(Foo(3), Foo(3));\n-   23|      1|    assert_ne!(Foo(0), Foo(5));\n-   24|      1|    println!(\"{:?}\", bar);\n-   25|      1|    println!(\"{:?}\", Foo(1));\n-   26|      1|\n-   27|      1|    let is_true = std::env::args().len() == 1;\n-   28|      1|\n-   29|      1|    assert_eq!(\n-   30|      1|        Foo(1),\n-   31|      1|        Foo(1)\n-   32|      1|    );\n-   33|      1|    assert_ne!(\n-   34|      1|        Foo(0),\n-   35|      1|        Foo(1)\n-   36|      1|    );\n-   37|      1|    assert_eq!(\n-   38|      1|        Foo(2),\n-   39|      1|        Foo(2)\n-   40|      1|    );\n-   41|      1|    let bar = Foo(1\n-   42|      1|    );\n-   43|      1|    assert_ne!(\n-   44|      1|        Foo(0),\n-   45|      1|        Foo(3)\n-   46|      1|    );\n-   47|      1|    if is_true {\n-   48|      1|        assert_ne!(\n-   49|      1|            Foo(0),\n-   50|      1|            Foo(4)\n-   51|      1|        );\n-   52|       |    } else {\n-   53|      0|        assert_eq!(\n-   54|      0|            Foo(3),\n-   55|      0|            Foo(3)\n-   56|      0|        );\n-   57|       |    }\n-   58|       |    assert_ne!(\n-   59|      1|        if is_true {\n-   60|      1|            Foo(0)\n-   61|       |        } else {\n-   62|      0|            Foo(1)\n-   63|       |        },\n-   64|       |        Foo(5)\n-   65|       |    );\n-   66|      1|    assert_ne!(\n-   67|      1|        Foo(5),\n-   68|      1|        if is_true {\n-   69|      1|            Foo(0)\n-   70|       |        } else {\n-   71|      0|            Foo(1)\n-   72|       |        }\n-   73|       |    );\n-   74|       |    assert_ne!(\n-   75|      1|        if is_true {\n-   76|      1|            assert_eq!(\n-   77|      1|                Foo(3),\n-   78|      1|                Foo(3)\n-   79|      1|            );\n-   80|      1|            Foo(0)\n-   81|       |        } else {\n-   82|       |            assert_ne!(\n-   83|      0|                if is_true {\n-   84|      0|                    Foo(0)\n-   85|       |                } else {\n-   86|      0|                    Foo(1)\n-   87|       |                },\n-   88|       |                Foo(5)\n-   89|       |            );\n+   22|      1|    assert_eq!(Foo(3), Foo(3), \"with a message\");\n+                                             ^0\n+   23|      1|    println!(\"{:?}\", bar);\n+   24|      1|    println!(\"{:?}\", Foo(1));\n+   25|      1|\n+   26|      1|    assert_ne!(Foo(0), Foo(5), \"{}\", if is_true { \"true message\" } else { \"false message\" });\n+                                             ^0                 ^0                      ^0\n+   27|      1|    assert_ne!(\n+   28|       |        Foo(0)\n+   29|       |        ,\n+   30|       |        Foo(5)\n+   31|       |        ,\n+   32|      0|        \"{}\"\n+   33|      0|        ,\n+   34|      0|        if\n+   35|      0|        is_true\n+   36|       |        {\n+   37|      0|            \"true message\"\n+   38|       |        } else {\n+   39|      0|            \"false message\"\n+   40|       |        }\n+   41|       |    );\n+   42|       |\n+   43|      1|    let is_true = std::env::args().len() == 1;\n+   44|      1|\n+   45|      1|    assert_eq!(\n+   46|      1|        Foo(1),\n+   47|      1|        Foo(1)\n+   48|      1|    );\n+   49|      1|    assert_ne!(\n+   50|      1|        Foo(0),\n+   51|      1|        Foo(1)\n+   52|      1|    );\n+   53|      1|    assert_eq!(\n+   54|      1|        Foo(2),\n+   55|      1|        Foo(2)\n+   56|      1|    );\n+   57|      1|    let bar = Foo(1);\n+   58|      1|    assert_ne!(\n+   59|      1|        bar,\n+   60|      1|        Foo(3)\n+   61|      1|    );\n+   62|      1|    if is_true {\n+   63|      1|        assert_ne!(\n+   64|      1|            Foo(0),\n+   65|      1|            Foo(4)\n+   66|      1|        );\n+   67|       |    } else {\n+   68|      0|        assert_eq!(\n+   69|      0|            Foo(3),\n+   70|      0|            Foo(3)\n+   71|      0|        );\n+   72|       |    }\n+   73|      1|    if is_true {\n+   74|      1|        assert_ne!(\n+   75|       |            Foo(0),\n+   76|       |            Foo(4),\n+   77|      0|            \"with a message\"\n+   78|       |        );\n+   79|       |    } else {\n+   80|      0|        assert_eq!(\n+   81|       |            Foo(3),\n+   82|       |            Foo(3),\n+   83|      0|            \"with a message\"\n+   84|       |        );\n+   85|       |    }\n+   86|      1|    assert_ne!(\n+   87|      1|        if is_true {\n+   88|      1|            Foo(0)\n+   89|       |        } else {\n    90|      0|            Foo(1)\n    91|       |        },\n    92|       |        Foo(5)\n    93|       |    );\n-   94|      1|}\n+   94|      1|    assert_ne!(\n+   95|      1|        Foo(5),\n+   96|      1|        if is_true {\n+   97|      1|            Foo(0)\n+   98|       |        } else {\n+   99|      0|            Foo(1)\n+  100|       |        }\n+  101|       |    );\n+  102|      1|    assert_ne!(\n+  103|      1|        if is_true {\n+  104|      1|            assert_eq!(\n+  105|      1|                Foo(3),\n+  106|      1|                Foo(3)\n+  107|      1|            );\n+  108|      1|            Foo(0)\n+  109|       |        } else {\n+  110|      0|            assert_ne!(\n+  111|      0|                if is_true {\n+  112|      0|                    Foo(0)\n+  113|       |                } else {\n+  114|      0|                    Foo(1)\n+  115|       |                },\n+  116|       |                Foo(5)\n+  117|       |            );\n+  118|      0|            Foo(1)\n+  119|       |        },\n+  120|       |        Foo(5),\n+  121|      0|        \"with a message\"\n+  122|       |    );\n+  123|      1|    assert_eq!(\n+  124|       |        Foo(1),\n+  125|       |        Foo(3),\n+  126|      1|        \"this assert should fail\"\n+  127|       |    );\n+  128|      0|    assert_eq!(\n+  129|       |        Foo(3),\n+  130|       |        Foo(3),\n+  131|      0|        \"this assert should not be reached\"\n+  132|       |    );\n+  133|      0|}\n+  134|       |\n+  135|       |impl std::fmt::Debug for Foo {\n+  136|       |    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+  137|      7|        write!(f, \"try and succeed\")?;\n+                                                  ^0\n+  138|      7|        Ok(())\n+  139|      7|    }\n+  140|       |}\n+  141|       |\n+  142|       |static mut DEBUG_LEVEL_ENABLED: bool = false;\n+  143|       |\n+  144|       |macro_rules! debug {\n+  145|       |    ($($arg:tt)+) => (\n+  146|       |        if unsafe { DEBUG_LEVEL_ENABLED } {\n+  147|       |            println!($($arg)+);\n+  148|       |        }\n+  149|       |    );\n+  150|       |}\n+  151|       |\n+  152|      1|fn test1() {\n+  153|      1|    debug!(\"debug is enabled\");\n+                         ^0\n+  154|      1|    debug!(\"debug is enabled\");\n+                         ^0\n+  155|      1|    let _ = 0;\n+  156|      1|    debug!(\"debug is enabled\");\n+                         ^0\n+  157|      1|    unsafe {\n+  158|      1|        DEBUG_LEVEL_ENABLED = true;\n+  159|      1|    }\n+  160|      1|    debug!(\"debug is enabled\");\n+  161|      1|}\n+  162|       |\n+  163|      1|fn main() {\n+  164|      1|    test1();\n+  165|      1|    test2();\n+  166|      1|}\n "}, {"sha": "c2d5143a61816f881992c53bf2c3fa2a412201dc", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=f12795f8a0c499a9297182cdc3bb240b36712822", "patch": "@@ -3,9 +3,9 @@\n     3|       |use std::fmt::Debug;\n     4|       |\n     5|      1|pub fn used_function() {\n-    6|       |    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n-    7|       |    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n-    8|       |    // dependent conditions.\n+    6|      1|    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n+    7|      1|    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n+    8|      1|    // dependent conditions.\n     9|      1|    let is_true = std::env::args().len() == 1;\n    10|      1|    let mut countdown = 0;\n    11|      1|    if is_true {"}, {"sha": "dab31cbf4ac9eef4770d4c4a0b292c5da3f0aa25", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_inline_crate.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt?ref=f12795f8a0c499a9297182cdc3bb240b36712822", "patch": "@@ -5,9 +5,9 @@\n     5|       |use std::fmt::Debug;\n     6|       |\n     7|      1|pub fn used_function() {\n-    8|       |    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n-    9|       |    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n-   10|       |    // dependent conditions.\n+    8|      1|    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n+    9|      1|    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n+   10|      1|    // dependent conditions.\n    11|      1|    let is_true = std::env::args().len() == 1;\n    12|      1|    let mut countdown = 0;\n    13|      1|    if is_true {\n@@ -19,9 +19,9 @@\n    18|       |\n    19|       |#[inline(always)]\n    20|      1|pub fn used_inline_function() {\n-   21|       |    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n-   22|       |    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n-   23|       |    // dependent conditions.\n+   21|      1|    // Initialize test constants in a way that cannot be determined at compile time, to ensure\n+   22|      1|    // rustc and LLVM cannot optimize out statements (or coverage counters) downstream from\n+   23|      1|    // dependent conditions.\n    24|      1|    let is_true = std::env::args().len() == 1;\n    25|      1|    let mut countdown = 0;\n    26|      1|    if is_true {"}, {"sha": "5c8fd0b7caeaa9c4a2c19f9e2c36bcf818fe0b1b", "filename": "src/test/run-make-fulldeps/coverage/issue-84561.rs", "status": "modified", "additions": 85, "deletions": 13, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12795f8a0c499a9297182cdc3bb240b36712822/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs?ref=f12795f8a0c499a9297182cdc3bb240b36712822", "patch": "@@ -1,10 +1,10 @@\n-// FIXME(#84561): function-like macros produce unintuitive coverage results.\n-// This test demonstrates some of the problems.\n+// This demonstrated Issue #84561: function-like macros produce unintuitive coverage results.\n \n-#[derive(Debug, PartialEq, Eq)]\n+// expect-exit-status-101\n+#[derive(PartialEq, Eq)]\n struct Foo(u32);\n-\n-fn main() {\n+fn test2() {\n+    let is_true = std::env::args().len() == 1;\n     let bar = Foo(1);\n     assert_eq!(bar, Foo(1));\n     let baz = Foo(0);\n@@ -16,14 +16,30 @@ fn main() {\n     assert_eq!(Foo(1), Foo(1));\n     assert_ne!(Foo(0), Foo(1));\n     assert_eq!(Foo(2), Foo(2));\n-    let bar = Foo(1);\n-    assert_ne!(Foo(0), Foo(3));\n+    let bar = Foo(0);\n+    assert_ne!(bar, Foo(3));\n     assert_ne!(Foo(0), Foo(4));\n-    assert_eq!(Foo(3), Foo(3));\n-    assert_ne!(Foo(0), Foo(5));\n+    assert_eq!(Foo(3), Foo(3), \"with a message\");\n     println!(\"{:?}\", bar);\n     println!(\"{:?}\", Foo(1));\n \n+    assert_ne!(Foo(0), Foo(5), \"{}\", if is_true { \"true message\" } else { \"false message\" });\n+    assert_ne!(\n+        Foo(0)\n+        ,\n+        Foo(5)\n+        ,\n+        \"{}\"\n+        ,\n+        if\n+        is_true\n+        {\n+            \"true message\"\n+        } else {\n+            \"false message\"\n+        }\n+    );\n+\n     let is_true = std::env::args().len() == 1;\n \n     assert_eq!(\n@@ -38,10 +54,9 @@ fn main() {\n         Foo(2),\n         Foo(2)\n     );\n-    let bar = Foo(1\n-    );\n+    let bar = Foo(1);\n     assert_ne!(\n-        Foo(0),\n+        bar,\n         Foo(3)\n     );\n     if is_true {\n@@ -55,6 +70,19 @@ fn main() {\n             Foo(3)\n         );\n     }\n+    if is_true {\n+        assert_ne!(\n+            Foo(0),\n+            Foo(4),\n+            \"with a message\"\n+        );\n+    } else {\n+        assert_eq!(\n+            Foo(3),\n+            Foo(3),\n+            \"with a message\"\n+        );\n+    }\n     assert_ne!(\n         if is_true {\n             Foo(0)\n@@ -89,6 +117,50 @@ fn main() {\n             );\n             Foo(1)\n         },\n-        Foo(5)\n+        Foo(5),\n+        \"with a message\"\n+    );\n+    assert_eq!(\n+        Foo(1),\n+        Foo(3),\n+        \"this assert should fail\"\n+    );\n+    assert_eq!(\n+        Foo(3),\n+        Foo(3),\n+        \"this assert should not be reached\"\n+    );\n+}\n+\n+impl std::fmt::Debug for Foo {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"try and succeed\")?;\n+        Ok(())\n+    }\n+}\n+\n+static mut DEBUG_LEVEL_ENABLED: bool = false;\n+\n+macro_rules! debug {\n+    ($($arg:tt)+) => (\n+        if unsafe { DEBUG_LEVEL_ENABLED } {\n+            println!($($arg)+);\n+        }\n     );\n }\n+\n+fn test1() {\n+    debug!(\"debug is enabled\");\n+    debug!(\"debug is enabled\");\n+    let _ = 0;\n+    debug!(\"debug is enabled\");\n+    unsafe {\n+        DEBUG_LEVEL_ENABLED = true;\n+    }\n+    debug!(\"debug is enabled\");\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+}"}]}