{"sha": "819c6d1c048c909fe6bbdde4937dc832cf485849", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxOWM2ZDFjMDQ4YzkwOWZlNmJiZGRlNDkzN2RjODMyY2Y0ODU4NDk=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-02-07T02:35:01Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-02-13T23:08:27Z"}, "message": "deriving-eq all over ast", "tree": {"sha": "1b9189f1ef8634bf6c6bcba1ecb6c11a258f73c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b9189f1ef8634bf6c6bcba1ecb6c11a258f73c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/819c6d1c048c909fe6bbdde4937dc832cf485849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/819c6d1c048c909fe6bbdde4937dc832cf485849", "html_url": "https://github.com/rust-lang/rust/commit/819c6d1c048c909fe6bbdde4937dc832cf485849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/819c6d1c048c909fe6bbdde4937dc832cf485849/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17d3a55362eb6a0b900d1d828e90d583897fa3b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/17d3a55362eb6a0b900d1d828e90d583897fa3b1", "html_url": "https://github.com/rust-lang/rust/commit/17d3a55362eb6a0b900d1d828e90d583897fa3b1"}], "stats": {"total": 583, "additions": 81, "deletions": 502}, "files": [{"sha": "02f7029fac2fe9733ce030ffd8053c273752efd7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 80, "deletions": 502, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/819c6d1c048c909fe6bbdde4937dc832cf485849/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819c6d1c048c909fe6bbdde4937dc832cf485849/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=819c6d1c048c909fe6bbdde4937dc832cf485849", "patch": "@@ -69,6 +69,7 @@ pub type fn_ident = Option<ident>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct path {\n     span: span,\n     global: bool,\n@@ -83,23 +84,18 @@ pub type node_id = int;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct def_id {\n     crate: crate_num,\n     node: node_id,\n }\n \n-pub impl def_id : cmp::Eq {\n-    pure fn eq(&self, other: &def_id) -> bool {\n-        (*self).crate == (*other).crate && (*self).node == (*other).node\n-    }\n-    pure fn ne(&self, other: &def_id) -> bool { !(*self).eq(other) }\n-}\n-\n pub const local_crate: crate_num = 0;\n pub const crate_node_id: node_id = 0;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n@@ -111,6 +107,7 @@ pub enum ty_param_bound {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct ty_param {\n     ident: ident,\n     id: node_id,\n@@ -119,6 +116,7 @@ pub struct ty_param {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum def {\n     def_fn(def_id, purity),\n     def_static_method(/* method */ def_id,\n@@ -147,143 +145,14 @@ pub enum def {\n     def_label(node_id)\n }\n \n-pub impl def : cmp::Eq {\n-    pure fn eq(&self, other: &def) -> bool {\n-        match (*self) {\n-            def_fn(e0a, e1a) => {\n-                match (*other) {\n-                    def_fn(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_static_method(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    def_static_method(e0b, e1b, e2b) =>\n-                    e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            def_self(e0a, e1a) => {\n-                match (*other) {\n-                    def_self(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_self_ty(e0a) => {\n-                match (*other) {\n-                    def_self_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_mod(e0a) => {\n-                match (*other) {\n-                    def_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_foreign_mod(e0a) => {\n-                match (*other) {\n-                    def_foreign_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_const(e0a) => {\n-                match (*other) {\n-                    def_const(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_arg(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    def_arg(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            def_local(e0a, e1a) => {\n-                match (*other) {\n-                    def_local(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_variant(e0a, e1a) => {\n-                match (*other) {\n-                    def_variant(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_ty(e0a) => {\n-                match (*other) {\n-                    def_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_prim_ty(e0a) => {\n-                match (*other) {\n-                    def_prim_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_ty_param(e0a, e1a) => {\n-                match (*other) {\n-                    def_ty_param(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_binding(e0a, e1a) => {\n-                match (*other) {\n-                    def_binding(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_use(e0a) => {\n-                match (*other) {\n-                    def_use(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_upvar(e0a, e1a, e2a, e3a) => {\n-                match (*other) {\n-                    def_upvar(e0b, e1b, e2b, e3b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b && e3a == e3b,\n-                    _ => false\n-                }\n-            }\n-            def_struct(e0a) => {\n-                match (*other) {\n-                    def_struct(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_typaram_binder(e0a) => {\n-                match (*other) {\n-                    def_typaram_binder(e1a) => e0a == e1a,\n-                    _ => false\n-                }\n-            }\n-            def_region(e0a) => {\n-                match (*other) {\n-                    def_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_label(e0a) => {\n-                match (*other) {\n-                    def_label(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &def) -> bool { !(*self).eq(other) }\n-}\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n pub type crate_cfg = ~[@meta_item];\n \n pub type crate = spanned<crate_>;\n \n+#[deriving_eq]\n pub struct crate_ {\n     module: _mod,\n     attrs: ~[attribute],\n@@ -294,6 +163,7 @@ pub type meta_item = spanned<meta_item_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum meta_item_ {\n     meta_word(~str),\n     meta_list(~str, ~[@meta_item]),\n@@ -304,6 +174,7 @@ pub type blk = spanned<blk_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct blk_ {\n     view_items: ~[@view_item],\n     stmts: ~[@stmt],\n@@ -314,6 +185,7 @@ pub struct blk_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct pat {\n     id: node_id,\n     node: pat_,\n@@ -322,6 +194,7 @@ pub struct pat {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct field_pat {\n     ident: ident,\n     pat: @pat,\n@@ -352,6 +225,7 @@ pub impl binding_mode : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -377,6 +251,7 @@ pub enum pat_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n pub impl mutability : to_bytes::IterBytes {\n@@ -385,13 +260,6 @@ pub impl mutability : to_bytes::IterBytes {\n     }\n }\n \n-pub impl mutability : cmp::Eq {\n-    pure fn eq(&self, other: &mutability) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &mutability) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n@@ -440,6 +308,7 @@ pub impl Sigil : ToStr {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),   // [1,2,3,4]\n@@ -450,6 +319,7 @@ pub enum vstore {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum expr_vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     expr_vstore_fixed(Option<uint>),   // [1,2,3,4]\n@@ -462,6 +332,7 @@ pub enum expr_vstore {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum binop {\n     add,\n     subtract,\n@@ -483,15 +354,9 @@ pub enum binop {\n     gt,\n }\n \n-pub impl binop : cmp::Eq {\n-    pure fn eq(&self, other: &binop) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -500,50 +365,11 @@ pub enum unop {\n     neg\n }\n \n-pub impl unop : cmp::Eq {\n-    pure fn eq(&self, other: &unop) -> bool {\n-        match (*self) {\n-            box(e0a) => {\n-                match (*other) {\n-                    box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            uniq(e0a) => {\n-                match (*other) {\n-                    uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            deref => {\n-                match (*other) {\n-                    deref => true,\n-                    _ => false\n-                }\n-            }\n-            not => {\n-                match (*other) {\n-                    not => true,\n-                    _ => false\n-                }\n-            }\n-            neg => {\n-                match (*other) {\n-                    neg => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &unop) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum inferable<T> {\n     expl(T),\n     infer(node_id)\n@@ -561,29 +387,10 @@ pub impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     }\n }\n \n-pub impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n-    pure fn eq(&self, other: &inferable<T>) -> bool {\n-        match (*self) {\n-            expl(ref e0a) => {\n-                match (*other) {\n-                    expl(ref e0b) => (*e0a) == (*e0b),\n-                    _ => false\n-                }\n-            }\n-            infer(e0a) => {\n-                match (*other) {\n-                    infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &inferable<T>) -> bool { !(*self).eq(other) }\n-}\n-\n // \"resolved\" mode: the real modes.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum rmode { by_ref, by_val, by_copy }\n \n pub impl rmode : to_bytes::IterBytes {\n@@ -592,21 +399,14 @@ pub impl rmode : to_bytes::IterBytes {\n     }\n }\n \n-\n-pub impl rmode : cmp::Eq {\n-    pure fn eq(&self, other: &rmode) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &rmode) -> bool { !(*self).eq(other) }\n-}\n-\n // inferable mode.\n pub type mode = inferable<rmode>;\n \n pub type stmt = spanned<stmt_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -624,6 +424,7 @@ pub enum stmt_ {\n // a refinement on pat.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct local_ {\n     is_mutbl: bool,\n     ty: @Ty,\n@@ -638,10 +439,12 @@ pub type decl = spanned<decl_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct arm {\n     pats: ~[@pat],\n     guard: Option<@expr>,\n@@ -650,6 +453,7 @@ pub struct arm {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct field_ {\n     mutbl: mutability,\n     ident: ident,\n@@ -660,22 +464,12 @@ pub type field = spanned<field_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum blk_check_mode { default_blk, unsafe_blk, }\n \n-pub impl blk_check_mode : cmp::Eq {\n-    pure fn eq(&self, other: &blk_check_mode) -> bool {\n-        match ((*self), (*other)) {\n-            (default_blk, default_blk) => true,\n-            (unsafe_blk, unsafe_blk) => true,\n-            (default_blk, _) => false,\n-            (unsafe_blk, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &blk_check_mode) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct expr {\n     id: node_id,\n     // Extra node ID is only used for index, assign_op, unary, binary, method\n@@ -687,6 +481,7 @@ pub struct expr {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum log_level { error, debug, log_other }\n // 0 = error, 1 = debug, 2 = log_other\n \n@@ -701,6 +496,7 @@ pub enum CallSugar {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -777,6 +573,7 @@ pub enum expr_ {\n //\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum token_tree {\n     // a single token\n@@ -851,6 +648,7 @@ pub type matcher = spanned<matcher_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum matcher_ {\n     // match one token\n     match_tok(::parse::token::Token),\n@@ -865,6 +663,7 @@ pub type mac = spanned<mac_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum mac_ {\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n }\n@@ -873,6 +672,7 @@ pub type lit = spanned<lit_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum lit_ {\n     lit_str(@~str),\n     lit_int(i64, int_ty),\n@@ -884,47 +684,19 @@ pub enum lit_ {\n     lit_bool(bool),\n }\n \n-pub impl lit_: cmp::Eq {\n-    pure fn eq(&self, other: &lit_) -> bool {\n-        match ((*self), *other) {\n-            (lit_str(a), lit_str(b)) => a == b,\n-            (lit_int(val_a, ty_a), lit_int(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_uint(val_a, ty_a), lit_uint(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_int_unsuffixed(a), lit_int_unsuffixed(b)) => a == b,\n-            (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_float_unsuffixed(a), lit_float_unsuffixed(b)) => a == b,\n-            (lit_nil, lit_nil) => true,\n-            (lit_bool(a), lit_bool(b)) => a == b,\n-            (lit_str(_), _) => false,\n-            (lit_int(*), _) => false,\n-            (lit_uint(*), _) => false,\n-            (lit_int_unsuffixed(*), _) => false,\n-            (lit_float(*), _) => false,\n-            (lit_float_unsuffixed(*), _) => false,\n-            (lit_nil, _) => false,\n-            (lit_bool(_), _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &lit_) -> bool { !(*self).eq(other) }\n-}\n-\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct mt {\n     ty: @Ty,\n     mutbl: mutability,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct ty_field_ {\n     ident: ident,\n     mt: mt,\n@@ -934,6 +706,7 @@ pub type ty_field = spanned<ty_field_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct ty_method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -947,6 +720,7 @@ pub struct ty_method {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -957,6 +731,7 @@ pub enum trait_method {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n pub impl int_ty : ToStr {\n@@ -971,28 +746,9 @@ pub impl int_ty : to_bytes::IterBytes {\n     }\n }\n \n-pub impl int_ty : cmp::Eq {\n-    pure fn eq(&self, other: &int_ty) -> bool {\n-        match ((*self), (*other)) {\n-            (ty_i, ty_i) => true,\n-            (ty_char, ty_char) => true,\n-            (ty_i8, ty_i8) => true,\n-            (ty_i16, ty_i16) => true,\n-            (ty_i32, ty_i32) => true,\n-            (ty_i64, ty_i64) => true,\n-            (ty_i, _) => false,\n-            (ty_char, _) => false,\n-            (ty_i8, _) => false,\n-            (ty_i16, _) => false,\n-            (ty_i32, _) => false,\n-            (ty_i64, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &int_ty) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n pub impl uint_ty : ToStr {\n@@ -1007,26 +763,9 @@ pub impl uint_ty : to_bytes::IterBytes {\n     }\n }\n \n-pub impl uint_ty : cmp::Eq {\n-    pure fn eq(&self, other: &uint_ty) -> bool {\n-        match ((*self), (*other)) {\n-            (ty_u, ty_u) => true,\n-            (ty_u8, ty_u8) => true,\n-            (ty_u16, ty_u16) => true,\n-            (ty_u32, ty_u32) => true,\n-            (ty_u64, ty_u64) => true,\n-            (ty_u, _) => false,\n-            (ty_u8, _) => false,\n-            (ty_u16, _) => false,\n-            (ty_u32, _) => false,\n-            (ty_u64, _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &uint_ty) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n pub impl float_ty : ToStr {\n@@ -1041,16 +780,7 @@ pub impl float_ty : to_bytes::IterBytes {\n     }\n }\n \n-pub impl float_ty : cmp::Eq {\n-    pure fn eq(&self, other: &float_ty) -> bool {\n-        match ((*self), (*other)) {\n-            (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n-            (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &float_ty) -> bool { !(*self).eq(other) }\n-}\n-\n+// NB Eq method appears below.\n #[auto_encode]\n #[auto_decode]\n pub struct Ty {\n@@ -1062,6 +792,7 @@ pub struct Ty {\n // Not represented directly in the AST, referred to by name through a ty_path.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -1070,53 +801,17 @@ pub enum prim_ty {\n     ty_bool,\n }\n \n-pub impl prim_ty : cmp::Eq {\n-    pure fn eq(&self, other: &prim_ty) -> bool {\n-        match (*self) {\n-            ty_int(e0a) => {\n-                match (*other) {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match (*other) {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match (*other) {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_str => {\n-                match (*other) {\n-                    ty_str => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match (*other) {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &prim_ty) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct region {\n     id: node_id,\n     node: region_,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum region_ {\n     re_anon,\n     re_static,\n@@ -1149,6 +844,7 @@ pub impl Onceness : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct TyClosure {\n     sigil: Sigil,\n     region: Option<@region>,\n@@ -1167,6 +863,7 @@ pub struct TyBareFn {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -1207,6 +904,7 @@ pub impl Ty : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct arg {\n     mode: mode,\n     is_mutbl: bool,\n@@ -1217,6 +915,7 @@ pub struct arg {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct fn_decl {\n     inputs: ~[arg],\n     output: @Ty,\n@@ -1225,6 +924,7 @@ pub struct fn_decl {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n@@ -1249,15 +949,9 @@ pub impl purity : to_bytes::IterBytes {\n     }\n }\n \n-pub impl purity : cmp::Eq {\n-    pure fn eq(&self, other: &purity) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &purity) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n@@ -1270,20 +964,9 @@ pub impl ret_style : to_bytes::IterBytes {\n     }\n }\n \n-pub impl ret_style : cmp::Eq {\n-    pure fn eq(&self, other: &ret_style) -> bool {\n-        match ((*self), (*other)) {\n-            (noreturn, noreturn) => true,\n-            (return_val, return_val) => true,\n-            (noreturn, _) => false,\n-            (return_val, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &ret_style) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n@@ -1293,54 +976,11 @@ pub enum self_ty_ {\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }\n \n-pub impl self_ty_ : cmp::Eq {\n-    pure fn eq(&self, other: &self_ty_) -> bool {\n-        match (*self) {\n-            sty_static => {\n-                match (*other) {\n-                    sty_static => true,\n-                    _ => false\n-                }\n-            }\n-            sty_by_ref => {\n-                match (*other) {\n-                    sty_by_ref => true,\n-                    _ => false\n-                }\n-            }\n-            sty_value => {\n-                match (*other) {\n-                    sty_value => true,\n-                    _ => false\n-                }\n-            }\n-            sty_region(e0a) => {\n-                match (*other) {\n-                    sty_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_box(e0a) => {\n-                match (*other) {\n-                    sty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_uniq(e0a) => {\n-                match (*other) {\n-                    sty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &self_ty_) -> bool { !(*self).eq(other) }\n-}\n-\n pub type self_ty = spanned<self_ty_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1357,13 +997,15 @@ pub struct method {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct _mod {\n     view_items: ~[@view_item],\n     items: ~[@item],\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum foreign_abi {\n     foreign_abi_rust_intrinsic,\n     foreign_abi_cdecl,\n@@ -1373,31 +1015,12 @@ pub enum foreign_abi {\n // Foreign mods can be named or anonymous\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum foreign_mod_sort { named, anonymous }\n \n-pub impl foreign_mod_sort : cmp::Eq {\n-    pure fn eq(&self, other: &foreign_mod_sort) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &foreign_mod_sort) -> bool { !(*self).eq(other) }\n-}\n-\n-pub impl foreign_abi : cmp::Eq {\n-    pure fn eq(&self, other: &foreign_abi) -> bool {\n-        match ((*self), (*other)) {\n-            (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n-            (foreign_abi_cdecl, foreign_abi_cdecl) => true,\n-            (foreign_abi_stdcall, foreign_abi_stdcall) => true,\n-            (foreign_abi_rust_intrinsic, _) => false,\n-            (foreign_abi_cdecl, _) => false,\n-            (foreign_abi_stdcall, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &foreign_abi) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abi: ident,\n@@ -1407,13 +1030,15 @@ pub struct foreign_mod {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct variant_arg {\n     ty: @Ty,\n     id: node_id,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n@@ -1422,17 +1047,20 @@ pub enum variant_kind {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct enum_def_ {\n     variants: ~[variant],\n     common: Option<@struct_def>,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum enum_def = enum_def_;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct variant_ {\n     name: ident,\n     attrs: ~[attribute],\n@@ -1446,6 +1074,7 @@ pub type variant = spanned<variant_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct path_list_ident_ {\n     name: ident,\n     id: node_id,\n@@ -1455,19 +1084,14 @@ pub type path_list_ident = spanned<path_list_ident_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum namespace { module_ns, type_value_ns }\n \n-pub impl namespace : cmp::Eq {\n-    pure fn eq(&self, other: &namespace) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &namespace) -> bool { !(*self).eq(other) }\n-}\n-\n pub type view_path = spanned<view_path_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1486,6 +1110,7 @@ pub enum view_path_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct view_item {\n     node: view_item_,\n     attrs: ~[attribute],\n@@ -1495,6 +1120,7 @@ pub struct view_item {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum view_item_ {\n     view_item_use(ident, ~[@meta_item], node_id),\n     view_item_import(~[@view_path]),\n@@ -1508,18 +1134,13 @@ pub type attribute = spanned<attribute_>;\n // distinguished for pretty-printing.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum attr_style { attr_outer, attr_inner, }\n \n-pub impl attr_style : cmp::Eq {\n-    pure fn eq(&self, other: &attr_style) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &attr_style) -> bool { !(*self).eq(other) }\n-}\n-\n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct attribute_ {\n     style: attr_style,\n     value: meta_item,\n@@ -1535,31 +1156,20 @@ pub struct attribute_ {\n  */\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct trait_ref {\n     path: @path,\n     ref_id: node_id,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum visibility { public, private, inherited }\n \n-pub impl visibility : cmp::Eq {\n-    pure fn eq(&self, other: &visibility) -> bool {\n-        match ((*self), (*other)) {\n-            (public, public) => true,\n-            (private, private) => true,\n-            (inherited, inherited) => true,\n-            (public, _) => false,\n-            (private, _) => false,\n-            (inherited, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &visibility) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n@@ -1570,40 +1180,15 @@ pub type struct_field = spanned<struct_field_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum struct_field_kind {\n     named_field(ident, struct_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n-pub impl struct_field_kind : cmp::Eq {\n-    pure fn eq(&self, other: &struct_field_kind) -> bool {\n-        match (*self) {\n-            named_field(ident_a, struct_mutability_a, visibility_a) => {\n-                match *other {\n-                    named_field(ident_b, struct_mutability_b, visibility_b)\n-                            => {\n-                        ident_a == ident_b &&\n-                        struct_mutability_a == struct_mutability_b &&\n-                        visibility_a == visibility_b\n-                    }\n-                    unnamed_field => false\n-                }\n-            }\n-            unnamed_field => {\n-                match *other {\n-                    named_field(*) => false,\n-                    unnamed_field => true\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &struct_field_kind) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct struct_def {\n     fields: ~[@struct_field], /* fields */\n     /* (not including ctor or dtor) */\n@@ -1620,6 +1205,7 @@ pub struct struct_def {\n  */\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1631,6 +1217,7 @@ pub struct item {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum item_ {\n     item_const(@Ty, @expr),\n     item_fn(fn_decl, purity, ~[ty_param], blk),\n@@ -1641,14 +1228,15 @@ pub enum item_ {\n     item_struct(@struct_def, ~[ty_param]),\n     item_trait(~[ty_param], ~[@trait_ref], ~[trait_method]),\n     item_impl(~[ty_param],\n-              Option<@trait_ref>, /* (optional) trait this impl implements */\n-              @Ty, /* self */\n+              Option<@trait_ref>, // (optional) trait this impl implements\n+              @Ty, // self\n               ~[@method]),\n     item_mac(mac),\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum struct_mutability { struct_mutable, struct_immutable }\n \n pub impl struct_mutability : to_bytes::IterBytes {\n@@ -1657,24 +1245,11 @@ pub impl struct_mutability : to_bytes::IterBytes {\n     }\n }\n \n-pub impl struct_mutability : cmp::Eq {\n-    pure fn eq(&self, other: &struct_mutability) -> bool {\n-        match ((*self), (*other)) {\n-            (struct_mutable, struct_mutable) => true,\n-            (struct_immutable, struct_immutable) => true,\n-            (struct_mutable, _) => false,\n-            (struct_immutable, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &struct_mutability) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n pub type struct_dtor = spanned<struct_dtor_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct struct_dtor_ {\n     id: node_id,\n     attrs: ~[attribute],\n@@ -1684,6 +1259,7 @@ pub struct struct_dtor_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct foreign_item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1695,6 +1271,7 @@ pub struct foreign_item {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, ~[ty_param]),\n     foreign_item_const(@Ty)\n@@ -1705,6 +1282,7 @@ pub enum foreign_item_ {\n // that we trans.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),"}, {"sha": "3fbf732c14376cc0a63b8e0f7dae4d8c74f5baff", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/819c6d1c048c909fe6bbdde4937dc832cf485849/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819c6d1c048c909fe6bbdde4937dc832cf485849/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=819c6d1c048c909fe6bbdde4937dc832cf485849", "patch": "@@ -130,6 +130,7 @@ pub struct span {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct spanned<T> { node: T, span: span }\n \n pub impl span : cmp::Eq {"}]}