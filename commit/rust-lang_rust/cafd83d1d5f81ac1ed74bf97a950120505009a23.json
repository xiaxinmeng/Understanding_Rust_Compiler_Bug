{"sha": "cafd83d1d5f81ac1ed74bf97a950120505009a23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZmQ4M2QxZDVmODFhYzFlZDc0YmY5N2E5NTAxMjA1MDUwMDlhMjM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-11T11:07:01Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: don't keep RegionHighlightMode in a thread-local.", "tree": {"sha": "2d0605a923fe082b5ce47e5611340e7d3ddbeadc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d0605a923fe082b5ce47e5611340e7d3ddbeadc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cafd83d1d5f81ac1ed74bf97a950120505009a23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cafd83d1d5f81ac1ed74bf97a950120505009a23", "html_url": "https://github.com/rust-lang/rust/commit/cafd83d1d5f81ac1ed74bf97a950120505009a23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cafd83d1d5f81ac1ed74bf97a950120505009a23/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4eecef0b256850166fdb0070568544f2380115", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4eecef0b256850166fdb0070568544f2380115", "html_url": "https://github.com/rust-lang/rust/commit/7c4eecef0b256850166fdb0070568544f2380115"}], "stats": {"total": 640, "additions": 334, "deletions": 306}, "files": [{"sha": "26deecfdbf0fc74a9a4801076dc6c4dc6107fc1a", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=cafd83d1d5f81ac1ed74bf97a950120505009a23", "patch": "@@ -3,6 +3,7 @@ use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOrigin;\n use crate::ty::{self, Ty, Infer, TyVar};\n+use ty::print::Print;\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -64,18 +65,28 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n \n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn extract_type_name(&self, ty: &'a Ty<'tcx>) -> String {\n+    pub fn extract_type_name(\n+        &self,\n+        ty: &'a Ty<'tcx>,\n+        highlight: Option<ty::print::RegionHighlightMode>,\n+    ) -> String {\n         if let ty::Infer(ty::TyVar(ty_vid)) = (*ty).sty {\n             let ty_vars = self.type_variables.borrow();\n             if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n                 *ty_vars.var_origin(ty_vid) {\n-                name.to_string()\n-            } else {\n-                ty.to_string()\n+                return name.to_string();\n             }\n-        } else {\n-            ty.to_string()\n         }\n+\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(&mut s);\n+        if let Some(highlight) = highlight {\n+            printer.region_highlight_mode = highlight;\n+        }\n+        let _ = ty::print::PrintCx::with(self.tcx, printer, |cx| {\n+            ty.print(cx)\n+        });\n+        s\n     }\n \n     pub fn need_type_info_err(&self,\n@@ -84,7 +95,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             ty: Ty<'tcx>)\n                             -> DiagnosticBuilder<'gcx> {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty);\n+        let name = self.extract_type_name(&ty, None);\n \n         let mut err_span = span;\n         let mut labels = vec![("}, {"sha": "65fcc69a338675c38ffc9ec65f9edde6df3912ca", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 124, "deletions": 106, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=cafd83d1d5f81ac1ed74bf97a950120505009a23", "patch": "@@ -5,10 +5,12 @@ use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n-use crate::ty;\n+use crate::ty::{self, TyCtxt};\n use crate::ty::error::ExpectedFound;\n use crate::ty::subst::SubstsRef;\n-use crate::util::ppaux::RegionHighlightMode;\n+use crate::ty::print::{Print, RegionHighlightMode, FmtPrinter};\n+\n+use std::fmt::{self, Write};\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n@@ -309,13 +311,48 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         sup_placeholder: Option<ty::Region<'tcx>>,\n         has_sub: Option<usize>,\n         has_sup: Option<usize>,\n-        expected_trait_ref: ty::TraitRef<'_>,\n-        actual_trait_ref: ty::TraitRef<'_>,\n+        expected_trait_ref: ty::TraitRef<'tcx>,\n+        actual_trait_ref: ty::TraitRef<'tcx>,\n         vid: Option<ty::Region<'tcx>>,\n         expected_has_vid: Option<usize>,\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n     ) {\n+        // HACK(eddyb) maybe move this in a more central location.\n+        #[derive(Copy, Clone)]\n+        struct Highlighted<'a, 'gcx, 'tcx, T> {\n+            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            highlight: RegionHighlightMode,\n+            value: T,\n+        }\n+\n+        impl<'a, 'gcx, 'tcx, T> Highlighted<'a, 'gcx, 'tcx, T> {\n+            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'a, 'gcx, 'tcx, U> {\n+                Highlighted {\n+                    tcx: self.tcx,\n+                    highlight: self.highlight,\n+                    value: f(self.value),\n+                }\n+            }\n+        }\n+\n+        impl<'tcx, T> fmt::Display for Highlighted<'_, '_, 'tcx, T>\n+            where T: for<'a, 'b> Print<'tcx,\n+                FmtPrinter<&'a mut fmt::Formatter<'b>>,\n+                Error = fmt::Error,\n+            >,\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                let mut printer = ty::print::FmtPrinter::new(f);\n+                printer.region_highlight_mode = self.highlight;\n+\n+                ty::print::PrintCx::with(self.tcx, printer, |cx| {\n+                    self.value.print(cx)?;\n+                    Ok(())\n+                })\n+            }\n+        }\n+\n         // The weird thing here with the `maybe_highlighting_region` calls and the\n         // the match inside is meant to be like this:\n         //\n@@ -331,112 +368,93 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         // None, an then we check again inside the closure, but this\n         // setup sort of minimized the number of calls and so form.\n \n-        RegionHighlightMode::maybe_highlighting_region(sub_placeholder, has_sub, || {\n-            RegionHighlightMode::maybe_highlighting_region(sup_placeholder, has_sup, || {\n-                match (has_sub, has_sup) {\n-                    (Some(n1), Some(n2)) => {\n-                        if any_self_ty_has_vid {\n-                            err.note(&format!(\n-                                \"`{}` would have to be implemented for the type `{}`, \\\n-                                 for any two lifetimes `'{}` and `'{}`\",\n-                                expected_trait_ref,\n-                                expected_trait_ref.self_ty(),\n-                                std::cmp::min(n1, n2),\n-                                std::cmp::max(n1, n2),\n-                            ));\n-                        } else {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}`, \\\n-                                 for any two lifetimes `'{}` and `'{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                                std::cmp::min(n1, n2),\n-                                std::cmp::max(n1, n2),\n-                            ));\n-                        }\n-                    }\n-                    (Some(n), _) | (_, Some(n)) => {\n-                        if any_self_ty_has_vid {\n-                            err.note(&format!(\n-                                \"`{}` would have to be implemented for the type `{}`, \\\n-                                 for any lifetime `'{}`\",\n-                                expected_trait_ref,\n-                                expected_trait_ref.self_ty(),\n-                                n,\n-                            ));\n-                        } else {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}`, for any lifetime `'{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                                n,\n-                            ));\n-                        }\n-                    }\n-                    (None, None) => RegionHighlightMode::maybe_highlighting_region(\n-                        vid,\n-                        expected_has_vid,\n-                        || {\n-                            if let Some(n) = expected_has_vid {\n-                                err.note(&format!(\n-                                    \"`{}` would have to be implemented for the type `{}`, \\\n-                                     for some specific lifetime `'{}`\",\n-                                    expected_trait_ref,\n-                                    expected_trait_ref.self_ty(),\n-                                    n,\n-                                ));\n-                            } else {\n-                                if any_self_ty_has_vid {\n-                                    err.note(&format!(\n-                                        \"`{}` would have to be implemented for the type `{}`\",\n-                                        expected_trait_ref,\n-                                        expected_trait_ref.self_ty(),\n-                                    ));\n-                                } else {\n-                                    err.note(&format!(\n-                                        \"`{}` must implement `{}`\",\n-                                        expected_trait_ref.self_ty(),\n-                                        expected_trait_ref,\n-                                    ));\n-                                }\n-                            }\n-                        },\n-                    ),\n-                }\n-            })\n-        });\n+        let highlight_trait_ref = |trait_ref| Highlighted {\n+            tcx: self.tcx(),\n+            highlight: RegionHighlightMode::default(),\n+            value: trait_ref,\n+        };\n \n-        RegionHighlightMode::maybe_highlighting_region(\n-            vid,\n-            actual_has_vid,\n-            || match actual_has_vid {\n-                Some(n) => {\n-                    if any_self_ty_has_vid {\n-                        err.note(&format!(\n-                            \"but `{}` is actually implemented for the type `{}`, \\\n-                             for some specific lifetime `'{}`\",\n-                            actual_trait_ref,\n-                            actual_trait_ref.self_ty(),\n-                            n\n-                        ));\n-                    } else {\n-                        err.note(&format!(\n-                            \"but `{}` actually implements `{}`, for some specific lifetime `'{}`\",\n-                            actual_trait_ref.self_ty(),\n-                            actual_trait_ref,\n-                            n\n-                        ));\n+        let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n+        expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n+        expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n+        err.note(&{\n+            let passive_voice = match (has_sub, has_sup) {\n+                (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n+                (None, None) => {\n+                    expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n+                    match expected_has_vid {\n+                        Some(_) => true,\n+                        None => any_self_ty_has_vid,\n                     }\n                 }\n+            };\n \n-                _ => {\n-                    err.note(&format!(\n-                        \"but `{}` is actually implemented for the type `{}`\",\n-                        actual_trait_ref,\n-                        actual_trait_ref.self_ty(),\n-                    ));\n+            let mut note = if passive_voice {\n+                format!(\n+                    \"`{}` would have to be implemented for the type `{}`\",\n+                    expected_trait_ref,\n+                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                )\n+            } else {\n+                format!(\n+                    \"`{}` must implement `{}`\",\n+                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                    expected_trait_ref,\n+                )\n+            };\n+\n+            match (has_sub, has_sup) {\n+                (Some(n1), Some(n2)) => {\n+                    let _ = write!(note,\n+                        \", for any two lifetimes `'{}` and `'{}`\",\n+                        std::cmp::min(n1, n2),\n+                        std::cmp::max(n1, n2),\n+                    );\n                 }\n-            },\n-        );\n+                (Some(n), _) | (_, Some(n)) => {\n+                    let _ = write!(note,\n+                        \", for any lifetime `'{}`\",\n+                        n,\n+                    );\n+                }\n+                (None, None) => if let Some(n) = expected_has_vid {\n+                    let _ = write!(note,\n+                        \", for some specific lifetime `'{}`\",\n+                        n,\n+                    );\n+                },\n+            }\n+\n+            note\n+        });\n+\n+        let mut actual_trait_ref = highlight_trait_ref(actual_trait_ref);\n+        actual_trait_ref.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+        err.note(&{\n+            let passive_voice = match actual_has_vid {\n+                Some(_) => any_self_ty_has_vid,\n+                None => true,\n+            };\n+\n+            let mut note = if passive_voice {\n+                format!(\n+                    \"but `{}` is actually implemented for the type `{}`\",\n+                    actual_trait_ref,\n+                    actual_trait_ref.map(|tr| tr.self_ty()),\n+                )\n+            } else {\n+                format!(\n+                    \"but `{}` actually implements `{}`\",\n+                    actual_trait_ref.map(|tr| tr.self_ty()),\n+                    actual_trait_ref,\n+                )\n+            };\n+\n+            if let Some(n) = actual_has_vid {\n+                let _ = write!(note, \", for some specific lifetime `'{}`\", n);\n+            }\n+\n+            note\n+        });\n     }\n }"}, {"sha": "28e21b28f7e449ded41274e47318778660f798d1", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=cafd83d1d5f81ac1ed74bf97a950120505009a23", "patch": "@@ -47,6 +47,102 @@ pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n // FIXME(eddyb) this module uses `pub(crate)` for things used only\n // from `ppaux` - when that is removed, they can be re-privatized.\n \n+/// The \"region highlights\" are used to control region printing during\n+/// specific error messages. When a \"region highlight\" is enabled, it\n+/// gives an alternate way to print specific regions. For now, we\n+/// always print those regions using a number, so something like \"`'0`\".\n+///\n+/// Regions not selected by the region highlight mode are presently\n+/// unaffected.\n+#[derive(Copy, Clone, Default)]\n+pub struct RegionHighlightMode {\n+    /// If enabled, when we see the selected region, use \"`'N`\"\n+    /// instead of the ordinary behavior.\n+    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n+\n+    /// If enabled, when printing a \"free region\" that originated from\n+    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n+    /// have names print as normal.\n+    ///\n+    /// This is used when you have a signature like `fn foo(x: &u32,\n+    /// y: &'a u32)` and we want to give a name to the region of the\n+    /// reference `x`.\n+    pub(crate) highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n+}\n+\n+impl RegionHighlightMode {\n+    /// If `region` and `number` are both `Some`, invokes\n+    /// `highlighting_region`.\n+    pub fn maybe_highlighting_region(\n+        &mut self,\n+        region: Option<ty::Region<'_>>,\n+        number: Option<usize>,\n+    ) {\n+        if let Some(k) = region {\n+            if let Some(n) = number {\n+                self.highlighting_region(k, n);\n+            }\n+        }\n+    }\n+\n+    /// Highlights the region inference variable `vid` as `'N`.\n+    pub fn highlighting_region(\n+        &mut self,\n+        region: ty::Region<'_>,\n+        number: usize,\n+    ) {\n+        let num_slots = self.highlight_regions.len();\n+        let first_avail_slot = self.highlight_regions.iter_mut()\n+            .filter(|s| s.is_none())\n+            .next()\n+            .unwrap_or_else(|| {\n+                bug!(\n+                    \"can only highlight {} placeholders at a time\",\n+                    num_slots,\n+                )\n+            });\n+        *first_avail_slot = Some((*region, number));\n+    }\n+\n+    /// Convenience wrapper for `highlighting_region`.\n+    pub fn highlighting_region_vid(\n+        &mut self,\n+        vid: ty::RegionVid,\n+        number: usize,\n+    ) {\n+        self.highlighting_region(&ty::ReVar(vid), number)\n+    }\n+\n+    /// Returns `Some(n)` with the number to use for the given region, if any.\n+    pub(crate) fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n+        self\n+            .highlight_regions\n+            .iter()\n+            .filter_map(|h| match h {\n+                Some((r, n)) if r == region => Some(*n),\n+                _ => None,\n+            })\n+            .next()\n+    }\n+\n+    /// Highlight the given bound region.\n+    /// We can only highlight one bound region at a time. See\n+    /// the field `highlight_bound_region` for more detailed notes.\n+    pub fn highlighting_bound_region(\n+        &mut self,\n+        br: ty::BoundRegion,\n+        number: usize,\n+    ) {\n+        assert!(self.highlight_bound_region.is_none());\n+        self.highlight_bound_region = Some((br, number));\n+    }\n+\n+    /// Returns `Some(N)` if the placeholder `p` is highlighted to print as \"`'N`\".\n+    pub(crate) fn placeholder_highlight(&self, p: ty::PlaceholderRegion) -> Option<usize> {\n+        self.region_highlighted(&ty::RePlaceholder(p))\n+    }\n+}\n+\n struct LateBoundRegionNameCollector(FxHashSet<InternedString>);\n impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n@@ -237,6 +333,10 @@ pub trait PrettyPrinter: Printer<Error = fmt::Error, Path = Self> + fmt::Write {\n             config: self.config,\n         })\n     }\n+\n+    fn region_highlight_mode(&self) -> RegionHighlightMode {\n+        RegionHighlightMode::default()\n+    }\n }\n \n macro_rules! nest {\n@@ -450,13 +550,15 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n pub struct FmtPrinter<F: fmt::Write> {\n     pub(crate) fmt: F,\n     empty: bool,\n+    pub region_highlight_mode: RegionHighlightMode,\n }\n \n impl<F: fmt::Write> FmtPrinter<F> {\n     pub fn new(fmt: F) -> Self {\n         FmtPrinter {\n             fmt,\n             empty: true,\n+            region_highlight_mode: RegionHighlightMode::default(),\n         }\n     }\n }\n@@ -920,4 +1022,8 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n             config: self.config,\n         })\n     }\n+\n+    fn region_highlight_mode(&self) -> RegionHighlightMode {\n+        self.region_highlight_mode\n+    }\n }"}, {"sha": "d4111e0375f1613a12b09aff43915208937c6141", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 32, "deletions": 161, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cafd83d1d5f81ac1ed74bf97a950120505009a23", "patch": "@@ -12,7 +12,6 @@ use crate::ty::{self, ParamConst, Ty, TypeFoldable};\n use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print, Printer};\n use crate::mir::interpret::ConstValue;\n \n-use std::cell::Cell;\n use std::fmt::{self, Write as _};\n use std::iter;\n use std::usize;\n@@ -22,142 +21,6 @@ use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::{Symbol, InternedString};\n use crate::hir;\n \n-/// The \"region highlights\" are used to control region printing during\n-/// specific error messages. When a \"region highlight\" is enabled, it\n-/// gives an alternate way to print specific regions. For now, we\n-/// always print those regions using a number, so something like \"`'0`\".\n-///\n-/// Regions not selected by the region highlight mode are presently\n-/// unaffected.\n-#[derive(Copy, Clone, Default)]\n-pub struct RegionHighlightMode {\n-    /// If enabled, when we see the selected region, use \"`'N`\"\n-    /// instead of the ordinary behavior.\n-    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n-\n-    /// If enabled, when printing a \"free region\" that originated from\n-    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n-    /// have names print as normal.\n-    ///\n-    /// This is used when you have a signature like `fn foo(x: &u32,\n-    /// y: &'a u32)` and we want to give a name to the region of the\n-    /// reference `x`.\n-    highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n-}\n-\n-thread_local! {\n-    /// Mechanism for highlighting of specific regions for display in NLL region inference errors.\n-    /// Contains region to highlight and counter for number to use when highlighting.\n-    static REGION_HIGHLIGHT_MODE: Cell<RegionHighlightMode> =\n-        Cell::new(RegionHighlightMode::default())\n-}\n-\n-impl RegionHighlightMode {\n-    /// Reads and returns the current region highlight settings (accesses thread-local state).\n-    pub fn get() -> Self {\n-        REGION_HIGHLIGHT_MODE.with(|c| c.get())\n-    }\n-\n-    // Internal helper to update current settings during the execution of `op`.\n-    fn set<R>(\n-        old_mode: Self,\n-        new_mode: Self,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        REGION_HIGHLIGHT_MODE.with(|c| {\n-            c.set(new_mode);\n-            let result = op();\n-            c.set(old_mode);\n-            result\n-        })\n-    }\n-\n-    /// If `region` and `number` are both `Some`, invokes\n-    /// `highlighting_region`; otherwise, just invokes `op` directly.\n-    pub fn maybe_highlighting_region<R>(\n-        region: Option<ty::Region<'_>>,\n-        number: Option<usize>,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        if let Some(k) = region {\n-            if let Some(n) = number {\n-                return Self::highlighting_region(k, n, op);\n-            }\n-        }\n-\n-        op()\n-    }\n-\n-    /// During the execution of `op`, highlights the region inference\n-    /// variable `vid` as `'N`. We can only highlight one region `vid`\n-    /// at a time.\n-    pub fn highlighting_region<R>(\n-        region: ty::Region<'_>,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        let old_mode = Self::get();\n-        let mut new_mode = old_mode;\n-        let first_avail_slot = new_mode.highlight_regions.iter_mut()\n-            .filter(|s| s.is_none())\n-            .next()\n-            .unwrap_or_else(|| {\n-                panic!(\n-                    \"can only highlight {} placeholders at a time\",\n-                    old_mode.highlight_regions.len(),\n-                )\n-            });\n-        *first_avail_slot = Some((*region, number));\n-        Self::set(old_mode, new_mode, op)\n-    }\n-\n-    /// Convenience wrapper for `highlighting_region`.\n-    pub fn highlighting_region_vid<R>(\n-        vid: ty::RegionVid,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        Self::highlighting_region(&ty::ReVar(vid), number, op)\n-    }\n-\n-    /// Returns `Some(n)` with the number to use for the given region, if any.\n-    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n-        Self::get()\n-            .highlight_regions\n-            .iter()\n-            .filter_map(|h| match h {\n-                Some((r, n)) if r == region => Some(*n),\n-                _ => None,\n-            })\n-            .next()\n-    }\n-\n-    /// During the execution of `op`, highlight the given bound\n-    /// region. We can only highlight one bound region at a time. See\n-    /// the field `highlight_bound_region` for more detailed notes.\n-    pub fn highlighting_bound_region<R>(\n-        br: ty::BoundRegion,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        let old_mode = Self::get();\n-        assert!(old_mode.highlight_bound_region.is_none());\n-        Self::set(\n-            old_mode,\n-            Self {\n-                highlight_bound_region: Some((br, number)),\n-                ..old_mode\n-            },\n-            op,\n-        )\n-    }\n-\n-    /// Returns `Some(N)` if the placeholder `p` is highlighted to print as \"`'N`\".\n-    pub fn placeholder_highlight(&self, p: ty::PlaceholderRegion) -> Option<usize> {\n-        self.region_highlighted(&ty::RePlaceholder(p))\n-    }\n-}\n-\n macro_rules! gen_display_debug_body {\n     ( $with:path ) => {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -622,7 +485,7 @@ define_print! {\n                 }\n             }\n \n-            let highlight = RegionHighlightMode::get();\n+            let highlight = cx.printer.region_highlight_mode();\n             if let Some((region, counter)) = highlight.highlight_bound_region {\n                 if *self == region {\n                     p!(write(\"'{}\", counter));\n@@ -647,7 +510,9 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::BoundRegion {\n-    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool\n+        where P: PrettyPrinter\n+    {\n         if cx.config.is_verbose {\n             return true;\n         }\n@@ -658,7 +523,7 @@ impl ty::BoundRegion {\n             }\n         }\n \n-        let highlight = RegionHighlightMode::get();\n+        let highlight = cx.printer.region_highlight_mode();\n         if let Some((region, _)) = highlight.highlight_bound_region {\n             if *self == region {\n                 return true;\n@@ -676,7 +541,7 @@ define_print! {\n                 return self.print_debug(cx);\n             }\n \n-            let highlight = RegionHighlightMode::get();\n+            let highlight = cx.printer.region_highlight_mode();\n             if let Some(counter) = highlight.placeholder_highlight(*self) {\n                 p!(write(\"'{}\", counter));\n             } else {\n@@ -690,12 +555,14 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::PlaceholderRegion {\n-    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool\n+        where P: PrettyPrinter\n+    {\n         if cx.config.is_verbose {\n             return true;\n         }\n \n-        let highlight = RegionHighlightMode::get();\n+        let highlight = cx.printer.region_highlight_mode();\n         if highlight.placeholder_highlight(*self).is_some() {\n             return true;\n         }\n@@ -712,8 +579,8 @@ define_print! {\n             }\n \n             // Watch out for region highlights.\n-            if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n-                p!(write(\"'{:?}\", n));\n+            if let Some(n) = cx.printer.region_highlight_mode().region_highlighted(self) {\n+                p!(write(\"'{}\", n));\n                 return Ok(cx.printer);\n             }\n \n@@ -780,12 +647,12 @@ define_print! {\n                 }\n \n                 ty::ReLateBound(binder_id, ref bound_region) => {\n-                    p!(write(\"ReLateBound({:?}, {:?})\",\n-                           binder_id,\n-                           bound_region))\n+                    p!(write(\"ReLateBound({:?}, \", binder_id),\n+                       print_debug(bound_region),\n+                       write(\")\"))\n                 }\n \n-                ty::ReFree(ref fr) => p!(write(\"{:?}\", fr)),\n+                ty::ReFree(ref fr) => p!(print_debug(fr)),\n \n                 ty::ReScope(id) => {\n                     p!(write(\"ReScope({:?})\", id))\n@@ -794,11 +661,11 @@ define_print! {\n                 ty::ReStatic => p!(write(\"ReStatic\")),\n \n                 ty::ReVar(ref vid) => {\n-                    p!(write(\"{:?}\", vid))\n+                    p!(print_debug(vid))\n                 }\n \n                 ty::RePlaceholder(placeholder) => {\n-                    p!(write(\"RePlaceholder({:?})\", placeholder))\n+                    p!(write(\"RePlaceholder(\"), print_debug(placeholder), write(\")\"))\n                 }\n \n                 ty::ReEmpty => p!(write(\"ReEmpty\")),\n@@ -817,12 +684,14 @@ define_print! {\n // NB: this must be kept in sync with the printing logic above.\n impl ty::RegionKind {\n     // HACK(eddyb) `pub(crate)` only for `ty::print`.\n-    pub(crate) fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool {\n+    pub(crate) fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool\n+        where P: PrettyPrinter\n+    {\n         if cx.config.is_verbose {\n             return true;\n         }\n \n-        if RegionHighlightMode::get().region_highlighted(self).is_some() {\n+        if cx.printer.region_highlight_mode().region_highlighted(self).is_some() {\n             return true;\n         }\n \n@@ -926,17 +795,17 @@ define_print! {\n                 return self.print_debug(cx);\n             }\n \n-            let highlight = RegionHighlightMode::get();\n+            let highlight = cx.printer.region_highlight_mode();\n             if let Some(counter) = highlight.region_highlighted(&ty::ReVar(*self)) {\n-                p!(write(\"'{:?}\", counter));\n+                p!(write(\"'{}\", counter));\n             }\n         }\n         debug {\n             // HACK(eddyb) this is duplicated from `display` printing,\n             // to keep NLL borrowck working even with `-Zverbose`.\n-            let highlight = RegionHighlightMode::get();\n+            let highlight = cx.printer.region_highlight_mode();\n             if let Some(counter) = highlight.region_highlighted(&ty::ReVar(*self)) {\n-                p!(write(\"'{:?}\", counter));\n+                p!(write(\"'{}\", counter));\n             } else {\n                 p!(write(\"'_#{}r\", self.index()));\n             }\n@@ -948,12 +817,14 @@ define_print! {\n //\n // NB: this must be kept in sync with the printing logic above.\n impl ty::RegionVid {\n-    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool {\n+    fn display_outputs_anything<P>(&self, cx: &PrintCx<'_, '_, '_, P>) -> bool\n+        where P: PrettyPrinter\n+    {\n         if cx.config.is_verbose {\n             return true;\n         }\n \n-        let highlight = RegionHighlightMode::get();\n+        let highlight = cx.printer.region_highlight_mode();\n         if highlight.region_highlighted(&ty::ReVar(*self)).is_some() {\n             return true;\n         }\n@@ -1165,9 +1036,9 @@ define_print! {\n                         // FIXME(eddyb) print this with `print_def_path`.\n                         if let Some(first) = substs.next() {\n                             p!(write(\"::<\"));\n-                            p!(write(\"{}\", first));\n+                            p!(print_display(first));\n                             for subst in substs {\n-                                p!(write(\", {}\", subst));\n+                                p!(write(\", \"), print_display(subst));\n                             }\n                             p!(write(\">\"));\n                         }"}, {"sha": "9a80415827e89ff040fa9c060117d9b986596c58", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=cafd83d1d5f81ac1ed74bf97a950120505009a23", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::{\n     TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n-use rustc::util::ppaux::RegionHighlightMode;\n+use rustc::ty::print::Print;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n@@ -831,7 +831,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         if let Some(annotation) = self.annotate_argument_and_return_for_borrow(borrow) {\n-            let region_name = annotation.emit(&mut err);\n+            let region_name = annotation.emit(self, &mut err);\n \n             err.span_label(\n                 borrow_span,\n@@ -1875,7 +1875,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn annotate_argument_and_return_for_borrow(\n         &self,\n         borrow: &BorrowData<'tcx>,\n-    ) -> Option<AnnotatedBorrowFnSignature<'_>> {\n+    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         // Define a fallback for when we can't match a closure.\n         let fallback = || {\n             let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n@@ -2099,7 +2099,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         did: DefId,\n         sig: ty::PolyFnSig<'tcx>,\n-    ) -> Option<AnnotatedBorrowFnSignature<'_>> {\n+    ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n         let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did)?;\n@@ -2245,29 +2245,33 @@ enum AnnotatedBorrowFnSignature<'tcx> {\n impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     /// Annotate the provided diagnostic with information about borrow from the fn signature that\n     /// helps explain.\n-    fn emit(&self, diag: &mut DiagnosticBuilder<'_>) -> String {\n+    fn emit(\n+        &self,\n+        cx: &mut MirBorrowckCtxt<'_, '_, 'tcx>,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> String {\n         match self {\n             AnnotatedBorrowFnSignature::Closure {\n                 argument_ty,\n                 argument_span,\n             } => {\n                 diag.span_label(\n                     *argument_span,\n-                    format!(\"has type `{}`\", self.get_name_for_ty(argument_ty, 0)),\n+                    format!(\"has type `{}`\", cx.get_name_for_ty(argument_ty, 0)),\n                 );\n \n-                self.get_region_name_for_ty(argument_ty, 0)\n+                cx.get_region_name_for_ty(argument_ty, 0)\n             }\n             AnnotatedBorrowFnSignature::AnonymousFunction {\n                 argument_ty,\n                 argument_span,\n                 return_ty,\n                 return_span,\n             } => {\n-                let argument_ty_name = self.get_name_for_ty(argument_ty, 0);\n+                let argument_ty_name = cx.get_name_for_ty(argument_ty, 0);\n                 diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n \n-                let return_ty_name = self.get_name_for_ty(return_ty, 0);\n+                let return_ty_name = cx.get_name_for_ty(return_ty, 0);\n                 let types_equal = return_ty_name == argument_ty_name;\n                 diag.span_label(\n                     *return_span,\n@@ -2286,15 +2290,15 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                      lifetime-syntax.html#lifetime-elision>\",\n                 );\n \n-                self.get_region_name_for_ty(return_ty, 0)\n+                cx.get_region_name_for_ty(return_ty, 0)\n             }\n             AnnotatedBorrowFnSignature::NamedFunction {\n                 arguments,\n                 return_ty,\n                 return_span,\n             } => {\n                 // Region of return type and arguments checked to be the same earlier.\n-                let region_name = self.get_region_name_for_ty(return_ty, 0);\n+                let region_name = cx.get_region_name_for_ty(return_ty, 0);\n                 for (_, argument_span) in arguments {\n                     diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n                 }\n@@ -2314,10 +2318,15 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n             }\n         }\n     }\n+}\n \n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Return the name of the provided `Ty` (that must be a reference) with a synthesized lifetime\n     /// name where required.\n     fn get_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(&mut s);\n+\n         // We need to add synthesized lifetimes where appropriate. We do\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n@@ -2327,28 +2336,41 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n-            ) => RegionHighlightMode::highlighting_bound_region(*br, counter, || ty.to_string()),\n-            _ => ty.to_string(),\n+            ) => printer.region_highlight_mode.highlighting_bound_region(*br, counter),\n+            _ => {}\n         }\n+\n+        let _ = ty::print::PrintCx::with(self.infcx.tcx, printer, |cx| {\n+            ty.print(cx)\n+        });\n+        s\n     }\n \n     /// Returns the name of the provided `Ty` (that must be a reference)'s region with a\n     /// synthesized lifetime name where required.\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n-        match ty.sty {\n-            ty::TyKind::Ref(region, _, _) => match region {\n-                ty::RegionKind::ReLateBound(_, br)\n-                | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n-                    RegionHighlightMode::highlighting_bound_region(\n-                        *br,\n-                        counter,\n-                        || region.to_string(),\n-                    )\n+        let mut s = String::new();\n+        let mut printer = ty::print::FmtPrinter::new(&mut s);\n+\n+        let region = match ty.sty {\n+            ty::TyKind::Ref(region, _, _) => {\n+                match region {\n+                    ty::RegionKind::ReLateBound(_, br)\n+                    | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n+                        printer.region_highlight_mode.highlighting_bound_region(*br, counter)\n+                    }\n+                    _ => {}\n                 }\n-                _ => region.to_string(),\n-            },\n+\n+                region\n+            }\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n-        }\n+        };\n+\n+        let _ = ty::print::PrintCx::with(self.infcx.tcx, printer, |cx| {\n+            region.print(cx)\n+        });\n+        s\n     }\n }\n "}, {"sha": "362214d3257123d5b54de71737686a0f60fd5160", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cafd83d1d5f81ac1ed74bf97a950120505009a23/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=cafd83d1d5f81ac1ed74bf97a950120505009a23", "patch": "@@ -8,7 +8,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::Mir;\n use rustc::ty::subst::{SubstsRef, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n-use rustc::util::ppaux::RegionHighlightMode;\n+use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::Name;\n use syntax::symbol::keywords;\n@@ -396,9 +396,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let type_name = RegionHighlightMode::highlighting_region_vid(needle_fr, *counter, || {\n-            infcx.extract_type_name(&argument_ty)\n-        });\n+        let mut highlight = RegionHighlightMode::default();\n+        highlight.highlighting_region_vid(needle_fr, *counter);\n+        let type_name = infcx.extract_type_name(&argument_ty, Some(highlight));\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n@@ -680,9 +680,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n-        let type_name = RegionHighlightMode::highlighting_region_vid(\n-            fr, *counter, || infcx.extract_type_name(&return_ty),\n-        );\n+        let mut highlight = RegionHighlightMode::default();\n+        highlight.highlighting_region_vid(fr, *counter);\n+        let type_name = infcx.extract_type_name(&return_ty, Some(highlight));\n \n         let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n "}]}