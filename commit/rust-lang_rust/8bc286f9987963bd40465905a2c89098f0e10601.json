{"sha": "8bc286f9987963bd40465905a2c89098f0e10601", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYzI4NmY5OTg3OTYzYmQ0MDQ2NTkwNWEyYzg5MDk4ZjBlMTA2MDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-30T21:16:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-30T21:16:32Z"}, "message": "auto merge of #15238 : aochagavia/rust/json, r=alexcrichton\n\n### Breaking changes:\r\n\r\n* **Removed unnecessary `box` from enum variant (`Object(Box<Object>)` becomes `Object(Object)`)**\r\n* **Deprecated `Encoder::str_encode`**\r\n\r\n### Other changes:\r\n\r\n* Tried to make the code more idiomatic\r\n* Renamed the `wr` field of the `Encoder` and `PrettyEncoder` structs to `writer`\r\n* Replaced some `from_utf8` by `from_utf8_owned` to avoid unnecessary allocations\r\n* Removed unnecessary `unsafe` code\r\n* Added `encode` and `decode` shortcut functions\r\n* Implemented `FromStr` for `Json`\r\n* Implemented `ToJson` for tuples of arity up to 12\r\n* Fixed some details in the documentation\r\n\r\n### Questions\r\n\r\n* ~~The `encode` shortcut function does the same as the `Encoder::str_encode` function. It seems wrong to me that two functions do exactly the same. Should we deprecate `Encoder::str_encode`?~~\r\n* ~~Do we really want the ToJson trait for tuples? At the moment we have it for (), (A, B), (A, B, C). I would like to remove them.~~\r\n* ~~We are using `String` as key in the `TreeMap` representing a `Json` object. It would be better to use `&str`, but this would require to annotate lots of lifetimes. Is there any easy solution for this?~~\r\n* There is a lot of duplicated code (`PrettyEncoder` copies about 50 lines from `Encoder`). In an OO language this could be solved very elegantly by using inheritance and overriding. What can we do here to reduce the amount of boilerplate?\r\n\r\n[breaking-change]", "tree": {"sha": "fd1fa577f243e6ce65ac4fb96a6af872636c45ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd1fa577f243e6ce65ac4fb96a6af872636c45ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bc286f9987963bd40465905a2c89098f0e10601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc286f9987963bd40465905a2c89098f0e10601", "html_url": "https://github.com/rust-lang/rust/commit/8bc286f9987963bd40465905a2c89098f0e10601", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bc286f9987963bd40465905a2c89098f0e10601/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a345c543344b8ff4f3aeecb816856101443bf907", "url": "https://api.github.com/repos/rust-lang/rust/commits/a345c543344b8ff4f3aeecb816856101443bf907", "html_url": "https://github.com/rust-lang/rust/commit/a345c543344b8ff4f3aeecb816856101443bf907"}, {"sha": "c3cf3b3fb10754f92c0703062c39726b52726298", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3cf3b3fb10754f92c0703062c39726b52726298", "html_url": "https://github.com/rust-lang/rust/commit/c3cf3b3fb10754f92c0703062c39726b52726298"}], "stats": {"total": 808, "additions": 325, "deletions": 483}, "files": [{"sha": "86b80ee24943691a4abf49bab1ad1e7f0e9508c9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8bc286f9987963bd40465905a2c89098f0e10601/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc286f9987963bd40465905a2c89098f0e10601/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8bc286f9987963bd40465905a2c89098f0e10601", "patch": "@@ -408,18 +408,17 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     //   \"crate\": { parsed crate ... },\n     //   \"plugins\": { output of plugins ... }\n     // }\n-    let mut json = box std::collections::TreeMap::new();\n-    json.insert(\"schema\".to_string(),\n-                json::String(SCHEMA_VERSION.to_string()));\n-    let plugins_json = box res.move_iter()\n-                              .filter_map(|opt| {\n-                                  match opt {\n-                                      None => None,\n-                                      Some((string, json)) => {\n-                                          Some((string.to_string(), json))\n-                                      }\n+    let mut json = std::collections::TreeMap::new();\n+    json.insert(\"schema\".to_string(), json::String(SCHEMA_VERSION.to_string()));\n+    let plugins_json = res.move_iter()\n+                          .filter_map(|opt| {\n+                              match opt {\n+                                  None => None,\n+                                  Some((string, json)) => {\n+                                      Some((string.to_string(), json))\n                                   }\n-                              }).collect();\n+                              }\n+                          }).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n@@ -429,7 +428,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        str::from_utf8(w.unwrap().as_slice()).unwrap().to_string()\n+        str::from_utf8_owned(w.unwrap()).unwrap()\n     };\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n@@ -440,6 +439,5 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     json.insert(\"plugins\".to_string(), json::Object(plugins_json));\n \n     let mut file = try!(File::create(&dst));\n-    try!(json::Object(json).to_writer(&mut file));\n-    Ok(())\n+    json::Object(json).to_writer(&mut file)\n }"}, {"sha": "832bc9c4e10cbb2c8f6085a2303aaaa92900e8d2", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 309, "deletions": 465, "changes": 774, "blob_url": "https://github.com/rust-lang/rust/blob/8bc286f9987963bd40465905a2c89098f0e10601/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc286f9987963bd40465905a2c89098f0e10601/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=8bc286f9987963bd40465905a2c89098f0e10601", "patch": "@@ -20,12 +20,19 @@ JSON parsing and serialization\n # What is JSON?\n \n JSON (JavaScript Object Notation) is a way to write data in Javascript.\n-Like XML it allows one to encode structured data in a text format that can be read by humans easily.\n-Its native compatibility with JavaScript and its simple syntax make it used widely.\n+Like XML, it allows to encode structured data in a text format that can be easily read by humans.\n+Its simple syntax and native compatibility with JavaScript have made it a widely used format.\n+\n+Data types that can be encoded are JavaScript types (see the `Json` enum for more details):\n+\n+* `Boolean`: equivalent to rust's `bool`\n+* `Number`: equivalent to rust's `f64`\n+* `String`: equivalent to rust's `String`\n+* `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n+array\n+* `Object`: equivalent to rust's `Treemap<String, json::Json>`\n+* `Null`\n \n-Json data are encoded in a form of \"key\":\"value\".\n-Data types that can be encoded are JavaScript types :\n-boolean (`true` or `false`), number (`f64`), string, array, object, null.\n An object is a series of string keys mapping to values, in `\"key\": value` format.\n Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n A simple JSON document encoding a person, his/her age, address and phone numbers could look like:\n@@ -49,105 +56,20 @@ A simple JSON document encoding a person, his/her age, address and phone numbers\n \n # Rust Type-based Encoding and Decoding\n \n-Rust provides a mechanism for low boilerplate encoding & decoding\n-of values to and from JSON via the serialization API.\n+Rust provides a mechanism for low boilerplate encoding & decoding of values to and from JSON via\n+the serialization API.\n To be able to encode a piece of data, it must implement the `serialize::Encodable` trait.\n To be able to decode a piece of data, it must implement the `serialize::Decodable` trait.\n-The Rust compiler provides an annotation to automatically generate\n-the code for these traits: `#[deriving(Decodable, Encodable)]`\n-\n-To encode using Encodable :\n-\n-```rust\n-use std::io;\n-use serialize::{json, Encodable};\n+The Rust compiler provides an annotation to automatically generate the code for these traits:\n+`#[deriving(Decodable, Encodable)]`\n \n- #[deriving(Encodable)]\n- pub struct TestStruct   {\n-    data_str: String,\n- }\n-\n-fn main() {\n-    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_string()};\n-    let mut m = io::MemWriter::new();\n-    {\n-        let mut encoder = json::Encoder::new(&mut m as &mut Writer);\n-        match to_encode_object.encode(&mut encoder) {\n-            Ok(()) => (),\n-            Err(e) => fail!(\"json encoding error: {}\", e)\n-        };\n-    }\n-}\n-```\n-\n-Two wrapper functions are provided to encode a Encodable object\n-into a string (String) or buffer (vec![u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n-\n-```rust\n-use serialize::json;\n-let to_encode_object = \"example of string to encode\".to_string();\n-let encoded_str: String = json::Encoder::str_encode(&to_encode_object);\n-```\n-\n-JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n-The trait `ToJson` encode object into a container `json::Json` and the API provide writer\n-to encode them into a stream or a string ...\n+The JSON API provides an enum `json::Json` and a trait `ToJson` to encode objects.\n+The `ToJson` trait provides a `to_json` method to convert an object into a `json::Json` value.\n+A `json::Json` value can be encoded as a string or buffer using the functions described above.\n+You can also use the `json::Encoder` object, which implements the `Encoder` trait.\n \n When using `ToJson` the `Encodable` trait implementation is not mandatory.\n \n-A basic `ToJson` example using a TreeMap of attribute name / attribute value:\n-\n-\n-```rust\n-use std::collections::TreeMap;\n-use serialize::json;\n-use serialize::json::ToJson;\n-\n-pub struct MyStruct  {\n-    attr1: u8,\n-    attr2: String,\n-}\n-\n-impl ToJson for MyStruct {\n-    fn to_json( &self ) -> json::Json {\n-        let mut d = box TreeMap::new();\n-        d.insert(\"attr1\".to_string(), self.attr1.to_json());\n-        d.insert(\"attr2\".to_string(), self.attr2.to_json());\n-        json::Object(d)\n-    }\n-}\n-\n-fn main() {\n-    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_string()};\n-    let tjson: json::Json = test2.to_json();\n-    let json_str: String = tjson.to_str().into_string();\n-}\n-```\n-\n-To decode a JSON string using `Decodable` trait :\n-\n-```rust\n-extern crate serialize;\n-use serialize::{json, Decodable};\n-\n-#[deriving(Decodable)]\n-pub struct MyStruct  {\n-     attr1: u8,\n-     attr2: String,\n-}\n-\n-fn main() {\n-    let json_str_to_decode: String =\n-            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_string();\n-    let json_object = json::from_str(json_str_to_decode.as_slice());\n-    let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let decoded_object: MyStruct = match Decodable::decode(&mut decoder) {\n-        Ok(v) => v,\n-        Err(e) => fail!(\"Decoding error: {}\", e)\n-    }; // create the final object\n-}\n-```\n-\n # Examples of use\n \n ## Using Autoserialization\n@@ -157,41 +79,37 @@ using the serialization API, using the derived serialization code.\n \n ```rust\n extern crate serialize;\n-use serialize::{json, Encodable, Decodable};\n+use serialize::json;\n \n- #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n- pub struct TestStruct1  {\n+#[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n+pub struct TestStruct1  {\n     data_int: u8,\n     data_str: String,\n     data_vector: Vec<u8>,\n- }\n+}\n \n-// To serialize use the `json::str_encode` to encode an object in a string.\n-// It calls the generated `Encodable` impl.\n fn main() {\n-    let to_encode_object = TestStruct1\n+    let object = TestStruct1\n          {data_int: 1, data_str:\"toto\".to_string(), data_vector:vec![2,3,4,5]};\n-    let encoded_str: String = json::Encoder::str_encode(&to_encode_object);\n \n-    // To deserialize use the `json::from_str` and `json::Decoder`\n+    // Serialize using `json::encode`\n+    let encoded = json::encode(&object);\n \n-    let json_object = json::from_str(encoded_str.as_slice());\n-    let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let decoded1: TestStruct1 = Decodable::decode(&mut decoder).unwrap(); // create the final object\n+    // Deserialize using `json::decode`\n+    let decoded: TestStruct1 = json::decode(encoded.as_slice()).unwrap();\n }\n ```\n \n ## Using `ToJson`\n \n-This example uses the ToJson impl to deserialize the JSON string.\n-Example of `ToJson` trait implementation for TestStruct1.\n+This example uses the `ToJson` trait to generate the JSON string.\n \n ```rust\n use std::collections::TreeMap;\n use serialize::json::ToJson;\n-use serialize::{json, Encodable, Decodable};\n+use serialize::json;\n \n-#[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n+#[deriving(Decodable)]\n pub struct TestStruct1  {\n     data_int: u8,\n     data_str: String,\n@@ -200,7 +118,7 @@ pub struct TestStruct1  {\n \n impl ToJson for TestStruct1 {\n     fn to_json( &self ) -> json::Json {\n-        let mut d = box TreeMap::new();\n+        let mut d = TreeMap::new();\n         d.insert(\"data_int\".to_string(), self.data_int.to_json());\n         d.insert(\"data_str\".to_string(), self.data_str.to_json());\n         d.insert(\"data_vector\".to_string(), self.data_vector.to_json());\n@@ -209,35 +127,25 @@ impl ToJson for TestStruct1 {\n }\n \n fn main() {\n-    // Serialization using our impl of to_json\n-\n-    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_string(),\n-                                          data_vector:vec![2,3,4,5]};\n+    // Serialize using `ToJson`\n+    let test2 = TestStruct1 {data_int: 1, data_str:\"toto\".to_string(), data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: String = tjson.to_str().into_string();\n+    let json_str: String = tjson.to_str();\n \n-    // Deserialize like before.\n-\n-    let mut decoder =\n-        json::Decoder::new(json::from_str(json_str.as_slice()).unwrap());\n-    // create the final object\n-    let decoded2: TestStruct1 = Decodable::decode(&mut decoder).unwrap();\n+    // Deserialize like before\n+    let decoded: TestStruct1 = json::decode(json_str.as_slice()).unwrap();\n }\n ```\n \n */\n \n-use std::char;\n+use std;\n use std::collections::{HashMap, TreeMap};\n-use std::f64;\n-use std::fmt;\n+use std::{char, f64, fmt, io, num, str};\n use std::io::MemWriter;\n-use std::io;\n-use std::mem::{swap,transmute};\n+use std::mem::{swap, transmute};\n use std::num::{FPNaN, FPInfinite};\n-use std::num;\n use std::str::ScalarValue;\n-use std::str;\n use std::string::String;\n use std::vec::Vec;\n \n@@ -250,7 +158,7 @@ pub enum Json {\n     String(String),\n     Boolean(bool),\n     List(List),\n-    Object(Box<Object>),\n+    Object(Object),\n     Null,\n }\n \n@@ -318,13 +226,29 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n     }\n }\n \n+/// Shortcut function to decode a JSON `&str` into an object\n+pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T> {\n+    let json = match from_str(s) {\n+        Ok(x) => x,\n+        Err(e) => return Err(ParseError(e))\n+    };\n+\n+    let mut decoder = Decoder::new(json);\n+    ::Decodable::decode(&mut decoder)\n+}\n+\n+/// Shortcut function to encode a `T` into a JSON `String`\n+pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n+    let buff = Encoder::buffer_encode(object);\n+    str::from_utf8_owned(buff).unwrap()\n+}\n+\n impl fmt::Show for ErrorCode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         error_str(*self).fmt(f)\n     }\n }\n \n-\n fn io_error_to_error(io: io::IoError) -> ParserError {\n     IoError(io.kind, io.desc)\n }\n@@ -363,41 +287,40 @@ fn spaces(n: uint) -> String {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n-    wr: &'a mut io::Writer,\n+    writer: &'a mut io::Writer,\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n-    pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n-        Encoder { wr: wr }\n+    pub fn new(writer: &'a mut io::Writer) -> Encoder<'a> {\n+        Encoder { writer: writer }\n     }\n \n     /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> Vec<u8>  {\n-       //Serialize the object in a string using a writer\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(object: &T) -> Vec<u8>  {\n+        //Serialize the object in a string using a writer\n         let mut m = MemWriter::new();\n         // FIXME(14302) remove the transmute and unsafe block.\n         unsafe {\n             let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n             // MemWriter never Errs\n-            let _ = to_encode_object.encode(transmute(&mut encoder));\n+            let _ = object.encode(transmute(&mut encoder));\n         }\n         m.unwrap()\n     }\n \n     /// Encode the specified struct into a json str\n-    pub fn str_encode<T:Encodable<Encoder<'a>,\n-                        io::IoError>>(\n-                      to_encode_object: &T)\n-                      -> String {\n-        let buff = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8(buff.as_slice()).unwrap().to_string()\n+    ///\n+    /// Note: this function is deprecated. Consider using `json::encode` instead.\n+    #[deprecated = \"Replaced by `json::encode`\"]\n+    pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n+        encode(object)\n     }\n }\n \n impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n-    fn emit_nil(&mut self) -> EncodeResult { write!(self.wr, \"null\") }\n+    fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n@@ -413,27 +336,27 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n-            write!(self.wr, \"true\")\n+            write!(self.writer, \"true\")\n         } else {\n-            write!(self.wr, \"false\")\n+            write!(self.writer, \"false\")\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.wr, \"{}\", fmt_number_or_null(v))\n+        write!(self.writer, \"{}\", fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n \n     fn emit_char(&mut self, v: char) -> EncodeResult {\n         self.emit_str(str::from_char(v).as_slice())\n     }\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        write!(self.wr, \"{}\", escape_str(v))\n+        write!(self.writer, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self,\n-                 _name: &str,\n-                 f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult { f(self) }\n+    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+        f(self)\n+    }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n@@ -444,21 +367,21 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            write!(self.wr, \"{}\", escape_str(name))\n+            write!(self.writer, \"{}\", escape_str(name))\n         } else {\n-            try!(write!(self.wr, \"{{\\\"variant\\\":\"));\n-            try!(write!(self.wr, \"{}\", escape_str(name)));\n-            try!(write!(self.wr, \",\\\"fields\\\":[\"));\n+            try!(write!(self.writer, \"{{\\\"variant\\\":\"));\n+            try!(write!(self.writer, \"{}\", escape_str(name)));\n+            try!(write!(self.writer, \",\\\"fields\\\":[\"));\n             try!(f(self));\n-            write!(self.wr, \"]}}\")\n+            write!(self.writer, \"]}}\")\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n-            try!(write!(self.wr, \",\"));\n+            try!(write!(self.writer, \",\"));\n         }\n         f(self)\n     }\n@@ -482,17 +405,17 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n                    _: &str,\n                    _: uint,\n                    f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \"{{\"));\n+        try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n-        write!(self.wr, \"}}\")\n+        write!(self.writer, \"}}\")\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n                          f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        if idx != 0 { try!(write!(self.wr, \",\")); }\n-        try!(write!(self.wr, \"{}:\", escape_str(name)));\n+        if idx != 0 { try!(write!(self.writer, \",\")); }\n+        try!(write!(self.writer, \"{}:\", escape_str(name)));\n         f(self)\n     }\n \n@@ -526,29 +449,28 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n     }\n \n     fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \"[\"));\n+        try!(write!(self.writer, \"[\"));\n         try!(f(self));\n-        write!(self.wr, \"]\")\n+        write!(self.writer, \"]\")\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n-            try!(write!(self.wr, \",\"));\n+            try!(write!(self.writer, \",\"));\n         }\n         f(self)\n     }\n \n     fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \"{{\"));\n+        try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n-        write!(self.wr, \"}}\")\n+        write!(self.writer, \"}}\")\n     }\n \n     fn emit_map_elt_key(&mut self,\n                         idx: uint,\n                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        use std::str::from_utf8;\n-        if idx != 0 { try!(write!(self.wr, \",\")) }\n+        if idx != 0 { try!(write!(self.writer, \",\")) }\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n@@ -557,43 +479,39 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n             let mut check_encoder = Encoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let buf = buf.unwrap();\n-        let out = from_utf8(buf.as_slice()).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' &&\n-            out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        let out = str::from_utf8_owned(buf.unwrap()).unwrap();\n+        let out = out.as_slice();\n+        let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         Ok(())\n     }\n \n     fn emit_map_elt_val(&mut self,\n                         _idx: uint,\n                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \":\"));\n+        try!(write!(self.writer, \":\"));\n         f(self)\n     }\n }\n \n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder<'a> {\n-    wr: &'a mut io::Writer,\n+    writer: &'a mut io::Writer,\n     indent: uint,\n }\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n-        PrettyEncoder {\n-            wr: wr,\n-            indent: 0,\n-        }\n+    pub fn new<'a>(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+        PrettyEncoder { writer: writer, indent: 0 }\n     }\n }\n \n impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n-    fn emit_nil(&mut self) -> EncodeResult { write!(self.wr, \"null\") }\n+    fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n@@ -609,14 +527,14 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n-            write!(self.wr, \"true\")\n+            write!(self.writer, \"true\")\n         } else {\n-            write!(self.wr, \"false\")\n+            write!(self.writer, \"false\")\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        write!(self.wr, \"{}\", fmt_number_or_null(v))\n+        write!(self.writer, \"{}\", fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n         self.emit_f64(v as f64)\n@@ -626,7 +544,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         self.emit_str(str::from_char(v).as_slice())\n     }\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        write!(self.wr, \"{}\", escape_str(v))\n+        write!(self.writer, \"{}\", escape_str(v))\n     }\n \n     fn emit_enum(&mut self,\n@@ -641,24 +559,24 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                          cnt: uint,\n                          f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if cnt == 0 {\n-            write!(self.wr, \"{}\", escape_str(name))\n+            write!(self.writer, \"{}\", escape_str(name))\n         } else {\n             self.indent += 2;\n-            try!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n+            try!(write!(self.writer, \"[\\n{}{},\\n\", spaces(self.indent),\n                           escape_str(name)));\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}]\", spaces(self.indent))\n+            write!(self.writer, \"\\n{}]\", spaces(self.indent))\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n-            try!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n@@ -683,13 +601,13 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                    len: uint,\n                    f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            write!(self.wr, \"{{}}\")\n+            write!(self.writer, \"{{}}\")\n         } else {\n-            try!(write!(self.wr, \"{{\"));\n+            try!(write!(self.writer, \"{{\"));\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}}}\", spaces(self.indent))\n+            write!(self.writer, \"\\n{}}}\", spaces(self.indent))\n         }\n     }\n \n@@ -698,11 +616,11 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                          idx: uint,\n                          f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.writer, \"\\n\"));\n         } else {\n-            try!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n+        try!(write!(self.writer, \"{}{}: \", spaces(self.indent), escape_str(name)));\n         f(self)\n     }\n \n@@ -741,52 +659,51 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                 len: uint,\n                 f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            write!(self.wr, \"[]\")\n+            write!(self.writer, \"[]\")\n         } else {\n-            try!(write!(self.wr, \"[\"));\n+            try!(write!(self.writer, \"[\"));\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}]\", spaces(self.indent))\n+            write!(self.writer, \"\\n{}]\", spaces(self.indent))\n         }\n     }\n \n     fn emit_seq_elt(&mut self,\n                     idx: uint,\n                     f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.writer, \"\\n\"));\n         } else {\n-            try!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n     fn emit_map(&mut self,\n                 len: uint,\n                 f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            write!(self.wr, \"{{}}\")\n+            write!(self.writer, \"{{}}\")\n         } else {\n-            try!(write!(self.wr, \"{{\"));\n+            try!(write!(self.writer, \"{{\"));\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}}}\", spaces(self.indent))\n+            write!(self.writer, \"\\n{}}}\", spaces(self.indent))\n         }\n     }\n \n     fn emit_map_elt_key(&mut self,\n                         idx: uint,\n                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n-        use std::str::from_utf8;\n         if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n+            try!(write!(self.writer, \"\\n\"));\n         } else {\n-            try!(write!(self.wr, \",\\n\"));\n+            try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n@@ -795,20 +712,19 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             let mut check_encoder = PrettyEncoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let buf = buf.unwrap();\n-        let out = from_utf8(buf.as_slice()).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' &&\n-            out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        let out = str::from_utf8_owned(buf.unwrap()).unwrap();\n+        let out = out.as_slice();\n+        let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         Ok(())\n     }\n \n     fn emit_map_elt_val(&mut self,\n                         _idx: uint,\n                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n-        try!(write!(self.wr, \": \"));\n+        try!(write!(self.writer, \": \"));\n         f(self)\n     }\n }\n@@ -827,24 +743,24 @@ impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n }\n \n impl Json {\n-    /// Encodes a json value into an io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: &mut io::Writer) -> EncodeResult {\n-        let mut encoder = Encoder::new(wr);\n+    /// Encodes a json value into an io::writer. Uses a single line.\n+    pub fn to_writer(&self, writer: &mut io::Writer) -> EncodeResult {\n+        let mut encoder = Encoder::new(writer);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into an io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: &mut io::Writer) -> EncodeResult {\n-        let mut encoder = PrettyEncoder::new(wr);\n+    pub fn to_pretty_writer(&self, writer: &mut io::Writer) -> EncodeResult {\n+        let mut encoder = PrettyEncoder::new(writer);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> String {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8(s.unwrap().as_slice()).unwrap().to_string()\n+        str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -903,7 +819,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n         match self {\n-            &Object(ref map) => Some(&**map),\n+            &Object(ref map) => Some(map),\n             _ => None\n         }\n     }\n@@ -1038,27 +954,25 @@ enum InternalStackElement {\n \n impl Stack {\n     pub fn new() -> Stack {\n-        Stack {\n-            stack: Vec::new(),\n-            str_buffer: Vec::new(),\n-        }\n+        Stack { stack: Vec::new(), str_buffer: Vec::new() }\n     }\n \n     /// Returns The number of elements in the Stack.\n     pub fn len(&self) -> uint { self.stack.len() }\n \n-    /// Returns true if the stack is empty, equivalent to self.len() == 0.\n-    pub fn is_empty(&self) -> bool { self.stack.len() == 0 }\n+    /// Returns true if the stack is empty.\n+    pub fn is_empty(&self) -> bool { self.stack.is_empty() }\n \n     /// Provides access to the StackElement at a given index.\n     /// lower indices are at the bottom of the stack while higher indices are\n     /// at the top.\n     pub fn get<'l>(&'l self, idx: uint) -> StackElement<'l> {\n-        return match *self.stack.get(idx) {\n-          InternalIndex(i) => { Index(i) }\n-          InternalKey(start, size) => {\n-            Key(str::from_utf8(self.str_buffer.slice(start as uint, (start+size) as uint)).unwrap())\n-          }\n+        match *self.stack.get(idx) {\n+            InternalIndex(i) => { Index(i) }\n+            InternalKey(start, size) => {\n+                Key(str::from_utf8(\n+                    self.str_buffer.slice(start as uint, start as uint + size as uint)).unwrap())\n+            }\n         }\n     }\n \n@@ -1124,9 +1038,7 @@ impl Stack {\n         match *self.stack.last().unwrap() {\n             InternalKey(_, sz) => {\n                 let new_size = self.str_buffer.len() - sz as uint;\n-                unsafe {\n-                    self.str_buffer.set_len(new_size);\n-                }\n+                self.str_buffer.truncate(new_size);\n             }\n             InternalIndex(_) => {}\n         }\n@@ -1146,8 +1058,8 @@ impl Stack {\n     fn bump_index(&mut self) {\n         let len = self.stack.len();\n         let idx = match *self.stack.last().unwrap() {\n-          InternalIndex(i) => { i + 1 }\n-          _ => { fail!(); }\n+            InternalIndex(i) => { i + 1 }\n+            _ => { fail!(); }\n         };\n         *self.stack.get_mut(len - 1) = InternalIndex(idx);\n     }\n@@ -1249,23 +1161,14 @@ impl<T: Iterator<char>> Parser<T> {\n             neg = -1.0;\n         }\n \n-        let mut res = match self.parse_integer() {\n-          Ok(res) => res,\n-          Err(e) => return Err(e)\n-        };\n+        let mut res = try!(self.parse_integer());\n \n         if self.ch_is('.') {\n-            match self.parse_decimal(res) {\n-              Ok(r) => res = r,\n-              Err(e) => return Err(e)\n-            }\n+            res = try!(self.parse_decimal(res));\n         }\n \n         if self.ch_is('e') || self.ch_is('E') {\n-            match self.parse_exponent(res) {\n-              Ok(r) => res = r,\n-              Err(e) => return Err(e)\n-            }\n+            res = try!(self.parse_exponent(res));\n         }\n \n         Ok(neg * res)\n@@ -1301,7 +1204,7 @@ impl<T: Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn parse_decimal(&mut self, res: f64) -> Result<f64, ParserError> {\n+    fn parse_decimal(&mut self, mut res: f64) -> Result<f64, ParserError> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -1310,7 +1213,6 @@ impl<T: Iterator<char>> Parser<T> {\n              _ => return self.error(InvalidNumber)\n         }\n \n-        let mut res = res;\n         let mut dec = 1.0;\n         while !self.eof() {\n             match self.ch_or_null() {\n@@ -1356,7 +1258,7 @@ impl<T: Iterator<char>> Parser<T> {\n             }\n         }\n \n-        let exp: f64 = num::pow(10u as f64, exp);\n+        let exp = num::pow(10_f64, exp);\n         if neg_exp {\n             res /= exp;\n         } else {\n@@ -1369,24 +1271,24 @@ impl<T: Iterator<char>> Parser<T> {\n     fn decode_hex_escape(&mut self) -> Result<u16, ParserError> {\n         let mut i = 0u;\n         let mut n = 0u16;\n-        while i < 4u && !self.eof() {\n+        while i < 4 && !self.eof() {\n             self.bump();\n             n = match self.ch_or_null() {\n-                c @ '0' .. '9' => n * 16_u16 + ((c as u16) - ('0' as u16)),\n-                'a' | 'A' => n * 16_u16 + 10_u16,\n-                'b' | 'B' => n * 16_u16 + 11_u16,\n-                'c' | 'C' => n * 16_u16 + 12_u16,\n-                'd' | 'D' => n * 16_u16 + 13_u16,\n-                'e' | 'E' => n * 16_u16 + 14_u16,\n-                'f' | 'F' => n * 16_u16 + 15_u16,\n+                c @ '0' .. '9' => n * 16 + ((c as u16) - ('0' as u16)),\n+                'a' | 'A' => n * 16 + 10,\n+                'b' | 'B' => n * 16 + 11,\n+                'c' | 'C' => n * 16 + 12,\n+                'd' | 'D' => n * 16 + 13,\n+                'e' | 'E' => n * 16 + 14,\n+                'f' | 'F' => n * 16 + 15,\n                 _ => return self.error(InvalidEscape)\n             };\n \n             i += 1u;\n         }\n \n         // Error out if we didn't parse 4 digits.\n-        if i != 4u {\n+        if i != 4 {\n             return self.error(InvalidEscape);\n         }\n \n@@ -1419,9 +1321,7 @@ impl<T: Iterator<char>> Parser<T> {\n                         // Non-BMP characters are encoded as a sequence of\n                         // two hex escapes, representing UTF-16 surrogates.\n                         n1 @ 0xD800 .. 0xDBFF => {\n-                            let c1 = self.next_char();\n-                            let c2 = self.next_char();\n-                            match (c1, c2) {\n+                            match (self.next_char(), self.next_char()) {\n                                 (Some('\\\\'), Some('u')) => (),\n                                 _ => return self.error(UnexpectedEndOfHexEscape),\n                             }\n@@ -1636,37 +1536,37 @@ impl<T: Iterator<char>> Parser<T> {\n                 }\n             }\n             self.bump();\n-            return ObjectEnd;\n+            ObjectEnd\n         } else if self.eof() {\n-            return self.error_event(EOFWhileParsingObject);\n+            self.error_event(EOFWhileParsingObject)\n         } else {\n-            return self.error_event(InvalidSyntax);\n+            self.error_event(InvalidSyntax)\n         }\n     }\n \n     fn parse_value(&mut self) -> JsonEvent {\n         if self.eof() { return self.error_event(EOFWhileParsingValue); }\n         match self.ch_or_null() {\n-            'n' => { return self.parse_ident(\"ull\", NullValue); }\n-            't' => { return self.parse_ident(\"rue\", BooleanValue(true)); }\n-            'f' => { return self.parse_ident(\"alse\", BooleanValue(false)); }\n-            '0' .. '9' | '-' => return match self.parse_number() {\n+            'n' => { self.parse_ident(\"ull\", NullValue) }\n+            't' => { self.parse_ident(\"rue\", BooleanValue(true)) }\n+            'f' => { self.parse_ident(\"alse\", BooleanValue(false)) }\n+            '0' .. '9' | '-' => match self.parse_number() {\n                 Ok(f) => NumberValue(f),\n                 Err(e) => Error(e),\n             },\n-            '\"' => return match self.parse_str() {\n+            '\"' => match self.parse_str() {\n                 Ok(s) => StringValue(s),\n                 Err(e) => Error(e),\n             },\n             '[' => {\n                 self.bump();\n-                return ListStart;\n+                ListStart\n             }\n             '{' => {\n                 self.bump();\n-                return ObjectStart;\n+                ObjectStart\n             }\n-            _ => { return self.error_event(InvalidSyntax); }\n+            _ => { self.error_event(InvalidSyntax) }\n         }\n     }\n \n@@ -1694,10 +1594,7 @@ pub struct Builder<T> {\n impl<T: Iterator<char>> Builder<T> {\n     /// Create a JSON Builder.\n     pub fn new(src: T) -> Builder<T> {\n-        Builder {\n-            parser: Parser::new(src),\n-            token: None,\n-        }\n+        Builder { parser: Parser::new(src), token: None, }\n     }\n \n     // Decode a Json value from a Parser.\n@@ -1710,7 +1607,7 @@ impl<T: Iterator<char>> Builder<T> {\n             Some(Error(e)) => { return Err(e); }\n             ref tok => { fail!(\"unexpected token {}\", tok.clone()); }\n         }\n-        return result;\n+        result\n     }\n \n     fn bump(&mut self) {\n@@ -1755,9 +1652,9 @@ impl<T: Iterator<char>> Builder<T> {\n     fn build_object(&mut self) -> Result<Json, BuilderError> {\n         self.bump();\n \n-        let mut values = box TreeMap::new();\n+        let mut values = TreeMap::new();\n \n-        while self.token != None {\n+        loop {\n             match self.token {\n                 Some(ObjectEnd) => { return Ok(Object(values)); }\n                 Some(Error(e)) => { return Err(e); }\n@@ -1778,16 +1675,15 @@ impl<T: Iterator<char>> Builder<T> {\n     }\n }\n \n-\n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n     let contents = match rdr.read_to_end() {\n         Ok(c) => c,\n         Err(e) => return Err(io_error_to_error(e))\n     };\n-    let s = match str::from_utf8(contents.as_slice()) {\n-        Some(s) => s.to_string(),\n-        None => return Err(SyntaxError(NotUtf8, 0, 0))\n+    let s = match str::from_utf8_owned(contents) {\n+        Ok(s) => s,\n+        _ => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n     let mut builder = Builder::new(s.as_slice().chars());\n     builder.build()\n@@ -1796,7 +1692,7 @@ pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n /// Decodes a json value from a string\n pub fn from_str(s: &str) -> Result<Json, BuilderError> {\n     let mut builder = Builder::new(s.chars());\n-    return builder.build();\n+    builder.build()\n }\n \n /// A structure to decode JSON to values in rust.\n@@ -1807,9 +1703,7 @@ pub struct Decoder {\n impl Decoder {\n     /// Creates a new decoder instance for decoding the specified JSON value.\n     pub fn new(json: Json) -> Decoder {\n-        Decoder {\n-            stack: vec!(json),\n-        }\n+        Decoder { stack: vec![json] }\n     }\n }\n \n@@ -1841,8 +1735,7 @@ macro_rules! expect(\n impl ::Decoder<DecoderError> for Decoder {\n     fn read_nil(&mut self) -> DecodeResult<()> {\n         debug!(\"read_nil\");\n-        try!(expect!(self.pop(), Null));\n-        Ok(())\n+        expect!(self.pop(), Null)\n     }\n \n     fn read_u64(&mut self)  -> DecodeResult<u64 > { Ok(try!(self.read_f64()) as u64) }\n@@ -1859,28 +1752,24 @@ impl ::Decoder<DecoderError> for Decoder {\n \n     fn read_bool(&mut self) -> DecodeResult<bool> {\n         debug!(\"read_bool\");\n-        Ok(try!(expect!(self.pop(), Boolean)))\n+        expect!(self.pop(), Boolean)\n     }\n \n     fn read_f64(&mut self) -> DecodeResult<f64> {\n-        use std::from_str::FromStr;\n         debug!(\"read_f64\");\n         match self.pop() {\n             Number(f) => Ok(f),\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n-                // is going to have a string here, as per JSON spec..\n-                Ok(FromStr::from_str(s.as_slice()).unwrap())\n+                // is going to have a string here, as per JSON spec.\n+                Ok(std::from_str::from_str(s.as_slice()).unwrap())\n             },\n             Null => Ok(f64::NAN),\n-            value => {\n-                Err(ExpectedError(\"Number\".to_string(),\n-                                  format!(\"{}\", value)))\n-            }\n+            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n         }\n     }\n \n-    fn read_f32(&mut self) -> DecodeResult<f32> { Ok(try!(self.read_f64()) as f32) }\n+    fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n \n     fn read_char(&mut self) -> DecodeResult<char> {\n         let s = try!(self.read_str());\n@@ -1892,13 +1781,12 @@ impl ::Decoder<DecoderError> for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_string(),\n-                          format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n     }\n \n     fn read_str(&mut self) -> DecodeResult<String> {\n         debug!(\"read_str\");\n-        Ok(try!(expect!(self.pop(), String)))\n+        expect!(self.pop(), String)\n     }\n \n     fn read_enum<T>(&mut self,\n@@ -1919,8 +1807,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 let n = match o.pop(&\"variant\".to_string()) {\n                     Some(String(s)) => s,\n                     Some(val) => {\n-                        return Err(ExpectedError(\"String\".to_string(),\n-                                                 format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n                         return Err(MissingFieldError(\"variant\".to_string()))\n@@ -1929,12 +1816,11 @@ impl ::Decoder<DecoderError> for Decoder {\n                 match o.pop(&\"fields\".to_string()) {\n                     Some(List(l)) => {\n                         for field in l.move_iter().rev() {\n-                            self.stack.push(field.clone());\n+                            self.stack.push(field);\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"List\".to_string(),\n-                                                 format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"List\".to_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n                         return Err(MissingFieldError(\"fields\".to_string()))\n@@ -1943,14 +1829,11 @@ impl ::Decoder<DecoderError> for Decoder {\n                 n\n             }\n             json => {\n-                return Err(ExpectedError(\"String or Object\".to_string(),\n-                                         format!(\"{}\", json)))\n+                return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n         let idx = match names.iter()\n-                             .position(|n| {\n-                                 str::eq_slice(*n, name.as_slice())\n-                             }) {\n+                             .position(|n| str::eq_slice(*n, name.as_slice())) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -2093,48 +1976,18 @@ pub trait ToJson {\n     fn to_json(&self) -> Json;\n }\n \n-impl ToJson for Json {\n-    fn to_json(&self) -> Json { (*self).clone() }\n-}\n-\n-impl ToJson for int {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i8 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i16 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i32 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i64 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for uint {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for u8 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for u16 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n+macro_rules! to_json_impl(\n+    ($($t:ty), +) => (\n+        $(impl ToJson for $t {\n+            fn to_json(&self) -> Json { Number(*self as f64) }\n+        })+\n+    )\n+)\n \n-impl ToJson for u32 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n+to_json_impl!(int, i8, i16, i32, i64, uint, u8, u16, u32, u64)\n \n-impl ToJson for u64 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n+impl ToJson for Json {\n+    fn to_json(&self) -> Json { self.clone() }\n }\n \n impl ToJson for f32 {\n@@ -2145,7 +1998,7 @@ impl ToJson for f64 {\n     fn to_json(&self) -> Json {\n         match self.classify() {\n             FPNaN | FPInfinite => Null,\n-            _ => Number(*self)\n+            _                  => Number(*self)\n         }\n     }\n }\n@@ -2162,59 +2015,71 @@ impl ToJson for String {\n     fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n-impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n-    fn to_json(&self) -> Json {\n-        match *self {\n-          (ref a, ref b) => {\n-            List(vec![a.to_json(), b.to_json()])\n-          }\n-        }\n-    }\n-}\n+macro_rules! tuple_impl {\n+    // use variables to indicate the arity of the tuple\n+    ($($tyvar:ident),* ) => {\n+        // the trailing commas are for the 1 tuple\n+        impl<\n+            $( $tyvar : ToJson ),*\n+            > ToJson for ( $( $tyvar ),* , ) {\n \n-impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n-    fn to_json(&self) -> Json {\n-        match *self {\n-          (ref a, ref b, ref c) => {\n-            List(vec![a.to_json(), b.to_json(), c.to_json()])\n-          }\n+            #[inline]\n+            #[allow(uppercase_variables)]\n+            fn to_json(&self) -> Json {\n+                match *self {\n+                    ($(ref $tyvar),*,) => List(vec![$($tyvar.to_json()),*])\n+                }\n+            }\n         }\n     }\n }\n \n-impl<'a, A:ToJson> ToJson for &'a [A] {\n+tuple_impl!{A}\n+tuple_impl!{A, B}\n+tuple_impl!{A, B, C}\n+tuple_impl!{A, B, C, D}\n+tuple_impl!{A, B, C, D, E}\n+tuple_impl!{A, B, C, D, E, F}\n+tuple_impl!{A, B, C, D, E, F, G}\n+tuple_impl!{A, B, C, D, E, F, G, H}\n+tuple_impl!{A, B, C, D, E, F, G, H, I}\n+tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n+tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n+tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n+\n+impl<'a, A: ToJson> ToJson for &'a [A] {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A:ToJson> ToJson for Vec<A> {\n+impl<A: ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A:ToJson> ToJson for TreeMap<String, A> {\n+impl<A: ToJson> ToJson for TreeMap<String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n-        Object(box d)\n+        Object(d)\n     }\n }\n \n-impl<A:ToJson> ToJson for HashMap<String, A> {\n+impl<A: ToJson> ToJson for HashMap<String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n-        Object(box d)\n+        Object(d)\n     }\n }\n \n impl<A:ToJson> ToJson for Option<A> {\n     fn to_json(&self) -> Json {\n         match *self {\n-          None => Null,\n-          Some(ref value) => value.to_json()\n+            None => Null,\n+            Some(ref value) => value.to_json()\n         }\n     }\n }\n@@ -2226,6 +2091,12 @@ impl fmt::Show for Json {\n     }\n }\n \n+impl std::from_str::FromStr for Json {\n+    fn from_str(s: &str) -> Option<Json> {\n+        from_str(s).ok()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;\n@@ -2240,9 +2111,7 @@ mod tests {\n                 InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n                 EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n                 TrailingCharacters};\n-    use std::f32;\n-    use std::f64;\n-    use std::io;\n+    use std::{f32, f64, io};\n     use std::collections::TreeMap;\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n@@ -2264,7 +2133,7 @@ mod tests {\n     }\n \n     fn mk_object(items: &[(String, Json)]) -> Json {\n-        let mut d = box TreeMap::new();\n+        let mut d = TreeMap::new();\n \n         for item in items.iter() {\n             match *item {\n@@ -2275,6 +2144,12 @@ mod tests {\n         Object(d)\n     }\n \n+    #[test]\n+    fn test_from_str_trait() {\n+        let s = \"null\";\n+        assert!(::std::from_str::from_str::<Json>(s).unwrap() == from_str(s).unwrap());\n+    }\n+\n     #[test]\n     fn test_write_null() {\n         assert_eq!(Null.to_str().into_string(), \"null\".to_string());\n@@ -2437,31 +2312,31 @@ mod tests {\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = Encoder::new(wr);\n+            with_str_writer(|writer| {\n+                let mut encoder = Encoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n             \"\\\"Dog\\\"\".to_string()\n         );\n         assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::new(wr);\n+            with_str_writer(|writer| {\n+                let mut encoder = PrettyEncoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n             \"\\\"Dog\\\"\".to_string()\n         );\n \n         let animal = Frog(\"Henry\".to_string(), 349);\n         assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = Encoder::new(wr);\n+            with_str_writer(|writer| {\n+                let mut encoder = Encoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n             \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_string()\n         );\n         assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::new(wr);\n+            with_str_writer(|writer| {\n+                let mut encoder = PrettyEncoder::new(writer);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n             \"\\\n@@ -2476,15 +2351,15 @@ mod tests {\n     #[test]\n     fn test_write_some() {\n         let value = Some(\"jodhpurs\".to_string());\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n+        let s = with_str_writer(|writer| {\n+            let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"\\\"jodhpurs\\\"\".to_string());\n \n         let value = Some(\"jodhpurs\".to_string());\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = PrettyEncoder::new(wr);\n+        let s = with_str_writer(|writer| {\n+            let mut encoder = PrettyEncoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"\\\"jodhpurs\\\"\".to_string());\n@@ -2493,14 +2368,14 @@ mod tests {\n     #[test]\n     fn test_write_none() {\n         let value: Option<String> = None;\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n+        let s = with_str_writer(|writer| {\n+            let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"null\".to_string());\n \n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n+        let s = with_str_writer(|writer| {\n+            let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"null\".to_string());\n@@ -2535,16 +2410,13 @@ mod tests {\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let v: () = Decodable::decode(&mut decoder).unwrap();\n+        let v: () = super::decode(\"null\").unwrap();\n         assert_eq!(v, ());\n \n-        let mut decoder = Decoder::new(from_str(\"true\").unwrap());\n-        let v: bool = Decodable::decode(&mut decoder).unwrap();\n+        let v: bool = super::decode(\"true\").unwrap();\n         assert_eq!(v, true);\n \n-        let mut decoder = Decoder::new(from_str(\"false\").unwrap());\n-        let v: bool = Decodable::decode(&mut decoder).unwrap();\n+        let v: bool = super::decode(\"false\").unwrap();\n         assert_eq!(v, false);\n     }\n \n@@ -2571,32 +2443,25 @@ mod tests {\n \n     #[test]\n     fn test_decode_numbers() {\n-        let mut decoder = Decoder::new(from_str(\"3\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"3\").unwrap();\n         assert_eq!(v, 3.0);\n \n-        let mut decoder = Decoder::new(from_str(\"3.1\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"3.1\").unwrap();\n         assert_eq!(v, 3.1);\n \n-        let mut decoder = Decoder::new(from_str(\"-1.2\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"-1.2\").unwrap();\n         assert_eq!(v, -1.2);\n \n-        let mut decoder = Decoder::new(from_str(\"0.4\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"0.4\").unwrap();\n         assert_eq!(v, 0.4);\n \n-        let mut decoder = Decoder::new(from_str(\"0.4e5\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"0.4e5\").unwrap();\n         assert_eq!(v, 0.4e5);\n \n-        let mut decoder = Decoder::new(from_str(\"0.4e15\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"0.4e15\").unwrap();\n         assert_eq!(v, 0.4e15);\n \n-        let mut decoder = Decoder::new(from_str(\"0.4e-01\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"0.4e-01\").unwrap();\n         assert_eq!(v, 0.4e-01);\n     }\n \n@@ -2630,13 +2495,8 @@ mod tests {\n                  (\"\\\"\\\\uAB12\\\"\", \"\\uAB12\")];\n \n         for &(i, o) in s.iter() {\n-            let mut decoder = Decoder::new(from_str(i).unwrap());\n-            let v: String = Decodable::decode(&mut decoder).unwrap();\n+            let v: String = super::decode(i).unwrap();\n             assert_eq!(v.as_slice(), o);\n-\n-            let mut decoder = Decoder::new(from_str(i).unwrap());\n-            let v: String = Decodable::decode(&mut decoder).unwrap();\n-            assert_eq!(v, o.to_string());\n         }\n     }\n \n@@ -2663,28 +2523,19 @@ mod tests {\n \n     #[test]\n     fn test_decode_list() {\n-        let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n-        let v: Vec<()> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<()> = super::decode(\"[]\").unwrap();\n         assert_eq!(v, vec![]);\n \n-        let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n-        let v: Vec<()> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<()> = super::decode(\"[null]\").unwrap();\n         assert_eq!(v, vec![()]);\n \n-        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: Vec<bool> = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, vec![true]);\n-\n-        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: Vec<bool> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<bool> = super::decode(\"[true]\").unwrap();\n         assert_eq!(v, vec![true]);\n \n-        let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n-        let v: Vec<int> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<int> = super::decode(\"[3, 1]\").unwrap();\n         assert_eq!(v, vec![3, 1]);\n \n-        let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n-        let v: Vec<Vec<uint>> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<Vec<uint>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n         assert_eq!(v, vec![vec![3], vec![1, 2]]);\n     }\n \n@@ -2750,8 +2601,8 @@ mod tests {\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n         }\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let v: Outer = Decodable::decode(&mut decoder).unwrap();\n+\n+        let v: Outer = super::decode(s).unwrap();\n         assert_eq!(\n             v,\n             Outer {\n@@ -2769,44 +2620,37 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_struct_with_nan() {\n-        let encoded_str = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n-        let json_object = from_str(encoded_str.as_slice());\n-        let mut decoder = Decoder::new(json_object.unwrap());\n-        let after: FloatStruct = Decodable::decode(&mut decoder).unwrap();\n-        assert!(after.f.is_nan());\n-        assert!(after.a.get(0).is_nan());\n-        assert_eq!(after.a.get(1), &123f64);\n+        let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n+        let obj: FloatStruct = super::decode(s).unwrap();\n+        assert!(obj.f.is_nan());\n+        assert!(obj.a.get(0).is_nan());\n+        assert_eq!(obj.a.get(1), &123f64);\n     }\n \n     #[test]\n     fn test_decode_option() {\n-        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let value: Option<String> = Decodable::decode(&mut decoder).unwrap();\n+        let value: Option<String> = super::decode(\"null\").unwrap();\n         assert_eq!(value, None);\n \n-        let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<String> = Decodable::decode(&mut decoder).unwrap();\n+        let value: Option<String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n         assert_eq!(value, Some(\"jodhpurs\".to_string()));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let mut decoder = Decoder::new(from_str(\"\\\"Dog\\\"\").unwrap());\n-        let value: Animal = Decodable::decode(&mut decoder).unwrap();\n+        let value: Animal = super::decode(\"\\\"Dog\\\"\").unwrap();\n         assert_eq!(value, Dog);\n \n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let value: Animal = Decodable::decode(&mut decoder).unwrap();\n+        let value: Animal = super::decode(s).unwrap();\n         assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let mut map: TreeMap<String, Animal> = Decodable::decode(&mut decoder).unwrap();\n+        let mut map: TreeMap<String, Animal> = super::decode(s).unwrap();\n \n         assert_eq!(map.pop(&\"a\".to_string()), Some(Dog));\n         assert_eq!(map.pop(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n@@ -3331,7 +3175,7 @@ mod tests {\n             let mut tree_map = TreeMap::new();\n             tree_map.insert(\"a\".to_string(), Number(1.0_f64));\n             tree_map.insert(\"b\".to_string(), Number(2.0_f64));\n-            Object(box tree_map)\n+            Object(tree_map)\n         };\n \n         assert_eq!(list2.to_json(), list2);"}, {"sha": "ec31ffc93f38e8c68c67171d3de5b19c5225ebc8", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bc286f9987963bd40465905a2c89098f0e10601/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc286f9987963bd40465905a2c89098f0e10601/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=8bc286f9987963bd40465905a2c89098f0e10601", "patch": "@@ -1104,7 +1104,7 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n \n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n-        let mut map = box TreeMap::new();\n+        let mut map = TreeMap::new();\n         map.insert(\"value\".to_string(), json::Number(self.value));\n         map.insert(\"noise\".to_string(), json::Number(self.noise));\n         json::Object(map)"}, {"sha": "a0a800e08906dc134f9a597873f80c851b03ca00", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bc286f9987963bd40465905a2c89098f0e10601/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc286f9987963bd40465905a2c89098f0e10601/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=8bc286f9987963bd40465905a2c89098f0e10601", "patch": "@@ -22,11 +22,11 @@ enum object {\n     int_value(i64),\n }\n \n-fn lookup(table: Box<json::Object>, key: String, default: String) -> String\n+fn lookup(table: json::Object, key: String, default: String) -> String\n {\n     match table.find(&key.to_string()) {\n         option::Some(&json::String(ref s)) => {\n-            (*s).to_string()\n+            s.to_string()\n         }\n         option::Some(value) => {\n             println!(\"{} was expected to be a string but is a {:?}\", key, value);\n@@ -42,7 +42,7 @@ fn add_interface(_store: int, managed_ip: String, data: json::Json) -> (String,\n {\n     match &data {\n         &json::Object(ref interface) => {\n-            let name = lookup((*interface).clone(),\n+            let name = lookup(interface.clone(),\n                               \"ifDescr\".to_string(),\n                               \"\".to_string());\n             let label = format!(\"{}-{}\", managed_ip, name);"}]}