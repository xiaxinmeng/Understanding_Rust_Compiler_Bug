{"sha": "3ea5456366170f2b39bd77070c00c632537ec591", "node_id": "C_kwDOAAsO6NoAKDNlYTU0NTYzNjYxNzBmMmIzOWJkNzcwNzBjMDBjNjMyNTM3ZWM1OTE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-29T11:19:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-29T11:19:40Z"}, "message": "Rollup merge of #100239 - RalfJung:const-prop-uninit, r=oli-obk\n\nremove an ineffective check in const_prop\n\nBased on https://github.com/rust-lang/rust/pull/100043, only the last two commits are new.\n\nConstProp has a special check when reading from a local that prevents reading uninit locals. However, if that local flows into `force_allocation`, then no check fires and evaluation proceeds. So this check is not really effective at preventing accesses to uninit locals.\n\nWith https://github.com/rust-lang/rust/pull/100043, `read_immediate` and friends always fail when reading uninit locals, so I don't see why ConstProp would need a separate check. Thus I propose we remove it. This is needed to be able to do https://github.com/rust-lang/rust/pull/100085.", "tree": {"sha": "aba6fa2bbb0c58508a1d67cb5b7a85a36f665f15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aba6fa2bbb0c58508a1d67cb5b7a85a36f665f15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ea5456366170f2b39bd77070c00c632537ec591", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDKDMCRBK7hj4Ov3rIwAARykIAD/HGcspaSsC4DEwgxwOqP2a\nIit5VkYwMysDWBJuZu3jHQAMn2JDGmPzPda4paZhEhCDAWkbk/cDupUIowx8/1rG\n/bYTEwXoZOx9p2u0tQCgtD7r/Fz7ym4lDlPPonKxRQ8i9BEgW4p7CNoLMvDkLDhZ\n2fF6T+78CVQVabEZZ7cEWsfaPFcwE1Mn+19IjMR/KdQ2AMWUm/WGgV6E1BDTorwW\neLEsmOvntnq2kpveEuW0+biQACyCjxNMdb9sp+CQ1yQWfWl5iMNVcjXqb5abItua\nvsHXjO0bPaZmoVR0woppLUf+xysiBmXImB1WCha8PdVxMug8cYwGQ2Ij1xo14C8=\n=Llic\n-----END PGP SIGNATURE-----\n", "payload": "tree aba6fa2bbb0c58508a1d67cb5b7a85a36f665f15\nparent 5555e13a6ec5268612e85baa3af62ddf95fa2517\nparent aff9841507d2e0caef015c523fd8f41848b0c2f9\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661771980 +0530\ncommitter GitHub <noreply@github.com> 1661771980 +0530\n\nRollup merge of #100239 - RalfJung:const-prop-uninit, r=oli-obk\n\nremove an ineffective check in const_prop\n\nBased on https://github.com/rust-lang/rust/pull/100043, only the last two commits are new.\n\nConstProp has a special check when reading from a local that prevents reading uninit locals. However, if that local flows into `force_allocation`, then no check fires and evaluation proceeds. So this check is not really effective at preventing accesses to uninit locals.\n\nWith https://github.com/rust-lang/rust/pull/100043, `read_immediate` and friends always fail when reading uninit locals, so I don't see why ConstProp would need a separate check. Thus I propose we remove it. This is needed to be able to do https://github.com/rust-lang/rust/pull/100085.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea5456366170f2b39bd77070c00c632537ec591", "html_url": "https://github.com/rust-lang/rust/commit/3ea5456366170f2b39bd77070c00c632537ec591", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ea5456366170f2b39bd77070c00c632537ec591/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5555e13a6ec5268612e85baa3af62ddf95fa2517", "url": "https://api.github.com/repos/rust-lang/rust/commits/5555e13a6ec5268612e85baa3af62ddf95fa2517", "html_url": "https://github.com/rust-lang/rust/commit/5555e13a6ec5268612e85baa3af62ddf95fa2517"}, {"sha": "aff9841507d2e0caef015c523fd8f41848b0c2f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff9841507d2e0caef015c523fd8f41848b0c2f9", "html_url": "https://github.com/rust-lang/rust/commit/aff9841507d2e0caef015c523fd8f41848b0c2f9"}], "stats": {"total": 122, "additions": 64, "deletions": 58}, "files": [{"sha": "d37eaeed095a154fa7732fa24253ab4dfde84688", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=3ea5456366170f2b39bd77070c00c632537ec591", "patch": "@@ -187,9 +187,6 @@ pub enum LocalValue<Prov: Provenance = AllocId> {\n \n impl<'tcx, Prov: Provenance + 'static> LocalState<'tcx, Prov> {\n     /// Read the local's value or error if the local is not yet live or not live anymore.\n-    ///\n-    /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n-    /// anywhere else. You may be invalidating machine invariants if you do!\n     #[inline]\n     pub fn access(&self) -> InterpResult<'tcx, &Operand<Prov>> {\n         match &self.value {"}, {"sha": "b151d03681f43df4a89246f7bea8d052cd7d0238", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=3ea5456366170f2b39bd77070c00c632537ec591", "patch": "@@ -215,23 +215,12 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         right: &ImmTy<'tcx, Self::Provenance>,\n     ) -> InterpResult<'tcx, (Scalar<Self::Provenance>, bool, Ty<'tcx>)>;\n \n-    /// Called to read the specified `local` from the `frame`.\n-    /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n-    /// for ZST reads.\n-    #[inline]\n-    fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n-        local: mir::Local,\n-    ) -> InterpResult<'tcx, &'a Operand<Self::Provenance>>\n-    where\n-        'tcx: 'mir,\n-    {\n-        frame.locals[local].access()\n-    }\n-\n     /// Called to write the specified `local` from the `frame`.\n     /// Since writing a ZST is not actually accessing memory or locals, this is never invoked\n     /// for ZST reads.\n+    ///\n+    /// Due to borrow checker trouble, we indicate the `frame` as an index rather than an `&mut\n+    /// Frame`.\n     #[inline]\n     fn access_local_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "91a97fe4d4dd84dec4b661abbe26f8be3e65fd20", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=3ea5456366170f2b39bd77070c00c632537ec591", "patch": "@@ -444,7 +444,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Read from a local. Will not actually access the local if reading from a ZST.\n+    /// Read from a local.\n     /// Will not access memory, instead an indirect `Operand` is returned.\n     ///\n     /// This is public because it is used by [priroda](https://github.com/oli-obk/priroda) to get an\n@@ -456,12 +456,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let layout = self.layout_of_local(frame, local, layout)?;\n-        let op = if layout.is_zst() {\n-            // Bypass `access_local` (helps in ConstProp)\n-            Operand::Immediate(Immediate::Uninit)\n-        } else {\n-            *M::access_local(frame, local)?\n-        };\n+        let op = *frame.locals[local].access()?;\n         Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }\n "}, {"sha": "d56323448cea19326c2746da29b52385afed217d", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=3ea5456366170f2b39bd77070c00c632537ec591", "patch": "@@ -642,7 +642,7 @@ where\n         // avoid force_allocation.\n         let src = match self.read_immediate_raw(src)? {\n             Ok(src_val) => {\n-                assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n+                assert!(!src.layout.is_unsized(), \"cannot copy unsized immediates\");\n                 assert!(\n                     !dest.layout.is_unsized(),\n                     \"the src is sized, so the dest must also be sized\""}, {"sha": "16ce5bc71750a868d845528f8ff068a0a3165495", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=3ea5456366170f2b39bd77070c00c632537ec591", "patch": "@@ -100,6 +100,8 @@ where\n         // This makes several assumptions about what layouts we will encounter; we match what\n         // codegen does as good as we can (see `extract_field` in `rustc_codegen_ssa/src/mir/operand.rs`).\n         let field_val: Immediate<_> = match (*base, base.layout.abi) {\n+            // if the entire value is uninit, then so is the field (can happen in ConstProp)\n+            (Immediate::Uninit, _) => Immediate::Uninit,\n             // the field contains no information, can be left uninit\n             _ if field_layout.is_zst() => Immediate::Uninit,\n             // the field covers the entire type\n@@ -124,6 +126,7 @@ where\n                     b_val\n                 })\n             }\n+            // everything else is a bug\n             _ => span_bug!(\n                 self.cur_span(),\n                 \"invalid field access on immediate {}, layout {:#?}\","}, {"sha": "53f33a7a0bad2516cde21120e629806b0898fa09", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=3ea5456366170f2b39bd77070c00c632537ec591", "patch": "@@ -243,24 +243,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n-    fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n-        local: Local,\n-    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::Provenance>> {\n-        let l = &frame.locals[local];\n-\n-        if matches!(\n-            l.value,\n-            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-        ) {\n-            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n-            // So stop here.\n-            throw_machine_stop_str!(\"tried to access alocal with unknown value \")\n-        }\n-\n-        l.access()\n-    }\n-\n     fn access_local_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n@@ -431,7 +413,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n-            Ok(op) => op,\n+            Ok(op) => {\n+                if matches!(*op, interpret::Operand::Immediate(Immediate::Uninit)) {\n+                    // Make sure nobody accidentally uses this value.\n+                    return None;\n+                }\n+                op\n+            }\n             Err(e) => {\n                 trace!(\"get_const failed: {}\", e);\n                 return None;\n@@ -643,6 +631,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if rvalue.needs_subst() {\n             return None;\n         }\n+        if !rvalue\n+            .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n+            .is_sized(self.ecx.tcx, self.param_env)\n+        {\n+            // the interpreter doesn't support unsized locals (only unsized arguments),\n+            // but rustc does (in a kinda broken way), so we have to skip them here\n+            return None;\n+        }\n \n         if self.tcx.sess.mir_opt_level() >= 4 {\n             self.eval_rvalue_with_identities(rvalue, place)\n@@ -660,18 +656,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         self.use_ecx(|this| match rvalue {\n             Rvalue::BinaryOp(op, box (left, right))\n             | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                let l = this.ecx.eval_operand(left, None);\n-                let r = this.ecx.eval_operand(right, None);\n+                let l = this.ecx.eval_operand(left, None).and_then(|x| this.ecx.read_immediate(&x));\n+                let r =\n+                    this.ecx.eval_operand(right, None).and_then(|x| this.ecx.read_immediate(&x));\n \n                 let const_arg = match (l, r) {\n-                    (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n-                    (Err(e), Err(_)) => return Err(e),\n-                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place),\n+                    (Ok(x), Err(_)) | (Err(_), Ok(x)) => x, // exactly one side is known\n+                    (Err(e), Err(_)) => return Err(e),      // neither side is known\n+                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place), // both sides are known\n                 };\n \n                 if !matches!(const_arg.layout.abi, abi::Abi::Scalar(..)) {\n                     // We cannot handle Scalar Pair stuff.\n-                    return this.ecx.eval_rvalue_into_place(rvalue, place);\n+                    // No point in calling `eval_rvalue_into_place`, since only one side is known\n+                    throw_machine_stop_str!(\"cannot optimize this\")\n                 }\n \n                 let arg_value = const_arg.to_scalar().to_bits(const_arg.layout.size)?;\n@@ -696,7 +694,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             this.ecx.write_immediate(*const_arg, &dest)\n                         }\n                     }\n-                    _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n+                    _ => throw_machine_stop_str!(\"cannot optimize this\"),\n                 }\n             }\n             _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n@@ -1073,7 +1071,11 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 if let Some(ref value) = self.eval_operand(&cond) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = Scalar::from_bool(*expected);\n-                    let value_const = self.ecx.read_scalar(&value).unwrap();\n+                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n+                        // FIXME should be used use_ecx rather than a local match... but we have\n+                        // quite a few of these read_scalar/read_immediate that need fixing.\n+                        return\n+                    };\n                     if expected != value_const {\n                         // Poison all places this operand references so that further code\n                         // doesn't use the invalid value"}, {"sha": "082d6c9f07e535c38175a741687ee8b144b85ea7", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea5456366170f2b39bd77070c00c632537ec591/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=3ea5456366170f2b39bd77070c00c632537ec591", "patch": "@@ -6,6 +6,7 @@ use crate::const_prop::ConstPropMachine;\n use crate::const_prop::ConstPropMode;\n use crate::MirLint;\n use rustc_const_eval::const_eval::ConstEvalErr;\n+use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n     self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n@@ -229,7 +230,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n-            Ok(op) => op,\n+            Ok(op) => {\n+                if matches!(*op, interpret::Operand::Immediate(Immediate::Uninit)) {\n+                    // Make sure nobody accidentally uses this value.\n+                    return None;\n+                }\n+                op\n+            }\n             Err(e) => {\n                 trace!(\"get_const failed: {}\", e);\n                 return None;\n@@ -515,6 +522,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if rvalue.needs_subst() {\n             return None;\n         }\n+        if !rvalue\n+            .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n+            .is_sized(self.ecx.tcx, self.param_env)\n+        {\n+            // the interpreter doesn't support unsized locals (only unsized arguments),\n+            // but rustc does (in a kinda broken way), so we have to skip them here\n+            return None;\n+        }\n \n         self.use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, place))\n     }\n@@ -624,7 +639,11 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 if let Some(ref value) = self.eval_operand(&cond, source_info) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = Scalar::from_bool(*expected);\n-                    let value_const = self.ecx.read_scalar(&value).unwrap();\n+                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n+                        // FIXME should be used use_ecx rather than a local match... but we have\n+                        // quite a few of these read_scalar/read_immediate that need fixing.\n+                        return\n+                    };\n                     if expected != value_const {\n                         enum DbgVal<T> {\n                             Val(T),\n@@ -641,9 +660,9 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                         let mut eval_to_int = |op| {\n                             // This can be `None` if the lhs wasn't const propagated and we just\n                             // triggered the assert on the value of the rhs.\n-                            self.eval_operand(op, source_info).map_or(DbgVal::Underscore, |op| {\n-                                DbgVal::Val(self.ecx.read_immediate(&op).unwrap().to_const_int())\n-                            })\n+                            self.eval_operand(op, source_info)\n+                                .and_then(|op| self.ecx.read_immediate(&op).ok())\n+                                .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n                         };\n                         let msg = match msg {\n                             AssertKind::DivisionByZero(op) => {"}, {"sha": "186a953735675ec67382585fca5dc3510245b973", "filename": "src/test/mir-opt/const_prop/mutable_variable_unprop_assign.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ea5456366170f2b39bd77070c00c632537ec591/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3ea5456366170f2b39bd77070c00c632537ec591/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff?ref=3ea5456366170f2b39bd77070c00c632537ec591", "patch": "@@ -41,7 +41,8 @@\n           StorageLive(_4);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+4:9: +4:10\n           _4 = (_2.1: i32);                // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+4:13: +4:16\n           StorageLive(_5);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:9: +5:10\n-          _5 = (_2.0: i32);                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n+-         _5 = (_2.0: i32);                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n++         _5 = const 1_i32;                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n           nop;                             // scope 0 at $DIR/mutable_variable_unprop_assign.rs:+0:11: +6:2\n           StorageDead(_5);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2\n           StorageDead(_4);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2"}]}