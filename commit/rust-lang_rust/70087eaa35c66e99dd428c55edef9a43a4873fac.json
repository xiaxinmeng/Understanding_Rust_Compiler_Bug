{"sha": "70087eaa35c66e99dd428c55edef9a43a4873fac", "node_id": "C_kwDOAAsO6NoAKDcwMDg3ZWFhMzVjNjZlOTlkZDQyOGM1NWVkZWY5YTQzYTQ4NzNmYWM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-26T08:42:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-26T08:44:07Z"}, "message": "add pthread_getname_np", "tree": {"sha": "0ca5deb0018470ff4db95273029b078072b8c3a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ca5deb0018470ff4db95273029b078072b8c3a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70087eaa35c66e99dd428c55edef9a43a4873fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70087eaa35c66e99dd428c55edef9a43a4873fac", "html_url": "https://github.com/rust-lang/rust/commit/70087eaa35c66e99dd428c55edef9a43a4873fac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70087eaa35c66e99dd428c55edef9a43a4873fac/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a46ccba167086f0b562eb78403f7446b0fed5f65", "url": "https://api.github.com/repos/rust-lang/rust/commits/a46ccba167086f0b562eb78403f7446b0fed5f65", "html_url": "https://github.com/rust-lang/rust/commit/a46ccba167086f0b562eb78403f7446b0fed5f65"}], "stats": {"total": 162, "additions": 131, "deletions": 31}, "files": [{"sha": "ac5dcbf0f4f2fc8b799d046bf69f54bada7dc0fa", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=70087eaa35c66e99dd428c55edef9a43a4873fac", "patch": "@@ -870,6 +870,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.machine.threads.active_thread_stack_mut()\n     }\n \n+    /// Set the name of the current thread. The buffer must not include the null terminator.\n     #[inline]\n     fn set_thread_name(&mut self, thread: ThreadId, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();"}, {"sha": "f98727186c48d91f07159b875e414e1cc454cf99", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=70087eaa35c66e99dd428c55edef9a43a4873fac", "patch": "@@ -1,6 +1,7 @@\n pub mod convert;\n \n use std::cmp;\n+use std::iter;\n use std::mem;\n use std::num::NonZeroUsize;\n use std::time::Duration;\n@@ -735,6 +736,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         })\n     }\n \n+    /// Read a sequence of bytes until the first null terminator.\n     fn read_c_str<'a>(&'a self, ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, &'a [u8]>\n     where\n         'tcx: 'a,\n@@ -761,6 +763,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.read_bytes_ptr_strip_provenance(ptr, len)\n     }\n \n+    /// Helper function to write a sequence of bytes with an added null-terminator, which is what\n+    /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `c_str` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does include the null terminator.\n+    fn write_c_str(\n+        &mut self,\n+        c_str: &[u8],\n+        ptr: Pointer<Option<Provenance>>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n+        // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n+        let string_length = u64::try_from(c_str.len()).unwrap();\n+        let string_length = string_length.checked_add(1).unwrap();\n+        if size < string_length {\n+            return Ok((false, string_length));\n+        }\n+        self.eval_context_mut()\n+            .write_bytes_ptr(ptr, c_str.iter().copied().chain(iter::once(0u8)))?;\n+        Ok((true, string_length))\n+    }\n+\n+    /// Read a sequence of u16 until the first null terminator.\n     fn read_wide_str(&self, mut ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, Vec<u16>> {\n         let this = self.eval_context_ref();\n         let size2 = Size::from_bytes(2);\n@@ -783,6 +809,39 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(wchars)\n     }\n \n+    /// Helper function to write a sequence of u16 with an added 0x0000-terminator, which is what\n+    /// the Windows APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does include the null terminator. Length is measured in units of\n+    /// `u16.`\n+    fn write_wide_str(\n+        &mut self,\n+        wide_str: &[u16],\n+        ptr: Pointer<Option<Provenance>>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n+        // 0x0000 terminator to memory would cause an out-of-bounds access.\n+        let string_length = u64::try_from(wide_str.len()).unwrap();\n+        let string_length = string_length.checked_add(1).unwrap();\n+        if size < string_length {\n+            return Ok((false, string_length));\n+        }\n+\n+        // Store the UTF-16 string.\n+        let size2 = Size::from_bytes(2);\n+        let this = self.eval_context_mut();\n+        let mut alloc = this\n+            .get_ptr_alloc_mut(ptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n+            .unwrap(); // not a ZST, so we will get a result\n+        for (offset, wchar) in wide_str.iter().copied().chain(iter::once(0x0000)).enumerate() {\n+            let offset = u64::try_from(offset).unwrap();\n+            alloc.write_scalar(alloc_range(size2 * offset, size2), Scalar::from_u16(wchar))?;\n+        }\n+        Ok((true, string_length))\n+    }\n+\n     /// Check that the ABI is what we expect.\n     fn check_abi<'a>(&self, abi: Abi, exp_abi: Abi) -> InterpResult<'a, ()> {\n         if self.eval_context_ref().machine.enforce_abi && abi != exp_abi {"}, {"sha": "99b3605c60175458d117488ab67d7bc01f22c5ce", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=70087eaa35c66e99dd428c55edef9a43a4873fac", "patch": "@@ -1,6 +1,5 @@\n use std::borrow::Cow;\n use std::ffi::{OsStr, OsString};\n-use std::iter;\n use std::path::{Path, PathBuf};\n \n #[cfg(unix)]\n@@ -9,7 +8,6 @@ use std::os::unix::ffi::{OsStrExt, OsStringExt};\n use std::os::windows::ffi::{OsStrExt, OsStringExt};\n \n use rustc_middle::ty::layout::LayoutOf;\n-use rustc_target::abi::{Align, Size};\n \n use crate::*;\n \n@@ -100,16 +98,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let bytes = os_str_to_bytes(os_str)?;\n-        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n-        // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n-        let string_length = u64::try_from(bytes.len()).unwrap();\n-        let string_length = string_length.checked_add(1).unwrap();\n-        if size < string_length {\n-            return Ok((false, string_length));\n-        }\n-        self.eval_context_mut()\n-            .write_bytes_ptr(ptr, bytes.iter().copied().chain(iter::once(0u8)))?;\n-        Ok((true, string_length))\n+        self.eval_context_mut().write_c_str(bytes, ptr, size)\n     }\n \n     /// Helper function to write an OsStr as a 0x0000-terminated u16-sequence, which is what\n@@ -140,25 +129,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         let u16_vec = os_str_to_u16vec(os_str)?;\n-        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n-        // 0x0000 terminator to memory would cause an out-of-bounds access.\n-        let string_length = u64::try_from(u16_vec.len()).unwrap();\n-        let string_length = string_length.checked_add(1).unwrap();\n-        if size < string_length {\n-            return Ok((false, string_length));\n-        }\n-\n-        // Store the UTF-16 string.\n-        let size2 = Size::from_bytes(2);\n-        let this = self.eval_context_mut();\n-        let mut alloc = this\n-            .get_ptr_alloc_mut(ptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n-            .unwrap(); // not a ZST, so we will get a result\n-        for (offset, wchar) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n-            let offset = u64::try_from(offset).unwrap();\n-            alloc.write_scalar(alloc_range(size2 * offset, size2), Scalar::from_u16(wchar))?;\n-        }\n-        Ok((true, string_length))\n+        self.eval_context_mut().write_wide_str(&u16_vec, ptr, size)\n     }\n \n     /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of bytes."}, {"sha": "c004e2292a93aef6f51b2b3eb915ed7bbcaedbe8", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=70087eaa35c66e99dd428c55edef9a43a4873fac", "patch": "@@ -72,6 +72,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.pthread_setname_np(this.read_scalar(thread)?, this.read_scalar(name)?)?;\n                 this.write_scalar(res, dest)?;\n             }\n+            \"pthread_getname_np\" => {\n+                let [thread, name, len] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let res = this.pthread_getname_np(\n+                    this.read_scalar(thread)?,\n+                    this.read_scalar(name)?,\n+                    this.read_scalar(len)?,\n+                )?;\n+                this.write_scalar(res, dest)?;\n+            }\n \n             // Dynamically invoked syscalls\n             \"syscall\" => {"}, {"sha": "0e931023e6c1cb781ed4d422a0a794125318b26f", "filename": "src/tools/miri/src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=70087eaa35c66e99dd428c55edef9a43a4873fac", "patch": "@@ -178,6 +178,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let thread = this.pthread_self()?;\n                 this.pthread_setname_np(thread, this.read_scalar(name)?)?;\n             }\n+            \"pthread_getname_np\" => {\n+                let [thread, name, len] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let res = this.pthread_getname_np(\n+                    this.read_scalar(thread)?,\n+                    this.read_scalar(name)?,\n+                    this.read_scalar(len)?,\n+                )?;\n+                this.write_scalar(res, dest)?;\n+            }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library."}, {"sha": "4320ecd389e5bc29de7ed7071b51a0b7b7317659", "filename": "src/tools/miri/src/shims/unix/thread.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs?ref=70087eaa35c66e99dd428c55edef9a43a4873fac", "patch": "@@ -78,11 +78,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let name = name.to_pointer(this)?;\n \n         let name = this.read_c_str(name)?.to_owned();\n+\n+        if name.len() > 15 {\n+            // Thread names are limited to 16 characaters, including the null terminator.\n+            return this.eval_libc(\"ERANGE\");\n+        }\n+\n         this.set_thread_name(thread, name);\n \n         Ok(Scalar::from_u32(0))\n     }\n \n+    fn pthread_getname_np(\n+        &mut self,\n+        thread: Scalar<Provenance>,\n+        name_out: Scalar<Provenance>,\n+        len: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let thread = ThreadId::try_from(thread.to_machine_usize(this)?).unwrap();\n+        let name_out = name_out.to_pointer(this)?;\n+        let len = len.to_machine_usize(this)?;\n+\n+        let name = this.get_thread_name(thread).to_owned();\n+        let (success, _written) = this.write_c_str(&name, name_out, len)?;\n+\n+        if success { Ok(Scalar::from_u32(0)) } else { this.eval_libc(\"ERANGE\") }\n+    }\n+\n     fn sched_yield(&mut self) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n "}, {"sha": "bbddca74754c50125e47a2b46e5893da292b74da", "filename": "src/tools/miri/tests/pass-dep/shims/pthreads.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70087eaa35c66e99dd428c55edef9a43a4873fac/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs?ref=70087eaa35c66e99dd428c55edef9a43a4873fac", "patch": "@@ -1,10 +1,14 @@\n //@ignore-target-windows: No libc on Windows\n+#![feature(cstr_from_bytes_until_nul)]\n+use std::ffi::CStr;\n+use std::thread;\n \n fn main() {\n     test_mutex_libc_init_recursive();\n     test_mutex_libc_init_normal();\n     test_mutex_libc_init_errorcheck();\n     test_rwlock_libc_static_initializer();\n+    test_named_thread_truncation();\n \n     #[cfg(any(target_os = \"linux\"))]\n     test_mutex_libc_static_initializer_recursive();\n@@ -125,3 +129,24 @@ fn test_rwlock_libc_static_initializer() {\n         assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n     }\n }\n+\n+fn test_named_thread_truncation() {\n+    let long_name = std::iter::once(\"test_named_thread_truncation\")\n+        .chain(std::iter::repeat(\" yada\").take(100))\n+        .collect::<String>();\n+\n+    let result = thread::Builder::new().name(long_name.clone()).spawn(move || {\n+        // Rust remembers the full thread name itself.\n+        assert_eq!(thread::current().name(), Some(long_name.as_str()));\n+\n+        // But the system is limited -- make sure we successfully set a truncation.\n+        let mut buf = vec![0u8; long_name.len() + 1];\n+        unsafe {\n+            libc::pthread_getname_np(libc::pthread_self(), buf.as_mut_ptr().cast(), buf.len());\n+        }\n+        let cstr = CStr::from_bytes_until_nul(&buf).unwrap();\n+        assert!(cstr.to_bytes().len() >= 15); // POSIX seems to promise at least 15 chars\n+        assert!(long_name.as_bytes().starts_with(cstr.to_bytes()));\n+    });\n+    result.unwrap().join().unwrap();\n+}"}]}