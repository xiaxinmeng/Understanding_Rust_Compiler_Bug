{"sha": "81dc88f88f92ba8ad7465f9cba10c12d3a7b70f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZGM4OGY4OGY5MmJhOGFkNzQ2NWY5Y2JhMTBjMTJkM2E3YjcwZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-13T21:36:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-13T21:36:02Z"}, "message": "Auto merge of #75105 - ssomers:btree_respect_min_len_hard, r=Mark-Simulacrum\n\nHard way to respect BTreeMap's minimum node length\n\nResolves #74834 the hard way (though not the hardest imaginable).\n\nBenchmarks (which are all biased/realistic, inserting keys in ascending order) say:\n```\nbenchcmp r0 r1 --threshold 10\n name                                        r0 ns/iter  r1 ns/iter  diff ns/iter   diff %  speedup\n btree::map::clone_slim_100_and_clear        2,183       2,723                540   24.74%   x 0.80\n btree::map::clone_slim_100_and_drain_all    3,652       4,173                521   14.27%   x 0.88\n btree::map::clone_slim_100_and_drain_half   3,320       3,940                620   18.67%   x 0.84\n btree::map::clone_slim_100_and_into_iter    2,154       2,717                563   26.14%   x 0.79\n btree::map::clone_slim_100_and_pop_all      3,372       3,870                498   14.77%   x 0.87\n btree::map::clone_slim_100_and_remove_all   5,111       5,647                536   10.49%   x 0.91\n btree::map::clone_slim_100_and_remove_half  3,259       3,821                562   17.24%   x 0.85\n btree::map::iter_0                          1,733       1,509               -224  -12.93%   x 1.15\n btree::map::iter_100                        2,714       3,739              1,025   37.77%   x 0.73\n btree::map::iter_10k                        3,728       4,269                541   14.51%   x 0.87\n btree::map::range_unbounded_unbounded       28,426      36,631             8,205   28.86%   x 0.78\n btree::map::range_unbounded_vs_iter         28,808      34,056             5,248   18.22%   x 0.85\n```\nThis difference is not caused by the `debug_assert`-related code in the function `splitpoint`, it's the same without.", "tree": {"sha": "a9ef432b92933100f46efe74c1f07900582ada9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9ef432b92933100f46efe74c1f07900582ada9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81dc88f88f92ba8ad7465f9cba10c12d3a7b70f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81dc88f88f92ba8ad7465f9cba10c12d3a7b70f1", "html_url": "https://github.com/rust-lang/rust/commit/81dc88f88f92ba8ad7465f9cba10c12d3a7b70f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81dc88f88f92ba8ad7465f9cba10c12d3a7b70f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "html_url": "https://github.com/rust-lang/rust/commit/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b"}, {"sha": "17ab457f21700caad62c3f3fcfeff48f21d2393b", "url": "https://api.github.com/repos/rust-lang/rust/commits/17ab457f21700caad62c3f3fcfeff48f21d2393b", "html_url": "https://github.com/rust-lang/rust/commit/17ab457f21700caad62c3f3fcfeff48f21d2393b"}], "stats": {"total": 81, "additions": 65, "deletions": 16}, "files": [{"sha": "aa959c667accf1a2814eb40fb7b0ec7b81299aed", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/81dc88f88f92ba8ad7465f9cba10c12d3a7b70f1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dc88f88f92ba8ad7465f9cba10c12d3a7b70f1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=81dc88f88f92ba8ad7465f9cba10c12d3a7b70f1", "patch": "@@ -821,6 +821,53 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n+enum InsertionPlace {\n+    Left(usize),\n+    Right(usize),\n+}\n+\n+/// Given an edge index where we want to insert into a node filled to capacity,\n+/// computes a sensible KV index of a split point and where to perform the insertion.\n+/// The goal of the split point is for its key and value to end up in a parent node;\n+/// the keys, values and edges to the left of the split point become the left child;\n+/// the keys, values and edges to the right of the split point become the right child.\n+fn splitpoint(edge_idx: usize) -> (usize, InsertionPlace) {\n+    debug_assert!(edge_idx <= CAPACITY);\n+    // Rust issue #74834 tries to explain these symmetric rules.\n+    let middle_kv_idx;\n+    let insertion;\n+    if edge_idx <= B - 2 {\n+        middle_kv_idx = B - 2;\n+        insertion = InsertionPlace::Left(edge_idx);\n+    } else if edge_idx == B - 1 {\n+        middle_kv_idx = B - 1;\n+        insertion = InsertionPlace::Left(edge_idx);\n+    } else if edge_idx == B {\n+        middle_kv_idx = B - 1;\n+        insertion = InsertionPlace::Right(0);\n+    } else {\n+        middle_kv_idx = B;\n+        let new_edge_idx = edge_idx - (B + 1);\n+        insertion = InsertionPlace::Right(new_edge_idx);\n+    }\n+    let mut left_len = middle_kv_idx;\n+    let mut right_len = CAPACITY - middle_kv_idx - 1;\n+    match insertion {\n+        InsertionPlace::Left(edge_idx) => {\n+            debug_assert!(edge_idx <= left_len);\n+            left_len += 1;\n+        }\n+        InsertionPlace::Right(edge_idx) => {\n+            debug_assert!(edge_idx <= right_len);\n+            right_len += 1;\n+        }\n+    }\n+    debug_assert!(left_len >= MIN_LEN);\n+    debug_assert!(right_len >= MIN_LEN);\n+    debug_assert!(left_len + right_len == CAPACITY);\n+    (middle_kv_idx, insertion)\n+}\n+\n impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n     /// Helps implementations of `insert_fit` for a particular `NodeType`,\n     /// by taking care of leaf data.\n@@ -863,18 +910,20 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n             (InsertResult::Fit(kv), ptr)\n         } else {\n-            let middle = unsafe { Handle::new_kv(self.node, B) };\n+            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n+            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            let ptr = if self.idx <= B {\n-                unsafe { Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val) }\n-            } else {\n-                unsafe {\n+            let ptr = match insertion {\n+                InsertionPlace::Left(insert_idx) => unsafe {\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val)\n+                },\n+                InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n                         right.node_as_mut().cast_unchecked::<marker::Leaf>(),\n-                        self.idx - (B + 1),\n+                        insert_idx,\n                     )\n                     .insert_fit(key, val)\n-                }\n+                },\n             };\n             (InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right }), ptr)\n         }\n@@ -936,20 +985,20 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n             InsertResult::Fit(kv)\n         } else {\n-            let middle = unsafe { Handle::new_kv(self.node, B) };\n+            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n+            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            if self.idx <= B {\n-                unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val, edge);\n-                }\n-            } else {\n-                unsafe {\n+            match insertion {\n+                InsertionPlace::Left(insert_idx) => unsafe {\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val, edge);\n+                },\n+                InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n                         right.node_as_mut().cast_unchecked::<marker::Internal>(),\n-                        self.idx - (B + 1),\n+                        insert_idx,\n                     )\n                     .insert_fit(key, val, edge);\n-                }\n+                },\n             }\n             InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right })\n         }"}]}