{"sha": "2afe58571e53d48a1fc2354271abe5aff60c5c44", "node_id": "C_kwDOAAsO6NoAKDJhZmU1ODU3MWU1M2Q0OGExZmMyMzU0MjcxYWJlNWFmZjYwYzVjNDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-08T01:34:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-08T01:34:05Z"}, "message": "Auto merge of #104658 - thomcc:rand-update-and-usable-no_std, r=Mark-Simulacrum\n\nUpdate `rand` in the stdlib tests, and remove the `getrandom` feature from it.\n\nThe main goal is actually removing `getrandom`, so that eventually we can allow running the stdlib test suite on tier3 targets which don't have `getrandom` support. Currently those targets can only run the subset of stdlib tests that exist in uitests, and (generally speaking), we prefer not to test libstd functionality in uitests, which came up recently in https://github.com/rust-lang/rust/pull/104095 and https://github.com/rust-lang/rust/pull/104185. Additionally, the fact that we can't update `rand`/`getrandom` means we're stuck with the old set of tier3 targets, so can't test new ones.\n\n~~Anyway, I haven't checked that this actually does allow use on tier3 targets (I think it does not, as some work is needed in stdlib submodules) but it moves us slightly closer to this, and seems to allow at least finally updating our `rand` dep, which definitely improves the status quo.~~ Checked and works now.\n\nFor the most part, our tests and benchmarks are fine using hard-coded seeds. A couple tests seem to fail with this (stuff manipulating the environment expecting no collisions, for example), or become pointless (all inputs to a function become equivalent). In these cases I've done a (gross) dance (ab)using `RandomState` and `Location::caller()` for some extra \"entropy\".\n\nTrying to share that code seems *way* more painful than it's worth given that the duplication is a 7-line function, even if the lines are quite gross. (Keeping in mind that sharing it would require adding `rand` as a non-dev dep to std, and exposing a type from it publicly, all of which sounds truly awful, even if done behind a perma-unstable feature).\n\nSee also some previous attempts:\n- https://github.com/rust-lang/rust/pull/86963 (in particular https://github.com/rust-lang/rust/pull/86963#issuecomment-885438936 which explains why this is non-trivial)\n- https://github.com/rust-lang/rust/pull/89131\n- https://github.com/rust-lang/rust/pull/96626#issuecomment-1114562857 (I tried in that PR at the same time, but settled for just removing the usage of `thread_rng()` from the benchmarks, since that was the main goal).\n- https://github.com/rust-lang/rust/pull/104185\n- Probably more. It's very tempting of a thing to \"just update\".\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "5da1df8e294c5fa8f555164d779f0fa239276224", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5da1df8e294c5fa8f555164d779f0fa239276224"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2afe58571e53d48a1fc2354271abe5aff60c5c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2afe58571e53d48a1fc2354271abe5aff60c5c44", "html_url": "https://github.com/rust-lang/rust/commit/2afe58571e53d48a1fc2354271abe5aff60c5c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2afe58571e53d48a1fc2354271abe5aff60c5c44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5d46a5bdac3f19793297914d4ada432024fbe95", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d46a5bdac3f19793297914d4ada432024fbe95", "html_url": "https://github.com/rust-lang/rust/commit/e5d46a5bdac3f19793297914d4ada432024fbe95"}, {"sha": "a4bf36e87bdec61240fb3040774d008c70acbfbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4bf36e87bdec61240fb3040774d008c70acbfbb", "html_url": "https://github.com/rust-lang/rust/commit/a4bf36e87bdec61240fb3040774d008c70acbfbb"}], "stats": {"total": 988, "additions": 508, "deletions": 480}, "files": [{"sha": "da47b08c7df55bc54fa99408563defa00803d51e", "filename": "Cargo.lock", "status": "modified", "additions": 34, "deletions": 91, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -30,7 +30,7 @@ version = \"0.7.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"43bb833f0bf979d8475d38fbf09ed3b8a55e1885fe93ad3f93239fc6a4f17b98\"\n dependencies = [\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n  \"once_cell\",\n  \"version_check\",\n ]\n@@ -50,7 +50,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"compiler_builtins\",\n  \"core\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rand_xorshift\",\n ]\n \n@@ -951,7 +951,7 @@ checksum = \"6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e\"\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rand_xorshift\",\n ]\n \n@@ -1055,7 +1055,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ef2b4b23cddf68b89b8f8069890e8c270d54e2d5fe1b143820234805e4cb17ef\"\n dependencies = [\n  \"generic-array\",\n- \"rand_core 0.6.4\",\n+ \"rand_core\",\n  \"subtle\",\n  \"zeroize\",\n ]\n@@ -1314,7 +1314,7 @@ version = \"2.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6a3d382e8464107391c8706b4c14b087808ecb909f6c15c34114bc42e53a9e4c\"\n dependencies = [\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n ]\n \n [[package]]\n@@ -1351,7 +1351,7 @@ dependencies = [\n  \"hkdf\",\n  \"pem-rfc7468\",\n  \"pkcs8\",\n- \"rand_core 0.6.4\",\n+ \"rand_core\",\n  \"sec1\",\n  \"subtle\",\n  \"zeroize\",\n@@ -1482,7 +1482,7 @@ version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d013fc25338cc558c5c2cfbad646908fb23591e2404481826742b651c9af7160\"\n dependencies = [\n- \"rand_core 0.6.4\",\n+ \"rand_core\",\n  \"subtle\",\n ]\n \n@@ -1749,17 +1749,6 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n-[[package]]\n-name = \"getrandom\"\n-version = \"0.1.16\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce\"\n-dependencies = [\n- \"cfg-if\",\n- \"libc\",\n- \"wasi 0.9.0+wasi-snapshot-preview1\",\n-]\n-\n [[package]]\n name = \"getrandom\"\n version = \"0.2.8\"\n@@ -1769,7 +1758,7 @@ dependencies = [\n  \"cfg-if\",\n  \"js-sys\",\n  \"libc\",\n- \"wasi 0.11.0+wasi-snapshot-preview1\",\n+ \"wasi\",\n  \"wasm-bindgen\",\n ]\n \n@@ -1840,7 +1829,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5dfbfb3a6cfbd390d5c9564ab283a0349b9b9fcd46a706c1eb10e0db70bfbac7\"\n dependencies = [\n  \"ff\",\n- \"rand_core 0.6.4\",\n+ \"rand_core\",\n  \"subtle\",\n ]\n \n@@ -2115,7 +2104,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"af1955a75fa080c677d3972822ec4bad316169ab1cfc6c257a942c2265dbe5fe\"\n dependencies = [\n  \"bitmaps\",\n- \"rand_core 0.6.4\",\n+ \"rand_core\",\n  \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n@@ -2660,14 +2649,14 @@ version = \"0.1.0\"\n dependencies = [\n  \"colored\",\n  \"env_logger 0.9.0\",\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n  \"lazy_static\",\n  \"libc\",\n  \"libffi\",\n  \"libloading\",\n  \"log\",\n  \"measureme\",\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n@@ -2970,10 +2959,10 @@ checksum = \"ed20c4c21d893414f42e0cbfebe8a8036b5ae9b0264611fb6504e395eda6ceec\"\n dependencies = [\n  \"ct-codecs\",\n  \"ed25519-compact\",\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n  \"orion\",\n  \"p384\",\n- \"rand_core 0.6.4\",\n+ \"rand_core\",\n  \"regex\",\n  \"serde\",\n  \"serde_json\",\n@@ -3093,7 +3082,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5d5285893bb5eb82e6aaf5d59ee909a06a16737a8970984dd7746ba9283498d6\"\n dependencies = [\n  \"phf_shared\",\n- \"rand 0.8.5\",\n+ \"rand\",\n ]\n \n [[package]]\n@@ -3298,38 +3287,15 @@ dependencies = [\n  \"proc-macro2\",\n ]\n \n-[[package]]\n-name = \"rand\"\n-version = \"0.7.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n-dependencies = [\n- \"getrandom 0.1.16\",\n- \"libc\",\n- \"rand_chacha 0.2.2\",\n- \"rand_core 0.5.1\",\n- \"rand_hc\",\n-]\n-\n [[package]]\n name = \"rand\"\n version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\n dependencies = [\n  \"libc\",\n- \"rand_chacha 0.3.0\",\n- \"rand_core 0.6.4\",\n-]\n-\n-[[package]]\n-name = \"rand_chacha\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402\"\n-dependencies = [\n- \"ppv-lite86\",\n- \"rand_core 0.5.1\",\n+ \"rand_chacha\",\n+ \"rand_core\",\n ]\n \n [[package]]\n@@ -3339,16 +3305,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e12735cf05c9e10bf21534da50a147b924d555dc7a547c42e6bb2d5b6017ae0d\"\n dependencies = [\n  \"ppv-lite86\",\n- \"rand_core 0.6.4\",\n-]\n-\n-[[package]]\n-name = \"rand_core\"\n-version = \"0.5.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n-dependencies = [\n- \"getrandom 0.1.16\",\n+ \"rand_core\",\n ]\n \n [[package]]\n@@ -3357,25 +3314,16 @@ version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\n dependencies = [\n- \"getrandom 0.2.8\",\n-]\n-\n-[[package]]\n-name = \"rand_hc\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\"\n-dependencies = [\n- \"rand_core 0.5.1\",\n+ \"getrandom\",\n ]\n \n [[package]]\n name = \"rand_xorshift\"\n-version = \"0.2.0\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"77d416b86801d23dde1aa643023b775c3a462efc0ed96443add11546cdf1dca8\"\n+checksum = \"d25bf25ec5ae4a3f1b92f929810509a2f53d7dca2f50b794ff57e3face536c8f\"\n dependencies = [\n- \"rand_core 0.5.1\",\n+ \"rand_core\",\n ]\n \n [[package]]\n@@ -3384,7 +3332,7 @@ version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6f97cdb2a36ed4183de61b2f824cc45c9f1037f28afe0a322e9fff4c108b5aaa\"\n dependencies = [\n- \"rand_core 0.6.4\",\n+ \"rand_core\",\n ]\n \n [[package]]\n@@ -3426,7 +3374,7 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64\"\n dependencies = [\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n  \"redox_syscall\",\n ]\n \n@@ -3640,10 +3588,10 @@ version = \"1.0.0\"\n dependencies = [\n  \"bstr 0.2.17\",\n  \"clap 3.2.20\",\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n  \"libc\",\n  \"libz-sys\",\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"regex\",\n  \"serde_json\",\n  \"syn\",\n@@ -3656,7 +3604,7 @@ name = \"rustc_abi\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"rand_xoshiro\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n@@ -4162,7 +4110,7 @@ dependencies = [\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -5185,7 +5133,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"74233d3b3b2f6d4b006dc19dee745e73e2a6bfb6f93607cd3b02bd5b00797d7c\"\n dependencies = [\n  \"digest\",\n- \"rand_core 0.6.4\",\n+ \"rand_core\",\n ]\n \n [[package]]\n@@ -5345,11 +5293,12 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.7.3\",\n+ \"rand\",\n+ \"rand_xorshift\",\n  \"rustc-demangle\",\n  \"std_detect\",\n  \"unwind\",\n- \"wasi 0.11.0+wasi-snapshot-preview1\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -5821,7 +5770,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675\"\n dependencies = [\n  \"cfg-if\",\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"static_assertions\",\n ]\n \n@@ -6104,7 +6053,7 @@ version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bc5cf98d8186244414c848017f0e2676b3fcb46807f6668a97dfe67359a3c4b7\"\n dependencies = [\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n ]\n \n [[package]]\n@@ -6145,12 +6094,6 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n-[[package]]\n-name = \"wasi\"\n-version = \"0.9.0+wasi-snapshot-preview1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\"\n-\n [[package]]\n name = \"wasi\"\n version = \"0.11.0+wasi-snapshot-preview1\""}, {"sha": "95c07abf73106647bc3a6c3f3909caff11cce0ed", "filename": "library/alloc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2FCargo.toml?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -13,8 +13,8 @@ core = { path = \"../core\" }\n compiler_builtins = { version = \"0.1.40\", features = ['rustc-dep-of-std'] }\n \n [dev-dependencies]\n-rand = \"0.7\"\n-rand_xorshift = \"0.2\"\n+rand = { version = \"0.8.5\", default-features = false, features = [\"alloc\"] }\n+rand_xorshift = \"0.3.0\"\n \n [[test]]\n name = \"collectionstests\""}, {"sha": "b62be9d39a1cd393a330deb7f3df688f6137d120", "filename": "library/alloc/benches/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fslice.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -1,6 +1,6 @@\n use std::{mem, ptr};\n \n-use rand::distributions::{Alphanumeric, Standard};\n+use rand::distributions::{Alphanumeric, DistString, Standard};\n use rand::Rng;\n use test::{black_box, Bencher};\n \n@@ -218,7 +218,7 @@ fn gen_strings(len: usize) -> Vec<String> {\n     let mut v = vec![];\n     for _ in 0..len {\n         let n = rng.gen::<usize>() % 20 + 1;\n-        v.push((&mut rng).sample_iter(&Alphanumeric).take(n).collect());\n+        v.push(Alphanumeric.sample_string(&mut rng, n));\n     }\n     v\n }"}, {"sha": "59c516374c0e2790d6c2357b6ed1566afa7c2344", "filename": "library/alloc/src/collections/binary_heap/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -465,7 +465,7 @@ fn test_retain() {\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn panic_safe() {\n-    use rand::{seq::SliceRandom, thread_rng};\n+    use rand::seq::SliceRandom;\n     use std::cmp;\n     use std::panic::{self, AssertUnwindSafe};\n     use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -490,7 +490,7 @@ fn panic_safe() {\n             self.0.partial_cmp(&other.0)\n         }\n     }\n-    let mut rng = thread_rng();\n+    let mut rng = crate::test_helpers::test_rng();\n     const DATASZ: usize = 32;\n     // Miri is too slow\n     let ntest = if cfg!(miri) { 1 } else { 10 };"}, {"sha": "04594d55b6abf1834eea51ac3f19ee0e2039a123", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -5,7 +5,7 @@ use crate::vec::Vec;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::thread;\n \n-use rand::{thread_rng, RngCore};\n+use rand::RngCore;\n \n #[test]\n fn test_basic() {\n@@ -481,12 +481,12 @@ fn test_split_off_2() {\n     }\n }\n \n-fn fuzz_test(sz: i32) {\n+fn fuzz_test(sz: i32, rng: &mut impl RngCore) {\n     let mut m: LinkedList<_> = LinkedList::new();\n     let mut v = vec![];\n     for i in 0..sz {\n         check_links(&m);\n-        let r: u8 = thread_rng().next_u32() as u8;\n+        let r: u8 = rng.next_u32() as u8;\n         match r % 6 {\n             0 => {\n                 m.pop_back();\n@@ -521,11 +521,12 @@ fn fuzz_test(sz: i32) {\n \n #[test]\n fn test_fuzz() {\n+    let mut rng = crate::test_helpers::test_rng();\n     for _ in 0..25 {\n-        fuzz_test(3);\n-        fuzz_test(16);\n+        fuzz_test(3, &mut rng);\n+        fuzz_test(16, &mut rng);\n         #[cfg(not(miri))] // Miri is too slow\n-        fuzz_test(189);\n+        fuzz_test(189, &mut rng);\n     }\n }\n "}, {"sha": "4e812529c2cc846d7934672a05202a0eb9db7218", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -192,6 +192,7 @@\n #![feature(unsized_fn_params)]\n #![feature(c_unwind)]\n #![feature(with_negative_coherence)]\n+#![cfg_attr(test, feature(panic_update_hook))]\n //\n // Rustdoc features:\n #![feature(doc_cfg)]\n@@ -255,3 +256,20 @@ pub mod vec;\n pub mod __export {\n     pub use core::format_args;\n }\n+\n+#[cfg(test)]\n+#[allow(dead_code)] // Not used in all configurations\n+pub(crate) mod test_helpers {\n+    /// Copied from `std::test_helpers::test_rng`, since these tests rely on the\n+    /// seed not being the same for every RNG invocation too.\n+    pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n+        use std::hash::{BuildHasher, Hash, Hasher};\n+        let mut hasher = std::collections::hash_map::RandomState::new().build_hasher();\n+        std::panic::Location::caller().hash(&mut hasher);\n+        let hc64 = hasher.finish();\n+        let seed_vec =\n+            hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<crate::vec::Vec<u8>>();\n+        let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n+        rand::SeedableRng::from_seed(seed)\n+    }\n+}"}, {"sha": "e9886fc5717990ec4a93feafa5901aa4235ca9fd", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -28,6 +28,9 @@ use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[unstable(feature = \"slice_range\", issue = \"76393\")]\n pub use core::slice::range;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]"}, {"sha": "f674530aaa54c1934518243a1726ac0fd794598b", "filename": "library/alloc/src/slice/tests.rs", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Fslice%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Fsrc%2Fslice%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice%2Ftests.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -0,0 +1,359 @@\n+use crate::borrow::ToOwned;\n+use crate::rc::Rc;\n+use crate::string::ToString;\n+use crate::test_helpers::test_rng;\n+use crate::vec::Vec;\n+\n+use core::cell::Cell;\n+use core::cmp::Ordering::{self, Equal, Greater, Less};\n+use core::convert::identity;\n+use core::fmt;\n+use core::mem;\n+use core::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n+use rand::{distributions::Standard, prelude::*, Rng, RngCore};\n+use std::panic;\n+\n+macro_rules! do_test {\n+    ($input:ident, $func:ident) => {\n+        let len = $input.len();\n+\n+        // Work out the total number of comparisons required to sort\n+        // this array...\n+        let mut count = 0usize;\n+        $input.to_owned().$func(|a, b| {\n+            count += 1;\n+            a.cmp(b)\n+        });\n+\n+        // ... and then panic on each and every single one.\n+        for panic_countdown in 0..count {\n+            // Refresh the counters.\n+            VERSIONS.store(0, Relaxed);\n+            for i in 0..len {\n+                DROP_COUNTS[i].store(0, Relaxed);\n+            }\n+\n+            let v = $input.to_owned();\n+            let _ = std::panic::catch_unwind(move || {\n+                let mut v = v;\n+                let mut panic_countdown = panic_countdown;\n+                v.$func(|a, b| {\n+                    if panic_countdown == 0 {\n+                        SILENCE_PANIC.with(|s| s.set(true));\n+                        panic!();\n+                    }\n+                    panic_countdown -= 1;\n+                    a.cmp(b)\n+                })\n+            });\n+\n+            // Check that the number of things dropped is exactly\n+            // what we expect (i.e., the contents of `v`).\n+            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+                let count = c.load(Relaxed);\n+                assert!(count == 1, \"found drop count == {} for i == {}, len == {}\", count, i, len);\n+            }\n+\n+            // Check that the most recent versions of values were dropped.\n+            assert_eq!(VERSIONS.load(Relaxed), 0);\n+        }\n+    };\n+}\n+\n+const MAX_LEN: usize = 80;\n+\n+static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n+    // FIXME(RFC 1109): AtomicUsize is not Copy.\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+];\n+\n+static VERSIONS: AtomicUsize = AtomicUsize::new(0);\n+\n+#[derive(Clone, Eq)]\n+struct DropCounter {\n+    x: u32,\n+    id: usize,\n+    version: Cell<usize>,\n+}\n+\n+impl PartialEq for DropCounter {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl PartialOrd for DropCounter {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.version.set(self.version.get() + 1);\n+        other.version.set(other.version.get() + 1);\n+        VERSIONS.fetch_add(2, Relaxed);\n+        self.x.partial_cmp(&other.x)\n+    }\n+}\n+\n+impl Ord for DropCounter {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n+}\n+\n+impl Drop for DropCounter {\n+    fn drop(&mut self) {\n+        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n+        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n+    }\n+}\n+\n+std::thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n+fn panic_safe() {\n+    panic::update_hook(move |prev, info| {\n+        if !SILENCE_PANIC.with(|s| s.get()) {\n+            prev(info);\n+        }\n+    });\n+\n+    let mut rng = test_rng();\n+\n+    // Miri is too slow (but still need to `chain` to make the types match)\n+    let lens = if cfg!(miri) { (1..10).chain(0..0) } else { (1..20).chain(70..MAX_LEN) };\n+    let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n+\n+    for len in lens {\n+        for &modulus in moduli {\n+            for &has_runs in &[false, true] {\n+                let mut input = (0..len)\n+                    .map(|id| DropCounter {\n+                        x: rng.next_u32() % modulus,\n+                        id: id,\n+                        version: Cell::new(0),\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if has_runs {\n+                    for c in &mut input {\n+                        c.x = c.id as u32;\n+                    }\n+\n+                    for _ in 0..5 {\n+                        let a = rng.gen::<usize>() % len;\n+                        let b = rng.gen::<usize>() % len;\n+                        if a < b {\n+                            input[a..b].reverse();\n+                        } else {\n+                            input.swap(a, b);\n+                        }\n+                    }\n+                }\n+\n+                do_test!(input, sort_by);\n+                do_test!(input, sort_unstable_by);\n+            }\n+        }\n+    }\n+\n+    // Set default panic hook again.\n+    drop(panic::take_hook());\n+}\n+\n+#[test]\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n+fn test_sort() {\n+    let mut rng = test_rng();\n+\n+    for len in (2..25).chain(500..510) {\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..10 {\n+                let orig: Vec<_> = (&mut rng)\n+                    .sample_iter::<i32, _>(&Standard)\n+                    .map(|x| x % modulus)\n+                    .take(len)\n+                    .collect();\n+\n+                // Sort in default order.\n+                let mut v = orig.clone();\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| a.cmp(b));\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| b.cmp(a));\n+                assert!(v.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Sort in lexicographic order.\n+                let mut v1 = orig.clone();\n+                let mut v2 = orig.clone();\n+                v1.sort_by_key(|x| x.to_string());\n+                v2.sort_by_cached_key(|x| x.to_string());\n+                assert!(v1.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n+                assert!(v1 == v2);\n+\n+                // Sort with many pre-sorted runs.\n+                let mut v = orig.clone();\n+                v.sort();\n+                v.reverse();\n+                for _ in 0..5 {\n+                    let a = rng.gen::<usize>() % len;\n+                    let b = rng.gen::<usize>() % len;\n+                    if a < b {\n+                        v[a..b].reverse();\n+                    } else {\n+                        v.swap(a, b);\n+                    }\n+                }\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+            }\n+        }\n+    }\n+\n+    // Sort using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    let mut v = [0; 500];\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+    v.sort_by(|_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n+    v.sort();\n+    for i in 0..v.len() {\n+        assert_eq!(v[i], i as i32);\n+    }\n+\n+    // Should not panic.\n+    [0i32; 0].sort();\n+    [(); 10].sort();\n+    [(); 100].sort();\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.sort();\n+    assert!(v == [0xDEADBEEF]);\n+}\n+\n+#[test]\n+fn test_sort_stability() {\n+    // Miri is too slow\n+    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n+    let rounds = if cfg!(miri) { 1 } else { 10 };\n+\n+    let mut rng = test_rng();\n+    for len in (2..25).chain(large_range) {\n+        for _ in 0..rounds {\n+            let mut counts = [0; 10];\n+\n+            // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n+            // where the first item of each tuple is random, but\n+            // the second item represents which occurrence of that\n+            // number this element is, i.e., the second elements\n+            // will occur in sorted order.\n+            let orig: Vec<_> = (0..len)\n+                .map(|_| {\n+                    let n = rng.gen::<usize>() % 10;\n+                    counts[n] += 1;\n+                    (n, counts[n])\n+                })\n+                .collect();\n+\n+            let mut v = orig.clone();\n+            // Only sort on the first element, so an unstable sort\n+            // may mix up the counts.\n+            v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n+\n+            // This comparison includes the count (the second item\n+            // of the tuple), so elements with equal first items\n+            // will need to be ordered with increasing\n+            // counts... i.e., exactly asserting that this sort is\n+            // stable.\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+            let mut v = orig.clone();\n+            v.sort_by_cached_key(|&(x, _)| x);\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+        }\n+    }\n+}"}, {"sha": "0693beb48c402130a58f7ce54c18291d660bde0f", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 1, "deletions": 348, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -1,15 +1,9 @@\n-use std::cell::Cell;\n-use std::cmp::Ordering::{self, Equal, Greater, Less};\n+use std::cmp::Ordering::{Equal, Greater, Less};\n use std::convert::identity;\n use std::fmt;\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n-use std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n-\n-use rand::distributions::Standard;\n-use rand::seq::SliceRandom;\n-use rand::{thread_rng, Rng, RngCore};\n \n fn square(n: usize) -> usize {\n     n * n\n@@ -388,123 +382,6 @@ fn test_reverse() {\n     assert_eq!(v, (-50..51i16).rev().collect::<Vec<_>>());\n }\n \n-#[test]\n-#[cfg_attr(miri, ignore)] // Miri is too slow\n-fn test_sort() {\n-    let mut rng = thread_rng();\n-\n-    for len in (2..25).chain(500..510) {\n-        for &modulus in &[5, 10, 100, 1000] {\n-            for _ in 0..10 {\n-                let orig: Vec<_> =\n-                    rng.sample_iter::<i32, _>(&Standard).map(|x| x % modulus).take(len).collect();\n-\n-                // Sort in default order.\n-                let mut v = orig.clone();\n-                v.sort();\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in ascending order.\n-                let mut v = orig.clone();\n-                v.sort_by(|a, b| a.cmp(b));\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in descending order.\n-                let mut v = orig.clone();\n-                v.sort_by(|a, b| b.cmp(a));\n-                assert!(v.windows(2).all(|w| w[0] >= w[1]));\n-\n-                // Sort in lexicographic order.\n-                let mut v1 = orig.clone();\n-                let mut v2 = orig.clone();\n-                v1.sort_by_key(|x| x.to_string());\n-                v2.sort_by_cached_key(|x| x.to_string());\n-                assert!(v1.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n-                assert!(v1 == v2);\n-\n-                // Sort with many pre-sorted runs.\n-                let mut v = orig.clone();\n-                v.sort();\n-                v.reverse();\n-                for _ in 0..5 {\n-                    let a = rng.gen::<usize>() % len;\n-                    let b = rng.gen::<usize>() % len;\n-                    if a < b {\n-                        v[a..b].reverse();\n-                    } else {\n-                        v.swap(a, b);\n-                    }\n-                }\n-                v.sort();\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-            }\n-        }\n-    }\n-\n-    // Sort using a completely random comparison function.\n-    // This will reorder the elements *somehow*, but won't panic.\n-    let mut v = [0; 500];\n-    for i in 0..v.len() {\n-        v[i] = i as i32;\n-    }\n-    v.sort_by(|_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n-    v.sort();\n-    for i in 0..v.len() {\n-        assert_eq!(v[i], i as i32);\n-    }\n-\n-    // Should not panic.\n-    [0i32; 0].sort();\n-    [(); 10].sort();\n-    [(); 100].sort();\n-\n-    let mut v = [0xDEADBEEFu64];\n-    v.sort();\n-    assert!(v == [0xDEADBEEF]);\n-}\n-\n-#[test]\n-fn test_sort_stability() {\n-    // Miri is too slow\n-    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n-    let rounds = if cfg!(miri) { 1 } else { 10 };\n-\n-    for len in (2..25).chain(large_range) {\n-        for _ in 0..rounds {\n-            let mut counts = [0; 10];\n-\n-            // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n-            // where the first item of each tuple is random, but\n-            // the second item represents which occurrence of that\n-            // number this element is, i.e., the second elements\n-            // will occur in sorted order.\n-            let orig: Vec<_> = (0..len)\n-                .map(|_| {\n-                    let n = thread_rng().gen::<usize>() % 10;\n-                    counts[n] += 1;\n-                    (n, counts[n])\n-                })\n-                .collect();\n-\n-            let mut v = orig.clone();\n-            // Only sort on the first element, so an unstable sort\n-            // may mix up the counts.\n-            v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n-\n-            // This comparison includes the count (the second item\n-            // of the tuple), so elements with equal first items\n-            // will need to be ordered with increasing\n-            // counts... i.e., exactly asserting that this sort is\n-            // stable.\n-            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-            let mut v = orig.clone();\n-            v.sort_by_cached_key(|&(x, _)| x);\n-            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-        }\n-    }\n-}\n-\n #[test]\n fn test_rotate_left() {\n     let expected: Vec<_> = (0..13).collect();\n@@ -1608,230 +1485,6 @@ fn test_copy_from_slice_dst_shorter() {\n     dst.copy_from_slice(&src);\n }\n \n-const MAX_LEN: usize = 80;\n-\n-static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n-    // FIXME(RFC 1109): AtomicUsize is not Copy.\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-];\n-\n-static VERSIONS: AtomicUsize = AtomicUsize::new(0);\n-\n-#[derive(Clone, Eq)]\n-struct DropCounter {\n-    x: u32,\n-    id: usize,\n-    version: Cell<usize>,\n-}\n-\n-impl PartialEq for DropCounter {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other) == Some(Ordering::Equal)\n-    }\n-}\n-\n-impl PartialOrd for DropCounter {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.version.set(self.version.get() + 1);\n-        other.version.set(other.version.get() + 1);\n-        VERSIONS.fetch_add(2, Relaxed);\n-        self.x.partial_cmp(&other.x)\n-    }\n-}\n-\n-impl Ord for DropCounter {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other).unwrap()\n-    }\n-}\n-\n-impl Drop for DropCounter {\n-    fn drop(&mut self) {\n-        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n-        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n-    }\n-}\n-\n-macro_rules! test {\n-    ($input:ident, $func:ident) => {\n-        let len = $input.len();\n-\n-        // Work out the total number of comparisons required to sort\n-        // this array...\n-        let mut count = 0usize;\n-        $input.to_owned().$func(|a, b| {\n-            count += 1;\n-            a.cmp(b)\n-        });\n-\n-        // ... and then panic on each and every single one.\n-        for panic_countdown in 0..count {\n-            // Refresh the counters.\n-            VERSIONS.store(0, Relaxed);\n-            for i in 0..len {\n-                DROP_COUNTS[i].store(0, Relaxed);\n-            }\n-\n-            let v = $input.to_owned();\n-            let _ = std::panic::catch_unwind(move || {\n-                let mut v = v;\n-                let mut panic_countdown = panic_countdown;\n-                v.$func(|a, b| {\n-                    if panic_countdown == 0 {\n-                        SILENCE_PANIC.with(|s| s.set(true));\n-                        panic!();\n-                    }\n-                    panic_countdown -= 1;\n-                    a.cmp(b)\n-                })\n-            });\n-\n-            // Check that the number of things dropped is exactly\n-            // what we expect (i.e., the contents of `v`).\n-            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n-                let count = c.load(Relaxed);\n-                assert!(count == 1, \"found drop count == {} for i == {}, len == {}\", count, i, len);\n-            }\n-\n-            // Check that the most recent versions of values were dropped.\n-            assert_eq!(VERSIONS.load(Relaxed), 0);\n-        }\n-    };\n-}\n-\n-thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n-\n-#[test]\n-#[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n-fn panic_safe() {\n-    panic::update_hook(move |prev, info| {\n-        if !SILENCE_PANIC.with(|s| s.get()) {\n-            prev(info);\n-        }\n-    });\n-\n-    let mut rng = thread_rng();\n-\n-    // Miri is too slow (but still need to `chain` to make the types match)\n-    let lens = if cfg!(miri) { (1..10).chain(0..0) } else { (1..20).chain(70..MAX_LEN) };\n-    let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n-\n-    for len in lens {\n-        for &modulus in moduli {\n-            for &has_runs in &[false, true] {\n-                let mut input = (0..len)\n-                    .map(|id| DropCounter {\n-                        x: rng.next_u32() % modulus,\n-                        id: id,\n-                        version: Cell::new(0),\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                if has_runs {\n-                    for c in &mut input {\n-                        c.x = c.id as u32;\n-                    }\n-\n-                    for _ in 0..5 {\n-                        let a = rng.gen::<usize>() % len;\n-                        let b = rng.gen::<usize>() % len;\n-                        if a < b {\n-                            input[a..b].reverse();\n-                        } else {\n-                            input.swap(a, b);\n-                        }\n-                    }\n-                }\n-\n-                test!(input, sort_by);\n-                test!(input, sort_unstable_by);\n-            }\n-        }\n-    }\n-\n-    // Set default panic hook again.\n-    drop(panic::take_hook());\n-}\n-\n #[test]\n fn repeat_generic_slice() {\n     assert_eq!([1, 2].repeat(2), vec![1, 2, 1, 2]);"}, {"sha": "3dc8c84e0bfde0837d4623c05fdd33e604c5a308", "filename": "library/core/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2FCargo.toml?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -24,8 +24,8 @@ path = \"benches/lib.rs\"\n test = true\n \n [dev-dependencies]\n-rand = \"0.7\"\n-rand_xorshift = \"0.2\"\n+rand = { version = \"0.8.5\", default-features = false }\n+rand_xorshift = { version = \"0.3.0\", default-features = false }\n \n [features]\n # Make panics and failed asserts immediately abort without formatting any message"}, {"sha": "bb61224b5baadc15acdeb163d084657009b9726f", "filename": "library/core/benches/num/int_log/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -21,7 +21,7 @@ macro_rules! int_log_bench {\n             /* Exponentially distributed random numbers from the whole range of the type.  */\n             let numbers: Vec<$t> = (0..256)\n                 .map(|_| {\n-                    let x = rng.gen::<$t>() >> rng.gen_range(0, <$t>::BITS);\n+                    let x = rng.gen::<$t>() >> rng.gen_range(0..<$t>::BITS);\n                     if x != 0 { x } else { 1 }\n                 })\n                 .collect();\n@@ -38,7 +38,7 @@ macro_rules! int_log_bench {\n             /* Exponentially distributed random numbers from the range 0..256.  */\n             let numbers: Vec<$t> = (0..256)\n                 .map(|_| {\n-                    let x = (rng.gen::<u8>() >> rng.gen_range(0, u8::BITS)) as $t;\n+                    let x = (rng.gen::<u8>() >> rng.gen_range(0..u8::BITS)) as $t;\n                     if x != 0 { x } else { 1 }\n                 })\n                 .collect();"}, {"sha": "c910cb65c55def0f32dc6c9fb7294965d79b2d54", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -155,3 +155,16 @@ mod time;\n mod tuple;\n mod unicode;\n mod waker;\n+\n+/// Copied from `std::test_helpers::test_rng`, see that function for rationale.\n+#[track_caller]\n+#[allow(dead_code)] // Not used in all configurations.\n+pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n+    use core::hash::{BuildHasher, Hash, Hasher};\n+    let mut hasher = std::collections::hash_map::RandomState::new().build_hasher();\n+    core::panic::Location::caller().hash(&mut hasher);\n+    let hc64 = hasher.finish();\n+    let seed_vec = hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<Vec<u8>>();\n+    let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n+    rand::SeedableRng::from_seed(seed)\n+}"}, {"sha": "0084c1c814e2d6470faae5b04090525c741aa38e", "filename": "library/core/tests/num/flt2dec/random.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -9,8 +9,6 @@ use core::num::flt2dec::MAX_SIG_DIGITS;\n use core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\n \n use rand::distributions::{Distribution, Uniform};\n-use rand::rngs::StdRng;\n-use rand::SeedableRng;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n@@ -92,7 +90,7 @@ where\n     if cfg!(target_os = \"emscripten\") {\n         return; // using rng pulls in i128 support, which doesn't work\n     }\n-    let mut rng = StdRng::from_entropy();\n+    let mut rng = crate::test_rng();\n     let f32_range = Uniform::new(0x0000_0001u32, 0x7f80_0000);\n     iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n         let x = f32::from_bits(f32_range.sample(&mut rng));\n@@ -108,7 +106,7 @@ where\n     if cfg!(target_os = \"emscripten\") {\n         return; // using rng pulls in i128 support, which doesn't work\n     }\n-    let mut rng = StdRng::from_entropy();\n+    let mut rng = crate::test_rng();\n     let f64_range = Uniform::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n     iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n         let x = f64::from_bits(f64_range.sample(&mut rng));"}, {"sha": "fd35d96c3fef814bd7952fb8b13afbcd7f31354f", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -1805,15 +1805,15 @@ fn brute_force_rotate_test_1() {\n fn sort_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use core::slice::heapsort;\n-    use rand::{rngs::StdRng, seq::SliceRandom, Rng, SeedableRng};\n+    use rand::{seq::SliceRandom, Rng};\n \n     // Miri is too slow (but still need to `chain` to make the types match)\n     let lens = if cfg!(miri) { (2..20).chain(0..0) } else { (2..25).chain(500..510) };\n     let rounds = if cfg!(miri) { 1 } else { 100 };\n \n     let mut v = [0; 600];\n     let mut tmp = [0; 600];\n-    let mut rng = StdRng::from_entropy();\n+    let mut rng = crate::test_rng();\n \n     for len in lens {\n         let v = &mut v[0..len];\n@@ -1879,11 +1879,10 @@ fn sort_unstable() {\n #[cfg_attr(miri, ignore)] // Miri is too slow\n fn select_nth_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n-    use rand::rngs::StdRng;\n     use rand::seq::SliceRandom;\n-    use rand::{Rng, SeedableRng};\n+    use rand::Rng;\n \n-    let mut rng = StdRng::from_entropy();\n+    let mut rng = crate::test_rng();\n \n     for len in (2..21).chain(500..501) {\n         let mut orig = vec![0; len];"}, {"sha": "adf521d9b94a124544268303b51f52e8e5ef2c05", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -33,7 +33,8 @@ default-features = false\n features = ['read_core', 'elf', 'macho', 'pe', 'unaligned', 'archive']\n \n [dev-dependencies]\n-rand = \"0.7\"\n+rand = { version = \"0.8.5\", default-features = false, features = [\"alloc\"] }\n+rand_xorshift = \"0.3.0\"\n \n [target.'cfg(any(all(target_family = \"wasm\", not(target_os = \"emscripten\")), all(target_vendor = \"fortanix\", target_env = \"sgx\")))'.dependencies]\n dlmalloc = { version = \"0.2.3\", features = ['rustc-dep-of-std'] }"}, {"sha": "6b89518e2e26cd69bdb606b44dfc38815c09cab3", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -3,7 +3,8 @@ use super::HashMap;\n use super::RandomState;\n use crate::assert_matches::assert_matches;\n use crate::cell::RefCell;\n-use rand::{thread_rng, Rng};\n+use crate::test_helpers::test_rng;\n+use rand::Rng;\n use realstd::collections::TryReserveErrorKind::*;\n \n // https://github.com/rust-lang/rust/issues/62301\n@@ -710,16 +711,16 @@ fn test_entry_take_doesnt_corrupt() {\n     }\n \n     let mut m = HashMap::new();\n-    let mut rng = thread_rng();\n+    let mut rng = test_rng();\n \n     // Populate the map with some items.\n     for _ in 0..50 {\n-        let x = rng.gen_range(-10, 10);\n+        let x = rng.gen_range(-10..10);\n         m.insert(x, ());\n     }\n \n     for _ in 0..1000 {\n-        let x = rng.gen_range(-10, 10);\n+        let x = rng.gen_range(-10..10);\n         match m.entry(x) {\n             Vacant(_) => {}\n             Occupied(e) => {"}, {"sha": "eb582be012bd54d72940ab3c694d99c769e0b236", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -10,7 +10,7 @@ use crate::sys_common::io::test::{tmpdir, TempDir};\n use crate::thread;\n use crate::time::{Duration, Instant};\n \n-use rand::{rngs::StdRng, RngCore, SeedableRng};\n+use rand::RngCore;\n \n #[cfg(unix)]\n use crate::os::unix::fs::symlink as symlink_dir;\n@@ -1181,7 +1181,7 @@ fn _assert_send_sync() {\n #[test]\n fn binary_file() {\n     let mut bytes = [0; 1024];\n-    StdRng::from_entropy().fill_bytes(&mut bytes);\n+    crate::test_helpers::test_rng().fill_bytes(&mut bytes);\n \n     let tmpdir = tmpdir();\n \n@@ -1194,7 +1194,7 @@ fn binary_file() {\n #[test]\n fn write_then_read() {\n     let mut bytes = [0; 1024];\n-    StdRng::from_entropy().fill_bytes(&mut bytes);\n+    crate::test_helpers::test_rng().fill_bytes(&mut bytes);\n \n     let tmpdir = tmpdir();\n "}, {"sha": "a7e13f5b866b53058f0f995f5818e739c47c09de", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -652,3 +652,30 @@ mod sealed {\n     #[unstable(feature = \"sealed\", issue = \"none\")]\n     pub trait Sealed {}\n }\n+\n+#[cfg(test)]\n+#[allow(dead_code)] // Not used in all configurations.\n+pub(crate) mod test_helpers {\n+    /// Test-only replacement for `rand::thread_rng()`, which is unusable for\n+    /// us, as we want to allow running stdlib tests on tier-3 targets which may\n+    /// not have `getrandom` support.\n+    ///\n+    /// Does a bit of a song and dance to ensure that the seed is different on\n+    /// each call (as some tests sadly rely on this), but doesn't try that hard.\n+    ///\n+    /// This is duplicated in the `core`, `alloc` test suites (as well as\n+    /// `std`'s integration tests), but figuring out a mechanism to share these\n+    /// seems far more painful than copy-pasting a 7 line function a couple\n+    /// times, given that even under a perma-unstable feature, I don't think we\n+    /// want to expose types from `rand` from `std`.\n+    #[track_caller]\n+    pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n+        use core::hash::{BuildHasher, Hash, Hasher};\n+        let mut hasher = crate::collections::hash_map::RandomState::new().build_hasher();\n+        core::panic::Location::caller().hash(&mut hasher);\n+        let hc64 = hasher.finish();\n+        let seed_vec = hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<Vec<u8>>();\n+        let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n+        rand::SeedableRng::from_seed(seed)\n+    }\n+}"}, {"sha": "1a9d3d3f12f3cea109c9fa772edbfe128f44afe6", "filename": "library/std/src/sync/rwlock/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -2,7 +2,7 @@ use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sync::mpsc::channel;\n use crate::sync::{Arc, RwLock, RwLockReadGuard, TryLockError};\n use crate::thread;\n-use rand::{self, Rng};\n+use rand::Rng;\n \n #[derive(Eq, PartialEq, Debug)]\n struct NonCopy(i32);\n@@ -28,7 +28,7 @@ fn frob() {\n         let tx = tx.clone();\n         let r = r.clone();\n         thread::spawn(move || {\n-            let mut rng = rand::thread_rng();\n+            let mut rng = crate::test_helpers::test_rng();\n             for _ in 0..M {\n                 if rng.gen_bool(1.0 / (N as f64)) {\n                     drop(r.write().unwrap());"}, {"sha": "4a42ff3c618ce4c744cb2d9f479ea86926faffa8", "filename": "library/std/src/sys_common/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -39,9 +39,10 @@ pub mod test {\n         }\n     }\n \n+    #[track_caller] // for `test_rng`\n     pub fn tmpdir() -> TempDir {\n         let p = env::temp_dir();\n-        let mut r = rand::thread_rng();\n+        let mut r = crate::test_helpers::test_rng();\n         let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n         fs::create_dir(&ret).unwrap();\n         TempDir(ret)"}, {"sha": "aae2c49d8982e8a10de8ca331b26b6df9d3381bf", "filename": "library/std/tests/env.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Ftests%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/library%2Fstd%2Ftests%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Fenv.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -1,12 +1,24 @@\n use std::env::*;\n use std::ffi::{OsStr, OsString};\n \n-use rand::distributions::Alphanumeric;\n-use rand::{thread_rng, Rng};\n+use rand::distributions::{Alphanumeric, DistString};\n+\n+/// Copied from `std::test_helpers::test_rng`, since these tests rely on the\n+/// seed not being the same for every RNG invocation too.\n+#[track_caller]\n+pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n+    use core::hash::{BuildHasher, Hash, Hasher};\n+    let mut hasher = std::collections::hash_map::RandomState::new().build_hasher();\n+    core::panic::Location::caller().hash(&mut hasher);\n+    let hc64 = hasher.finish();\n+    let seed_vec = hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<Vec<u8>>();\n+    let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n+    rand::SeedableRng::from_seed(seed)\n+}\n \n+#[track_caller]\n fn make_rand_name() -> OsString {\n-    let rng = thread_rng();\n-    let n = format!(\"TEST{}\", rng.sample_iter(&Alphanumeric).take(10).collect::<String>());\n+    let n = format!(\"TEST{}\", Alphanumeric.sample_string(&mut test_rng(), 10));\n     let n = OsString::from(n);\n     assert!(var_os(&n).is_none());\n     n"}, {"sha": "29501d2d3b6be975e94faa0b46e06beacc1426f4", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2afe58571e53d48a1fc2354271abe5aff60c5c44/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afe58571e53d48a1fc2354271abe5aff60c5c44/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=2afe58571e53d48a1fc2354271abe5aff60c5c44", "patch": "@@ -195,7 +195,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"rand\",\n     \"rand_chacha\",\n     \"rand_core\",\n-    \"rand_hc\",\n     \"rand_xorshift\",\n     \"rand_xoshiro\",\n     \"redox_syscall\","}]}