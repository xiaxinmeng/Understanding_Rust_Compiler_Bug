{"sha": "33b55ac39fa633d0983fad014469e1036669bf28", "node_id": "C_kwDOAAsO6NoAKDMzYjU1YWMzOWZhNjMzZDA5ODNmYWQwMTQ0NjllMTAzNjY2OWJmMjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T03:08:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T03:08:59Z"}, "message": "Auto merge of #102233 - petrochenkov:effvis, r=jackh726\n\nprivacy: Rename \"accessibility levels\" to \"effective visibilities\"\n\nAnd a couple of other naming and comment tweaks.\n\nRelated to https://github.com/rust-lang/rust/issues/48054\n\nFor `enum Level` I initially used naming `enum EffectiveVisibilityLevel`, but it was too long and inconvenient because it's used pretty often.\nSo I shortened it to just `Level`, if it needs to be used from some context where this name would be ambiguous, then it can be imported with renaming like `use rustc_middle::privacy::Level as EffVisLevel` or something.", "tree": {"sha": "1645341a632d6db197536be4d35d5edc0ebe5903", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1645341a632d6db197536be4d35d5edc0ebe5903"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33b55ac39fa633d0983fad014469e1036669bf28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33b55ac39fa633d0983fad014469e1036669bf28", "html_url": "https://github.com/rust-lang/rust/commit/33b55ac39fa633d0983fad014469e1036669bf28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33b55ac39fa633d0983fad014469e1036669bf28/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7174231ae66aa3e938cbe0b84e23e79d867fec20", "url": "https://api.github.com/repos/rust-lang/rust/commits/7174231ae66aa3e938cbe0b84e23e79d867fec20", "html_url": "https://github.com/rust-lang/rust/commit/7174231ae66aa3e938cbe0b84e23e79d867fec20"}, {"sha": "34eb73c72d7e40d61ca2efa0dd1fedc89e21f0b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/34eb73c72d7e40d61ca2efa0dd1fedc89e21f0b8", "html_url": "https://github.com/rust-lang/rust/commit/34eb73c72d7e40d61ca2efa0dd1fedc89e21f0b8"}], "stats": {"total": 1040, "additions": 524, "deletions": 516}, "files": [{"sha": "7f1d21bf1d8b0cdebacd4fb2dc8b1ab73776d69d", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -927,7 +927,7 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n     sess.time(\"misc_checking_3\", || {\n         parallel!(\n             {\n-                tcx.ensure().privacy_access_levels(());\n+                tcx.ensure().effective_visibilities(());\n \n                 parallel!(\n                     {"}, {"sha": "fa20e34f9ca2ac2d94819fb597eddafee96e38cd", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -563,7 +563,7 @@ impl MissingDoc {\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a `NodeId`).\n         if def_id != CRATE_DEF_ID {\n-            if !cx.access_levels.is_exported(def_id) {\n+            if !cx.effective_visibilities.is_exported(def_id) {\n                 return;\n             }\n         }\n@@ -721,7 +721,7 @@ declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS])\n \n impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_reachable(item.def_id.def_id) {\n             return;\n         }\n         let (def, ty) = match item.kind {\n@@ -814,7 +814,7 @@ impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_reachable(item.def_id.def_id) {\n             return;\n         }\n \n@@ -1385,7 +1385,8 @@ impl UnreachablePub {\n         exportable: bool,\n     ) {\n         let mut applicability = Applicability::MachineApplicable;\n-        if cx.tcx.visibility(def_id).is_public() && !cx.access_levels.is_reachable(def_id) {\n+        if cx.tcx.visibility(def_id).is_public() && !cx.effective_visibilities.is_reachable(def_id)\n+        {\n             if vis_span.from_expansion() {\n                 applicability = Applicability::MaybeIncorrect;\n             }"}, {"sha": "cec0003ffea78b1460f2a999be9a9c1799d6ed0f", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -31,7 +31,7 @@ use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -542,7 +542,7 @@ pub struct LateContext<'tcx> {\n     pub param_env: ty::ParamEnv<'tcx>,\n \n     /// Items accessible from the crate being checked.\n-    pub access_levels: &'tcx AccessLevels,\n+    pub effective_visibilities: &'tcx EffectiveVisibilities,\n \n     /// The store of registered lints and the lint levels.\n     pub lint_store: &'tcx LintStore,"}, {"sha": "303fcb1a1d152349709856e31a4d02d54d0152b9", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -338,14 +338,14 @@ fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n     module_def_id: LocalDefId,\n     pass: T,\n ) {\n-    let access_levels = &tcx.privacy_access_levels(());\n+    let effective_visibilities = &tcx.effective_visibilities(());\n \n     let context = LateContext {\n         tcx,\n         enclosing_body: None,\n         cached_typeck_results: Cell::new(None),\n         param_env: ty::ParamEnv::empty(),\n-        access_levels,\n+        effective_visibilities,\n         lint_store: unerased_lint_store(tcx),\n         last_node_with_lint_attrs: tcx.hir().local_def_id_to_hir_id(module_def_id),\n         generics: None,\n@@ -386,14 +386,14 @@ pub fn late_lint_mod<'tcx, T: LateLintPass<'tcx>>(\n }\n \n fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n-    let access_levels = &tcx.privacy_access_levels(());\n+    let effective_visibilities = &tcx.effective_visibilities(());\n \n     let context = LateContext {\n         tcx,\n         enclosing_body: None,\n         cached_typeck_results: Cell::new(None),\n         param_env: ty::ParamEnv::empty(),\n-        access_levels,\n+        effective_visibilities,\n         lint_store: unerased_lint_store(tcx),\n         last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n         generics: None,"}, {"sha": "5288fc542d79a0b0f200f9bab547da6cbf1fa948", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -212,7 +212,7 @@ macro_rules! late_lint_mod_passes {\n                 TypeLimits: TypeLimits::new(),\n                 NonSnakeCase: NonSnakeCase,\n                 InvalidNoMangleItems: InvalidNoMangleItems,\n-                // Depends on access levels\n+                // Depends on effective visibilities\n                 UnreachablePub: UnreachablePub,\n                 ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n                 InvalidValue: InvalidValue,"}, {"sha": "4e69b42416f502b8b6e3031cb98b450dc449dc3f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -787,9 +787,8 @@ fn should_encode_attr(\n     } else if attr.doc_str().is_some() {\n         // We keep all public doc comments because they might be \"imported\" into downstream crates\n         // if they use `#[doc(inline)]` to copy an item's documentation into their own.\n-        *is_def_id_public.get_or_insert_with(|| {\n-            tcx.privacy_access_levels(()).get_effective_vis(def_id).is_some()\n-        })\n+        *is_def_id_public\n+            .get_or_insert_with(|| tcx.effective_visibilities(()).effective_vis(def_id).is_some())\n     } else if attr.has_name(sym::doc) {\n         // If this is a `doc` attribute, and it's marked `inline` (as in `#[doc(inline)]`), we can\n         // remove it. It won't be inlinable in downstream crates."}, {"sha": "321cdf873c1f2d3f259d74e8bbf6fc8b4ff530ed", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -77,7 +77,7 @@ macro_rules! arena_types {\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Ty<'tcx>>\n                 >,\n             [] all_traits: Vec<rustc_hir::def_id::DefId>,\n-            [] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n+            [] effective_visibilities: rustc_middle::middle::privacy::EffectiveVisibilities,\n             [] foreign_module: rustc_session::cstore::ForeignModule,\n             [] foreign_modules: Vec<rustc_session::cstore::ForeignModule>,\n             [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,"}, {"sha": "9c68c7504754a664e63a6bc324cada2cce139f64", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 79, "deletions": 80, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -9,106 +9,101 @@ use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::{DefId, LocalDefId};\n use std::hash::Hash;\n \n-/// Represents the levels of accessibility an item can have.\n+/// Represents the levels of effective visibility an item can have.\n ///\n-/// The variants are sorted in ascending order of accessibility.\n+/// The variants are sorted in ascending order of directness.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n-pub enum AccessLevel {\n-    /// Superset of `AccessLevel::Reachable` used to mark impl Trait items.\n-    ReachableFromImplTrait,\n-    /// Exported items + items participating in various kinds of public interfaces,\n-    /// but not directly nameable. For example, if function `fn f() -> T {...}` is\n-    /// public, then type `T` is reachable. Its values can be obtained by other crates\n-    /// even if the type itself is not nameable.\n+pub enum Level {\n+    /// Superset of `Reachable` including items leaked through return position `impl Trait`.\n+    ReachableThroughImplTrait,\n+    /// Item is either reexported, or leaked through any kind of interface.\n+    /// For example, if function `fn f() -> T {...}` is directly public, then type `T` is publicly\n+    /// reachable and its values can be obtained by other crates even if the type itself is not\n+    /// nameable.\n     Reachable,\n-    /// Public items + items accessible to other crates with the help of `pub use` re-exports.\n-    Exported,\n-    /// Items accessible to other crates directly, without the help of re-exports.\n-    Public,\n+    /// Item is accessible either directly, or with help of `use` reexports.\n+    Reexported,\n+    /// Item is directly accessible, without help of reexports.\n+    Direct,\n }\n \n-impl AccessLevel {\n-    pub fn all_levels() -> [AccessLevel; 4] {\n-        [\n-            AccessLevel::Public,\n-            AccessLevel::Exported,\n-            AccessLevel::Reachable,\n-            AccessLevel::ReachableFromImplTrait,\n-        ]\n+impl Level {\n+    pub fn all_levels() -> [Level; 4] {\n+        [Level::Direct, Level::Reexported, Level::Reachable, Level::ReachableThroughImplTrait]\n     }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]\n pub struct EffectiveVisibility {\n-    public: Visibility,\n-    exported: Visibility,\n+    direct: Visibility,\n+    reexported: Visibility,\n     reachable: Visibility,\n-    reachable_from_impl_trait: Visibility,\n+    reachable_through_impl_trait: Visibility,\n }\n \n impl EffectiveVisibility {\n-    pub fn get(&self, tag: AccessLevel) -> &Visibility {\n-        match tag {\n-            AccessLevel::Public => &self.public,\n-            AccessLevel::Exported => &self.exported,\n-            AccessLevel::Reachable => &self.reachable,\n-            AccessLevel::ReachableFromImplTrait => &self.reachable_from_impl_trait,\n+    pub fn at_level(&self, level: Level) -> &Visibility {\n+        match level {\n+            Level::Direct => &self.direct,\n+            Level::Reexported => &self.reexported,\n+            Level::Reachable => &self.reachable,\n+            Level::ReachableThroughImplTrait => &self.reachable_through_impl_trait,\n         }\n     }\n \n-    fn get_mut(&mut self, tag: AccessLevel) -> &mut Visibility {\n-        match tag {\n-            AccessLevel::Public => &mut self.public,\n-            AccessLevel::Exported => &mut self.exported,\n-            AccessLevel::Reachable => &mut self.reachable,\n-            AccessLevel::ReachableFromImplTrait => &mut self.reachable_from_impl_trait,\n+    fn at_level_mut(&mut self, level: Level) -> &mut Visibility {\n+        match level {\n+            Level::Direct => &mut self.direct,\n+            Level::Reexported => &mut self.reexported,\n+            Level::Reachable => &mut self.reachable,\n+            Level::ReachableThroughImplTrait => &mut self.reachable_through_impl_trait,\n         }\n     }\n \n-    pub fn is_public_at_level(&self, tag: AccessLevel) -> bool {\n-        self.get(tag).is_public()\n+    pub fn is_public_at_level(&self, level: Level) -> bool {\n+        self.at_level(level).is_public()\n     }\n \n     pub fn from_vis(vis: Visibility) -> EffectiveVisibility {\n         EffectiveVisibility {\n-            public: vis,\n-            exported: vis,\n+            direct: vis,\n+            reexported: vis,\n             reachable: vis,\n-            reachable_from_impl_trait: vis,\n+            reachable_through_impl_trait: vis,\n         }\n     }\n }\n \n-/// Holds a map of accessibility levels for reachable HIR nodes.\n+/// Holds a map of effective visibilities for reachable HIR nodes.\n #[derive(Debug, Clone)]\n-pub struct AccessLevels<Id = LocalDefId> {\n+pub struct EffectiveVisibilities<Id = LocalDefId> {\n     map: FxHashMap<Id, EffectiveVisibility>,\n }\n \n-impl<Id: Hash + Eq + Copy> AccessLevels<Id> {\n-    pub fn is_public_at_level(&self, id: Id, tag: AccessLevel) -> bool {\n-        self.get_effective_vis(id)\n-            .map_or(false, |effective_vis| effective_vis.is_public_at_level(tag))\n+impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n+    pub fn is_public_at_level(&self, id: Id, level: Level) -> bool {\n+        self.effective_vis(id)\n+            .map_or(false, |effective_vis| effective_vis.is_public_at_level(level))\n     }\n \n-    /// See `AccessLevel::Reachable`.\n+    /// See `Level::Reachable`.\n     pub fn is_reachable(&self, id: Id) -> bool {\n-        self.is_public_at_level(id, AccessLevel::Reachable)\n+        self.is_public_at_level(id, Level::Reachable)\n     }\n \n-    /// See `AccessLevel::Exported`.\n+    /// See `Level::Reexported`.\n     pub fn is_exported(&self, id: Id) -> bool {\n-        self.is_public_at_level(id, AccessLevel::Exported)\n+        self.is_public_at_level(id, Level::Reexported)\n     }\n \n-    /// See `AccessLevel::Public`.\n-    pub fn is_public(&self, id: Id) -> bool {\n-        self.is_public_at_level(id, AccessLevel::Public)\n+    /// See `Level::Direct`.\n+    pub fn is_directly_public(&self, id: Id) -> bool {\n+        self.is_public_at_level(id, Level::Direct)\n     }\n \n-    pub fn get_access_level(&self, id: Id) -> Option<AccessLevel> {\n-        self.get_effective_vis(id).and_then(|effective_vis| {\n-            for level in AccessLevel::all_levels() {\n+    pub fn public_at_level(&self, id: Id) -> Option<Level> {\n+        self.effective_vis(id).and_then(|effective_vis| {\n+            for level in Level::all_levels() {\n                 if effective_vis.is_public_at_level(level) {\n                     return Some(level);\n                 }\n@@ -117,38 +112,41 @@ impl<Id: Hash + Eq + Copy> AccessLevels<Id> {\n         })\n     }\n \n-    pub fn get_effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n+    pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n         self.map.get(&id)\n     }\n \n     pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n         self.map.iter()\n     }\n \n-    pub fn map_id<OutId: Hash + Eq + Copy>(&self, f: impl Fn(Id) -> OutId) -> AccessLevels<OutId> {\n-        AccessLevels { map: self.map.iter().map(|(k, v)| (f(*k), *v)).collect() }\n+    pub fn map_id<OutId: Hash + Eq + Copy>(\n+        &self,\n+        f: impl Fn(Id) -> OutId,\n+    ) -> EffectiveVisibilities<OutId> {\n+        EffectiveVisibilities { map: self.map.iter().map(|(k, v)| (f(*k), *v)).collect() }\n     }\n \n-    pub fn set_access_level(\n+    pub fn set_public_at_level(\n         &mut self,\n         id: Id,\n         default_vis: impl FnOnce() -> Visibility,\n-        tag: AccessLevel,\n+        level: Level,\n     ) {\n         let mut effective_vis = self\n-            .get_effective_vis(id)\n+            .effective_vis(id)\n             .copied()\n             .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis()));\n-        for level in AccessLevel::all_levels() {\n-            if level <= tag {\n-                *effective_vis.get_mut(level) = Visibility::Public;\n+        for l in Level::all_levels() {\n+            if l <= level {\n+                *effective_vis.at_level_mut(l) = Visibility::Public;\n             }\n         }\n         self.map.insert(id, effective_vis);\n     }\n }\n \n-impl<Id: Hash + Eq + Copy + Into<DefId>> AccessLevels<Id> {\n+impl<Id: Hash + Eq + Copy + Into<DefId>> EffectiveVisibilities<Id> {\n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n     pub fn update(\n@@ -157,28 +155,29 @@ impl<Id: Hash + Eq + Copy + Into<DefId>> AccessLevels<Id> {\n         nominal_vis: Visibility,\n         default_vis: impl FnOnce() -> Visibility,\n         parent_id: Id,\n-        tag: AccessLevel,\n+        level: Level,\n         tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = self.get_effective_vis(id).copied().unwrap_or_else(|| {\n+        let mut current_effective_vis = self.effective_vis(id).copied().unwrap_or_else(|| {\n             if id.into().is_crate_root() {\n                 EffectiveVisibility::from_vis(Visibility::Public)\n             } else {\n                 EffectiveVisibility::from_vis(default_vis())\n             }\n         });\n-        if let Some(inherited_effective_vis) = self.get_effective_vis(parent_id) {\n-            let mut inherited_effective_vis_at_prev_level = *inherited_effective_vis.get(tag);\n+        if let Some(inherited_effective_vis) = self.effective_vis(parent_id) {\n+            let mut inherited_effective_vis_at_prev_level =\n+                *inherited_effective_vis.at_level(level);\n             let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n-            for level in AccessLevel::all_levels() {\n-                if tag >= level {\n-                    let inherited_effective_vis_at_level = *inherited_effective_vis.get(level);\n-                    let current_effective_vis_at_level = current_effective_vis.get_mut(level);\n+            for l in Level::all_levels() {\n+                if level >= l {\n+                    let inherited_effective_vis_at_level = *inherited_effective_vis.at_level(l);\n+                    let current_effective_vis_at_level = current_effective_vis.at_level_mut(l);\n                     // effective visibility for id shouldn't be recalculated if\n                     // inherited from parent_id effective visibility isn't changed at next level\n                     if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n-                        && tag != level)\n+                        && level != l)\n                     {\n                         calculated_effective_vis =\n                             if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n@@ -205,15 +204,15 @@ impl<Id: Hash + Eq + Copy + Into<DefId>> AccessLevels<Id> {\n     }\n }\n \n-impl<Id> Default for AccessLevels<Id> {\n+impl<Id> Default for EffectiveVisibilities<Id> {\n     fn default() -> Self {\n-        AccessLevels { map: Default::default() }\n+        EffectiveVisibilities { map: Default::default() }\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for AccessLevels {\n+impl<'a> HashStable<StableHashingContext<'a>> for EffectiveVisibilities {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let AccessLevels { ref map } = *self;\n+        let EffectiveVisibilities { ref map } = *self;\n         map.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "de2538f94d05864a8e0f69587d80f0e65b00289f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -1065,10 +1065,10 @@ rustc_queries! {\n         cache_on_disk_if { key.is_local() }\n     }\n \n-    /// Performs part of the privacy check and computes \"access levels\".\n-    query privacy_access_levels(_: ()) -> &'tcx AccessLevels {\n+    /// Performs part of the privacy check and computes effective visibilities.\n+    query effective_visibilities(_: ()) -> &'tcx EffectiveVisibilities {\n         eval_always\n-        desc { \"checking privacy access levels\" }\n+        desc { \"checking effective visibilities\" }\n     }\n     query check_private_in_public(_: ()) -> () {\n         eval_always"}, {"sha": "a42d05706137c898077f6307d86697ee4db8ea4e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -17,7 +17,7 @@ pub use self::IntVarValue::*;\n pub use self::Variance::*;\n use crate::error::{OpaqueHiddenTypeMismatch, TypeMismatchReason};\n use crate::metadata::ModChild;\n-use crate::middle::privacy::AccessLevels;\n+use crate::middle::privacy::EffectiveVisibilities;\n use crate::mir::{Body, GeneratorLayout};\n use crate::traits::{self, Reveal};\n use crate::ty;\n@@ -160,7 +160,7 @@ pub struct ResolverGlobalCtxt {\n     pub expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n     /// Reference span for definitions.\n     pub source_span: IndexVec<LocalDefId, Span>,\n-    pub access_levels: AccessLevels,\n+    pub effective_visibilities: EffectiveVisibilities,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,"}, {"sha": "3e2b4edf716c58e87f70e8af30ee7dae88aa65be", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -5,7 +5,7 @@ use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n-use crate::middle::privacy::AccessLevels;\n+use crate::middle::privacy::EffectiveVisibilities;\n use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;"}, {"sha": "2fb46f47da27a59a14e751269cfa590679269cef", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Node, PatKind, TyKind};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::middle::privacy::AccessLevel;\n+use rustc_middle::middle::privacy::Level;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::lint;\n@@ -604,13 +604,13 @@ fn check_foreign_item<'tcx>(\n fn create_and_seed_worklist<'tcx>(\n     tcx: TyCtxt<'tcx>,\n ) -> (Vec<LocalDefId>, FxHashMap<LocalDefId, LocalDefId>) {\n-    let access_levels = &tcx.privacy_access_levels(());\n+    let effective_visibilities = &tcx.effective_visibilities(());\n     // see `MarkSymbolVisitor::struct_constructors`\n     let mut struct_constructors = Default::default();\n-    let mut worklist = access_levels\n+    let mut worklist = effective_visibilities\n         .iter()\n         .filter_map(|(&id, effective_vis)| {\n-            effective_vis.is_public_at_level(AccessLevel::Reachable).then_some(id)\n+            effective_vis.is_public_at_level(Level::Reachable).then_some(id)\n         })\n         // Seed entry point\n         .chain(tcx.entry_fn(()).and_then(|(def_id, _)| def_id.as_local()))"}, {"sha": "273cab7922e35395f4761b2784d7bae78a76d6ae", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n-use rustc_middle::middle::privacy::{self, AccessLevel};\n+use rustc_middle::middle::privacy::{self, Level};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::CrateType;\n@@ -303,7 +303,7 @@ fn check_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::ItemId,\n     worklist: &mut Vec<LocalDefId>,\n-    access_levels: &privacy::AccessLevels,\n+    effective_visibilities: &privacy::EffectiveVisibilities,\n ) {\n     if has_custom_linkage(tcx, id.def_id.def_id) {\n         worklist.push(id.def_id.def_id);\n@@ -318,7 +318,7 @@ fn check_item<'tcx>(\n     if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n         item.kind\n     {\n-        if !access_levels.is_reachable(item.def_id.def_id) {\n+        if !effective_visibilities.is_reachable(item.def_id.def_id) {\n             worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id.def_id));\n \n             let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n@@ -354,7 +354,7 @@ fn has_custom_linkage<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n }\n \n fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n-    let access_levels = &tcx.privacy_access_levels(());\n+    let effective_visibilities = &tcx.effective_visibilities(());\n \n     let any_library =\n         tcx.sess.crate_types().iter().any(|ty| {\n@@ -373,10 +373,10 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    reachable_context.worklist = access_levels\n+    reachable_context.worklist = effective_visibilities\n         .iter()\n         .filter_map(|(&id, effective_vis)| {\n-            effective_vis.is_public_at_level(AccessLevel::ReachableFromImplTrait).then_some(id)\n+            effective_vis.is_public_at_level(Level::ReachableThroughImplTrait).then_some(id)\n         })\n         .collect::<Vec<_>>();\n \n@@ -399,7 +399,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            check_item(tcx, id, &mut reachable_context.worklist, access_levels);\n+            check_item(tcx, id, &mut reachable_context.worklist, effective_visibilities);\n         }\n \n         for id in crate_items.impl_items() {"}, {"sha": "d7655655d78c5bca4959f06b3aa2e06421845cb0", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{FieldDef, Item, ItemKind, TraitRef, Ty, TyKind, Variant};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::middle::stability::{AllowUnstable, DeprecationEntry, Index};\n use rustc_middle::ty::{query::Providers, TyCtxt};\n use rustc_session::lint;\n@@ -516,13 +516,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n struct MissingStabilityAnnotations<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'tcx AccessLevels,\n+    effective_visibilities: &'tcx EffectiveVisibilities,\n }\n \n impl<'tcx> MissingStabilityAnnotations<'tcx> {\n     fn check_missing_stability(&self, def_id: LocalDefId, span: Span) {\n         let stab = self.tcx.stability().local_stability(def_id);\n-        if !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(def_id) {\n+        if !self.tcx.sess.opts.test\n+            && stab.is_none()\n+            && self.effective_visibilities.is_reachable(def_id)\n+        {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n             self.tcx.sess.emit_err(MissingStabilityAttr { span, descr });\n         }\n@@ -540,7 +543,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n             .lookup_stability(def_id)\n             .map_or(false, |stability| stability.level.is_stable());\n         let missing_const_stability_attribute = self.tcx.lookup_const_stability(def_id).is_none();\n-        let is_reachable = self.access_levels.is_reachable(def_id);\n+        let is_reachable = self.effective_visibilities.is_reachable(def_id);\n \n         if is_const && is_stable && missing_const_stability_attribute && is_reachable {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n@@ -919,8 +922,8 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     let is_staged_api =\n         tcx.sess.opts.unstable_opts.force_unstable_if_unmarked || tcx.features().staged_api;\n     if is_staged_api {\n-        let access_levels = &tcx.privacy_access_levels(());\n-        let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n+        let effective_visibilities = &tcx.effective_visibilities(());\n+        let mut missing = MissingStabilityAnnotations { tcx, effective_visibilities };\n         missing.check_missing_stability(CRATE_DEF_ID, tcx.hir().span(CRATE_HIR_ID));\n         tcx.hir().walk_toplevel_module(&mut missing);\n         tcx.hir().visit_all_item_likes_in_crate(&mut missing);"}, {"sha": "df8454ed4ee062c3facf1f90a0321d4bf8864735", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -23,7 +23,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::span_bug;\n use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst, Node as ACNode};\n use rustc_middle::ty::query::Providers;\n@@ -310,7 +310,7 @@ fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visib\n \n struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n+    effective_visibilities: &'a EffectiveVisibilities,\n     min: VL,\n }\n \n@@ -344,8 +344,12 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl(def_id: LocalDefId, tcx: TyCtxt<'_>, access_levels: &AccessLevels) -> Self {\n-        let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n+    fn of_impl(\n+        def_id: LocalDefId,\n+        tcx: TyCtxt<'_>,\n+        effective_visibilities: &EffectiveVisibilities,\n+    ) -> Self {\n+        let mut find = FindMin { tcx, effective_visibilities, min: Self::MAX };\n         find.visit(tcx.type_of(def_id));\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n             find.visit_trait(trait_ref);\n@@ -359,8 +363,8 @@ impl VisibilityLike for ty::Visibility {\n         min(find.tcx.local_visibility(def_id), find.min, find.tcx)\n     }\n }\n-impl VisibilityLike for Option<AccessLevel> {\n-    const MAX: Self = Some(AccessLevel::Public);\n+impl VisibilityLike for Option<Level> {\n+    const MAX: Self = Some(Level::Direct);\n     // Type inference is very smart sometimes.\n     // It can make an impl reachable even some components of its type or trait are unreachable.\n     // E.g. methods of `impl ReachableTrait<UnreachableTy> for ReachableTy<UnreachableTy> { ... }`\n@@ -372,7 +376,7 @@ impl VisibilityLike for Option<AccessLevel> {\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self {\n-        cmp::min(find.access_levels.get_access_level(def_id), find.min)\n+        cmp::min(find.effective_visibilities.public_at_level(def_id), find.min)\n     }\n }\n \n@@ -383,8 +387,8 @@ impl VisibilityLike for Option<AccessLevel> {\n struct EmbargoVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    /// Accessibility levels for reachable nodes.\n-    access_levels: AccessLevels,\n+    /// Effective visibilities for reachable nodes.\n+    effective_visibilities: EffectiveVisibilities,\n     /// A set of pairs corresponding to modules, where the first module is\n     /// reachable via a macro that's defined in the second module. This cannot\n     /// be represented as reachable because it can't handle the following case:\n@@ -398,38 +402,34 @@ struct EmbargoVisitor<'tcx> {\n     ///     n::p::f()\n     /// }\n     macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n-    /// Previous accessibility level; `None` means unreachable.\n-    prev_level: Option<AccessLevel>,\n+    /// Previous visibility level; `None` means unreachable.\n+    prev_level: Option<Level>,\n     /// Has something changed in the level map?\n     changed: bool,\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    access_level: Option<AccessLevel>,\n+    level: Option<Level>,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n }\n \n impl<'tcx> EmbargoVisitor<'tcx> {\n-    fn get(&self, def_id: LocalDefId) -> Option<AccessLevel> {\n-        self.access_levels.get_access_level(def_id)\n+    fn get(&self, def_id: LocalDefId) -> Option<Level> {\n+        self.effective_visibilities.public_at_level(def_id)\n     }\n \n-    fn update_with_hir_id(\n-        &mut self,\n-        hir_id: hir::HirId,\n-        level: Option<AccessLevel>,\n-    ) -> Option<AccessLevel> {\n+    fn update_with_hir_id(&mut self, hir_id: hir::HirId, level: Option<Level>) -> Option<Level> {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n         self.update(def_id, level)\n     }\n \n     /// Updates node level and returns the updated level.\n-    fn update(&mut self, def_id: LocalDefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+    fn update(&mut self, def_id: LocalDefId, level: Option<Level>) -> Option<Level> {\n         let old_level = self.get(def_id);\n-        // Accessibility levels can only grow.\n+        // Visibility levels can only grow.\n         if level > old_level {\n-            self.access_levels.set_access_level(\n+            self.effective_visibilities.set_public_at_level(\n                 def_id,\n                 || ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id)),\n                 level.unwrap(),\n@@ -444,10 +444,10 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        access_level: Option<AccessLevel>,\n+        level: Option<Level>,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n+            level: cmp::min(level, Some(Level::Reachable)),\n             item_def_id: def_id,\n             ev: self,\n         }\n@@ -530,7 +530,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         vis: ty::Visibility,\n         module: LocalDefId,\n     ) {\n-        let level = Some(AccessLevel::Reachable);\n+        let level = Some(Level::Reachable);\n         if vis.is_public() {\n             self.update(def_id, level);\n         }\n@@ -627,10 +627,10 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                let impl_level = Option::<AccessLevel>::of_impl(\n+                let impl_level = Option::<Level>::of_impl(\n                     item.def_id.def_id,\n                     self.tcx,\n-                    &self.access_levels,\n+                    &self.effective_visibilities,\n                 );\n                 self.update(item.def_id.def_id, impl_level)\n             }\n@@ -705,7 +705,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::Macro(..) | hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`.\n             hir::ItemKind::Mod(..) => {}\n-            // Handled in the access level of in rustc_resolve\n+            // Handled in `rustc_resolve`.\n             hir::ItemKind::Use(..) => {}\n             // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n@@ -718,8 +718,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // FIXME: This is some serious pessimization intended to workaround deficiencies\n                     // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_level =\n-                        cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n+                    let exist_level = cmp::max(item_level, Some(Level::ReachableThroughImplTrait));\n                     self.reach(item.def_id.def_id, exist_level).generics().predicates().ty();\n                 }\n             }\n@@ -901,32 +900,32 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if let Some(def_id) = def_id.as_local() {\n-            if let (ty::Visibility::Public, _) | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n-                (self.tcx().visibility(def_id.to_def_id()), self.access_level)\n+            if let (ty::Visibility::Public, _) | (_, Some(Level::ReachableThroughImplTrait)) =\n+                (self.tcx().visibility(def_id.to_def_id()), self.level)\n             {\n-                self.ev.update(def_id, self.access_level);\n+                self.ev.update(def_id, self.level);\n             }\n         }\n         ControlFlow::CONTINUE\n     }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-/// Visitor, used for AccessLevels table checking\n+/// Visitor, used for EffectiveVisibilities table checking\n ////////////////////////////////////////////////////////////////////////////////\n pub struct TestReachabilityVisitor<'tcx, 'a> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n+    effective_visibilities: &'a EffectiveVisibilities,\n }\n \n impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n-    fn access_level_diagnostic(&mut self, def_id: LocalDefId) {\n+    fn effective_visibility_diagnostic(&mut self, def_id: LocalDefId) {\n         if self.tcx.has_attr(def_id.to_def_id(), sym::rustc_effective_visibility) {\n             let mut error_msg = String::new();\n             let span = self.tcx.def_span(def_id.to_def_id());\n-            if let Some(effective_vis) = self.access_levels.get_effective_vis(def_id) {\n-                for level in AccessLevel::all_levels() {\n-                    let vis_str = match effective_vis.get(level) {\n+            if let Some(effective_vis) = self.effective_visibilities.effective_vis(def_id) {\n+                for level in Level::all_levels() {\n+                    let vis_str = match effective_vis.at_level(level) {\n                         ty::Visibility::Restricted(restricted_id) => {\n                             if restricted_id.is_top_level_module() {\n                                 \"pub(crate)\".to_string()\n@@ -938,7 +937,7 @@ impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n                         }\n                         ty::Visibility::Public => \"pub\".to_string(),\n                     };\n-                    if level != AccessLevel::Public {\n+                    if level != Level::Direct {\n                         error_msg.push_str(\", \");\n                     }\n                     error_msg.push_str(&format!(\"{:?}: {}\", level, vis_str));\n@@ -953,37 +952,37 @@ impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n \n impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.access_level_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.def_id.def_id);\n \n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in def.variants.iter() {\n                     let variant_id = self.tcx.hir().local_def_id(variant.id);\n-                    self.access_level_diagnostic(variant_id);\n+                    self.effective_visibility_diagnostic(variant_id);\n                     for field in variant.data.fields() {\n                         let def_id = self.tcx.hir().local_def_id(field.hir_id);\n-                        self.access_level_diagnostic(def_id);\n+                        self.effective_visibility_diagnostic(def_id);\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 for field in def.fields() {\n                     let def_id = self.tcx.hir().local_def_id(field.hir_id);\n-                    self.access_level_diagnostic(def_id);\n+                    self.effective_visibility_diagnostic(def_id);\n                 }\n             }\n             _ => {}\n         }\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.def_id.def_id);\n     }\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.def_id.def_id);\n     }\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.def_id.def_id);\n     }\n }\n \n@@ -1054,7 +1053,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n \n     fn visit_mod(&mut self, _m: &'tcx hir::Mod<'tcx>, _s: Span, _n: hir::HirId) {\n         // Don't visit nested modules, since we run a separate visitor walk\n-        // for each module in `privacy_access_levels`\n+        // for each module in `effective_visibilities`\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n@@ -1179,7 +1178,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n     fn visit_mod(&mut self, _m: &'tcx hir::Mod<'tcx>, _s: Span, _n: hir::HirId) {\n         // Don't visit nested modules, since we run a separate visitor walk\n-        // for each module in `privacy_access_levels`\n+        // for each module in `effective_visibilities`\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n@@ -1404,7 +1403,7 @@ impl<'tcx> DefIdVisitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n+    effective_visibilities: &'a EffectiveVisibilities,\n     in_variant: bool,\n     // Set of errors produced by this obsolete visitor.\n     old_error_set: HirIdSet,\n@@ -1447,7 +1446,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn trait_is_public(&self, trait_id: LocalDefId) -> bool {\n         // FIXME: this would preferably be using `exported_items`, but all\n         // traits are exported currently (see `EmbargoVisitor.exported_trait`).\n-        self.access_levels.is_public(trait_id)\n+        self.effective_visibilities.is_directly_public(trait_id)\n     }\n \n     fn check_generic_bound(&mut self, bound: &hir::GenericBound<'_>) {\n@@ -1459,7 +1458,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn item_is_public(&self, def_id: LocalDefId) -> bool {\n-        self.access_levels.is_reachable(def_id) || self.tcx.visibility(def_id).is_public()\n+        self.effective_visibilities.is_reachable(def_id) || self.tcx.visibility(def_id).is_public()\n     }\n }\n \n@@ -1573,9 +1572,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     || impl_.items.iter().any(|impl_item_ref| {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         match impl_item.kind {\n-                            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => {\n-                                self.access_levels.is_reachable(impl_item_ref.id.def_id.def_id)\n-                            }\n+                            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => self\n+                                .effective_visibilities\n+                                .is_reachable(impl_item_ref.id.def_id.def_id),\n                             hir::ImplItemKind::Type(_) => false,\n                         }\n                     });\n@@ -1635,7 +1634,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_.items {\n-                        if self.access_levels.is_reachable(impl_item_ref.id.def_id.def_id)\n+                        if self.effective_visibilities.is_reachable(impl_item_ref.id.def_id.def_id)\n                             || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n                         {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n@@ -1695,7 +1694,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        if self.access_levels.is_reachable(item.def_id.def_id) {\n+        if self.effective_visibilities.is_reachable(item.def_id.def_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1710,7 +1709,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n-        if self.access_levels.is_reachable(self.tcx.hir().local_def_id(v.id)) {\n+        if self.effective_visibilities.is_reachable(self.tcx.hir().local_def_id(v.id)) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v);\n             self.in_variant = false;\n@@ -2040,7 +2039,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         visibility,\n-        privacy_access_levels,\n+        effective_visibilities,\n         check_private_in_public,\n         check_mod_privacy,\n         ..*providers\n@@ -2112,14 +2111,14 @@ fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n \n-fn privacy_access_levels(tcx: TyCtxt<'_>, (): ()) -> &AccessLevels {\n+fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n         tcx,\n-        access_levels: tcx.resolutions(()).access_levels.clone(),\n+        effective_visibilities: tcx.resolutions(()).effective_visibilities.clone(),\n         macro_reachable: Default::default(),\n-        prev_level: Some(AccessLevel::Public),\n+        prev_level: Some(Level::Direct),\n         changed: false,\n     };\n \n@@ -2132,18 +2131,19 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, (): ()) -> &AccessLevels {\n         }\n     }\n \n-    let mut check_visitor = TestReachabilityVisitor { tcx, access_levels: &visitor.access_levels };\n+    let mut check_visitor =\n+        TestReachabilityVisitor { tcx, effective_visibilities: &visitor.effective_visibilities };\n     tcx.hir().visit_all_item_likes_in_crate(&mut check_visitor);\n \n-    tcx.arena.alloc(visitor.access_levels)\n+    tcx.arena.alloc(visitor.effective_visibilities)\n }\n \n fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n-    let access_levels = tcx.privacy_access_levels(());\n+    let effective_visibilities = tcx.effective_visibilities(());\n \n     let mut visitor = ObsoleteVisiblePrivateTypesVisitor {\n         tcx,\n-        access_levels,\n+        effective_visibilities,\n         in_variant: false,\n         old_error_set: Default::default(),\n     };"}, {"sha": "c40669ac95bee19193deb48ab4bcfb8012a51ca0", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "renamed", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -6,55 +6,54 @@ use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_middle::middle::privacy::AccessLevel;\n+use rustc_middle::middle::privacy::Level;\n use rustc_middle::ty::{DefIdTree, Visibility};\n \n-pub struct AccessLevelsVisitor<'r, 'a> {\n+pub struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n     changed: bool,\n }\n \n-impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n-    /// Fills the `Resolver::access_levels` table with public & exported items\n+impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n+    /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n-    pub fn compute_access_levels<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n-        let mut visitor = AccessLevelsVisitor { r, changed: false };\n+    pub fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n+        let mut visitor = EffectiveVisibilitiesVisitor { r, changed: false };\n \n-        visitor.update(CRATE_DEF_ID, Visibility::Public, CRATE_DEF_ID, AccessLevel::Public);\n-        visitor.set_bindings_access_level(CRATE_DEF_ID);\n+        visitor.update(CRATE_DEF_ID, Visibility::Public, CRATE_DEF_ID, Level::Direct);\n+        visitor.set_bindings_effective_visibilities(CRATE_DEF_ID);\n \n         while visitor.changed {\n             visitor.reset();\n             visit::walk_crate(&mut visitor, krate);\n         }\n \n-        info!(\"resolve::access_levels: {:#?}\", r.access_levels);\n+        info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n     }\n \n     fn reset(&mut self) {\n         self.changed = false;\n     }\n \n-    /// Update the access level of the bindings in the given module accordingly. The module access\n-    /// level has to be Exported or Public.\n-    /// This will also follow `use` chains (see PrivacyVisitor::set_import_binding_access_level).\n-    fn set_bindings_access_level(&mut self, module_id: LocalDefId) {\n+    /// Update effective visibilities of bindings in the given module,\n+    /// including their whole reexport chains.\n+    fn set_bindings_effective_visibilities(&mut self, module_id: LocalDefId) {\n         assert!(self.r.module_map.contains_key(&&module_id.to_def_id()));\n         let module = self.r.get_module(module_id.to_def_id()).unwrap();\n         let resolutions = self.r.resolutions(module);\n \n         for (_, name_resolution) in resolutions.borrow().iter() {\n             if let Some(mut binding) = name_resolution.borrow().binding() && !binding.is_ambiguity() {\n-                // Set the given binding access level to `AccessLevel::Public` and\n-                // sets the rest of the `use` chain to `AccessLevel::Exported` until\n+                // Set the given effective visibility level to `Level::Direct` and\n+                // sets the rest of the `use` chain to `Level::Reexported` until\n                 // we hit the actual exported item.\n \n                 // FIXME: tag and is_public() condition should be removed, but assertions occur.\n-                let tag = if binding.is_import() { AccessLevel::Exported } else { AccessLevel::Public };\n+                let tag = if binding.is_import() { Level::Reexported } else { Level::Direct };\n                 if binding.vis.is_public() {\n                     let mut prev_parent_id = module_id;\n-                    let mut level = AccessLevel::Public;\n+                    let mut level = Level::Direct;\n                     while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                         binding.kind\n                     {\n@@ -76,7 +75,7 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n                             update(additional_ids.1);\n                         }\n \n-                        level = AccessLevel::Exported;\n+                        level = Level::Reexported;\n                         prev_parent_id = self.r.local_def_id(import.id);\n                         binding = nested_binding;\n                     }\n@@ -94,7 +93,7 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n         def_id: LocalDefId,\n         nominal_vis: Visibility,\n         parent_id: LocalDefId,\n-        tag: AccessLevel,\n+        tag: Level,\n     ) {\n         let module_id = self\n             .r\n@@ -106,23 +105,23 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n         {\n             return;\n         }\n-        let mut access_levels = std::mem::take(&mut self.r.access_levels);\n-        self.changed |= access_levels.update(\n+        let mut effective_visibilities = std::mem::take(&mut self.r.effective_visibilities);\n+        self.changed |= effective_visibilities.update(\n             def_id,\n             nominal_vis,\n             || Visibility::Restricted(module_id),\n             parent_id,\n             tag,\n             &*self.r,\n         );\n-        self.r.access_levels = access_levels;\n+        self.r.effective_visibilities = effective_visibilities;\n     }\n }\n \n-impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n+impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n     fn visit_item(&mut self, item: &'ast ast::Item) {\n         let def_id = self.r.local_def_id(item.id);\n-        // Set access level of nested items.\n+        // Update effective visibilities of nested items.\n         // If it's a mod, also make the visitor walk all of its items\n         match item.kind {\n             // Resolved in rustc_privacy when types are available\n@@ -136,29 +135,29 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n             // Foreign modules inherit level from parents.\n             ast::ItemKind::ForeignMod(..) => {\n                 let parent_id = self.r.local_parent(def_id);\n-                self.update(def_id, Visibility::Public, parent_id, AccessLevel::Public);\n+                self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n             }\n \n             // Only exported `macro_rules!` items are public, but they always are\n             ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n                 let parent_id = self.r.local_parent(def_id);\n                 let vis = self.r.visibilities[&def_id];\n-                self.update(def_id, vis, parent_id, AccessLevel::Public);\n+                self.update(def_id, vis, parent_id, Level::Direct);\n             }\n \n             ast::ItemKind::Mod(..) => {\n-                self.set_bindings_access_level(def_id);\n+                self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);\n             }\n \n             ast::ItemKind::Enum(EnumDef { ref variants }, _) => {\n-                self.set_bindings_access_level(def_id);\n+                self.set_bindings_effective_visibilities(def_id);\n                 for variant in variants {\n                     let variant_def_id = self.r.local_def_id(variant.id);\n                     for field in variant.data.fields() {\n                         let field_def_id = self.r.local_def_id(field.id);\n                         let vis = self.r.visibilities[&field_def_id];\n-                        self.update(field_def_id, vis, variant_def_id, AccessLevel::Public);\n+                        self.update(field_def_id, vis, variant_def_id, Level::Direct);\n                     }\n                 }\n             }\n@@ -167,12 +166,12 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n                 for field in def.fields() {\n                     let field_def_id = self.r.local_def_id(field.id);\n                     let vis = self.r.visibilities[&field_def_id];\n-                    self.update(field_def_id, vis, def_id, AccessLevel::Public);\n+                    self.update(field_def_id, vis, def_id, Level::Direct);\n                 }\n             }\n \n             ast::ItemKind::Trait(..) => {\n-                self.set_bindings_access_level(def_id);\n+                self.set_bindings_effective_visibilities(def_id);\n             }\n \n             ast::ItemKind::ExternCrate(..)", "previous_filename": "compiler/rustc_resolve/src/access_levels.rs"}, {"sha": "11b70a38da58d18abc8cbce6bb71fc1a5bafa7d2", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -7,6 +7,7 @@\n //! Type-relative name resolution (methods, fields, associated items) happens in `rustc_hir_analysis`.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(if_let_guard)]\n@@ -40,7 +41,7 @@ use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools};\n use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n@@ -63,15 +64,15 @@ use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource, PatternSource};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n-use crate::access_levels::AccessLevelsVisitor;\n+use crate::effective_visibilities::EffectiveVisibilitiesVisitor;\n \n type Res = def::Res<NodeId>;\n \n-mod access_levels;\n mod build_reduced_graph;\n mod check_unused;\n mod def_collector;\n mod diagnostics;\n+mod effective_visibilities;\n mod ident;\n mod imports;\n mod late;\n@@ -1030,7 +1031,7 @@ pub struct Resolver<'a> {\n     proc_macros: Vec<NodeId>,\n     confused_type_with_std_module: FxHashMap<Span, Span>,\n \n-    access_levels: AccessLevels,\n+    effective_visibilities: EffectiveVisibilities,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1334,7 +1335,7 @@ impl<'a> Resolver<'a> {\n             trait_impls: Default::default(),\n             proc_macros: Default::default(),\n             confused_type_with_std_module: Default::default(),\n-            access_levels: Default::default(),\n+            effective_visibilities: Default::default(),\n         };\n \n         let root_parent_scope = ParentScope::module(graph_root, &resolver);\n@@ -1392,14 +1393,14 @@ impl<'a> Resolver<'a> {\n         let glob_map = self.glob_map;\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n-        let access_levels = self.access_levels;\n+        let effective_visibilities = self.effective_visibilities;\n         let global_ctxt = ResolverGlobalCtxt {\n             cstore,\n             source_span,\n             expn_that_defined,\n             visibilities,\n             has_pub_restricted,\n-            access_levels,\n+            effective_visibilities,\n             extern_crate_map,\n             reexport_map,\n             glob_map,\n@@ -1457,7 +1458,7 @@ impl<'a> Resolver<'a> {\n             proc_macros,\n             confused_type_with_std_module: self.confused_type_with_std_module.clone(),\n             registered_tools: self.registered_tools.clone(),\n-            access_levels: self.access_levels.clone(),\n+            effective_visibilities: self.effective_visibilities.clone(),\n         };\n         let ast_lowering = ty::ResolverAstLowering {\n             legacy_const_generic_args: self.legacy_const_generic_args.clone(),\n@@ -1520,8 +1521,8 @@ impl<'a> Resolver<'a> {\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.session.time(\"resolve_crate\", || {\n             self.session.time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n-            self.session.time(\"resolve_access_levels\", || {\n-                AccessLevelsVisitor::compute_access_levels(self, krate)\n+            self.session.time(\"compute_effective_visibilities\", || {\n+                EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });\n             self.session.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n             self.session.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));"}, {"sha": "d0752e5a20d0f607f80b4b43770cfc06dd0e76cd", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -57,7 +57,7 @@ macro_rules! access_from {\n     ($save_ctxt:expr, $id:expr) => {\n         Access {\n             public: $save_ctxt.tcx.visibility($id).is_public(),\n-            reachable: $save_ctxt.access_levels.is_reachable($id),\n+            reachable: $save_ctxt.effective_visibilities.is_reachable($id),\n         }\n     };\n }"}, {"sha": "d1ed0e078d21dd1af7df75ce0a2266d43b232a58", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -26,7 +26,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n use rustc_hir_pretty::{enum_def_to_string, fn_to_string, ty_to_string};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::ty::{self, print::with_no_trimmed_paths, DefIdTree, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, Input, OutputType};\n@@ -54,7 +54,7 @@ use rls_data::{\n pub struct SaveContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n-    access_levels: &'tcx AccessLevels,\n+    effective_visibilities: &'tcx EffectiveVisibilities,\n     span_utils: SpanUtils<'tcx>,\n     config: Config,\n     impl_counter: Cell<u32>,\n@@ -968,16 +968,16 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n             info!(\"Dumping crate {}\", cratename);\n \n             // Privacy checking must be done outside of type inference; use a\n-            // fallback in case the access levels couldn't have been correctly computed.\n-            let access_levels = match tcx.sess.compile_status() {\n-                Ok(..) => tcx.privacy_access_levels(()),\n-                Err(..) => tcx.arena.alloc(AccessLevels::default()),\n+            // fallback in case effective visibilities couldn't have been correctly computed.\n+            let effective_visibilities = match tcx.sess.compile_status() {\n+                Ok(..) => tcx.effective_visibilities(()),\n+                Err(..) => tcx.arena.alloc(EffectiveVisibilities::default()),\n             };\n \n             let save_ctxt = SaveContext {\n                 tcx,\n                 maybe_typeck_results: None,\n-                access_levels: &access_levels,\n+                effective_visibilities: &effective_visibilities,\n                 span_utils: SpanUtils::new(&tcx.sess),\n                 config: find_config(config),\n                 impl_counter: Cell::new(0),"}, {"sha": "8b63c3db3c335b3959df738a9bb286e9cd0d39af", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n         for trait_def_id in cx.tcx.all_traits() {\n-            if !cx.cache.access_levels.is_public(trait_def_id)\n+            if !cx.cache.effective_visibilities.is_directly_public(trait_def_id)\n                 || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n             {\n                 continue;"}, {"sha": "b9f787729c14876976c2ed3a893d4d0ba9766c45", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -374,7 +374,7 @@ pub(crate) fn build_impl(\n     if !did.is_local() {\n         if let Some(traitref) = associated_trait {\n             let did = traitref.def_id;\n-            if !cx.cache.access_levels.is_public(did) {\n+            if !cx.cache.effective_visibilities.is_directly_public(did) {\n                 return;\n             }\n \n@@ -403,7 +403,7 @@ pub(crate) fn build_impl(\n     // reachable in rustdoc generated documentation\n     if !did.is_local() {\n         if let Some(did) = for_.def_id(&cx.cache) {\n-            if !cx.cache.access_levels.is_public(did) {\n+            if !cx.cache.effective_visibilities.is_directly_public(did) {\n                 return;\n             }\n "}, {"sha": "d5322f5c4662e5604d01567576ec18ffa8a0d81f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -1431,7 +1431,7 @@ fn maybe_expand_private_type_alias<'tcx>(\n     let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n     // Substitute private type aliases\n     let def_id = def_id.as_local()?;\n-    let alias = if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n+    let alias = if !cx.cache.effective_visibilities.is_exported(def_id.to_def_id()) {\n         &cx.tcx.hir().expect_item(def_id).kind\n     } else {\n         return None;"}, {"sha": "6fcf02dfc94941ebb3bb39a6aeda3519c7498051", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -348,7 +348,7 @@ pub(crate) fn run_global_ctxt(\n \n     let auto_traits =\n         tcx.all_traits().filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id)).collect();\n-    let access_levels = tcx.privacy_access_levels(()).map_id(Into::into);\n+    let effective_visibilities = tcx.effective_visibilities(()).map_id(Into::into);\n \n     let mut ctxt = DocContext {\n         tcx,\n@@ -361,7 +361,7 @@ pub(crate) fn run_global_ctxt(\n         impl_trait_bounds: Default::default(),\n         generated_synthetics: Default::default(),\n         auto_traits,\n-        cache: Cache::new(access_levels, render_options.document_private),\n+        cache: Cache::new(effective_visibilities, render_options.document_private),\n         inlined: FxHashSet::default(),\n         output_format,\n         render_options,"}, {"sha": "afe2264e8bf85dd5b62f37afae4f5785570f7430", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -2,7 +2,7 @@ use std::mem;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n \n@@ -77,8 +77,8 @@ pub(crate) struct Cache {\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n-    // the access levels from the privacy check pass.\n-    pub(crate) access_levels: AccessLevels<DefId>,\n+    // the effective visibilities from the privacy check pass.\n+    pub(crate) effective_visibilities: EffectiveVisibilities<DefId>,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n     pub(crate) crate_version: Option<String>,\n@@ -132,8 +132,11 @@ struct CacheBuilder<'a, 'tcx> {\n }\n \n impl Cache {\n-    pub(crate) fn new(access_levels: AccessLevels<DefId>, document_private: bool) -> Self {\n-        Cache { access_levels, document_private, ..Cache::default() }\n+    pub(crate) fn new(\n+        effective_visibilities: EffectiveVisibilities<DefId>,\n+        document_private: bool,\n+    ) -> Self {\n+        Cache { effective_visibilities, document_private, ..Cache::default() }\n     }\n \n     /// Populates the `Cache` with more data. The returned `Crate` will be missing some data that was\n@@ -381,7 +384,10 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // paths map if there was already an entry present and we're\n                     // not a public item.\n                     if !self.cache.paths.contains_key(&item.item_id.expect_def_id())\n-                        || self.cache.access_levels.is_public(item.item_id.expect_def_id())\n+                        || self\n+                            .cache\n+                            .effective_visibilities\n+                            .is_directly_public(item.item_id.expect_def_id())\n                     {\n                         self.cache.paths.insert(\n                             item.item_id.expect_def_id(),"}, {"sha": "92e7f2739afbb4ef27dd43741b0e5f126449bdf3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -659,7 +659,7 @@ pub(crate) fn href_with_root_path(\n     }\n \n     if !did.is_local()\n-        && !cache.access_levels.is_public(did)\n+        && !cache.effective_visibilities.is_directly_public(did)\n         && !cache.document_private\n         && !cache.primitive_locations.values().any(|&id| id == did)\n     {"}, {"sha": "7740c6d5bbbb8b8b7d0b5d2a3e640164592a7921", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -56,7 +56,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.access_levels.is_public(item.item_id.expect_def_id())\n+    if !cx.cache.effective_visibilities.is_directly_public(item.item_id.expect_def_id())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -130,7 +130,7 @@ pub(crate) fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item\n             );\n         }\n     } else if tests.found_tests > 0\n-        && !cx.cache.access_levels.is_exported(item.item_id.expect_def_id())\n+        && !cx.cache.effective_visibilities.is_exported(item.item_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "8aa0abd369cd504ef68c1990b0b44f076eef32ee", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -1202,8 +1202,8 @@ impl LinkCollector<'_, '_> {\n                 item.item_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n             })\n         {\n-            if self.cx.tcx.privacy_access_levels(()).is_exported(src_id)\n-                && !self.cx.tcx.privacy_access_levels(()).is_exported(dst_id)\n+            if self.cx.tcx.effective_visibilities(()).is_exported(src_id)\n+                && !self.cx.tcx.effective_visibilities(()).is_exported(dst_id)\n             {\n                 privacy_error(self.cx, diag_info, path_str);\n             }"}, {"sha": "450f69e15d1affc8d63c1518503d1e05eea34749", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) ->\n     {\n         let mut stripper = Stripper {\n             retained: &mut retained,\n-            access_levels: &cx.cache.access_levels,\n+            effective_visibilities: &cx.cache.effective_visibilities,\n             update_retained: true,\n             is_json_output,\n         };"}, {"sha": "f293a6fcc6df174ce1d0dca185c92b5b4109859f", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -1,6 +1,6 @@\n //! A collection of utility functions for the `strip_*` passes.\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use std::mem;\n \n use crate::clean::{self, Item, ItemId, ItemIdSet};\n@@ -9,7 +9,7 @@ use crate::formats::cache::Cache;\n \n pub(crate) struct Stripper<'a> {\n     pub(crate) retained: &'a mut ItemIdSet,\n-    pub(crate) access_levels: &'a AccessLevels<DefId>,\n+    pub(crate) effective_visibilities: &'a EffectiveVisibilities<DefId>,\n     pub(crate) update_retained: bool,\n     pub(crate) is_json_output: bool,\n }\n@@ -20,13 +20,13 @@ pub(crate) struct Stripper<'a> {\n #[inline]\n fn is_item_reachable(\n     is_json_output: bool,\n-    access_levels: &AccessLevels<DefId>,\n+    effective_visibilities: &EffectiveVisibilities<DefId>,\n     item_id: ItemId,\n ) -> bool {\n     if is_json_output {\n-        access_levels.is_reachable(item_id.expect_def_id())\n+        effective_visibilities.is_reachable(item_id.expect_def_id())\n     } else {\n-        access_levels.is_exported(item_id.expect_def_id())\n+        effective_visibilities.is_exported(item_id.expect_def_id())\n     }\n }\n \n@@ -64,7 +64,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ForeignTypeItem => {\n                 let item_id = i.item_id;\n                 if item_id.is_local()\n-                    && !is_item_reachable(self.is_json_output, self.access_levels, item_id)\n+                    && !is_item_reachable(self.is_json_output, self.effective_visibilities, item_id)\n                 {\n                     debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                     return None;\n@@ -168,7 +168,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                         item_id.is_local()\n                             && !is_item_reachable(\n                                 self.is_json_output,\n-                                &self.cache.access_levels,\n+                                &self.cache.effective_visibilities,\n                                 item_id,\n                             )\n                     })"}, {"sha": "8023ec9fa9a2d2367092b0b8bba2017269799226", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_middle::middle::privacy::AccessLevel;\n+use rustc_middle::middle::privacy::Level;\n use rustc_middle::ty::{TyCtxt, Visibility};\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -230,10 +230,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     } else {\n                         // All items need to be handled here in case someone wishes to link\n                         // to them with intra-doc links\n-                        self.cx.cache.access_levels.set_access_level(\n+                        self.cx.cache.effective_visibilities.set_public_at_level(\n                             did,\n                             || Visibility::Restricted(CRATE_DEF_ID),\n-                            AccessLevel::Public,\n+                            Level::Direct,\n                         );\n                     }\n                 }\n@@ -246,7 +246,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false,\n         };\n \n-        let is_private = !self.cx.cache.access_levels.is_public(res_did);\n+        let is_private = !self.cx.cache.effective_visibilities.is_directly_public(res_did);\n         let is_hidden = inherits_doc_hidden(self.cx.tcx, res_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped."}, {"sha": "70214e2adba463e7b34cee03e96c64d032dbd930", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n-use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::ty::{TyCtxt, Visibility};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n@@ -10,10 +10,10 @@ use rustc_middle::ty::{TyCtxt, Visibility};\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n pub(crate) struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    // Accessibility levels for reachable nodes\n-    access_levels: &'a mut AccessLevels<DefId>,\n-    // Previous accessibility level, None means unreachable\n-    prev_level: Option<AccessLevel>,\n+    // Effective visibilities for reachable nodes\n+    effective_visibilities: &'a mut EffectiveVisibilities<DefId>,\n+    // Previous level, None means unreachable\n+    prev_level: Option<Level>,\n     // Keeps track of already visited modules, in case a module re-exports its parent\n     visited_mods: FxHashSet<DefId>,\n }\n@@ -22,26 +22,26 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n     pub(crate) fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n             tcx: cx.tcx,\n-            access_levels: &mut cx.cache.access_levels,\n-            prev_level: Some(AccessLevel::Public),\n+            effective_visibilities: &mut cx.cache.effective_visibilities,\n+            prev_level: Some(Level::Direct),\n             visited_mods: FxHashSet::default(),\n         }\n     }\n \n     pub(crate) fn visit_lib(&mut self, cnum: CrateNum) {\n         let did = cnum.as_def_id();\n-        self.update(did, Some(AccessLevel::Public));\n+        self.update(did, Some(Level::Direct));\n         self.visit_mod(did);\n     }\n \n     // Updates node level and returns the updated level\n-    fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+    fn update(&mut self, did: DefId, level: Option<Level>) -> Option<Level> {\n         let is_hidden = self.tcx.is_doc_hidden(did);\n \n-        let old_level = self.access_levels.get_access_level(did);\n-        // Accessibility levels can only grow\n+        let old_level = self.effective_visibilities.public_at_level(did);\n+        // Visibility levels can only grow\n         if level > old_level && !is_hidden {\n-            self.access_levels.set_access_level(\n+            self.effective_visibilities.set_public_at_level(\n                 did,\n                 || Visibility::Restricted(CRATE_DEF_ID),\n                 level.unwrap(),"}, {"sha": "6bca7161886855debdfef80175ff11c8b152efcc", "filename": "src/test/ui/privacy/access_levels.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7174231ae66aa3e938cbe0b84e23e79d867fec20/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7174231ae66aa3e938cbe0b84e23e79d867fec20/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs?ref=7174231ae66aa3e938cbe0b84e23e79d867fec20", "patch": "@@ -1,75 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-#[rustc_effective_visibility]\n-mod outer { //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n-    #[rustc_effective_visibility]\n-    pub mod inner1 { //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-\n-        #[rustc_effective_visibility]\n-        extern \"C\" {} //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-\n-        #[rustc_effective_visibility]\n-        pub trait PubTrait { //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-            #[rustc_effective_visibility]\n-            const A: i32; //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-            #[rustc_effective_visibility]\n-            type B; //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-        }\n-\n-        #[rustc_effective_visibility]\n-        struct PrivStruct; //~ ERROR not in the table\n-\n-        #[rustc_effective_visibility]\n-        pub union PubUnion { //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-            #[rustc_effective_visibility]\n-            a: u8, //~ ERROR not in the table\n-            #[rustc_effective_visibility]\n-            pub b: u8, //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-        }\n-\n-        #[rustc_effective_visibility]\n-        pub enum Enum { //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-            #[rustc_effective_visibility]\n-            A( //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-                #[rustc_effective_visibility]\n-                PubUnion,  //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-            ),\n-        }\n-    }\n-\n-    #[rustc_effective_visibility]\n-    macro_rules! none_macro { //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n-        () => {};\n-    }\n-\n-    #[macro_export]\n-    #[rustc_effective_visibility]\n-    macro_rules! public_macro { //~ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-        () => {};\n-    }\n-\n-    #[rustc_effective_visibility]\n-    pub struct ReachableStruct { //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub, ReachableFromImplTrait: pub\n-        #[rustc_effective_visibility]\n-        pub a: u8, //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub, ReachableFromImplTrait: pub\n-    }\n-}\n-\n-#[rustc_effective_visibility]\n-pub use outer::inner1; //~ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-\n-pub fn foo() -> outer::ReachableStruct { outer::ReachableStruct {a: 0} }\n-\n-mod half_public_import {\n-    #[rustc_effective_visibility]\n-    pub type HalfPublicImport = u8; //~ ERROR Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-    #[rustc_effective_visibility]\n-    #[allow(non_upper_case_globals)]\n-    pub(crate) const HalfPublicImport: u8 = 0; //~ ERROR Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n-}\n-\n-#[rustc_effective_visibility]\n-pub use half_public_import::HalfPublicImport; //~ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-                                              //~^ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-\n-fn main() {}"}, {"sha": "07c4d436ff000a84a570dbc25f5e9415e520b712", "filename": "src/test/ui/privacy/access_levels.stderr", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7174231ae66aa3e938cbe0b84e23e79d867fec20/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7174231ae66aa3e938cbe0b84e23e79d867fec20/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr?ref=7174231ae66aa3e938cbe0b84e23e79d867fec20", "patch": "@@ -1,134 +0,0 @@\n-error: Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n-  --> $DIR/access_levels.rs:4:1\n-   |\n-LL | mod outer {\n-   | ^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:6:5\n-   |\n-LL |     pub mod inner1 {\n-   |     ^^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:9:9\n-   |\n-LL |         extern \"C\" {}\n-   |         ^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:12:9\n-   |\n-LL |         pub trait PubTrait {\n-   |         ^^^^^^^^^^^^^^^^^^\n-\n-error: not in the table\n-  --> $DIR/access_levels.rs:20:9\n-   |\n-LL |         struct PrivStruct;\n-   |         ^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:23:9\n-   |\n-LL |         pub union PubUnion {\n-   |         ^^^^^^^^^^^^^^^^^^\n-\n-error: not in the table\n-  --> $DIR/access_levels.rs:25:13\n-   |\n-LL |             a: u8,\n-   |             ^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:27:13\n-   |\n-LL |             pub b: u8,\n-   |             ^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:31:9\n-   |\n-LL |         pub enum Enum {\n-   |         ^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:33:13\n-   |\n-LL |             A(\n-   |             ^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:35:17\n-   |\n-LL |                 PubUnion,\n-   |                 ^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n-  --> $DIR/access_levels.rs:41:5\n-   |\n-LL |     macro_rules! none_macro {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:47:5\n-   |\n-LL |     macro_rules! public_macro {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub(crate), Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:52:5\n-   |\n-LL |     pub struct ReachableStruct {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub(crate), Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:54:9\n-   |\n-LL |         pub a: u8,\n-   |         ^^^^^^^^^\n-\n-error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:59:9\n-   |\n-LL | pub use outer::inner1;\n-   |         ^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:65:5\n-   |\n-LL |     pub type HalfPublicImport = u8;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub(crate), Reachable: pub(crate), ReachableFromImplTrait: pub(crate)\n-  --> $DIR/access_levels.rs:68:5\n-   |\n-LL |     pub(crate) const HalfPublicImport: u8 = 0;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:72:9\n-   |\n-LL | pub use half_public_import::HalfPublicImport;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:72:9\n-   |\n-LL | pub use half_public_import::HalfPublicImport;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:14:13\n-   |\n-LL |             const A: i32;\n-   |             ^^^^^^^^^^^^\n-\n-error: Public: pub(crate), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n-  --> $DIR/access_levels.rs:16:13\n-   |\n-LL |             type B;\n-   |             ^^^^^^\n-\n-error: aborting due to 22 previous errors\n-"}, {"sha": "1d806a1d1d167da5c3f200832d38b8a325d992e5", "filename": "src/test/ui/privacy/effective_visibilities.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -0,0 +1,75 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_effective_visibility]\n+mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+    #[rustc_effective_visibility]\n+    pub mod inner1 { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+\n+        #[rustc_effective_visibility]\n+        extern \"C\" {} //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+\n+        #[rustc_effective_visibility]\n+        pub trait PubTrait { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+            #[rustc_effective_visibility]\n+            const A: i32; //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+            #[rustc_effective_visibility]\n+            type B; //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+        }\n+\n+        #[rustc_effective_visibility]\n+        struct PrivStruct; //~ ERROR not in the table\n+\n+        #[rustc_effective_visibility]\n+        pub union PubUnion { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+            #[rustc_effective_visibility]\n+            a: u8, //~ ERROR not in the table\n+            #[rustc_effective_visibility]\n+            pub b: u8, //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+        }\n+\n+        #[rustc_effective_visibility]\n+        pub enum Enum { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+            #[rustc_effective_visibility]\n+            A( //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+                #[rustc_effective_visibility]\n+                PubUnion,  //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+            ),\n+        }\n+    }\n+\n+    #[rustc_effective_visibility]\n+    macro_rules! none_macro { //~ Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+        () => {};\n+    }\n+\n+    #[macro_export]\n+    #[rustc_effective_visibility]\n+    macro_rules! public_macro { //~ Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+        () => {};\n+    }\n+\n+    #[rustc_effective_visibility]\n+    pub struct ReachableStruct { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub, ReachableThroughImplTrait: pub\n+        #[rustc_effective_visibility]\n+        pub a: u8, //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub, ReachableThroughImplTrait: pub\n+    }\n+}\n+\n+#[rustc_effective_visibility]\n+pub use outer::inner1; //~ ERROR Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+\n+pub fn foo() -> outer::ReachableStruct { outer::ReachableStruct {a: 0} }\n+\n+mod half_public_import {\n+    #[rustc_effective_visibility]\n+    pub type HalfPublicImport = u8; //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+    #[rustc_effective_visibility]\n+    #[allow(non_upper_case_globals)]\n+    pub(crate) const HalfPublicImport: u8 = 0; //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+}\n+\n+#[rustc_effective_visibility]\n+pub use half_public_import::HalfPublicImport; //~ ERROR Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+                                              //~^ ERROR Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+\n+fn main() {}"}, {"sha": "1c6201600b630b727d67f277afd2607cdfabd7f4", "filename": "src/test/ui/privacy/effective_visibilities.stderr", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -0,0 +1,134 @@\n+error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+  --> $DIR/effective_visibilities.rs:4:1\n+   |\n+LL | mod outer {\n+   | ^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:6:5\n+   |\n+LL |     pub mod inner1 {\n+   |     ^^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:9:9\n+   |\n+LL |         extern \"C\" {}\n+   |         ^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:12:9\n+   |\n+LL |         pub trait PubTrait {\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error: not in the table\n+  --> $DIR/effective_visibilities.rs:20:9\n+   |\n+LL |         struct PrivStruct;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:23:9\n+   |\n+LL |         pub union PubUnion {\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error: not in the table\n+  --> $DIR/effective_visibilities.rs:25:13\n+   |\n+LL |             a: u8,\n+   |             ^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:27:13\n+   |\n+LL |             pub b: u8,\n+   |             ^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:31:9\n+   |\n+LL |         pub enum Enum {\n+   |         ^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:33:13\n+   |\n+LL |             A(\n+   |             ^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:35:17\n+   |\n+LL |                 PubUnion,\n+   |                 ^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+  --> $DIR/effective_visibilities.rs:41:5\n+   |\n+LL |     macro_rules! none_macro {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:47:5\n+   |\n+LL |     macro_rules! public_macro {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:52:5\n+   |\n+LL |     pub struct ReachableStruct {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:54:9\n+   |\n+LL |         pub a: u8,\n+   |         ^^^^^^^^^\n+\n+error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:59:9\n+   |\n+LL | pub use outer::inner1;\n+   |         ^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:65:5\n+   |\n+LL |     pub type HalfPublicImport = u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+  --> $DIR/effective_visibilities.rs:68:5\n+   |\n+LL |     pub(crate) const HalfPublicImport: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:72:9\n+   |\n+LL | pub use half_public_import::HalfPublicImport;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:72:9\n+   |\n+LL | pub use half_public_import::HalfPublicImport;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:14:13\n+   |\n+LL |             const A: i32;\n+   |             ^^^^^^^^^^^^\n+\n+error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+  --> $DIR/effective_visibilities.rs:16:13\n+   |\n+LL |             type B;\n+   |             ^^^^^^\n+\n+error: aborting due to 22 previous errors\n+"}, {"sha": "b47fa6c7ecf5732e3dbced0b222945ebc5428869", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -345,7 +345,7 @@ fn lint_for_missing_headers<'tcx>(\n     body_id: Option<hir::BodyId>,\n     panic_span: Option<Span>,\n ) {\n-    if !cx.access_levels.is_exported(def_id) {\n+    if !cx.effective_visibilities.is_exported(def_id) {\n         return; // Private functions do not require doc comments\n     }\n "}, {"sha": "2c3487a6e10f2a9b7d91e83a8716388f3601dc89", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -296,7 +296,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n             }\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            if !(self.avoid_breaking_exported_api && cx.access_levels.is_exported(item.def_id.def_id)) {\n+            if !(self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(item.def_id.def_id)) {\n                 check_variant(cx, self.threshold, def, item_name, item.span);\n             }\n         }"}, {"sha": "bb07b29b0763baa77b3844266b7e166dae1872d0", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -73,7 +73,7 @@ impl LateLintPass<'_> for ExhaustiveItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if_chain! {\n             if let ItemKind::Enum(..) | ItemKind::Struct(..) = item.kind;\n-            if cx.access_levels.is_exported(item.def_id.def_id);\n+            if cx.effective_visibilities.is_exported(item.def_id.def_id);\n             let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {"}, {"sha": "32cba5e608ada90ddce448d2b12af2d710d877c3", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -24,7 +24,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n     if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.def_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n@@ -44,7 +44,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n \n pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.def_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n@@ -67,7 +67,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n \n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.def_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n@@ -137,7 +137,7 @@ fn check_must_use_candidate<'tcx>(\n         || mutates_static(cx, body)\n         || in_external_macro(cx.sess(), item_span)\n         || returns_unit(decl)\n-        || !cx.access_levels.is_exported(item_id)\n+        || !cx.effective_visibilities.is_exported(item_id)\n         || is_must_use_ty(cx, return_ty(cx, cx.tcx.hir().local_def_id_to_hir_id(item_id)))\n     {\n         return;"}, {"sha": "0831b5cc38bdefa741745a80c0951f5bd2413299", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -42,7 +42,7 @@ fn check_raw_ptr<'tcx>(\n     body: &'tcx hir::Body<'tcx>,\n     def_id: LocalDefId,\n ) {\n-    if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(def_id) {\n+    if unsafety == hir::Unsafety::Normal && cx.effective_visibilities.is_exported(def_id) {\n         let raw_ptrs = iter_input_pats(decl, body)\n             .filter_map(|arg| raw_ptr_arg(cx, arg))\n             .collect::<HirIdSet>();"}, {"sha": "c5ce56dd2cef88dc0aaf6257d465db716c1f713b", "filename": "src/tools/clippy/clippy_lints/src/functions/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -36,7 +36,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, l\n     if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind\n         && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span)\n     {\n-        if cx.access_levels.is_exported(item.def_id.def_id) {\n+        if cx.effective_visibilities.is_exported(item.def_id.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             check_result_unit_err(cx, err_ty, fn_header_span);\n         }\n@@ -50,7 +50,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem\n         && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span)\n         && trait_ref_of_method(cx, item.def_id.def_id).is_none()\n     {\n-        if cx.access_levels.is_exported(item.def_id.def_id) {\n+        if cx.effective_visibilities.is_exported(item.def_id.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             check_result_unit_err(cx, err_ty, fn_header_span);\n         }\n@@ -62,7 +62,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::TraitIt\n     if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span) {\n-            if cx.access_levels.is_exported(item.def_id.def_id) {\n+            if cx.effective_visibilities.is_exported(item.def_id.def_id) {\n                 check_result_unit_err(cx, err_ty, fn_header_span);\n             }\n             check_result_large_err(cx, err_ty, hir_ty.span, large_err_threshold);"}, {"sha": "6415f35ddd038b50e668a8960a5dad4ee3fb9f3f", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -111,7 +111,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(item.def_id.def_id) {\n             return;\n         }\n "}, {"sha": "6e31812d70536a3652217fc19cb34e1ebaa21998", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -134,7 +134,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if item.ident.name == sym::len;\n             if let ImplItemKind::Fn(sig, _) = &item.kind;\n             if sig.decl.implicit_self.has_implicit_self();\n-            if cx.access_levels.is_exported(item.def_id.def_id);\n+            if cx.effective_visibilities.is_exported(item.def_id.def_id);\n             if matches!(sig.decl.output, FnRetTy::Return(_));\n             if let Some(imp) = get_parent_as_impl(cx.tcx, item.hir_id());\n             if imp.of_trait.is_none();\n@@ -210,7 +210,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.def_id.def_id)\n+    if cx.effective_visibilities.is_exported(visited_trait.def_id.def_id)\n         && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n@@ -331,7 +331,7 @@ fn check_for_is_empty<'tcx>(\n             None,\n             None,\n         ),\n-        Some(is_empty) if !cx.access_levels.is_exported(is_empty.def_id.expect_local()) => (\n+        Some(is_empty) if !cx.effective_visibilities.is_exported(is_empty.def_id.expect_local()) => (\n             format!(\n                 \"{item_kind} `{}` has a public `len` method, but a private `is_empty` method\",\n                 item_name.as_str(),"}, {"sha": "adfa7426607f96e92176f49457448a53e53fefff", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -3258,7 +3258,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n             let first_arg_ty_opt = method_sig.inputs().iter().next().copied();\n             // if this impl block implements a trait, lint in trait definition instead\n-            if !implements_trait && cx.access_levels.is_exported(impl_item.def_id.def_id) {\n+            if !implements_trait && cx.effective_visibilities.is_exported(impl_item.def_id.def_id) {\n                 // check missing trait implementations\n                 for method_config in &TRAIT_METHODS {\n                     if name == method_config.method_name\n@@ -3292,7 +3292,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             if sig.decl.implicit_self.has_implicit_self()\n                     && !(self.avoid_breaking_exported_api\n-                    && cx.access_levels.is_exported(impl_item.def_id.def_id))\n+                    && cx.effective_visibilities.is_exported(impl_item.def_id.def_id))\n                     && let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next()\n                     && let Some(first_arg_ty) = first_arg_ty_opt\n                 {"}, {"sha": "ed9da2d921737205bb1aadf3c778e4c006f6d05a", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(it.def_id.def_id) {\n             return;\n         }\n         match it.kind {\n@@ -142,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        if !cx.access_levels.is_exported(impl_item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(impl_item.def_id.def_id) {\n             return;\n         }\n \n@@ -159,7 +159,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         };\n \n         if let Some(trait_def_id) = trait_def_id {\n-            if trait_def_id.is_local() && !cx.access_levels.is_exported(impl_item.def_id.def_id) {\n+            if trait_def_id.is_local() && !cx.effective_visibilities.is_exported(impl_item.def_id.def_id) {\n                 // If a trait is being implemented for an item, and the\n                 // trait is not exported, we don't need #[inline]\n                 return;"}, {"sha": "99166c68936c477ca90619f59c105d15ab47e892", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                         if_chain! {\n                             if sig.decl.inputs.is_empty();\n                             if name == sym::new;\n-                            if cx.access_levels.is_reachable(impl_item.def_id.def_id);\n+                            if cx.effective_visibilities.is_reachable(impl_item.def_id.def_id);\n                             let self_def_id = cx.tcx.hir().get_parent_item(id);\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if self_ty == return_ty(cx, id);"}, {"sha": "c55985275db66bd610ff02b4e5354fb87179d6b9", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> PassByRefOrValue {\n     }\n \n     fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, def_id: LocalDefId, decl: &FnDecl<'_>, span: Option<Span>) {\n-        if self.avoid_breaking_exported_api && cx.access_levels.is_exported(def_id) {\n+        if self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(def_id) {\n             return;\n         }\n "}, {"sha": "bc73613a1502ec880fe70a3d29f7919c90d65387", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if_chain! {\n             if cx.tcx.visibility(item.def_id.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n-            if !cx.access_levels.is_exported(item.def_id.def_id) && self.is_exported.last() == Some(&false);\n+            if !cx.effective_visibilities.is_exported(item.def_id.def_id) && self.is_exported.last() == Some(&false);\n             if is_not_macro_export(item);\n             then {\n                 let span = item.span.with_hi(item.ident.span.hi());\n@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n \n         if let ItemKind::Mod { .. } = item.kind {\n-            self.is_exported.push(cx.access_levels.is_exported(item.def_id.def_id));\n+            self.is_exported.push(cx.effective_visibilities.is_exported(item.def_id.def_id));\n         }\n     }\n "}, {"sha": "7f34be5e7fd89d9e7ff22ccfbb4df62558fbb4ef", "filename": "src/tools/clippy/clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -74,7 +74,7 @@ fn check_method(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_def: LocalDefId, spa\n         if !in_external_macro(cx.sess(), span);\n         if decl.implicit_self.has_implicit_self();\n         // We only show this warning for public exported methods.\n-        if cx.access_levels.is_exported(fn_def);\n+        if cx.effective_visibilities.is_exported(fn_def);\n         // We don't want to emit this lint if the `#[must_use]` attribute is already there.\n         if !cx.tcx.hir().attrs(hir_id).iter().any(|attr| attr.has_name(sym::must_use));\n         if cx.tcx.visibility(fn_def.to_def_id()).is_public();"}, {"sha": "40cdcc3865bac2e0334b1776a5a76d6caec809b4", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -319,7 +319,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n                 false\n             };\n \n-        let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(id));\n+        let is_exported = cx.effective_visibilities.is_exported(cx.tcx.hir().local_def_id(id));\n \n         self.check_fn_decl(\n             cx,\n@@ -333,7 +333,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let is_exported = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_exported = cx.effective_visibilities.is_exported(item.def_id.def_id);\n \n         match item.kind {\n             ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(\n@@ -379,7 +379,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(field.hir_id));\n+        let is_exported = cx.effective_visibilities.is_exported(cx.tcx.hir().local_def_id(field.hir_id));\n \n         self.check_ty(\n             cx,\n@@ -392,7 +392,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &TraitItem<'_>) {\n-        let is_exported = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_exported = cx.effective_visibilities.is_exported(item.def_id.def_id);\n \n         let context = CheckTyContext {\n             is_exported,"}, {"sha": "60b46854b4ffebb2fa84bcd8f721e19a76c2d330", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         match fn_kind {\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 let def_id = cx.tcx.hir().local_def_id(hir_id);\n-                if self.avoid_breaking_exported_api && cx.access_levels.is_exported(def_id) {\n+                if self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(def_id) {\n                     return;\n                 }\n             },"}, {"sha": "62ab927d2f5c0be8042eee08cb864fbccd6e4ad4", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n             if let ItemKind::Impl(Impl { of_trait: None, .. }) = parent_item.kind;\n             if assoc_item.fn_has_self_parameter;\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n-            if !cx.access_levels.is_exported(impl_item.def_id.def_id) || !self.avoid_breaking_exported_api;\n+            if !cx.effective_visibilities.is_exported(impl_item.def_id.def_id) || !self.avoid_breaking_exported_api;\n             let body = cx.tcx.hir().body(*body_id);\n             if let [self_param, ..] = body.params;\n             if !is_local_used(cx, body, self_param.pat.hir_id);"}, {"sha": "7a20148c70a5f6f46c6d8f31dae221187c3141c6", "filename": "src/tools/clippy/clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b55ac39fa633d0983fad014469e1036669bf28/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=33b55ac39fa633d0983fad014469e1036669bf28", "patch": "@@ -105,7 +105,7 @@ impl LateLintPass<'_> for UpperCaseAcronyms {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &Item<'_>) {\n         // do not lint public items or in macros\n         if in_external_macro(cx.sess(), it.span)\n-            || (self.avoid_breaking_exported_api && cx.access_levels.is_exported(it.def_id.def_id))\n+            || (self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(it.def_id.def_id))\n         {\n             return;\n         }"}]}