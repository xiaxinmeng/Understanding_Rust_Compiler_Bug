{"sha": "38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4Zjk3ZWExMDMxM2JhOWE4YzZmNTdmYmY3M2ZmOGRhZjUzNzZlOGI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-11T19:52:17Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-13T01:54:13Z"}, "message": "std: Rename {Option,Result}::chain{,_err}* to {and_then,or_else}", "tree": {"sha": "72966f38845b07f6f43291d06957634135d97030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72966f38845b07f6f43291d06957634135d97030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "html_url": "https://github.com/rust-lang/rust/commit/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "url": "https://api.github.com/repos/rust-lang/rust/commits/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde", "html_url": "https://github.com/rust-lang/rust/commit/e03d60e9ebf2dbc2d18ab9919f905c17b967fcde"}], "stats": {"total": 363, "additions": 202, "deletions": 161}, "files": [{"sha": "1991d9f1b5bbc7486e4c16be06e27c36eacd7884", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -273,9 +273,9 @@ impl<T: FromStr + Clone + Integer + Ord>\n             return None\n         }\n         let a_option: Option<T> = FromStr::from_str(split[0]);\n-        do a_option.chain |a| {\n+        do a_option.and_then |a| {\n             let b_option: Option<T> = FromStr::from_str(split[1]);\n-            do b_option.chain |b| {\n+            do b_option.and_then |b| {\n                 Some(Ratio::new(a.clone(), b.clone()))\n             }\n         }\n@@ -291,10 +291,10 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n         } else {\n             let a_option: Option<T> = FromStrRadix::from_str_radix(split[0],\n                                                                    radix);\n-            do a_option.chain |a| {\n+            do a_option.and_then |a| {\n                 let b_option: Option<T> =\n                     FromStrRadix::from_str_radix(split[1], radix);\n-                do b_option.chain |b| {\n+                do b_option.and_then |b| {\n                     Some(Ratio::new(a.clone(), b.clone()))\n                 }\n             }"}, {"sha": "d51d1c217857140565bb8b144e4817b3a15041c2", "filename": "src/libextra/time.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -442,21 +442,21 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           },\n           'c' => {\n             parse_type(s, pos, 'a', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'b', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'e', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'T', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'Y', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'b', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'e', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'T', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'Y', &mut *tm))\n           }\n           'D' | 'x' => {\n             parse_type(s, pos, 'm', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'd', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'y', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '/'))\n+                .and_then(|pos| parse_type(s, pos, 'd', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '/'))\n+                .and_then(|pos| parse_type(s, pos, 'y', &mut *tm))\n           }\n           'd' => match match_digits_in_range(s, pos, 2u, false, 1_i32,\n                                              31_i32) {\n@@ -475,10 +475,10 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           'F' => {\n             parse_type(s, pos, 'Y', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'm', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'd', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '-'))\n+                .and_then(|pos| parse_type(s, pos, 'm', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '-'))\n+                .and_then(|pos| parse_type(s, pos, 'd', &mut *tm))\n           }\n           'H' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 23_i32) {\n@@ -553,17 +553,17 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           },\n           'R' => {\n             parse_type(s, pos, 'H', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n           }\n           'r' => {\n             parse_type(s, pos, 'I', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'p', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'S', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ' '))\n+                .and_then(|pos| parse_type(s, pos, 'p', &mut *tm))\n           }\n           'S' => {\n             match match_digits_in_range(s, pos, 2u, false, 0_i32, 60_i32) {\n@@ -578,10 +578,10 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           //'s' {}\n           'T' | 'X' => {\n             parse_type(s, pos, 'H', &mut *tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'M', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, ':'))\n+                .and_then(|pos| parse_type(s, pos, 'S', &mut *tm))\n           }\n           't' => parse_char(s, pos, '\\t'),\n           'u' => {\n@@ -596,10 +596,10 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           'v' => {\n             parse_type(s, pos, 'e', &mut *tm)\n-                .chain(|pos|  parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'b', &mut *tm))\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'Y', &mut *tm))\n+                .and_then(|pos|  parse_char(s, pos, '-'))\n+                .and_then(|pos| parse_type(s, pos, 'b', &mut *tm))\n+                .and_then(|pos| parse_char(s, pos, '-'))\n+                .and_then(|pos| parse_type(s, pos, 'Y', &mut *tm))\n           }\n           //'W' {}\n           'w' => {"}, {"sha": "5078d0ded18d129e225bf7d56ccf3031634d38e1", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -961,7 +961,7 @@ pub fn build_output_filenames(input: &input,\n           if !linkage_metas.is_empty() {\n               // But if a linkage meta is present, that overrides\n               let maybe_name = linkage_metas.iter().find(|m| \"name\" == m.name());\n-              match maybe_name.chain(|m| m.value_str()) {\n+              match maybe_name.and_then(|m| m.value_str()) {\n                   Some(s) => stem = s,\n                   _ => ()\n               }"}, {"sha": "2c0068729a72e1ada4c46f16cee9587d56e59158", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -58,7 +58,7 @@ fn filter_view_item<'r>(cx: @Context, view_item: &'r ast::view_item)-> Option<&'\n \n fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n     let filtered_items = do  m.items.iter().filter_map |a| {\n-        filter_item(cx, *a).chain(|x| fld.fold_item(x))\n+        filter_item(cx, *a).and_then(|x| fld.fold_item(x))\n     }.collect();\n     let filtered_view_items = do m.view_items.iter().filter_map |a| {\n         do filter_view_item(cx, a).map_move |x| {\n@@ -139,7 +139,7 @@ fn fold_block(\n     fld: @fold::ast_fold\n ) -> ast::Block {\n     let resulting_stmts = do b.stmts.iter().filter_map |a| {\n-        filter_stmt(cx, *a).chain(|stmt| fld.fold_stmt(stmt))\n+        filter_stmt(cx, *a).and_then(|stmt| fld.fold_stmt(stmt))\n     }.collect();\n     let filtered_view_items = do b.view_items.iter().filter_map |a| {\n         filter_view_item(cx, a).map(|x| fld.fold_view_item(*x))"}, {"sha": "3b563e47426a3ce299763874430e05669a57331c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -184,7 +184,7 @@ fn visit_item(e: &Env, i: @ast::item) {\n             ast::named => {\n                 let link_name = i.attrs.iter()\n                     .find(|at| \"link_name\" == at.name())\n-                    .chain(|at| at.value_str());\n+                    .and_then(|at| at.value_str());\n \n                 let foreign_name = match link_name {\n                         Some(nn) => {"}, {"sha": "c94151095a442fafbe916130de919ab95a2db5d7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -210,7 +210,7 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n-    do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n+    do reader::maybe_get_doc(d, tag_disr_val).and_then |val_doc| {\n         do reader::with_doc_data(val_doc) |data| { u64::parse_bytes(data, 10u) }\n     }\n }"}, {"sha": "267ac8b2f4df20ea77a6f57b267b86790e89c150", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -505,7 +505,10 @@ impl get_node_info for ast::Block {\n \n impl get_node_info for Option<@ast::Expr> {\n     fn info(&self) -> Option<NodeInfo> {\n-        self.chain_ref(|s| s.info())\n+        match *self {\n+            Some(ref s) => s.info(),\n+            None => None,\n+        }\n     }\n }\n "}, {"sha": "a33f2bd3a557ef9c5b891ff6cdaedb05c69fe804", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -50,9 +50,9 @@ impl Value {\n     /// must be the only user of this value, and there must not be any conditional\n     /// branches between the store and the given block.\n     pub fn get_dominating_store(self, bcx: @mut Block) -> Option<Value> {\n-        match self.get_single_user().chain(|user| user.as_store_inst()) {\n+        match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n-                do store.get_parent().chain |store_bb| {\n+                do store.get_parent().and_then |store_bb| {\n                     let mut bb = BasicBlock(bcx.llbb);\n                     let mut ret = Some(store);\n                     while *bb != *store_bb {\n@@ -150,7 +150,7 @@ impl Iterator<Value> for UserIterator {\n     fn next(&mut self) -> Option<Value> {\n         let current = self.next;\n \n-        self.next = do current.chain |u| { u.get_next_use() };\n+        self.next = do current.and_then |u| { u.get_next_use() };\n \n         do current.map |u| { u.get_user() }\n     }"}, {"sha": "f942638a8adfe3d78be89f7e576b6cc373ac07a0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -745,10 +745,17 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n                           RegionParamNames(bound_lifetime_names.clone()));\n \n     let input_tys = do decl.inputs.iter().enumerate().map |(i, a)| {\n-        let expected_arg_ty = do expected_sig.chain_ref |e| {\n-            // no guarantee that the correct number of expected args\n-            // were supplied\n-            if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n+        let expected_arg_ty = match expected_sig {\n+            Some(ref e) => {\n+                // no guarantee that the correct number of expected args\n+                // were supplied\n+                if i < e.inputs.len() {\n+                    Some(e.inputs[i])\n+                } else {\n+                    None\n+                }\n+            }\n+            None => None,\n         };\n         ty_of_arg(this, &rb, a, expected_arg_ty)\n     }.collect();"}, {"sha": "cdfb8732a38aaa29962c1b1b27a5274409bf912e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -15,7 +15,7 @@\n // the trait `Combine` and contains methods for combining two\n // instances of various things and yielding a new instance.  These\n // combiner methods always yield a `result<T>`---failure is propagated\n-// upward using `chain()` methods.  There is a lot of common code for\n+// upward using `and_then()` methods.  There is a lot of common code for\n // these operations, implemented as default methods on the `Combine`\n // trait.\n //\n@@ -108,7 +108,7 @@ pub trait Combine {\n             (Some(a), Some(b)) => {\n                 // FIXME(#5781) this should be eq_tys\n                 // eq_tys(self, a, b).then(|| Ok(Some(a)) )\n-                self.contratys(a, b).chain(|t| Ok(Some(t)))\n+                self.contratys(a, b).and_then(|t| Ok(Some(t)))\n             }\n             (None, Some(_)) |\n                 (Some(_), None) => {\n@@ -162,13 +162,13 @@ pub trait Combine {\n                                 }\n \n                                 ty::rv_covariant => {\n-                                    do this.regions(a_r, b_r).chain |r| {\n+                                    do this.regions(a_r, b_r).and_then |r| {\n                                         Ok(ty::NonerasedRegions(opt_vec::with(r)))\n                                     }\n                                 }\n \n                                 ty::rv_contravariant => {\n-                                    do this.contraregions(a_r, b_r).chain |r| {\n+                                    do this.contraregions(a_r, b_r).and_then |r| {\n                                         Ok(ty::NonerasedRegions(opt_vec::with(r)))\n                                     }\n                                 }\n@@ -179,12 +179,12 @@ pub trait Combine {\n             }\n         }\n \n-        do self.tps(as_.tps, bs.tps).chain |tps| {\n-            do self.self_tys(as_.self_ty, bs.self_ty).chain |self_ty| {\n+        do self.tps(as_.tps, bs.tps).and_then |tps| {\n+            do self.self_tys(as_.self_ty, bs.self_ty).and_then |self_ty| {\n                 do relate_region_params(self,\n                                         generics,\n                                         &as_.regions,\n-                                        &bs.regions).chain |regions| {\n+                                        &bs.regions).and_then |regions| {\n                     Ok(substs {\n                             regions: regions,\n                             self_ty: self_ty,\n@@ -227,8 +227,8 @@ pub trait Combine {\n     fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n         if a.ident == b.ident {\n             self.mts(&a.mt, &b.mt)\n-                .chain(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n-                .chain_err(|e| Err(ty::terr_in_field(@e, a.ident)) )\n+                .and_then(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n+                .or_else(|e| Err(ty::terr_in_field(@e, a.ident)) )\n         } else {\n             Err(ty::terr_record_fields(\n                                        expected_found(self,\n@@ -238,7 +238,7 @@ pub trait Combine {\n     }\n \n     fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        do self.contratys(a, b).chain |t| {\n+        do self.contratys(a, b).and_then |t| {\n             Ok(t)\n         }\n     }\n@@ -274,7 +274,7 @@ pub trait Combine {\n \n         match (a, b) {\n             (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n-                do self.contraregions(a_r, b_r).chain |r| {\n+                do self.contraregions(a_r, b_r).and_then |r| {\n                     Ok(ty::vstore_slice(r))\n                 }\n             }\n@@ -299,7 +299,7 @@ pub trait Combine {\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n-                do self.contraregions(a_r, b_r).chain |r| {\n+                do self.contraregions(a_r, b_r).and_then |r| {\n                     Ok(ty::RegionTraitStore(r))\n                 }\n             }\n@@ -357,7 +357,7 @@ pub fn expected_found<C:Combine,T>(\n pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n     let suber = this.sub();\n     do this.infcx().try {\n-        do suber.tys(a, b).chain |_ok| {\n+        do suber.tys(a, b).and_then |_ok| {\n             suber.contratys(a, b)\n         }.to_ures()\n     }\n@@ -371,10 +371,10 @@ pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n     let sub = this.sub();\n     do indent {\n         this.infcx().try(|| {\n-            do sub.regions(a, b).chain |_r| {\n+            do sub.regions(a, b).and_then |_r| {\n                 sub.contraregions(a, b)\n             }\n-        }).chain_err(|e| {\n+        }).or_else(|e| {\n             // substitute a better error, but use the regions\n             // found in the original error\n             match e {\n@@ -427,8 +427,8 @@ pub fn super_fn_sigs<C:Combine>(\n     }\n \n     do argvecs(this, a.inputs, b.inputs)\n-            .chain |inputs| {\n-        do this.tys(a.output, b.output).chain |output| {\n+            .and_then |inputs| {\n+        do this.tys(a.output, b.output).and_then |output| {\n             Ok(FnSig {bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n                       inputs: inputs.clone(),\n                       output: output})\n@@ -508,7 +508,7 @@ pub fn super_tys<C:Combine>(\n        &ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n           let type_def = ty::lookup_item_type(tcx, a_id);\n-          do this.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+          do this.substs(&type_def.generics, a_substs, b_substs).and_then |substs| {\n               Ok(ty::mk_enum(tcx, a_id, substs))\n           }\n       }\n@@ -517,9 +517,9 @@ pub fn super_tys<C:Combine>(\n        &ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl, b_bounds))\n       if a_id == b_id && a_mutbl == b_mutbl => {\n           let trait_def = ty::lookup_trait_def(tcx, a_id);\n-          do this.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n-              do this.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n-                  do this.bounds(a_bounds, b_bounds).chain |bounds| {\n+          do this.substs(&trait_def.generics, a_substs, b_substs).and_then |substs| {\n+              do this.trait_stores(ty::terr_trait, a_store, b_store).and_then |s| {\n+                  do this.bounds(a_bounds, b_bounds).and_then |bounds| {\n                     Ok(ty::mk_trait(tcx,\n                                     a_id,\n                                     substs.clone(),\n@@ -534,25 +534,25 @@ pub fn super_tys<C:Combine>(\n       (&ty::ty_struct(a_id, ref a_substs), &ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n           let type_def = ty::lookup_item_type(tcx, a_id);\n-          do this.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+          do this.substs(&type_def.generics, a_substs, b_substs).and_then |substs| {\n               Ok(ty::mk_struct(tcx, a_id, substs))\n           }\n       }\n \n       (&ty::ty_box(ref a_mt), &ty::ty_box(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).and_then |mt| {\n             Ok(ty::mk_box(tcx, mt))\n         }\n       }\n \n       (&ty::ty_uniq(ref a_mt), &ty::ty_uniq(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).and_then |mt| {\n             Ok(ty::mk_uniq(tcx, mt))\n         }\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).and_then |mt| {\n             Ok(ty::mk_ptr(tcx, mt))\n         }\n       }\n@@ -564,15 +564,15 @@ pub fn super_tys<C:Combine>(\n       }\n \n       (&ty::ty_evec(ref a_mt, vs_a), &ty::ty_evec(ref b_mt, vs_b)) => {\n-        do this.mts(a_mt, b_mt).chain |mt| {\n-            do this.vstores(ty::terr_vec, vs_a, vs_b).chain |vs| {\n+        do this.mts(a_mt, b_mt).and_then |mt| {\n+            do this.vstores(ty::terr_vec, vs_a, vs_b).and_then |vs| {\n                 Ok(ty::mk_evec(tcx, mt, vs))\n             }\n         }\n       }\n \n       (&ty::ty_estr(vs_a), &ty::ty_estr(vs_b)) => {\n-        do this.vstores(ty::terr_str, vs_a, vs_b).chain |vs| {\n+        do this.vstores(ty::terr_str, vs_a, vs_b).and_then |vs| {\n             Ok(ty::mk_estr(tcx,vs))\n         }\n       }\n@@ -581,21 +581,21 @@ pub fn super_tys<C:Combine>(\n         if as_.len() == bs.len() {\n             result::collect(as_.iter().zip(bs.iter())\n                             .map(|(a, b)| this.tys(*a, *b)))\n-                    .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n+                    .and_then(|ts| Ok(ty::mk_tup(tcx, ts)) )\n         } else {\n             Err(ty::terr_tuple_size(\n                 expected_found(this, as_.len(), bs.len())))\n         }\n       }\n \n       (&ty::ty_bare_fn(ref a_fty), &ty::ty_bare_fn(ref b_fty)) => {\n-        do this.bare_fn_tys(a_fty, b_fty).chain |fty| {\n+        do this.bare_fn_tys(a_fty, b_fty).and_then |fty| {\n             Ok(ty::mk_bare_fn(tcx, fty))\n         }\n       }\n \n       (&ty::ty_closure(ref a_fty), &ty::ty_closure(ref b_fty)) => {\n-        do this.closure_tys(a_fty, b_fty).chain |fty| {\n+        do this.closure_tys(a_fty, b_fty).and_then |fty| {\n             Ok(ty::mk_closure(tcx, fty))\n         }\n       }"}, {"sha": "af62da5fde03333fb5475c8af3150dffce26eae9", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -61,7 +61,7 @@ impl Combine for Glb {\n           // If one side or both is immutable, we can use the GLB of\n           // both sides but mutbl must be `MutImmutable`.\n           (MutImmutable, MutImmutable) => {\n-            self.tys(a.ty, b.ty).chain(|t| {\n+            self.tys(a.ty, b.ty).and_then(|t| {\n                 Ok(ty::mt {ty: t, mutbl: MutImmutable})\n             })\n           }"}, {"sha": "4cbdf9fa1fb8bc2f9ece3c7e890b00de63701a46", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -232,7 +232,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n             (&Some(_),       &None) => Ok((*a).clone()),\n             (&None,          &Some(_)) => Ok((*b).clone()),\n             (&Some(ref v_a), &Some(ref v_b)) => {\n-                do lattice_op(self, v_a, v_b).chain |v| {\n+                do lattice_op(self, v_a, v_b).and_then |v| {\n                     Ok(Some(v))\n                 }\n             }"}, {"sha": "260bc93611e963ffef7f42fd93e0d1e0235cd1b1", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -62,15 +62,15 @@ impl Combine for Lub {\n         let m = a.mutbl;\n         match m {\n           MutImmutable => {\n-            self.tys(a.ty, b.ty).chain(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n+            self.tys(a.ty, b.ty).and_then(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n           }\n \n           MutMutable => {\n             self.infcx.try(|| {\n                 eq_tys(self, a.ty, b.ty).then(|| {\n                     Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n-            }).chain_err(|e| Err(e))\n+            }).or_else(|e| Err(e))\n           }\n         }\n     }"}, {"sha": "e73a36de143cca925f318e91ddfbb7bc21121d85", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -451,7 +451,7 @@ trait then {\n impl then for ures {\n     fn then<T:Clone>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n-        self.chain(|_i| f())\n+        self.and_then(|_i| f())\n     }\n }\n \n@@ -474,7 +474,7 @@ trait CresCompare<T> {\n \n impl<T:Clone + Eq> CresCompare<T> for cres<T> {\n     fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n-        do (*self).clone().chain |s| {\n+        do (*self).clone().and_then |s| {\n             if s == t {\n                 (*self).clone()\n             } else {"}, {"sha": "57ebb2185d16587f3bb395423206342a8f22f10c", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -79,7 +79,7 @@ impl Combine for Sub {\n           }\n           MutImmutable => {\n             // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).chain(|_t| Ok(*a) )\n+            self.tys(a.ty, b.ty).and_then(|_t| Ok(*a) )\n           }\n         }\n     }"}, {"sha": "1967122745dad5ebfaa98895dbebd991fd0fa8fd", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -202,7 +202,7 @@ impl RegionScope for MethodRscope {\n         if !self.region_param_names.has_ident(id) {\n             return RegionParamNames::undeclared_name(None);\n         }\n-        do EmptyRscope.named_region(span, id).chain_err |_e| {\n+        do EmptyRscope.named_region(span, id).or_else |_e| {\n             result::Err(RegionError {\n                 msg: ~\"lifetime is not in scope\",\n                 replacement: ty::re_bound(ty::br_self)\n@@ -251,7 +251,7 @@ impl RegionScope for TypeRscope {\n     }\n     fn named_region(&self, span: Span, id: ast::Ident)\n                       -> Result<ty::Region, RegionError> {\n-        do EmptyRscope.named_region(span, id).chain_err |_e| {\n+        do EmptyRscope.named_region(span, id).or_else |_e| {\n             result::Err(RegionError {\n                 msg: ~\"only 'self is allowed as part of a type declaration\",\n                 replacement: self.replacement()\n@@ -310,7 +310,7 @@ impl RegionScope for BindingRscope {\n                     span: Span,\n                     id: ast::Ident) -> Result<ty::Region, RegionError>\n     {\n-        do self.base.named_region(span, id).chain_err |_e| {\n+        do self.base.named_region(span, id).or_else |_e| {\n             let result = ty::re_bound(ty::br_named(id));\n             if self.region_param_names.has_ident(id) {\n                 result::Ok(result)"}, {"sha": "ff6401456b6b9965d37616b3d870ce698544606a", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -138,30 +138,30 @@ fn config_from_opts(\n \n     let config = default_config(input_crate);\n     let result = result::Ok(config);\n-    let result = do result.chain |config| {\n+    let result = do result.and_then |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = output_dir.map_move(|s| Path(s));\n         result::Ok(Config {\n             output_dir: output_dir.unwrap_or(config.output_dir.clone()),\n             .. config\n         })\n     };\n-    let result = do result.chain |config| {\n+    let result = do result.and_then |config| {\n         let output_format = getopts::opt_maybe_str(matches, opt_output_format());\n         do output_format.map_move_default(result::Ok(config.clone())) |output_format| {\n-            do parse_output_format(output_format).chain |output_format| {\n+            do parse_output_format(output_format).and_then |output_format| {\n                 result::Ok(Config {\n                     output_format: output_format,\n                     .. config.clone()\n                 })\n             }\n         }\n     };\n-    let result = do result.chain |config| {\n+    let result = do result.and_then |config| {\n         let output_style =\n             getopts::opt_maybe_str(matches, opt_output_style());\n         do output_style.map_move_default(result::Ok(config.clone())) |output_style| {\n-            do parse_output_style(output_style).chain |output_style| {\n+            do parse_output_style(output_style).and_then |output_style| {\n                 result::Ok(Config {\n                     output_style: output_style,\n                     .. config.clone()\n@@ -170,11 +170,11 @@ fn config_from_opts(\n         }\n     };\n     let process_output = Cell::new(process_output);\n-    let result = do result.chain |config| {\n+    let result = do result.and_then |config| {\n         let pandoc_cmd = getopts::opt_maybe_str(matches, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n             &config, pandoc_cmd, process_output.take());\n-        do pandoc_cmd.chain |pandoc_cmd| {\n+        do pandoc_cmd.and_then |pandoc_cmd| {\n             result::Ok(Config {\n                 pandoc_cmd: pandoc_cmd,\n                 .. config.clone()"}, {"sha": "6eb4cc56a2bdde1cd322831a7804f17a8f7d1e5e", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -118,7 +118,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n         if !l.is_whitespace() {\n             output = Some(l);\n         }\n-        match output.chain(try_parsing_version) {\n+        match output.and_then(try_parsing_version) {\n             Some(v) => return Some(v),\n             None    => ()\n         }\n@@ -158,7 +158,7 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n                 }\n             }\n \n-            output.chain(try_parsing_version)\n+            output.and_then(try_parsing_version)\n         }\n         else {\n             None"}, {"sha": "2ca36de4f49cce83a79c69e1736c49027abfca25", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -1618,7 +1618,7 @@ impl<T:Writer> WriterUtil for T {\n }\n \n pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n-    mk_file_writer(path, flags).chain(|w| Ok(w))\n+    mk_file_writer(path, flags).and_then(|w| Ok(w))\n }\n \n \n@@ -1779,7 +1779,7 @@ pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n }\n \n pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n-    do read_whole_file(file).chain |bytes| {\n+    do read_whole_file(file).and_then |bytes| {\n         if str::is_utf8(bytes) {\n             Ok(str::from_utf8(bytes))\n         } else {\n@@ -1791,7 +1791,7 @@ pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n-    do file_reader(file).chain |rdr| {\n+    do file_reader(file).and_then |rdr| {\n         Ok(rdr.read_whole_stream())\n     }\n }"}, {"sha": "f36fb2d98bdfdebfad7016684f2c976f7d377d57", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -1474,7 +1474,7 @@ pub struct Scan<'self, A, B, T, St> {\n impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'self, A, B, T, St> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.iter.next().chain(|a| (self.f)(&mut self.state, a))\n+        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n     }\n \n     #[inline]\n@@ -1494,8 +1494,7 @@ pub struct FlatMap<'self, A, T, U> {\n     priv backiter: Option<U>,\n }\n \n-impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n-    FlatMap<'self, A, T, U> {\n+impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'self, A, T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n@@ -1505,7 +1504,12 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n                 }\n             }\n             match self.iter.next().map_move(|x| (self.f)(x)) {\n-                None => return self.backiter.chain_mut_ref(|it| it.next()),\n+                None => {\n+                    return match self.backiter {\n+                        Some(ref mut it) => it.next(),\n+                        None => None,\n+                    };\n+                }\n                 next => self.frontiter = next,\n             }\n         }\n@@ -1537,7 +1541,12 @@ impl<'self,\n                 }\n             }\n             match self.iter.next_back().map_move(|x| (self.f)(x)) {\n-                None => return self.frontiter.chain_mut_ref(|it| it.next_back()),\n+                None => {\n+                    return match self.frontiter {\n+                        Some(ref mut it) => it.next_back(),\n+                        None => None,\n+                    };\n+                }\n                 next => self.backiter = next,\n             }\n         }"}, {"sha": "9b5b28d5cebb830fa4ff40e821d71e46f8e4f923", "filename": "src/libstd/option.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -141,9 +141,9 @@ impl<T> Option<T> {\n     /// Returns `None` if the option is `None`, otherwise calls and returns the\n     /// value of `f`.\n     #[inline]\n-    pub fn and_then(self, f: &fn() -> Option<T>) -> Option<T> {\n+    pub fn and_then<U>(self, f: &fn(T) -> Option<U>) -> Option<U> {\n         match self {\n-            Some(_) => f(),\n+            Some(x) => f(x),\n             None => None,\n         }\n     }\n@@ -167,36 +167,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Update an optional value by optionally running its content through a\n-    /// function that returns an option.\n-    #[inline]\n-    pub fn chain<U>(self, f: &fn(T) -> Option<U>) -> Option<U> {\n-        match self {\n-            Some(t) => f(t),\n-            None => None\n-        }\n-    }\n-\n-    /// Update an optional value by optionally running its content by reference\n-    /// through a function that returns an option.\n-    #[inline]\n-    pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n-        match *self {\n-            Some(ref x) => f(x),\n-            None => None\n-        }\n-    }\n-\n-    /// Update an optional value by optionally running its content by mut reference\n-    /// through a function that returns an option.\n-    #[inline]\n-    pub fn chain_mut_ref<'a, U>(&'a mut self, f: &fn(x: &'a mut T) -> Option<U>) -> Option<U> {\n-        match *self {\n-            Some(ref mut x) => f(x),\n-            None => None\n-        }\n-    }\n-\n     /// Filters an optional value using given function.\n     #[inline(always)]\n     pub fn filtered(self, f: &fn(t: &T) -> bool) -> Option<T> {\n@@ -637,12 +607,12 @@ mod tests {\n     #[test]\n     fn test_and_then() {\n         let x: Option<int> = Some(1);\n-        assert_eq!(x.and_then(|| Some(2)), Some(2));\n-        assert_eq!(x.and_then(|| None), None);\n+        assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n+        assert_eq!(x.and_then(|_| None::<int>), None);\n \n         let x: Option<int> = None;\n-        assert_eq!(x.and_then(|| Some(2)), None);\n-        assert_eq!(x.and_then(|| None), None);\n+        assert_eq!(x.and_then(|x| Some(x + 1)), None);\n+        assert_eq!(x.and_then(|_| None::<int>), None);\n     }\n \n     #[test]"}, {"sha": "3811f34cec43c1d5f0d4ebe32501dfdfd5eaa18b", "filename": "src/libstd/result.rs", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -171,10 +171,22 @@ impl<T, E: ToStr> Result<T, E> {\n         }\n     }\n \n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok`, then `res` it is returned. If `self` is `Err`,\n+    /// then `self` is returned.\n+    #[inline]\n+    pub fn and(self, res: Result<T, E>) -> Result<T, E> {\n+        match self {\n+            Ok(_) => res,\n+            Err(_) => self,\n+        }\n+    }\n+\n     /// Call a method based on a previous result\n     ///\n     /// If `self` is `Ok` then the value is extracted and passed to `op`\n-    /// whereupon `op`s result is returned. if `self` is `Err` then it is\n+    /// whereupon `op`s result is returned. If `self` is `Err` then it is\n     /// immediately returned. This function can be used to compose the results\n     /// of two functions.\n     ///\n@@ -184,21 +196,33 @@ impl<T, E: ToStr> Result<T, E> {\n     ///         Ok(parse_bytes(buf))\n     ///     };\n     #[inline]\n-    pub fn chain<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n+    pub fn and_then<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n             Err(e) => Err(e),\n         }\n     }\n \n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok`, then `self` is returned. If `self` is `Err`\n+    /// then `res` is returned.\n+    #[inline]\n+    pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n+        match self {\n+            Ok(_) => self,\n+            Err(_) => res,\n+        }\n+    }\n+\n     /// Call a function based on a previous result\n     ///\n     /// If `self` is `Err` then the value is extracted and passed to `op`\n     /// whereupon `op`s result is returned. if `self` is `Ok` then it is\n     /// immediately returned.  This function can be used to pass through a\n     /// successful result while handling an error.\n     #[inline]\n-    pub fn chain_err<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n+    pub fn or_else<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n             Err(e) => op(e),\n@@ -430,21 +454,42 @@ mod tests {\n     use vec::ImmutableVector;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n+    pub fn op2() -> Result<int, ~str> { Err(~\"sadface\") }\n+\n+    #[test]\n+    pub fn test_and() {\n+        assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n+        assert_eq!(op1().and(Err(~\"bad\")).unwrap_err(), ~\"bad\");\n \n-    pub fn op2(i: int) -> Result<uint, ~str> {\n-        Ok(i as uint + 1u)\n+        assert_eq!(op2().and(Ok(667)).unwrap_err(), ~\"sadface\");\n+        assert_eq!(op2().and(Err(~\"bad\")).unwrap_err(), ~\"sadface\");\n     }\n \n-    pub fn op3() -> Result<int, ~str> { Err(~\"sadface\") }\n+    #[test]\n+    pub fn test_and_then() {\n+        assert_eq!(op1().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap(), 667);\n+        assert_eq!(op1().and_then(|_| Err::<int, ~str>(~\"bad\")).unwrap_err(), ~\"bad\");\n+\n+        assert_eq!(op2().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap_err(), ~\"sadface\");\n+        assert_eq!(op2().and_then(|_| Err::<int, ~str>(~\"bad\")).unwrap_err(), ~\"sadface\");\n+    }\n \n     #[test]\n-    pub fn chain_success() {\n-        assert_eq!(op1().chain(op2).unwrap(), 667u);\n+    pub fn test_or() {\n+        assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n+        assert_eq!(op1().or(Err(~\"bad\")).unwrap(), 666);\n+\n+        assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n+        assert_eq!(op2().or(Err(~\"bad\")).unwrap_err(), ~\"bad\");\n     }\n \n     #[test]\n-    pub fn chain_failure() {\n-        assert_eq!(op3().chain( op2).unwrap_err(), ~\"sadface\");\n+    pub fn test_or_else() {\n+        assert_eq!(op1().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 666);\n+        assert_eq!(op1().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap(), 666);\n+\n+        assert_eq!(op2().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 667);\n+        assert_eq!(op2().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap_err(), ~\"sadface!\");\n     }\n \n     #[test]"}, {"sha": "041253455f01a48cad69e6defa0159dc04bf57cb", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -177,7 +177,7 @@ impl<'self> Parser<'self> {\n         }\n \n         do self.read_atomically |p| {\n-            p.read_char().chain(|c| parse_digit(c, radix))\n+            p.read_char().and_then(|c| parse_digit(c, radix))\n         }\n     }\n "}, {"sha": "295485d6f6efaa7a30a4e29a3baaafedec2e3e66", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -187,12 +187,12 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n                                  -> Option<@str> {\n     attrs.iter()\n         .find(|at| name == at.name())\n-        .chain(|at| at.value_str())\n+        .and_then(|at| at.value_str())\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<@str> {\n-    items.rev_iter().find(|mi| name == mi.name()).chain(|i| i.value_str())\n+    items.rev_iter().find(|mi| name == mi.name()).and_then(|i| i.value_str())\n }\n \n /* Higher-level applications */"}, {"sha": "4d62285cf6ee8e5a5c58982a684ce83a0b6c005e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=38f97ea10313ba9a8c6f57fbf73ff8daf5376e8b", "patch": "@@ -331,11 +331,18 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n     };\n \n     let maybe_it = match expanded {\n-        MRItem(it) => mark_item(it,fm).chain(|i| {fld.fold_item(i)}),\n-        MRExpr(_) => cx.span_fatal(pth.span,\n-                                   fmt!(\"expr macro in item position: %s\", extnamestr)),\n-        MRAny(_, item_maker, _) => item_maker().chain(|i| {mark_item(i,fm)})\n-                                      .chain(|i| {fld.fold_item(i)}),\n+        MRItem(it) => {\n+            mark_item(it,fm)\n+                .and_then(|i| fld.fold_item(i))\n+        }\n+        MRExpr(_) => {\n+            cx.span_fatal(pth.span, fmt!(\"expr macro in item position: %s\", extnamestr))\n+        }\n+        MRAny(_, item_maker, _) => {\n+            item_maker()\n+                .and_then(|i| mark_item(i,fm))\n+                .and_then(|i| fld.fold_item(i))\n+        }\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one."}]}