{"sha": "64f75977764439f500f58ed6f2ac6db4873b250a", "node_id": "C_kwDOAAsO6NoAKDY0Zjc1OTc3NzY0NDM5ZjUwMGY1OGVkNmYyYWM2ZGI0ODczYjI1MGE", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-04-08T19:37:41Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-04-10T20:16:53Z"}, "message": "Migrate most of `rustc_builtin_macros` to diagnostic impls\n\nCo-authored-by: Joe ST <joe@fbstj.net>\nCo-authored-by: Michael Goulet <michael@errs.io>", "tree": {"sha": "774109c31b41752d791d0ceba7609d23e7a71601", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/774109c31b41752d791d0ceba7609d23e7a71601"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64f75977764439f500f58ed6f2ac6db4873b250a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64f75977764439f500f58ed6f2ac6db4873b250a", "html_url": "https://github.com/rust-lang/rust/commit/64f75977764439f500f58ed6f2ac6db4873b250a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64f75977764439f500f58ed6f2ac6db4873b250a/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6f6104a1f62a0eec7d2e2ccdc07709fcc4c83f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f6104a1f62a0eec7d2e2ccdc07709fcc4c83f0", "html_url": "https://github.com/rust-lang/rust/commit/b6f6104a1f62a0eec7d2e2ccdc07709fcc4c83f0"}], "stats": {"total": 1327, "additions": 978, "deletions": 349}, "files": [{"sha": "83dc1ac50e55dff3ee6f9894f5c5ec6548f333ed", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -3,3 +3,149 @@ builtin_macros_requires_cfg_pattern =\n     .label = cfg-pattern required\n \n builtin_macros_expected_one_cfg_pattern = expected 1 cfg-pattern\n+\n+builtin_macros_alloc_error_must_be_fn = alloc_error_handler must be a function\n+\n+builtin_macros_assert_requires_boolean = macro requires a boolean expression as an argument\n+    .label = boolean expression required\n+\n+builtin_macros_assert_requires_expression = macro requires an expression as an argument\n+    .suggestion = try removing semicolon\n+\n+builtin_macros_assert_missing_comma = unexpected string literal\n+    .suggestion = try adding a comma\n+\n+builtin_macros_cfg_accessible_unspecified_path = `cfg_accessible` path is not specified\n+builtin_macros_cfg_accessible_multiple_paths = multiple `cfg_accessible` paths are specified\n+builtin_macros_cfg_accessible_literal_path = `cfg_accessible` path cannot be a literal\n+builtin_macros_cfg_accessible_has_args = `cfg_accessible` path cannot accept arguments\n+\n+builtin_macros_cfg_accessible_indeterminate = cannot determine whether the path is accessible or not\n+\n+builtin_macros_concat_bytestr = cannot concatenate a byte string literal\n+\n+builtin_macros_concat_missing_literal = expected a literal\n+    .note = only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n+\n+builtin_macros_concat_bytes_missing_literal = expected a byte literal\n+    .note = only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n+\n+builtin_macros_concat_bytes_invalid = cannot concatenate {$lit_kind} literals\n+    .byte_char = try using a byte character\n+    .byte_str = try using a byte string\n+    .number_array = try wrapping the number in an array\n+\n+builtin_macros_concat_bytes_oob = numeric literal is out of bounds\n+\n+builtin_macros_concat_bytes_non_u8 = numeric literal is not a `u8`\n+\n+builtin_macros_concat_bytes_array = cannot concatenate doubly nested array\n+    .note = byte strings are treated as arrays of bytes\n+    .help = try flattening the array\n+\n+builtin_macros_concat_bytes_bad_repeat = repeat count is not a positive number\n+\n+builtin_macros_concat_idents_missing_args = `concat_idents!()` takes 1 or more arguments\n+builtin_macros_concat_idents_missing_comma = `concat_idents!()` expecting comma\n+builtin_macros_concat_idents_ident_args = `concat_idents!()` requires ident args\n+\n+builtin_macros_bad_derive_target = `derive` may only be applied to `struct`s, `enum`s and `union`s\n+    .label = not applicable here\n+    .label2 = not a `struct`, `enum` or `union`\n+\n+builtin_macros_unexpected_lit = expected path to a trait, found literal\n+    .label = not a trait\n+    .str_lit = try using `#[derive({$sym})]`\n+    .other = for example, write `#[derive(Debug)]` for `Debug`\n+\n+builtin_macros_derive_path_args_list = traits in `#[derive(...)]` don't accept arguments\n+    .suggestion = remove the arguments\n+\n+builtin_macros_derive_path_args_value = traits in `#[derive(...)]` don't accept values\n+    .suggestion = remove the value\n+\n+builtin_macros_derive_macro_call = `derive` cannot be used on items with type macros\n+\n+builtin_macros_cannot_derive_union = this trait cannot be derived for unions\n+\n+builtin_macros_no_default_variant = no default declared\n+    .help = make a unit variant default by placing `#[default]` above it\n+    .suggestion = make `{$ident}` default\n+\n+builtin_macros_multiple_defaults = multiple declared defaults\n+    .label = first default\n+    .additional = additional default\n+    .note = only one variant can be default\n+    .suggestion = make `{$ident}` default\n+\n+builtin_macros_non_unit_default = the `#[default]` attribute may only be used on unit enum variants\n+    .help = consider a manual implementation of `Default`\n+\n+builtin_macros_non_exhaustive_default = default variant must be exhaustive\n+    .label = declared `#[non_exhaustive]` here\n+    .help = consider a manual implementation of `Default`\n+\n+builtin_macros_multiple_default_attrs = multiple `#[default]` attributes\n+    .note = only one `#[default]` attribute is needed\n+    .label = `#[default]` used here\n+    .label_again = `#[default]` used again here\n+    .help = try removing {$only_one ->\n+    [true] this\n+    *[false] these\n+    }\n+\n+builtin_macros_default_arg = `#[default]` attribute does not accept a value\n+    .suggestion = try using `#[default]`\n+\n+builtin_macros_env_takes_args = `env!()` takes 1 or 2 arguments\n+\n+builtin_macros_env_not_defined = environment variable `{$var}` not defined at compile time\n+    .cargo = Cargo sets build script variables at run time. Use `std::env::var(\"{$var}\")` instead\n+    .other = use `std::env::var(\"{$var}\")` to read the variable at run time\n+\n+builtin_macros_format_requires_string = requires at least a format string argument\n+\n+builtin_macros_format_duplicate_arg = duplicate argument named `{$ident}`\n+    .label1 = previously here\n+    .label2 = duplicate argument\n+\n+builtin_macros_format_positional_after_named = positional arguments cannot follow named arguments\n+    .label = positional arguments must be before named arguments\n+    .named_args = named argument\n+\n+builtin_macros_format_string_invalid = invalid format string: {$desc}\n+    .label = {$label1} in format string\n+    .note = {$note}\n+    .second_label = {$label}\n+\n+builtin_macros_sugg = consider using a positional formatting argument instead\n+\n+builtin_macros_format_no_arg_named = there is no argument named `{$name}`\n+    .note = did you intend to capture a variable `{$name}` from the surrounding scope?\n+    .note2 = to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n+\n+builtin_macros_format_unknown_trait = unknown format trait `{$ty}`\n+    .note = the only appropriate formatting traits are:\n+                                            - ``, which uses the `Display` trait\n+                                            - `?`, which uses the `Debug` trait\n+                                            - `e`, which uses the `LowerExp` trait\n+                                            - `E`, which uses the `UpperExp` trait\n+                                            - `o`, which uses the `Octal` trait\n+                                            - `p`, which uses the `Pointer` trait\n+                                            - `b`, which uses the `Binary` trait\n+                                            - `x`, which uses the `LowerHex` trait\n+                                            - `X`, which uses the `UpperHex` trait\n+    .suggestion = use the `{$trait_name}` trait\n+\n+builtin_macros_format_unused_arg = {$named ->\n+    [true] named argument\n+    *[false] argument\n+    } never used\n+\n+builtin_macros_format_unused_args = multiple unused formatting arguments\n+    .label = multiple missing formatting specifiers\n+\n+builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n+    [one] argument\n+    *[more] arguments\n+    } in format string, but {$desc}"}, {"sha": "82bae9157e79d173e760a685968bafa4fa090a72", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use crate::util::check_builtin_macro_attribute;\n \n use rustc_ast::ptr::P;\n@@ -31,7 +32,7 @@ pub fn expand(\n         {\n             (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n         } else {\n-            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"alloc_error_handler must be a function\");\n+            ecx.sess.parse_sess.span_diagnostic.emit_err(errors::AllocErrorMustBeFn {span: item.span() });\n             return vec![orig_item];\n         };\n "}, {"sha": "0de424be2f161e24aae34d9391ef372feeb02cbb", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,12 +1,13 @@\n mod context;\n \n use crate::edition_panic::use_panic_2021;\n+use crate::errors;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n use rustc_ast::{DelimArgs, Expr, ExprKind, MacCall, MacDelimiter, Path, PathSegment, UnOp};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::PResult;\n use rustc_expand::base::{DummyResult, ExtCtxt, MacEager, MacResult};\n use rustc_parse::parser::Parser;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -114,9 +115,7 @@ fn parse_assert<'a>(cx: &mut ExtCtxt<'a>, sp: Span, stream: TokenStream) -> PRes\n     let mut parser = cx.new_parser_from_tts(stream);\n \n     if parser.token == token::Eof {\n-        let mut err = cx.struct_span_err(sp, \"macro requires a boolean expression as an argument\");\n-        err.span_label(sp, \"boolean expression required\");\n-        return Err(err);\n+        return Err(cx.create_err(errors::AssertRequiresBoolean { span: sp }));\n     }\n \n     let cond_expr = parser.parse_expr()?;\n@@ -129,15 +128,7 @@ fn parse_assert<'a>(cx: &mut ExtCtxt<'a>, sp: Span, stream: TokenStream) -> PRes\n     //\n     // Emit an error about semicolon and suggest removing it.\n     if parser.token == token::Semi {\n-        let mut err = cx.struct_span_err(sp, \"macro requires an expression as an argument\");\n-        err.span_suggestion(\n-            parser.token.span,\n-            \"try removing semicolon\",\n-            \"\",\n-            Applicability::MaybeIncorrect,\n-        );\n-        err.emit();\n-\n+        cx.emit_err(errors::AssertRequiresExpression { span: sp, token: parser.token.span });\n         parser.bump();\n     }\n \n@@ -149,15 +140,8 @@ fn parse_assert<'a>(cx: &mut ExtCtxt<'a>, sp: Span, stream: TokenStream) -> PRes\n     // Emit an error and suggest inserting a comma.\n     let custom_message =\n         if let token::Literal(token::Lit { kind: token::Str, .. }) = parser.token.kind {\n-            let mut err = cx.struct_span_err(parser.token.span, \"unexpected string literal\");\n-            let comma_span = parser.prev_token.span.shrink_to_hi();\n-            err.span_suggestion_short(\n-                comma_span,\n-                \"try adding a comma\",\n-                \", \",\n-                Applicability::MaybeIncorrect,\n-            );\n-            err.emit();\n+            let comma = parser.prev_token.span.shrink_to_hi();\n+            cx.emit_err(errors::AssertMissingComma { span: parser.token.span, comma });\n \n             parse_custom_message(&mut parser)\n         } else if parser.eat(&token::Comma) {"}, {"sha": "1397cee7af83b93b43ca8216010f92a423a05855", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -2,13 +2,13 @@\n //! a literal `true` or `false` based on whether the given cfg matches the\n //! current compilation environment.\n \n+use crate::errors;\n use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_attr as attr;\n use rustc_errors::PResult;\n use rustc_expand::base::{self, *};\n-use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n pub fn expand_cfg(\n@@ -35,34 +35,19 @@ pub fn expand_cfg(\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(builtin_macros_requires_cfg_pattern)]\n-struct RequiresCfgPattern {\n-    #[primary_span]\n-    #[label]\n-    span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(builtin_macros_expected_one_cfg_pattern)]\n-struct OneCfgPattern {\n-    #[primary_span]\n-    span: Span,\n-}\n-\n fn parse_cfg<'a>(cx: &mut ExtCtxt<'a>, span: Span, tts: TokenStream) -> PResult<'a, ast::MetaItem> {\n     let mut p = cx.new_parser_from_tts(tts);\n \n     if p.token == token::Eof {\n-        return Err(cx.create_err(RequiresCfgPattern { span }));\n+        return Err(cx.create_err(errors::RequiresCfgPattern { span }));\n     }\n \n     let cfg = p.parse_meta_item()?;\n \n     let _ = p.eat(&token::Comma);\n \n     if !p.eat(&token::Eof) {\n-        return Err(cx.create_err(OneCfgPattern { span }));\n+        return Err(cx.create_err(errors::OneCfgPattern { span }));\n     }\n \n     Ok(cfg)"}, {"sha": "37ac09ccdff4d4bf20843245a014562415e61944", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,5 +1,6 @@\n //! Implementation of the `#[cfg_accessible(path)]` attribute macro.\n \n+use crate::errors;\n use rustc_ast as ast;\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -10,15 +11,22 @@ use rustc_span::Span;\n pub(crate) struct Expander;\n \n fn validate_input<'a>(ecx: &mut ExtCtxt<'_>, mi: &'a ast::MetaItem) -> Option<&'a ast::Path> {\n+    use errors::CfgAccessibleInvalid::*;\n     match mi.meta_item_list() {\n         None => {}\n-        Some([]) => ecx.span_err(mi.span, \"`cfg_accessible` path is not specified\"),\n-        Some([_, .., l]) => ecx.span_err(l.span(), \"multiple `cfg_accessible` paths are specified\"),\n+        Some([]) => {\n+            ecx.emit_err(UnspecifiedPath(mi.span));\n+        }\n+        Some([_, .., l]) => {\n+            ecx.emit_err(MultiplePaths(l.span()));\n+        }\n         Some([nmi]) => match nmi.meta_item() {\n-            None => ecx.span_err(nmi.span(), \"`cfg_accessible` path cannot be a literal\"),\n+            None => {\n+                ecx.emit_err(LiteralPath(nmi.span()));\n+            }\n             Some(mi) => {\n                 if !mi.is_word() {\n-                    ecx.span_err(mi.span, \"`cfg_accessible` path cannot accept arguments\");\n+                    ecx.emit_err(HasArguments(mi.span));\n                 }\n                 return Some(&mi.path);\n             }\n@@ -53,7 +61,7 @@ impl MultiItemModifier for Expander {\n             Ok(true) => ExpandResult::Ready(vec![item]),\n             Ok(false) => ExpandResult::Ready(Vec::new()),\n             Err(Indeterminate) if ecx.force_mode => {\n-                ecx.span_err(span, \"cannot determine whether the path is accessible or not\");\n+                ecx.emit_err(errors::CfgAccessibleIndeterminate { span });\n                 ExpandResult::Ready(vec![item])\n             }\n             Err(Indeterminate) => ExpandResult::Retry(item),"}, {"sha": "aeb3bb80045bbfcb1d02365391cd694dcc727d98", "filename": "compiler/rustc_builtin_macros/src/compile_error.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -13,6 +13,11 @@ pub fn expand_compile_error<'cx>(\n         return DummyResult::any(sp);\n     };\n \n+    #[expect(\n+        rustc::diagnostic_outside_of_impl,\n+        reason = \"diagnostic message is specified by user\"\n+    )]\n+    #[expect(rustc::untranslatable_diagnostic, reason = \"diagnostic message is specified by user\")]\n     cx.span_err(sp, var.as_str());\n \n     DummyResult::any(sp)"}, {"sha": "b92964d03e9f95c80876039c5107ab9418587313", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -4,6 +4,8 @@ use rustc_expand::base::{self, DummyResult};\n use rustc_session::errors::report_lit_error;\n use rustc_span::symbol::Symbol;\n \n+use crate::errors;\n+\n pub fn expand_concat(\n     cx: &mut base::ExtCtxt<'_>,\n     sp: rustc_span::Span,\n@@ -31,7 +33,7 @@ pub fn expand_concat(\n                     accumulator.push_str(&b.to_string());\n                 }\n                 Ok(ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..)) => {\n-                    cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n+                    cx.emit_err(errors::ConcatBytestr { span: e.span });\n                     has_errors = true;\n                 }\n                 Ok(ast::LitKind::Err) => {\n@@ -55,7 +57,7 @@ pub fn expand_concat(\n                 }\n             }\n             ast::ExprKind::IncludedBytes(..) => {\n-                cx.span_err(e.span, \"cannot concatenate a byte string literal\")\n+                cx.emit_err(errors::ConcatBytestr { span: e.span });\n             }\n             ast::ExprKind::Err => {\n                 has_errors = true;\n@@ -67,9 +69,7 @@ pub fn expand_concat(\n     }\n \n     if !missing_literal.is_empty() {\n-        let mut err = cx.struct_span_err(missing_literal, \"expected a literal\");\n-        err.note(\"only literals (like `\\\"foo\\\"`, `-42` and `3.14`) can be passed to `concat!()`\");\n-        err.emit();\n+        cx.emit_err(errors::ConcatMissingLiteral { spans: missing_literal });\n         return DummyResult::any(sp);\n     } else if has_errors {\n         return DummyResult::any(sp);"}, {"sha": "ba639c0a9fe3ca117c9ae10dbc0817c3fd6405bb", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 27, "deletions": 50, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,73 +1,58 @@\n use rustc_ast as ast;\n use rustc_ast::{ptr::P, tokenstream::TokenStream};\n-use rustc_errors::Applicability;\n use rustc_expand::base::{self, DummyResult};\n use rustc_session::errors::report_lit_error;\n use rustc_span::Span;\n \n+use crate::errors;\n+\n /// Emits errors for literal expressions that are invalid inside and outside of an array.\n fn invalid_type_err(\n     cx: &mut base::ExtCtxt<'_>,\n     token_lit: ast::token::Lit,\n     span: Span,\n     is_nested: bool,\n ) {\n+    use errors::{\n+        ConcatBytesInvalid, ConcatBytesInvalidSuggestion, ConcatBytesNonU8, ConcatBytesOob,\n+    };\n+    let snippet = cx.sess.source_map().span_to_snippet(span).ok();\n     match ast::LitKind::from_token_lit(token_lit) {\n         Ok(ast::LitKind::Char(_)) => {\n-            let mut err = cx.struct_span_err(span, \"cannot concatenate character literals\");\n-            if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n-                err.span_suggestion(\n-                    span,\n-                    \"try using a byte character\",\n-                    format!(\"b{}\", snippet),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n-            }\n+            let sugg =\n+                snippet.map(|snippet| ConcatBytesInvalidSuggestion::CharLit { span, snippet });\n+            cx.sess.emit_err(ConcatBytesInvalid { span, lit_kind: \"character\", sugg });\n         }\n         Ok(ast::LitKind::Str(_, _)) => {\n-            let mut err = cx.struct_span_err(span, \"cannot concatenate string literals\");\n             // suggestion would be invalid if we are nested\n-            if !is_nested {\n-                if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"try using a byte string\",\n-                        format!(\"b{}\", snippet),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            err.emit();\n+            let sugg = if !is_nested {\n+                snippet.map(|snippet| ConcatBytesInvalidSuggestion::StrLit { span, snippet })\n+            } else {\n+                None\n+            };\n+            cx.emit_err(ConcatBytesInvalid { span, lit_kind: \"string\", sugg });\n         }\n         Ok(ast::LitKind::Float(_, _)) => {\n-            cx.span_err(span, \"cannot concatenate float literals\");\n+            cx.emit_err(ConcatBytesInvalid { span, lit_kind: \"float\", sugg: None });\n         }\n         Ok(ast::LitKind::Bool(_)) => {\n-            cx.span_err(span, \"cannot concatenate boolean literals\");\n+            cx.emit_err(ConcatBytesInvalid { span, lit_kind: \"boolean\", sugg: None });\n         }\n         Ok(ast::LitKind::Err) => {}\n         Ok(ast::LitKind::Int(_, _)) if !is_nested => {\n-            let mut err = cx.struct_span_err(span, \"cannot concatenate numeric literals\");\n-            if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n-                err.span_suggestion(\n-                    span,\n-                    \"try wrapping the number in an array\",\n-                    format!(\"[{}]\", snippet),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            err.emit();\n+            let sugg =\n+                snippet.map(|snippet| ConcatBytesInvalidSuggestion::IntLit { span: span, snippet });\n+            cx.emit_err(ConcatBytesInvalid { span, lit_kind: \"numeric\", sugg });\n         }\n         Ok(ast::LitKind::Int(\n             val,\n             ast::LitIntType::Unsuffixed | ast::LitIntType::Unsigned(ast::UintTy::U8),\n         )) => {\n             assert!(val > u8::MAX.into()); // must be an error\n-            cx.span_err(span, \"numeric literal is out of bounds\");\n+            cx.emit_err(ConcatBytesOob { span });\n         }\n         Ok(ast::LitKind::Int(_, _)) => {\n-            cx.span_err(span, \"numeric literal is not a `u8`\");\n+            cx.emit_err(ConcatBytesNonU8 { span });\n         }\n         Ok(ast::LitKind::ByteStr(..) | ast::LitKind::Byte(_)) => unreachable!(),\n         Err(err) => {\n@@ -85,7 +70,7 @@ fn handle_array_element(\n     match expr.kind {\n         ast::ExprKind::Array(_) | ast::ExprKind::Repeat(_, _) => {\n             if !*has_errors {\n-                cx.span_err(expr.span, \"cannot concatenate doubly nested array\");\n+                cx.emit_err(errors::ConcatBytesArray { span: expr.span, bytestr: false });\n             }\n             *has_errors = true;\n             None\n@@ -99,10 +84,7 @@ fn handle_array_element(\n             Ok(ast::LitKind::Byte(val)) => Some(val),\n             Ok(ast::LitKind::ByteStr(..)) => {\n                 if !*has_errors {\n-                    cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n-                        .note(\"byte strings are treated as arrays of bytes\")\n-                        .help(\"try flattening the array\")\n-                        .emit();\n+                    cx.emit_err(errors::ConcatBytesArray { span: expr.span, bytestr: true });\n                 }\n                 *has_errors = true;\n                 None\n@@ -117,10 +99,7 @@ fn handle_array_element(\n         },\n         ast::ExprKind::IncludedBytes(..) => {\n             if !*has_errors {\n-                cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n-                    .note(\"byte strings are treated as arrays of bytes\")\n-                    .help(\"try flattening the array\")\n-                    .emit();\n+                cx.emit_err(errors::ConcatBytesArray { span: expr.span, bytestr: false });\n             }\n             *has_errors = true;\n             None\n@@ -167,7 +146,7 @@ pub fn expand_concat_bytes(\n                         }\n                     }\n                 } else {\n-                    cx.span_err(count.value.span, \"repeat count is not a positive number\");\n+                    cx.emit_err(errors::ConcatBytesBadRepeat {span: count.value.span });\n                 }\n             }\n             &ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n@@ -196,9 +175,7 @@ pub fn expand_concat_bytes(\n         }\n     }\n     if !missing_literals.is_empty() {\n-        let mut err = cx.struct_span_err(missing_literals, \"expected a byte literal\");\n-        err.note(\"only byte literals (like `b\\\"foo\\\"`, `b's'`, and `[3, 4, 5]`) can be passed to `concat_bytes!()`\");\n-        err.emit();\n+        cx.emit_err(errors::ConcatBytesMissingLiteral { spans: missing_literals });\n         return base::MacEager::expr(DummyResult::raw_expr(sp, true));\n     } else if has_errors {\n         return base::MacEager::expr(DummyResult::raw_expr(sp, true));"}, {"sha": "8c737f043237e4516e1607daee62f616ab07fbc0", "filename": "compiler/rustc_builtin_macros/src/concat_idents.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -6,13 +6,15 @@ use rustc_expand::base::{self, *};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n+use crate::errors;\n+\n pub fn expand_concat_idents<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     if tts.is_empty() {\n-        cx.span_err(sp, \"concat_idents! takes 1 or more arguments\");\n+        cx.emit_err(errors::ConcatIdentsMissingArgs { span: sp });\n         return DummyResult::any(sp);\n     }\n \n@@ -22,7 +24,7 @@ pub fn expand_concat_idents<'cx>(\n             match e {\n                 TokenTree::Token(Token { kind: token::Comma, .. }, _) => {}\n                 _ => {\n-                    cx.span_err(sp, \"concat_idents! expecting comma\");\n+                    cx.emit_err(errors::ConcatIdentsMissingComma { span: sp });\n                     return DummyResult::any(sp);\n                 }\n             }\n@@ -34,7 +36,7 @@ pub fn expand_concat_idents<'cx>(\n                 }\n             }\n \n-            cx.span_err(sp, \"concat_idents! requires ident args\");\n+            cx.emit_err(errors::ConcatIdentsIdentArgs { span: sp });\n             return DummyResult::any(sp);\n         }\n     }"}, {"sha": "fe4483104eeb3d09dd0185c4f2be73b3ac879cec", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,8 +1,8 @@\n use crate::cfg_eval::cfg_eval;\n+use crate::errors;\n \n use rustc_ast as ast;\n use rustc_ast::{GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n@@ -116,49 +116,33 @@ fn report_bad_target(sess: &Session, item: &Annotatable, span: Span) -> bool {\n     let bad_target =\n         !matches!(item_kind, Some(ItemKind::Struct(..) | ItemKind::Enum(..) | ItemKind::Union(..)));\n     if bad_target {\n-        struct_span_err!(\n-            sess,\n-            span,\n-            E0774,\n-            \"`derive` may only be applied to `struct`s, `enum`s and `union`s\",\n-        )\n-        .span_label(span, \"not applicable here\")\n-        .span_label(item.span(), \"not a `struct`, `enum` or `union`\")\n-        .emit();\n+        sess.emit_err(errors::BadDeriveTarget { span, item: item.span() });\n     }\n     bad_target\n }\n \n fn report_unexpected_meta_item_lit(sess: &Session, lit: &ast::MetaItemLit) {\n-    let help_msg = match lit.kind {\n+    let help = match lit.kind {\n         ast::LitKind::Str(_, ast::StrStyle::Cooked)\n             if rustc_lexer::is_ident(lit.symbol.as_str()) =>\n         {\n-            format!(\"try using `#[derive({})]`\", lit.symbol)\n+            errors::BadDeriveLitHelp::StrLit { sym: lit.symbol }\n         }\n-        _ => \"for example, write `#[derive(Debug)]` for `Debug`\".to_string(),\n+        _ => errors::BadDeriveLitHelp::Other,\n     };\n-    struct_span_err!(sess, lit.span, E0777, \"expected path to a trait, found literal\",)\n-        .span_label(lit.span, \"not a trait\")\n-        .help(&help_msg)\n-        .emit();\n+    sess.emit_err(errors::BadDeriveLit { span: lit.span, help });\n }\n \n fn report_path_args(sess: &Session, meta: &ast::MetaItem) {\n-    let report_error = |title, action| {\n-        let span = meta.span.with_lo(meta.path.span.hi());\n-        sess.struct_span_err(span, title)\n-            .span_suggestion(span, action, \"\", Applicability::MachineApplicable)\n-            .emit();\n-    };\n+    let span = meta.span.with_lo(meta.path.span.hi());\n+\n     match meta.kind {\n         MetaItemKind::Word => {}\n-        MetaItemKind::List(..) => report_error(\n-            \"traits in `#[derive(...)]` don't accept arguments\",\n-            \"remove the arguments\",\n-        ),\n+        MetaItemKind::List(..) => {\n+            sess.emit_err(errors::DerivePathArgsList { span });\n+        }\n         MetaItemKind::NameValue(..) => {\n-            report_error(\"traits in `#[derive(...)]` don't accept values\", \"remove the value\")\n+            sess.emit_err(errors::DerivePathArgsValue { span });\n         }\n     }\n }"}, {"sha": "33fe98b40e158f0e9a4f8ab6d601a727c7b7dfac", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 45, "deletions": 79, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,8 +1,8 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n+use crate::errors;\n use rustc_ast as ast;\n use rustc_ast::{attr, walk_list, EnumDef, VariantData};\n-use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym};\n@@ -118,67 +118,50 @@ fn extract_default_variant<'a>(\n                 .filter(|variant| matches!(variant.data, VariantData::Unit(..)))\n                 .filter(|variant| !attr::contains_name(&variant.attrs, sym::non_exhaustive));\n \n-            let mut diag = cx.struct_span_err(trait_span, \"no default declared\");\n-            diag.help(\"make a unit variant default by placing `#[default]` above it\");\n-            for variant in possible_defaults {\n-                // Suggest making each unit variant default.\n-                diag.tool_only_span_suggestion(\n-                    variant.span,\n-                    &format!(\"make `{}` default\", variant.ident),\n-                    format!(\"#[default] {}\", variant.ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            diag.emit();\n+            let suggs = possible_defaults\n+                .map(|v| errors::NoDefaultVariantSugg { span: v.span, ident: v.ident })\n+                .collect();\n+            cx.emit_err(errors::NoDefaultVariant { span: trait_span, suggs });\n \n             return Err(());\n         }\n         [first, rest @ ..] => {\n-            let mut diag = cx.struct_span_err(trait_span, \"multiple declared defaults\");\n-            diag.span_label(first.span, \"first default\");\n-            diag.span_labels(rest.iter().map(|variant| variant.span), \"additional default\");\n-            diag.note(\"only one variant can be default\");\n-            for variant in &default_variants {\n-                // Suggest making each variant already tagged default.\n-                let suggestion = default_variants\n-                    .iter()\n-                    .filter_map(|v| {\n-                        if v.span == variant.span {\n-                            None\n-                        } else {\n-                            Some((attr::find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n-                        }\n-                    })\n-                    .collect();\n-\n-                diag.tool_only_multipart_suggestion(\n-                    &format!(\"make `{}` default\", variant.ident),\n-                    suggestion,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            diag.emit();\n-\n+            let suggs = default_variants\n+                .iter()\n+                .map(|variant| {\n+                    let spans = default_variants\n+                        .iter()\n+                        .filter_map(|v| {\n+                            if v.span == variant.span {\n+                                None\n+                            } else {\n+                                Some(attr::find_by_name(&v.attrs, kw::Default)?.span)\n+                            }\n+                        })\n+                        .collect();\n+                    errors::MultipleDefaultsSugg { spans, ident: variant.ident }\n+                })\n+                .collect();\n+            cx.emit_err(errors::MultipleDefaults {\n+                span: trait_span,\n+                first: first.span,\n+                additional: rest.iter().map(|v| v.span).collect(),\n+                suggs,\n+            });\n             return Err(());\n         }\n     };\n \n     if !matches!(variant.data, VariantData::Unit(..)) {\n-        cx.struct_span_err(\n-            variant.ident.span,\n-            \"the `#[default]` attribute may only be used on unit enum variants\",\n-        )\n-        .help(\"consider a manual implementation of `Default`\")\n-        .emit();\n-\n+        cx.emit_err(errors::NonUnitDefault { span: variant.ident.span });\n         return Err(());\n     }\n \n     if let Some(non_exhaustive_attr) = attr::find_by_name(&variant.attrs, sym::non_exhaustive) {\n-        cx.struct_span_err(variant.ident.span, \"default variant must be exhaustive\")\n-            .span_label(non_exhaustive_attr.span, \"declared `#[non_exhaustive]` here\")\n-            .help(\"consider a manual implementation of `Default`\")\n-            .emit();\n+        cx.emit_err(errors::NonExhaustiveDefault {\n+            span: variant.ident.span,\n+            non_exhaustive: non_exhaustive_attr.span,\n+        });\n \n         return Err(());\n     }\n@@ -199,35 +182,23 @@ fn validate_default_attribute(\n             \"this method must only be called with a variant that has a `#[default]` attribute\",\n         ),\n         [first, rest @ ..] => {\n-            let suggestion_text =\n-                if rest.len() == 1 { \"try removing this\" } else { \"try removing these\" };\n-\n-            cx.struct_span_err(default_variant.ident.span, \"multiple `#[default]` attributes\")\n-                .note(\"only one `#[default]` attribute is needed\")\n-                .span_label(first.span, \"`#[default]` used here\")\n-                .span_label(rest[0].span, \"`#[default]` used again here\")\n-                .span_help(rest.iter().map(|attr| attr.span).collect::<Vec<_>>(), suggestion_text)\n-                // This would otherwise display the empty replacement, hence the otherwise\n-                // repetitive `.span_help` call above.\n-                .tool_only_multipart_suggestion(\n-                    suggestion_text,\n-                    rest.iter().map(|attr| (attr.span, String::new())).collect(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            let sugg = errors::MultipleDefaultAttrsSugg {\n+                spans: rest.iter().map(|attr| attr.span).collect(),\n+            };\n+            cx.emit_err(errors::MultipleDefaultAttrs {\n+                span: default_variant.ident.span,\n+                first: first.span,\n+                first_rest: rest[0].span,\n+                rest: rest.iter().map(|attr| attr.span).collect::<Vec<_>>().into(),\n+                only_one: rest.len() == 1,\n+                sugg,\n+            });\n \n             return Err(());\n         }\n     };\n     if !attr.is_word() {\n-        cx.struct_span_err(attr.span, \"`#[default]` attribute does not accept a value\")\n-            .span_suggestion_hidden(\n-                attr.span,\n-                \"try using `#[default]`\",\n-                \"#[default]\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        cx.emit_err(errors::DefaultHasArg { span: attr.span });\n \n         return Err(());\n     }\n@@ -241,12 +212,7 @@ struct DetectNonVariantDefaultAttr<'a, 'b> {\n impl<'a, 'b> rustc_ast::visit::Visitor<'a> for DetectNonVariantDefaultAttr<'a, 'b> {\n     fn visit_attribute(&mut self, attr: &'a rustc_ast::Attribute) {\n         if attr.has_name(kw::Default) {\n-            self.cx\n-                .struct_span_err(\n-                    attr.span,\n-                    \"the `#[default]` attribute may only be used on unit enum variants\",\n-                )\n-                .emit();\n+            self.cx.emit_err(errors::NonUnitDefault { span: attr.span });\n         }\n \n         rustc_ast::visit::walk_attribute(self, attr);"}, {"sha": "e5a0033158840d4a757fc9f93fdfe29edf3c7bb2", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -162,7 +162,7 @@\n pub use StaticFields::*;\n pub use SubstructureFields::*;\n \n-use crate::deriving;\n+use crate::{deriving, errors};\n use rustc_ast::ptr::P;\n use rustc_ast::{\n     self as ast, BindingAnnotation, ByRef, EnumDef, Expr, GenericArg, GenericParamKind, Generics,\n@@ -415,7 +415,7 @@ fn find_type_parameters(\n         }\n \n         fn visit_mac_call(&mut self, mac: &ast::MacCall) {\n-            self.cx.span_err(mac.span(), \"`derive` cannot be used on items with type macros\");\n+            self.cx.emit_err(errors::DeriveMacroCall { span: mac.span() });\n         }\n     }\n \n@@ -488,7 +488,7 @@ impl<'a> TraitDef<'a> {\n                                 is_packed,\n                             )\n                         } else {\n-                            cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n+                            cx.emit_err(errors::DeriveUnion { span: mitem.span });\n                             return;\n                         }\n                     }"}, {"sha": "58c972738c499fdcaf939584016ba2fde734506c", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -11,6 +11,8 @@ use rustc_span::Span;\n use std::env;\n use thin_vec::thin_vec;\n \n+use crate::errors;\n+\n pub fn expand_option_env<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n@@ -54,7 +56,7 @@ pub fn expand_env<'cx>(\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, tts) {\n         Some(exprs) if exprs.is_empty() || exprs.len() > 2 => {\n-            cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n+            cx.emit_err(errors::EnvTakesArgs { span: sp });\n             return DummyResult::any(sp);\n         }\n         None => return DummyResult::any(sp),\n@@ -78,34 +80,26 @@ pub fn expand_env<'cx>(\n     cx.sess.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n     let e = match value {\n         None => {\n-            let (msg, help) = match custom_msg {\n-                None => (\n-                    format!(\"environment variable `{var}` not defined at compile time\"),\n-                    Some(help_for_missing_env_var(var.as_str())),\n-                ),\n-                Some(s) => (s.to_string(), None),\n-            };\n-            let mut diag = cx.struct_span_err(sp, &msg);\n-            if let Some(help) = help {\n-                diag.help(help);\n-            }\n-            diag.emit();\n+            cx.emit_err(errors::EnvNotDefined {\n+                span: sp,\n+                msg: custom_msg,\n+                var,\n+                help: custom_msg.is_none().then(|| help_for_missing_env_var(var.as_str())),\n+            });\n             return DummyResult::any(sp);\n         }\n         Some(value) => cx.expr_str(sp, value),\n     };\n     MacEager::expr(e)\n }\n \n-fn help_for_missing_env_var(var: &str) -> String {\n+fn help_for_missing_env_var(var: &str) -> errors::EnvNotDefinedHelp {\n     if var.starts_with(\"CARGO_\")\n         || var.starts_with(\"DEP_\")\n         || matches!(var, \"OUT_DIR\" | \"OPT_LEVEL\" | \"PROFILE\" | \"HOST\" | \"TARGET\")\n     {\n-        format!(\n-            \"Cargo sets build script variables at run time. Use `std::env::var(\\\"{var}\\\")` instead\"\n-        )\n+        errors::EnvNotDefinedHelp::CargoVar\n     } else {\n-        format!(\"Use `std::env::var(\\\"{var}\\\")` to read the variable at run time\")\n+        errors::EnvNotDefinedHelp::Other\n     }\n }"}, {"sha": "630f9b87bc3ea0bc37f79a488a2854e148619121", "filename": "compiler/rustc_builtin_macros/src/errors.rs", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -0,0 +1,553 @@\n+use rustc_errors::{\n+    AddToDiagnostic, EmissionGuarantee, IntoDiagnostic, MultiSpan, SingleLabelManySpans,\n+};\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_requires_cfg_pattern)]\n+pub(crate) struct RequiresCfgPattern {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_expected_one_cfg_pattern)]\n+pub(crate) struct OneCfgPattern {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_alloc_error_must_be_fn)]\n+pub(crate) struct AllocErrorMustBeFn {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_assert_requires_boolean)]\n+pub(crate) struct AssertRequiresBoolean {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_assert_requires_expression)]\n+pub(crate) struct AssertRequiresExpression {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub(crate) token: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_assert_missing_comma)]\n+pub(crate) struct AssertMissingComma {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[suggestion(code = \", \", applicability = \"maybe-incorrect\", style = \"short\")]\n+    pub(crate) comma: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum CfgAccessibleInvalid {\n+    #[diag(builtin_macros_cfg_accessible_unspecified_path)]\n+    UnspecifiedPath(#[primary_span] Span),\n+    #[diag(builtin_macros_cfg_accessible_multiple_paths)]\n+    MultiplePaths(#[primary_span] Span),\n+    #[diag(builtin_macros_cfg_accessible_literal_path)]\n+    LiteralPath(#[primary_span] Span),\n+    #[diag(builtin_macros_cfg_accessible_has_args)]\n+    HasArguments(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_cfg_accessible_indeterminate)]\n+pub(crate) struct CfgAccessibleIndeterminate {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_missing_literal)]\n+#[note]\n+pub(crate) struct ConcatMissingLiteral {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytestr)]\n+pub(crate) struct ConcatBytestr {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_invalid)]\n+pub(crate) struct ConcatBytesInvalid {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) lit_kind: &'static str,\n+    #[subdiagnostic]\n+    pub(crate) sugg: Option<ConcatBytesInvalidSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ConcatBytesInvalidSuggestion {\n+    #[suggestion(\n+        builtin_macros_byte_char,\n+        code = \"b{snippet}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    CharLit {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[suggestion(\n+        builtin_macros_byte_str,\n+        code = \"b{snippet}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    StrLit {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[suggestion(\n+        builtin_macros_number_array,\n+        code = \"[{snippet}]\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    IntLit {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_oob)]\n+pub(crate) struct ConcatBytesOob {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_non_u8)]\n+pub(crate) struct ConcatBytesNonU8 {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_missing_literal)]\n+#[note]\n+pub(crate) struct ConcatBytesMissingLiteral {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_array)]\n+pub(crate) struct ConcatBytesArray {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[note]\n+    #[help]\n+    pub(crate) bytestr: bool,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_bad_repeat)]\n+pub(crate) struct ConcatBytesBadRepeat {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_idents_missing_args)]\n+pub(crate) struct ConcatIdentsMissingArgs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_idents_missing_comma)]\n+pub(crate) struct ConcatIdentsMissingComma {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_idents_ident_args)]\n+pub(crate) struct ConcatIdentsIdentArgs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_bad_derive_target, code = \"E0774\")]\n+pub(crate) struct BadDeriveTarget {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(builtin_macros_label2)]\n+    pub(crate) item: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_unexpected_lit, code = \"E0777\")]\n+pub(crate) struct BadDeriveLit {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[subdiagnostic]\n+    pub help: BadDeriveLitHelp,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum BadDeriveLitHelp {\n+    #[help(builtin_macros_str_lit)]\n+    StrLit { sym: Symbol },\n+    #[help(builtin_macros_other)]\n+    Other,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_derive_path_args_list)]\n+pub(crate) struct DerivePathArgsList {\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_derive_path_args_value)]\n+pub(crate) struct DerivePathArgsValue {\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_no_default_variant)]\n+#[help]\n+pub(crate) struct NoDefaultVariant {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[subdiagnostic]\n+    pub(crate) suggs: Vec<NoDefaultVariantSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    builtin_macros_suggestion,\n+    code = \"#[default] {ident}\",\n+    applicability = \"maybe-incorrect\",\n+    style = \"tool-only\"\n+)]\n+pub(crate) struct NoDefaultVariantSugg {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_multiple_defaults)]\n+#[note]\n+pub(crate) struct MultipleDefaults {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) first: Span,\n+    #[label(builtin_macros_additional)]\n+    pub additional: Vec<Span>,\n+    #[subdiagnostic]\n+    pub suggs: Vec<MultipleDefaultsSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    builtin_macros_suggestion,\n+    applicability = \"maybe-incorrect\",\n+    style = \"tool-only\"\n+)]\n+pub(crate) struct MultipleDefaultsSugg {\n+    #[suggestion_part(code = \"\")]\n+    pub(crate) spans: Vec<Span>,\n+    pub(crate) ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_non_unit_default)]\n+#[help]\n+pub(crate) struct NonUnitDefault {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_non_exhaustive_default)]\n+#[help]\n+pub(crate) struct NonExhaustiveDefault {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) non_exhaustive: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_multiple_default_attrs)]\n+#[note]\n+pub(crate) struct MultipleDefaultAttrs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) first: Span,\n+    #[label(builtin_macros_label_again)]\n+    pub(crate) first_rest: Span,\n+    #[help]\n+    pub(crate) rest: MultiSpan,\n+    pub(crate) only_one: bool,\n+    #[subdiagnostic]\n+    pub(crate) sugg: MultipleDefaultAttrsSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    builtin_macros_help,\n+    applicability = \"machine-applicable\",\n+    style = \"tool-only\"\n+)]\n+pub(crate) struct MultipleDefaultAttrsSugg {\n+    #[suggestion_part(code = \"\")]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_default_arg)]\n+pub(crate) struct DefaultHasArg {\n+    #[primary_span]\n+    #[suggestion(code = \"#[default]\", style = \"hidden\", applicability = \"maybe-incorrect\")]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_derive_macro_call)]\n+pub(crate) struct DeriveMacroCall {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_cannot_derive_union)]\n+pub(crate) struct DeriveUnion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_env_takes_args)]\n+pub(crate) struct EnvTakesArgs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+//#[derive(Diagnostic)]\n+//#[diag(builtin_macros_env_not_defined)]\n+pub(crate) struct EnvNotDefined {\n+    pub(crate) span: Span,\n+    pub(crate) msg: Option<Symbol>,\n+    pub(crate) var: Symbol,\n+    pub(crate) help: Option<EnvNotDefinedHelp>,\n+}\n+\n+// Hand-written implementation to support custom user messages\n+impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for EnvNotDefined {\n+    #[track_caller]\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, G> {\n+        let mut diag = if let Some(msg) = self.msg {\n+            handler.struct_diagnostic(msg.as_str())\n+        } else {\n+            handler.struct_diagnostic(crate::fluent_generated::builtin_macros_env_not_defined)\n+        };\n+        diag.set_arg(\"var\", self.var);\n+        diag.set_span(self.span);\n+        if let Some(help) = self.help {\n+            diag.subdiagnostic(help);\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum EnvNotDefinedHelp {\n+    #[help(builtin_macros_cargo)]\n+    CargoVar,\n+    #[help(builtin_macros_other)]\n+    Other,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_requires_string)]\n+pub(crate) struct FormatRequiresString {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_duplicate_arg)]\n+pub(crate) struct FormatDuplicateArg {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label(builtin_macros_label1)]\n+    pub(crate) prev: Span,\n+    #[label(builtin_macros_label2)]\n+    pub(crate) duplicate: Span,\n+    pub(crate) ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_positional_after_named)]\n+pub(crate) struct PositionalAfterNamed {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(builtin_macros_named_args)]\n+    pub(crate) args: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_string_invalid)]\n+pub(crate) struct InvalidFormatString {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) desc: String,\n+    pub(crate) label1: String,\n+    #[subdiagnostic]\n+    pub(crate) note_: Option<InvalidFormatStringNote>,\n+    #[subdiagnostic]\n+    pub(crate) label_: Option<InvalidFormatStringLabel>,\n+    #[subdiagnostic]\n+    pub(crate) sugg_: Option<InvalidFormatStringSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(builtin_macros_note)]\n+pub(crate) struct InvalidFormatStringNote {\n+    pub(crate) note: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(builtin_macros_second_label)]\n+pub(crate) struct InvalidFormatStringLabel {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) label: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    builtin_macros_sugg,\n+    style = \"verbose\",\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct InvalidFormatStringSuggestion {\n+    #[suggestion_part(code = \"{len}\")]\n+    pub(crate) captured: Span,\n+    pub(crate) len: String,\n+    #[suggestion_part(code = \", {arg}\")]\n+    pub(crate) span: Span,\n+    pub(crate) arg: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_no_arg_named)]\n+#[note]\n+#[note(builtin_macros_note2)]\n+pub(crate) struct FormatNoArgNamed {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_unknown_trait)]\n+#[note]\n+pub(crate) struct FormatUnknownTrait<'a> {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ty: &'a str,\n+    #[subdiagnostic]\n+    pub(crate) suggs: Vec<FormatUnknownTraitSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    builtin_macros_suggestion,\n+    code = \"{fmt}\",\n+    style = \"tool-only\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct FormatUnknownTraitSugg {\n+    #[primary_span]\n+    pub span: Span,\n+    pub fmt: &'static str,\n+    pub trait_name: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_unused_arg)]\n+pub(crate) struct FormatUnusedArg {\n+    #[primary_span]\n+    #[label(builtin_macros_format_unused_arg)]\n+    pub(crate) span: Span,\n+    pub(crate) named: bool,\n+}\n+\n+// Allow the singular form to be a subdiagnostic of the multiple-unused\n+// form of diagnostic.\n+impl AddToDiagnostic for FormatUnusedArg {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, f: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"named\", self.named);\n+        let msg = f(diag, crate::fluent_generated::builtin_macros_format_unused_arg.into());\n+        diag.span_label(self.span, msg);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_unused_args)]\n+pub(crate) struct FormatUnusedArgs {\n+    #[primary_span]\n+    pub(crate) unused: Vec<Span>,\n+    #[label]\n+    pub(crate) fmt: Span,\n+    #[subdiagnostic]\n+    pub(crate) unused_labels: Vec<FormatUnusedArg>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_pos_mismatch)]\n+pub(crate) struct FormatPositionalMismatch {\n+    #[primary_span]\n+    pub(crate) span: MultiSpan,\n+    pub(crate) n: usize,\n+    pub(crate) desc: String,\n+    #[subdiagnostic]\n+    pub(crate) highlight: SingleLabelManySpans,\n+}"}, {"sha": "435a07d8ce7adfab88961c2e941cff43f70b397f", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 78, "deletions": 97, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::{\n     FormatDebugHex, FormatOptions, FormatPlaceholder, FormatSign, FormatTrait,\n };\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n+use rustc_errors::{Applicability, MultiSpan, PResult, SingleLabelManySpans};\n use rustc_expand::base::{self, *};\n use rustc_parse_format as parse;\n use rustc_span::symbol::{Ident, Symbol};\n@@ -36,6 +36,8 @@ enum PositionUsedAs {\n }\n use PositionUsedAs::*;\n \n+use crate::errors;\n+\n struct MacroInput {\n     fmtstr: P<Expr>,\n     args: FormatArguments,\n@@ -66,7 +68,7 @@ fn parse_args<'a>(ecx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<\n     let mut p = ecx.new_parser_from_tts(tts);\n \n     if p.token == token::Eof {\n-        return Err(ecx.struct_span_err(sp, \"requires at least a format string argument\"));\n+        return Err(ecx.create_err(errors::FormatRequiresString { span: sp }));\n     }\n \n     let first_token = &p.token;\n@@ -121,34 +123,34 @@ fn parse_args<'a>(ecx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<\n                 p.expect(&token::Eq)?;\n                 let expr = p.parse_expr()?;\n                 if let Some((_, prev)) = args.by_name(ident.name) {\n-                    ecx.struct_span_err(\n-                        ident.span,\n-                        &format!(\"duplicate argument named `{}`\", ident),\n-                    )\n-                    .span_label(prev.kind.ident().unwrap().span, \"previously here\")\n-                    .span_label(ident.span, \"duplicate argument\")\n-                    .emit();\n+                    ecx.emit_err(errors::FormatDuplicateArg {\n+                        span: ident.span,\n+                        prev: prev.kind.ident().unwrap().span,\n+                        duplicate: ident.span,\n+                        ident,\n+                    });\n                     continue;\n                 }\n                 args.add(FormatArgument { kind: FormatArgumentKind::Named(ident), expr });\n             }\n             _ => {\n                 let expr = p.parse_expr()?;\n                 if !args.named_args().is_empty() {\n-                    let mut err = ecx.struct_span_err(\n-                        expr.span,\n-                        \"positional arguments cannot follow named arguments\",\n-                    );\n-                    err.span_label(\n-                        expr.span,\n-                        \"positional arguments must be before named arguments\",\n-                    );\n-                    for arg in args.named_args() {\n-                        if let Some(name) = arg.kind.ident() {\n-                            err.span_label(name.span.to(arg.expr.span), \"named argument\");\n-                        }\n-                    }\n-                    err.emit();\n+                    ecx.emit_err(errors::PositionalAfterNamed {\n+                        span: expr.span,\n+                        args: args\n+                            .named_args()\n+                            .iter()\n+                            .filter_map(|a| {\n+                                if let Some(ident) = a.kind.ident() {\n+                                    Some((a, ident))\n+                                } else {\n+                                    None\n+                                }\n+                            })\n+                            .map(|(arg, n)| n.span.to(arg.expr.span))\n+                            .collect(),\n+                    });\n                 }\n                 args.add(FormatArgument { kind: FormatArgumentKind::Normal, expr });\n             }\n@@ -234,13 +236,19 @@ fn make_format_args(\n             // argument span here.\n             fmt_span\n         };\n-        let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\", err.description));\n-        e.span_label(sp, err.label + \" in format string\");\n+        let mut e = errors::InvalidFormatString {\n+            span: sp,\n+            note_: None,\n+            label_: None,\n+            sugg_: None,\n+            desc: err.description,\n+            label1: err.label,\n+        };\n         if let Some(note) = err.note {\n-            e.note(&note);\n+            e.note_ = Some(errors::InvalidFormatStringNote { note });\n         }\n         if let Some((label, span)) = err.secondary_label && is_source_literal {\n-            e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n+            e.label_ = Some(errors::InvalidFormatStringLabel { span: fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label } );\n         }\n         if err.should_be_replaced_with_positional_argument {\n             let captured_arg_span =\n@@ -250,17 +258,15 @@ fn make_format_args(\n                     Some(arg) => arg.expr.span,\n                     None => fmt_span,\n                 };\n-                e.multipart_suggestion_verbose(\n-                    \"consider using a positional formatting argument instead\",\n-                    vec![\n-                        (captured_arg_span, args.unnamed_args().len().to_string()),\n-                        (span.shrink_to_hi(), format!(\", {}\", arg)),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n+                e.sugg_ = Some(errors::InvalidFormatStringSuggestion {\n+                    captured: captured_arg_span,\n+                    len: args.unnamed_args().len().to_string(),\n+                    span: span.shrink_to_hi(),\n+                    arg,\n+                });\n             }\n         }\n-        e.emit();\n+        ecx.emit_err(e);\n         return Err(());\n     }\n \n@@ -318,10 +324,7 @@ fn make_format_args(\n                     } else {\n                         // For the moment capturing variables from format strings expanded from macros is\n                         // disabled (see RFC #2795)\n-                        ecx.struct_span_err(span, &format!(\"there is no argument named `{name}`\"))\n-                            .note(format!(\"did you intend to capture a variable `{name}` from the surrounding scope?\"))\n-                            .note(\"to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\")\n-                            .emit();\n+                        ecx.emit_err(errors::FormatNoArgNamed { span, name });\n                         DummyResult::raw_expr(span, true)\n                     };\n                     Ok(args.add(FormatArgument { kind: FormatArgumentKind::Captured(ident), expr }))\n@@ -475,12 +478,8 @@ fn make_format_args(\n         .enumerate()\n         .filter(|&(_, used)| !used)\n         .map(|(i, _)| {\n-            let msg = if let FormatArgumentKind::Named(_) = args.explicit_args()[i].kind {\n-                \"named argument never used\"\n-            } else {\n-                \"argument never used\"\n-            };\n-            (args.explicit_args()[i].expr.span, msg)\n+            let named = matches!(args.explicit_args()[i].kind, FormatArgumentKind::Named(_));\n+            (args.explicit_args()[i].expr.span, named)\n         })\n         .collect::<Vec<_>>();\n \n@@ -531,22 +530,8 @@ fn invalid_placeholder_type_error(\n     fmt_span: Span,\n ) {\n     let sp = ty_span.map(|sp| fmt_span.from_inner(InnerSpan::new(sp.start, sp.end)));\n-    let mut err =\n-        ecx.struct_span_err(sp.unwrap_or(fmt_span), &format!(\"unknown format trait `{}`\", ty));\n-    err.note(\n-        \"the only appropriate formatting traits are:\\n\\\n-                                - ``, which uses the `Display` trait\\n\\\n-                                - `?`, which uses the `Debug` trait\\n\\\n-                                - `e`, which uses the `LowerExp` trait\\n\\\n-                                - `E`, which uses the `UpperExp` trait\\n\\\n-                                - `o`, which uses the `Octal` trait\\n\\\n-                                - `p`, which uses the `Pointer` trait\\n\\\n-                                - `b`, which uses the `Binary` trait\\n\\\n-                                - `x`, which uses the `LowerHex` trait\\n\\\n-                                - `X`, which uses the `UpperHex` trait\",\n-    );\n-    if let Some(sp) = sp {\n-        for (fmt, name) in &[\n+    let suggs = if let Some(sp) = sp {\n+        [\n             (\"\", \"Display\"),\n             (\"?\", \"Debug\"),\n             (\"e\", \"LowerExp\"),\n@@ -556,40 +541,38 @@ fn invalid_placeholder_type_error(\n             (\"b\", \"Binary\"),\n             (\"x\", \"LowerHex\"),\n             (\"X\", \"UpperHex\"),\n-        ] {\n-            err.tool_only_span_suggestion(\n-                sp,\n-                &format!(\"use the `{}` trait\", name),\n-                *fmt,\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-    }\n-    err.emit();\n+        ]\n+        .into_iter()\n+        .map(|(fmt, trait_name)| errors::FormatUnknownTraitSugg { span: sp, fmt, trait_name })\n+        .collect()\n+    } else {\n+        vec![]\n+    };\n+    ecx.emit_err(errors::FormatUnknownTrait { span: sp.unwrap_or(fmt_span), ty, suggs });\n }\n \n fn report_missing_placeholders(\n     ecx: &mut ExtCtxt<'_>,\n-    unused: Vec<(Span, &str)>,\n+    unused: Vec<(Span, bool)>,\n     detect_foreign_fmt: bool,\n     str_style: Option<usize>,\n     fmt_str: &str,\n     fmt_span: Span,\n ) {\n-    let mut diag = if let &[(span, msg)] = &unused[..] {\n-        let mut diag = ecx.struct_span_err(span, msg);\n-        diag.span_label(span, msg);\n-        diag\n+    let mut diag = if let &[(span, named)] = &unused[..] {\n+        //let mut diag = ecx.struct_span_err(span, msg);\n+        //diag.span_label(span, msg);\n+        //diag\n+        ecx.create_err(errors::FormatUnusedArg { span, named })\n     } else {\n-        let mut diag = ecx.struct_span_err(\n-            unused.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n-            \"multiple unused formatting arguments\",\n-        );\n-        diag.span_label(fmt_span, \"multiple missing formatting specifiers\");\n-        for &(span, msg) in &unused {\n-            diag.span_label(span, msg);\n-        }\n-        diag\n+        let unused_labels =\n+            unused.iter().map(|&(span, named)| errors::FormatUnusedArg { span, named }).collect();\n+        let unused_spans = unused.iter().map(|&(span, _)| span).collect();\n+        ecx.create_err(errors::FormatUnusedArgs {\n+            fmt: fmt_span,\n+            unused: unused_spans,\n+            unused_labels,\n+        })\n     };\n \n     // Used to ensure we only report translations for *one* kind of foreign format.\n@@ -768,18 +751,16 @@ fn report_invalid_references(\n         } else {\n             MultiSpan::from_spans(spans)\n         };\n-        e = ecx.struct_span_err(\n+        e = ecx.create_err(errors::FormatPositionalMismatch {\n             span,\n-            &format!(\n-                \"{} positional argument{} in format string, but {}\",\n-                num_placeholders,\n-                pluralize!(num_placeholders),\n-                num_args_desc,\n-            ),\n-        );\n-        for arg in args.explicit_args() {\n-            e.span_label(arg.expr.span, \"\");\n-        }\n+            n: num_placeholders,\n+            desc: num_args_desc,\n+            highlight: SingleLabelManySpans {\n+                spans: args.explicit_args().iter().map(|arg| arg.expr.span).collect(),\n+                label: \"\",\n+                kind: rustc_errors::LabelKind::Label,\n+            },\n+        });\n         // Point out `{:.*}` placeholders: those take an extra argument.\n         let mut has_precision_star = false;\n         for piece in template {"}, {"sha": "37fbd03a6a2161375ed6189161bb5ebd3b935db8", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -9,6 +9,7 @@\n #![feature(if_let_guard)]\n #![feature(is_sorted)]\n #![feature(let_chains)]\n+#![feature(lint_reasons)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![recursion_limit = \"256\"]\n@@ -39,6 +40,7 @@ mod derive;\n mod deriving;\n mod edition_panic;\n mod env;\n+mod errors;\n mod format;\n mod format_foreign;\n mod global_allocator;"}, {"sha": "cd0049b45586f26a27f13e6652b9831dc348a470", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -880,6 +880,7 @@ impl Diagnostic {\n     ///\n     /// This is intended to be used for suggestions that are *very* obvious in what the changes\n     /// need to be from the message, but we still want other tools to be able to apply them.\n+    #[rustc_lint_diagnostics]\n     pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,"}, {"sha": "65f8a61a30a9a045c3d7d4f526f832d52867ea95", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,11 +1,12 @@\n-use crate::fluent_generated as fluent;\n+use crate::{fluent_generated as fluent, AddToDiagnostic};\n use crate::{DiagnosticArgValue, DiagnosticBuilder, Handler, IntoDiagnostic, IntoDiagnosticArg};\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_hir as hir;\n use rustc_lint_defs::Level;\n use rustc_span::edition::Edition;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::TargetDataLayoutErrors;\n use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n use rustc_type_ir as type_ir;\n@@ -276,3 +277,26 @@ impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n         }\n     }\n }\n+\n+/// Utility struct used to apply a single label while highlighting multiple spans\n+pub struct SingleLabelManySpans {\n+    pub spans: Vec<Span>,\n+    pub label: &'static str,\n+    pub kind: LabelKind,\n+}\n+impl AddToDiagnostic for SingleLabelManySpans {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut crate::Diagnostic, _: F) {\n+        match self.kind {\n+            LabelKind::Note => diag.span_note(self.spans, self.label),\n+            LabelKind::Label => diag.span_labels(self.spans, self.label),\n+            LabelKind::Help => diag.span_help(self.spans, self.label),\n+        };\n+    }\n+}\n+\n+/// The kind of label to attach when using [`SingleLabelManySpans`]\n+pub enum LabelKind {\n+    Note,\n+    Label,\n+    Help,\n+}"}, {"sha": "5b0d8096207379d7238bf030acaac18a1927c82e", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -383,7 +383,9 @@ pub use diagnostic::{\n     DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n-pub use diagnostic_impls::{DiagnosticArgFromDisplay, DiagnosticSymbolList};\n+pub use diagnostic_impls::{\n+    DiagnosticArgFromDisplay, DiagnosticSymbolList, LabelKind, SingleLabelManySpans,\n+};\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output."}, {"sha": "181e65d89531be331bf22c5111de3e35d695543b", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -392,14 +392,16 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             }\n             SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n                 let inner = info.ty.inner_type();\n-                if type_matches_path(inner, &[\"rustc_span\", \"Span\"]) {\n+                if type_matches_path(inner, &[\"rustc_span\", \"Span\"])\n+                    || type_matches_path(inner, &[\"rustc_span\", \"MultiSpan\"])\n+                {\n                     Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n                 } else if type_is_unit(inner)\n                     || (matches!(info.ty, FieldInnerTy::Plain(_)) && type_is_bool(inner))\n                 {\n                     Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n-                    report_type_error(attr, \"`Span`, `bool` or `()`\")?\n+                    report_type_error(attr, \"`Span`, `MultiSpan`, `bool` or `()`\")?\n                 }\n             }\n             SubdiagnosticKind::Suggestion {"}, {"sha": "6cc7bab37266d5e3e65230662f31acfbe65f4e4c", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -518,7 +518,7 @@ struct BoolField {\n     #[help]\n     foo: bool,\n     #[help(no_crate_help)]\n-    //~^ ERROR the `#[help(...)]` attribute can only be applied to fields of type `Span`, `bool` or `()`\n+    //~^ ERROR the `#[help(...)]` attribute can only be applied to fields of type\n     // only allow plain 'bool' fields\n     bar: Option<bool>,\n }"}, {"sha": "a2f3bb5277b55d710bce7013ef591b129a93a406", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -323,7 +323,7 @@ error: invalid applicability\n LL |     #[suggestion(no_crate_suggestion, code = \"...\", applicability = \"batman\")]\n    |                                                                     ^^^^^^^^\n \n-error: the `#[help(...)]` attribute can only be applied to fields of type `Span`, `bool` or `()`\n+error: the `#[help(...)]` attribute can only be applied to fields of type `Span`, `MultiSpan`, `bool` or `()`\n   --> $DIR/diagnostic-derive.rs:520:5\n    |\n LL |     #[help(no_crate_help)]"}, {"sha": "2ff6d242b27c94eb9b57764daff9c7724b64ff5c", "filename": "tests/ui/extenv/extenv-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextenv%2Fextenv-no-args.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1 +1 @@\n-fn main() { env!(); } //~ ERROR: env! takes 1 or 2 arguments\n+fn main() { env!(); } //~ ERROR: `env!()` takes 1 or 2 arguments"}, {"sha": "70b85932c2338dd1b85394320ea07ccc6fd16a78", "filename": "tests/ui/extenv/extenv-no-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fextenv-no-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fextenv-no-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextenv%2Fextenv-no-args.stderr?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,4 +1,4 @@\n-error: env! takes 1 or 2 arguments\n+error: `env!()` takes 1 or 2 arguments\n   --> $DIR/extenv-no-args.rs:1:13\n    |\n LL | fn main() { env!(); }"}, {"sha": "ffad1c51303fc35a7f15827073587b5d7b2c66bb", "filename": "tests/ui/extenv/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextenv%2Fextenv-too-many-args.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1 +1 @@\n-fn main() { env!(\"one\", \"two\", \"three\"); } //~ ERROR: env! takes 1 or 2 arguments\n+fn main() { env!(\"one\", \"two\", \"three\"); } //~ ERROR: `env!()` takes 1 or 2 arguments"}, {"sha": "47cf810b70d77b4d8789563fb2cbeaf5343cbb05", "filename": "tests/ui/extenv/extenv-too-many-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fextenv-too-many-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fextenv-too-many-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextenv%2Fextenv-too-many-args.stderr?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,4 +1,4 @@\n-error: env! takes 1 or 2 arguments\n+error: `env!()` takes 1 or 2 arguments\n   --> $DIR/extenv-too-many-args.rs:1:13\n    |\n LL | fn main() { env!(\"one\", \"two\", \"three\"); }"}, {"sha": "401db827813a9de859a42b96934deb3fba73a877", "filename": "tests/ui/extenv/issue-55897.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fissue-55897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fextenv%2Fissue-55897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextenv%2Fissue-55897.stderr?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -4,7 +4,7 @@ error: environment variable `NON_EXISTENT` not defined at compile time\n LL |     include!(concat!(env!(\"NON_EXISTENT\"), \"/data.rs\"));\n    |                      ^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: Use `std::env::var(\"NON_EXISTENT\")` to read the variable at run time\n+   = help: use `std::env::var(\"NON_EXISTENT\")` to read the variable at run time\n    = note: this error originates in the macro `env` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: suffixes on string literals are invalid"}, {"sha": "ab22aff26d99c5e26f2524e4a66dcab8eeb498e6", "filename": "tests/ui/issues/issue-50403.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fissues%2Fissue-50403.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fissues%2Fissue-50403.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-50403.rs?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,5 +1,5 @@\n #![feature(concat_idents)]\n \n fn main() {\n-    let x = concat_idents!(); //~ ERROR concat_idents! takes 1 or more arguments\n+    let x = concat_idents!(); //~ ERROR `concat_idents!()` takes 1 or more arguments\n }"}, {"sha": "d50befa5e326bcc83774775a65eb50efb8ae6ee9", "filename": "tests/ui/issues/issue-50403.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fissues%2Fissue-50403.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fissues%2Fissue-50403.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-50403.stderr?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -1,4 +1,4 @@\n-error: concat_idents! takes 1 or more arguments\n+error: `concat_idents!()` takes 1 or more arguments\n   --> $DIR/issue-50403.rs:4:13\n    |\n LL |     let x = concat_idents!();"}, {"sha": "3f2c64922e34d24796f408325dea16ede570c8fa", "filename": "tests/ui/macros/concat-bytes-error.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fmacros%2Fconcat-bytes-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fmacros%2Fconcat-bytes-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fconcat-bytes-error.stderr?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -4,15 +4,15 @@ error: expected a byte literal\n LL |     concat_bytes!(pie);\n    |                   ^^^\n    |\n-   = note: only byte literals (like `b\"foo\"`, `b's'`, and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n+   = note: only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n \n error: expected a byte literal\n   --> $DIR/concat-bytes-error.rs:5:19\n    |\n LL |     concat_bytes!(pie, pie);\n    |                   ^^^  ^^^\n    |\n-   = note: only byte literals (like `b\"foo\"`, `b's'`, and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n+   = note: only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n \n error: cannot concatenate string literals\n   --> $DIR/concat-bytes-error.rs:6:19\n@@ -98,7 +98,7 @@ error: expected a byte literal\n LL |         -33,\n    |         ^^^\n    |\n-   = note: only byte literals (like `b\"foo\"`, `b's'`, and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n+   = note: only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n \n error: cannot concatenate doubly nested array\n   --> $DIR/concat-bytes-error.rs:35:9\n@@ -151,7 +151,7 @@ error: expected a byte literal\n LL |     concat_bytes!([pie; 2]);\n    |                    ^^^\n    |\n-   = note: only byte literals (like `b\"foo\"`, `b's'`, and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n+   = note: only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n \n error: cannot concatenate float literals\n   --> $DIR/concat-bytes-error.rs:46:20"}, {"sha": "ca373ea6cd9e4838f69d77d5f8d5f29960a80486", "filename": "tests/ui/macros/macros-nonfatal-errors.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64f75977764439f500f58ed6f2ac6db4873b250a/tests%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr?ref=64f75977764439f500f58ed6f2ac6db4873b250a", "patch": "@@ -3,36 +3,48 @@ error: the `#[default]` attribute may only be used on unit enum variants\n    |\n LL |     #[default]\n    |     ^^^^^^^^^^\n+   |\n+   = help: consider a manual implementation of `Default`\n \n error: the `#[default]` attribute may only be used on unit enum variants\n   --> $DIR/macros-nonfatal-errors.rs:18:36\n    |\n LL | struct DefaultInnerAttrTupleStruct(#[default] ());\n    |                                    ^^^^^^^^^^\n+   |\n+   = help: consider a manual implementation of `Default`\n \n error: the `#[default]` attribute may only be used on unit enum variants\n   --> $DIR/macros-nonfatal-errors.rs:22:1\n    |\n LL | #[default]\n    | ^^^^^^^^^^\n+   |\n+   = help: consider a manual implementation of `Default`\n \n error: the `#[default]` attribute may only be used on unit enum variants\n   --> $DIR/macros-nonfatal-errors.rs:26:1\n    |\n LL | #[default]\n    | ^^^^^^^^^^\n+   |\n+   = help: consider a manual implementation of `Default`\n \n error: the `#[default]` attribute may only be used on unit enum variants\n   --> $DIR/macros-nonfatal-errors.rs:36:11\n    |\n LL |     Foo = #[default] 0,\n    |           ^^^^^^^^^^\n+   |\n+   = help: consider a manual implementation of `Default`\n \n error: the `#[default]` attribute may only be used on unit enum variants\n   --> $DIR/macros-nonfatal-errors.rs:37:14\n    |\n LL |     Bar([u8; #[default] 1]),\n    |              ^^^^^^^^^^\n+   |\n+   = help: consider a manual implementation of `Default`\n \n error: no default declared\n   --> $DIR/macros-nonfatal-errors.rs:42:10\n@@ -132,7 +144,7 @@ error: asm template must be a string literal\n LL |     asm!(invalid);\n    |          ^^^^^^^\n \n-error: concat_idents! requires ident args\n+error: `concat_idents!()` requires ident args\n   --> $DIR/macros-nonfatal-errors.rs:101:5\n    |\n LL |     concat_idents!(\"not\", \"idents\");\n@@ -150,7 +162,7 @@ error: expected string literal\n LL |     env!(invalid);\n    |          ^^^^^^^\n \n-error: env! takes 1 or 2 arguments\n+error: `env!()` takes 1 or 2 arguments\n   --> $DIR/macros-nonfatal-errors.rs:105:5\n    |\n LL |     env!(foo, abr, baz);\n@@ -162,7 +174,7 @@ error: environment variable `RUST_HOPEFULLY_THIS_DOESNT_EXIST` not defined at co\n LL |     env!(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: Use `std::env::var(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\")` to read the variable at run time\n+   = help: use `std::env::var(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\")` to read the variable at run time\n    = note: this error originates in the macro `env` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: format argument must be a string literal"}]}