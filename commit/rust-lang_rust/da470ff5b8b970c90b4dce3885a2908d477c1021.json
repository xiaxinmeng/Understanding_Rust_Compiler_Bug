{"sha": "da470ff5b8b970c90b4dce3885a2908d477c1021", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNDcwZmY1YjhiOTcwYzkwYjRkY2UzODg1YTI5MDhkNDc3YzEwMjE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-25T20:29:41Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-25T20:29:41Z"}, "message": "Merge", "tree": {"sha": "f65aa2d105f18cdeb79321a37e47e26a5f592149", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f65aa2d105f18cdeb79321a37e47e26a5f592149"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da470ff5b8b970c90b4dce3885a2908d477c1021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da470ff5b8b970c90b4dce3885a2908d477c1021", "html_url": "https://github.com/rust-lang/rust/commit/da470ff5b8b970c90b4dce3885a2908d477c1021", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da470ff5b8b970c90b4dce3885a2908d477c1021/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44d0a061be0ec9cae51c61b7bb335e8c4b8c6cf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/44d0a061be0ec9cae51c61b7bb335e8c4b8c6cf5", "html_url": "https://github.com/rust-lang/rust/commit/44d0a061be0ec9cae51c61b7bb335e8c4b8c6cf5"}, {"sha": "fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/fad307d7b4aa5e7ff6cf30194b069062aaad1a89", "html_url": "https://github.com/rust-lang/rust/commit/fad307d7b4aa5e7ff6cf30194b069062aaad1a89"}], "stats": {"total": 1373, "additions": 767, "deletions": 606}, "files": [{"sha": "5da6314c4d16e98ad382aef9cd955c6f45fcffd0", "filename": "RELEASES.txt", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,3 +1,47 @@\n+Version 0.3  (June 2012) - not yet!\n+-----------------------------------\n+\n+  * ~1500 changes, numerous bugfixes\n+\n+  * New coding conveniences\n+    * Integer-literal suffix inference\n+    * Per-module control over warnings, errors\n+    * #[cfg(windows)] and #[cfg(unix)] attributes\n+\n+  * Semantic cleanup\n+    * Resolve pass and exhaustiveness checker rewritten\n+    * Borrow-check taking over from alias-analysis\n+    * Liveness taking over from last-use, typestate\n+    * Extensive work on region pointers\n+\n+  * Experimental new language features\n+    * Slices and fixed-size, interior-allocated vectors\n+    * #!-comments for lang versioning, shell execution\n+    * More work on classes\n+    * Type reflection\n+\n+  * Removal of various obsolete features\n+    * Keywords: be, prove, syntax, note, mutable, do, bind\n+    * Constructs: do-while loops, fn binding, \n+\n+  * Compiler reorganization\n+    * Syntax-layer of compiler split into separate crate\n+    * Clang (from LLVM project) integrated into build\n+    * Typechecker split into sub-modules\n+\n+  * New library code\n+    * New time functions\n+    * Extension methods for many built-in types\n+    * Arc: atomic-refcount read-only / exclusive-use shared cells\n+    * Par: parallel map and search routines\n+    * Extensive work on libuv interface\n+    * Much vector code moved to libraries\n+    * Syntax extensions: #line, #col, #file, #mod,\n+      #stringify, #include, #include_str, #include_bin.\n+\n+  * Tool improvements\n+    * Cargo automatically resolves dependencies\n+\n Version 0.2  (March 2012)\n -------------------------\n "}, {"sha": "881d736d2ba8f7e5270bffe26a8a39f713828943", "filename": "src/libcore/box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -2,9 +2,9 @@\n \n export ptr_eq;\n \n-pure fn ptr_eq<T>(a: @T, b: @T) -> bool unchecked {\n+pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     #[doc = \"Determine if two shared boxes point to the same object\"];\n-    ptr::addr_of(*a) == ptr::addr_of(*b)\n+    unsafe { ptr::addr_of(*a) == ptr::addr_of(*b) }\n }\n \n #[test]"}, {"sha": "9aa1614114b635edfb64b968af424012da07f79b", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -231,7 +231,7 @@ fn test_to_digit() {\n }\n \n #[test]\n-fn test_is_ascii() unsafe {\n+fn test_is_ascii() {\n    assert str::all(\"banana\", char::is_ascii);\n    assert ! str::all(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", char::is_ascii);\n }"}, {"sha": "8cc82e56b8f109fbe25ca1794103833ea4355fcf", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -210,13 +210,13 @@ fn recv_<T: send>(p: *rust_port) -> T {\n     ret res;\n }\n \n-fn peek_(p: *rust_port) -> bool unsafe {\n+fn peek_(p: *rust_port) -> bool {\n     rustrt::rust_port_size(p) != 0u as libc::size_t\n }\n \n #[doc = \"Receive on one of two ports\"]\n fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n-    -> either<A, B> unsafe {\n+    -> either<A, B> {\n     let ports = [(**p_a).po, (**p_b).po];\n     let n_ports = 2 as libc::size_t;\n     let yield = 0u, yieldp = ptr::addr_of(yield);\n@@ -440,7 +440,7 @@ fn test_recv_chan_wrong_task() {\n     let po = port();\n     let ch = chan(po);\n     send(ch, \"flower\");\n-    assert result::is_failure(task::try {||\n+    assert result::is_err(task::try {||\n         recv_chan(ch)\n     })\n }"}, {"sha": "8b55a04ca484b2524c1af3604019a36fed6c4092", "filename": "src/libcore/core.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -11,6 +11,7 @@ import option::extensions;\n import option_iter::extensions;\n import ptr::extensions;\n import rand::extensions;\n+import result::extensions;\n \n export path, option, some, none, unreachable;\n export extensions;"}, {"sha": "175974f09cb1b1ba1382ec9e572180479bdaa61c", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -81,7 +81,7 @@ mod ct {\n     enum piece { piece_string(str), piece_conv(conv), }\n     type error_fn = fn@(str) -> ! ;\n \n-    fn parse_fmt_string(s: str, error: error_fn) -> [piece] unsafe {\n+    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n         let mut pieces: [piece] = [];\n         let lim = str::len(s);\n         let mut buf = \"\";\n@@ -225,7 +225,7 @@ mod ct {\n             } else { {count: count_implied, next: i} };\n     }\n     fn parse_type(s: str, i: uint, lim: uint, error: error_fn) ->\n-       {ty: ty, next: uint} unsafe {\n+       {ty: ty, next: uint} {\n         if i >= lim { error(\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n         // TODO: Do we really want two signed types here?\n@@ -314,7 +314,7 @@ mod rt {\n         let mut s = str::from_char(c);\n         ret pad(cv, s, pad_nozero);\n     }\n-    fn conv_str(cv: conv, s: str) -> str unsafe {\n+    fn conv_str(cv: conv, s: str) -> str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = alt cv.precision {\n@@ -378,7 +378,7 @@ mod rt {\n             };\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, pad_float }\n-    fn pad(cv: conv, &s: str, mode: pad_mode) -> str unsafe {\n+    fn pad(cv: conv, &s: str, mode: pad_mode) -> str {\n         let uwidth : uint = alt cv.width {\n           count_implied { ret s; }\n           count_is(width) {"}, {"sha": "f1017488ee743ac46ad18ea7661806a48d12a445", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -93,10 +93,10 @@ fn parse_buf(buf: [u8], radix: uint) -> option<T> {\n fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n #[doc = \"Convert to a string in a given base\"]\n-fn to_str(n: T, radix: uint) -> str unsafe {\n+fn to_str(n: T, radix: uint) -> str {\n     to_str_bytes(n, radix) {|slice|\n         vec::unpack_slice(slice) {|p, len|\n-            str::unsafe::from_buf_len(p, len)\n+            unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }\n }"}, {"sha": "5fda13bcd709cd41730649c648245207f918b182", "filename": "src/libcore/io.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -192,13 +192,13 @@ fn convert_whence(whence: seek_style) -> i32 {\n }\n \n impl of reader for *libc::FILE {\n-    fn read_bytes(len: uint) -> [u8] unsafe {\n+    fn read_bytes(len: uint) -> [u8] {\n         let mut buf : [mut u8] = [mut];\n         vec::reserve(buf, len);\n         vec::as_mut_buf(buf) {|b|\n             let read = libc::fread(b as *mut c_void, 1u as size_t,\n                                    len as size_t, self);\n-            vec::unsafe::set_len(buf, read as uint);\n+            unsafe { vec::unsafe::set_len(buf, read as uint) };\n         }\n         ret vec::from_mut(buf);\n     }\n@@ -333,7 +333,7 @@ impl <T: writer, C> of writer for {base: T, cleanup: C} {\n }\n \n impl of writer for *libc::FILE {\n-    fn write(v: [const u8]/&) unsafe {\n+    fn write(v: [const u8]/&) {\n         vec::unpack_const_slice(v) {|vbuf, len|\n             let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n                                     1u as size_t, self);\n@@ -361,7 +361,7 @@ fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n }\n \n impl of writer for fd_t {\n-    fn write(v: [const u8]/&) unsafe {\n+    fn write(v: [const u8]/&) {\n         let mut count = 0u;\n         vec::unpack_const_slice(v) {|vbuf, len|\n             while count < len {"}, {"sha": "fe07198b4222ca6b1a97c6058f57d69dd1479d1e", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -70,21 +70,23 @@ pure fn iter<T>(opt: option<T>, f: fn(T)) {\n     alt opt { none { } some(t) { f(t); } }\n }\n \n-pure fn unwrap<T>(-opt: option<T>) -> T unsafe {\n+pure fn unwrap<T>(-opt: option<T>) -> T {\n     #[doc = \"\n     Moves a value out of an option type and returns it.\n \n     Useful primarily for getting strings, vectors and unique pointers out of\n     option types without copying them.\n     \"];\n \n-    let addr = alt opt {\n-      some(x) { ptr::addr_of(x) }\n-      none { fail \"option none\" }\n-    };\n-    let liberated_value = unsafe::reinterpret_cast(*addr);\n-    unsafe::forget(opt);\n-    ret liberated_value;\n+    unsafe {\n+        let addr = alt opt {\n+          some(x) { ptr::addr_of(x) }\n+          none { fail \"option none\" }\n+        };\n+        let liberated_value = unsafe::reinterpret_cast(*addr);\n+        unsafe::forget(opt);\n+        ret liberated_value;\n+    }\n }\n \n impl extensions<T> for option<T> {"}, {"sha": "ee26bfc54960d5eb5dd5c260a6f3b99ae7c628fd", "filename": "src/libcore/os.rs", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -180,19 +180,21 @@ mod global_env {\n         }\n     }\n \n-    fn global_env_task(msg_po: comm::port<msg>) unsafe {\n-        priv::weaken_task {|weak_po|\n-            loop {\n-                alt comm::select2(msg_po, weak_po) {\n-                  either::left(msg_getenv(n, resp_ch)) {\n-                    comm::send(resp_ch, impl::getenv(n))\n-                  }\n-                  either::left(msg_setenv(n, v, resp_ch)) {\n-                    comm::send(resp_ch, impl::setenv(n, v))\n-                  }\n-                  either::right(_) {\n-                    break;\n-                  }\n+    fn global_env_task(msg_po: comm::port<msg>) {\n+        unsafe {\n+            priv::weaken_task {|weak_po|\n+                loop {\n+                    alt comm::select2(msg_po, weak_po) {\n+                      either::left(msg_getenv(n, resp_ch)) {\n+                        comm::send(resp_ch, impl::getenv(n))\n+                      }\n+                      either::left(msg_setenv(n, v, resp_ch)) {\n+                        comm::send(resp_ch, impl::setenv(n, v))\n+                      }\n+                      either::right(_) {\n+                        break;\n+                      }\n+                    }\n                 }\n             }\n         }\n@@ -201,18 +203,20 @@ mod global_env {\n     mod impl {\n \n         #[cfg(unix)]\n-        fn getenv(n: str) -> option<str> unsafe {\n-            let s = str::as_c_str(n, libc::getenv);\n-            ret if unsafe::reinterpret_cast(s) == 0 {\n-                option::none::<str>\n-            } else {\n-                let s = unsafe::reinterpret_cast(s);\n-                option::some::<str>(str::unsafe::from_buf(s))\n-            };\n+        fn getenv(n: str) -> option<str> {\n+            unsafe {\n+                let s = str::as_c_str(n, libc::getenv);\n+                ret if unsafe::reinterpret_cast(s) == 0 {\n+                    option::none::<str>\n+                } else {\n+                    let s = unsafe::reinterpret_cast(s);\n+                    option::some::<str>(str::unsafe::from_buf(s))\n+                };\n+            }\n         }\n \n         #[cfg(windows)]\n-        fn getenv(n: str) -> option<str> unsafe {\n+        fn getenv(n: str) -> option<str> {\n             import libc::types::os::arch::extra::*;\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n@@ -362,21 +366,23 @@ fn dll_filename(base: str) -> str {\n fn self_exe_path() -> option<path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    fn load_self() -> option<path> unsafe {\n-        import libc::funcs::bsd44::*;\n-        import libc::consts::os::extra::*;\n-        fill_charp_buf() {|buf, sz|\n-            let mib = [CTL_KERN as c_int,\n-                       KERN_PROC as c_int,\n-                       KERN_PROC_PATHNAME as c_int, -1 as c_int];\n-            sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n-                   buf as *mut c_void, ptr::mut_addr_of(sz),\n-                   ptr::null(), 0u as size_t) == (0 as c_int)\n+    fn load_self() -> option<path> {\n+        unsafe {\n+            import libc::funcs::bsd44::*;\n+            import libc::consts::os::extra::*;\n+            fill_charp_buf() {|buf, sz|\n+                let mib = [CTL_KERN as c_int,\n+                           KERN_PROC as c_int,\n+                           KERN_PROC_PATHNAME as c_int, -1 as c_int];\n+                sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n+                       buf as *mut c_void, ptr::mut_addr_of(sz),\n+                       ptr::null(), 0u as size_t) == (0 as c_int)\n+            }\n         }\n     }\n \n     #[cfg(target_os = \"linux\")]\n-    fn load_self() -> option<path> unsafe {\n+    fn load_self() -> option<path> {\n         import libc::funcs::posix01::unistd::readlink;\n         fill_charp_buf() {|buf, sz|\n             as_c_charp(\"/proc/self/exe\") { |proc_self_buf|\n@@ -386,17 +392,18 @@ fn self_exe_path() -> option<path> {\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    fn load_self() -> option<path> unsafe {\n+    fn load_self() -> option<path> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::*;\n+\n         fill_charp_buf() {|buf, sz|\n             _NSGetExecutablePath(buf, ptr::mut_addr_of(sz as u32))\n                 == (0 as c_int)\n         }\n     }\n \n     #[cfg(windows)]\n-    fn load_self() -> option<path> unsafe {\n+    fn load_self() -> option<path> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n@@ -525,14 +532,14 @@ fn make_dir(p: path, mode: c_int) -> bool {\n     ret mkdir(p, mode);\n \n     #[cfg(windows)]\n-    fn mkdir(p: path, _mode: c_int) -> bool unsafe {\n+    fn mkdir(p: path, _mode: c_int) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n         // FIXME: turn mode into something useful? #2623\n         as_utf16_p(p) {|buf|\n-            CreateDirectoryW(buf, unsafe::reinterpret_cast(0))\n+            CreateDirectoryW(buf, unsafe { unsafe::reinterpret_cast(0) })\n                 != (0 as BOOL)\n         }\n     }\n@@ -645,7 +652,7 @@ fn copy_file(from: path, to: path) -> bool {\n     }\n \n     #[cfg(unix)]\n-    fn do_copy_file(from: path, to: path) -> bool unsafe {\n+    fn do_copy_file(from: path, to: path) -> bool {\n         let istream = as_c_charp(from) {|fromp|\n             as_c_charp(\"rb\") {|modebuf|\n                 libc::fopen(fromp, modebuf)"}, {"sha": "93b32b6b8bdbb67b1e9b8cc32c6aaa59462d7bf1", "filename": "src/libcore/path.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -105,14 +105,20 @@ Given paths `pre` and `post, removes any trailing path separator on `pre` and\n any leading path separator on `post`, and returns the concatenation of the two\n with a single path separator between them.\n \"]\n-fn connect(pre: path, post: path) -> path unsafe {\n+fn connect(pre: path, post: path) -> path {\n     let mut pre_ = pre;\n     let mut post_ = post;\n     let sep = consts::path_sep as u8;\n     let pre_len  = str::len(pre);\n     let post_len = str::len(post);\n-    if pre_len > 1u && pre[pre_len-1u] == sep { str::unsafe::pop_byte(pre_); }\n-    if post_len > 1u && post[0] == sep { str::unsafe::shift_byte(post_); }\n+    unsafe {\n+        if pre_len > 1u && pre[pre_len-1u] == sep {\n+            str::unsafe::pop_byte(pre_);\n+        }\n+        if post_len > 1u && post[0] == sep {\n+            str::unsafe::shift_byte(post_);\n+        }\n+    }\n     ret pre_ + path_sep() + post_;\n }\n "}, {"sha": "5b59496a488c0c9cd7c1c0c1bd7a7fc9a8008aa1", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -82,7 +82,7 @@ unsafe fn chan_from_global_ptr<T: send>(\n }\n \n #[test]\n-fn test_from_global_chan1() unsafe {\n+fn test_from_global_chan1() {\n \n     // This is unreadable, right?\n \n@@ -91,21 +91,25 @@ fn test_from_global_chan1() unsafe {\n     let globchanp = ptr::addr_of(globchan);\n \n     // Create the global channel, attached to a new task\n-    let ch = chan_from_global_ptr(globchanp, task::builder) {|po|\n-        let ch = comm::recv(po);\n-        comm::send(ch, true);\n-        let ch = comm::recv(po);\n-        comm::send(ch, true);\n+    let ch = unsafe {\n+        chan_from_global_ptr(globchanp, task::builder) {|po|\n+            let ch = comm::recv(po);\n+            comm::send(ch, true);\n+            let ch = comm::recv(po);\n+            comm::send(ch, true);\n+        }\n     };\n     // Talk to it\n     let po = comm::port();\n     comm::send(ch, comm::chan(po));\n     assert comm::recv(po) == true;\n \n     // This one just reuses the previous channel\n-    let ch = chan_from_global_ptr(globchanp, task::builder) {|po|\n-        let ch = comm::recv(po);\n-        comm::send(ch, false);\n+    let ch = unsafe {\n+        chan_from_global_ptr(globchanp, task::builder) {|po|\n+            let ch = comm::recv(po);\n+            comm::send(ch, false);\n+        }\n     };\n \n     // Talk to the original global task\n@@ -115,7 +119,7 @@ fn test_from_global_chan1() unsafe {\n }\n \n #[test]\n-fn test_from_global_chan2() unsafe {\n+fn test_from_global_chan2() {\n \n     iter::repeat(100u) {||\n         // The global channel\n@@ -129,12 +133,14 @@ fn test_from_global_chan2() unsafe {\n         // create the global channel\n         for uint::range(0u, 10u) {|i|\n             task::spawn() {||\n-                let ch = chan_from_global_ptr(\n-                    globchanp, task::builder) {|po|\n-\n-                    for uint::range(0u, 10u) {|_j|\n-                        let ch = comm::recv(po);\n-                        comm::send(ch, {i});\n+                let ch = unsafe {\n+                    chan_from_global_ptr(\n+                        globchanp, task::builder) {|po|\n+\n+                        for uint::range(0u, 10u) {|_j|\n+                            let ch = comm::recv(po);\n+                            comm::send(ch, {i});\n+                        }\n                     }\n                 };\n                 let po = comm::port();\n@@ -174,10 +180,12 @@ This function is super-unsafe. Do not use.\n * Weak tasks must not be supervised. A supervised task keeps\n   a reference to its parent, so the parent will not die.\n \"]\n-unsafe fn weaken_task(f: fn(comm::port<()>)) unsafe {\n+unsafe fn weaken_task(f: fn(comm::port<()>)) {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    rustrt::rust_task_weaken(unsafe::reinterpret_cast(ch));\n+    unsafe {\n+        rustrt::rust_task_weaken(unsafe::reinterpret_cast(ch));\n+    }\n     let _unweaken = unweaken(ch);\n     f(po);\n \n@@ -191,50 +199,60 @@ unsafe fn weaken_task(f: fn(comm::port<()>)) unsafe {\n }\n \n #[test]\n-fn test_weaken_task_then_unweaken() unsafe {\n+fn test_weaken_task_then_unweaken() {\n     task::try {||\n-        weaken_task {|_po|\n+        unsafe {\n+            weaken_task {|_po|\n+            }\n         }\n     };\n }\n \n #[test]\n-fn test_weaken_task_wait() unsafe {\n+fn test_weaken_task_wait() {\n     let builder = task::builder();\n     task::unsupervise(builder);\n     task::run(builder) {||\n-        weaken_task {|po|\n-            comm::recv(po);\n+        unsafe {\n+            weaken_task {|po|\n+                comm::recv(po);\n+            }\n         }\n     }\n }\n \n #[test]\n-fn test_weaken_task_stress() unsafe {\n+fn test_weaken_task_stress() {\n     // Create a bunch of weak tasks\n     iter::repeat(100u) {||\n         task::spawn {||\n-            weaken_task {|_po|\n+            unsafe {\n+                weaken_task {|_po|\n+                }\n             }\n         }\n         let builder = task::builder();\n         task::unsupervise(builder);\n         task::run(builder) {||\n-            weaken_task {|po|\n-                // Wait for it to tell us to die\n-                comm::recv(po);\n+            unsafe {\n+                weaken_task {|po|\n+                    // Wait for it to tell us to die\n+                    comm::recv(po);\n+                }\n             }\n         }\n     }\n }\n \n #[test]\n #[ignore(cfg(windows))]\n-fn test_weaken_task_fail() unsafe {\n+fn test_weaken_task_fail() {\n     let res = task::try {||\n-        weaken_task {|_po|\n-            fail;\n+        unsafe {\n+            weaken_task {|_po|\n+                fail;\n+            }\n         }\n     };\n-    assert result::is_failure(res);\n+    assert result::is_err(res);\n }"}, {"sha": "d6288ea21268cf8c512cdddd24992a09d134136e", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -39,20 +39,26 @@ pure fn addr_of<T>(val: T) -> *T { unchecked { rusti::addr_of(val) } }\n \n #[doc = \"Get an unsafe mut pointer to a value\"]\n #[inline(always)]\n-pure fn mut_addr_of<T>(val: T) -> *mut T unsafe {\n-    unsafe::reinterpret_cast(rusti::addr_of(val))\n+pure fn mut_addr_of<T>(val: T) -> *mut T {\n+    unsafe {\n+        unsafe::reinterpret_cast(rusti::addr_of(val))\n+    }\n }\n \n #[doc = \"Calculate the offset from a pointer\"]\n #[inline(always)]\n-fn offset<T>(ptr: *T, count: uint) -> *T unsafe {\n-    (ptr as uint + count * sys::size_of::<T>()) as *T\n+fn offset<T>(ptr: *T, count: uint) -> *T {\n+    unsafe {\n+        (ptr as uint + count * sys::size_of::<T>()) as *T\n+    }\n }\n \n #[doc = \"Calculate the offset from a const pointer\"]\n #[inline(always)]\n-fn const_offset<T>(ptr: *const T, count: uint) -> *const T unsafe {\n-    (ptr as uint + count * sys::size_of::<T>()) as *T\n+fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n+    unsafe {\n+        (ptr as uint + count * sys::size_of::<T>()) as *T\n+    }\n }\n \n #[doc = \"Calculate the offset from a mut pointer\"]\n@@ -79,7 +85,7 @@ unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n \n #[doc = \"Create an unsafe null pointer\"]\n #[inline(always)]\n-pure fn null<T>() -> *T unsafe { ret unsafe::reinterpret_cast(0u); }\n+pure fn null<T>() -> *T { unsafe { unsafe::reinterpret_cast(0u) } }\n \n #[doc = \"Returns true if the pointer is equal to the null pointer.\"]\n pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n@@ -127,48 +133,52 @@ impl extensions<T> for *T {\n }\n \n #[test]\n-fn test() unsafe {\n-    type pair = {mut fst: int, mut snd: int};\n-    let p = {mut fst: 10, mut snd: 20};\n-    let pptr: *mut pair = mut_addr_of(p);\n-    let iptr: *mut int = unsafe::reinterpret_cast(pptr);\n-    assert (*iptr == 10);;\n-    *iptr = 30;\n-    assert (*iptr == 30);\n-    assert (p.fst == 30);;\n-\n-    *pptr = {mut fst: 50, mut snd: 60};\n-    assert (*iptr == 50);\n-    assert (p.fst == 50);\n-    assert (p.snd == 60);\n-\n-    let v0 = [32000u16, 32001u16, 32002u16];\n-    let v1 = [0u16, 0u16, 0u16];\n-\n-    ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 1u),\n-                ptr::offset(vec::unsafe::to_ptr(v0), 1u), 1u);\n-    assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-    ptr::memcpy(vec::unsafe::to_ptr(v1),\n-                ptr::offset(vec::unsafe::to_ptr(v0), 2u), 1u);\n-    assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-    ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 2u),\n-                vec::unsafe::to_ptr(v0), 1u);\n-    assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n+fn test() {\n+    unsafe {\n+        type pair = {mut fst: int, mut snd: int};\n+        let p = {mut fst: 10, mut snd: 20};\n+        let pptr: *mut pair = mut_addr_of(p);\n+        let iptr: *mut int = unsafe::reinterpret_cast(pptr);\n+        assert (*iptr == 10);;\n+        *iptr = 30;\n+        assert (*iptr == 30);\n+        assert (p.fst == 30);;\n+\n+        *pptr = {mut fst: 50, mut snd: 60};\n+        assert (*iptr == 50);\n+        assert (p.fst == 50);\n+        assert (p.snd == 60);\n+\n+        let v0 = [32000u16, 32001u16, 32002u16];\n+        let v1 = [0u16, 0u16, 0u16];\n+\n+        ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 1u),\n+                    ptr::offset(vec::unsafe::to_ptr(v0), 1u), 1u);\n+        assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n+        ptr::memcpy(vec::unsafe::to_ptr(v1),\n+                    ptr::offset(vec::unsafe::to_ptr(v0), 2u), 1u);\n+        assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n+        ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 2u),\n+                    vec::unsafe::to_ptr(v0), 1u);\n+        assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n+    }\n }\n \n #[test]\n-fn test_position() unsafe {\n+fn test_position() {\n     import str::as_c_str;\n     import libc::c_char;\n \n     let s = \"hello\";\n-    assert 2u == as_c_str(s) {|p| position(p) {|c| c == 'l' as c_char} };\n-    assert 4u == as_c_str(s) {|p| position(p) {|c| c == 'o' as c_char} };\n-    assert 5u == as_c_str(s) {|p| position(p) {|c| c == 0 as c_char } };\n+    unsafe {\n+        assert 2u == as_c_str(s) {|p| position(p) {|c| c == 'l' as c_char} };\n+        assert 4u == as_c_str(s) {|p| position(p) {|c| c == 'o' as c_char} };\n+        assert 5u == as_c_str(s) {|p| position(p) {|c| c == 0 as c_char } };\n+    }\n }\n \n #[test]\n-fn test_buf_len() unsafe {\n+fn test_buf_len() {\n     let s0 = \"hello\";\n     let s1 = \"there\";\n     let s2 = \"thing\";\n@@ -177,7 +187,7 @@ fn test_buf_len() unsafe {\n             str::as_c_str(s2) {|p2|\n                 let v = [p0, p1, p2, null()];\n                 vec::as_buf(v) {|vp|\n-                    assert buf_len(vp) == 3u;\n+                    assert unsafe { buf_len(vp) } == 3u;\n                 }\n             }\n         }"}, {"sha": "5c65971f2ea7141636274155c480d52fc7489a36", "filename": "src/libcore/result.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -43,16 +43,16 @@ pure fn get_err<T, U: copy>(res: result<T, U>) -> U {\n }\n \n #[doc = \"Returns true if the result is `ok`\"]\n-pure fn is_success<T, U>(res: result<T, U>) -> bool {\n+pure fn is_ok<T, U>(res: result<T, U>) -> bool {\n     alt res {\n       ok(_) { true }\n       err(_) { false }\n     }\n }\n \n-#[doc = \"Returns true if the result is `error`\"]\n-pure fn is_failure<T, U>(res: result<T, U>) -> bool {\n-    !is_success(res)\n+#[doc = \"Returns true if the result is `err`\"]\n+pure fn is_err<T, U>(res: result<T, U>) -> bool {\n+    !is_ok(res)\n }\n \n #[doc = \"\n@@ -180,22 +180,10 @@ fn map_err<T: copy, E, F: copy>(res: result<T, E>, op: fn(E) -> F)\n     }\n }\n \n-impl extensions<T:copy, E:copy> for result<T,E> {\n-    fn get() -> T { get(self) }\n-\n-    fn get_err() -> E { get_err(self) }\n-\n-    fn is_success() -> bool { is_success(self) }\n-\n-    fn is_failure() -> bool { is_failure(self) }\n-\n-    fn chain<U:copy>(op: fn(T) -> result<U,E>) -> result<U,E> {\n-        chain(self, op)\n-    }\n+impl extensions<T, E> for result<T, E> {\n+    fn is_ok() -> bool { is_ok(self) }\n \n-    fn chain_err<F:copy>(op: fn(E) -> result<T,F>) -> result<T,F> {\n-        chain_err(self, op)\n-    }\n+    fn is_err() -> bool { is_err(self) }\n \n     fn iter(f: fn(T)) {\n         alt self {\n@@ -210,19 +198,37 @@ impl extensions<T:copy, E:copy> for result<T,E> {\n           err(e) { f(e) }\n         }\n     }\n+}\n+\n+impl extensions<T:copy, E> for result<T, E> {\n+    fn get() -> T { get(self) }\n+\n+    fn map_err<F:copy>(op: fn(E) -> F) -> result<T,F> {\n+        alt self {\n+          ok(t) { ok(t) }\n+          err(e) { err(op(e)) }\n+        }\n+    }\n+}\n+\n+impl extensions<T, E:copy> for result<T, E> {\n+    fn get_err() -> E { get_err(self) }\n \n     fn map<U:copy>(op: fn(T) -> U) -> result<U,E> {\n         alt self {\n           ok(t) { ok(op(t)) }\n           err(e) { err(e) }\n         }\n     }\n+}\n \n-    fn map_err<F:copy>(op: fn(E) -> F) -> result<T,F> {\n-        alt self {\n-          ok(t) { ok(t) }\n-          err(e) { err(op(e)) }\n-        }\n+impl extensions<T:copy, E:copy> for result<T,E> {\n+    fn chain<U:copy>(op: fn(T) -> result<U,E>) -> result<U,E> {\n+        chain(self, op)\n+    }\n+\n+    fn chain_err<F:copy>(op: fn(E) -> result<T,F>) -> result<T,F> {\n+        chain_err(self, op)\n     }\n }\n \n@@ -320,14 +326,16 @@ fn iter_vec2<S,T,U:copy>(ss: [S], ts: [T],\n #[doc=\"\n Unwraps a result, assuming it is an `ok(T)`\n \"]\n-fn unwrap<T, U>(-res: result<T, U>) -> T unsafe {\n-    let addr = alt res {\n-      ok(x) { ptr::addr_of(x) }\n-      err(_) { fail \"error result\" }\n-    };\n-    let liberated_value = unsafe::reinterpret_cast(*addr);\n-    unsafe::forget(res);\n-    ret liberated_value;\n+fn unwrap<T, U>(-res: result<T, U>) -> T {\n+    unsafe {\n+        let addr = alt res {\n+          ok(x) { ptr::addr_of(x) }\n+          err(_) { fail \"error result\" }\n+        };\n+        let liberated_value = unsafe::reinterpret_cast(*addr);\n+        unsafe::forget(res);\n+        ret liberated_value;\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "beb314593ab51aa42035696f8641d64991da32b8", "filename": "src/libcore/run.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -66,7 +66,7 @@ fn spawn_process(prog: str, args: [str],\n                  env: option<[(str,str)]>,\n                  dir: option<str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n-   -> pid_t unsafe {\n+   -> pid_t {\n     with_argv(prog, args) {|argv|\n         with_envp(env) { |envp|\n             with_dirp(dir) { |dirp|\n@@ -78,7 +78,7 @@ fn spawn_process(prog: str, args: [str],\n }\n \n fn with_argv<T>(prog: str, args: [str],\n-                cb: fn(**libc::c_char) -> T) -> T unsafe {\n+                cb: fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog) {|b| [b] };\n     let mut tmps = [];\n     for vec::each(args) {|arg|\n@@ -92,7 +92,7 @@ fn with_argv<T>(prog: str, args: [str],\n \n #[cfg(unix)]\n fn with_envp<T>(env: option<[(str,str)]>,\n-                cb: fn(*c_void) -> T) -> T unsafe {\n+                cb: fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     alt env {\n@@ -107,7 +107,9 @@ fn with_envp<T>(env: option<[(str,str)]>,\n             ptrs += str::as_c_str(*t) {|b| [b]};\n         }\n         ptrs += [ptr::null()];\n-        vec::as_buf(ptrs) { |p| cb(::unsafe::reinterpret_cast(p)) }\n+        vec::as_buf(ptrs) { |p|\n+            unsafe { cb(::unsafe::reinterpret_cast(p)) }\n+        }\n       }\n       _ {\n         cb(ptr::null())\n@@ -117,31 +119,33 @@ fn with_envp<T>(env: option<[(str,str)]>,\n \n #[cfg(windows)]\n fn with_envp<T>(env: option<[(str,str)]>,\n-                cb: fn(*c_void) -> T) -> T unsafe {\n+                cb: fn(*c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n-    alt env {\n-      some(es) if !vec::is_empty(es) {\n-        let mut blk : [u8] = [];\n-        for vec::each(es) {|e|\n-            let (k,v) = e;\n-            let t = #fmt(\"%s=%s\", k, v);\n-            let mut v : [u8] = ::unsafe::reinterpret_cast(t);\n-            blk += v;\n-            ::unsafe::forget(v);\n+    unsafe {\n+        alt env {\n+          some(es) if !vec::is_empty(es) {\n+            let mut blk : [u8] = [];\n+            for vec::each(es) {|e|\n+                let (k,v) = e;\n+                let t = #fmt(\"%s=%s\", k, v);\n+                let mut v : [u8] = ::unsafe::reinterpret_cast(t);\n+                blk += v;\n+                ::unsafe::forget(v);\n+            }\n+            blk += [0_u8];\n+            vec::as_buf(blk) {|p| cb(::unsafe::reinterpret_cast(p)) }\n+          }\n+          _ {\n+            cb(ptr::null())\n+          }\n         }\n-        blk += [0_u8];\n-        vec::as_buf(blk) {|p| cb(::unsafe::reinterpret_cast(p)) }\n-      }\n-      _ {\n-        cb(ptr::null())\n-      }\n     }\n }\n \n fn with_dirp<T>(d: option<str>,\n-                cb: fn(*libc::c_char) -> T) -> T unsafe {\n+                cb: fn(*libc::c_char) -> T) -> T {\n     alt d {\n       some(dir) { str::as_c_str(dir, cb) }\n       none { cb(ptr::null()) }"}, {"sha": "90138468fa8c69978dff8a27fd3cc84a7e3613a4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 192, "deletions": 163, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -122,9 +122,9 @@ Convert a vector of bytes to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-pure fn from_bytes(vv: [u8]) -> str unsafe {\n-   assert is_utf8(vv);\n-   ret unsafe::from_bytes(vv);\n+pure fn from_bytes(vv: [u8]) -> str {\n+    assert is_utf8(vv);\n+    ret unsafe { unsafe::from_bytes(vv) };\n }\n \n #[doc = \"\n@@ -134,83 +134,85 @@ Convert a byte to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-pure fn from_byte(b: u8) -> str unsafe {\n+pure fn from_byte(b: u8) -> str {\n     assert b < 128u8;\n     let mut v = [b, 0u8];\n-    ::unsafe::transmute(v)\n+    unsafe { ::unsafe::transmute(v) }\n }\n \n #[doc = \"Appends a character at the end of a string\"]\n-fn push_char(&s: str, ch: char) unsafe {\n-    let code = ch as uint;\n-    let nb = if code < max_one_b { 1u }\n+fn push_char(&s: str, ch: char) {\n+    unsafe {\n+        let code = ch as uint;\n+        let nb = if code < max_one_b { 1u }\n         else if code < max_two_b { 2u }\n         else if code < max_three_b { 3u }\n         else if code < max_four_b { 4u }\n         else if code < max_five_b { 5u }\n         else { 6u };\n-    let len = len(s);\n-    let new_len = len + nb;\n-    reserve_at_least(s, new_len);\n-    let off = len;\n-    as_buf(s) {|buf|\n-        let buf: *mut u8 = ::unsafe::reinterpret_cast(buf);\n-        if nb == 1u {\n-            *ptr::mut_offset(buf, off) =\n-                code as u8;\n-        } else if nb == 2u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 6u & 31u | tag_two_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code & 63u | tag_cont) as u8;\n-        } else if nb == 3u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 12u & 15u | tag_three_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code >> 6u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 2u) =\n-                (code & 63u | tag_cont) as u8;\n-        } else if nb == 4u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 18u & 7u | tag_four_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code >> 12u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 2u) =\n-                (code >> 6u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 3u) =\n-                (code & 63u | tag_cont) as u8;\n-        } else if nb == 5u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 24u & 3u | tag_five_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code >> 18u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 2u) =\n-                (code >> 12u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 3u) =\n-                (code >> 6u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 4u) =\n-                (code & 63u | tag_cont) as u8;\n-        } else if nb == 6u {\n-            *ptr::mut_offset(buf, off) =\n-                (code >> 30u & 1u | tag_six_b) as u8;\n-            *ptr::mut_offset(buf, off + 1u) =\n-                (code >> 24u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 2u) =\n-                (code >> 18u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 3u) =\n-                (code >> 12u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 4u) =\n-                (code >> 6u & 63u | tag_cont) as u8;\n-            *ptr::mut_offset(buf, off + 5u) =\n-                (code & 63u | tag_cont) as u8;\n+        let len = len(s);\n+        let new_len = len + nb;\n+        reserve_at_least(s, new_len);\n+        let off = len;\n+        as_buf(s) {|buf|\n+            let buf: *mut u8 = ::unsafe::reinterpret_cast(buf);\n+            if nb == 1u {\n+                *ptr::mut_offset(buf, off) =\n+                    code as u8;\n+            } else if nb == 2u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 6u & 31u | tag_two_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code & 63u | tag_cont) as u8;\n+            } else if nb == 3u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 12u & 15u | tag_three_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code >> 6u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 2u) =\n+                    (code & 63u | tag_cont) as u8;\n+            } else if nb == 4u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 18u & 7u | tag_four_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code >> 12u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 2u) =\n+                    (code >> 6u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 3u) =\n+                    (code & 63u | tag_cont) as u8;\n+            } else if nb == 5u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 24u & 3u | tag_five_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code >> 18u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 2u) =\n+                    (code >> 12u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 3u) =\n+                    (code >> 6u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 4u) =\n+                    (code & 63u | tag_cont) as u8;\n+            } else if nb == 6u {\n+                *ptr::mut_offset(buf, off) =\n+                    (code >> 30u & 1u | tag_six_b) as u8;\n+                *ptr::mut_offset(buf, off + 1u) =\n+                    (code >> 24u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 2u) =\n+                    (code >> 18u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 3u) =\n+                    (code >> 12u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 4u) =\n+                    (code >> 6u & 63u | tag_cont) as u8;\n+                *ptr::mut_offset(buf, off + 5u) =\n+                    (code & 63u | tag_cont) as u8;\n+            }\n+            *ptr::mut_offset(buf, off + nb) = 0u8;\n         }\n-        *ptr::mut_offset(buf, off + nb) = 0u8;\n-    }\n \n-    as_bytes(s) {|bytes|\n-        let mut mut_bytes: [u8] = ::unsafe::reinterpret_cast(bytes);\n-        vec::unsafe::set_len(mut_bytes, new_len + 1u);\n-        ::unsafe::forget(mut_bytes);\n+        as_bytes(s) {|bytes|\n+            let mut mut_bytes: [u8] = ::unsafe::reinterpret_cast(bytes);\n+            vec::unsafe::set_len(mut_bytes, new_len + 1u);\n+            ::unsafe::forget(mut_bytes);\n+        }\n     }\n }\n \n@@ -276,9 +278,9 @@ Remove the first character from a string and return it\n \n If the string does not contain any characters\n \"]\n-fn shift_char(&s: str) -> char unsafe {\n+fn shift_char(&s: str) -> char {\n     let {ch, next} = char_range_at(s, 0u);\n-    s = unsafe::slice_bytes(s, next, len(s));\n+    s = unsafe { unsafe::slice_bytes(s, next, len(s)) };\n     ret ch;\n }\n \n@@ -320,20 +322,22 @@ Converts a string to a vector of bytes\n \n The result vector is not null-terminated.\n \"]\n-pure fn bytes(s: str) -> [u8] unsafe {\n-    let mut s_copy = s;\n-    let mut v: [u8] = ::unsafe::transmute(s_copy);\n-    vec::unsafe::set_len(v, len(s));\n-    ret v;\n+pure fn bytes(s: str) -> [u8] {\n+    unsafe {\n+        let mut s_copy = s;\n+        let mut v: [u8] = ::unsafe::transmute(s_copy);\n+        vec::unsafe::set_len(v, len(s));\n+        ret v;\n+    }\n }\n \n #[doc = \"\n Work with the string as a byte slice, not including trailing null.\n \"]\n #[inline(always)]\n-pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n+pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T {\n     unpack_slice(s) {|p,n|\n-        vec::unsafe::form_slice(p, n-1u, f)\n+        unsafe { vec::unsafe::form_slice(p, n-1u, f) }\n     }\n }\n \n@@ -365,10 +369,10 @@ Returns a slice of the given string from the byte range [`begin`..`end`)\n Fails when `begin` and `end` do not point to valid characters or\n beyond the last character of the string\n \"]\n-pure fn slice(s: str/&, begin: uint, end: uint) -> str unsafe {\n+pure fn slice(s: str/&, begin: uint, end: uint) -> str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n-    unsafe::slice_bytes(s, begin, end)\n+    unsafe { unsafe::slice_bytes(s, begin, end) }\n }\n \n #[doc = \"\n@@ -396,23 +400,23 @@ pure fn split_char_nonempty(s: str/&, sep: char) -> [str] {\n }\n \n pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n-    -> [str] unsafe {\n+    -> [str] {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut result = [], done = 0u;\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n-                    result += [unsafe::slice_bytes(s, start, i)];\n+                    result += [unsafe { unsafe::slice_bytes(s, start, i) }];\n                 }\n                 start = i + 1u;\n                 done += 1u;\n             }\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            result += [unsafe::slice_bytes(s, start, l)];\n+            result += [unsafe { unsafe::slice_bytes(s, start, l) }];\n         }\n         result\n     } else {\n@@ -440,22 +444,22 @@ pure fn split_nonempty(s: str/&, sepfn: fn(char) -> bool) -> [str] {\n }\n \n pure fn split_inner(s: str/&, sepfn: fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool) -> [str] unsafe {\n+               allow_empty: bool) -> [str] {\n     let l = len(s);\n     let mut result = [], i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i {\n-                result += [unsafe::slice_bytes(s, start, i)];\n+                result += [unsafe { unsafe::slice_bytes(s, start, i) }];\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_empty || start < l {\n-        result += [unsafe::slice_bytes(s, start, l)];\n+        result += [unsafe { unsafe::slice_bytes(s, start, l) }];\n     }\n     result\n }\n@@ -578,7 +582,7 @@ Replace all occurrences of one string with another\n \n The original string with all occurances of `from` replaced with `to`\n \"]\n-pure fn replace(s: str, from: str, to: str) -> str unsafe {\n+pure fn replace(s: str, from: str, to: str) -> str {\n     let mut result = \"\", first = true;\n     iter_between_matches(s, from) {|start, end|\n         if first { first = false; } else { result += to; }\n@@ -709,7 +713,7 @@ Apply a function to each substring after splitting by character, up to\n `count` times\n \"]\n pure fn splitn_char_iter(ss: str/&, sep: char, count: uint,\n-                         ff: fn(&&str)) unsafe {\n+                         ff: fn(&&str)) {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n@@ -1149,7 +1153,7 @@ Returns true if one string starts with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool unsafe {\n+pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1564,9 +1568,11 @@ interop.\n let i = str::as_bytes(\\\"Hello World\\\") { |bytes| vec::len(bytes) };\n ~~~\n \"]\n-pure fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T unsafe {\n-    let v: *[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    f(*v)\n+pure fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T {\n+    unsafe {\n+        let v: *[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        f(*v)\n+    }\n }\n \n #[doc = \"\n@@ -1575,8 +1581,8 @@ Work with the byte buffer of a string.\n Allows for unsafe manipulation of strings, which is useful for native\n interop.\n \"]\n-pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T unsafe {\n-    as_bytes(s) { |v| vec::as_buf(v, f) }\n+pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T {\n+    as_bytes(s) { |v| unsafe { vec::as_buf(v, f) } }\n }\n \n #[doc = \"\n@@ -1591,7 +1597,7 @@ interop, without copying the original string.\n let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n ~~~\n \"]\n-pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T unsafe {\n+pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T {\n     as_buf(s) {|buf| f(buf as *libc::c_char) }\n }\n \n@@ -1605,10 +1611,12 @@ indexable area for a null byte, as is the case in slices pointing\n to full strings, or suffixes of them.\n \"]\n #[inline(always)]\n-pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T unsafe {\n-    let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    let (buf,len) = *v;\n-    f(buf, len)\n+pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T {\n+    unsafe {\n+        let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len)\n+    }\n }\n \n #[doc = \"\n@@ -1653,15 +1661,15 @@ capacity, then no action is taken.\n * s - A string\n * n - The number of bytes to reserve space for\n \"]\n-fn reserve_at_least(&s: str, n: uint) unsafe {\n+fn reserve_at_least(&s: str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n \n #[doc = \"\n Returns the number of single-byte characters the string can hold without\n reallocating\n \"]\n-pure fn capacity(&&s: str) -> uint unsafe {\n+pure fn capacity(&&s: str) -> uint {\n     as_bytes(s) {|buf|\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n@@ -1742,10 +1750,12 @@ mod unsafe {\n \n    Does not verify that the vector contains valid UTF-8.\n    \"]\n-   unsafe fn from_bytes(v: [const u8]) -> str unsafe {\n-       let mut vcopy : [u8] = ::unsafe::transmute(copy v);\n-       vec::push(vcopy, 0u8);\n-       ::unsafe::transmute(vcopy)\n+   unsafe fn from_bytes(v: [const u8]) -> str {\n+       unsafe {\n+           let mut vcopy : [u8] = ::unsafe::transmute(copy v);\n+           vec::push(vcopy, 0u8);\n+           ::unsafe::transmute(vcopy)\n+       }\n    }\n \n    #[doc = \"\n@@ -1765,20 +1775,22 @@ mod unsafe {\n    If begin is greater than end.\n    If end is greater than the length of the string.\n    \"]\n-   unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str unsafe {\n+   unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str {\n        unpack_slice(s) { |sbuf, n|\n            assert (begin <= end);\n            assert (end <= n);\n \n            let mut v = [];\n            vec::reserve(v, end - begin + 1u);\n-           vec::as_buf(v) { |vbuf|\n-               let src = ptr::offset(sbuf, begin);\n-               ptr::memcpy(vbuf, src, end - begin);\n+           unsafe {\n+               vec::as_buf(v) { |vbuf|\n+                   let src = ptr::offset(sbuf, begin);\n+                   ptr::memcpy(vbuf, src, end - begin);\n+               }\n+               vec::unsafe::set_len(v, end - begin);\n+               v += [0u8];\n+               ::unsafe::transmute(v)\n            }\n-           vec::unsafe::set_len(v, end - begin);\n-           v += [0u8];\n-           ::unsafe::transmute(v)\n        }\n    }\n \n@@ -1795,22 +1807,22 @@ mod unsafe {\n    #[doc = \"\n    Removes the last byte from a string and returns it. (Not UTF-8 safe).\n    \"]\n-   unsafe fn pop_byte(&s: str) -> u8 unsafe {\n+   unsafe fn pop_byte(&s: str) -> u8 {\n        let len = len(s);\n        assert (len > 0u);\n        let b = s[len - 1u];\n-       set_len(s, len - 1u);\n+       unsafe { set_len(s, len - 1u) };\n        ret b;\n    }\n \n    #[doc = \"\n    Removes the first byte from a string and returns it. (Not UTF-8 safe).\n    \"]\n-   unsafe fn shift_byte(&s: str) -> u8 unsafe {\n+   unsafe fn shift_byte(&s: str) -> u8 {\n        let len = len(s);\n        assert (len > 0u);\n        let b = s[0];\n-       s = unsafe::slice_bytes(s, 1u, len);\n+       s = unsafe { unsafe::slice_bytes(s, 1u, len) };\n        ret b;\n    }\n \n@@ -1825,11 +1837,13 @@ mod unsafe {\n     }\n \n     #[test]\n-    fn test_from_buf_len() unsafe {\n-        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-        let b = vec::unsafe::to_ptr(a);\n-        let c = from_buf_len(b, 3u);\n-        assert (c == \"AAA\");\n+    fn test_from_buf_len() {\n+        unsafe {\n+            let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let b = vec::unsafe::to_ptr(a);\n+            let c = from_buf_len(b, 3u);\n+            assert (c == \"AAA\");\n+        }\n     }\n \n }\n@@ -2274,24 +2288,27 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unsafe_slice() unsafe {\n-        assert (eq(\"ab\", unsafe::slice_bytes(\"abc\", 0u, 2u)));\n-        assert (eq(\"bc\", unsafe::slice_bytes(\"abc\", 1u, 3u)));\n-        assert (eq(\"\", unsafe::slice_bytes(\"abc\", 1u, 1u)));\n-        fn a_million_letter_a() -> str {\n-            let mut i = 0;\n-            let mut rs = \"\";\n-            while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n-            ret rs;\n-        }\n-        fn half_a_million_letter_a() -> str {\n-            let mut i = 0;\n-            let mut rs = \"\";\n-            while i < 100000 { rs += \"aaaaa\"; i += 1; }\n-            ret rs;\n+    fn test_unsafe_slice() {\n+        unsafe {\n+            assert (eq(\"ab\", unsafe::slice_bytes(\"abc\", 0u, 2u)));\n+            assert (eq(\"bc\", unsafe::slice_bytes(\"abc\", 1u, 3u)));\n+            assert (eq(\"\", unsafe::slice_bytes(\"abc\", 1u, 1u)));\n+            fn a_million_letter_a() -> str {\n+                let mut i = 0;\n+                let mut rs = \"\";\n+                while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n+                ret rs;\n+            }\n+            fn half_a_million_letter_a() -> str {\n+                let mut i = 0;\n+                let mut rs = \"\";\n+                while i < 100000 { rs += \"aaaaa\"; i += 1; }\n+                ret rs;\n+            }\n+            assert eq(half_a_million_letter_a(),\n+                      unsafe::slice_bytes(a_million_letter_a(),\n+                                          0u, 500000u));\n         }\n-        assert (eq(half_a_million_letter_a(),\n-               unsafe::slice_bytes(a_million_letter_a(), 0u, 500000u)));\n     }\n \n     #[test]\n@@ -2483,25 +2500,25 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_shift_byte() unsafe {\n+    fn test_shift_byte() {\n         let mut s = \"ABC\";\n-        let b = unsafe::shift_byte(s);\n+        let b = unsafe { unsafe::shift_byte(s) };\n         assert (s == \"BC\");\n         assert (b == 65u8);\n     }\n \n     #[test]\n-    fn test_pop_byte() unsafe {\n+    fn test_pop_byte() {\n         let mut s = \"ABC\";\n-        let b = unsafe::pop_byte(s);\n+        let b = unsafe { unsafe::pop_byte(s) };\n         assert (s == \"AB\");\n         assert (b == 67u8);\n     }\n \n     #[test]\n-    fn test_unsafe_from_bytes() unsafe {\n+    fn test_unsafe_from_bytes() {\n         let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-        let b = unsafe::from_bytes(a);\n+        let b = unsafe { unsafe::from_bytes(a) };\n         assert (b == \"AAAAAAA\");\n     }\n \n@@ -2541,11 +2558,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_buf() unsafe {\n-        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-        let b = vec::unsafe::to_ptr(a);\n-        let c = unsafe::from_buf(b);\n-        assert (c == \"AAAAAAA\");\n+    fn test_from_buf() {\n+        unsafe {\n+            let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let b = vec::unsafe::to_ptr(a);\n+            let c = unsafe::from_buf(b);\n+            assert (c == \"AAAAAAA\");\n+        }\n     }\n \n     #[test]\n@@ -2557,25 +2576,33 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_buf() unsafe {\n+    fn test_as_buf() {\n         let a = \"Abcdefg\";\n-        let b = as_buf(a, {|buf| assert (*buf == 65u8); 100 });\n+        let b = as_buf(a, {|buf|\n+            assert unsafe { *buf } == 65u8;\n+            100\n+        });\n         assert (b == 100);\n     }\n \n     #[test]\n-    fn test_as_buf_small() unsafe {\n+    fn test_as_buf_small() {\n         let a = \"A\";\n-        let b = as_buf(a, {|buf| assert (*buf == 65u8); 100 });\n+        let b = as_buf(a, {|buf|\n+            assert unsafe { *buf } == 65u8;\n+            100\n+        });\n         assert (b == 100);\n     }\n \n     #[test]\n-    fn test_as_buf2() unsafe {\n-        let s = \"hello\";\n-        let sb = as_buf(s, {|b| b });\n-        let s_cstr = unsafe::from_buf(sb);\n-        assert (eq(s_cstr, s));\n+    fn test_as_buf2() {\n+        unsafe {\n+            let s = \"hello\";\n+            let sb = as_buf(s, {|b| b });\n+            let s_cstr = unsafe::from_buf(sb);\n+            assert (eq(s_cstr, s));\n+        }\n     }\n \n     #[test]\n@@ -2813,14 +2840,16 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unpack_slice() unsafe {\n+    fn test_unpack_slice() {\n         let a = \"hello\";\n         unpack_slice(a) {|buf, len|\n-            assert a[0] == 'h' as u8;\n-            assert *buf == 'h' as u8;\n-            assert len == 6u;\n-            assert *ptr::offset(buf,4u) == 'o' as u8;\n-            assert *ptr::offset(buf,5u) == 0u8;\n+            unsafe {\n+                assert a[0] == 'h' as u8;\n+                assert *buf == 'h' as u8;\n+                assert len == 6u;\n+                assert *ptr::offset(buf,4u) == 'o' as u8;\n+                assert *ptr::offset(buf,5u) == 0u8;\n+            }\n         }\n     }\n "}, {"sha": "771107cd1a7e9f277d0ecba7626e3c43217837dc", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -52,7 +52,7 @@ pure fn get_type_desc<T>() -> *type_desc {\n \n #[doc = \"Returns the size of a type\"]\n #[inline(always)]\n-pure fn size_of<T>() -> uint unsafe {\n+pure fn size_of<T>() -> uint {\n     unchecked { rusti::size_of::<T>() }\n }\n \n@@ -62,12 +62,12 @@ Returns the ABI-required minimum alignment of a type\n This is the alignment used for struct fields. It may be smaller\n than the preferred alignment.\n \"]\n-pure fn min_align_of<T>() -> uint unsafe {\n+pure fn min_align_of<T>() -> uint {\n     unchecked { rusti::min_align_of::<T>() }\n }\n \n #[doc = \"Returns the preferred alignment of a type\"]\n-pure fn pref_align_of<T>() -> uint unsafe {\n+pure fn pref_align_of<T>() -> uint {\n     unchecked { rusti::pref_align_of::<T>() }\n }\n "}, {"sha": "a284fc13e2e4cb0f4ae01fec31e8a2a2837baf24", "filename": "src/libcore/task.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -504,7 +504,7 @@ type task_id = int;\n type rust_task = libc::c_void;\n type rust_closure = libc::c_void;\n \n-fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n+fn spawn_raw(opts: task_opts, +f: fn~()) {\n \n     let mut f = if opts.supervise {\n         f\n@@ -519,25 +519,27 @@ fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n         }\n     };\n \n-    let fptr = ptr::addr_of(f);\n-    let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n+    unsafe {\n+        let fptr = ptr::addr_of(f);\n+        let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n \n-    let new_task = alt opts.sched {\n-      none {\n-        rustrt::new_task()\n-      }\n-      some(sched_opts) {\n-        new_task_in_new_sched(sched_opts)\n-      }\n-    };\n+        let new_task = alt opts.sched {\n+          none {\n+            rustrt::new_task()\n+          }\n+          some(sched_opts) {\n+            new_task_in_new_sched(sched_opts)\n+          }\n+        };\n \n-    option::iter(opts.notify_chan) {|c|\n-        // FIXME (#1087): Would like to do notification in Rust\n-        rustrt::rust_task_config_notify(new_task, c);\n-    }\n+        option::iter(opts.notify_chan) {|c|\n+            // FIXME (#1087): Would like to do notification in Rust\n+            rustrt::rust_task_config_notify(new_task, c);\n+        }\n \n-    rustrt::start_task(new_task, closure);\n-    unsafe::forget(f);\n+        rustrt::start_task(new_task, closure);\n+        unsafe::forget(f);\n+    }\n \n     fn new_task_in_new_sched(opts: sched_opts) -> *rust_task {\n         if opts.native_stack_size != none {\n@@ -962,7 +964,7 @@ fn test_osmain() {\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n-fn test_unkillable() unsafe {\n+fn test_unkillable() {\n     import comm::methods;\n     let po = comm::port();\n     let ch = po.chan();\n@@ -980,14 +982,16 @@ fn test_unkillable() unsafe {\n         fail;\n     }\n \n-    unkillable {||\n-        let p = ~0;\n-        let pp: *uint = unsafe::transmute(p);\n+    unsafe {\n+        unkillable {||\n+            let p = ~0;\n+            let pp: *uint = unsafe::transmute(p);\n \n-        // If we are killed here then the box will leak\n-        po.recv();\n+            // If we are killed here then the box will leak\n+            po.recv();\n \n-        let _p: ~int = unsafe::transmute(pp);\n+            let _p: ~int = unsafe::transmute(pp);\n+        }\n     }\n \n     // Now we can be killed"}, {"sha": "d5f0cc465c7eb2ce8ed43d6eedd2d47e3f8e1d57", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -131,17 +131,17 @@ Convert to a string in a given base\n \n Fails if `radix` < 2 or `radix` > 16\n \"]\n-fn to_str(num: T, radix: uint) -> str unsafe {\n+fn to_str(num: T, radix: uint) -> str {\n     to_str_bytes(false, num, radix) {|slice|\n         vec::unpack_slice(slice) {|p, len|\n-            str::unsafe::from_buf_len(p, len)\n+            unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }\n }\n \n #[doc = \"Low-level helper routine for string conversion.\"]\n fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n-                   f: fn([u8]/&) -> U) -> U unsafe {\n+                   f: fn([u8]/&) -> U) -> U {\n \n     #[inline(always)]\n     fn digit(n: T) -> u8 {\n@@ -177,28 +177,30 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n     // pointers and unsafe bits, and the codegen will prove it's all\n     // in-bounds, no extra cost.\n \n-    vec::unpack_slice(buf) {|p, len|\n-        let mp = p as *mut u8;\n-        let mut i = len;\n-        let mut n = num;\n-        let radix = radix as T;\n-        loop {\n-            i -= 1u;\n+    unsafe {\n+        vec::unpack_slice(buf) {|p, len|\n+            let mp = p as *mut u8;\n+            let mut i = len;\n+            let mut n = num;\n+            let radix = radix as T;\n+            loop {\n+                i -= 1u;\n+                assert 0u < i && i < len;\n+                *ptr::mut_offset(mp, i) = digit(n % radix);\n+                n /= radix;\n+                if n == 0 as T { break; }\n+            }\n+\n             assert 0u < i && i < len;\n-            *ptr::mut_offset(mp, i) = digit(n % radix);\n-            n /= radix;\n-            if n == 0 as T { break; }\n-        }\n \n-        assert 0u < i && i < len;\n+            if neg {\n+                i -= 1u;\n+                *ptr::mut_offset(mp, i) = '-' as u8;\n+            }\n \n-        if neg {\n-            i -= 1u;\n-            *ptr::mut_offset(mp, i) = '-' as u8;\n+            vec::unsafe::form_slice(ptr::offset(p, i),\n+                                    len - i, f)\n         }\n-\n-        vec::unsafe::form_slice(ptr::offset(p, i),\n-                                len - i, f)\n     }\n }\n "}, {"sha": "85e2f8d8934e9c56b0e61cc9e938f57e00a98e36", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -45,20 +45,24 @@ unsafe fn transmute<L, G>(-thing: L) -> G {\n mod tests {\n \n     #[test]\n-    fn test_reinterpret_cast() unsafe {\n-        assert reinterpret_cast(1) == 1u;\n+    fn test_reinterpret_cast() {\n+        assert unsafe { reinterpret_cast(1) } == 1u;\n     }\n \n     #[test]\n-    fn test_transmute() unsafe {\n-        let x = @1;\n-        let x: *int = transmute(x);\n-        assert *x == 1;\n-        let _x: @int = transmute(x);\n+    fn test_transmute() {\n+        unsafe {\n+            let x = @1;\n+            let x: *int = transmute(x);\n+            assert *x == 1;\n+            let _x: @int = transmute(x);\n+        }\n     }\n \n     #[test]\n-    fn test_transmute2() unsafe {\n-        assert transmute(\"L\") == [76u8, 0u8];\n+    fn test_transmute2() {\n+        unsafe {\n+            assert transmute(\"L\") == [76u8, 0u8];\n+        }\n     }\n }"}, {"sha": "b81073c729f747f1276ff67145c15052f0b6fa68", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 111, "deletions": 72, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -158,14 +158,16 @@ fn reserve_at_least<T>(&v: [const T], n: uint) {\n Returns the number of elements the vector can hold without reallocating\n \"]\n #[inline(always)]\n-pure fn capacity<T>(&&v: [const T]) -> uint unsafe {\n-    let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n-    (**repr).alloc / sys::size_of::<T>()\n+pure fn capacity<T>(&&v: [const T]) -> uint {\n+    unsafe {\n+        let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        (**repr).alloc / sys::size_of::<T>()\n+    }\n }\n \n #[doc = \"Returns the length of a vector\"]\n #[inline(always)]\n-pure fn len<T>(&&v: [const T]/&) -> uint unsafe {\n+pure fn len<T>(&&v: [const T]/&) -> uint {\n     unpack_const_slice(v) {|_p, len| len}\n }\n \n@@ -179,7 +181,7 @@ pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> [T] {\n     let mut v = [];\n     unchecked{reserve(v, n_elts);}\n     let mut i: uint = 0u;\n-    while i < n_elts { v += [op(i)]; i += 1u; }\n+    while i < n_elts unsafe { push(v, op(i)); i += 1u; }\n     ret v;\n }\n \n@@ -200,13 +202,13 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n }\n \n #[doc = \"Produces a mut vector from an immutable vector.\"]\n-fn to_mut<T>(+v: [T]) -> [mut T] unsafe {\n-    ::unsafe::transmute(v)\n+fn to_mut<T>(+v: [T]) -> [mut T] {\n+    unsafe { ::unsafe::transmute(v) }\n }\n \n #[doc = \"Produces an immutable vector from a mut vector.\"]\n-fn from_mut<T>(+v: [mut T]) -> [T] unsafe {\n-    ::unsafe::transmute(v)\n+fn from_mut<T>(+v: [mut T]) -> [T] {\n+    unsafe { ::unsafe::transmute(v) }\n }\n \n // Accessors\n@@ -385,7 +387,6 @@ fn shift<T>(&v: [T]) -> T {\n             let mut r <- *vv;\n \n             for uint::range(1u, ln) {|i|\n-                // FIXME (#2703): this isn't legal, per se...\n                 let r <- *ptr::offset(vv, i);\n                 push(v, r);\n             }\n@@ -397,14 +398,25 @@ fn shift<T>(&v: [T]) -> T {\n     }\n }\n \n+#[doc = \"Prepend an element to the vector\"]\n+fn unshift<T>(&v: [T], +x: T) {\n+    let mut vv = [x];\n+    v <-> vv;\n+    while len(vv) > 0 {\n+        push(v, shift(vv));\n+    }\n+}\n+\n #[doc = \"Remove the last element from a vector and return it\"]\n-fn pop<T>(&v: [const T]) -> T unsafe {\n+fn pop<T>(&v: [const T]) -> T {\n     let ln = len(v);\n     assert ln > 0u;\n     let valptr = ptr::mut_addr_of(v[ln - 1u]);\n-    let val <- *valptr;\n-    unsafe::set_len(v, ln - 1u);\n-    val\n+    unsafe {\n+        let val <- *valptr;\n+        unsafe::set_len(v, ln - 1u);\n+        val\n+    }\n }\n \n #[doc = \"Append an element to a vector\"]\n@@ -556,7 +568,7 @@ Apply a function to each element of a vector and return the results\n pure fn mapi<T, U>(v: [T]/&, f: fn(uint, T) -> U) -> [U] {\n     let mut result = [];\n     unchecked{reserve(result, len(v));}\n-    for eachi(v) {|i, elem| result += [f(i, elem)]; }\n+    for eachi(v) {|i, elem| unsafe { push(result, f(i, elem)); } }\n     ret result;\n }\n \n@@ -955,13 +967,15 @@ Iterates over a vector, with option to break\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn each<T>(v: [const T]/&, f: fn(T) -> bool) unsafe {\n+pure fn each<T>(v: [const T]/&, f: fn(T) -> bool) {\n     vec::unpack_slice(v) {|p, n|\n         let mut n = n;\n         let mut p = p;\n         while n > 0u {\n-            if !f(*p) { break; }\n-            p = ptr::offset(p, 1u);\n+            unsafe {\n+                if !f(*p) { break; }\n+                p = ptr::offset(p, 1u);\n+            }\n             n -= 1u;\n         }\n     }\n@@ -973,13 +987,15 @@ Iterates over a vector's elements and indices\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) unsafe {\n+pure fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) {\n     vec::unpack_slice(v) {|p, n|\n         let mut i = 0u;\n         let mut p = p;\n         while i < n {\n-            if !f(i, *p) { break; }\n-            p = ptr::offset(p, 1u);\n+            unsafe {\n+                if !f(i, *p) { break; }\n+                p = ptr::offset(p, 1u);\n+            }\n             i += 1u;\n         }\n     }\n@@ -1080,11 +1096,11 @@ Work with the buffer of a vector.\n Allows for unsafe manipulation of vector contents, which is useful for native\n interop.\n \"]\n-fn as_buf<E,T>(v: [E]/&, f: fn(*E) -> T) -> T unsafe {\n+fn as_buf<E,T>(v: [E]/&, f: fn(*E) -> T) -> T {\n     unpack_slice(v) { |buf, _len| f(buf) }\n }\n \n-fn as_mut_buf<E,T>(v: [mut E]/&, f: fn(*mut E) -> T) -> T unsafe {\n+fn as_mut_buf<E,T>(v: [mut E]/&, f: fn(*mut E) -> T) -> T {\n     unpack_mut_slice(v) { |buf, _len| f(buf) }\n }\n \n@@ -1093,32 +1109,40 @@ Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n pure fn unpack_slice<T,U>(s: [const T]/&,\n-                          f: fn(*T, uint) -> U) -> U unsafe {\n-    let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    let (buf,len) = *v;\n-    f(buf, len / sys::size_of::<T>())\n+                          f: fn(*T, uint) -> U) -> U {\n+    unsafe {\n+        let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len / sys::size_of::<T>())\n+    }\n }\n \n #[doc = \"\n Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n pure fn unpack_const_slice<T,U>(s: [const T]/&,\n-                                f: fn(*const T, uint) -> U) -> U unsafe {\n-    let v : *(*const T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    let (buf,len) = *v;\n-    f(buf, len / sys::size_of::<T>())\n+                                f: fn(*const T, uint) -> U) -> U {\n+    unsafe {\n+        let v : *(*const T,uint) =\n+            ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len / sys::size_of::<T>())\n+    }\n }\n \n #[doc = \"\n Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n pure fn unpack_mut_slice<T,U>(s: [mut T]/&,\n-                              f: fn(*mut T, uint) -> U) -> U unsafe {\n-    let v : *(*const T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-    let (buf,len) = *v;\n-    f(buf, len / sys::size_of::<T>())\n+                              f: fn(*mut T, uint) -> U) -> U {\n+    unsafe {\n+        let v : *(*const T,uint) =\n+            ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len / sys::size_of::<T>())\n+    }\n }\n \n impl extensions<T: copy> for [T] {\n@@ -1372,12 +1396,14 @@ mod u8 {\n     export hash;\n \n     #[doc = \"Bytewise string comparison\"]\n-    pure fn cmp(&&a: [u8], &&b: [u8]) -> int unsafe {\n+    pure fn cmp(&&a: [u8], &&b: [u8]) -> int {\n         let a_len = len(a);\n         let b_len = len(b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n-        let r = libc::memcmp(unsafe::to_ptr(a) as *libc::c_void,\n-                             unsafe::to_ptr(b) as *libc::c_void, n) as int;\n+        let r = unsafe {\n+            libc::memcmp(unsafe::to_ptr(a) as *libc::c_void,\n+                         unsafe::to_ptr(b) as *libc::c_void, n) as int\n+        };\n \n         if r != 0 { r } else {\n             if a_len == b_len {\n@@ -1397,10 +1423,10 @@ mod u8 {\n     pure fn le(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) <= 0 }\n \n     #[doc = \"Bytewise equality\"]\n-    pure fn eq(&&a: [u8], &&b: [u8]) -> bool unsafe { cmp(a, b) == 0 }\n+    pure fn eq(&&a: [u8], &&b: [u8]) -> bool { unsafe { cmp(a, b) == 0 } }\n \n     #[doc = \"Bytewise inequality\"]\n-    pure fn ne(&&a: [u8], &&b: [u8]) -> bool unsafe { cmp(a, b) != 0 }\n+    pure fn ne(&&a: [u8], &&b: [u8]) -> bool { unsafe { cmp(a, b) != 0 } }\n \n     #[doc =\"Bytewise greater than or equal\"]\n     pure fn ge(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) >= 0 }\n@@ -1474,26 +1500,28 @@ mod tests {\n     fn add(&&x: uint, &&y: uint) -> uint { ret x + y; }\n \n     #[test]\n-    fn test_unsafe_ptrs() unsafe {\n-        // Test on-stack copy-from-buf.\n-        let a = [1, 2, 3];\n-        let mut ptr = unsafe::to_ptr(a);\n-        let b = unsafe::from_buf(ptr, 3u);\n-        assert (len(b) == 3u);\n-        assert (b[0] == 1);\n-        assert (b[1] == 2);\n-        assert (b[2] == 3);\n-\n-        // Test on-heap copy-from-buf.\n-        let c = [1, 2, 3, 4, 5];\n-        ptr = unsafe::to_ptr(c);\n-        let d = unsafe::from_buf(ptr, 5u);\n-        assert (len(d) == 5u);\n-        assert (d[0] == 1);\n-        assert (d[1] == 2);\n-        assert (d[2] == 3);\n-        assert (d[3] == 4);\n-        assert (d[4] == 5);\n+    fn test_unsafe_ptrs() {\n+        unsafe {\n+            // Test on-stack copy-from-buf.\n+            let a = [1, 2, 3];\n+            let mut ptr = unsafe::to_ptr(a);\n+            let b = unsafe::from_buf(ptr, 3u);\n+            assert (len(b) == 3u);\n+            assert (b[0] == 1);\n+            assert (b[1] == 2);\n+            assert (b[2] == 3);\n+\n+            // Test on-heap copy-from-buf.\n+            let c = [1, 2, 3, 4, 5];\n+            ptr = unsafe::to_ptr(c);\n+            let d = unsafe::from_buf(ptr, 5u);\n+            assert (len(d) == 5u);\n+            assert (d[0] == 1);\n+            assert (d[1] == 2);\n+            assert (d[2] == 3);\n+            assert (d[3] == 4);\n+            assert (d[4] == 5);\n+        }\n     }\n \n     #[test]\n@@ -2181,21 +2209,32 @@ mod tests {\n     }\n \n     #[test]\n-    fn to_mut_no_copy() unsafe {\n-        let x = [1, 2, 3];\n-        let addr = unsafe::to_ptr(x);\n-        let x_mut = to_mut(x);\n-        let addr_mut = unsafe::to_ptr(x_mut);\n-        assert addr == addr_mut;\n+    fn to_mut_no_copy() {\n+        unsafe {\n+            let x = [1, 2, 3];\n+            let addr = unsafe::to_ptr(x);\n+            let x_mut = to_mut(x);\n+            let addr_mut = unsafe::to_ptr(x_mut);\n+            assert addr == addr_mut;\n+        }\n+    }\n+\n+    #[test]\n+    fn from_mut_no_copy() {\n+        unsafe {\n+            let x = [mut 1, 2, 3];\n+            let addr = unsafe::to_ptr(x);\n+            let x_imm = from_mut(x);\n+            let addr_imm = unsafe::to_ptr(x_imm);\n+            assert addr == addr_imm;\n+        }\n     }\n \n     #[test]\n-    fn from_mut_no_copy() unsafe {\n-        let x = [mut 1, 2, 3];\n-        let addr = unsafe::to_ptr(x);\n-        let x_imm = from_mut(x);\n-        let addr_imm = unsafe::to_ptr(x_imm);\n-        assert addr == addr_imm;\n+    fn test_unshift() {\n+        let mut x = [1, 2, 3];\n+        unshift(x, 0);\n+        assert x == [0, 1, 2, 3];\n     }\n \n     #[test]"}, {"sha": "c828566841e79ccf526a09984f897c1b46bac3d9", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -822,7 +822,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n     log(debug, \"starting tcp::read\");\n     let iotask = (*socket_data).iotask;\n     let rs_result = read_start_common_impl(socket_data);\n-    if result::is_failure(rs_result) {\n+    if result::is_err(rs_result) {\n         let err_data = result::get_err(rs_result);\n         result::err(err_data)\n     }\n@@ -1433,7 +1433,7 @@ mod test {\n \n                         let accept_result = accept(new_conn);\n                         log(debug, \"SERVER: after accept()\");\n-                        if result::is_failure(accept_result) {\n+                        if result::is_err(accept_result) {\n                             log(debug, \"SERVER: error accept connection\");\n                             let err_data = result::get_err(accept_result);\n                             comm::send(kill_ch, some(err_data));\n@@ -1474,7 +1474,7 @@ mod test {\n                 log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n             });\n             // err check on listen_result\n-            if result::is_failure(listen_result) {\n+            if result::is_err(listen_result) {\n                 let err_data = result::get_err(listen_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n                                 err_data.err_name, err_data.err_msg));\n@@ -1495,7 +1495,7 @@ mod test {\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let new_listener_result =\n                 new_listener(server_ip_addr, server_port, 128u, iotask);\n-            if result::is_failure(new_listener_result) {\n+            if result::is_err(new_listener_result) {\n                 let err_data = result::get_err(new_listener_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n                                 err_data.err_name, err_data.err_msg));\n@@ -1507,7 +1507,7 @@ mod test {\n             // in a loop {}, but we're just going to take a single\n             // client.. get their req, write a resp and then exit\n             let new_conn_result = server_port.recv();\n-            if result::is_failure(new_conn_result) {\n+            if result::is_err(new_conn_result) {\n                 let err_data = result::get_err(new_conn_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n                                 err_data.err_name, err_data.err_msg));\n@@ -1544,7 +1544,7 @@ mod test {\n \n         log(debug, \"CLIENT: starting..\");\n         let connect_result = connect(server_ip_addr, server_port, iotask);\n-        if result::is_failure(connect_result) {\n+        if result::is_err(connect_result) {\n             log(debug, \"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);\n             log(debug, #fmt(\"CLIENT: connect err name: %s msg: %s\",\n@@ -1556,7 +1556,7 @@ mod test {\n             let resp_bytes = str::bytes(resp);\n             tcp_write_single(sock, resp_bytes);\n             let read_result = sock.read(0u);\n-            if read_result.is_failure() {\n+            if read_result.is_err() {\n                 log(debug, \"CLIENT: failure to read\");\n                 \"\"\n             }\n@@ -1573,7 +1573,7 @@ mod test {\n     fn tcp_write_single(sock: tcp_socket, val: [u8]) {\n         let write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n-        if result::is_failure(write_result) {\n+        if result::is_err(write_result) {\n             log(debug, \"tcp_write_single: write failed!\");\n             let err_data = result::get_err(write_result);\n             log(debug, #fmt(\"tcp_write_single err name: %s msg: %s\","}, {"sha": "17297d94bd9410c8e8ffe98d35ff265af9d64061", "filename": "src/libstd/par.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -42,7 +42,7 @@ fn map_slices<A: copy send, B: copy send>(\n             // FIXME: why is the ::<A, ()> annotation required here? (#2617)\n             vec::unpack_slice::<A, ()>(xs) {|p, _len|\n                 let f = f();\n-                futures += [future::spawn() {|copy base|\n+                let f = future::spawn() {|copy base|\n                     unsafe {\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base),\n@@ -55,7 +55,8 @@ fn map_slices<A: copy send, B: copy send>(\n                         assert(vec::len(slice) == end - base);\n                         f(base, slice)\n                     }\n-                }];\n+                };\n+                vec::push(futures, f);\n             };\n             base += items_per_task;\n         }"}, {"sha": "fe9f59d553842cdc92b6edd991dea30cc216b0cf", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -452,10 +452,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n         []\n       }\n \n-      ast::ty_vstore(_, _) {\n-        cx.span_unimpl(ty.span, \"serialization for vstore types\");\n-      }\n-\n+      ast::ty_vstore(@{node: ast::ty_vec(mt),_}, ast::vstore_uniq) |\n       ast::ty_vec(mt) {\n         let ser_e =\n             cx.expr(\n@@ -472,6 +469,11 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n             std::serialization::emit_from_vec($(s), $(v), {|__e| $(ser_e) })\n         }]\n       }\n+\n+      ast::ty_vstore(_, _) {\n+        cx.span_unimpl(ty.span, \"serialization for vstore types\");\n+      }\n+\n     }\n }\n \n@@ -673,14 +675,15 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         #ast{ fail }\n       }\n \n-      ast::ty_vstore(_, _) {\n-        cx.span_unimpl(ty.span, \"deserialization for vstore types\");\n-      }\n-\n+      ast::ty_vstore(@{node: ast::ty_vec(mt),_}, ast::vstore_uniq) |\n       ast::ty_vec(mt) {\n         let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n         #ast{ std::serialization::read_to_vec($(d), $(l)) }\n       }\n+\n+      ast::ty_vstore(_, _) {\n+        cx.span_unimpl(ty.span, \"deserialization for vstore types\");\n+      }\n     }\n }\n "}, {"sha": "a1043c4ed2f4cda2f4fe0ff3e698f736ed7e4e73", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -771,9 +771,9 @@ class parser {\n         } else if self.eat_keyword(\"if\") {\n             ret pexpr(self.parse_if_expr());\n         } else if self.eat_keyword(\"for\") {\n-            ret pexpr(self.parse_for_expr());\n+            ret pexpr(self.parse_sugary_call_expr(\"for\", expr_loop_body));\n         } else if self.eat_keyword(\"do\") {\n-            ret pexpr(self.parse_do_expr());\n+            ret pexpr(self.parse_sugary_call_expr(\"do\", expr_do_body));\n         } else if self.eat_keyword(\"while\") {\n             ret pexpr(self.parse_while_expr());\n         } else if self.eat_keyword(\"loop\") {\n@@ -1283,36 +1283,21 @@ class parser {\n         }\n     }\n \n-    fn parse_for_expr() -> @expr {\n+    fn parse_sugary_call_expr(keyword: str,\n+                              ctor: fn(+@expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n         let call = self.parse_expr_res(RESTRICT_STMT_EXPR);\n         alt call.node {\n           expr_call(f, args, true) {\n             let b_arg = vec::last(args);\n             let last = self.mk_expr(b_arg.span.lo, b_arg.span.hi,\n-                                    expr_loop_body(b_arg));\n+                                    ctor(b_arg));\n             @{node: expr_call(f, vec::init(args) + [last], true)\n               with *call}\n           }\n           _ {\n-            self.span_fatal(lo, \"`for` must be followed by a block call\");\n-          }\n-        }\n-    }\n-\n-    fn parse_do_expr() -> @expr {\n-        let lo = self.last_span;\n-        let call = self.parse_expr_res(RESTRICT_STMT_EXPR);\n-        alt call.node {\n-          expr_call(f, args, true) {\n-            let b_arg = vec::last(args);\n-            let last = self.mk_expr(b_arg.span.lo, b_arg.span.hi,\n-                                    expr_do_body(b_arg));\n-            @{node: expr_call(f, vec::init(args) + [last], true)\n-              with *call}\n-          }\n-          _ {\n-            self.span_fatal(lo, \"`do` must be followed by a block call\");\n+            self.span_fatal(\n+                lo, #fmt(\"`%s` must be followed by a block call\", keyword));\n           }\n         }\n     }\n@@ -1956,7 +1941,7 @@ class parser {\n         let rp = self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n         let class_path = self.ident_to_path_tys(class_name, rp, ty_params);\n-        let ifaces : [@iface_ref] = if self.eat_keyword(\"implements\")\n+        let ifaces : [@iface_ref] = if self.eat(token::COLON)\n             { self.parse_iface_ref_list() }\n         else { [] };\n         self.expect(token::LBRACE);"}, {"sha": "9240e3d7a9f6f3b0e5d9632841e3a643f216fd78", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -251,7 +251,6 @@ fn contextual_keyword_table() -> hashmap<str, ()> {\n     let keys = [\n         \"as\",\n         \"else\",\n-        \"implements\",\n         \"move\",\n         \"of\",\n         \"priv\", \"pub\","}, {"sha": "b38f4c35d86a0609e9c1d9b5ed8b5b692e1c6609", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -495,9 +495,11 @@ fn print_item(s: ps, &&item: @ast::item) {\n           word_nbsp(s, *item.ident);\n           print_region_param(s, rp);\n           print_type_params(s, tps);\n-          word_space(s, \"implements\");\n-          commasep(s, inconsistent, ifaces, {|s, p|\n-                      print_path(s, p.path, false)});\n+          if vec::len(ifaces) != 0u {\n+              word_space(s, \":\");\n+              commasep(s, inconsistent, ifaces, {|s, p|\n+                  print_path(s, p.path, false)});\n+          }\n           bopen(s);\n           hardbreak_if_not_bol(s);\n           maybe_print_comment(s, ctor.span.lo);"}, {"sha": "ad729494c457e6483f1d947f4bc211eb330d070a", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -891,9 +891,7 @@ rust_unlock_cond_lock(rust_cond_lock *lock) {\n extern \"C\" void\n rust_wait_cond_lock(rust_cond_lock *lock) {\n     rust_task *task = rust_get_current_task();\n-#ifdef DEBUG_LOCKS\n-    assert(lock->lock.lock_held_by_current_thread());\n-#endif\n+    lock->lock.must_have_lock();\n     assert(NULL == lock->waiting);\n     lock->waiting = task;\n     task->block(lock, \"waiting for signal\");\n@@ -905,9 +903,7 @@ rust_wait_cond_lock(rust_cond_lock *lock) {\n \n extern \"C\" bool\n rust_signal_cond_lock(rust_cond_lock *lock) {\n-#ifdef DEBUG_LOCKS\n-    assert(lock->lock.lock_held_by_current_thread());\n-#endif\n+    lock->lock.must_have_lock();\n     if(NULL == lock->waiting) {\n         return false;\n     }"}, {"sha": "9fcc3d286fc6bd23387c71a7812d31e58716b2f9", "filename": "src/rustc/middle/block_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fblock_use.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -34,7 +34,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n             i += 1u;\n         }\n       }\n-      expr_loop_body(body) {\n+      expr_loop_body(body) | expr_do_body(body) {\n         cx.allow_block = true;\n         v.visit_expr(body, cx, v);\n       }"}, {"sha": "43eb9f8c58d4ade20260e8633ba4bd250c297ab8", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1752,7 +1752,6 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n             arg_exprs([src]), save_in(target));\n \n         ret move_val(bcx, DROP_EXISTING, lhs_res.val,\n-                     // FIXME (#2704): should kind be owned?\n                      {bcx: bcx, val: target, kind: owned},\n                      dty);\n       }"}, {"sha": "c5aa42186bc345ddb0e6dfec81cc7a30e4881c55", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -677,7 +677,7 @@ fn mk_nil_ptr(cx: ctxt) -> t {\n     mk_ptr(cx, {ty: mk_nil(cx), mutbl: ast::m_imm})\n }\n \n-fn mk_vec(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_vec(tm)) }\n+fn mk_vec(cx: ctxt, tm: mt) -> t { mk_evec(cx, tm, vstore_uniq) }\n \n fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n     mk_t(cx, ty_evec(tm, t))\n@@ -1472,7 +1472,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) { kind_implicitly_sendable() | kind_const() }\n       // Implicit copyability of strs is configurable\n-      ty_str {\n+      ty_str | ty_estr(vstore_uniq) {\n         if cx.vecs_implicitly_copyable {\n             kind_implicitly_sendable() | kind_const()\n         } else { kind_sendable() | kind_const() }\n@@ -1502,7 +1502,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         remove_implicit(mutable_type_kind(cx, tm))\n       }\n       // Implicit copyability of vecs is configurable\n-      ty_vec(tm) {\n+      ty_vec(tm) | ty_evec(tm, vstore_uniq) {\n           if cx.vecs_implicitly_copyable {\n               mutable_type_kind(cx, tm)\n           } else { remove_implicit(mutable_type_kind(cx, tm)) }\n@@ -1520,17 +1520,13 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n             kind_implicitly_copyable()\n         }\n       }\n-      ty_evec(tm, vstore_uniq) {\n-        remove_implicit(mutable_type_kind(cx, tm))\n-      }\n       ty_evec(tm, vstore_fixed(_)) {\n         mutable_type_kind(cx, tm)\n       }\n \n       // All estrs are copyable; uniques and interiors are sendable.\n       ty_estr(vstore_box) |\n       ty_estr(vstore_slice(_)) { kind_implicitly_copyable() | kind_const() }\n-      ty_estr(vstore_uniq) { kind_sendable() | kind_const() }\n       ty_estr(vstore_fixed(_)) { kind_implicitly_sendable() | kind_const() }\n \n       // Records lower to the lowest of their members."}, {"sha": "ad1a613e7392e5ec539a500a43e976228dc3b95f", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -218,7 +218,7 @@ fn require_same_types(\n \n fn arg_is_argv_ty(_tcx: ty::ctxt, a: ty::arg) -> bool {\n     alt ty::get(a.ty).struct {\n-      ty::ty_vec(mt) {\n+      ty::ty_evec(mt, vstore_uniq) {\n         if mt.mutbl != ast::m_imm { ret false; }\n         alt ty::get(mt.ty).struct {\n           ty::ty_str { ret true; }\n@@ -271,12 +271,12 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     }\n }\n \n-fn check_for_main_fn(ccx: @crate_ctxt, crate: @ast::crate) {\n+fn check_for_main_fn(ccx: @crate_ctxt) {\n     let tcx = ccx.tcx;\n     if !tcx.sess.building_library {\n         alt copy tcx.sess.main_fn {\n           some((id, sp)) { check_main_fn_ty(ccx, id, sp); }\n-          none { tcx.sess.span_err(crate.span, \"main function not found\"); }\n+          none { tcx.sess.err(\"main function not found\"); }\n         }\n     }\n }\n@@ -289,7 +289,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                 tcx: tcx};\n     collect::collect_item_types(ccx, crate);\n     check::check_item_types(ccx, crate);\n-    check_for_main_fn(ccx, crate);\n+    check_for_main_fn(ccx);\n     tcx.sess.abort_if_errors();\n     (ccx.method_map, ccx.vtable_map)\n }"}, {"sha": "c40b86d05309ea7b677fb3256d6284723a423d28", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -170,6 +170,12 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n             ret ty::mk_evec(tcx, mt, vst);\n           }\n \n+          // HACK: if we get a []/~, we assume that it was actually a\n+          // [] that got written down, and we throw away the /~...\n+          ty::ty_evec(mt, vstore_uniq) {\n+            ret ty::mk_evec(tcx, mt, vst);\n+          }\n+\n           ty::ty_str {\n             ret ty::mk_estr(tcx, vst);\n           }"}, {"sha": "5ba7c88d3cd522c329ed21cdec72a05dd51dbfa0", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -381,7 +381,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           // Check that there's at least one field\n           let (fields,_) = split_class_items(members);\n           if fields.len() < 1u {\n-              ccx.tcx.sess.span_err(it.span, \"A class must have at least one \\\n+              ccx.tcx.sess.span_err(it.span, \"a class must have at least one \\\n                 field\");\n           }\n           // Check that the class is instantiable\n@@ -938,7 +938,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 // separate case below.\n                 tcx.sess.span_bug(\n                     expr.span,\n-                    #fmt[\"Comparison operator in expr_binop: %s\",\n+                    #fmt[\"comparison operator in expr_binop: %s\",\n                          ast_util::binop_to_str(op)]);\n               }\n               _ { lhs_t }\n@@ -1217,7 +1217,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               result::ok(_) { /* fall through */ }\n               result::err(_) {\n                 tcx.sess.span_err(expr.span,\n-                                  \"ret; in function returning non-nil\"); }\n+                                  \"`ret;` in function returning non-nil\"); }\n             }\n           }\n           some(e) { check_expr_with(fcx, e, ret_ty); }\n@@ -1299,16 +1299,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               result::ok(_) {}\n               result::err(err) {\n                 tcx.sess.span_fatal(\n-                    expr.span, #fmt(\"a loop function's last argument \\\n+                    expr.span, #fmt(\"a `loop` function's last argument \\\n                                      should return `bool`, not `%s`\",\n                                     fcx.infcx.ty_to_str(fty.output)));\n               }\n             }\n             (ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty}), fty.proto)\n           }\n           _ {\n-            tcx.sess.span_fatal(expr.span, \"a loop function's last argument \\\n-                                            should be of function type\");\n+            tcx.sess.span_fatal(expr.span, \"a `loop` function's last \\\n+                                            argument should be of function \\\n+                                            type\");\n           }\n         };\n         alt check b.node {\n@@ -1334,7 +1335,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             (ty::mk_fn(tcx, fty), fty.proto)\n           }\n           _ {\n-            tcx.sess.span_fatal(expr.span, \"a do function's last argument \\\n+            tcx.sess.span_fatal(expr.span, \"a `do` function's last argument \\\n                                             should be of function type\");\n           }\n         };\n@@ -1547,8 +1548,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n               none {\n                 let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n-                let msg = #fmt[\"attempted access of field %s on type %s, but \\\n-                          no public field or method with that name was found\",\n+                let msg = #fmt[\"attempted access of field `%s` on type `%s`, \\\n+                                but no public field or method with that name \\\n+                                was found\",\n                                *field, fcx.infcx.ty_to_str(t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n@@ -1781,8 +1783,8 @@ fn check_instantiable(tcx: ty::ctxt,\n     let rty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, rty) {\n         tcx.sess.span_err(sp, #fmt[\"this type cannot be instantiated \\\n-                                    without an instance of itself. \\\n-                                    Consider using option<%s>.\",\n+                                    without an instance of itself; \\\n+                                    consider using `option<%s>`\",\n                                    ty_to_str(tcx, rty)]);\n     }\n }\n@@ -1821,7 +1823,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n         }\n         if vec::contains(disr_vals, disr_val) {\n             ccx.tcx.sess.span_err(v.span,\n-                                  \"discriminator value already exists.\");\n+                                  \"discriminator value already exists\");\n         }\n         disr_vals += [disr_val];\n         let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n@@ -1848,7 +1850,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n           _ { false }\n         }\n     }) {\n-        ccx.tcx.sess.span_err(sp, \"illegal recursive enum type. \\\n+        ccx.tcx.sess.span_err(sp, \"illegal recursive enum type; \\\n                                    wrap the inner value in a box to \\\n                                    make it representable\");\n     }\n@@ -2195,13 +2197,13 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     if !r_used {\n         ccx.tcx.sess.span_err(\n             span, \"lifetime `self` unused inside \\\n-                   reference-parameterized type.\");\n+                   reference-parameterized type\");\n     }\n \n     for tps_used.eachi { |i, b|\n         if !b {\n             ccx.tcx.sess.span_err(\n-                span, #fmt[\"Type parameter %s is unused.\", *tps[i].ident]);\n+                span, #fmt[\"type parameter `%s` is unused\", *tps[i].ident]);\n         }\n     }\n }\n@@ -2268,13 +2270,13 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n     let i_n_tps = (*i_ty.bounds).len();\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span, #fmt(\"intrinsic has wrong number \\\n-                                         of type parameters. found %u, \\\n+                                         of type parameters: found %u, \\\n                                          expected %u\", i_n_tps, n_tps));\n     } else {\n         require_same_types(\n             tcx, none, it.span, i_ty.ty, fty,\n-            {|| #fmt[\"intrinsic has wrong type. \\\n-                      expected %s\",\n+            {|| #fmt[\"intrinsic has wrong type: \\\n+                      expected `%s`\",\n                      ty_to_str(ccx.tcx, fty)]});\n     }\n }"}, {"sha": "63b8426ac93c19e81fd0be7f30b7f307d746df8b", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -3,7 +3,7 @@ import to_str::to_str;\n \n mod kitty {\n \n-class cat implements to_str {\n+class cat : to_str {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "56733b29178124077763c2f5251d6a65f4155ce9", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -305,7 +305,7 @@ fn validate(edges: [(node_id, node_id)],\n                     status = false;\n                 }\n \n-                path += [parent];\n+                vec::push(path, parent);\n                 parent = tree[parent];\n             }\n "}, {"sha": "b6a6ba60a9f1ece087dfb29d9e73fef81aa82340", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -40,7 +40,7 @@ fn run(args: [str]) {\n     let mut worker_results = [];\n     for uint::range(0u, workers) {|_i|\n         let builder = task::builder();\n-        worker_results += [task::future_result(builder)];\n+        vec::push(worker_results, task::future_result(builder));\n         task::run(builder) {||\n             for uint::range(0u, size / workers) {|_i|\n                 comm::send(to_child, bytes(100u));"}, {"sha": "c4e519026289b8bf253ffbe32c0e1aa661b4da4a", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -77,7 +77,6 @@ mod map_reduce {\n \n     type putter<K: send, V: send> = fn(K, V);\n \n-    // FIXME: the first K1 parameter should probably be a - (#2599)\n     type mapper<K1: send, K2: send, V: send> = fn~(K1, putter<K2, V>);\n \n     type getter<V: send> = fn() -> option<V>;"}, {"sha": "e79c021d9f3ef79f39ac163871eda6390f652ec6", "filename": "src/test/compile-fail/class-cast-to-iface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,9 +1,9 @@\n-// error-pattern: attempted access of field eat on type noisy\n+// error-pattern: attempted access of field `eat` on type `noisy`\n iface noisy {\n   fn speak();\n }\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "4e95b986a9ab8421cd8499bbf6c67832d2998233", "filename": "src/test/compile-fail/class-implements-bad-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,5 +1,5 @@\n // error-pattern:unresolved typename: nonexistent\n-class cat implements nonexistent {\n+class cat : nonexistent {\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }"}, {"sha": "1768b8c4bf04729c46a20bc3adbb7a595b09b5d4", "filename": "src/test/compile-fail/class-implements-int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,4 +1,4 @@\n-class cat implements int { //! ERROR can only implement interface types\n+class cat : int { //! ERROR can only implement interface types\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }"}, {"sha": "788baa73c345cc78e6ef3606d547b94493304776", "filename": "src/test/compile-fail/class-method-missing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -3,7 +3,7 @@ iface animal {\n   fn eat();\n }\n \n-class cat implements animal {\n+class cat : animal {\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }"}, {"sha": "e0d3680a381b5eff0b3f0122e7f26ad56749b3d7", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern:expected `str` but found `[int]`\n+// error-pattern:expected `str` but found `[int]/~`\n fn main() { fail [0i]; }"}, {"sha": "17510164a5f9e92e85bab28f65c0e0e9efb82264", "filename": "src/test/compile-fail/issue-1763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,6 +1,6 @@\n // Issue #1763 - infer types correctly\n \n-type actor<T> = { //! ERROR Type parameter T is unused.\n+type actor<T> = { //! ERROR type parameter `T` is unused\n     unused: bool\n };\n "}, {"sha": "69970f8dc950e24c0148cac26be8961243c42261", "filename": "src/test/compile-fail/issue-2509-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,4 +1,4 @@\n-class c { //! ERROR A class must have at least one field\n+class c { //! ERROR a class must have at least one field\n     new() { }\n }\n "}, {"sha": "f54a0ffc068d52bfc922f71f99ff93f214ec77fa", "filename": "src/test/compile-fail/private-method-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fprivate-method-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fprivate-method-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method-cross-crate.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:attempted access of field nap on type\n+// error-pattern:attempted access of field `nap` on type\n // xfail-fast\n // aux-build:cci_class_5.rs\n use cci_class_5;"}, {"sha": "4153f413dc034bddcb5baf4ae0d02ecbf742ab3d", "filename": "src/test/compile-fail/ret-non-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: ret; in function returning non-nil\n+// error-pattern: `ret;` in function returning non-nil\n \n fn f() { ret; }\n "}, {"sha": "cc6faa07557b521e169b80f070a6fa2cd4f6cbb6", "filename": "src/test/compile-fail/unsafe-fn-autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -15,7 +15,7 @@ fn f(p: *rec) -> int {\n     // are prohibited by various checks, such as that the enum is\n     // instantiable and so forth).\n \n-    ret p.f; //! ERROR attempted access of field f on type *rec\n+    ret p.f; //! ERROR attempted access of field `f` on type `*rec`\n }\n \n fn main() {"}, {"sha": "6642112d9986cc49df6d4284bad07b3b990a046e", "filename": "src/test/compile-fail/vec-add.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-add.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,8 +1,8 @@\n // xfail-test\n \n-// FIXME: + should allow immutable or mutable vectors on the right\n-// hand side in all cases. We are getting compiler errors about this\n-// now, so I'm xfailing the test for now. -eholk\n+// FIXME (Issue #2711): + should allow immutable or mutable vectors on\n+// the right hand side in all cases. We are getting compiler errors\n+// about this now, so I'm xfailing the test for now. -eholk\n \n fn add(i: [int], m: [mut int], c: [const int]) {\n "}, {"sha": "7eb7e118b39f0465ccc181d1bbdbeab9ec6c2195", "filename": "src/test/compile-fail/vec-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-field.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:attempted access of field some_field_name on type [int]\n+// error-pattern:attempted access of field `some_field_name` on type `[int]/~`\n // issue #367\n \n fn f() {"}, {"sha": "13c0e60c427f488dbc9c8da79b91785bd679dc5e", "filename": "src/test/run-pass/class-cast-to-iface-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,7 +1,7 @@\n import to_str::*;\n import to_str::to_str;\n \n-class cat implements to_str {\n+class cat : to_str {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "e2dc7b732a8ef027751bfca7f34b94cd9831734b", "filename": "src/test/run-pass/class-cast-to-iface-multiple-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -2,7 +2,7 @@ iface noisy {\n   fn speak() -> int;\n }\n \n-class dog implements noisy {\n+class dog : noisy {\n   priv {\n     let barks : @mut uint;\n     fn bark() -> int {\n@@ -26,7 +26,7 @@ class dog implements noisy {\n   fn speak() -> int { self.bark() }\n }\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let meows : @mut uint;\n     fn meow() -> uint {"}, {"sha": "10222acc45aa71c87cf625de59041e6f8fb7d67b", "filename": "src/test/run-pass/class-cast-to-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -2,7 +2,7 @@ iface noisy {\n   fn speak();\n }\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "4da75037421c0502ea2ee68e0ce6de0cf533a431", "filename": "src/test/run-pass/class-iface-bounded-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -2,7 +2,7 @@ use std;\n import std::map::{map, hashmap, int_hash};\n \n class keys<K: copy, V: copy, M: copy map<K,V>>\n-    implements iter::base_iter<K> {\n+    : iter::base_iter<K> {\n \n     let map: M;\n "}, {"sha": "dc76b57c2d26484e835b222059d40e321e38a67a", "filename": "src/test/run-pass/class-impl-parameterized-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::map::*;\n \n-class cat implements map<int, bool> {\n+class cat : map<int, bool> {\n   priv {\n     // Yes, you can have negative meows\n     let mut meows : int;"}, {"sha": "30c4be25c604351d2f8cb5ff0fe7c4f796940ae0", "filename": "src/test/run-pass/class-impl-very-parameterized-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -7,7 +7,7 @@ enum cat_type { tuxedo, tabby, tortoiseshell }\n // for any int value that's less than the meows field\n \n // ok: T should be in scope when resolving the iface ref for map\n-class cat<T: copy> implements map<int, T> {\n+class cat<T: copy> : map<int, T> {\n   priv {\n     // Yes, you can have negative meows\n     let mut meows : int;"}, {"sha": "5add42fb263c89614d7229544bce0447845a423d", "filename": "src/test/run-pass/class-implement-iface-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -3,7 +3,7 @@\n use cci_class_iface;\n import cci_class_iface::animals::*;\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "f772ef957d7eee842a4eced98beda64c08cf68b1", "filename": "src/test/run-pass/class-implement-ifaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -2,7 +2,7 @@ iface noisy {\n   fn speak();\n }\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "fe3f160c1f8184f52ede87251ef9b36fa9ea66d4", "filename": "src/test/run-pass/class-implements-multiple-ifaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -24,7 +24,7 @@ fn vec_includes<T>(xs: [T], x: T) -> bool {\n }\n \n // vtables other than the 1st one don't seem to work\n-class cat implements noisy, scratchy, bitey {\n+class cat : noisy, scratchy, bitey {\n   priv {\n     let meows : @mut uint;\n     let scratched : dvec<furniture>;"}, {"sha": "3f5e92cdb75a20691f02f68852f4f67744e1422f", "filename": "src/test/run-pass/cleanup-copy-mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -2,7 +2,7 @@\n fn adder(+x: @int, +y: @int) -> int { ret *x + *y; }\n fn failer() -> @int { fail; }\n fn main() {\n-    assert(result::is_failure(task::try {||\n+    assert(result::is_err(task::try {||\n         adder(@2, failer()); ()\n     }));\n }"}, {"sha": "c7fec67542db9289271c0e4a4afaed9707871b59", "filename": "src/test/run-pass/do-stack.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fdo-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fdo-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-stack.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -0,0 +1,5 @@\n+fn f(f: fn&(int)) { f(10) }\n+\n+fn main() {\n+    do f() { |i| assert i == 10 }\n+}"}, {"sha": "458a0b12698b80597c24548e27a81e032eb1400d", "filename": "src/test/run-pass/issue-506.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fissue-506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Fissue-506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-506.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -1,9 +1,3 @@\n-// xfail-test\n-// FIXME: This test is no longer testing what it was intended to. It should\n-// be testing spawning of a native function, but is actually testing\n-// spawning some other function, then executing a native function.\n-// #2602\n-\n /*\n   A reduced test case for Issue #506, provided by Rob Arnold.\n */\n@@ -13,9 +7,7 @@ import task;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn task_yield();\n+    fn rust_task_allow_kill();\n }\n \n-fn yield_wrap(&&_arg: ()) { rustrt::task_yield(); }\n-\n-fn main() { task::spawn((), yield_wrap); }\n+fn main() { task::spawn(rustrt::rust_task_allow_kill); }"}, {"sha": "d250b311cccd83858c5c3a78afffaca092a7b01b", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da470ff5b8b970c90b4dce3885a2908d477c1021/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=da470ff5b8b970c90b4dce3885a2908d477c1021", "patch": "@@ -52,8 +52,6 @@ fn test_tag() {\n     send(ch, tag1);\n     send(ch, tag2(10));\n     send(ch, tag3(10, 11u8, 'A'));\n-    // FIXME: Do port semantics really guarantee these happen in order?\n-    // (#2605)\n     let mut t1: t;\n     t1 = recv(po);\n     assert (t1 == tag1);"}]}