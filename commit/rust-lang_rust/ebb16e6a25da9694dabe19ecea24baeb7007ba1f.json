{"sha": "ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYjE2ZTZhMjVkYTk2OTRkYWJlMTllY2VhMjRiYWViNzAwN2JhMWY=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-15T20:33:12Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-15T22:35:28Z"}, "message": "Use span stacks to track macro expansion for less troublesome error messages.", "tree": {"sha": "180e6854766f09a97f0ef887eada5bad88403327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/180e6854766f09a97f0ef887eada5bad88403327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "html_url": "https://github.com/rust-lang/rust/commit/ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "html_url": "https://github.com/rust-lang/rust/commit/c48036c0b7d10606dc8c63b87351fb394cf7d4a6"}], "stats": {"total": 100, "additions": 63, "deletions": 37}, "files": [{"sha": "435efb3e167863f6774027568bfafde922c11bce", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "patch": "@@ -153,7 +153,7 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n fn parse_constr[@T](st: @pstate, sd: str_def, pser: arg_parser[T]) ->\n    @ty::constr_general[T] {\n     let sp = ast::dummy_sp(); // FIXME: use a real span\n-    let args: [@sp_constr_arg[T]][] = ~[];\n+    let args: [@sp_constr_arg[T]] = ~[];\n     let pth: path = parse_path(st, sd);\n     let ignore: char = next(st) as char;\n     assert (ignore as char == '(');"}, {"sha": "9e37364ab65bd35ea94b0f47c84d3518272582bb", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "patch": "@@ -127,7 +127,7 @@ fn node_span(node: &ast_node) -> codemap::span {\n mod test {\n     #[test]\n     fn test_node_span_item() {\n-        let expected: codemap::span = {lo: 20u, hi: 30u};\n+        let expected: codemap::span = mk_sp(20u, 30u);\n         let node = node_item(@{ident: \"test\",\n                                attrs: ~[],\n                                id: 0,\n@@ -139,7 +139,7 @@ mod test {\n \n     #[test]\n     fn test_node_span_obj_ctor() {\n-        let expected: codemap::span = {lo: 20u, hi: 30u};\n+        let expected: codemap::span = mk_sp(20u, 30u);\n         let node = node_obj_ctor(@{ident: \"test\",\n                                    attrs: ~[],\n                                    id: 0,\n@@ -151,7 +151,7 @@ mod test {\n \n     #[test]\n     fn test_node_span_native_item() {\n-        let expected: codemap::span = {lo: 20u, hi: 30u};\n+        let expected: codemap::span = mk_sp(20u, 30u);\n         let node = node_native_item(@{ident: \"test\",\n                                       attrs: ~[],\n                                       node: native_item_ty,\n@@ -162,7 +162,7 @@ mod test {\n \n     #[test]\n     fn test_node_span_expr() {\n-        let expected: codemap::span = {lo: 20u, hi: 30u};\n+        let expected: codemap::span = mk_sp(20u, 30u);\n         let node = node_expr(@{id: 0,\n                                node: expr_break,\n                                span: expected});"}, {"sha": "739633c795fb4e071ff573900e7e48ebdfed08ee", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "patch": "@@ -49,7 +49,7 @@ fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n     }\n     fn field_patterns_supersede(tcx: &ty::ctxt, fas: &[field_pat],\n                                 fbs: &[field_pat]) -> bool {\n-        let wild = @{id: 0, node: pat_wild, span: dummy_sp();\n+        let wild = @{id: 0, node: pat_wild, span: dummy_sp()};\n         for fa: field_pat  in fas {\n             let pb = wild;\n             for fb: field_pat  in fbs {"}, {"sha": "366a9adf53b7e4816ee394f53e39e721f1b793ab", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "patch": "@@ -126,7 +126,7 @@ fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n \n fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n    match {\n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp();\n+    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(dummy: &@ast::pat, fields: &[ast::ident], p: &@ast::pat) ->\n        option::t[[@ast::pat]] {\n         alt p.node {\n@@ -148,7 +148,7 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n }\n \n fn enter_tup(m: &match, col: uint, val: ValueRef, n_elts: uint) -> match {\n-    let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n+    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(dummy: &@ast::pat, n_elts: uint, p: &@ast::pat)\n         -> option::t[[@ast::pat]] {\n         alt p.node {"}, {"sha": "9ad3d8d1b2e81ab6a4d758e0bf7d25953f5fc48d", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "patch": "@@ -35,19 +35,29 @@ fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n }\n \n obj ext_ctxt(sess: @session, crate_file_name_hack: str,\n-             mutable backtrace: span[]) {\n+             mutable backtrace: codemap::opt_span) {\n     fn crate_file_name() -> str { ret crate_file_name_hack; }\n \n     fn session() -> @session { ret sess; }\n \n     fn print_backtrace() {\n-        for sp: span in backtrace {\n-            sess.span_note(sp, \"(while expanding this)\")\n-        }\n     }\n \n-    fn bt_push(sp: span) { backtrace += ~[sp]; }\n-    fn bt_pop() { ivec::pop(backtrace); }\n+    fn backtrace() -> codemap::opt_span { ret backtrace; }\n+\n+    fn bt_push(sp: span) {\n+        backtrace = codemap::os_some(@{lo: sp.lo, hi: sp.hi,\n+                                       expanded_from: backtrace});\n+    }\n+    fn bt_pop() {\n+        alt backtrace {\n+          codemap::os_some(@{expanded_from: pre, _}) {\n+            let tmp = pre;\n+            backtrace = tmp;\n+          }\n+          _ { self.bug(\"tried to pop without a push\"); }\n+        }\n+    }\n \n     fn span_fatal(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n@@ -85,7 +95,7 @@ fn mk_ctxt(sess: &session) -> ext_ctxt {\n     // super-ugly and needs a better solution.\n     let crate_file_name_hack = sess.get_codemap().files.(0).name;\n \n-    ret ext_ctxt(@sess, crate_file_name_hack, ~[]);\n+    ret ext_ctxt(@sess, crate_file_name_hack, codemap::os_none);\n }\n \n fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: str) -> str {"}, {"sha": "b57812cb1d232f288a376644c1f2dd3e23fb5c11", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "patch": "@@ -205,6 +205,10 @@ fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t[bindings] {\n fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n     let idx_path: @mutable [uint] = @mutable ~[];\n     fn new_id(old: node_id, cx: &ext_ctxt) -> node_id { ret cx.next_id(); }\n+    fn new_span(cx: &ext_ctxt, sp: &span) -> span {\n+        /* this discards information in the case of macro-defining macros */\n+        ret {lo: sp.lo, hi: sp.hi, expanded_from: cx.backtrace()};\n+    }\n     let afp = default_ast_fold();\n     let f_pre =\n         {fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n@@ -215,7 +219,8 @@ fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n          fold_block:\n              bind transcribe_block(cx, b, idx_path, _, _, afp.fold_block),\n          map_exprs: bind transcribe_exprs(cx, b, idx_path, _, _),\n-         new_id: bind new_id(_, cx) with *afp};\n+         new_id: bind new_id(_, cx),\n+         new_span: bind new_span(cx, _) with *afp};\n     let f = make_fold(f_pre);\n     let result = f.fold_expr(body);\n     dummy_out(f); //temporary: kill circular reference"}, {"sha": "7e5bbf41493bb3602e3353d628a5198372c45509", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "patch": "@@ -44,7 +44,8 @@ type ast_fold_precursor =\n      fold_path: fn(&path_, ast_fold) -> path_ ,\n      fold_local: fn(&local_, ast_fold) -> local_ ,\n      map_exprs: fn(fn(&@expr) -> @expr , [@expr]) -> [@expr],\n-     new_id: fn(node_id) -> node_id};\n+     new_id: fn(node_id) -> node_id,\n+     new_span: fn(&span) -> span};\n \n type a_f =\n     {fold_crate: fn(&crate) -> crate ,\n@@ -70,7 +71,8 @@ type a_f =\n      fold_path: fn(&path) -> path ,\n      fold_local: fn(&@local) -> @local ,\n      map_exprs: fn(fn(&@expr) -> @expr , [@expr]) -> [@expr],\n-     new_id: fn(node_id) -> node_id};\n+     new_id: fn(node_id) -> node_id,\n+     new_span: fn(&span) -> span};\n \n \n //fn nf_dummy[T](&T node) -> T { fail; }\n@@ -514,6 +516,8 @@ fn noop_map_exprs(f: fn(&@expr) -> @expr , es: [@expr]) -> [@expr] {\n \n fn noop_id(i: node_id) -> node_id { ret i; }\n \n+fn noop_span(sp: &span) -> span { ret sp; }\n+\n \n fn default_ast_fold() -> @ast_fold_precursor {\n     ret @{fold_crate: noop_fold_crate,\n@@ -539,7 +543,8 @@ fn default_ast_fold() -> @ast_fold_precursor {\n           fold_path: noop_fold_path,\n           fold_local: noop_fold_local,\n           map_exprs: noop_map_exprs,\n-          new_id: noop_id};\n+          new_id: noop_id,\n+          new_span: noop_span};\n }\n \n fn dummy_out(a: ast_fold) {\n@@ -567,7 +572,8 @@ fn dummy_out(a: ast_fold) {\n          fold_path: nf_path_dummy,\n          fold_local: nf_local_dummy,\n          map_exprs: noop_map_exprs,\n-         new_id: noop_id};\n+         new_id: noop_id,\n+         new_span: noop_span};\n }\n \n \n@@ -596,19 +602,22 @@ fn make_fold(afp: &ast_fold_precursor) -> ast_fold {\n                   fold_path: nf_path_dummy,\n                   fold_local: nf_local_dummy,\n                   map_exprs: noop_map_exprs,\n-                  new_id: noop_id};\n+                  new_id: noop_id,\n+                  new_span: noop_span};\n \n     /* naturally, a macro to write these would be nice */\n     fn f_crate(afp: &ast_fold_precursor, f: ast_fold, c: &crate) -> crate {\n-        ret {node: afp.fold_crate(c.node, f), span: c.span};\n+        ret {node: afp.fold_crate(c.node, f), span: afp.new_span(c.span)};\n     }\n     fn f_crate_directive(afp: &ast_fold_precursor, f: ast_fold,\n                          c: &@crate_directive) -> @crate_directive {\n-        ret @{node: afp.fold_crate_directive(c.node, f), span: c.span};\n+        ret @{node: afp.fold_crate_directive(c.node, f),\n+              span: afp.new_span(c.span)};\n     }\n     fn f_view_item(afp: &ast_fold_precursor, f: ast_fold, x: &@view_item) ->\n        @view_item {\n-        ret @{node: afp.fold_view_item(x.node, f), span: x.span};\n+        ret @{node: afp.fold_view_item(x.node, f),\n+              span: afp.new_span(x.span)};\n     }\n     fn f_native_item(afp: &ast_fold_precursor, f: ast_fold, x: &@native_item)\n        -> @native_item {\n@@ -623,34 +632,34 @@ fn make_fold(afp: &ast_fold_precursor) -> ast_fold {\n     }\n     fn f_method(afp: &ast_fold_precursor, f: ast_fold, x: &@method) ->\n        @method {\n-        ret @{node: afp.fold_method(x.node, f), span: x.span};\n+        ret @{node: afp.fold_method(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_block(afp: &ast_fold_precursor, f: ast_fold, x: &blk) -> blk {\n-        ret {node: afp.fold_block(x.node, f), span: x.span};\n+        ret {node: afp.fold_block(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_stmt(afp: &ast_fold_precursor, f: ast_fold, x: &@stmt) -> @stmt {\n-        ret @{node: afp.fold_stmt(x.node, f), span: x.span};\n+        ret @{node: afp.fold_stmt(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_arm(afp: &ast_fold_precursor, f: ast_fold, x: &arm) -> arm {\n         ret afp.fold_arm(x, f);\n     }\n     fn f_pat(afp: &ast_fold_precursor, f: ast_fold, x: &@pat) -> @pat {\n         ret @{id: afp.new_id(x.id),\n-              node: afp.fold_pat(x.node, f), span: x.span};\n+              node: afp.fold_pat(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_decl(afp: &ast_fold_precursor, f: ast_fold, x: &@decl) -> @decl {\n-        ret @{node: afp.fold_decl(x.node, f), span: x.span};\n+        ret @{node: afp.fold_decl(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_expr(afp: &ast_fold_precursor, f: ast_fold, x: &@expr) -> @expr {\n         ret @{id: afp.new_id(x.id),\n-              node: afp.fold_expr(x.node, f), span: x.span};\n+              node: afp.fold_expr(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_ty(afp: &ast_fold_precursor, f: ast_fold, x: &@ty) -> @ty {\n-        ret @{node: afp.fold_ty(x.node, f), span: x.span};\n+        ret @{node: afp.fold_ty(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_constr(afp: &ast_fold_precursor, f: ast_fold, x: &@ast::constr) ->\n        @ast::constr {\n-        ret @{node: afp.fold_constr(x.node, f), span: x.span};\n+        ret @{node: afp.fold_constr(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_fn(afp: &ast_fold_precursor, f: ast_fold, x: &_fn) -> _fn {\n         ret afp.fold_fn(x, f);\n@@ -664,16 +673,16 @@ fn make_fold(afp: &ast_fold_precursor) -> ast_fold {\n     }\n     fn f_variant(afp: &ast_fold_precursor, f: ast_fold, x: &variant) ->\n        variant {\n-        ret {node: afp.fold_variant(x.node, f), span: x.span};\n+        ret {node: afp.fold_variant(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_ident(afp: &ast_fold_precursor, f: ast_fold, x: &ident) -> ident {\n         ret afp.fold_ident(x, f);\n     }\n     fn f_path(afp: &ast_fold_precursor, f: ast_fold, x: &path) -> path {\n-        ret {node: afp.fold_path(x.node, f), span: x.span};\n+        ret {node: afp.fold_path(x.node, f), span: afp.new_span(x.span)};\n     }\n     fn f_local(afp: &ast_fold_precursor, f: ast_fold, x: &@local) -> @local {\n-        ret @{node: afp.fold_local(x.node, f), span: x.span};\n+        ret @{node: afp.fold_local(x.node, f), span: afp.new_span(x.span)};\n     }\n \n     *result =\n@@ -700,7 +709,8 @@ fn make_fold(afp: &ast_fold_precursor) -> ast_fold {\n          fold_path: bind f_path(afp, result, _),\n          fold_local: bind f_local(afp, result, _),\n          map_exprs: afp.map_exprs,\n-         new_id: afp.new_id};\n+         new_id: afp.new_id,\n+         new_span: afp.new_span};\n     ret result;\n }\n "}, {"sha": "19f058d7ee2acac40461c84328a7b8250a96f114", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb16e6a25da9694dabe19ecea24baeb7007ba1f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "patch": "@@ -1478,7 +1478,8 @@ fn parse_pat(p: &parser) -> @ast::pat {\n         if p.peek() == token::RPAREN {\n             hi = p.get_hi_pos();\n             p.bump();\n-            pat = ast::pat_lit(@{node: ast::lit_nil, span: {lo: lo, hi: hi}});\n+            pat = ast::pat_lit(@{node: ast::lit_nil,\n+                                 span: ast::mk_sp(lo,hi)});\n         } else {\n             let fields = ~[parse_pat(p)];\n             while p.peek() == token::COMMA {"}]}