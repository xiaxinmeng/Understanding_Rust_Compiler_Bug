{"sha": "08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NzY0YWQxNjM4ZDQ5ZWU4MzAzYThlNWIxYTllNDM5Y2JiYzg3ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-10T23:27:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-10T23:27:28Z"}, "message": "Auto merge of #77087 - estebank:issue-45817, r=matthewjasper\n\nProvide structured suggestions when finding structs when expecting a trait\n\nWhen finding an ADT in a trait object definition provide some solutions. Fix #45817.\nGiven `<Param as Trait>::Assoc: Ty` suggest `Param: Trait<Assoc = Ty>`. Fix #75829.", "tree": {"sha": "770af02a1069537634eb478c8af07cccf9c9f755", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/770af02a1069537634eb478c8af07cccf9c9f755"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "html_url": "https://github.com/rust-lang/rust/commit/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1af43bc63bc7417938df056f7f25d456cc11b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1af43bc63bc7417938df056f7f25d456cc11b0e", "html_url": "https://github.com/rust-lang/rust/commit/b1af43bc63bc7417938df056f7f25d456cc11b0e"}, {"sha": "4ae8f6ec7c75b3098ee3f8897254f5b8d12d75dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae8f6ec7c75b3098ee3f8897254f5b8d12d75dc", "html_url": "https://github.com/rust-lang/rust/commit/4ae8f6ec7c75b3098ee3f8897254f5b8d12d75dc"}], "stats": {"total": 549, "additions": 525, "deletions": 24}, "files": [{"sha": "245353c2e0756495099f5b703b076722464723c3", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "patch": "@@ -1884,6 +1884,16 @@ impl Clone for Ty {\n     }\n }\n \n+impl Ty {\n+    pub fn peel_refs(&self) -> &Self {\n+        let mut final_ty = self;\n+        while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n+            final_ty = &ty;\n+        }\n+        final_ty\n+    }\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafe,"}, {"sha": "219517b4ab2e2d013afbc6b1292d63478b909956", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "patch": "@@ -384,6 +384,13 @@ struct DiagnosticMetadata<'ast> {\n \n     /// Used to detect possible `if let` written without `let` and to provide structured suggestion.\n     in_if_condition: Option<&'ast Expr>,\n+\n+    /// If we are currently in a trait object definition. Used to point at the bounds when\n+    /// encountering a struct or enum.\n+    current_trait_object: Option<&'ast [ast::GenericBound]>,\n+\n+    /// Given `where <T as Bar>::Baz: String`, suggest `where T: Bar<Baz = String>`.\n+    current_where_predicate: Option<&'ast WherePredicate>,\n }\n \n struct LateResolutionVisitor<'a, 'b, 'ast> {\n@@ -453,6 +460,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.diagnostic_metadata.current_let_binding = original;\n     }\n     fn visit_ty(&mut self, ty: &'ast Ty) {\n+        let prev = self.diagnostic_metadata.current_trait_object;\n         match ty.kind {\n             TyKind::Path(ref qself, ref path) => {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n@@ -464,9 +472,13 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n             }\n+            TyKind::TraitObject(ref bounds, ..) => {\n+                self.diagnostic_metadata.current_trait_object = Some(&bounds[..]);\n+            }\n             _ => (),\n         }\n         visit::walk_ty(self, ty);\n+        self.diagnostic_metadata.current_trait_object = prev;\n     }\n     fn visit_poly_trait_ref(&mut self, tref: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n         self.smart_resolve_path(\n@@ -660,6 +672,14 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         }\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n+\n+    fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n+        debug!(\"visit_where_predicate {:?}\", p);\n+        let previous_value =\n+            replace(&mut self.diagnostic_metadata.current_where_predicate, Some(p));\n+        visit::walk_where_predicate(self, p);\n+        self.diagnostic_metadata.current_where_predicate = previous_value;\n+    }\n }\n \n impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {"}, {"sha": "bee05e7738280ebc56e6e2701b1a07d5bb2d4e7c", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 203, "deletions": 16, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "patch": "@@ -1,13 +1,14 @@\n use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n-use crate::late::{LateResolutionVisitor, RibKind};\n+use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n use crate::path_names_to_string;\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::visit::FnKind;\n use rustc_ast::{self as ast, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n+use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -19,7 +20,7 @@ use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, Span, DUMMY_SP};\n+use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n \n use tracing::debug;\n \n@@ -439,27 +440,213 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             }\n         }\n \n-        if !self.type_ascription_suggestion(&mut err, base_span)\n-            && !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span)\n-        {\n-            // Fallback label.\n-            err.span_label(base_span, fallback_label);\n-\n-            match self.diagnostic_metadata.current_let_binding {\n-                Some((pat_sp, Some(ty_sp), None)) if ty_sp.contains(base_span) && could_be_expr => {\n-                    err.span_suggestion_short(\n-                        pat_sp.between(ty_sp),\n-                        \"use `=` if you meant to assign\",\n-                        \" = \".to_string(),\n-                        Applicability::MaybeIncorrect,\n+        if !self.type_ascription_suggestion(&mut err, base_span) {\n+            let mut fallback = false;\n+            if let (\n+                PathSource::Trait(AliasPossibility::Maybe),\n+                Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)),\n+            ) = (source, res)\n+            {\n+                if let Some(bounds @ [_, .., _]) = self.diagnostic_metadata.current_trait_object {\n+                    fallback = true;\n+                    let spans: Vec<Span> = bounds\n+                        .iter()\n+                        .map(|bound| bound.span())\n+                        .filter(|&sp| sp != base_span)\n+                        .collect();\n+\n+                    let start_span = bounds.iter().map(|bound| bound.span()).next().unwrap();\n+                    // `end_span` is the end of the poly trait ref (Foo + 'baz + Bar><)\n+                    let end_span = bounds.iter().map(|bound| bound.span()).last().unwrap();\n+                    // `last_bound_span` is the last bound of the poly trait ref (Foo + >'baz< + Bar)\n+                    let last_bound_span = spans.last().cloned().unwrap();\n+                    let mut multi_span: MultiSpan = spans.clone().into();\n+                    for sp in spans {\n+                        let msg = if sp == last_bound_span {\n+                            format!(\n+                                \"...because of {} bound{}\",\n+                                if bounds.len() <= 2 { \"this\" } else { \"these\" },\n+                                if bounds.len() <= 2 { \"\" } else { \"s\" },\n+                            )\n+                        } else {\n+                            String::new()\n+                        };\n+                        multi_span.push_span_label(sp, msg);\n+                    }\n+                    multi_span.push_span_label(\n+                        base_span,\n+                        \"expected this type to be a trait...\".to_string(),\n                     );\n+                    err.span_help(\n+                        multi_span,\n+                        \"`+` is used to constrain a \\\"trait object\\\" type with lifetimes or \\\n+                         auto-traits; structs and enums can't be bound in that way\",\n+                    );\n+                    if bounds.iter().all(|bound| match bound {\n+                        ast::GenericBound::Outlives(_) => true,\n+                        ast::GenericBound::Trait(tr, _) => tr.span == base_span,\n+                    }) {\n+                        let mut sugg = vec![];\n+                        if base_span != start_span {\n+                            sugg.push((start_span.until(base_span), String::new()));\n+                        }\n+                        if base_span != end_span {\n+                            sugg.push((base_span.shrink_to_hi().to(end_span), String::new()));\n+                        }\n+\n+                        err.multipart_suggestion(\n+                            \"if you meant to use a type and not a trait here, remove the bounds\",\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 }\n-                _ => {}\n+            }\n+\n+            fallback |= self.restrict_assoc_type_in_where_clause(span, &mut err);\n+\n+            if !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span) {\n+                fallback = true;\n+                match self.diagnostic_metadata.current_let_binding {\n+                    Some((pat_sp, Some(ty_sp), None))\n+                        if ty_sp.contains(base_span) && could_be_expr =>\n+                    {\n+                        err.span_suggestion_short(\n+                            pat_sp.between(ty_sp),\n+                            \"use `=` if you meant to assign\",\n+                            \" = \".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            if fallback {\n+                // Fallback label.\n+                err.span_label(base_span, fallback_label);\n             }\n         }\n         (err, candidates)\n     }\n \n+    /// Given `where <T as Bar>::Baz: String`, suggest `where T: Bar<Baz = String>`.\n+    fn restrict_assoc_type_in_where_clause(\n+        &mut self,\n+        span: Span,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) -> bool {\n+        // Detect that we are actually in a `where` predicate.\n+        let (bounded_ty, bounds, where_span) =\n+            if let Some(ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bounded_ty,\n+                bound_generic_params,\n+                bounds,\n+                span,\n+            })) = self.diagnostic_metadata.current_where_predicate\n+            {\n+                if !bound_generic_params.is_empty() {\n+                    return false;\n+                }\n+                (bounded_ty, bounds, span)\n+            } else {\n+                return false;\n+            };\n+\n+        // Confirm that the target is an associated type.\n+        let (ty, position, path) = if let ast::TyKind::Path(\n+            Some(ast::QSelf { ty, position, .. }),\n+            path,\n+        ) = &bounded_ty.kind\n+        {\n+            // use this to verify that ident is a type param.\n+            let partial_res = if let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n+                bounded_ty.id,\n+                None,\n+                &Segment::from_path(path),\n+                Namespace::TypeNS,\n+                span,\n+                true,\n+                CrateLint::No,\n+            ) {\n+                partial_res\n+            } else {\n+                return false;\n+            };\n+            if !(matches!(\n+                partial_res.base_res(),\n+                hir::def::Res::Def(hir::def::DefKind::AssocTy, _)\n+            ) && partial_res.unresolved_segments() == 0)\n+            {\n+                return false;\n+            }\n+            (ty, position, path)\n+        } else {\n+            return false;\n+        };\n+\n+        if let ast::TyKind::Path(None, type_param_path) = &ty.peel_refs().kind {\n+            // Confirm that the `SelfTy` is a type parameter.\n+            let partial_res = if let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n+                bounded_ty.id,\n+                None,\n+                &Segment::from_path(type_param_path),\n+                Namespace::TypeNS,\n+                span,\n+                true,\n+                CrateLint::No,\n+            ) {\n+                partial_res\n+            } else {\n+                return false;\n+            };\n+            if !(matches!(\n+                partial_res.base_res(),\n+                hir::def::Res::Def(hir::def::DefKind::TyParam, _)\n+            ) && partial_res.unresolved_segments() == 0)\n+            {\n+                return false;\n+            }\n+            if let (\n+                [ast::PathSegment { ident: constrain_ident, args: None, .. }],\n+                [ast::GenericBound::Trait(poly_trait_ref, ast::TraitBoundModifier::None)],\n+            ) = (&type_param_path.segments[..], &bounds[..])\n+            {\n+                if let [ast::PathSegment { ident, args: None, .. }] =\n+                    &poly_trait_ref.trait_ref.path.segments[..]\n+                {\n+                    if ident.span == span {\n+                        err.span_suggestion_verbose(\n+                            *where_span,\n+                            &format!(\"constrain the associated type to `{}`\", ident),\n+                            format!(\n+                                \"{}: {}<{} = {}>\",\n+                                self.r\n+                                    .session\n+                                    .source_map()\n+                                    .span_to_snippet(ty.span) // Account for `<&'a T as Foo>::Bar`.\n+                                    .unwrap_or_else(|_| constrain_ident.to_string()),\n+                                path.segments[..*position]\n+                                    .iter()\n+                                    .map(|segment| path_segment_to_string(segment))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"::\"),\n+                                path.segments[*position..]\n+                                    .iter()\n+                                    .map(|segment| path_segment_to_string(segment))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"::\"),\n+                                ident,\n+                            ),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     /// Check if the source is call expression and the first argument is `self`. If true,\n     /// return the span of whole call and the span for all arguments expect the first one (`self`).\n     fn call_has_self_arg(&self, source: PathSource<'_>) -> Option<(Span, Option<Span>)> {"}, {"sha": "c66009fe24c06ce0cd9cbd2dacffe285c8f4f720", "filename": "src/test/ui/traits/assoc_type_bound_with_struct.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.rs?ref=08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "patch": "@@ -0,0 +1,19 @@\n+trait Bar {\n+    type Baz;\n+}\n+\n+struct Foo<T> where T: Bar, <T as Bar>::Baz: String { //~ ERROR expected trait, found struct\n+    t: T,\n+}\n+\n+struct Qux<'a, T> where T: Bar, <&'a T as Bar>::Baz: String { //~ ERROR expected trait, found struct\n+    t: &'a T,\n+}\n+\n+fn foo<T: Bar>(_: T) where <T as Bar>::Baz: String { //~ ERROR expected trait, found struct\n+}\n+\n+fn qux<'a, T: Bar>(_: &'a T) where <&'a T as Bar>::Baz: String { //~ ERROR expected trait, found\n+}\n+\n+fn main() {}"}, {"sha": "7cf872eb6ac6907553e32a62343fcd55354eb4fc", "filename": "src/test/ui/traits/assoc_type_bound_with_struct.stderr", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.stderr?ref=08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "patch": "@@ -0,0 +1,83 @@\n+error[E0404]: expected trait, found struct `String`\n+  --> $DIR/assoc_type_bound_with_struct.rs:5:46\n+   |\n+LL | struct Foo<T> where T: Bar, <T as Bar>::Baz: String {\n+   |                                              ^^^^^^ not a trait\n+   | \n+  ::: $SRC_DIR/alloc/src/string.rs:LL:COL\n+   |\n+LL | pub trait ToString {\n+   | ------------------ similarly named trait `ToString` defined here\n+   |\n+help: constrain the associated type to `String`\n+   |\n+LL | struct Foo<T> where T: Bar, T: Bar<Baz = String> {\n+   |                             ^^^^^^^^^^^^^^^^^^^^\n+help: a trait with a similar name exists\n+   |\n+LL | struct Foo<T> where T: Bar, <T as Bar>::Baz: ToString {\n+   |                                              ^^^^^^^^\n+\n+error[E0404]: expected trait, found struct `String`\n+  --> $DIR/assoc_type_bound_with_struct.rs:9:54\n+   |\n+LL | struct Qux<'a, T> where T: Bar, <&'a T as Bar>::Baz: String {\n+   |                                                      ^^^^^^ not a trait\n+   | \n+  ::: $SRC_DIR/alloc/src/string.rs:LL:COL\n+   |\n+LL | pub trait ToString {\n+   | ------------------ similarly named trait `ToString` defined here\n+   |\n+help: constrain the associated type to `String`\n+   |\n+LL | struct Qux<'a, T> where T: Bar, &'a T: Bar<Baz = String> {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+help: a trait with a similar name exists\n+   |\n+LL | struct Qux<'a, T> where T: Bar, <&'a T as Bar>::Baz: ToString {\n+   |                                                      ^^^^^^^^\n+\n+error[E0404]: expected trait, found struct `String`\n+  --> $DIR/assoc_type_bound_with_struct.rs:13:45\n+   |\n+LL | fn foo<T: Bar>(_: T) where <T as Bar>::Baz: String {\n+   |                                             ^^^^^^ not a trait\n+   | \n+  ::: $SRC_DIR/alloc/src/string.rs:LL:COL\n+   |\n+LL | pub trait ToString {\n+   | ------------------ similarly named trait `ToString` defined here\n+   |\n+help: constrain the associated type to `String`\n+   |\n+LL | fn foo<T: Bar>(_: T) where T: Bar<Baz = String> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^\n+help: a trait with a similar name exists\n+   |\n+LL | fn foo<T: Bar>(_: T) where <T as Bar>::Baz: ToString {\n+   |                                             ^^^^^^^^\n+\n+error[E0404]: expected trait, found struct `String`\n+  --> $DIR/assoc_type_bound_with_struct.rs:16:57\n+   |\n+LL | fn qux<'a, T: Bar>(_: &'a T) where <&'a T as Bar>::Baz: String {\n+   |                                                         ^^^^^^ not a trait\n+   | \n+  ::: $SRC_DIR/alloc/src/string.rs:LL:COL\n+   |\n+LL | pub trait ToString {\n+   | ------------------ similarly named trait `ToString` defined here\n+   |\n+help: constrain the associated type to `String`\n+   |\n+LL | fn qux<'a, T: Bar>(_: &'a T) where &'a T: Bar<Baz = String> {\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+help: a trait with a similar name exists\n+   |\n+LL | fn qux<'a, T: Bar>(_: &'a T) where <&'a T as Bar>::Baz: ToString {\n+   |                                                         ^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0404`."}, {"sha": "8633e9d7a4cefb9b1e6a2628259052e3de3749af", "filename": "src/test/ui/traits/trait-bounds-not-on-struct.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-struct.rs?ref=08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "patch": "@@ -1,9 +1,38 @@\n+// We don't need those errors. Ideally we would silence them, but to do so we need to move the\n+// lint from being an early-lint during parsing to a late-lint, because it needs to be aware of\n+// the types involved.\n #![allow(bare_trait_objects)]\n \n struct Foo;\n \n fn foo(_x: Box<Foo + Send>) { } //~ ERROR expected trait, found struct `Foo`\n \n-type A<T> = Box<dyn Vec<T>>; //~ ERROR expected trait, found struct `Vec`\n+type TypeAlias<T> = Box<dyn Vec<T>>; //~ ERROR expected trait, found struct `Vec`\n \n-fn main() { }\n+struct A;\n+fn a() -> A + 'static { //~ ERROR expected trait, found\n+    A\n+}\n+fn b<'a,T,E>(iter: Iterator<Item=Result<T,E> + 'a>) { //~ ERROR expected trait, found\n+    panic!()\n+}\n+fn c() -> 'static + A { //~ ERROR expected trait, found\n+    A\n+}\n+fn d<'a,T,E>(iter: Iterator<Item='a + Result<T,E>>) { //~ ERROR expected trait, found\n+    panic!()\n+}\n+fn e() -> 'static + A + 'static { //~ ERROR expected trait, found\n+//~^ ERROR only a single explicit lifetime bound is permitted\n+    A\n+}\n+fn f<'a,T,E>(iter: Iterator<Item='a + Result<T,E> + 'a>) { //~ ERROR expected trait, found\n+//~^ ERROR only a single explicit lifetime bound is permitted\n+    panic!()\n+}\n+struct Traitor;\n+trait Trait {}\n+fn g() -> Traitor + 'static { //~ ERROR expected trait, found struct `Traitor`\n+    A\n+}\n+fn main() {}"}, {"sha": "0f97e3bdf1872c16166649cb96e6678647b5b6d4", "filename": "src/test/ui/traits/trait-bounds-not-on-struct.stderr", "status": "modified", "additions": 159, "deletions": 6, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08764ad1638d49ee8303a8e5b1a9e439cbbc87f6/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-not-on-struct.stderr?ref=08764ad1638d49ee8303a8e5b1a9e439cbbc87f6", "patch": "@@ -1,15 +1,168 @@\n+error[E0226]: only a single explicit lifetime bound is permitted\n+  --> $DIR/trait-bounds-not-on-struct.rs:25:25\n+   |\n+LL | fn e() -> 'static + A + 'static {\n+   |                         ^^^^^^^\n+\n+error[E0226]: only a single explicit lifetime bound is permitted\n+  --> $DIR/trait-bounds-not-on-struct.rs:29:53\n+   |\n+LL | fn f<'a,T,E>(iter: Iterator<Item='a + Result<T,E> + 'a>) {\n+   |                                                     ^^\n+\n error[E0404]: expected trait, found struct `Foo`\n-  --> $DIR/trait-bounds-not-on-struct.rs:5:16\n+  --> $DIR/trait-bounds-not-on-struct.rs:8:16\n    |\n LL | fn foo(_x: Box<Foo + Send>) { }\n    |                ^^^ not a trait\n+   |\n+help: `+` is used to constrain a \"trait object\" type with lifetimes or auto-traits; structs and enums can't be bound in that way\n+  --> $DIR/trait-bounds-not-on-struct.rs:8:22\n+   |\n+LL | fn foo(_x: Box<Foo + Send>) { }\n+   |                ---   ^^^^ ...because of this bound\n+   |                |\n+   |                expected this type to be a trait...\n \n error[E0404]: expected trait, found struct `Vec`\n-  --> $DIR/trait-bounds-not-on-struct.rs:7:21\n+  --> $DIR/trait-bounds-not-on-struct.rs:10:29\n+   |\n+LL | type TypeAlias<T> = Box<dyn Vec<T>>;\n+   |                             ^^^^^^ not a trait\n+\n+error[E0404]: expected trait, found struct `A`\n+  --> $DIR/trait-bounds-not-on-struct.rs:13:11\n+   |\n+LL | fn a() -> A + 'static {\n+   |           ^ not a trait\n+   |\n+help: `+` is used to constrain a \"trait object\" type with lifetimes or auto-traits; structs and enums can't be bound in that way\n+  --> $DIR/trait-bounds-not-on-struct.rs:13:15\n+   |\n+LL | fn a() -> A + 'static {\n+   |           -   ^^^^^^^ ...because of this bound\n+   |           |\n+   |           expected this type to be a trait...\n+help: if you meant to use a type and not a trait here, remove the bounds\n+   |\n+LL | fn a() -> A {\n+   |           --\n+\n+error[E0404]: expected trait, found enum `Result`\n+  --> $DIR/trait-bounds-not-on-struct.rs:16:34\n+   |\n+LL | fn b<'a,T,E>(iter: Iterator<Item=Result<T,E> + 'a>) {\n+   |                                  ^^^^^^^^^^^ not a trait\n+   |\n+help: `+` is used to constrain a \"trait object\" type with lifetimes or auto-traits; structs and enums can't be bound in that way\n+  --> $DIR/trait-bounds-not-on-struct.rs:16:48\n+   |\n+LL | fn b<'a,T,E>(iter: Iterator<Item=Result<T,E> + 'a>) {\n+   |                                  -----------   ^^ ...because of this bound\n+   |                                  |\n+   |                                  expected this type to be a trait...\n+help: if you meant to use a type and not a trait here, remove the bounds\n+   |\n+LL | fn b<'a,T,E>(iter: Iterator<Item=Result<T,E>>) {\n+   |                                            --\n+\n+error[E0404]: expected trait, found struct `A`\n+  --> $DIR/trait-bounds-not-on-struct.rs:19:21\n+   |\n+LL | fn c() -> 'static + A {\n+   |                     ^ not a trait\n+   |\n+help: `+` is used to constrain a \"trait object\" type with lifetimes or auto-traits; structs and enums can't be bound in that way\n+  --> $DIR/trait-bounds-not-on-struct.rs:19:11\n+   |\n+LL | fn c() -> 'static + A {\n+   |           ^^^^^^^   - expected this type to be a trait...\n+   |           |\n+   |           ...because of this bound\n+help: if you meant to use a type and not a trait here, remove the bounds\n+   |\n+LL | fn c() -> A {\n+   |          --\n+\n+error[E0404]: expected trait, found enum `Result`\n+  --> $DIR/trait-bounds-not-on-struct.rs:22:39\n+   |\n+LL | fn d<'a,T,E>(iter: Iterator<Item='a + Result<T,E>>) {\n+   |                                       ^^^^^^^^^^^ not a trait\n+   |\n+help: `+` is used to constrain a \"trait object\" type with lifetimes or auto-traits; structs and enums can't be bound in that way\n+  --> $DIR/trait-bounds-not-on-struct.rs:22:34\n+   |\n+LL | fn d<'a,T,E>(iter: Iterator<Item='a + Result<T,E>>) {\n+   |                                  ^^   ----------- expected this type to be a trait...\n+   |                                  |\n+   |                                  ...because of this bound\n+help: if you meant to use a type and not a trait here, remove the bounds\n+   |\n+LL | fn d<'a,T,E>(iter: Iterator<Item=Result<T,E>>) {\n+   |                                 --\n+\n+error[E0404]: expected trait, found struct `A`\n+  --> $DIR/trait-bounds-not-on-struct.rs:25:21\n+   |\n+LL | fn e() -> 'static + A + 'static {\n+   |                     ^ not a trait\n+   |\n+help: `+` is used to constrain a \"trait object\" type with lifetimes or auto-traits; structs and enums can't be bound in that way\n+  --> $DIR/trait-bounds-not-on-struct.rs:25:11\n+   |\n+LL | fn e() -> 'static + A + 'static {\n+   |           ^^^^^^^   -   ^^^^^^^ ...because of these bounds\n+   |                     |\n+   |                     expected this type to be a trait...\n+help: if you meant to use a type and not a trait here, remove the bounds\n+   |\n+LL | fn e() -> A {\n+   |          ---\n+\n+error[E0404]: expected trait, found enum `Result`\n+  --> $DIR/trait-bounds-not-on-struct.rs:29:39\n+   |\n+LL | fn f<'a,T,E>(iter: Iterator<Item='a + Result<T,E> + 'a>) {\n+   |                                       ^^^^^^^^^^^ not a trait\n+   |\n+help: `+` is used to constrain a \"trait object\" type with lifetimes or auto-traits; structs and enums can't be bound in that way\n+  --> $DIR/trait-bounds-not-on-struct.rs:29:34\n+   |\n+LL | fn f<'a,T,E>(iter: Iterator<Item='a + Result<T,E> + 'a>) {\n+   |                                  ^^   -----------   ^^ ...because of these bounds\n+   |                                       |\n+   |                                       expected this type to be a trait...\n+help: if you meant to use a type and not a trait here, remove the bounds\n+   |\n+LL | fn f<'a,T,E>(iter: Iterator<Item=Result<T,E>>) {\n+   |                                 --         --\n+\n+error[E0404]: expected trait, found struct `Traitor`\n+  --> $DIR/trait-bounds-not-on-struct.rs:35:11\n+   |\n+LL | trait Trait {}\n+   | ----------- similarly named trait `Trait` defined here\n+LL | fn g() -> Traitor + 'static {\n+   |           ^^^^^^^ not a trait\n+   |\n+help: `+` is used to constrain a \"trait object\" type with lifetimes or auto-traits; structs and enums can't be bound in that way\n+  --> $DIR/trait-bounds-not-on-struct.rs:35:21\n+   |\n+LL | fn g() -> Traitor + 'static {\n+   |           -------   ^^^^^^^ ...because of this bound\n+   |           |\n+   |           expected this type to be a trait...\n+help: if you meant to use a type and not a trait here, remove the bounds\n+   |\n+LL | fn g() -> Traitor {\n+   |                 --\n+help: a trait with a similar name exists\n    |\n-LL | type A<T> = Box<dyn Vec<T>>;\n-   |                     ^^^^^^ not a trait\n+LL | fn g() -> Trait + 'static {\n+   |           ^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 11 previous errors\n \n-For more information about this error, try `rustc --explain E0404`.\n+Some errors have detailed explanations: E0226, E0404.\n+For more information about an error, try `rustc --explain E0226`."}]}