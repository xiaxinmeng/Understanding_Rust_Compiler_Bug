{"sha": "19f77603c0aed92ec70a836dae4d447b8fcab922", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5Zjc3NjAzYzBhZWQ5MmVjNzBhODM2ZGFlNGQ0NDdiOGZjYWI5MjI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-27T18:00:08Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-27T18:00:08Z"}, "message": "Merge #661\n\n661: Implement type generics for functions r=flodiebold a=marcusklaas\n\nPretty printing of function types isn't as nice any more since the current implementation does not store its argument types directly. We could store some more information to print more information on the argument and return types, at a cost of course.\n\nCo-authored-by: Marcus Klaas de Vries <mail@marcusklaas.nl>", "tree": {"sha": "a1739442c9f79c5c6addc0efc7d25a7da678ce02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1739442c9f79c5c6addc0efc7d25a7da678ce02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19f77603c0aed92ec70a836dae4d447b8fcab922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19f77603c0aed92ec70a836dae4d447b8fcab922", "html_url": "https://github.com/rust-lang/rust/commit/19f77603c0aed92ec70a836dae4d447b8fcab922", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19f77603c0aed92ec70a836dae4d447b8fcab922/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "3f4f50baaa21cb2d0f6c102f1ca521946071a8dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4f50baaa21cb2d0f6c102f1ca521946071a8dc", "html_url": "https://github.com/rust-lang/rust/commit/3f4f50baaa21cb2d0f6c102f1ca521946071a8dc"}, {"sha": "6249989e6c133792ff457896d4723c0eb0f42137", "url": "https://api.github.com/repos/rust-lang/rust/commits/6249989e6c133792ff457896d4723c0eb0f42137", "html_url": "https://github.com/rust-lang/rust/commit/6249989e6c133792ff457896d4723c0eb0f42137"}], "stats": {"total": 311, "additions": 227, "deletions": 84}, "files": [{"sha": "e4008058ccf58bf7275af6350ee8f079cd6353f7", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -424,6 +424,10 @@ impl Function {\n         self.id.module(db)\n     }\n \n+    pub fn name(&self, db: &impl HirDatabase) -> Name {\n+        self.signature(db).name.clone()\n+    }\n+\n     pub fn body_syntax_mapping(&self, db: &impl HirDatabase) -> Arc<BodySyntaxMapping> {\n         db.body_syntax_mapping(*self)\n     }"}, {"sha": "37715a903a4ebbda2d826767d5fe38b07c1495a5", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 126, "deletions": 36, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -20,6 +20,7 @@ mod tests;\n pub(crate) mod method_resolution;\n \n use std::borrow::Cow;\n+use std::iter::repeat;\n use std::ops::Index;\n use std::sync::Arc;\n use std::{fmt, mem};\n@@ -185,7 +186,7 @@ pub enum Ty {\n \n     /// Structures, enumerations and unions.\n     Adt {\n-        /// The DefId of the struct/enum.\n+        /// The definition of the struct/enum.\n         def_id: AdtDef,\n         /// The name, for displaying.\n         name: Name,\n@@ -209,6 +210,27 @@ pub enum Ty {\n     /// `&'a mut T` or `&'a T`.\n     Ref(Arc<Ty>, Mutability),\n \n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef {\n+        // Function definition\n+        def: Function,\n+        /// For display\n+        name: Name,\n+        /// Parameters and return type\n+        sig: Arc<FnSig>,\n+        /// Substitutions for the generic parameters of the type\n+        substs: Substs,\n+    },\n+\n     /// A pointer to a function.  Written as `fn() -> i32`.\n     ///\n     /// For example the type of `bar` here:\n@@ -448,12 +470,12 @@ impl Ty {\n         }\n         // add placeholders for args that were not provided\n         // TODO: handle defaults\n-        for _ in segment\n+        let supplied_params = segment\n             .args_and_bindings\n             .as_ref()\n             .map(|ga| ga.args.len())\n-            .unwrap_or(0)..def_generics.params.len()\n-        {\n+            .unwrap_or(0);\n+        for _ in supplied_params..def_generics.params.len() {\n             substs.push(Ty::Unknown);\n         }\n         assert_eq!(substs.len(), def_generics.params.len());\n@@ -485,6 +507,19 @@ impl Ty {\n                 }\n                 sig_mut.output.walk_mut(f);\n             }\n+            Ty::FnDef { substs, sig, .. } => {\n+                let sig_mut = Arc::make_mut(sig);\n+                for input in &mut sig_mut.input {\n+                    input.walk_mut(f);\n+                }\n+                sig_mut.output.walk_mut(f);\n+                // Without an Arc::make_mut_slice, we can't avoid the clone here:\n+                let mut v: Vec<_> = substs.0.iter().cloned().collect();\n+                for t in &mut v {\n+                    t.walk_mut(f);\n+                }\n+                substs.0 = v.into();\n+            }\n             Ty::Adt { substs, .. } => {\n                 // Without an Arc::make_mut_slice, we can't avoid the clone here:\n                 let mut v: Vec<_> = substs.0.iter().cloned().collect();\n@@ -524,6 +559,12 @@ impl Ty {\n                 name,\n                 substs,\n             },\n+            Ty::FnDef { def, name, sig, .. } => Ty::FnDef {\n+                def,\n+                name,\n+                sig,\n+                substs,\n+            },\n             _ => self,\n         }\n     }\n@@ -551,7 +592,7 @@ impl Ty {\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     fn substs(&self) -> Option<Substs> {\n         match self {\n-            Ty::Adt { substs, .. } => Some(substs.clone()),\n+            Ty::Adt { substs, .. } | Ty::FnDef { substs, .. } => Some(substs.clone()),\n             _ => None,\n         }\n     }\n@@ -586,6 +627,22 @@ impl fmt::Display for Ty {\n                     .to_fmt(f)?;\n                 write!(f, \" -> {}\", sig.output)\n             }\n+            Ty::FnDef {\n+                name, substs, sig, ..\n+            } => {\n+                write!(f, \"fn {}\", name)?;\n+                if substs.0.len() > 0 {\n+                    join(substs.0.iter())\n+                        .surround_with(\"<\", \">\")\n+                        .separator(\", \")\n+                        .to_fmt(f)?;\n+                }\n+                join(sig.input.iter())\n+                    .surround_with(\"(\", \")\")\n+                    .separator(\", \")\n+                    .to_fmt(f)?;\n+                write!(f, \" -> {}\", sig.output)\n+            }\n             Ty::Adt { name, substs, .. } => {\n                 write!(f, \"{}\", name)?;\n                 if substs.0.len() > 0 {\n@@ -607,11 +664,11 @@ impl fmt::Display for Ty {\n \n /// Compute the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n-    let signature = f.signature(db);\n-    let module = f.module(db);\n-    let impl_block = f.impl_block(db);\n-    let generics = f.generic_params(db);\n+fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n+    let signature = def.signature(db);\n+    let module = def.module(db);\n+    let impl_block = def.impl_block(db);\n+    let generics = def.generic_params(db);\n     let input = signature\n         .params()\n         .iter()\n@@ -624,8 +681,15 @@ fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n         &generics,\n         signature.ret_type(),\n     );\n-    let sig = FnSig { input, output };\n-    Ty::FnPtr(Arc::new(sig))\n+    let sig = Arc::new(FnSig { input, output });\n+    let substs = make_substs(&generics);\n+    let name = def.name(db);\n+    Ty::FnDef {\n+        def,\n+        sig,\n+        name,\n+        substs,\n+    }\n }\n \n fn make_substs(generics: &GenericParams) -> Substs {\n@@ -1102,7 +1166,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             .into();\n         let typable = typable?;\n         let ty = self.db.type_for_def(typable);\n+        let generics = GenericParams::default();\n+        let substs = Ty::substs_from_path(\n+            self.db,\n+            &self.module,\n+            self.impl_block.as_ref(),\n+            &generics,\n+            path,\n+            typable,\n+        );\n+        let ty = ty.apply_substs(substs);\n         let ty = self.insert_type_vars(ty);\n+\n         Some(ty)\n     }\n \n@@ -1142,7 +1217,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(var.into()))\n             }\n-            TypableDef::Enum(_) | TypableDef::Function(_) => (Ty::Unknown, None),\n+            TypableDef::Function(_) | TypableDef::Enum(_) => (Ty::Unknown, None),\n         }\n     }\n \n@@ -1196,9 +1271,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     Ty::Tuple(ref tuple_args) => &**tuple_args,\n                     _ => &[],\n                 };\n-                let expectations_iter = expectations\n-                    .into_iter()\n-                    .chain(std::iter::repeat(&Ty::Unknown));\n+                let expectations_iter = expectations.into_iter().chain(repeat(&Ty::Unknown));\n \n                 let inner_tys = args\n                     .iter()\n@@ -1332,18 +1405,25 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let (param_tys, ret_ty) = match &callee_ty {\n-                    Ty::FnPtr(sig) => (&sig.input[..], sig.output.clone()),\n+                    Ty::FnPtr(sig) => (sig.input.clone(), sig.output.clone()),\n+                    Ty::FnDef { substs, sig, .. } => {\n+                        let ret_ty = sig.output.clone().subst(&substs);\n+                        let param_tys = sig\n+                            .input\n+                            .iter()\n+                            .map(|ty| ty.clone().subst(&substs))\n+                            .collect();\n+                        (param_tys, ret_ty)\n+                    }\n                     _ => {\n                         // not callable\n                         // TODO report an error?\n-                        (&[][..], Ty::Unknown)\n+                        (Vec::new(), Ty::Unknown)\n                     }\n                 };\n-                for (i, arg) in args.iter().enumerate() {\n-                    self.infer_expr(\n-                        *arg,\n-                        &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                    );\n+                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n+                for (arg, param) in args.iter().zip(param_iter) {\n+                    self.infer_expr(*arg, &Expectation::has_type(param));\n                 }\n                 ret_ty\n             }\n@@ -1365,21 +1445,34 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n                     Ty::FnPtr(sig) => {\n                         if sig.input.len() > 0 {\n-                            (&sig.input[0], &sig.input[1..], sig.output.clone())\n+                            (\n+                                sig.input[0].clone(),\n+                                sig.input[1..].iter().cloned().collect(),\n+                                sig.output.clone(),\n+                            )\n                         } else {\n-                            (&Ty::Unknown, &[][..], sig.output.clone())\n+                            (Ty::Unknown, Vec::new(), sig.output.clone())\n                         }\n                     }\n-                    _ => (&Ty::Unknown, &[][..], Ty::Unknown),\n+                    Ty::FnDef { substs, sig, .. } => {\n+                        let ret_ty = sig.output.clone().subst(&substs);\n+\n+                        if sig.input.len() > 0 {\n+                            let mut arg_iter = sig.input.iter().map(|ty| ty.clone().subst(&substs));\n+                            let receiver_ty = arg_iter.next().unwrap();\n+                            (receiver_ty, arg_iter.collect(), ret_ty)\n+                        } else {\n+                            (Ty::Unknown, Vec::new(), ret_ty)\n+                        }\n+                    }\n+                    _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n                 };\n                 // TODO we would have to apply the autoderef/autoref steps here\n                 // to get the correct receiver type to unify...\n-                self.unify(expected_receiver_ty, &receiver_ty);\n-                for (i, arg) in args.iter().enumerate() {\n-                    self.infer_expr(\n-                        *arg,\n-                        &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                    );\n+                self.unify(&expected_receiver_ty, &receiver_ty);\n+                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n+                for (arg, param) in args.iter().zip(param_iter) {\n+                    self.infer_expr(*arg, &Expectation::has_type(param));\n                 }\n                 ret_ty\n             }\n@@ -1609,10 +1702,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n             self.infer_pat(*pat, &ty);\n         }\n-        self.return_ty = {\n-            let ty = self.make_ty(signature.ret_type());\n-            ty\n-        };\n+        self.return_ty = self.make_ty(signature.ret_type());\n     }\n \n     fn infer_body(&mut self) {"}, {"sha": "f5840a934748e8c244010bed30ae39c2a0bd0799", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_backwards.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_backwards.snap", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_backwards.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_backwards.snap?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -1,16 +1,16 @@\n ---\n-created: \"2019-01-22T14:44:59.880187500+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-26T17:46:03.842478456+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [14; 15) 'x': u32\n [22; 24) '{}': ()\n [78; 231) '{     ...t &c }': &mut &f64\n [88; 89) 'a': u32\n [92; 108) 'unknow...nction': [unknown]\n [92; 110) 'unknow...tion()': u32\n-[116; 125) 'takes_u32': fn(u32) -> ()\n+[116; 125) 'takes_u32': fn takes_u32(u32) -> ()\n [116; 128) 'takes_u32(a)': ()\n [126; 127) 'a': u32\n [138; 139) 'b': i32"}, {"sha": "b9dda2bc073cafb2045e8b9abb3e7393fceee114", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_binary_op.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_binary_op.snap", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_binary_op.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_binary_op.snap?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -1,8 +1,8 @@\n ---\n-created: \"2019-01-22T14:44:59.880187500+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-26T17:46:03.853259898+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [6; 7) 'x': bool\n [22; 34) '{     0i32 }': i32\n@@ -28,7 +28,7 @@ source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n [174; 196) 'minus_...ONST_2': bool\n [189; 196) 'CONST_2': isize\n [206; 207) 'c': i32\n-[210; 211) 'f': fn(bool) -> i32\n+[210; 211) 'f': fn f(bool) -> i32\n [210; 219) 'f(z || y)': i32\n [210; 223) 'f(z || y) + 5': i32\n [212; 213) 'z': bool"}, {"sha": "8ff6e55a6b6638de04395514085998836eed1123", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_function_generics.snap", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -1,21 +1,21 @@\n ---\n-created: \"2019-01-22T14:44:59.954958500+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-26T18:16:16.530712344+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [10; 11) 't': [unknown]\n [21; 26) '{ t }': [unknown]\n [23; 24) 't': [unknown]\n [38; 98) '{     ...(1); }': ()\n-[44; 46) 'id': fn(T) -> T\n-[44; 52) 'id(1u32)': T\n+[44; 46) 'id': fn id<u32>(T) -> T\n+[44; 52) 'id(1u32)': u32\n [47; 51) '1u32': u32\n-[58; 68) 'id::<i128>': fn(T) -> T\n-[58; 71) 'id::<i128>(1)': T\n-[69; 70) '1': T\n-[81; 82) 'x': T\n-[90; 92) 'id': fn(T) -> T\n-[90; 95) 'id(1)': T\n-[93; 94) '1': T\n+[58; 68) 'id::<i128>': fn id<i128>(T) -> T\n+[58; 71) 'id::<i128>(1)': i128\n+[69; 70) '1': i128\n+[81; 82) 'x': u64\n+[90; 92) 'id': fn id<u64>(T) -> T\n+[90; 95) 'id(1)': u64\n+[93; 94) '1': u64\n "}, {"sha": "f21bffa75450b20cf4f9ad263fd3187f645cefc9", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_generic_chain.snap", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -1,8 +1,8 @@\n ---\n-created: \"2019-01-22T14:44:59.961936900+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-26T17:46:03.866825843+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [53; 57) 'self': A<[unknown]>\n [65; 87) '{     ...     }': [unknown]\n@@ -12,25 +12,25 @@ source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n [110; 115) '{ t }': [unknown]\n [112; 113) 't': [unknown]\n [135; 261) '{     ....x() }': i128\n-[146; 147) 'x': T\n-[150; 151) '1': T\n-[162; 163) 'y': T\n-[166; 168) 'id': fn(T) -> T\n-[166; 171) 'id(x)': T\n-[169; 170) 'x': T\n-[182; 183) 'a': A<T>\n-[186; 200) 'A { x: id(y) }': A<T>\n-[193; 195) 'id': fn(T) -> T\n-[193; 198) 'id(y)': T\n-[196; 197) 'y': T\n-[211; 212) 'z': T\n-[215; 217) 'id': fn(T) -> T\n-[215; 222) 'id(a.x)': T\n-[218; 219) 'a': A<T>\n-[218; 221) 'a.x': T\n-[233; 234) 'b': A<T>\n-[237; 247) 'A { x: z }': A<T>\n-[244; 245) 'z': T\n-[254; 255) 'b': A<T>\n+[146; 147) 'x': i32\n+[150; 151) '1': i32\n+[162; 163) 'y': i32\n+[166; 168) 'id': fn id<i32>(T) -> T\n+[166; 171) 'id(x)': i32\n+[169; 170) 'x': i32\n+[182; 183) 'a': A<i32>\n+[186; 200) 'A { x: id(y) }': A<i32>\n+[193; 195) 'id': fn id<i32>(T) -> T\n+[193; 198) 'id(y)': i32\n+[196; 197) 'y': i32\n+[211; 212) 'z': i32\n+[215; 217) 'id': fn id<i32>(T) -> T\n+[215; 222) 'id(a.x)': i32\n+[218; 219) 'a': A<i32>\n+[218; 221) 'a.x': i32\n+[233; 234) 'b': A<i32>\n+[237; 247) 'A { x: z }': A<i32>\n+[244; 245) 'z': i32\n+[254; 255) 'b': A<i32>\n [254; 259) 'b.x()': i128\n "}, {"sha": "afbe2f747aabf9b1ab1d3d6d0052d7b1453ba989", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_paths.snap", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_paths.snap", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_paths.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_paths.snap?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -1,16 +1,16 @@\n ---\n-created: \"2019-01-22T14:44:59.975899500+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-26T17:46:03.928773630+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [15; 20) '{ 1 }': u32\n [17; 18) '1': u32\n [48; 53) '{ 1 }': u32\n [50; 51) '1': u32\n [67; 91) '{     ...c(); }': ()\n-[73; 74) 'a': fn() -> u32\n+[73; 74) 'a': fn a() -> u32\n [73; 76) 'a()': u32\n-[82; 86) 'b::c': fn() -> u32\n+[82; 86) 'b::c': fn c() -> u32\n [82; 88) 'b::c()': u32\n "}, {"sha": "a993232642020beb9bd20a6d1737b4b16a00b5a4", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_type_param.snap", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -0,0 +1,26 @@\n+---\n+created: \"2019-01-27T16:54:18.368427685+00:00\"\n+creator: insta@0.5.2\n+expression: \"&result\"\n+source: crates/ra_hir/src/ty/tests.rs\n+---\n+[10; 11) 'x': [unknown]\n+[21; 30) '{     x }': [unknown]\n+[27; 28) 'x': [unknown]\n+[44; 45) 'x': &[unknown]\n+[56; 65) '{     x }': &[unknown]\n+[62; 63) 'x': &[unknown]\n+[77; 157) '{     ...(1); }': ()\n+[87; 88) 'y': u32\n+[91; 96) '10u32': u32\n+[102; 104) 'id': fn id<u32>(T) -> T\n+[102; 107) 'id(y)': u32\n+[105; 106) 'y': u32\n+[117; 118) 'x': bool\n+[127; 132) 'clone': fn clone<bool>(&T) -> T\n+[127; 135) 'clone(z)': bool\n+[133; 134) 'z': &bool\n+[141; 151) 'id::<i128>': fn id<i128>(T) -> T\n+[141; 154) 'id::<i128>(1)': i128\n+[152; 153) '1': i128\n+"}, {"sha": "ac12d974b89a0b94b5dc9b7b5e02921862b8bb42", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f77603c0aed92ec70a836dae4d447b8fcab922/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=19f77603c0aed92ec70a836dae4d447b8fcab922", "patch": "@@ -594,6 +594,29 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_type_param() {\n+    check_inference(\n+        \"infer_type_param\",\n+        r#\"\n+fn id<T>(x: T) -> T {\n+    x\n+}\n+\n+fn clone<T>(x: &T) -> T {\n+    x\n+}\n+\n+fn test() {\n+    let y = 10u32;\n+    id(y);\n+    let x: bool = clone(z);\n+    id::<i128>(1);\n+}\n+\"#,\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.parse(file_id);"}]}