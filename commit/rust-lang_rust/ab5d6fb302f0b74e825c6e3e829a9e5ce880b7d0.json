{"sha": "ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNWQ2ZmIzMDJmMGI3NGU4MjVjNmUzZTgyOWE5ZTVjZTg4MGI3ZDA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-10T12:50:36Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: remove the closure from ppaux's p! macro (by making ? implicit).", "tree": {"sha": "fd026156e06150833d0ece61d5734cec5d38b31f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd026156e06150833d0ece61d5734cec5d38b31f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0", "html_url": "https://github.com/rust-lang/rust/commit/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37e918526a7107bc3c8de48f9a535b0100da40f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/37e918526a7107bc3c8de48f9a535b0100da40f5", "html_url": "https://github.com/rust-lang/rust/commit/37e918526a7107bc3c8de48f9a535b0100da40f5"}], "stats": {"total": 256, "additions": 122, "deletions": 134}, "files": [{"sha": "005dd18177d2380ea444a54ff7277817aa9b9122", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0", "patch": "@@ -611,12 +611,12 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n     ) -> Result<P::Path, P::Error> {\n         let mut empty = true;\n         let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n-            if empty {\n+            write!(cx.printer, \"{}\", if empty {\n                 empty = false;\n-                write!(cx.printer, \"{}\", start)\n+                start\n             } else {\n-                write!(cx.printer, \"{}\", cont)\n-            }\n+                cont\n+            })\n         };\n \n         let start = if ns == Namespace::ValueNS { \"::<\" } else { \"<\" };"}, {"sha": "55e0544d2bbe5cd21491e8585cb9e1a762c0e2b7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 118, "deletions": 130, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ab5d6fb302f0b74e825c6e3e829a9e5ce880b7d0", "patch": "@@ -196,9 +196,11 @@ macro_rules! gen_print_impl {\n             type Output = ();\n             type Error = fmt::Error;\n             fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, P>) -> fmt::Result {\n-                define_scoped_cx!($cx);\n-                if $cx.config.is_debug $dbg\n-                else $disp\n+                Ok({\n+                    define_scoped_cx!($cx);\n+                    if $cx.config.is_debug $dbg\n+                    else $disp\n+                })\n             }\n         }\n     };\n@@ -207,9 +209,11 @@ macro_rules! gen_print_impl {\n             type Output = ();\n             type Error = fmt::Error;\n             fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, P>) -> fmt::Result {\n-                define_scoped_cx!($cx);\n-                if $cx.config.is_debug $dbg\n-                else $disp\n+                Ok({\n+                    define_scoped_cx!($cx);\n+                    if $cx.config.is_debug $dbg\n+                    else $disp\n+                })\n             }\n         }\n     };\n@@ -238,7 +242,7 @@ macro_rules! define_print {\n     ( $generic:tt $target:ty,\n       ($self:ident, $cx:ident) { display $disp:block } ) => {\n         gen_print_impl! { $generic $target, ($self, $cx) yes $disp no {\n-            write!($cx.printer, \"{:?}\", $self)\n+            write!($cx.printer, \"{:?}\", $self)?\n         } }\n     };\n }\n@@ -257,10 +261,9 @@ macro_rules! print_inner {\n }\n macro_rules! p {\n     ($($kind:ident $data:tt),+) => {\n-        (|| -> fmt::Result {\n-            $(print_inner!($kind $data)?;)+\n-            Ok(())\n-        })()\n+        {\n+            $(print_inner!($kind $data)?);+\n+        }\n     };\n }\n macro_rules! define_scoped_cx {\n@@ -281,20 +284,20 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n     ) -> fmt::Result {\n         define_scoped_cx!(self);\n \n-        p!(write(\"(\"))?;\n+        p!(write(\"(\"));\n         let mut inputs = inputs.iter();\n         if let Some(&ty) = inputs.next() {\n-            p!(print_display(ty))?;\n+            p!(print_display(ty));\n             for &ty in inputs {\n-                p!(write(\", \"), print_display(ty))?;\n+                p!(write(\", \"), print_display(ty));\n             }\n             if c_variadic {\n-                p!(write(\", ...\"))?;\n+                p!(write(\", ...\"));\n             }\n         }\n-        p!(write(\")\"))?;\n+        p!(write(\")\"));\n         if !output.is_unit() {\n-            p!(write(\" -> \"), print_display(output))?;\n+            p!(write(\" -> \"), print_display(output));\n         }\n \n         Ok(())\n@@ -322,14 +325,12 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n \n         let mut empty = true;\n         let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n-            define_scoped_cx!(cx);\n-\n-            if empty {\n+            write!(cx.printer, \"{}\", if empty {\n                 empty = false;\n-                p!(write(\"{}\", start))\n+                start\n             } else {\n-                p!(write(\"{}\", cont))\n-            }\n+                cont\n+            })\n         };\n \n         // NOTE(eddyb) this must be below `start_or_continue`'s definition\n@@ -343,7 +344,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             let _ = start_or_continue(self, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {\n-                    let _ = p!(write(\"{}\", name));\n+                    let _ = write!(self.printer, \"{}\", name);\n                     br\n                 }\n                 ty::BrAnon(_) |\n@@ -356,7 +357,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n                             break name;\n                         }\n                     };\n-                    let _ = p!(write(\"{}\", name));\n+                    let _ = write!(self.printer, \"{}\", name);\n                     ty::BrNamed(self.tcx.hir().local_def_id(CRATE_NODE_ID), name)\n                 }\n             };\n@@ -453,7 +454,7 @@ define_print! {\n \n             for (_, def_id) in auto_traits {\n                 if !first {\n-                    p!(write(\" + \"))?;\n+                    p!(write(\" + \"));\n                 }\n                 first = false;\n \n@@ -464,8 +465,6 @@ define_print! {\n                     iter::empty(),\n                 )?;\n             }\n-\n-            Ok(())\n         }\n     }\n }\n@@ -528,7 +527,8 @@ impl fmt::Debug for ty::UpvarId {\n             p!(write(\"UpvarId({:?};`{}`;{:?})\",\n                 self.var_path.hir_id,\n                 cx.tcx.hir().name_by_hir_id(self.var_path.hir_id),\n-                self.closure_expr_id))\n+                self.closure_expr_id));\n+            Ok(())\n         })\n     }\n }\n@@ -543,12 +543,12 @@ impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n define_print! {\n     ('tcx) &'tcx ty::List<Ty<'tcx>>, (self, cx) {\n         display {\n-            p!(write(\"{{\"))?;\n+            p!(write(\"{{\"));\n             let mut tys = self.iter();\n             if let Some(&ty) = tys.next() {\n-                p!(print(ty))?;\n+                p!(print(ty));\n                 for &ty in tys {\n-                    p!(write(\", \"), print(ty))?;\n+                    p!(write(\", \"), print(ty));\n                 }\n             }\n             p!(write(\"}}\"))\n@@ -571,13 +571,12 @@ define_print! {\n         display {\n             let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n \n-            ty::Binder::bind(*self)\n+            p!(print_display(ty::Binder::bind(*self)\n                 .with_self_ty(cx.tcx, dummy_self)\n-                .skip_binder()\n-                .print_display(cx)\n+                .skip_binder()))\n         }\n         debug {\n-            self.print_display(cx)\n+            p!(print_display(self))\n         }\n     }\n }\n@@ -599,29 +598,28 @@ define_print! {\n \n             if let BrNamed(_, name) = *self {\n                 if name != \"\" && name != \"'_\" {\n-                    return p!(write(\"{}\", name));\n+                    p!(write(\"{}\", name));\n+                    return Ok(());\n                 }\n             }\n \n             let highlight = RegionHighlightMode::get();\n             if let Some((region, counter)) = highlight.highlight_bound_region {\n                 if *self == region {\n-                    return p!(write(\"'{}\", counter));\n+                    p!(write(\"'{}\", counter));\n                 }\n             }\n-\n-            Ok(())\n         }\n         debug {\n-            return match *self {\n+            match *self {\n                 BrAnon(n) => p!(write(\"BrAnon({:?})\", n)),\n                 BrFresh(n) => p!(write(\"BrFresh({:?})\", n)),\n                 BrNamed(did, name) => {\n                     p!(write(\"BrNamed({:?}:{:?}, {})\",\n                            did.krate, did.index, name))\n                 }\n                 BrEnv => p!(write(\"BrEnv\")),\n-            };\n+            }\n         }\n     }\n }\n@@ -661,10 +659,10 @@ define_print! {\n \n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.placeholder_highlight(*self) {\n-                return p!(write(\"'{}\", counter));\n+                p!(write(\"'{}\", counter));\n+            } else {\n+                p!(print_display(self.name));\n             }\n-\n-            p!(print_display(self.name))\n         }\n     }\n }\n@@ -696,7 +694,8 @@ define_print! {\n \n             // Watch out for region highlights.\n             if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n-                return p!(write(\"'{:?}\", n));\n+                p!(write(\"'{:?}\", n));\n+                return Ok(());\n             }\n \n             // These printouts are concise.  They do not contain all the information\n@@ -707,8 +706,6 @@ define_print! {\n                 ty::ReEarlyBound(ref data) => {\n                     if data.name != \"'_\" {\n                         p!(write(\"{}\", data.name))\n-                    } else {\n-                        Ok(())\n                     }\n                 }\n                 ty::ReLateBound(_, br) |\n@@ -742,7 +739,7 @@ define_print! {\n                     p!(print_display(region_vid))\n                 }\n                 ty::ReScope(_) |\n-                ty::ReErased => Ok(()),\n+                ty::ReErased => {}\n                 ty::ReStatic => p!(write(\"'static\")),\n                 ty::ReEmpty => p!(write(\"'<empty>\")),\n \n@@ -853,7 +850,7 @@ define_print! {\n                 ty::Contravariant => \"-\",\n                 ty::Invariant => \"o\",\n                 ty::Bivariant => \"*\",\n-            })\n+            })?\n         }\n     }\n }\n@@ -862,15 +859,15 @@ define_print! {\n     ('tcx) ty::FnSig<'tcx>, (self, cx) {\n         display {\n             if self.unsafety == hir::Unsafety::Unsafe {\n-                p!(write(\"unsafe \"))?;\n+                p!(write(\"unsafe \"));\n             }\n \n             if self.abi != Abi::Rust {\n-                p!(write(\"extern {} \", self.abi))?;\n+                p!(write(\"extern {} \", self.abi));\n             }\n \n-            p!(write(\"fn\"))?;\n-            cx.fn_sig(self.inputs(), self.c_variadic, self.output())\n+            p!(write(\"fn\"));\n+            cx.fn_sig(self.inputs(), self.c_variadic, self.output())?\n         }\n         debug {\n             p!(write(\"({:?}; c_variadic: {})->{:?}\",\n@@ -912,20 +909,18 @@ define_print! {\n \n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.region_highlighted(&ty::ReVar(*self)) {\n-                return p!(write(\"'{:?}\", counter));\n+                p!(write(\"'{:?}\", counter));\n             }\n-\n-            Ok(())\n         }\n         debug {\n             // HACK(eddyb) this is duplicated from `display` printing,\n             // to keep NLL borrowck working even with `-Zverbose`.\n             let highlight = RegionHighlightMode::get();\n             if let Some(counter) = highlight.region_highlighted(&ty::ReVar(*self)) {\n-                return p!(write(\"'{:?}\", counter));\n+                p!(write(\"'{:?}\", counter));\n+            } else {\n+                p!(write(\"'_#{}r\", self.index()));\n             }\n-\n-            p!(write(\"'_#{}r\", self.index()))\n         }\n     }\n }\n@@ -1016,7 +1011,7 @@ define_print_multi! {\n     ]\n     (self, cx) {\n         display {\n-            cx.in_binder(self)\n+            cx.in_binder(self)?\n         }\n     }\n }\n@@ -1030,11 +1025,9 @@ define_print! {\n                 Namespace::TypeNS,\n                 iter::empty(),\n             )?;\n-            Ok(())\n         }\n         debug {\n             let _ = cx.path_qualified(None, self.self_ty(), Some(*self), Namespace::TypeNS)?;\n-            Ok(())\n         }\n     }\n }\n@@ -1052,34 +1045,34 @@ define_print! {\n                     p!(write(\"*{} \", match tm.mutbl {\n                         hir::MutMutable => \"mut\",\n                         hir::MutImmutable => \"const\",\n-                    }))?;\n-                    tm.ty.print(cx)\n+                    }));\n+                    p!(print(tm.ty))\n                 }\n                 Ref(r, ty, mutbl) => {\n-                    p!(write(\"&\"))?;\n+                    p!(write(\"&\"));\n                     if r.display_outputs_anything(cx) {\n-                        p!(print_display(r), write(\" \"))?;\n+                        p!(print_display(r), write(\" \"));\n                     }\n-                    ty::TypeAndMut { ty, mutbl }.print(cx)\n+                    p!(print(ty::TypeAndMut { ty, mutbl }))\n                 }\n                 Never => p!(write(\"!\")),\n                 Tuple(ref tys) => {\n-                    p!(write(\"(\"))?;\n+                    p!(write(\"(\"));\n                     let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n-                        p!(print(ty), write(\",\"))?;\n+                        p!(print(ty), write(\",\"));\n                         if let Some(&ty) = tys.next() {\n-                            p!(write(\" \"), print(ty))?;\n+                            p!(write(\" \"), print(ty));\n                             for &ty in tys {\n-                                p!(write(\", \"), print(ty))?;\n+                                p!(write(\", \"), print(ty));\n                             }\n                         }\n                     }\n                     p!(write(\")\"))\n                 }\n                 FnDef(def_id, substs) => {\n                     let sig = cx.tcx.fn_sig(def_id).subst(cx.tcx, substs);\n-                    p!(print(sig), write(\" {{\"))?;\n+                    p!(print(sig), write(\" {{\"));\n                     let _ = cx.print_def_path(\n                         def_id,\n                         Some(substs),\n@@ -1089,7 +1082,7 @@ define_print! {\n                     p!(write(\"}}\"))\n                 }\n                 FnPtr(ref bare_fn) => {\n-                    bare_fn.print(cx)\n+                    p!(print(bare_fn))\n                 }\n                 Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n                 Error => p!(write(\"[type error]\")),\n@@ -1114,19 +1107,16 @@ define_print! {\n                         Namespace::TypeNS,\n                         iter::empty(),\n                     )?;\n-                    Ok(())\n                 }\n                 Dynamic(data, r) => {\n                     let print_r = r.display_outputs_anything(cx);\n                     if print_r {\n-                        p!(write(\"(\"))?;\n+                        p!(write(\"(\"));\n                     }\n-                    p!(write(\"dyn \"))?;\n-                    data.print(cx)?;\n+                    p!(write(\"dyn \"), print(data));\n                     if print_r {\n-                        p!(write(\" + \"), print_display(r), write(\")\"))?;\n+                        p!(write(\" + \"), print_display(r), write(\")\"));\n                     }\n-                    Ok(())\n                 }\n                 Foreign(def_id) => {\n                     let _ = cx.print_def_path(\n@@ -1135,11 +1125,10 @@ define_print! {\n                         Namespace::TypeNS,\n                         iter::empty(),\n                     )?;\n-                    Ok(())\n                 }\n-                Projection(ref data) => data.print(cx),\n+                Projection(ref data) => p!(print(data)),\n                 UnnormalizedProjection(ref data) => {\n-                    p!(write(\"Unnormalized(\"))?;\n+                    p!(write(\"Unnormalized(\"));\n                     data.print(cx)?;\n                     p!(write(\")\"))\n                 }\n@@ -1148,21 +1137,22 @@ define_print! {\n                 }\n                 Opaque(def_id, substs) => {\n                     if cx.config.is_verbose {\n-                        return p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n+                        p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n+                        return Ok(());\n                     }\n \n                     let def_key = cx.tcx.def_key(def_id);\n                     if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                        p!(write(\"{}\", name))?;\n+                        p!(write(\"{}\", name));\n                         let mut substs = substs.iter();\n                         // FIXME(eddyb) print this with `print_def_path`.\n                         if let Some(first) = substs.next() {\n-                            p!(write(\"::<\"))?;\n-                            p!(write(\"{}\", first))?;\n+                            p!(write(\"::<\"));\n+                            p!(write(\"{}\", first));\n                             for subst in substs {\n-                                p!(write(\", {}\", subst))?;\n+                                p!(write(\", {}\", subst));\n                             }\n-                            p!(write(\">\"))?;\n+                            p!(write(\">\"));\n                         }\n                         return Ok(());\n                     }\n@@ -1172,7 +1162,7 @@ define_print! {\n \n                     let mut first = true;\n                     let mut is_sized = false;\n-                    p!(write(\"impl\"))?;\n+                    p!(write(\"impl\"));\n                     for predicate in bounds.predicates {\n                         if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n                             // Don't print +Sized, but rather +?Sized if absent.\n@@ -1183,70 +1173,69 @@ define_print! {\n \n                             p!(\n                                     write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                    print(trait_ref))?;\n+                                    print(trait_ref));\n                             first = false;\n                         }\n                     }\n                     if !is_sized {\n-                        p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }))?;\n+                        p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n                     } else if first {\n-                        p!(write(\" Sized\"))?;\n+                        p!(write(\" Sized\"));\n                     }\n-                    Ok(())\n                 }\n                 Str => p!(write(\"str\")),\n                 Generator(did, substs, movability) => {\n                     let upvar_tys = substs.upvar_tys(did, cx.tcx);\n                     let witness = substs.witness(did, cx.tcx);\n                     if movability == hir::GeneratorMovability::Movable {\n-                        p!(write(\"[generator\"))?;\n+                        p!(write(\"[generator\"));\n                     } else {\n-                        p!(write(\"[static generator\"))?;\n+                        p!(write(\"[static generator\"));\n                     }\n \n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n-                        p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)))?;\n+                        p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)));\n                         let mut sep = \" \";\n                         cx.tcx.with_freevars(hir_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 p!(\n                                        write(\"{}{}:\",\n                                              sep,\n                                              cx.tcx.hir().name(freevar.var_id())),\n-                                       print(upvar_ty))?;\n+                                       print(upvar_ty));\n                                 sep = \", \";\n                             }\n                             Ok(())\n                         })?\n                     } else {\n                         // cross-crate closure types should only be\n                         // visible in codegen bug reports, I imagine.\n-                        p!(write(\"@{:?}\", did))?;\n+                        p!(write(\"@{:?}\", did));\n                         let mut sep = \" \";\n                         for (index, upvar_ty) in upvar_tys.enumerate() {\n                             p!(\n                                    write(\"{}{}:\", sep, index),\n-                                   print(upvar_ty))?;\n+                                   print(upvar_ty));\n                             sep = \", \";\n                         }\n                     }\n \n                     p!(write(\" \"), print(witness), write(\"]\"))\n                 },\n                 GeneratorWitness(types) => {\n-                    cx.in_binder(&types)\n+                    cx.in_binder(&types)?\n                 }\n                 Closure(did, substs) => {\n                     let upvar_tys = substs.upvar_tys(did, cx.tcx);\n-                    p!(write(\"[closure\"))?;\n+                    p!(write(\"[closure\"));\n \n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n                         if cx.tcx.sess.opts.debugging_opts.span_free_formats {\n-                            p!(write(\"@{:?}\", hir_id))?;\n+                            p!(write(\"@{:?}\", hir_id));\n                         } else {\n-                            p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)))?;\n+                            p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)));\n                         }\n                         let mut sep = \" \";\n                         cx.tcx.with_freevars(hir_id, |freevars| {\n@@ -1255,46 +1244,46 @@ define_print! {\n                                        write(\"{}{}:\",\n                                              sep,\n                                              cx.tcx.hir().name(freevar.var_id())),\n-                                       print(upvar_ty))?;\n+                                       print(upvar_ty));\n                                 sep = \", \";\n                             }\n                             Ok(())\n                         })?\n                     } else {\n                         // cross-crate closure types should only be\n                         // visible in codegen bug reports, I imagine.\n-                        p!(write(\"@{:?}\", did))?;\n+                        p!(write(\"@{:?}\", did));\n                         let mut sep = \" \";\n                         for (index, upvar_ty) in upvar_tys.enumerate() {\n                             p!(\n                                    write(\"{}{}:\", sep, index),\n-                                   print(upvar_ty))?;\n+                                   print(upvar_ty));\n                             sep = \", \";\n                         }\n                     }\n \n-                    if cx.is_verbose {\n+                    if cx.config.is_verbose {\n                         p!(write(\n                             \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n                             substs.closure_kind_ty(did, cx.tcx),\n                             substs.closure_sig_ty(did, cx.tcx)\n-                        ))?;\n+                        ));\n                     }\n \n                     p!(write(\"]\"))\n                 },\n                 Array(ty, sz) => {\n-                    p!(write(\"[\"), print(ty), write(\"; \"))?;\n+                    p!(write(\"[\"), print(ty), write(\"; \"));\n                     match sz {\n                         ty::LazyConst::Unevaluated(_def_id, _substs) => {\n-                            p!(write(\"_\"))?;\n+                            p!(write(\"_\"));\n                         }\n                         ty::LazyConst::Evaluated(c) => {\n                             match c.val {\n-                                ConstValue::Infer(..) => p!(write(\"_\"))?,\n+                                ConstValue::Infer(..) => p!(write(\"_\")),\n                                 ConstValue::Param(ParamConst { name, .. }) =>\n-                                    p!(write(\"{}\", name))?,\n-                                _ => p!(write(\"{}\", c.unwrap_usize(cx.tcx)))?,\n+                                    p!(write(\"{}\", name)),\n+                                _ => p!(write(\"{}\", c.unwrap_usize(cx.tcx))),\n                             }\n                         }\n                     }\n@@ -1306,7 +1295,7 @@ define_print! {\n             }\n         }\n         debug {\n-            self.print_display(cx)\n+            p!(print_display(self))\n         }\n     }\n }\n@@ -1423,7 +1412,6 @@ define_print! {\n                 Namespace::TypeNS,\n                 iter::empty(),\n             )?;\n-            Ok(())\n         }\n     }\n }\n@@ -1444,14 +1432,14 @@ define_print! {\n     ('tcx) ty::Predicate<'tcx>, (self, cx) {\n         display {\n             match *self {\n-                ty::Predicate::Trait(ref data) => data.print(cx),\n-                ty::Predicate::Subtype(ref predicate) => predicate.print(cx),\n-                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(cx),\n-                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(cx),\n-                ty::Predicate::Projection(ref predicate) => predicate.print(cx),\n+                ty::Predicate::Trait(ref data) => p!(print(data)),\n+                ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n+                ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n+                ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),\n+                ty::Predicate::Projection(ref predicate) => p!(print(predicate)),\n                 ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    p!(write(\"the trait `\"))?;\n+                    p!(write(\"the trait `\"));\n                     let _ = cx.print_def_path(\n                         trait_def_id,\n                         None,\n@@ -1461,7 +1449,7 @@ define_print! {\n                     p!(write(\"` is object-safe\"))\n                 }\n                 ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                    p!(write(\"the closure `\"))?;\n+                    p!(write(\"the closure `\"));\n                     let _ = cx.print_def_path(\n                         closure_def_id,\n                         None,\n@@ -1471,7 +1459,7 @@ define_print! {\n                     p!(write(\"` implements the trait `{}`\", kind))\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    p!(write(\"the constant `\"))?;\n+                    p!(write(\"the constant `\"));\n                     let _ = cx.print_def_path(\n                         def_id,\n                         Some(substs),\n@@ -1484,12 +1472,12 @@ define_print! {\n         }\n         debug {\n             match *self {\n-                ty::Predicate::Trait(ref a) => a.print(cx),\n-                ty::Predicate::Subtype(ref pair) => pair.print(cx),\n-                ty::Predicate::RegionOutlives(ref pair) => pair.print(cx),\n-                ty::Predicate::TypeOutlives(ref pair) => pair.print(cx),\n-                ty::Predicate::Projection(ref pair) => pair.print(cx),\n-                ty::Predicate::WellFormed(ty) => ty.print(cx),\n+                ty::Predicate::Trait(ref a) => p!(print(a)),\n+                ty::Predicate::Subtype(ref pair) => p!(print(pair)),\n+                ty::Predicate::RegionOutlives(ref pair) => p!(print(pair)),\n+                ty::Predicate::TypeOutlives(ref pair) => p!(print(pair)),\n+                ty::Predicate::Projection(ref pair) => p!(print(pair)),\n+                ty::Predicate::WellFormed(ty) => p!(print(ty)),\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n                     p!(write(\"ObjectSafe({:?})\", trait_def_id))\n                 }"}]}