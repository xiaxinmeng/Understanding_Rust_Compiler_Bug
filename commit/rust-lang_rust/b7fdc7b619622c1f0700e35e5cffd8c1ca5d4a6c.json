{"sha": "b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZmRjN2I2MTk2MjJjMWYwNzAwZTM1ZTVjZmZkOGMxY2E1ZDRhNmM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-23T02:07:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-06T18:55:50Z"}, "message": "ty: remove unnecessary `Predicate::walk_tys` and `collect_regions`.", "tree": {"sha": "64e6e27d5a8a545d62cbdbc1260967788b4ab03c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64e6e27d5a8a545d62cbdbc1260967788b4ab03c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "html_url": "https://github.com/rust-lang/rust/commit/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1", "html_url": "https://github.com/rust-lang/rust/commit/3410aeddbe63bc931b50210eb5c0c8c70ebd9aa1"}], "stats": {"total": 125, "additions": 22, "deletions": 103}, "files": [{"sha": "7b23460eb6e4c06e8797b817f26bce7d3b017b46", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "patch": "@@ -263,20 +263,6 @@ where\n // Region folder\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Collects the free and escaping regions in `value` into `region_set`. Returns\n-    /// whether any late-bound regions were skipped\n-    pub fn collect_regions<T>(self, value: &T, region_set: &mut FxHashSet<ty::Region<'tcx>>) -> bool\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut have_bound_regions = false;\n-        self.fold_regions(value, &mut have_bound_regions, |r, d| {\n-            region_set.insert(self.mk_region(r.shifted_out_to_binder(d)));\n-            r\n-        });\n-        have_bound_regions\n-    }\n-\n     /// Folds the escaping and free regions in `value` using `f`, and\n     /// sets `skipped_regions` to true if any late-bound region was found\n     /// and skipped."}, {"sha": "48bc90526af241ea20473e0203e845bac6681b80", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "patch": "@@ -1518,77 +1518,7 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n-// A custom iterator used by `Predicate::walk_tys`.\n-enum WalkTysIter<'tcx, I, J, K>\n-where\n-    I: Iterator<Item = Ty<'tcx>>,\n-    J: Iterator<Item = Ty<'tcx>>,\n-    K: Iterator<Item = Ty<'tcx>>,\n-{\n-    None,\n-    One(Ty<'tcx>),\n-    Two(Ty<'tcx>, Ty<'tcx>),\n-    Types(I),\n-    InputTypes(J),\n-    ProjectionTypes(K),\n-}\n-\n-impl<'tcx, I, J, K> Iterator for WalkTysIter<'tcx, I, J, K>\n-where\n-    I: Iterator<Item = Ty<'tcx>>,\n-    J: Iterator<Item = Ty<'tcx>>,\n-    K: Iterator<Item = Ty<'tcx>>,\n-{\n-    type Item = Ty<'tcx>;\n-\n-    fn next(&mut self) -> Option<Ty<'tcx>> {\n-        match *self {\n-            WalkTysIter::None => None,\n-            WalkTysIter::One(item) => {\n-                *self = WalkTysIter::None;\n-                Some(item)\n-            }\n-            WalkTysIter::Two(item1, item2) => {\n-                *self = WalkTysIter::One(item2);\n-                Some(item1)\n-            }\n-            WalkTysIter::Types(ref mut iter) => iter.next(),\n-            WalkTysIter::InputTypes(ref mut iter) => iter.next(),\n-            WalkTysIter::ProjectionTypes(ref mut iter) => iter.next(),\n-        }\n-    }\n-}\n-\n impl<'tcx> Predicate<'tcx> {\n-    /// Iterates over the types in this predicate. Note that in all\n-    /// cases this is skipping over a binder, so late-bound regions\n-    /// with depth 0 are bound by the predicate.\n-    pub fn walk_tys(&'a self) -> impl Iterator<Item = Ty<'tcx>> + 'a {\n-        match *self {\n-            ty::Predicate::Trait(ref data, _) => {\n-                WalkTysIter::InputTypes(data.skip_binder().input_types())\n-            }\n-            ty::Predicate::Subtype(binder) => {\n-                let SubtypePredicate { a, b, a_is_expected: _ } = binder.skip_binder();\n-                WalkTysIter::Two(a, b)\n-            }\n-            ty::Predicate::TypeOutlives(binder) => WalkTysIter::One(binder.skip_binder().0),\n-            ty::Predicate::RegionOutlives(..) => WalkTysIter::None,\n-            ty::Predicate::Projection(ref data) => {\n-                let inner = data.skip_binder();\n-                WalkTysIter::ProjectionTypes(\n-                    inner.projection_ty.substs.types().chain(Some(inner.ty)),\n-                )\n-            }\n-            ty::Predicate::WellFormed(data) => WalkTysIter::One(data),\n-            ty::Predicate::ObjectSafe(_trait_def_id) => WalkTysIter::None,\n-            ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) => {\n-                WalkTysIter::Types(closure_substs.types())\n-            }\n-            ty::Predicate::ConstEvaluatable(_, substs) => WalkTysIter::Types(substs.types()),\n-        }\n-    }\n-\n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n         match *self {\n             Predicate::Trait(ref t, _) => Some(t.to_poly_trait_ref()),"}, {"sha": "eb8aec708a63993bc284b491e0b43dda6fdee84f", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "patch": "@@ -315,25 +315,28 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        pred.walk_tys()\n-            .flat_map(|t| {\n-                let mut regions = FxHashSet::default();\n-                tcx.collect_regions(&t, &mut regions);\n-\n-                regions.into_iter().flat_map(|r| {\n-                    match r {\n-                        // We only care about late bound regions, as we need to add them\n-                        // to the 'for<>' section\n-                        &ty::ReLateBound(_, ty::BoundRegion::BrNamed(_, name)) => {\n-                            Some(GenericParamDef {\n-                                name: name.to_string(),\n-                                kind: GenericParamDefKind::Lifetime,\n-                            })\n-                        }\n-                        &ty::ReVar(_) | &ty::ReEarlyBound(_) | &ty::ReStatic => None,\n-                        _ => panic!(\"Unexpected region type {:?}\", r),\n-                    }\n-                })\n+        let regions = match pred {\n+            ty::Predicate::Trait(poly_trait_pred, _) => {\n+                tcx.collect_referenced_late_bound_regions(&poly_trait_pred)\n+            }\n+            ty::Predicate::Projection(poly_proj_pred) => {\n+                tcx.collect_referenced_late_bound_regions(&poly_proj_pred)\n+            }\n+            _ => return FxHashSet::default(),\n+        };\n+\n+        regions\n+            .into_iter()\n+            .filter_map(|br| {\n+                match br {\n+                    // We only care about named late bound regions, as we need to add them\n+                    // to the 'for<>' section\n+                    ty::BrNamed(_, name) => Some(GenericParamDef {\n+                        name: name.to_string(),\n+                        kind: GenericParamDefKind::Lifetime,\n+                    }),\n+                    _ => None,\n+                }\n             })\n             .collect()\n     }"}]}