{"sha": "e4ce6c7468631788868e6e20c941ed4c5cbcf220", "node_id": "C_kwDOAAsO6NoAKGU0Y2U2Yzc0Njg2MzE3ODg4NjhlNmUyMGM5NDFlZDRjNWNiY2YyMjA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-07T11:02:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-07T11:02:39Z"}, "message": "Merge #10698\n\n10698: implement multi-token mapping for ssr r=Veykril a=spookyvision\n\n\n\nCo-authored-by: Anatol Ulrich <anatol.ulrich@ferrous-systems.com>", "tree": {"sha": "3940dd2137ba0d73bc7619ef14cb8b0abd0f1499", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3940dd2137ba0d73bc7619ef14cb8b0abd0f1499"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4ce6c7468631788868e6e20c941ed4c5cbcf220", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhh7JPCRBK7hj4Ov3rIwAA178IAAK96EEGZxC8P4i6KqRpgh9o\nUpyCM3NR4Y2asP9z2yC+jrAnf4Dv1uQlUoibO0mqHJBgc0DGQEAV+cT7aNN19VrX\nI7rBAU6ufO2K69Gmi6cgfTfm1uyTtjBfO50ndl1a0gT5VIrhh7zWPW1TqePFd9kh\nxrJYWjFgPZpR662Yj80UnT8LavsrRg7jyrZsgEhE8zIkBvKxnTcQol9ZpciSbdjb\nnbjHNMuSdnLeWZMEfs/l3KgkmIwZp+5BKM8RngaRtP5NVK6hbsHO/kIkRQLIjszy\nuGSZVHfuoJPSb0dELUzi8u69fI+3us8jS2CqDEhhOcDw1kt8P4C//6q4mf3PJjU=\n=OY4K\n-----END PGP SIGNATURE-----\n", "payload": "tree 3940dd2137ba0d73bc7619ef14cb8b0abd0f1499\nparent eebac7beb1f4650ba5e40c64631a390d12ed9765\nparent 69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1636282959 +0000\ncommitter GitHub <noreply@github.com> 1636282959 +0000\n\nMerge #10698\n\n10698: implement multi-token mapping for ssr r=Veykril a=spookyvision\n\n\n\nCo-authored-by: Anatol Ulrich <anatol.ulrich@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ce6c7468631788868e6e20c941ed4c5cbcf220", "html_url": "https://github.com/rust-lang/rust/commit/e4ce6c7468631788868e6e20c941ed4c5cbcf220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4ce6c7468631788868e6e20c941ed4c5cbcf220/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eebac7beb1f4650ba5e40c64631a390d12ed9765", "url": "https://api.github.com/repos/rust-lang/rust/commits/eebac7beb1f4650ba5e40c64631a390d12ed9765", "html_url": "https://github.com/rust-lang/rust/commit/eebac7beb1f4650ba5e40c64631a390d12ed9765"}, {"sha": "69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89", "html_url": "https://github.com/rust-lang/rust/commit/69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "ffecffc46d6832414b5a0e89cf98bc23b5eb2e14", "filename": "crates/ide_ssr/src/search.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e4ce6c7468631788868e6e20c941ed4c5cbcf220/crates%2Fide_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4ce6c7468631788868e6e20c941ed4c5cbcf220/crates%2Fide_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fsearch.rs?ref=e4ce6c7468631788868e6e20c941ed4c5cbcf220", "patch": "@@ -58,7 +58,7 @@ impl<'db> MatchFinder<'db> {\n         if let Some(resolved_path) = pick_path_for_usages(pattern) {\n             let definition: Definition = resolved_path.resolution.clone().into();\n             for file_range in self.find_usages(usage_cache, definition).file_ranges() {\n-                if let Some(node_to_match) = self.find_node_to_match(resolved_path, file_range) {\n+                for node_to_match in self.find_nodes_to_match(resolved_path, file_range) {\n                     if !is_search_permitted_ancestors(&node_to_match) {\n                         cov_mark::hit!(use_declaration_with_braces);\n                         continue;\n@@ -69,36 +69,45 @@ impl<'db> MatchFinder<'db> {\n         }\n     }\n \n-    fn find_node_to_match(\n+    fn find_nodes_to_match(\n         &self,\n         resolved_path: &ResolvedPath,\n         file_range: FileRange,\n-    ) -> Option<SyntaxNode> {\n+    ) -> Vec<SyntaxNode> {\n         let file = self.sema.parse(file_range.file_id);\n         let depth = resolved_path.depth as usize;\n         let offset = file_range.range.start();\n-        if let Some(path) =\n-            self.sema.find_node_at_offset_with_descend::<ast::Path>(file.syntax(), offset)\n-        {\n-            self.sema.ancestors_with_macros(path.syntax().clone()).nth(depth)\n-        } else if let Some(path) =\n-            self.sema.find_node_at_offset_with_descend::<ast::MethodCallExpr>(file.syntax(), offset)\n-        {\n-            // If the pattern contained a path and we found a reference to that path that wasn't\n-            // itself a path, but was a method call, then we need to adjust how far up to try\n-            // matching by how deep the path was within a CallExpr. The structure would have been\n-            // CallExpr, PathExpr, Path - i.e. a depth offset of 2. We don't need to check if the\n-            // path was part of a CallExpr because if it wasn't then all that will happen is we'll\n-            // fail to match, which is the desired behavior.\n-            const PATH_DEPTH_IN_CALL_EXPR: usize = 2;\n-            if depth < PATH_DEPTH_IN_CALL_EXPR {\n-                return None;\n-            }\n-            self.sema\n-                .ancestors_with_macros(path.syntax().clone())\n-                .nth(depth - PATH_DEPTH_IN_CALL_EXPR)\n+\n+        let mut paths = self\n+            .sema\n+            .find_nodes_at_offset_with_descend::<ast::Path>(file.syntax(), offset)\n+            .peekable();\n+\n+        if paths.peek().is_some() {\n+            paths\n+                .filter_map(|path| {\n+                    self.sema.ancestors_with_macros(path.syntax().clone()).nth(depth)\n+                })\n+                .collect::<Vec<_>>()\n         } else {\n-            None\n+            self.sema\n+                .find_nodes_at_offset_with_descend::<ast::MethodCallExpr>(file.syntax(), offset)\n+                .filter_map(|path| {\n+                    // If the pattern contained a path and we found a reference to that path that wasn't\n+                    // itself a path, but was a method call, then we need to adjust how far up to try\n+                    // matching by how deep the path was within a CallExpr. The structure would have been\n+                    // CallExpr, PathExpr, Path - i.e. a depth offset of 2. We don't need to check if the\n+                    // path was part of a CallExpr because if it wasn't then all that will happen is we'll\n+                    // fail to match, which is the desired behavior.\n+                    const PATH_DEPTH_IN_CALL_EXPR: usize = 2;\n+                    if depth < PATH_DEPTH_IN_CALL_EXPR {\n+                        return None;\n+                    }\n+                    self.sema\n+                        .ancestors_with_macros(path.syntax().clone())\n+                        .nth(depth - PATH_DEPTH_IN_CALL_EXPR)\n+                })\n+                .collect::<Vec<_>>()\n         }\n     }\n "}]}