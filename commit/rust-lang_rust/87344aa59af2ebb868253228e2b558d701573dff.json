{"sha": "87344aa59af2ebb868253228e2b558d701573dff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MzQ0YWE1OWFmMmViYjg2ODI1MzIyOGUyYjU1OGQ3MDE1NzNkZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-10T10:52:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-10T10:52:07Z"}, "message": "Auto merge of #47574 - zilbuz:issue-14844, r=nikomatsakis\n\nShow the used type variable when issuing a \"can't use type parameters from outer function\" error message\n\nFix #14844\n\nr? @estebank", "tree": {"sha": "e64ad8739124433604b5a5106a5c8ef617447799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e64ad8739124433604b5a5106a5c8ef617447799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87344aa59af2ebb868253228e2b558d701573dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87344aa59af2ebb868253228e2b558d701573dff", "html_url": "https://github.com/rust-lang/rust/commit/87344aa59af2ebb868253228e2b558d701573dff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87344aa59af2ebb868253228e2b558d701573dff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "948e3a30e6ec8417bcfdb923cd414fdf8fc87795", "url": "https://api.github.com/repos/rust-lang/rust/commits/948e3a30e6ec8417bcfdb923cd414fdf8fc87795", "html_url": "https://github.com/rust-lang/rust/commit/948e3a30e6ec8417bcfdb923cd414fdf8fc87795"}, {"sha": "0e68bb97285a1ade22cf6e68103dc54fb75db43f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e68bb97285a1ade22cf6e68103dc54fb75db43f", "html_url": "https://github.com/rust-lang/rust/commit/0e68bb97285a1ade22cf6e68103dc54fb75db43f"}], "stats": {"total": 352, "additions": 309, "deletions": 43}, "files": [{"sha": "49611689fc4af5c8b883254cbe10909b9bd24bd0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -571,7 +571,8 @@ impl<'a> LoweringContext<'a> {\n                         def_node_id,\n                         DefPathData::LifetimeDef(name.as_str()),\n                         DefIndexAddressSpace::High,\n-                        Mark::root()\n+                        Mark::root(),\n+                        span\n                     );\n \n                     hir::GenericParam::Lifetime(hir::LifetimeDef {\n@@ -1003,7 +1004,8 @@ impl<'a> LoweringContext<'a> {\n                             def_node_id,\n                             DefPathData::ImplTrait,\n                             DefIndexAddressSpace::High,\n-                            Mark::root()\n+                            Mark::root(),\n+                            span\n                         );\n \n                         let hir_bounds = self.lower_bounds(bounds, itctx);\n@@ -1150,7 +1152,8 @@ impl<'a> LoweringContext<'a> {\n                         def_node_id,\n                         DefPathData::LifetimeDef(name.name().as_str()),\n                         DefIndexAddressSpace::High,\n-                        Mark::root()\n+                        Mark::root(),\n+                        lifetime.span\n                     );\n                     let def_lifetime = hir::Lifetime {\n                         id: def_node_id,"}, {"sha": "3619a7fb0c603288df6a75c2c5b4b8ce74f68a2f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -18,6 +18,7 @@ use syntax::visit;\n use syntax::symbol::keywords;\n use syntax::symbol::Symbol;\n use syntax::parse::token::{self, Token};\n+use syntax_pos::Span;\n \n use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n \n@@ -57,12 +58,13 @@ impl<'a> DefCollector<'a> {\n     fn create_def(&mut self,\n                   node_id: NodeId,\n                   data: DefPathData,\n-                  address_space: DefIndexAddressSpace)\n+                  address_space: DefIndexAddressSpace,\n+                  span: Span)\n                   -> DefIndex {\n         let parent_def = self.parent_def.unwrap();\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n         self.definitions\n-            .create_def_with_parent(parent_def, node_id, data, address_space, self.expansion)\n+            .create_def_with_parent(parent_def, node_id, data, address_space, self.expansion, span)\n     }\n \n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n@@ -83,7 +85,7 @@ impl<'a> DefCollector<'a> {\n             _ => {}\n         }\n \n-        self.create_def(expr.id, DefPathData::Initializer, REGULAR_SPACE);\n+        self.create_def(expr.id, DefPathData::Initializer, REGULAR_SPACE, expr.span);\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId, const_expr: bool) {\n@@ -122,7 +124,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 return visit::walk_item(self, i);\n             }\n         };\n-        let def = self.create_def(i.id, def_data, ITEM_LIKE_SPACE);\n+        let def = self.create_def(i.id, def_data, ITEM_LIKE_SPACE, i.span);\n \n         self.with_parent(def, |this| {\n             match i.node {\n@@ -131,14 +133,16 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n                                             DefPathData::EnumVariant(v.node.name.name.as_str()),\n-                                            REGULAR_SPACE);\n+                                            REGULAR_SPACE,\n+                                            v.span);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n                                 this.create_def(field.id,\n                                                 DefPathData::Field(name.as_str()),\n-                                                REGULAR_SPACE);\n+                                                REGULAR_SPACE,\n+                                                field.span);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -152,13 +156,17 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     if !struct_def.is_struct() {\n                         this.create_def(struct_def.id(),\n                                         DefPathData::StructCtor,\n-                                        REGULAR_SPACE);\n+                                        REGULAR_SPACE,\n+                                        i.span);\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name)\n                             .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                        this.create_def(field.id, DefPathData::Field(name.as_str()), REGULAR_SPACE);\n+                        this.create_def(field.id,\n+                                        DefPathData::Field(name.as_str()),\n+                                        REGULAR_SPACE,\n+                                        field.span);\n                     }\n                 }\n                 _ => {}\n@@ -168,14 +176,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_use_tree(&mut self, use_tree: &'a UseTree, id: NodeId, _nested: bool) {\n-        self.create_def(id, DefPathData::Misc, ITEM_LIKE_SPACE);\n+        self.create_def(id, DefPathData::Misc, ITEM_LIKE_SPACE, use_tree.span);\n         visit::walk_use_tree(self, use_tree, id);\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n                                   DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n-                                  REGULAR_SPACE);\n+                                  REGULAR_SPACE,\n+                                  foreign_item.span);\n \n         self.with_parent(def, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n@@ -188,14 +197,16 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 self.create_def(\n                     lifetime_def.lifetime.id,\n                     DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_str()),\n-                    REGULAR_SPACE\n+                    REGULAR_SPACE,\n+                    lifetime_def.lifetime.span\n                 );\n             }\n             GenericParam::Type(ref ty_param) => {\n                 self.create_def(\n                     ty_param.id,\n                     DefPathData::TypeParam(ty_param.ident.name.as_str()),\n-                    REGULAR_SPACE\n+                    REGULAR_SPACE,\n+                    ty_param.span\n                 );\n             }\n         }\n@@ -211,7 +222,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n-        let def = self.create_def(ti.id, def_data, ITEM_LIKE_SPACE);\n+        let def = self.create_def(ti.id, def_data, ITEM_LIKE_SPACE, ti.span);\n         self.with_parent(def, |this| {\n             if let TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n                 this.visit_const_expr(expr);\n@@ -229,7 +240,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n-        let def = self.create_def(ii.id, def_data, ITEM_LIKE_SPACE);\n+        let def = self.create_def(ii.id, def_data, ITEM_LIKE_SPACE, ii.span);\n         self.with_parent(def, |this| {\n             if let ImplItemKind::Const(_, ref expr) = ii.node {\n                 this.visit_const_expr(expr);\n@@ -255,7 +266,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ExprKind::Closure(..) => {\n                 let def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n-                                          REGULAR_SPACE);\n+                                          REGULAR_SPACE,\n+                                          expr.span);\n                 self.parent_def = Some(def);\n             }\n             _ => {}\n@@ -270,7 +282,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n             TyKind::Array(_, ref length) => self.visit_const_expr(length),\n             TyKind::ImplTrait(..) => {\n-                self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE);\n+                self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE, ty.span);\n             }\n             TyKind::Typeof(ref expr) => self.visit_const_expr(expr),\n             _ => {}"}, {"sha": "1a2840de447de75d3d157288c0074610294d7002", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -28,6 +28,7 @@ use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n+use syntax_pos::{Span, DUMMY_SP};\n use util::nodemap::NodeMap;\n \n /// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n@@ -159,6 +160,7 @@ pub struct Definitions {\n     macro_def_scopes: FxHashMap<Mark, DefId>,\n     expansions: FxHashMap<DefIndex, Mark>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n+    def_index_to_span: FxHashMap<DefIndex, Span>,\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -176,6 +178,7 @@ impl Clone for Definitions {\n             macro_def_scopes: self.macro_def_scopes.clone(),\n             expansions: self.expansions.clone(),\n             next_disambiguator: self.next_disambiguator.clone(),\n+            def_index_to_span: self.def_index_to_span.clone(),\n         }\n     }\n }\n@@ -410,6 +413,7 @@ impl Definitions {\n             macro_def_scopes: FxHashMap(),\n             expansions: FxHashMap(),\n             next_disambiguator: FxHashMap(),\n+            def_index_to_span: FxHashMap(),\n         }\n     }\n \n@@ -493,6 +497,22 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n+    /// Retrieve the span of the given `DefId` if `DefId` is in the local crate, the span exists and\n+    /// it's not DUMMY_SP\n+    #[inline]\n+    pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n+        if def_id.krate == LOCAL_CRATE {\n+            let span = self.def_index_to_span.get(&def_id.index).cloned().unwrap_or(DUMMY_SP);\n+            if span != DUMMY_SP {\n+                Some(span)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n@@ -530,7 +550,8 @@ impl Definitions {\n                                   node_id: ast::NodeId,\n                                   data: DefPathData,\n                                   address_space: DefIndexAddressSpace,\n-                                  expansion: Mark)\n+                                  expansion: Mark,\n+                                  span: Span)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n@@ -583,6 +604,11 @@ impl Definitions {\n             self.expansions.insert(index, expansion);\n         }\n \n+        // The span is added if it isn't DUMMY_SP\n+        if span != DUMMY_SP {\n+            self.def_index_to_span.insert(index, span);\n+        }\n+\n         index\n     }\n \n@@ -692,7 +718,8 @@ macro_rules! define_global_metadata_kind {\n                         ast::DUMMY_NODE_ID,\n                         DefPathData::GlobalMetaData(instance.name().as_str()),\n                         GLOBAL_MD_ADDRESS_SPACE,\n-                        Mark::root()\n+                        Mark::root(),\n+                        DUMMY_SP\n                     );\n \n                     // Make sure calling def_index does not crash."}, {"sha": "a6b776125ae97491b25cd7545750ef99a5f911b5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 122, "deletions": 6, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -41,7 +41,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n-use syntax::codemap::{dummy_spanned, respan};\n+use syntax::codemap::{dummy_spanned, respan, CodeMap};\n use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -123,7 +123,7 @@ impl Ord for BindingError {\n \n enum ResolutionError<'a> {\n     /// error E0401: can't use type parameters from outer function\n-    TypeParametersFromOuterFunction,\n+    TypeParametersFromOuterFunction(Def),\n     /// error E0403: the name is already used for a type parameter in this type parameter list\n     NameAlreadyUsedInTypeParameterList(Name, &'a Span),\n     /// error E0407: method is not a member of trait\n@@ -173,13 +173,49 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                    resolution_error: ResolutionError<'a>)\n                                    -> DiagnosticBuilder<'sess> {\n     match resolution_error {\n-        ResolutionError::TypeParametersFromOuterFunction => {\n+        ResolutionError::TypeParametersFromOuterFunction(outer_def) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0401,\n-                                           \"can't use type parameters from outer function; \\\n-                                           try using a local type parameter instead\");\n+                                           \"can't use type parameters from outer function\");\n             err.span_label(span, \"use of type variable from outer function\");\n+            match outer_def {\n+                Def::SelfTy(_, maybe_impl_defid) => {\n+                    if let Some(impl_span) = maybe_impl_defid.map_or(None,\n+                            |def_id| resolver.definitions.opt_span(def_id)) {\n+                        let cm = resolver.session.codemap();\n+                        err.span_label(reduce_impl_span_to_impl_keyword(cm, impl_span),\n+                                    \"`Self` type implicitely declared here, on the `impl`\");\n+                    }\n+                },\n+                Def::TyParam(typaram_defid) => {\n+                    if let Some(typaram_span) = resolver.definitions.opt_span(typaram_defid) {\n+                        err.span_label(typaram_span, \"type variable from outer function\");\n+                    }\n+                },\n+                Def::Mod(..) | Def::Struct(..) | Def::Union(..) | Def::Enum(..) | Def::Variant(..) |\n+                Def::Trait(..) | Def::TyAlias(..) | Def::TyForeign(..) | Def::TraitAlias(..) |\n+                Def::AssociatedTy(..) | Def::PrimTy(..) | Def::Fn(..) | Def::Const(..) |\n+                Def::Static(..) | Def::StructCtor(..) | Def::VariantCtor(..) | Def::Method(..) |\n+                Def::AssociatedConst(..) | Def::Local(..) | Def::Upvar(..) | Def::Label(..) |\n+                Def::Macro(..) | Def::GlobalAsm(..) | Def::Err =>\n+                    bug!(\"TypeParametersFromOuterFunction should only be used with Def::SelfTy or \\\n+                         Def::TyParam\")\n+            }\n+\n+            // Try to retrieve the span of the function signature and generate a new message with\n+            // a local type parameter\n+            let sugg_msg = \"try using a local type parameter instead\";\n+            if let Some((sugg_span, new_snippet)) = generate_local_type_param_snippet(\n+                                                        resolver.session.codemap(), span) {\n+                // Suggest the modification to the user\n+                err.span_suggestion(sugg_span,\n+                                    sugg_msg,\n+                                    new_snippet);\n+            } else {\n+                err.help(\"try using a local type parameter instead\");\n+            }\n+\n             err\n         }\n         ResolutionError::NameAlreadyUsedInTypeParameterList(name, first_use_span) => {\n@@ -358,6 +394,86 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n     }\n }\n \n+/// Adjust the impl span so that just the `impl` keyword is taken by removing\n+/// everything after `<` (`\"impl<T> Iterator for A<T> {}\" -> \"impl\"`) and\n+/// everything after the first whitespace (`\"impl Iterator for A\" -> \"impl\"`)\n+///\n+/// Attention: The method used is very fragile since it essentially duplicates the work of the\n+/// parser. If you need to use this function or something similar, please consider updating the\n+/// codemap functions and this function to something more robust.\n+fn reduce_impl_span_to_impl_keyword(cm: &CodeMap, impl_span: Span) -> Span {\n+    let impl_span = cm.span_until_char(impl_span, '<');\n+    let impl_span = cm.span_until_whitespace(impl_span);\n+    impl_span\n+}\n+\n+/// Take the span of a type parameter in a function signature and try to generate a span for the\n+/// function name (with generics) and a new snippet for this span with the pointed type parameter as\n+/// a new local type parameter.\n+///\n+/// For instance:\n+/// ```\n+/// // Given span\n+/// fn my_function(param: T)\n+///                       ^ Original span\n+///\n+/// // Result\n+/// fn my_function(param: T)\n+///    ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n+/// ```\n+///\n+/// Attention: The method used is very fragile since it essentially duplicates the work of the\n+/// parser. If you need to use this function or something similar, please consider updating the\n+/// codemap functions and this function to something more robust.\n+fn generate_local_type_param_snippet(cm: &CodeMap, span: Span) -> Option<(Span, String)> {\n+    // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n+    // signature\n+    let sugg_span = cm.span_extend_to_prev_str(span, \"fn\");\n+    if sugg_span != span {\n+        if let Ok(snippet) = cm.span_to_snippet(sugg_span) {\n+            use syntax::codemap::BytePos;\n+\n+            // Consume the function name\n+            let mut offset = 0;\n+            for c in snippet.chars().take_while(|c| c.is_ascii_alphanumeric() ||\n+                                                    *c == '_') {\n+                offset += c.len_utf8();\n+            }\n+\n+            // Consume the generics part of the function signature\n+            let mut bracket_counter = 0;\n+            let mut last_char = None;\n+            for c in snippet[offset..].chars() {\n+                match c {\n+                    '<' => bracket_counter += 1,\n+                    '>' => bracket_counter -= 1,\n+                    '(' => if bracket_counter == 0 { break; }\n+                    _ => {}\n+                }\n+                offset += c.len_utf8();\n+                last_char = Some(c);\n+            }\n+\n+            // Adjust the suggestion span to encompass the function name with its generics\n+            let sugg_span = sugg_span.with_hi(BytePos(sugg_span.lo().0 + offset as u32));\n+\n+            // Prepare the new suggested snippet to append the type parameter that triggered\n+            // the error in the generics of the function signature\n+            let mut new_snippet = if last_char == Some('>') {\n+                format!(\"{}, \", &snippet[..(offset - '>'.len_utf8())])\n+            } else {\n+                format!(\"{}<\", &snippet[..offset])\n+            };\n+            new_snippet.push_str(&cm.span_to_snippet(span).unwrap_or(\"T\".to_string()));\n+            new_snippet.push('>');\n+\n+            return Some((sugg_span, new_snippet));\n+        }\n+    }\n+\n+    None\n+}\n+\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,\n@@ -3280,7 +3396,7 @@ impl<'a> Resolver<'a> {\n                             // its scope.\n                             if record_used {\n                                 resolve_error(self, span,\n-                                              ResolutionError::TypeParametersFromOuterFunction);\n+                                    ResolutionError::TypeParametersFromOuterFunction(def));\n                             }\n                             return Def::Err;\n                         }"}, {"sha": "c340f1b8c8ab328315409ce002537c2a9788571d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -533,7 +533,12 @@ impl CodeMap {\n         Ok(FileLines {file: lo.file, lines: lines})\n     }\n \n-    pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+    /// Extract the source surrounding the given `Span` using the `extract_source` function. The\n+    /// extract function takes three arguments: a string slice containing the source, an index in\n+    /// the slice for the beginning of the span and an index in the slice for the end of the span.\n+    fn span_to_source<F>(&self, sp: Span, extract_source: F) -> Result<String, SpanSnippetError>\n+        where F: Fn(&str, usize, usize) -> String\n+    {\n         if sp.lo() > sp.hi() {\n             return Err(SpanSnippetError::IllFormedSpan(sp));\n         }\n@@ -567,9 +572,9 @@ impl CodeMap {\n             }\n \n             if let Some(ref src) = local_begin.fm.src {\n-                return Ok((&src[start_index..end_index]).to_string());\n+                return Ok(extract_source(src, start_index, end_index));\n             } else if let Some(src) = local_begin.fm.external_src.borrow().get_source() {\n-                return Ok((&src[start_index..end_index]).to_string());\n+                return Ok(extract_source(src, start_index, end_index));\n             } else {\n                 return Err(SpanSnippetError::SourceNotAvailable {\n                     filename: local_begin.fm.name.clone()\n@@ -578,6 +583,17 @@ impl CodeMap {\n         }\n     }\n \n+    /// Return the source snippet as `String` corresponding to the given `Span`\n+    pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+        self.span_to_source(sp, |src, start_index, end_index| src[start_index..end_index]\n+                                                                .to_string())\n+    }\n+\n+    /// Return the source snippet as `String` before the given `Span`\n+    pub fn span_to_prev_source(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+        self.span_to_source(sp, |src, start_index, _| src[..start_index].to_string())\n+    }\n+\n     /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n     pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n         match self.span_to_snippet(sp) {\n@@ -593,6 +609,32 @@ impl CodeMap {\n         }\n     }\n \n+    /// Extend the given `Span` to just after the previous occurrence of `c`. Return the same span\n+    /// if no character could be found or if an error occurred while retrieving the code snippet.\n+    pub fn span_extend_to_prev_char(&self, sp: Span, c: char) -> Span {\n+        if let Ok(prev_source) = self.span_to_prev_source(sp) {\n+            let prev_source = prev_source.rsplit(c).nth(0).unwrap_or(\"\").trim_left();\n+            if !prev_source.is_empty() && !prev_source.contains('\\n') {\n+                return sp.with_lo(BytePos(sp.lo().0 - prev_source.len() as u32));\n+            }\n+        }\n+\n+        sp\n+    }\n+\n+    /// Extend the given `Span` to just after the previous occurrence of `pat`. Return the same span\n+    /// if no character could be found or if an error occurred while retrieving the code snippet.\n+    pub fn span_extend_to_prev_str(&self, sp: Span, pat: &str) -> Span {\n+        if let Ok(prev_source) = self.span_to_prev_source(sp) {\n+            let prev_source = prev_source.rsplit(pat).nth(0).unwrap_or(\"\").trim_left();\n+            if !prev_source.is_empty() && !prev_source.contains('\\n') {\n+                return sp.with_lo(BytePos(sp.lo().0 - prev_source.len() as u32));\n+            }\n+        }\n+\n+        sp\n+    }\n+\n     /// Given a `Span`, get a new `Span` covering the first token and all its trailing whitespace or\n     /// the original `Span`.\n     ///\n@@ -615,6 +657,24 @@ impl CodeMap {\n         sp\n     }\n \n+    /// Given a `Span`, get a new `Span` covering the first token without its trailing whitespace or\n+    /// the original `Span` in case of error.\n+    ///\n+    /// If `sp` points to `\"let mut x\"`, then a span pointing at `\"let\"` will be returned.\n+    pub fn span_until_whitespace(&self, sp: Span) -> Span {\n+        if let Ok(snippet) = self.span_to_snippet(sp) {\n+            let mut offset = 0;\n+            // Get the bytes width of all the non-whitespace characters\n+            for c in snippet.chars().take_while(|c| !c.is_whitespace()) {\n+                offset += c.len_utf8();\n+            }\n+            if offset > 1 {\n+                return sp.with_hi(BytePos(sp.lo().0 + offset as u32));\n+            }\n+        }\n+        sp\n+    }\n+\n     /// Given a `Span`, try to get a shorter span ending just after the first occurrence of `char`\n     /// `c`.\n     pub fn span_through_char(&self, sp: Span, c: char) -> Span {"}, {"sha": "4d763017c0f8b4a9c6ec28320322a5ecc97e5722", "filename": "src/test/compile-fail/inner-static-type-parameter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -14,7 +14,7 @@ enum Bar<T> { What } //~ ERROR parameter `T` is never used\n \n fn foo<T>() {\n     static a: Bar<T> = Bar::What;\n-//~^ ERROR can't use type parameters from outer function; try using a local type parameter instead\n+//~^ ERROR can't use type parameters from outer function\n }\n \n fn main() {"}, {"sha": "55975cc8e8645b712a93b1bd115790004d3740e9", "filename": "src/test/compile-fail/issue-3021-c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Fissue-3021-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Fissue-3021-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-c.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -11,8 +11,8 @@\n fn siphash<T>() {\n \n     trait t {\n-        fn g(&self, x: T) -> T;  //~ ERROR can't use type parameters from outer function; try using\n-        //~^ ERROR can't use type parameters from outer function; try using\n+        fn g(&self, x: T) -> T;  //~ ERROR can't use type parameters from outer function\n+        //~^ ERROR can't use type parameters from outer function\n     }\n }\n "}, {"sha": "9a769c39eca12743d38a462ef2413ede20193423", "filename": "src/test/compile-fail/issue-3214.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -10,7 +10,7 @@\n \n fn foo<T>() {\n     struct foo {\n-        x: T, //~ ERROR can't use type parameters from outer function;\n+        x: T, //~ ERROR can't use type parameters from outer function\n     }\n \n     impl<T> Drop for foo<T> {"}, {"sha": "af9e66b770bba6e3956bcf5020802523548505cc", "filename": "src/test/compile-fail/issue-5997-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Fissue-5997-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Fissue-5997-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5997-struct.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn f<T>() -> bool {\n-    struct S(T); //~ ERROR can't use type parameters from outer function; try using\n+    struct S(T); //~ ERROR can't use type parameters from outer function\n \n     true\n }"}, {"sha": "aac37289bb74952ddce176abc833629fdab68a0b", "filename": "src/test/compile-fail/nested-ty-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:can't use type parameters from outer function; try using\n+// error-pattern:can't use type parameters from outer function\n fn hd<U>(v: Vec<U> ) -> U {\n     fn hd1(w: [U]) -> U { return w[0]; }\n "}, {"sha": "04cd961e97ff76806659bedd7d398c98f789ea60", "filename": "src/test/compile-fail/type-arg-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:can't use type parameters from outer function; try using\n+// error-pattern:can't use type parameters from outer function\n fn foo<T>(x: T) {\n     fn bar(f: Box<FnMut(T) -> T>) { }\n }"}, {"sha": "15b946625778c02a88d457ec0d94832f95b41c68", "filename": "src/test/ui/error-codes/E0401.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -8,11 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+trait Baz<T> {}\n+\n fn foo<T>(x: T) {\n-    fn bar(y: T) { //~ ERROR E0401\n+    fn bar<U, V: Baz<U>, W: Fn()>(y: T) { //~ ERROR E0401\n+    }\n+    fn baz<U,\n+           V: Baz<U>,\n+           W: Fn()>\n+           (y: T) { //~ ERROR E0401\n     }\n     bar(x);\n }\n \n+\n+struct A<T> {\n+    inner: T,\n+}\n+\n+impl<T> Iterator for A<T> {\n+    type Item = u8;\n+    fn next(&mut self) -> Option<u8> {\n+        fn helper(sel: &Self) -> u8 { //~ ERROR E0401\n+            unimplemented!();\n+        }\n+        Some(helper(self))\n+    }\n+}\n+\n fn main() {\n }"}, {"sha": "c306ff4a04f6a92f1d887026c08e4f1722fc5d54", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87344aa59af2ebb868253228e2b558d701573dff/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=87344aa59af2ebb868253228e2b558d701573dff", "patch": "@@ -1,9 +1,35 @@\n-error[E0401]: can't use type parameters from outer function; try using a local type parameter instead\n-  --> $DIR/E0401.rs:12:15\n+error[E0401]: can't use type parameters from outer function\n+  --> $DIR/E0401.rs:14:38\n    |\n-LL |     fn bar(y: T) { //~ ERROR E0401\n-   |               ^ use of type variable from outer function\n+LL | fn foo<T>(x: T) {\n+   |        - type variable from outer function\n+LL |     fn bar<U, V: Baz<U>, W: Fn()>(y: T) { //~ ERROR E0401\n+   |        --------------------------    ^ use of type variable from outer function\n+   |        |\n+   |        help: try using a local type parameter instead: `bar<U, V: Baz<U>, W: Fn(), T>`\n \n-error: aborting due to previous error\n+error[E0401]: can't use type parameters from outer function\n+  --> $DIR/E0401.rs:19:16\n+   |\n+LL | fn foo<T>(x: T) {\n+   |        - type variable from outer function\n+...\n+LL |            (y: T) { //~ ERROR E0401\n+   |                ^ use of type variable from outer function\n+   |\n+   = help: try using a local type parameter instead\n+\n+error[E0401]: can't use type parameters from outer function\n+  --> $DIR/E0401.rs:32:25\n+   |\n+LL | impl<T> Iterator for A<T> {\n+   | ---- `Self` type implicitely declared here, on the `impl`\n+...\n+LL |         fn helper(sel: &Self) -> u8 { //~ ERROR E0401\n+   |            ------       ^^^^ use of type variable from outer function\n+   |            |\n+   |            help: try using a local type parameter instead: `helper<Self>`\n+\n+error: aborting due to 3 previous errors\n \n If you want more information on this error, try using \"rustc --explain E0401\""}]}