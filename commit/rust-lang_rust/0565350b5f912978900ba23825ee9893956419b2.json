{"sha": "0565350b5f912978900ba23825ee9893956419b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NjUzNTBiNWY5MTI5Nzg5MDBiYTIzODI1ZWU5ODkzOTU2NDE5YjI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-10T23:05:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-10T23:05:19Z"}, "message": "Typecheck vec and index exprs.", "tree": {"sha": "48f1ef8166c891e100e86d065c23fdb0c1a04077", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48f1ef8166c891e100e86d065c23fdb0c1a04077"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0565350b5f912978900ba23825ee9893956419b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0565350b5f912978900ba23825ee9893956419b2", "html_url": "https://github.com/rust-lang/rust/commit/0565350b5f912978900ba23825ee9893956419b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0565350b5f912978900ba23825ee9893956419b2/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaa76bd83fd26b4bb12fa79a407bb15f533d7dae", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaa76bd83fd26b4bb12fa79a407bb15f533d7dae", "html_url": "https://github.com/rust-lang/rust/commit/eaa76bd83fd26b4bb12fa79a407bb15f533d7dae"}], "stats": {"total": 94, "additions": 94, "deletions": 0}, "files": [{"sha": "0380437f7815cd1021b05474a2e0a6cd23c02839", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0565350b5f912978900ba23825ee9893956419b2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0565350b5f912978900ba23825ee9893956419b2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0565350b5f912978900ba23825ee9893956419b2", "patch": "@@ -654,6 +654,31 @@ fn type_is_scalar(@ty t) -> bool {\n     fail;\n }\n \n+\n+fn type_is_integral(@ty t) -> bool {\n+    alt (t.struct) {\n+        case (ty_int) { ret true; }\n+        case (ty_uint) { ret true; }\n+        case (ty_machine(?m)) {\n+            alt (m) {\n+                case (common.ty_i8) { ret true; }\n+                case (common.ty_i16) { ret true; }\n+                case (common.ty_i32) { ret true; }\n+                case (common.ty_i64) { ret true; }\n+\n+                case (common.ty_u8) { ret true; }\n+                case (common.ty_u16) { ret true; }\n+                case (common.ty_u32) { ret true; }\n+                case (common.ty_u64) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_char) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n fn type_is_fp(@ty t) -> bool {\n     alt (t.struct) {\n         case (ty_machine(?tm)) {\n@@ -1510,6 +1535,31 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                       ast.ann_type(t_1)));\n         }\n \n+        case (ast.expr_vec(?args, _)) {\n+            let vec[@ast.expr] args_1 = vec();\n+\n+            // FIXME: implement mutable vectors with leading 'mutable' flag\n+            // marking the elements as mutable.\n+\n+            let @ty t;\n+            if (_vec.len[@ast.expr](args) == 0u) {\n+                t = next_ty_var(fcx);\n+            } else {\n+                auto expr_1 = check_expr(fcx, args.(0));\n+                t = expr_ty(expr_1);\n+            }\n+\n+            for (@ast.expr e in args) {\n+                auto expr_1 = check_expr(fcx, e);\n+                auto expr_t = expr_ty(expr_1);\n+                demand(fcx, expr.span, t, expr_t);\n+                append[@ast.expr](args_1,expr_1);\n+            }\n+            auto ann = ast.ann_type(plain_ty(ty_vec(t)));\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_vec(args_1, ann));\n+        }\n+\n         case (ast.expr_tup(?elts, _)) {\n             let vec[ast.elt] elts_1 = vec();\n             let vec[@ty] elts_t = vec();\n@@ -1588,6 +1638,50 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n         }\n \n+        case (ast.expr_index(?base, ?idx, _)) {\n+            auto base_1 = check_expr(fcx, base);\n+            auto base_t = expr_ty(base_1);\n+\n+            auto idx_1 = check_expr(fcx, idx);\n+            auto idx_t = expr_ty(idx_1);\n+\n+            alt (base_t.struct) {\n+                case (ty_vec(?t)) {\n+                    if (! type_is_integral(idx_t)) {\n+                        fcx.ccx.sess.span_err\n+                            (idx.span,\n+                             \"non-integral type of vec index: \"\n+                             + ty_to_str(idx_t));\n+                    }\n+                    auto ann = ast.ann_type(t);\n+                    ret @fold.respan[ast.expr_](expr.span,\n+                                                ast.expr_index(base_1,\n+                                                               idx_1,\n+                                                               ann));\n+                }\n+                case (ty_str) {\n+                    if (! type_is_integral(idx_t)) {\n+                        fcx.ccx.sess.span_err\n+                            (idx.span,\n+                             \"non-integral type of str index: \"\n+                             + ty_to_str(idx_t));\n+                    }\n+                    auto t = ty_machine(common.ty_u8);\n+                    auto ann = ast.ann_type(plain_ty(t));\n+                    ret @fold.respan[ast.expr_](expr.span,\n+                                                ast.expr_index(base_1,\n+                                                               idx_1,\n+                                                               ann));\n+                }\n+                case (_) {\n+                    fcx.ccx.sess.span_err\n+                        (expr.span,\n+                         \"vector-indexing bad type: \"\n+                         + ty_to_str(base_t));\n+                }\n+            }\n+        }\n+\n         case (_) {\n             fcx.ccx.sess.unimpl(\"expr type in typeck.check_expr\");\n             // TODO"}]}