{"sha": "385c39a77b238df9371ee8bccc768b8d39258edd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NWMzOWE3N2IyMzhkZjkzNzFlZThiY2NjNzY4YjhkMzkyNThlZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-14T05:36:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-14T05:36:25Z"}, "message": "auto merge of #16332 : brson/rust/slicestab, r=aturon\n\nThis implements some of the recommendations from https://github.com/rust-lang/meeting-minutes/blob/master/Meeting-API-review-2014-08-06.md.\r\n\r\nExplanation in commits.", "tree": {"sha": "4d10ee4e9842587cccecdf5a4bf96ef13347362a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d10ee4e9842587cccecdf5a4bf96ef13347362a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/385c39a77b238df9371ee8bccc768b8d39258edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/385c39a77b238df9371ee8bccc768b8d39258edd", "html_url": "https://github.com/rust-lang/rust/commit/385c39a77b238df9371ee8bccc768b8d39258edd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/385c39a77b238df9371ee8bccc768b8d39258edd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d45d63d0d18f21f74c8a2a4e5367a785932f64e", "html_url": "https://github.com/rust-lang/rust/commit/9d45d63d0d18f21f74c8a2a4e5367a785932f64e"}, {"sha": "fce442e75c5b3df8eea401fae1200314f0d47c40", "url": "https://api.github.com/repos/rust-lang/rust/commits/fce442e75c5b3df8eea401fae1200314f0d47c40", "html_url": "https://github.com/rust-lang/rust/commit/fce442e75c5b3df8eea401fae1200314f0d47c40"}], "stats": {"total": 660, "additions": 450, "deletions": 210}, "files": [{"sha": "f6cd217b580cd24be78747dc23cca861906771ef", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -233,7 +233,7 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, \"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs: Vec<String> = nv.as_slice()\n-                                      .splitn('=', 1)\n+                                      .splitn(1, '=')\n                                       .map(|s| s.to_string())\n                                       .collect();\n "}, {"sha": "7663cd1e3466abb3d0bfb1ff5d67d455e8aa86f7", "filename": "src/etc/unicode.py", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -293,13 +293,12 @@ def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableVector;\n-    use core::option::None;\n-    r.bsearch(|&(lo,hi)| {\n+    use core::slice::ImmutableSlice;\n+    r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n         else { Greater }\n-    }) != None\n+    }).found().is_some()\n }\\n\n \"\"\")\n \n@@ -352,9 +351,10 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableVector;\n+    use core::slice::ImmutableSlice;\n     use core::tuple::Tuple2;\n     use core::option::{Option, Some, None};\n+    use core::slice;\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n@@ -371,11 +371,14 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     }\n \n     fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n-        table.bsearch(|&(key, _)| {\n+        match table.binary_search(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n             else { Greater }\n-        })\n+        }) {\n+            slice::Found(i) => Some(i),\n+            slice::NotFound(_) => None,\n+        }\n     }\n \n \"\"\")\n@@ -387,8 +390,8 @@ def emit_conversions_module(f, lowerupper, upperlower):\n \n def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n     f.write(\"\"\"pub mod grapheme {\n-    use core::option::{Some, None};\n-    use core::slice::ImmutableVector;\n+    use core::slice::ImmutableSlice;\n+    use core::slice;\n \n     #[allow(non_camel_case_types)]\n     #[deriving(Clone)]\n@@ -400,16 +403,16 @@ def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _)| {\n+        match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, cat) = r[idx];\n                 cat\n             }\n-            None => GC_Any\n+            slice::NotFound(_) => GC_Any\n         }\n     }\n \n@@ -427,20 +430,21 @@ def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n def emit_charwidth_module(f, width_table):\n     f.write(\"pub mod charwidth {\\n\")\n     f.write(\"    use core::option::{Option, Some, None};\\n\")\n-    f.write(\"    use core::slice::ImmutableVector;\\n\")\n+    f.write(\"    use core::slice::ImmutableSlice;\\n\")\n+    f.write(\"    use core::slice;\\n\")\n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n         use core::cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _, _)| {\n+        match r.binary_search(|&(lo, hi, _, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, r_ncjk, r_cjk) = r[idx];\n                 if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            None => 1\n+            slice::NotFound(_) => 1\n         }\n     }\n \"\"\")\n@@ -525,19 +529,19 @@ def comp_pfun(char):\n \n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use core::option::{Some, None};\n         use core::cmp::{Equal, Less, Greater};\n-        use core::slice::ImmutableVector;\n-        match r.bsearch(|&(lo, hi, _)| {\n+        use core::slice::ImmutableSlice;\n+        use core::slice;\n+        match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, result) = r[idx];\n                 result\n             }\n-            None => 0\n+            slice::NotFound(_) => 0\n         }\n     }\\n\n \"\"\")"}, {"sha": "dd07e718af418f05f55da322eb84d2635d8c1473", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -296,7 +296,7 @@ mod tests {\n     use std::prelude::*;\n     use std::mem;\n \n-    use slice::ImmutableVector;\n+    use slice::ImmutableSlice;\n     use super::{Hash, Hasher, Writer};\n \n     struct MyWriterHasher;"}, {"sha": "b31d811c2c966596aac6c572cc44f458836602c0", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -275,7 +275,7 @@ mod tests {\n \n     use str::Str;\n     use string::String;\n-    use slice::{Vector, ImmutableVector};\n+    use slice::{Slice, ImmutableSlice};\n     use vec::Vec;\n \n     use super::super::{Hash, Writer};"}, {"sha": "354beb56d2dc3cbcf8386a2bdaf8d258e92f9418", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -362,6 +362,7 @@ pub struct MutItems<'a, T> {\n \n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n+    #[allow(deprecated)] // mut_shift_ref\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;\n@@ -384,6 +385,7 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n \n impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n+    #[allow(deprecated)] // mut_shift_ref\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;"}, {"sha": "aac5b24fa6f02e4bbba57ac5f3ab60af2ad65a1d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -45,8 +45,8 @@ represents iteration over a slice.\n ## Traits\n \n A number of traits add methods that allow you to accomplish tasks with slices.\n-These traits include `ImmutableVector`, which is defined for `&[T]` types,\n-and `MutableVector`, defined for `&mut [T]` types.\n+These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n+and `MutableSlice`, defined for `&mut [T]` types.\n \n An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n a `Vec` or another slice from the index interval `[a, b)`:\n@@ -98,10 +98,11 @@ use {Collection, MutableSeq};\n use vec::Vec;\n \n pub use core::slice::{ref_slice, mut_ref_slice, Splits, Windows};\n-pub use core::slice::{Chunks, Vector, ImmutableVector, ImmutableEqVector};\n-pub use core::slice::{ImmutableOrdVector, MutableVector, Items, MutItems};\n+pub use core::slice::{Chunks, Slice, ImmutableSlice, ImmutablePartialEqSlice};\n+pub use core::slice::{ImmutableOrdSlice, MutableSlice, Items, MutItems};\n pub use core::slice::{MutSplits, MutChunks};\n-pub use core::slice::{bytes, MutableCloneableVector};\n+pub use core::slice::{bytes, MutableCloneableSlice};\n+pub use core::slice::{BinarySearchResult, Found, NotFound};\n \n // Functional utilities\n \n@@ -116,7 +117,7 @@ pub trait VectorVector<T> {\n     fn connect_vec(&self, sep: &T) -> Vec<T>;\n }\n \n-impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n+impl<'a, T: Clone, V: Slice<T>> VectorVector<T> for &'a [V] {\n     fn concat_vec(&self) -> Vec<T> {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size);\n@@ -558,7 +559,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n \n /// Extension methods for vectors such that their elements are\n /// mutable.\n-pub trait MutableVectorAllocating<'a, T> {\n+pub trait MutableSliceAllocating<'a, T> {\n     /// Sort the vector, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -604,7 +605,7 @@ pub trait MutableVectorAllocating<'a, T> {\n     fn move_from(self, src: Vec<T>, start: uint, end: uint) -> uint;\n }\n \n-impl<'a,T> MutableVectorAllocating<'a, T> for &'a mut [T] {\n+impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n     #[inline]\n     fn sort_by(self, compare: |&T, &T| -> Ordering) {\n         merge_sort(self, compare)\n@@ -621,7 +622,7 @@ impl<'a,T> MutableVectorAllocating<'a, T> for &'a mut [T] {\n \n /// Methods for mutable vectors with orderable elements, such as\n /// in-place sorting.\n-pub trait MutableOrdVector<T> {\n+pub trait MutableOrdSlice<T> {\n     /// Sort the vector, in place.\n     ///\n     /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n@@ -667,7 +668,7 @@ pub trait MutableOrdVector<T> {\n     fn prev_permutation(self) -> bool;\n }\n \n-impl<'a, T: Ord> MutableOrdVector<T> for &'a mut [T] {\n+impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n     #[inline]\n     fn sort(self) {\n         self.sort_by(|a,b| a.cmp(b))"}, {"sha": "60ee8cc04f74c667e4f05a9479f91915f581930b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -894,7 +894,7 @@ mod tests {\n     use {Collection, MutableSeq};\n \n     use super::*;\n-    use std::slice::{Vector, ImmutableVector};\n+    use std::slice::{Slice, ImmutableSlice};\n     use string::String;\n     use vec::Vec;\n \n@@ -1812,38 +1812,38 @@ mod tests {\n     fn test_splitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: Vec<&str> = data.splitn(' ', 3).collect();\n+        let split: Vec<&str> = data.splitn(3, ' ').collect();\n         assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: Vec<&str> = data.splitn(|c: char| c == ' ', 3).collect();\n+        let split: Vec<&str> = data.splitn(3, |c: char| c == ' ').collect();\n         assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let split: Vec<&str> = data.splitn('\u00e4', 3).collect();\n+        let split: Vec<&str> = data.splitn(3, '\u00e4').collect();\n         assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: Vec<&str> = data.splitn(|c: char| c == '\u00e4', 3).collect();\n+        let split: Vec<&str> = data.splitn(3, |c: char| c == '\u00e4').collect();\n         assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n     #[test]\n     fn test_rsplitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let mut split: Vec<&str> = data.rsplitn(' ', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n         split.reverse();\n         assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut split: Vec<&str> = data.rsplitn(|c: char| c == ' ', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n         split.reverse();\n         assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let mut split: Vec<&str> = data.rsplitn('\u00e4', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n         split.reverse();\n         assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut split: Vec<&str> = data.rsplitn(|c: char| c == '\u00e4', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n         split.reverse();\n         assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }"}, {"sha": "3b9e2ac72dc4b02952976d03a9bf8ab850ba0c41", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -18,12 +18,15 @@ use core::default::Default;\n use core::fmt;\n use core::mem;\n use core::ptr;\n-use core::raw::Slice;\n+// FIXME: ICE's abound if you import the `Slice` type while importing `Slice` trait\n+use RawSlice = core::raw::Slice;\n+use core::slice::Slice;\n \n use {Collection, Mutable, MutableSeq};\n use hash;\n use str;\n-use str::{CharRange, StrAllocating, MaybeOwned, Owned, Slice};\n+use str::{CharRange, StrAllocating, MaybeOwned, Owned};\n+use MaybeOwnedSlice = str::Slice; // So many `Slice`s...\n use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -130,15 +133,15 @@ impl String {\n     /// ```\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n         if str::is_utf8(v) {\n-            return Slice(unsafe { mem::transmute(v) })\n+            return MaybeOwnedSlice(unsafe { mem::transmute(v) })\n         }\n \n         static TAG_CONT_U8: u8 = 128u8;\n         static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n         let mut i = 0;\n         let total = v.len();\n         fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n-            unsafe { *xs.unsafe_ref(i) }\n+            unsafe { *xs.unsafe_get(i) }\n         }\n         fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n             if i >= total {\n@@ -496,7 +499,7 @@ impl String {\n         unsafe {\n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n-            let slice = Slice {\n+            let slice = RawSlice {\n                 data: self.vec.as_ptr().offset(cur_len as int),\n                 len: 4,\n             };"}, {"sha": "dcfe256807467fdeaa9f3f59867153d3e1aa68c9", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -926,7 +926,7 @@ macro_rules! iterator_impl {\n                 // such thing as invalid pointers and memory unsafety. The\n                 // reason is performance, without doing this we can get the\n                 // bench_iter_large microbenchmark down to about 30000 ns/iter\n-                // (using .unsafe_ref to index self.stack directly, 38000\n+                // (using .unsafe_get to index self.stack directly, 38000\n                 // ns/iter with [] checked indexing), but this smashes that down\n                 // to 13500 ns/iter.\n                 //"}, {"sha": "b49e8aa01bb4101044108818880a2052256e5a8c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -13,7 +13,8 @@\n use core::prelude::*;\n \n use alloc::heap::{allocate, reallocate, deallocate};\n-use core::raw::Slice;\n+use RawSlice = core::raw::Slice;\n+use core::slice::Slice;\n use core::cmp::max;\n use core::default::Default;\n use core::fmt;\n@@ -24,7 +25,7 @@ use core::ptr;\n use core::uint;\n \n use {Collection, Mutable, MutableSeq};\n-use slice::{MutableOrdVector, MutableVectorAllocating, CloneableVector};\n+use slice::{MutableOrdSlice, MutableSliceAllocating, CloneableVector};\n use slice::{Items, MutItems};\n \n \n@@ -347,7 +348,7 @@ impl<T: Clone> Vec<T> {\n             unsafe {\n                 ptr::write(\n                     self.as_mut_slice().unsafe_mut_ref(len),\n-                    other.unsafe_ref(i).clone());\n+                    other.unsafe_get(i).clone());\n                 self.set_len(len + 1);\n             }\n         }\n@@ -506,7 +507,7 @@ impl<T: PartialOrd> PartialOrd for Vec<T> {\n \n impl<T: Eq> Eq for Vec<T> {}\n \n-impl<T: PartialEq, V: Vector<T>> Equiv<V> for Vec<T> {\n+impl<T: PartialEq, V: Slice<T>> Equiv<V> for Vec<T> {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n@@ -702,7 +703,7 @@ impl<T> Vec<T> {\n                 // decrement len before the read(), so a failure on Drop doesn't\n                 // re-drop the just-failed value.\n                 self.len -= 1;\n-                ptr::read(self.as_slice().unsafe_ref(self.len));\n+                ptr::read(self.as_slice().unsafe_get(self.len));\n             }\n         }\n     }\n@@ -720,7 +721,7 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n-            mem::transmute(Slice {\n+            mem::transmute(RawSlice {\n                 data: self.as_mut_ptr() as *const T,\n                 len: self.len,\n             })\n@@ -911,8 +912,9 @@ impl<T> Vec<T> {\n     /// assert!(vec.tailn(2) == [3, 4]);\n     /// ```\n     #[inline]\n+    #[deprecated = \"use slice_from\"]\n     pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n-        self.as_slice().tailn(n)\n+        self.as_slice().slice_from(n)\n     }\n \n     /// Returns a reference to the last element of a vector, or `None` if it is\n@@ -1502,7 +1504,7 @@ impl<T:PartialEq> Vec<T> {\n     }\n }\n \n-impl<T> Vector<T> for Vec<T> {\n+impl<T> Slice<T> for Vec<T> {\n     /// Work with `self` as a slice.\n     ///\n     /// # Example\n@@ -1515,11 +1517,11 @@ impl<T> Vector<T> for Vec<T> {\n     /// ```\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe { mem::transmute(Slice { data: self.as_ptr(), len: self.len }) }\n+        unsafe { mem::transmute(RawSlice { data: self.as_ptr(), len: self.len }) }\n     }\n }\n \n-impl<T: Clone, V: Vector<T>> Add<V, Vec<T>> for Vec<T> {\n+impl<T: Clone, V: Slice<T>> Add<V, Vec<T>> for Vec<T> {\n     #[inline]\n     fn add(&self, rhs: &V) -> Vec<T> {\n         let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n@@ -1604,7 +1606,7 @@ impl<T> MutableSeq<T> for Vec<T> {\n         } else {\n             unsafe {\n                 self.len -= 1;\n-                Some(ptr::read(self.as_slice().unsafe_ref(self.len())))\n+                Some(ptr::read(self.as_slice().unsafe_get(self.len())))\n             }\n         }\n     }"}, {"sha": "3a07e43e50993d3dbf3b18c63aac7d533b2f6044", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n use num::{Zero, One, cast};\n use result::Ok;\n-use slice::{ImmutableVector, MutableVector};\n+use slice::{ImmutableSlice, MutableSlice};\n use slice;\n use str::StrSlice;\n "}, {"sha": "942f7f8b71019f2db0ecdf495b620f86a92caf9b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -24,7 +24,7 @@ use option::{Option, Some, None};\n use ops::Deref;\n use result::{Ok, Err};\n use result;\n-use slice::{Vector, ImmutableVector};\n+use slice::{Slice, ImmutableSlice};\n use slice;\n use str::StrSlice;\n use str;"}, {"sha": "21cbafdc60538b1052058bca2a832038c2dfacb6", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -18,7 +18,7 @@ use collections::Collection;\n use fmt;\n use iter::DoubleEndedIterator;\n use num::{Int, cast, zero};\n-use slice::{ImmutableVector, MutableVector};\n+use slice::{ImmutableSlice, MutableSlice};\n \n /// A type that represents a specific radix\n #[doc(hidden)]"}, {"sha": "74d87712a02ef96cc6d36a44a0f6f3558077fa87", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -143,7 +143,7 @@\n \n use cmp::{PartialEq, Eq, Ord};\n use default::Default;\n-use slice::Vector;\n+use slice::Slice;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use mem;\n use slice;\n@@ -518,7 +518,7 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-impl<T> Vector<T> for Option<T> {\n+impl<T> Slice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a [T] {"}, {"sha": "ead48092c4dcf46163cdc8e784b8ab2f00da1428", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -61,6 +61,6 @@ pub use str::{Str, StrSlice};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-pub use slice::{ImmutableEqVector, ImmutableOrdVector};\n-pub use slice::{MutableVector};\n-pub use slice::{Vector, ImmutableVector};\n+pub use slice::{ImmutablePartialEqSlice, ImmutableOrdSlice};\n+pub use slice::{MutableSlice};\n+pub use slice::{Slice, ImmutableSlice};"}, {"sha": "93dafc153b6b206878f5547f072e4c6718f1ae4a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 212, "deletions": 26, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -12,6 +12,7 @@\n //!\n //! For more details `std::slice`.\n \n+#![stable]\n #![doc(primitive = \"slice\")]\n \n // How this module is organized.\n@@ -47,34 +48,41 @@ use ptr::RawPtr;\n use mem;\n use mem::size_of;\n use kinds::marker;\n-use raw::{Repr, Slice};\n+use raw::Repr;\n+// Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n+use RawSlice = raw::Slice;\n+\n \n //\n // Extension traits\n //\n \n /// Extension methods for vectors\n-pub trait ImmutableVector<'a, T> {\n+#[unstable = \"may merge with other traits; region parameter may disappear\"]\n+pub trait ImmutableSlice<'a, T> {\n     /**\n      * Returns a slice of self spanning the interval [`start`, `end`).\n      *\n      * Fails when the slice (or part of it) is outside the bounds of self,\n      * or when `start` > `end`.\n      */\n+    #[unstable]\n     fn slice(&self, start: uint, end: uint) -> &'a [T];\n \n     /**\n      * Returns a slice of self from `start` to the end of the vec.\n      *\n      * Fails when `start` points outside the bounds of self.\n      */\n+    #[unstable]\n     fn slice_from(&self, start: uint) -> &'a [T];\n \n     /**\n      * Returns a slice of self from the start of the vec to `end`.\n      *\n      * Fails when `end` points outside the bounds of self.\n      */\n+    #[unstable]\n     fn slice_to(&self, end: uint) -> &'a [T];\n \n     /// Divides one slice into two at an index.\n@@ -84,24 +92,29 @@ pub trait ImmutableVector<'a, T> {\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n     /// Fails if `mid > len`.\n+    #[unstable]\n     fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]);\n \n     /// Returns an iterator over the vector\n+    #[unstable = \"iterator type may change\"]\n     fn iter(self) -> Items<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.  The matched element\n     /// is not contained in the subslices.\n+    #[unstable = \"iterator type may change\"]\n     fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.  The matched element is not contained in\n     /// the subslices.\n+    #[unstable = \"iterator type may change\"]\n     fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.  The matched element is not contained in the\n     /// subslices.\n+    #[unstable = \"iterator type may change\"]\n     fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n \n     /**\n@@ -126,6 +139,7 @@ pub trait ImmutableVector<'a, T> {\n      * ```\n      *\n      */\n+    #[unstable = \"iterator type may change\"]\n     fn windows(self, size: uint) -> Windows<'a, T>;\n     /**\n      *\n@@ -151,28 +165,42 @@ pub trait ImmutableVector<'a, T> {\n      * ```\n      *\n      */\n+    #[unstable = \"iterator type may change\"]\n     fn chunks(self, size: uint) -> Chunks<'a, T>;\n \n     /// Returns the element of a vector at the given index, or `None` if the\n     /// index is out of bounds\n+    #[unstable]\n     fn get(&self, index: uint) -> Option<&'a T>;\n     /// Returns the first element of a vector, or `None` if it is empty\n+    #[unstable = \"name may change\"]\n     fn head(&self) -> Option<&'a T>;\n     /// Returns all but the first element of a vector\n+    #[unstable = \"name may change\"]\n     fn tail(&self) -> &'a [T];\n     /// Returns all but the first `n' elements of a vector\n+    #[deprecated = \"use slice_from\"]\n     fn tailn(&self, n: uint) -> &'a [T];\n     /// Returns all but the last element of a vector\n+    #[unstable = \"name may change\"]\n     fn init(&self) -> &'a [T];\n     /// Returns all but the last `n' elements of a vector\n+    #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T];\n     /// Returns the last element of a vector, or `None` if it is empty.\n+    #[unstable = \"name may change\"]\n     fn last(&self) -> Option<&'a T>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n+    #[deprecated = \"renamed to `unsafe_get`\"]\n     unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n \n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[unstable]\n+    unsafe fn unsafe_get(self, index: uint) -> &'a T;\n+\n     /**\n      * Returns an unsafe pointer to the vector's buffer\n      *\n@@ -182,6 +210,7 @@ pub trait ImmutableVector<'a, T> {\n      * Modifying the vector may cause its buffer to be reallocated, which\n      * would also make any pointers to it invalid.\n      */\n+    #[unstable]\n     fn as_ptr(&self) -> *const T;\n \n     /**\n@@ -195,8 +224,23 @@ pub trait ImmutableVector<'a, T> {\n      * Returns the index where the comparator returned `Equal`, or `None` if\n      * not found.\n      */\n+    #[deprecated = \"use binary_search\"]\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n \n+    /// Binary search a sorted vector with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying vector, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n+    ///\n+    /// If the value is found then `Found` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `NotFound` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    #[unstable]\n+    fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult;\n+\n     /**\n      * Returns an immutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n@@ -213,6 +257,7 @@ pub trait ImmutableVector<'a, T> {\n      *\n      * Returns `None` if vector is empty\n      */\n+    #[deprecated = \"find some other way. sorry\"]\n     fn shift_ref(&mut self) -> Option<&'a T>;\n \n     /**\n@@ -231,16 +276,18 @@ pub trait ImmutableVector<'a, T> {\n      *\n      * Returns `None` if slice is empty.\n      */\n+    #[deprecated = \"find some other way. sorry\"]\n     fn pop_ref(&mut self) -> Option<&'a T>;\n }\n \n-impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n+#[unstable]\n+impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     #[inline]\n     fn slice(&self, start: uint, end: uint) -> &'a [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n         unsafe {\n-            transmute(Slice {\n+            transmute(RawSlice {\n                     data: self.as_ptr().offset(start as int),\n                     len: (end - start)\n                 })\n@@ -331,6 +378,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n \n     #[inline]\n+    #[deprecated = \"use slice_from\"]\n     fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n \n     #[inline]\n@@ -339,6 +387,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n+    #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T] {\n         self.slice(0, self.len() - n)\n     }\n@@ -349,16 +398,23 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n+    #[deprecated = \"renamed to `unsafe_get`\"]\n     unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n         transmute(self.repr().data.offset(index as int))\n     }\n \n+    #[inline]\n+    unsafe fn unsafe_get(self, index: uint) -> &'a T {\n+        transmute(self.repr().data.offset(index as int))\n+    }\n+\n     #[inline]\n     fn as_ptr(&self) -> *const T {\n         self.repr().data\n     }\n \n \n+    #[deprecated = \"use binary_search\"]\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n@@ -378,9 +434,29 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n         return None;\n     }\n \n+    #[unstable]\n+    fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n+\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Found(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n+        }\n+        return NotFound(base);\n+    }\n+\n     fn shift_ref(&mut self) -> Option<&'a T> {\n         unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n+            let s: &mut RawSlice<T> = transmute(self);\n             match raw::shift_ptr(s) {\n                 Some(p) => Some(&*p),\n                 None => None\n@@ -390,7 +466,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n \n     fn pop_ref(&mut self) -> Option<&'a T> {\n         unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n+            let s: &mut RawSlice<T> = transmute(self);\n             match raw::pop_ptr(s) {\n                 Some(p) => Some(&*p),\n                 None => None\n@@ -401,7 +477,8 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n \n /// Extension methods for vectors such that their elements are\n /// mutable.\n-pub trait MutableVector<'a, T> {\n+#[experimental = \"may merge with other traits; may lose region param; needs review\"]\n+pub trait MutableSlice<'a, T> {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     fn get_mut(self, index: uint) -> Option<&'a mut T>;\n@@ -465,6 +542,7 @@ pub trait MutableVector<'a, T> {\n      *\n      * Returns `None` if slice is empty\n      */\n+    #[deprecated = \"find some other way. sorry\"]\n     fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n \n     /**\n@@ -483,6 +561,7 @@ pub trait MutableVector<'a, T> {\n      *\n      * Returns `None` if slice is empty.\n      */\n+    #[deprecated = \"find some other way. sorry\"]\n     fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n \n     /// Swaps two elements in a vector.\n@@ -607,7 +686,8 @@ pub trait MutableVector<'a, T> {\n     unsafe fn copy_memory(self, src: &[T]);\n }\n \n-impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n+#[experimental = \"trait is experimental\"]\n+impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn get_mut(self, index: uint) -> Option<&'a mut T> {\n         if index < self.len() { Some(&mut self[index]) } else { None }\n@@ -620,7 +700,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n         unsafe {\n-            transmute(Slice {\n+            transmute(RawSlice {\n                     data: self.as_mut_ptr().offset(start as int) as *const T,\n                     len: (end - start)\n                 })\n@@ -685,7 +765,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n         unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n+            let s: &mut RawSlice<T> = transmute(self);\n             match raw::shift_ptr(s) {\n                 // FIXME #13933: this `&` -> `&mut` cast is a little\n                 // dubious\n@@ -697,7 +777,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n         unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n+            let s: &mut RawSlice<T> = transmute(self);\n             match raw::pop_ptr(s) {\n                 // FIXME #13933: this `&` -> `&mut` cast is a little\n                 // dubious\n@@ -755,7 +835,8 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n }\n \n /// Extension methods for vectors contain `PartialEq` elements.\n-pub trait ImmutableEqVector<T:PartialEq> {\n+#[unstable = \"may merge with other traits\"]\n+pub trait ImmutablePartialEqSlice<T:PartialEq> {\n     /// Find the first index containing a matching value\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n@@ -772,7 +853,8 @@ pub trait ImmutableEqVector<T:PartialEq> {\n     fn ends_with(&self, needle: &[T]) -> bool;\n }\n \n-impl<'a,T:PartialEq> ImmutableEqVector<T> for &'a [T] {\n+#[unstable = \"trait is unstable\"]\n+impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n         self.iter().position(|y| *x == *y)\n@@ -802,31 +884,59 @@ impl<'a,T:PartialEq> ImmutableEqVector<T> for &'a [T] {\n }\n \n /// Extension methods for vectors containing `Ord` elements.\n-pub trait ImmutableOrdVector<T: Ord> {\n+#[unstable = \"may merge with other traits\"]\n+pub trait ImmutableOrdSlice<T: Ord> {\n     /**\n      * Binary search a sorted vector for a given element.\n      *\n      * Returns the index of the element or None if not found.\n      */\n+    #[deprecated = \"use binary_search_elem\"]\n     fn bsearch_elem(&self, x: &T) -> Option<uint>;\n+\n+    /**\n+     * Binary search a sorted vector for a given element.\n+     *\n+     * If the value is found then `Found` is returned, containing the\n+     * index of the matching element; if the value is not found then\n+     * `NotFound` is returned, containing the index where a matching\n+     * element could be inserted while maintaining sorted order.\n+     */\n+    #[unstable]\n+    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n }\n \n-impl<'a, T: Ord> ImmutableOrdVector<T> for &'a [T] {\n+#[unstable = \"trait is unstable\"]\n+impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n+    #[deprecated = \"use binary_search_elem\"]\n+    #[allow(deprecated)]\n     fn bsearch_elem(&self, x: &T) -> Option<uint> {\n         self.bsearch(|p| p.cmp(x))\n     }\n+\n+    #[unstable]\n+    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n+        self.binary_search(|p| p.cmp(x))\n+    }\n }\n \n /// Trait for &[T] where T is Cloneable\n-pub trait MutableCloneableVector<T> {\n+#[unstable = \"may merge with other traits\"]\n+pub trait MutableCloneableSlice<T> {\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    #[deprecated = \"renamed to clone_from_slice\"]\n+    fn copy_from(self, s: &[T]) -> uint { self.clone_from_slice(s) }\n+\n     /// Copies as many elements from `src` as it can into `self` (the\n     /// shorter of `self.len()` and `src.len()`). Returns the number\n     /// of elements copied.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::slice::MutableCloneableVector;\n+    /// use std::slice::MutableCloneableSlice;\n     ///\n     /// let mut dst = [0i, 0, 0];\n     /// let src = [1i, 2];\n@@ -838,12 +948,13 @@ pub trait MutableCloneableVector<T> {\n     /// assert!(dst.copy_from(src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    fn copy_from(self, &[T]) -> uint;\n+    fn clone_from_slice(self, &[T]) -> uint;\n }\n \n-impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n+#[unstable = \"trait is unstable\"]\n+impl<'a, T:Clone> MutableCloneableSlice<T> for &'a mut [T] {\n     #[inline]\n-    fn copy_from(self, src: &[T]) -> uint {\n+    fn clone_from_slice(self, src: &[T]) -> uint {\n         for (a, b) in self.mut_iter().zip(src.iter()) {\n             a.clone_from(b);\n         }\n@@ -859,16 +970,19 @@ impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n //\n \n /// Any vector that can be represented as a slice.\n-pub trait Vector<T> {\n+#[unstable = \"may merge with other traits\"]\n+pub trait Slice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-impl<'a,T> Vector<T> for &'a [T] {\n+#[unstable = \"trait is unstable\"]\n+impl<'a,T> Slice<T> for &'a [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, T> Collection for &'a [T] {\n     /// Returns the length of a vector\n     #[inline]\n@@ -877,6 +991,7 @@ impl<'a, T> Collection for &'a [T] {\n     }\n }\n \n+#[unstable = \"waiting for DST\"]\n impl<'a, T> Default for &'a [T] {\n     fn default() -> &'a [T] { &[] }\n }\n@@ -891,6 +1006,7 @@ impl<'a, T> Default for &'a [T] {\n // The shared definition of the `Item` and `MutItems` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        #[experimental = \"needs review\"]\n         impl<'a, T> Iterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n@@ -926,6 +1042,7 @@ macro_rules! iterator {\n             }\n         }\n \n+        #[experimental = \"needs review\"]\n         impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -953,6 +1070,7 @@ macro_rules! iterator {\n }\n \n /// Immutable slice iterator\n+#[experimental = \"needs review\"]\n pub struct Items<'a, T> {\n     ptr: *const T,\n     end: *const T,\n@@ -961,12 +1079,15 @@ pub struct Items<'a, T> {\n \n iterator!{struct Items -> *const T, &'a T}\n \n+#[experimental = \"needs review\"]\n impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Clone for Items<'a, T> {\n     fn clone(&self) -> Items<'a, T> { *self }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -992,6 +1113,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n }\n \n /// Mutable slice iterator\n+#[experimental = \"needs review\"]\n pub struct MutItems<'a, T> {\n     ptr: *mut T,\n     end: *mut T,\n@@ -1001,16 +1123,19 @@ pub struct MutItems<'a, T> {\n \n iterator!{struct MutItems -> *mut T, &'a mut T}\n \n+#[experimental = \"needs review\"]\n impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n+#[experimental = \"needs review\"]\n pub struct Splits<'a, T> {\n     v: &'a [T],\n     pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1039,6 +1164,7 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1060,12 +1186,14 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n+#[experimental = \"needs review\"]\n pub struct MutSplits<'a, T> {\n     v: &'a mut [T],\n     pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n@@ -1102,6 +1230,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1126,12 +1255,14 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function, splitting at most a fixed number of times.\n+#[experimental = \"needs review\"]\n pub struct SplitsN<'a, T> {\n     iter: Splits<'a, T>,\n     count: uint,\n     invert: bool\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1161,11 +1292,13 @@ impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n #[deriving(Clone)]\n+#[experimental = \"needs review\"]\n pub struct Windows<'a, T> {\n     v: &'a [T],\n     size: uint\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1195,11 +1328,13 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n /// When the vector len is not evenly divided by the chunk size,\n /// the last slice of the iteration will be the remainder.\n #[deriving(Clone)]\n+#[experimental = \"needs review\"]\n pub struct Chunks<'a, T> {\n     v: &'a [T],\n     size: uint\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n@@ -1225,6 +1360,7 @@ impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1240,6 +1376,7 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1263,11 +1400,13 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n /// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n /// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n /// the remainder.\n+#[experimental = \"needs review\"]\n pub struct MutChunks<'a, T> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n@@ -1294,6 +1433,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n     }\n }\n \n+#[experimental = \"needs review\"]\n impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1313,6 +1453,43 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n \n \n \n+/// The result of calling `binary_search`.\n+///\n+/// `Found` means the search succeeded, and the contained value is the\n+/// index of the matching element. `NotFound` means the search\n+/// succeeded, and the contained value is an index where a matching\n+/// value could be inserted while maintaining sort order.\n+#[deriving(PartialEq, Show)]\n+#[experimental = \"needs review\"]\n+pub enum BinarySearchResult {\n+    /// The index of the found value.\n+    Found(uint),\n+    /// The index where the value should have been found.\n+    NotFound(uint)\n+}\n+\n+#[experimental = \"needs review\"]\n+impl BinarySearchResult {\n+    /// Converts a `Found` to `Some`, `NotFound` to `None`.\n+    /// Similar to `Result::ok`.\n+    pub fn found(&self) -> Option<uint> {\n+        match *self {\n+            Found(i) => Some(i),\n+            NotFound(_) => None\n+        }\n+    }\n+\n+    /// Convert a `Found` to `None`, `NotFound` to `Some`.\n+    /// Similar to `Result::err`.\n+    pub fn not_found(&self) -> Option<uint> {\n+        match *self {\n+            Found(_) => None,\n+            NotFound(i) => Some(i)\n+        }\n+    }\n+}\n+\n+\n \n //\n // Free functions\n@@ -1321,19 +1498,21 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n /**\n  * Converts a pointer to A into a slice of length 1 (without copying).\n  */\n+#[unstable = \"waiting for DST\"]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n-        transmute(Slice { data: s, len: 1 })\n+        transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n /**\n  * Converts a pointer to A into a slice of length 1 (without copying).\n  */\n+#[unstable = \"waiting for DST\"]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n-        transmute(Slice { data: ptr, len: 1 })\n+        transmute(RawSlice { data: ptr, len: 1 })\n     }\n }\n \n@@ -1345,6 +1524,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n //\n \n /// Unsafe operations\n+#[experimental = \"needs review\"]\n pub mod raw {\n     use mem::transmute;\n     use ptr::RawPtr;\n@@ -1410,10 +1590,11 @@ pub mod raw {\n }\n \n /// Operations on `[u8]`.\n+#[experimental = \"needs review\"]\n pub mod bytes {\n     use collections::Collection;\n     use ptr;\n-    use slice::MutableVector;\n+    use slice::MutableSlice;\n \n     /// A trait for operations on mutable `[u8]`s.\n     pub trait MutableByteVector {\n@@ -1447,6 +1628,7 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n+#[unstable = \"waiting for DST\"]\n impl<'a,T:PartialEq> PartialEq for &'a [T] {\n     fn eq(&self, other: & &'a [T]) -> bool {\n         self.len() == other.len() &&\n@@ -1458,19 +1640,23 @@ impl<'a,T:PartialEq> PartialEq for &'a [T] {\n     }\n }\n \n+#[unstable = \"waiting for DST\"]\n impl<'a,T:Eq> Eq for &'a [T] {}\n \n-impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n+#[unstable = \"waiting for DST\"]\n+impl<'a,T:PartialEq, V: Slice<T>> Equiv<V> for &'a [T] {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+#[unstable = \"waiting for DST\"]\n impl<'a,T:Ord> Ord for &'a [T] {\n     fn cmp(&self, other: & &'a [T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n+#[unstable = \"waiting for DST\"]\n impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {"}, {"sha": "4f7db7b41f38b7403ef1a496250790a34b400d26", "filename": "src/libcore/str.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -30,7 +30,7 @@ use iter::range;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use slice;\n use uint;\n \n@@ -964,7 +964,7 @@ pub mod raw {\n     use collections::Collection;\n     use ptr::RawPtr;\n     use raw::Slice;\n-    use slice::{ImmutableVector};\n+    use slice::{ImmutableSlice};\n     use str::{is_utf8, StrSlice};\n \n     /// Converts a slice of bytes to a string slice without checking\n@@ -1147,22 +1147,22 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(' ', 2).collect();\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_digit()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n     ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn('X', 0).collect();\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n     /// assert_eq!(v, vec![\"abcXdef\"]);\n     ///\n-    /// let v: Vec<&str> = \"\".splitn('X', 1).collect();\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n+    fn splitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1197,16 +1197,16 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_digit()).collect();\n     /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n+    fn rsplitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n \n     /// An iterator over the start and end indices of the disjoint\n     /// matches of `sep` within `self`.\n@@ -1697,7 +1697,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n+    fn splitn<Sep: CharEq>(&self, count: uint, sep: Sep)\n         -> CharSplitsN<'a, Sep> {\n         CharSplitsN {\n             iter: self.split(sep),\n@@ -1716,7 +1716,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n+    fn rsplitn<Sep: CharEq>(&self, count: uint, sep: Sep)\n         -> CharSplitsN<'a, Sep> {\n         CharSplitsN {\n             iter: self.split(sep),"}, {"sha": "3864321586ca67f643efbe9190c3c8dd8e6958ac", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -28,4 +28,5 @@ mod option;\n mod ptr;\n mod raw;\n mod result;\n+mod slice;\n mod tuple;"}, {"sha": "1288756dea4a5991e668aac6cd12680a8172f369", "filename": "src/libcoretest/slice.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::slice::{Found, NotFound};\n+\n+#[test]\n+fn binary_search_not_found() {\n+    let b = [1i, 2, 4, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    let b = [1i, 2, 4, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    let b = [1i, 2, 4, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&8)) == Found(4));\n+    let b = [1i, 2, 4, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(4));\n+    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&8)) == Found(5));\n+    let b = [1i, 2, 4, 5, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(5));\n+    let b = [1i, 2, 4, 5, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&0)) == NotFound(0));\n+    let b = [1i, 2, 4, 5, 6, 8];\n+    assert!(b.binary_search(|v| v.cmp(&9)) == NotFound(6));\n+}"}, {"sha": "987f214b153e07d3ba107024563594cf6b27ee2c", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -84,7 +84,7 @@ impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n     }\n }\n \n-impl<'a, T: PartialEq, V: Vector<T>> Equiv<V> for MaybeOwnedVector<'a, T> {\n+impl<'a, T: PartialEq, V: Slice<T>> Equiv<V> for MaybeOwnedVector<'a, T> {\n     fn equiv(&self, other: &V) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n@@ -99,7 +99,7 @@ impl<'a, T: PartialEq, V: Vector<T>> Equiv<V> for MaybeOwnedVector<'a, T> {\n // In any case, with `Vector` in place, the client can just use\n // `as_slice` if they prefer that over `match`.\n \n-impl<'b,T> slice::Vector<T> for MaybeOwnedVector<'b,T> {\n+impl<'b,T> Slice<T> for MaybeOwnedVector<'b,T> {\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match self {\n             &Growable(ref v) => v.as_slice(),"}, {"sha": "f3e4b0b21adf85ba94b9f918bd48fdacd5d3406c", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -341,7 +341,7 @@ impl<T: FromStr + Clone + Integer + PartialOrd>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom` or just `numer`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n-        let mut split = s.splitn('/', 1);\n+        let mut split = s.splitn(1, '/');\n \n         let num = split.next().and_then(|n| FromStr::from_str(n));\n         let den = split.next().or(Some(\"1\")).and_then(|d| FromStr::from_str(d));\n@@ -357,7 +357,7 @@ impl<T: FromStrRadix + Clone + Integer + PartialOrd>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n-        let split: Vec<&str> = s.splitn('/', 1).collect();\n+        let split: Vec<&str> = s.splitn(1, '/').collect();\n         if split.len() < 2 {\n             None\n         } else {"}, {"sha": "2fbfa6d6e85a0da393ae2050cb9d7ff963e4ab3f", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -348,7 +348,7 @@ impl Isaac64Rng {\n         static MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind (\n             ($x:expr) => {\n-                *self.mem.unsafe_ref(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n+                *self.mem.unsafe_get(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n         );\n \n@@ -362,8 +362,8 @@ impl Isaac64Rng {\n                             let mix = if $j == 0 {!mix} else {mix};\n \n                             unsafe {\n-                                let x = *self.mem.unsafe_ref(base + mr_offset);\n-                                a = mix + *self.mem.unsafe_ref(base + m2_offset);\n+                                let x = *self.mem.unsafe_get(base + mr_offset);\n+                                a = mix + *self.mem.unsafe_get(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n                                 self.mem.unsafe_set(base + mr_offset, y);\n \n@@ -379,8 +379,8 @@ impl Isaac64Rng {\n                             let mix = if $j == 0 {!mix} else {mix};\n \n                             unsafe {\n-                                let x = *self.mem.unsafe_ref(base + mr_offset);\n-                                a = mix + *self.mem.unsafe_ref(base + m2_offset);\n+                                let x = *self.mem.unsafe_get(base + mr_offset);\n+                                a = mix + *self.mem.unsafe_get(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n                                 self.mem.unsafe_set(base + mr_offset, y);\n \n@@ -416,7 +416,7 @@ impl Rng for Isaac64Rng {\n             self.isaac64();\n         }\n         self.cnt -= 1;\n-        unsafe { *self.rsl.unsafe_ref(self.cnt) }\n+        unsafe { *self.rsl.unsafe_get(self.cnt) }\n     }\n }\n "}, {"sha": "13b094a2cf2e6475bfacc54c19ed7a979a1e86d4", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -13,6 +13,7 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n+use std::slice;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -518,7 +519,7 @@ impl<'a> Parser<'a> {\n             min = try!(self.parse_uint(inner.as_slice()));\n             max = Some(min);\n         } else {\n-            let pieces: Vec<&str> = inner.as_slice().splitn(',', 1).collect();\n+            let pieces: Vec<&str> = inner.as_slice().splitn(1, ',').collect();\n             let (smin, smax) = (pieces[0], pieces[1]);\n             if smin.len() == 0 {\n                 return self.err(\"Max repetitions cannot be specified \\\n@@ -1017,9 +1018,9 @@ fn is_valid_cap(c: char) -> bool {\n }\n \n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n-    match classes.bsearch(|&(s, _)| s.cmp(&name)) {\n-        Some(i) => Some(Vec::from_slice(classes[i].val1())),\n-        None => None,\n+    match classes.binary_search(|&(s, _)| s.cmp(&name)) {\n+        slice::Found(i) => Some(Vec::from_slice(classes[i].val1())),\n+        slice::NotFound(_) => None,\n     }\n }\n "}, {"sha": "507a7641f2201bf100982cf9cb3b8e2e63527679", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -35,7 +35,7 @@\n \n use std::cmp;\n use std::mem;\n-use std::slice::MutableVector;\n+use std::slice::MutableSlice;\n use compile::{\n     Program,\n     Match, OneChar, CharClass, Any, EmptyBegin, EmptyEnd, EmptyWordBoundary,\n@@ -222,8 +222,8 @@ impl<'r, 't> Nfa<'r, 't> {\n                     let negate = flags & FLAG_NEGATED > 0;\n                     let casei = flags & FLAG_NOCASE > 0;\n                     let found = ranges.as_slice();\n-                    let found = found.bsearch(|&rc| class_cmp(casei, c, rc));\n-                    let found = found.is_some();\n+                    let found = found.binary_search(|&rc| class_cmp(casei, c, rc))\n+                        .found().is_some();\n                     if found ^ negate {\n                         self.add(nlist, pc+1, caps);\n                     }\n@@ -513,15 +513,15 @@ pub fn is_word(c: Option<char>) -> bool {\n     // Try the common ASCII case before invoking binary search.\n     match c {\n         '_' | '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' => true,\n-        _ => PERLW.bsearch(|&(start, end)| {\n+        _ => PERLW.binary_search(|&(start, end)| {\n             if c >= start && c <= end {\n                 Equal\n             } else if start > c {\n                 Greater\n             } else {\n                 Less\n             }\n-        }).is_some()\n+        }).found().is_some()\n     }\n }\n "}, {"sha": "706b5c3325576c212dc72be9055ec4b9a035166c", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -112,7 +112,7 @@ mod test {\n     use core::iter::Iterator;\n     use core::collections::Collection;\n     use core::str::StrSlice;\n-    use core::slice::{MutableVector, ImmutableVector};\n+    use core::slice::{MutableSlice, ImmutableSlice};\n \n     use super::{memcmp, memset, memcpy, memmove};\n "}, {"sha": "826579b62fcba23a1f08b0da0a43a5325dc67bed", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -353,7 +353,7 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n {\n     let mut cg = basic_codegen_options();\n     for option in matches.opt_strs(\"C\").move_iter() {\n-        let mut iter = option.as_slice().splitn('=', 1);\n+        let mut iter = option.as_slice().splitn(1, '=');\n         let key = iter.next().unwrap();\n         let value = iter.next();\n         let option_to_lookup = key.replace(\"-\", \"_\");\n@@ -750,7 +750,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut externs = HashMap::new();\n     for arg in matches.opt_strs(\"extern\").iter() {\n-        let mut parts = arg.as_slice().splitn('=', 1);\n+        let mut parts = arg.as_slice().splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => early_error(\"--extern value must not be empty\"),"}, {"sha": "dc600e0da3ec06ae26253c8ada1eee7ff7f2b918", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -356,7 +356,7 @@ pub enum PpMode {\n }\n \n fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<driver::UserIdentifiedItem>) {\n-    let mut split = name.splitn('=', 1);\n+    let mut split = name.splitn(1, '=');\n     let first = split.next().unwrap();\n     let opt_second = split.next();\n     let first = match first {"}, {"sha": "ceb7dcc54560c04931744bf91f3dbaeecdcd0d1d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -379,7 +379,7 @@ fn mk_test_module(cx: &TestCtxt, reexport_test_harness_main: &Option<InternedStr\n     let mainfn = (quote_item!(&cx.ext_cx,\n         pub fn main() {\n             #![main]\n-            use std::slice::Vector;\n+            use std::slice::Slice;\n             test::test_main_static(::std::os::args().as_slice(), TESTS);\n         }\n     )).unwrap();"}, {"sha": "fb1666bef0d2f467d8757c6b8d6bf244a0e7f596", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -328,7 +328,7 @@ fn acquire_input(input: &str,\n fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n     for arg in matches.opt_strs(\"extern\").iter() {\n-        let mut parts = arg.as_slice().splitn('=', 1);\n+        let mut parts = arg.as_slice().splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => {"}, {"sha": "e5f42bd65a30071d21dae7840c6f761cebb8edfe", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -19,7 +19,7 @@ use fmt;\n use iter::Iterator;\n use mem;\n use option::{Option, Some, None};\n-use slice::{ImmutableVector, MutableVector, Vector};\n+use slice::{ImmutableSlice, MutableSlice, Slice};\n use str::{Str, StrSlice};\n use str;\n use string::String;"}, {"sha": "5f52c0ada5d62d2d4077ab21864a905d839a885d", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -43,7 +43,7 @@ use option::{Option, Some, None};\n use ptr::RawPtr;\n use ptr;\n use raw;\n-use slice::Vector;\n+use slice::Slice;\n \n /// The type representing a foreign chunk of memory\n pub struct CVec<T> {\n@@ -145,7 +145,7 @@ impl<T> CVec<T> {\n     }\n }\n \n-impl<T> Vector<T> for CVec<T> {\n+impl<T> Slice<T> for CVec<T> {\n     /// View the stored data as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {"}, {"sha": "b8f8bd41a2d9dacb24121c4376433ac3c1e5eb7c", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -2743,7 +2743,7 @@ mod test_set {\n     use prelude::*;\n \n     use super::HashSet;\n-    use slice::ImmutableEqVector;\n+    use slice::ImmutablePartialEqSlice;\n     use collections::Collection;\n \n     #[test]"}, {"sha": "766f92292b1875d5b163bdfa4ef1b89143f61f1a", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -29,7 +29,7 @@ use option::*;\n use os;\n use path::{Path,GenericPath};\n use result::*;\n-use slice::{Vector,ImmutableVector};\n+use slice::{Slice,ImmutableSlice};\n use str;\n use string::String;\n use vec::Vec;"}, {"sha": "a9b0b33c59ad9ae3b2ef066b0ab8a08c431fab62", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -19,7 +19,7 @@ use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n-use slice::{ImmutableVector, MutableVector};\n+use slice::{ImmutableSlice, MutableSlice};\n use slice;\n use vec::Vec;\n "}, {"sha": "53b5fbe3894edc099bd9e36ea109b6b4ab76eca9", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -15,7 +15,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n-use slice::{bytes, MutableVector, ImmutableVector};\n+use slice::{bytes, MutableSlice, ImmutableSlice};\n use str::StrSlice;\n use super::{Reader, Writer, IoResult};\n use vec::Vec;"}, {"sha": "12caa7158658e28693df873b74ab099b4e6505c0", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -21,7 +21,7 @@ use option::{Option, Some, None};\n use result::{Ok, Err};\n use io;\n use io::{IoError, IoResult, Reader};\n-use slice::{ImmutableVector, Vector};\n+use slice::{ImmutableSlice, Slice};\n use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n@@ -153,7 +153,7 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     use ptr::{copy_nonoverlapping_memory};\n     use mem::from_be64;\n-    use slice::MutableVector;\n+    use slice::MutableSlice;\n \n     assert!(size <= 8u);\n "}, {"sha": "f95f41509a0f50b9158538476765560b4f265447", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -70,7 +70,7 @@ use path;\n use result::{Err, Ok};\n use rt::rtio::LocalIo;\n use rt::rtio;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n use vec::Vec;\n "}, {"sha": "ea9d08171e6cef2794753ab83d141915cd2d0b93", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -19,7 +19,7 @@ use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n-use slice::{Vector, ImmutableVector, MutableVector};\n+use slice::{Slice, ImmutableSlice, MutableSlice};\n use vec::Vec;\n \n static BUF_CAPACITY: uint = 128;"}, {"sha": "c95dd8618ed10a7648e14f8f07939117a3a3d9ad", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -235,7 +235,7 @@ use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n-use slice::{Vector, MutableVector, ImmutableVector};\n+use slice::{Slice, MutableSlice, ImmutableSlice};\n use str::{Str, StrSlice};\n use str;\n use string::String;"}, {"sha": "ed76cdc276ba62e8488f284fd2eb98fa2f5fb51c", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -21,7 +21,7 @@ use from_str::FromStr;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str::StrSlice;\n-use slice::{MutableCloneableVector, ImmutableVector, MutableVector};\n+use slice::{MutableCloneableSlice, ImmutableSlice, MutableSlice};\n \n pub type Port = u16;\n "}, {"sha": "7055b9d7a473887c5680905eb889372428f047ca", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -21,7 +21,7 @@ use clone::Clone;\n use collections::MutableSeq;\n use io::IoResult;\n use iter::Iterator;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use result::{Ok,Err};\n use io::net::addrinfo::get_host_addresses;\n use io::net::ip::SocketAddr;"}, {"sha": "1d882bdc0ad9e0fddd53ff318921029f8c43f265", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -30,7 +30,7 @@ use option::{Some, None};\n use boxed::Box;\n use result::{Ok, Err};\n use rt::rtio::{IoFactory, LocalIo, RtioSignal, Callback};\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use vec::Vec;\n \n /// Signals that can be sent and received"}, {"sha": "fea161c426a2e1a15a22fc5876fc052cd99cab16", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -41,7 +41,7 @@ use rt;\n use rt::local::Local;\n use rt::task::Task;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use str::StrSlice;\n use uint;\n "}, {"sha": "f5b2f31a127d603f25fc09ea5d8513e885d3380a", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "623a10725c826387d8c942b9c0f79efd3e416658", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "ffb1307908c90821941ee8721d7a7ed8c20989f2", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "4fbb7381238dc77569a6a05aafd84e20d1f9ac45", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "7821306f5fc3da122ee4d2f4d027a6920272b1c8", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};"}, {"sha": "407c8ea61d9146eeef1b061eb3ac96d6871586cd", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -20,7 +20,7 @@ use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use slice::{ImmutableVector, MutableVector};\n+use slice::{ImmutableSlice, MutableSlice};\n use std::cmp::{PartialOrd, PartialEq};\n use str::StrSlice;\n use string::String;"}, {"sha": "0f00f99e980a2a6c387555fd8ca36bbb7b3cdd33", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "e6c6bc377b7aa304d51cb468c93f06ac091b6768", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "7eb9e1a082fe872abb009e326cc94657d7048a41", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "300dd3bcc01a4cfc69f2f7965bb0f614a024f7ec", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "0adc22e321406ebdce3ef58c05d77dec808c8521", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -17,7 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableVector;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};"}, {"sha": "6a00368f9a21ec506e522f60ff3f5837cd37eaaa", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -45,7 +45,7 @@ use path::{Path, GenericPath, BytesContainer};\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n-use slice::{Vector, ImmutableVector, MutableVector, ImmutableEqVector};\n+use slice::{Slice, ImmutableSlice, MutableSlice, ImmutablePartialEqSlice};\n use str::{Str, StrSlice, StrAllocating};\n use string::String;\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n@@ -145,7 +145,7 @@ pub mod win32 {\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::{MutableVector, ImmutableVector};\n+    use slice::{MutableSlice, ImmutableSlice};\n     use string::String;\n     use str::StrSlice;\n     use vec::Vec;"}, {"sha": "d24c2e2266d4c68ae5165be33821b77612692fab", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -74,8 +74,8 @@ use option::{Option, None, Some};\n use str;\n use str::{MaybeOwned, Str, StrSlice};\n use string::String;\n-use slice::Vector;\n-use slice::{ImmutableEqVector, ImmutableVector};\n+use slice::Slice;\n+use slice::{ImmutablePartialEqSlice, ImmutableSlice};\n use vec::Vec;\n \n /// Typedef for POSIX file paths."}, {"sha": "0a7817c3e0047dd71c73d79b03f288e18e5cf95c", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -21,8 +21,8 @@ use iter::{DoubleEndedIterator, AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str::Str;\n use str;\n-use slice::{CloneableVector, Splits, Vector, VectorVector,\n-            ImmutableEqVector, ImmutableVector};\n+use slice::{CloneableVector, Splits, Slice, VectorVector,\n+            ImmutablePartialEqSlice, ImmutableSlice};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -367,7 +367,7 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<V: Vector<u8>+CloneableVector<u8>>(v: V) -> Vec<u8> {\n+    fn normalize<V: Slice<u8>+CloneableVector<u8>>(v: V) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;"}, {"sha": "8402d751bf2c81f54d1e5cfee784325ee1dd4cc8", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -23,7 +23,7 @@ use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Iterator, Map};\n use mem;\n use option::{Option, Some, None};\n-use slice::{Vector, ImmutableVector};\n+use slice::{Slice, ImmutableSlice};\n use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};\n use string::String;\n use unicode::char::UnicodeChar;"}, {"sha": "eb6dcc1f1a586d250600d8b3fbfd39fa4a97532d", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -83,11 +83,11 @@\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n #[doc(no_inline)] pub use slice::{CloneableVector, ImmutableCloneableVector};\n-#[doc(no_inline)] pub use slice::{MutableCloneableVector, MutableOrdVector};\n-#[doc(no_inline)] pub use slice::{ImmutableVector, MutableVector};\n-#[doc(no_inline)] pub use slice::{ImmutableEqVector, ImmutableOrdVector};\n-#[doc(no_inline)] pub use slice::{Vector, VectorVector};\n-#[doc(no_inline)] pub use slice::MutableVectorAllocating;\n+#[doc(no_inline)] pub use slice::{MutableCloneableSlice, MutableOrdSlice};\n+#[doc(no_inline)] pub use slice::{ImmutableSlice, MutableSlice};\n+#[doc(no_inline)] pub use slice::{ImmutablePartialEqSlice, ImmutableOrdSlice};\n+#[doc(no_inline)] pub use slice::{Slice, VectorVector};\n+#[doc(no_inline)] pub use slice::MutableSliceAllocating;\n #[doc(no_inline)] pub use string::String;\n #[doc(no_inline)] pub use vec::Vec;\n "}, {"sha": "2be4129883f7421aa9ee966140e7a03adc4bac4b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -70,7 +70,7 @@ mod imp {\n     use rand::Rng;\n     use result::{Ok};\n     use self::libc::{c_int, size_t};\n-    use slice::MutableVector;\n+    use slice::MutableSlice;\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -138,7 +138,7 @@ mod imp {\n     use rt::stack;\n     use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n     use self::libc::types::os::arch::extra::{LONG_PTR};\n-    use slice::MutableVector;\n+    use slice::MutableSlice;\n \n     type HCRYPTPROV = LONG_PTR;\n "}, {"sha": "a4491b2ab1d4695f3e467205c1d8e31694c11d70", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -258,7 +258,7 @@ mod imp {\n     pub fn write(w: &mut Writer) -> IoResult<()> {\n         use iter::{Iterator, range};\n         use result;\n-        use slice::{MutableVector};\n+        use slice::{MutableSlice};\n \n         extern {\n             fn backtrace(buf: *mut *mut libc::c_void,\n@@ -398,7 +398,7 @@ mod imp {\n         use path::GenericPath;\n         use ptr::RawPtr;\n         use ptr;\n-        use slice::{ImmutableVector, MutableVector};\n+        use slice::{ImmutableSlice, MutableSlice};\n \n         ////////////////////////////////////////////////////////////////////////\n         // libbacktrace.h API\n@@ -670,7 +670,7 @@ mod imp {\n     use path::Path;\n     use result::{Ok, Err};\n     use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use slice::ImmutableVector;\n+    use slice::ImmutableSlice;\n     use str::StrSlice;\n     use dynamic_lib::DynamicLibrary;\n "}, {"sha": "67605360a48cb665d1b4621aca5650012f4b174f", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -51,7 +51,7 @@ impl fmt::Show for CrateId {\n \n impl FromStr for CrateId {\n     fn from_str(s: &str) -> Option<CrateId> {\n-        let pieces: Vec<&str> = s.splitn('#', 1).collect();\n+        let pieces: Vec<&str> = s.splitn(1, '#').collect();\n         let path = pieces.get(0).to_string();\n \n         if path.as_slice().starts_with(\"/\") || path.as_slice().ends_with(\"/\") ||\n@@ -60,15 +60,15 @@ impl FromStr for CrateId {\n         }\n \n         let path_pieces: Vec<&str> = path.as_slice()\n-                                         .rsplitn('/', 1)\n+                                         .rsplitn(1, '/')\n                                          .collect();\n         let inferred_name = *path_pieces.get(0);\n \n         let (name, version) = if pieces.len() == 1 {\n             (inferred_name.to_string(), None)\n         } else {\n             let hash_pieces: Vec<&str> = pieces.get(1)\n-                                               .splitn(':', 1)\n+                                               .splitn(1, ':')\n                                                .collect();\n             let (hash_name, hash_version) = if hash_pieces.len() == 1 {\n                 (\"\", *hash_pieces.get(0))"}, {"sha": "a60e95c38272bf4f08c071587cc23a7a99a991d9", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -15,20 +15,21 @@\n \n use core::cmp::{Equal, Less, Greater};\n use core::option::{Option, Some, None};\n-use core::slice::ImmutableVector;\n+use core::slice;\n+use core::slice::ImmutableSlice;\n use tables::normalization::{canonical_table, compatibility_table, composition_table};\n \n fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'static [T]> {\n-    match r.bsearch(|&(val, _)| {\n+    match r.binary_search(|&(val, _)| {\n         if c == val { Equal }\n         else if val < c { Less }\n         else { Greater }\n     }) {\n-        Some(idx) => {\n+        slice::Found(idx) => {\n             let (_, result) = r[idx];\n             Some(result)\n         }\n-        None => None\n+        slice::NotFound(_) => None\n     }\n }\n \n@@ -82,16 +83,16 @@ pub fn compose(a: char, b: char) -> Option<char> {\n         match bsearch_table(a, composition_table) {\n             None => None,\n             Some(candidates) => {\n-                match candidates.bsearch(|&(val, _)| {\n+                match candidates.binary_search(|&(val, _)| {\n                     if b == val { Equal }\n                     else if val < b { Less }\n                     else { Greater }\n                 }) {\n-                    Some(idx) => {\n+                    slice::Found(idx) => {\n                         let (_, result) = candidates[idx];\n                         Some(result)\n                     }\n-                    None => None\n+                    slice::NotFound(_) => None\n                 }\n             }\n         }"}, {"sha": "d6010cd8d7bfbbd467664ccb9b1c237e2d44cf1e", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -14,13 +14,12 @@\n \n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableVector;\n-    use core::option::None;\n-    r.bsearch(|&(lo,hi)| {\n+    use core::slice::ImmutableSlice;\n+    r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n         else { Greater }\n-    }) != None\n+    }).found().is_some()\n }\n \n pub mod general_category {\n@@ -6228,19 +6227,19 @@ pub mod normalization {\n \n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use core::option::{Some, None};\n         use core::cmp::{Equal, Less, Greater};\n-        use core::slice::ImmutableVector;\n-        match r.bsearch(|&(lo, hi, _)| {\n+        use core::slice::ImmutableSlice;\n+        use core::slice;\n+        match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, result) = r[idx];\n                 result\n             }\n-            None => 0\n+            slice::NotFound(_) => 0\n         }\n     }\n \n@@ -6354,9 +6353,10 @@ pub mod normalization {\n \n pub mod conversions {\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableVector;\n+    use core::slice::ImmutableSlice;\n     use core::tuple::Tuple2;\n     use core::option::{Option, Some, None};\n+    use core::slice;\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n@@ -6373,11 +6373,14 @@ pub mod conversions {\n     }\n \n     fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n-        table.bsearch(|&(key, _)| {\n+        match table.binary_search(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n             else { Greater }\n-        })\n+        }) {\n+            slice::Found(i) => Some(i),\n+            slice::NotFound(_) => None,\n+        }\n     }\n \n     static LuLl_table: &'static [(char, char)] = &[\n@@ -6915,20 +6918,21 @@ pub mod conversions {\n \n pub mod charwidth {\n     use core::option::{Option, Some, None};\n-    use core::slice::ImmutableVector;\n+    use core::slice::ImmutableSlice;\n+    use core::slice;\n \n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n         use core::cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _, _)| {\n+        match r.binary_search(|&(lo, hi, _, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, r_ncjk, r_cjk) = r[idx];\n                 if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            None => 1\n+            slice::NotFound(_) => 1\n         }\n     }\n \n@@ -7112,8 +7116,8 @@ pub mod charwidth {\n }\n \n pub mod grapheme {\n-    use core::option::{Some, None};\n-    use core::slice::ImmutableVector;\n+    use core::slice::ImmutableSlice;\n+    use core::slice;\n \n     #[allow(non_camel_case_types)]\n     #[deriving(Clone)]\n@@ -7132,16 +7136,16 @@ pub mod grapheme {\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _)| {\n+        match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, cat) = r[idx];\n                 cat\n             }\n-            None => GC_Any\n+            slice::NotFound(_) => GC_Any\n         }\n     }\n "}, {"sha": "9ced6cb62af00f0c310167f6720f498782f9db30", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/385c39a77b238df9371ee8bccc768b8d39258edd/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=385c39a77b238df9371ee8bccc768b8d39258edd", "patch": "@@ -396,7 +396,7 @@ pub fn decode_form_urlencoded(s: &[u8])\n }\n \n fn split_char_first(s: &str, c: char) -> (&str, &str) {\n-    let mut iter = s.splitn(c, 1);\n+    let mut iter = s.splitn(1, c);\n \n     match (iter.next(), iter.next()) {\n         (Some(a), Some(b)) => (a, b),"}]}