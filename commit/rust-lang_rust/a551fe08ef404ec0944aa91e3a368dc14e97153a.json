{"sha": "a551fe08ef404ec0944aa91e3a368dc14e97153a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NTFmZTA4ZWY0MDRlYzA5NDRhYTkxZTNhMzY4ZGMxNGU5NzE1M2E=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:51:45Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:51:45Z"}, "message": "typeck/expr.rs: move check_expr_with_expectation_and_needs here.", "tree": {"sha": "61b8390cf5b3168d107708090e2e7e1ca7c8638d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61b8390cf5b3168d107708090e2e7e1ca7c8638d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a551fe08ef404ec0944aa91e3a368dc14e97153a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a551fe08ef404ec0944aa91e3a368dc14e97153a", "html_url": "https://github.com/rust-lang/rust/commit/a551fe08ef404ec0944aa91e3a368dc14e97153a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a551fe08ef404ec0944aa91e3a368dc14e97153a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fd2d12c2593e0b93cdb55aa7454a1ee35702b4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd2d12c2593e0b93cdb55aa7454a1ee35702b4c", "html_url": "https://github.com/rust-lang/rust/commit/8fd2d12c2593e0b93cdb55aa7454a1ee35702b4c"}], "stats": {"total": 120, "additions": 60, "deletions": 60}, "files": [{"sha": "f5102ae33c6dbe03a083fac302d61f0c0c32b571", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a551fe08ef404ec0944aa91e3a368dc14e97153a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a551fe08ef404ec0944aa91e3a368dc14e97153a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a551fe08ef404ec0944aa91e3a368dc14e97153a", "patch": "@@ -34,7 +34,66 @@ use rustc::ty::subst::InternalSubsts;\n use rustc::traits::{self, ObligationCauseCode};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub(super) fn check_expr_kind(\n+    /// Invariant:\n+    /// If an expression has any sub-expressions that result in a type error,\n+    /// inspecting that expression's type with `ty.references_error()` will return\n+    /// true. Likewise, if an expression is known to diverge, inspecting its\n+    /// type with `ty::type_is_bot` will return true (n.b.: since Rust is\n+    /// strict, _|_ can appear in the type of an expression that does not,\n+    /// itself, diverge: for example, fn() -> _|_.)\n+    /// Note that inspecting a type's structure *directly* may expose the fact\n+    /// that there are actually multiple representations for `Error`, so avoid\n+    /// that when err needs to be handled differently.\n+    pub(super) fn check_expr_with_expectation_and_needs(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n+        debug!(\">> type-checking: expr={:?} expected={:?}\",\n+               expr, expected);\n+\n+        // Warn for expressions after diverging siblings.\n+        self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n+\n+        // Hide the outer diverging and has_errors flags.\n+        let old_diverges = self.diverges.get();\n+        let old_has_errors = self.has_errors.get();\n+        self.diverges.set(Diverges::Maybe);\n+        self.has_errors.set(false);\n+\n+        let ty = self.check_expr_kind(expr, expected, needs);\n+\n+        // Warn for non-block expressions with diverging children.\n+        match expr.node {\n+            ExprKind::Block(..) |\n+            ExprKind::Loop(..) | ExprKind::While(..) |\n+            ExprKind::Match(..) => {}\n+\n+            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n+        }\n+\n+        // Any expression that produces a value of type `!` must have diverged\n+        if ty.is_never() {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+        }\n+\n+        // Record the type, which applies it effects.\n+        // We need to do this after the warning above, so that\n+        // we don't warn for the diverging expression itself.\n+        self.write_ty(expr.hir_id, ty);\n+\n+        // Combine the diverging and has_error flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n+\n+        debug!(\"type of {} is...\", self.tcx.hir().hir_to_string(expr.hir_id));\n+        debug!(\"... {:?}, expected is {:?}\", ty, expected);\n+\n+        ty\n+    }\n+\n+    fn check_expr_kind(\n         &self,\n         expr: &'tcx hir::Expr,\n         expected: Expectation<'tcx>,"}, {"sha": "8a3518c24dab66ef225d8599299cf5fb15b21843", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a551fe08ef404ec0944aa91e3a368dc14e97153a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a551fe08ef404ec0944aa91e3a368dc14e97153a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a551fe08ef404ec0944aa91e3a368dc14e97153a", "patch": "@@ -3864,65 +3864,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Invariant:\n-    /// If an expression has any sub-expressions that result in a type error,\n-    /// inspecting that expression's type with `ty.references_error()` will return\n-    /// true. Likewise, if an expression is known to diverge, inspecting its\n-    /// type with `ty::type_is_bot` will return true (n.b.: since Rust is\n-    /// strict, _|_ can appear in the type of an expression that does not,\n-    /// itself, diverge: for example, fn() -> _|_.)\n-    /// Note that inspecting a type's structure *directly* may expose the fact\n-    /// that there are actually multiple representations for `Error`, so avoid\n-    /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_needs(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-        needs: Needs,\n-    ) -> Ty<'tcx> {\n-        debug!(\">> type-checking: expr={:?} expected={:?}\",\n-               expr, expected);\n-\n-        // Warn for expressions after diverging siblings.\n-        self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n-\n-        // Hide the outer diverging and has_errors flags.\n-        let old_diverges = self.diverges.get();\n-        let old_has_errors = self.has_errors.get();\n-        self.diverges.set(Diverges::Maybe);\n-        self.has_errors.set(false);\n-\n-        let ty = self.check_expr_kind(expr, expected, needs);\n-\n-        // Warn for non-block expressions with diverging children.\n-        match expr.node {\n-            ExprKind::Block(..) |\n-            ExprKind::Loop(..) | ExprKind::While(..) |\n-            ExprKind::Match(..) => {}\n-\n-            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n-        }\n-\n-        // Any expression that produces a value of type `!` must have diverged\n-        if ty.is_never() {\n-            self.diverges.set(self.diverges.get() | Diverges::Always);\n-        }\n-\n-        // Record the type, which applies it effects.\n-        // We need to do this after the warning above, so that\n-        // we don't warn for the diverging expression itself.\n-        self.write_ty(expr.hir_id, ty);\n-\n-        // Combine the diverging and has_error flags.\n-        self.diverges.set(self.diverges.get() | old_diverges);\n-        self.has_errors.set(self.has_errors.get() | old_has_errors);\n-\n-        debug!(\"type of {} is...\", self.tcx.hir().hir_to_string(expr.hir_id));\n-        debug!(\"... {:?}, expected is {:?}\", ty, expected);\n-\n-        ty\n-    }\n-\n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,"}]}