{"sha": "bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "node_id": "C_kwDOAAsO6NoAKGJmNTdlOGFkYTZkYzYyMzY5ZDFjZWU3YWIwNTVmYjQwNzRiZDJkMTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-28T12:50:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-28T12:50:01Z"}, "message": "Auto merge of #108080 - oli-obk:FnPtr-trait, r=lcnr\n\nAdd a builtin `FnPtr` trait that is implemented for all function pointers\n\nr? `@ghost`\n\nRebased version of https://github.com/rust-lang/rust/pull/99531 (plus adjustments mentioned in the PR).\n\nIf perf is happy with this version, I would like to land it, even if the diagnostics fix in 9df8e1befb5031a5bf9d8dfe25170620642d3c59 only works for `FnPtr` specifically, and does not generally improve blanket impls.", "tree": {"sha": "21cb8bce941e422c139fe496537d8ab823fadccc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21cb8bce941e422c139fe496537d8ab823fadccc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "html_url": "https://github.com/rust-lang/rust/commit/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60660371efe59dfc99644e9d709a1b71e25ae2ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/60660371efe59dfc99644e9d709a1b71e25ae2ac", "html_url": "https://github.com/rust-lang/rust/commit/60660371efe59dfc99644e9d709a1b71e25ae2ac"}, {"sha": "5ae6caa0f04c686f0cc8a330f54390131148f899", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae6caa0f04c686f0cc8a330f54390131148f899", "html_url": "https://github.com/rust-lang/rust/commit/5ae6caa0f04c686f0cc8a330f54390131148f899"}], "stats": {"total": 656, "additions": 476, "deletions": 180}, "files": [{"sha": "54d67bd1f29dc58dffcce82d56da4e16e5764d51", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -382,6 +382,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::FnPtrShim(..)\n             | ty::InstanceDef::DropGlue(..)\n             | ty::InstanceDef::CloneShim(..)\n+            | ty::InstanceDef::FnPtrAddrShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n                 let Some((body, instance)) ="}, {"sha": "07faecdb6a7a1bb398198900a767050ea5c363ed", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -166,6 +166,9 @@ language_item_table! {\n \n     Freeze,                  sym::freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n \n+    FnPtrTrait,              sym::fn_ptr_trait,        fn_ptr_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    FnPtrAddr,               sym::fn_ptr_addr,         fn_ptr_addr,                Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n     Drop,                    sym::drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n     Destruct,                sym::destruct,            destruct_trait,             Target::Trait,          GenericRequirement::None;\n "}, {"sha": "90397f01bc8148c958e65d8aa4d527b1b459f675", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -381,7 +381,8 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             | InstanceDef::Virtual(..)\n                             | InstanceDef::ClosureOnceShim { .. }\n                             | InstanceDef::DropGlue(..)\n-                            | InstanceDef::CloneShim(..) => None,\n+                            | InstanceDef::CloneShim(..)\n+                            | InstanceDef::FnPtrAddrShim(..) => None,\n                         }\n                     }\n                     MonoItem::Static(def_id) => def_id.as_local().map(Idx::index),"}, {"sha": "9b31ad783fc35226c5508ff9827b718cf6c5bcaf", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -340,7 +340,8 @@ macro_rules! make_mir_visitor {\n \n                         ty::InstanceDef::FnPtrShim(_def_id, ty) |\n                         ty::InstanceDef::DropGlue(_def_id, Some(ty)) |\n-                        ty::InstanceDef::CloneShim(_def_id, ty) => {\n+                        ty::InstanceDef::CloneShim(_def_id, ty) |\n+                        ty::InstanceDef::FnPtrAddrShim(_def_id, ty) => {\n                             // FIXME(eddyb) use a better `TyContext` here.\n                             self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                         }"}, {"sha": "036b447767971ae056361ed014adbdf8f333ed48", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -96,6 +96,13 @@ pub enum InstanceDef<'tcx> {\n     ///\n     /// The `DefId` is for `Clone::clone`, the `Ty` is the type `T` with the builtin `Clone` impl.\n     CloneShim(DefId, Ty<'tcx>),\n+\n+    /// Compiler-generated `<T as FnPtr>::addr` implementation.\n+    ///\n+    /// Automatically generated for all potentially higher-ranked `fn(I) -> R` types.\n+    ///\n+    /// The `DefId` is for `FnPtr::addr`, the `Ty` is the type `T`.\n+    FnPtrAddrShim(DefId, Ty<'tcx>),\n }\n \n impl<'tcx> Instance<'tcx> {\n@@ -151,7 +158,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::Intrinsic(def_id)\n             | InstanceDef::ClosureOnceShim { call_once: def_id, track_caller: _ }\n             | InstanceDef::DropGlue(def_id, _)\n-            | InstanceDef::CloneShim(def_id, _) => def_id,\n+            | InstanceDef::CloneShim(def_id, _)\n+            | InstanceDef::FnPtrAddrShim(def_id, _) => def_id,\n         }\n     }\n \n@@ -167,7 +175,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::Intrinsic(..)\n             | InstanceDef::ClosureOnceShim { .. }\n             | InstanceDef::DropGlue(..)\n-            | InstanceDef::CloneShim(..) => None,\n+            | InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrAddrShim(..) => None,\n         }\n     }\n \n@@ -182,7 +191,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::Intrinsic(def_id)\n             | InstanceDef::ClosureOnceShim { call_once: def_id, track_caller: _ }\n             | InstanceDef::DropGlue(def_id, _)\n-            | InstanceDef::CloneShim(def_id, _) => ty::WithOptConstParam::unknown(def_id),\n+            | InstanceDef::CloneShim(def_id, _)\n+            | InstanceDef::FnPtrAddrShim(def_id, _) => ty::WithOptConstParam::unknown(def_id),\n         }\n     }\n \n@@ -268,6 +278,7 @@ impl<'tcx> InstanceDef<'tcx> {\n     pub fn has_polymorphic_mir_body(&self) -> bool {\n         match *self {\n             InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrAddrShim(..)\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::DropGlue(_, Some(_)) => false,\n             InstanceDef::ClosureOnceShim { .. }\n@@ -306,6 +317,7 @@ fn fmt_instance(\n         InstanceDef::DropGlue(_, None) => write!(f, \" - shim(None)\"),\n         InstanceDef::DropGlue(_, Some(ty)) => write!(f, \" - shim(Some({}))\", ty),\n         InstanceDef::CloneShim(_, ty) => write!(f, \" - shim({})\", ty),\n+        InstanceDef::FnPtrAddrShim(_, ty) => write!(f, \" - shim({})\", ty),\n     }\n }\n "}, {"sha": "c9dd3e499a8c0dbffd35829e3f0bdc52dca319d7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 29, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -2279,76 +2279,56 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns `true` if the impls are the same polarity and the trait either\n     /// has no items or is annotated `#[marker]` and prevents item overrides.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub fn impls_are_allowed_to_overlap(\n         self,\n         def_id1: DefId,\n         def_id2: DefId,\n     ) -> Option<ImplOverlapKind> {\n+        let impl_trait_ref1 = self.impl_trait_ref(def_id1);\n+        let impl_trait_ref2 = self.impl_trait_ref(def_id2);\n         // If either trait impl references an error, they're allowed to overlap,\n         // as one of them essentially doesn't exist.\n-        if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.subst_identity().references_error())\n-            || self\n-                .impl_trait_ref(def_id2)\n-                .map_or(false, |tr| tr.subst_identity().references_error())\n+        if impl_trait_ref1.map_or(false, |tr| tr.subst_identity().references_error())\n+            || impl_trait_ref2.map_or(false, |tr| tr.subst_identity().references_error())\n         {\n             return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n \n         match (self.impl_polarity(def_id1), self.impl_polarity(def_id2)) {\n             (ImplPolarity::Reservation, _) | (_, ImplPolarity::Reservation) => {\n                 // `#[rustc_reservation_impl]` impls don't overlap with anything\n-                debug!(\n-                    \"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (reservations)\",\n-                    def_id1, def_id2\n-                );\n                 return Some(ImplOverlapKind::Permitted { marker: false });\n             }\n             (ImplPolarity::Positive, ImplPolarity::Negative)\n             | (ImplPolarity::Negative, ImplPolarity::Positive) => {\n                 // `impl AutoTrait for Type` + `impl !AutoTrait for Type`\n-                debug!(\n-                    \"impls_are_allowed_to_overlap({:?}, {:?}) - None (differing polarities)\",\n-                    def_id1, def_id2\n-                );\n                 return None;\n             }\n             (ImplPolarity::Positive, ImplPolarity::Positive)\n             | (ImplPolarity::Negative, ImplPolarity::Negative) => {}\n         };\n \n         let is_marker_overlap = {\n-            let is_marker_impl = |def_id: DefId| -> bool {\n-                let trait_ref = self.impl_trait_ref(def_id);\n+            let is_marker_impl = |trait_ref: Option<EarlyBinder<TraitRef<'_>>>| -> bool {\n                 trait_ref.map_or(false, |tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n             };\n-            is_marker_impl(def_id1) && is_marker_impl(def_id2)\n+            is_marker_impl(impl_trait_ref1) && is_marker_impl(impl_trait_ref2)\n         };\n \n         if is_marker_overlap {\n-            debug!(\n-                \"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (marker overlap)\",\n-                def_id1, def_id2\n-            );\n             Some(ImplOverlapKind::Permitted { marker: true })\n         } else {\n             if let Some(self_ty1) = self.issue33140_self_ty(def_id1) {\n                 if let Some(self_ty2) = self.issue33140_self_ty(def_id2) {\n                     if self_ty1 == self_ty2 {\n-                        debug!(\n-                            \"impls_are_allowed_to_overlap({:?}, {:?}) - issue #33140 HACK\",\n-                            def_id1, def_id2\n-                        );\n                         return Some(ImplOverlapKind::Issue33140);\n                     } else {\n-                        debug!(\n-                            \"impls_are_allowed_to_overlap({:?}, {:?}) - found {:?} != {:?}\",\n-                            def_id1, def_id2, self_ty1, self_ty2\n-                        );\n+                        debug!(\"found {self_ty1:?} != {self_ty2:?}\");\n                     }\n                 }\n             }\n \n-            debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) = None\", def_id1, def_id2);\n             None\n         }\n     }\n@@ -2405,7 +2385,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             | ty::InstanceDef::Virtual(..)\n             | ty::InstanceDef::ClosureOnceShim { .. }\n             | ty::InstanceDef::DropGlue(..)\n-            | ty::InstanceDef::CloneShim(..) => self.mir_shims(instance),\n+            | ty::InstanceDef::CloneShim(..)\n+            | ty::InstanceDef::FnPtrAddrShim(..) => self.mir_shims(instance),\n         }\n     }\n "}, {"sha": "b69186c9451e4b3ef38906701c2b413c2b172a70", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -270,7 +270,8 @@ impl<'tcx> Inliner<'tcx> {\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::ClosureOnceShim { .. }\n             | InstanceDef::DropGlue(..)\n-            | InstanceDef::CloneShim(..) => return Ok(()),\n+            | InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrAddrShim(..) => return Ok(()),\n         }\n \n         if self.tcx.is_constructor(callee_def_id) {"}, {"sha": "faf404c77715b0df9f134275bc1c738ac79053ba", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -84,6 +84,9 @@ pub(crate) fn mir_callgraph_reachable<'tcx>(\n                 | InstanceDef::FnPtrShim(..)\n                 | InstanceDef::ClosureOnceShim { .. }\n                 | InstanceDef::CloneShim(..) => {}\n+\n+                // This shim does not call any other functions, thus there can be no recursion.\n+                InstanceDef::FnPtrAddrShim(..) => continue,\n                 InstanceDef::DropGlue(..) => {\n                     // FIXME: A not fully substituted drop shim can cause ICEs if one attempts to\n                     // have its MIR built. Likely oli-obk just screwed up the `ParamEnv`s, so this"}, {"sha": "06a6deeee43e40ebf2956b6116fa32333dc24042", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -77,6 +77,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n             build_drop_shim(tcx, def_id, ty)\n         }\n         ty::InstanceDef::CloneShim(def_id, ty) => build_clone_shim(tcx, def_id, ty),\n+        ty::InstanceDef::FnPtrAddrShim(def_id, ty) => build_fn_ptr_addr_shim(tcx, def_id, ty),\n         ty::InstanceDef::Virtual(..) => {\n             bug!(\"InstanceDef::Virtual ({:?}) is for direct calls only\", instance)\n         }\n@@ -861,3 +862,39 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n \n     body\n }\n+\n+/// ```ignore (pseudo-impl)\n+/// impl FnPtr for fn(u32) {\n+///     fn addr(self) -> usize {\n+///         self as usize\n+///     }\n+/// }\n+/// ```\n+fn build_fn_ptr_addr_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n+    assert!(matches!(self_ty.kind(), ty::FnPtr(..)), \"expected fn ptr, found {self_ty}\");\n+    let span = tcx.def_span(def_id);\n+    let Some(sig) = tcx.fn_sig(def_id).subst(tcx, &[self_ty.into()]).no_bound_vars() else {\n+        span_bug!(span, \"FnPtr::addr with bound vars for `{self_ty}`\");\n+    };\n+    let locals = local_decls_for_sig(&sig, span);\n+\n+    let source_info = SourceInfo::outermost(span);\n+    // FIXME: use `expose_addr` once we figure out whether function pointers have meaningful provenance.\n+    let rvalue = Rvalue::Cast(\n+        CastKind::FnPtrToPtr,\n+        Operand::Move(Place::from(Local::new(1))),\n+        tcx.mk_imm_ptr(tcx.types.unit),\n+    );\n+    let stmt = Statement {\n+        source_info,\n+        kind: StatementKind::Assign(Box::new((Place::return_place(), rvalue))),\n+    };\n+    let statements = vec![stmt];\n+    let start_block = BasicBlockData {\n+        statements,\n+        terminator: Some(Terminator { source_info, kind: TerminatorKind::Return }),\n+        is_cleanup: false,\n+    };\n+    let source = MirSource::from_instance(ty::InstanceDef::FnPtrAddrShim(def_id, self_ty));\n+    new_body(source, IndexVec::from_elem_n(start_block, 1), locals, sig.inputs().len(), span)\n+}"}, {"sha": "8e7012c27748c1796eb9c8d17ce2ffd9c363f9f9", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -974,7 +974,8 @@ fn visit_instance_use<'tcx>(\n         | ty::InstanceDef::ClosureOnceShim { .. }\n         | ty::InstanceDef::Item(..)\n         | ty::InstanceDef::FnPtrShim(..)\n-        | ty::InstanceDef::CloneShim(..) => {\n+        | ty::InstanceDef::CloneShim(..)\n+        | ty::InstanceDef::FnPtrAddrShim(..) => {\n             output.push(create_fn_mono_item(tcx, instance, source));\n         }\n     }"}, {"sha": "64968a76ab55438da5a6b39aa909fd6133508727", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -278,7 +278,8 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n                 | ty::InstanceDef::Intrinsic(..)\n                 | ty::InstanceDef::DropGlue(..)\n                 | ty::InstanceDef::Virtual(..)\n-                | ty::InstanceDef::CloneShim(..) => return None,\n+                | ty::InstanceDef::CloneShim(..)\n+                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n             };\n \n             // If this is a method, we want to put it into the same module as\n@@ -432,7 +433,8 @@ fn mono_item_visibility<'tcx>(\n         | InstanceDef::Intrinsic(..)\n         | InstanceDef::ClosureOnceShim { .. }\n         | InstanceDef::DropGlue(..)\n-        | InstanceDef::CloneShim(..) => return Visibility::Hidden,\n+        | InstanceDef::CloneShim(..)\n+        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n     };\n \n     // The `start_fn` lang item is actually a monomorphized instance of a"}, {"sha": "0ed9935314506a22f1db3e2e00d5681a9a979f68", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -722,6 +722,8 @@ symbols! {\n         fn_mut,\n         fn_once,\n         fn_once_output,\n+        fn_ptr_addr,\n+        fn_ptr_trait,\n         forbid,\n         forget,\n         format,"}, {"sha": "4fb77d795189d548f1ef86976ddebe362a1a0f21", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -153,6 +153,12 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is a `FnPtr` if it is of `FnPtr` type.\n+    fn consider_builtin_fn_ptr_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n     // A callable type (a closure, fn def, or fn ptr) is known to implement the `Fn<A>`\n     // family of traits where `A` is given by the signature of the type.\n     fn consider_builtin_fn_trait_candidates(\n@@ -331,6 +337,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_copy_clone_candidate(self, goal)\n         } else if lang_items.pointer_like() == Some(trait_def_id) {\n             G::consider_builtin_pointer_like_candidate(self, goal)\n+        } else if lang_items.fn_ptr_trait() == Some(trait_def_id) {\n+            G::consider_builtin_fn_ptr_trait_candidate(self, goal)\n         } else if let Some(kind) = self.tcx().fn_trait_kind_from_def_id(trait_def_id) {\n             G::consider_builtin_fn_trait_candidates(self, goal, kind)\n         } else if lang_items.tuple_trait() == Some(trait_def_id) {"}, {"sha": "2b104703aab2ff9430264e636653beb639d33cbc", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -261,6 +261,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         bug!(\"`PointerLike` does not have an associated type: {:?}\", goal);\n     }\n \n+    fn consider_builtin_fn_ptr_trait_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`FnPtr` does not have an associated type: {:?}\", goal);\n+    }\n+\n     fn consider_builtin_fn_trait_candidates(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "718c82c8f1f2847d6e29e282daed0151e5c59d93", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -222,9 +222,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let self_ty = tcx.erase_regions(goal.predicate.self_ty());\n \n         if let Ok(layout) = tcx.layout_of(goal.param_env.and(self_ty))\n-            &&  let usize_layout = tcx.layout_of(ty::ParamEnv::empty().and(tcx.types.usize)).unwrap().layout\n-            && layout.layout.size() == usize_layout.size()\n-            && layout.layout.align().abi == usize_layout.align().abi\n+            && layout.layout.size() == tcx.data_layout.pointer_size\n+            && layout.layout.align().abi == tcx.data_layout.pointer_align.abi\n         {\n             // FIXME: We could make this faster by making a no-constraints response\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n@@ -233,6 +232,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_builtin_fn_ptr_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if let ty::FnPtr(..) = goal.predicate.self_ty().kind() {\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_builtin_fn_trait_candidates(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "b7fafb0dca7a0356ea232308bdf256c2094f2e54", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -411,11 +411,24 @@ fn resolve_negative_obligation<'tcx>(\n     infcx.resolve_regions(&outlives_env).is_empty()\n }\n \n+/// Returns whether all impls which would apply to the `trait_ref`\n+/// e.g. `Ty: Trait<Arg>` are already known in the local crate.\n+///\n+/// This both checks whether any downstream or sibling crates could\n+/// implement it and whether an upstream crate can add this impl\n+/// without breaking backwards compatibility.\n #[instrument(level = \"debug\", skip(tcx), ret)]\n pub fn trait_ref_is_knowable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), Conflict> {\n+    if Some(trait_ref.def_id) == tcx.lang_items().fn_ptr_trait() {\n+        // The only types implementing `FnPtr` are function pointers,\n+        // so if there's no impl of `FnPtr` in the current crate,\n+        // then such an impl will never be added in the future.\n+        return Ok(());\n+    }\n+\n     if orphan_check_trait_ref(trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n         // substitution of this trait-ref."}, {"sha": "234d773d64d7894508b6ccc91e7338d5a4af25ec", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 146, "deletions": 6, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -5,6 +5,8 @@\n //! candidates. See the [rustc dev guide] for more details.\n //!\n //! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n+\n+use hir::def_id::DefId;\n use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n@@ -96,6 +98,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.assemble_candidate_for_tuple(obligation, &mut candidates);\n             } else if lang_items.pointer_like() == Some(def_id) {\n                 self.assemble_candidate_for_ptr_sized(obligation, &mut candidates);\n+            } else if lang_items.fn_ptr_trait() == Some(def_id) {\n+                self.assemble_candidates_for_fn_ptr_trait(obligation, &mut candidates);\n             } else {\n                 if lang_items.clone_trait() == Some(def_id) {\n                     // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n@@ -321,13 +325,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     /// Searches for impls that might apply to `obligation`.\n+    #[instrument(level = \"debug\", skip(self, candidates))]\n     fn assemble_candidates_from_impls(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        debug!(?obligation, \"assemble_candidates_from_impls\");\n-\n         // Essentially any user-written impl will match with an error type,\n         // so creating `ImplCandidates` isn't useful. However, we might\n         // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized`)\n@@ -352,6 +355,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if self.fast_reject_trait_refs(obligation, &impl_trait_ref.0) {\n                     return;\n                 }\n+                if self.reject_fn_ptr_impls(\n+                    impl_def_id,\n+                    obligation,\n+                    impl_trait_ref.skip_binder().self_ty(),\n+                ) {\n+                    return;\n+                }\n \n                 self.infcx.probe(|_| {\n                     if let Ok(_substs) = self.match_impl(impl_def_id, impl_trait_ref, obligation) {\n@@ -362,6 +372,99 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n     }\n \n+    /// The various `impl<T: FnPtr> Trait for T` in libcore are more like builtin impls for all function items\n+    /// and function pointers and less like blanket impls. Rejecting them when they can't possibly apply (because\n+    /// the obligation's self-type does not implement `FnPtr`) avoids reporting that the self type does not implement\n+    /// `FnPtr`, when we wanted to report that it doesn't implement `Trait`.\n+    #[instrument(level = \"trace\", skip(self), ret)]\n+    fn reject_fn_ptr_impls(\n+        &self,\n+        impl_def_id: DefId,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_self_ty: Ty<'tcx>,\n+    ) -> bool {\n+        // Let `impl<T: FnPtr> Trait for Vec<T>` go through the normal rejection path.\n+        if !matches!(impl_self_ty.kind(), ty::Param(..)) {\n+            return false;\n+        }\n+        let Some(fn_ptr_trait) = self.tcx().lang_items().fn_ptr_trait() else {\n+            return false;\n+        };\n+\n+        for &(predicate, _) in self.tcx().predicates_of(impl_def_id).predicates {\n+            let ty::PredicateKind::Clause(ty::Clause::Trait(pred))\n+                = predicate.kind().skip_binder() else { continue };\n+            if fn_ptr_trait != pred.trait_ref.def_id {\n+                continue;\n+            }\n+            trace!(?pred);\n+            // Not the bound we're looking for\n+            if pred.self_ty() != impl_self_ty {\n+                continue;\n+            }\n+\n+            match obligation.self_ty().skip_binder().kind() {\n+                // Fast path to avoid evaluating an obligation that trivally holds.\n+                // There may be more bounds, but these are checked by the regular path.\n+                ty::FnPtr(..) => return false,\n+                // These may potentially implement `FnPtr`\n+                ty::Placeholder(..)\n+                | ty::Dynamic(_, _, _)\n+                | ty::Alias(_, _)\n+                | ty::Infer(_)\n+                | ty::Param(..) => {}\n+\n+                ty::Bound(_, _) => span_bug!(\n+                    obligation.cause.span(),\n+                    \"cannot have escaping bound var in self type of {obligation:#?}\"\n+                ),\n+                // These can't possibly implement `FnPtr` as they are concrete types\n+                // and not `FnPtr`\n+                ty::Bool\n+                | ty::Char\n+                | ty::Int(_)\n+                | ty::Uint(_)\n+                | ty::Float(_)\n+                | ty::Adt(_, _)\n+                | ty::Foreign(_)\n+                | ty::Str\n+                | ty::Array(_, _)\n+                | ty::Slice(_)\n+                | ty::RawPtr(_)\n+                | ty::Ref(_, _, _)\n+                | ty::Closure(_, _)\n+                | ty::Generator(_, _, _)\n+                | ty::GeneratorWitness(_)\n+                | ty::GeneratorWitnessMIR(_, _)\n+                | ty::Never\n+                | ty::Tuple(_)\n+                | ty::Error(_) => return true,\n+                // FIXME: Function definitions could actually implement `FnPtr` by\n+                // casting the ZST function def to a function pointer.\n+                ty::FnDef(_, _) => return true,\n+            }\n+\n+            // Generic params can implement `FnPtr` if the predicate\n+            // holds within its own environment.\n+            let obligation = Obligation::new(\n+                self.tcx(),\n+                obligation.cause.clone(),\n+                obligation.param_env,\n+                self.tcx().mk_predicate(obligation.predicate.map_bound(|mut pred| {\n+                    pred.trait_ref =\n+                        self.tcx().mk_trait_ref(fn_ptr_trait, [pred.trait_ref.self_ty()]);\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(pred))\n+                })),\n+            );\n+            if let Ok(r) = self.infcx.evaluate_obligation(&obligation) {\n+                if !r.may_apply() {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     fn assemble_candidates_from_auto_impls(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -853,13 +956,50 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        let usize_layout =\n-            self.tcx().layout_of(ty::ParamEnv::empty().and(self.tcx().types.usize)).unwrap().layout;\n         if let Ok(layout) = self.tcx().layout_of(obligation.param_env.and(self_ty))\n-            && layout.layout.size() == usize_layout.size()\n-            && layout.layout.align().abi == usize_layout.align().abi\n+            && layout.layout.size() == self.tcx().data_layout.pointer_size\n+            && layout.layout.align().abi == self.tcx().data_layout.pointer_align.abi\n         {\n             candidates.vec.push(BuiltinCandidate { has_nested: false });\n         }\n     }\n+\n+    fn assemble_candidates_for_fn_ptr_trait(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        match self_ty.skip_binder().kind() {\n+            ty::FnPtr(_) => candidates.vec.push(BuiltinCandidate { has_nested: false }),\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(..)\n+            | ty::Foreign(..)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::Placeholder(..)\n+            | ty::Dynamic(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Never\n+            | ty::Tuple(..)\n+            | ty::Alias(..)\n+            | ty::Param(..)\n+            | ty::Bound(..)\n+            | ty::Error(_) => {}\n+            ty::Infer(_) => {\n+                candidates.ambiguous = true;\n+            }\n+        }\n+    }\n }"}, {"sha": "aa5c624f471ff1aff71e9bf7079476934fe7383e", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -21,6 +21,7 @@ pub struct FutureCompatOverlapError<'tcx> {\n }\n \n /// The result of attempting to insert an impl into a group of children.\n+#[derive(Debug)]\n enum Inserted<'tcx> {\n     /// The impl was inserted as a new child in this group of children.\n     BecameNewSibling(Option<FutureCompatOverlapError<'tcx>>),\n@@ -82,6 +83,7 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n \n     /// Attempt to insert an impl into this set of children, while comparing for\n     /// specialization relationships.\n+    #[instrument(level = \"debug\", skip(self, tcx), ret)]\n     fn insert(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n@@ -92,18 +94,13 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n         let mut last_lint = None;\n         let mut replace_children = Vec::new();\n \n-        debug!(\"insert(impl_def_id={:?}, simplified_self={:?})\", impl_def_id, simplified_self,);\n-\n         let possible_siblings = match simplified_self {\n             Some(st) => PotentialSiblings::Filtered(filtered_children(self, st)),\n             None => PotentialSiblings::Unfiltered(iter_children(self)),\n         };\n \n         for possible_sibling in possible_siblings {\n-            debug!(\n-                \"insert: impl_def_id={:?}, simplified_self={:?}, possible_sibling={:?}\",\n-                impl_def_id, simplified_self, possible_sibling,\n-            );\n+            debug!(?possible_sibling);\n \n             let create_overlap_error = |overlap: traits::coherence::OverlapResult<'tcx>| {\n                 let trait_ref = overlap.impl_header.trait_ref.unwrap();"}, {"sha": "ad70154c98efaf48ecc93ce32d262b01956b987e", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -243,7 +243,8 @@ fn resolve_associated_item<'tcx>(\n             }\n         }\n         traits::ImplSource::Builtin(..) => {\n-            if Some(trait_ref.def_id) == tcx.lang_items().clone_trait() {\n+            let lang_items = tcx.lang_items();\n+            if Some(trait_ref.def_id) == lang_items.clone_trait() {\n                 // FIXME(eddyb) use lang items for methods instead of names.\n                 let name = tcx.item_name(trait_item_id);\n                 if name == sym::clone {\n@@ -270,6 +271,22 @@ fn resolve_associated_item<'tcx>(\n                     let substs = tcx.erase_regions(rcvr_substs);\n                     Some(ty::Instance::new(trait_item_id, substs))\n                 }\n+            } else if Some(trait_ref.def_id) == lang_items.fn_ptr_trait() {\n+                if lang_items.fn_ptr_addr() == Some(trait_item_id) {\n+                    let self_ty = trait_ref.self_ty();\n+                    if !matches!(self_ty.kind(), ty::FnPtr(..)) {\n+                        return Ok(None);\n+                    }\n+                    Some(Instance {\n+                        def: ty::InstanceDef::FnPtrAddrShim(trait_item_id, self_ty),\n+                        substs: rcvr_substs,\n+                    })\n+                } else {\n+                    tcx.sess.span_fatal(\n+                        tcx.def_span(trait_item_id),\n+                        \"`FnPtrAddr` trait with unexpected assoc item\",\n+                    )\n+                }\n             } else {\n                 None\n             }"}, {"sha": "74e9c55396d1f54691f2e578b1b8b6073869dc7b", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -922,3 +922,18 @@ mod copy_impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Copy for &T {}\n }\n+\n+/// A common trait implemented by all function pointers.\n+#[unstable(\n+    feature = \"fn_ptr_trait\",\n+    issue = \"none\",\n+    reason = \"internal trait for implementing various traits for all function pointers\"\n+)]\n+#[lang = \"fn_ptr_trait\"]\n+#[cfg(not(bootstrap))]\n+#[rustc_deny_explicit_impl]\n+pub trait FnPtr: Copy + Clone {\n+    /// Returns the address of the function pointer.\n+    #[lang = \"fn_ptr_addr\"]\n+    fn addr(self) -> *const ();\n+}"}, {"sha": "9cdfd2c21cc98d6bd3a0b58755d98d8f6df86ac3", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 161, "deletions": 106, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -1891,150 +1891,205 @@ pub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n     hashee.hash(into);\n }\n \n-// If this is a unary fn pointer, it adds a doc comment.\n-// Otherwise, it hides the docs entirely.\n-macro_rules! maybe_fnptr_doc {\n-    (@ #[$meta:meta] $item:item) => {\n-        #[doc(hidden)]\n-        #[$meta]\n-        $item\n-    };\n-    ($a:ident @ #[$meta:meta] $item:item) => {\n-        #[doc(fake_variadic)]\n-        #[doc = \"This trait is implemented for function pointers with up to twelve arguments.\"]\n-        #[$meta]\n-        $item\n-    };\n-    ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n-        #[doc(hidden)]\n-        #[$meta]\n-        $item\n-    };\n-}\n+#[cfg(bootstrap)]\n+mod old_fn_ptr_impl {\n+    use super::*;\n+    // If this is a unary fn pointer, it adds a doc comment.\n+    // Otherwise, it hides the docs entirely.\n+    macro_rules! maybe_fnptr_doc {\n+        (@ #[$meta:meta] $item:item) => {\n+            #[doc(hidden)]\n+            #[$meta]\n+            $item\n+        };\n+        ($a:ident @ #[$meta:meta] $item:item) => {\n+            #[doc(fake_variadic)]\n+            #[doc = \"This trait is implemented for function pointers with up to twelve arguments.\"]\n+            #[$meta]\n+            $item\n+        };\n+        ($a:ident $($rest_a:ident)+ @ #[$meta:meta] $item:item) => {\n+            #[doc(hidden)]\n+            #[$meta]\n+            $item\n+        };\n+    }\n \n-// FIXME(strict_provenance_magic): function pointers have buggy codegen that\n-// necessitates casting to a usize to get the backend to do the right thing.\n-// for now I will break AVR to silence *a billion* lints. We should probably\n-// have a proper \"opaque function pointer type\" to handle this kind of thing.\n+    // FIXME(strict_provenance_magic): function pointers have buggy codegen that\n+    // necessitates casting to a usize to get the backend to do the right thing.\n+    // for now I will break AVR to silence *a billion* lints. We should probably\n+    // have a proper \"opaque function pointer type\" to handle this kind of thing.\n \n-// Impls for function pointers\n-macro_rules! fnptr_impls_safety_abi {\n-    ($FnTy: ty, $($Arg: ident),*) => {\n+    // Impls for function pointers\n+    macro_rules! fnptr_impls_safety_abi {\n+        ($FnTy: ty, $($Arg: ident),*) => {\n         fnptr_impls_safety_abi! { #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")] $FnTy, $($Arg),* }\n     };\n     (@c_unwind $FnTy: ty, $($Arg: ident),*) => {\n         fnptr_impls_safety_abi! { #[unstable(feature = \"c_unwind\", issue = \"74990\")] $FnTy, $($Arg),* }\n     };\n     (#[$meta:meta] $FnTy: ty, $($Arg: ident),*) => {\n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> PartialEq for $FnTy {\n-                #[inline]\n-                fn eq(&self, other: &Self) -> bool {\n-                    *self as usize == *other as usize\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> PartialEq for $FnTy {\n+                    #[inline]\n+                    fn eq(&self, other: &Self) -> bool {\n+                        *self as usize == *other as usize\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> Eq for $FnTy {}\n-        }\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> Eq for $FnTy {}\n+            }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n-                #[inline]\n-                fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-                    (*self as usize).partial_cmp(&(*other as usize))\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n+                    #[inline]\n+                    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+                        (*self as usize).partial_cmp(&(*other as usize))\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> Ord for $FnTy {\n-                #[inline]\n-                fn cmp(&self, other: &Self) -> Ordering {\n-                    (*self as usize).cmp(&(*other as usize))\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> Ord for $FnTy {\n+                    #[inline]\n+                    fn cmp(&self, other: &Self) -> Ordering {\n+                        (*self as usize).cmp(&(*other as usize))\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n-                fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n-                    state.write_usize(*self as usize)\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n+                    fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n+                        state.write_usize(*self as usize)\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    fmt::pointer_fmt_inner(*self as usize, f)\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n+                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        fmt::pointer_fmt_inner(*self as usize, f)\n+                    }\n                 }\n             }\n-        }\n \n-        maybe_fnptr_doc! {\n-            $($Arg)* @\n-            #[$meta]\n-            impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    fmt::pointer_fmt_inner(*self as usize, f)\n+            maybe_fnptr_doc! {\n+                $($Arg)* @\n+                #[$meta]\n+                impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n+                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        fmt::pointer_fmt_inner(*self as usize, f)\n+                    }\n                 }\n             }\n         }\n     }\n-}\n \n-macro_rules! fnptr_impls_args {\n-    ($($Arg: ident),+) => {\n-        fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n+    macro_rules! fnptr_impls_args {\n+        ($($Arg: ident),+) => {\n+            fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n         fnptr_impls_safety_abi! { @c_unwind extern \"C-unwind\" fn($($Arg),+) -> Ret, $($Arg),+ }\n         fnptr_impls_safety_abi! { @c_unwind extern \"C-unwind\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n-        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n+            fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n         fnptr_impls_safety_abi! { @c_unwind unsafe extern \"C-unwind\" fn($($Arg),+) -> Ret, $($Arg),+ }\n         fnptr_impls_safety_abi! { @c_unwind unsafe extern \"C-unwind\" fn($($Arg),+ , ...) -> Ret, $($Arg),+ }\n-    };\n-    () => {\n-        // No variadic functions with 0 parameters\n-        fnptr_impls_safety_abi! { extern \"Rust\" fn() -> Ret, }\n-        fnptr_impls_safety_abi! { extern \"C\" fn() -> Ret, }\n+        };\n+        () => {\n+            // No variadic functions with 0 parameters\n+            fnptr_impls_safety_abi! { extern \"Rust\" fn() -> Ret, }\n+            fnptr_impls_safety_abi! { extern \"C\" fn() -> Ret, }\n         fnptr_impls_safety_abi! { @c_unwind extern \"C-unwind\" fn() -> Ret, }\n-        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -> Ret, }\n-        fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -> Ret, }\n+            fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -> Ret, }\n+            fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -> Ret, }\n         fnptr_impls_safety_abi! { @c_unwind unsafe extern \"C-unwind\" fn() -> Ret, }\n-    };\n+        };\n+    }\n+\n+    fnptr_impls_args! {}\n+    fnptr_impls_args! { T }\n+    fnptr_impls_args! { A, B }\n+    fnptr_impls_args! { A, B, C }\n+    fnptr_impls_args! { A, B, C, D }\n+    fnptr_impls_args! { A, B, C, D, E }\n+    fnptr_impls_args! { A, B, C, D, E, F }\n+    fnptr_impls_args! { A, B, C, D, E, F, G }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H, I }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\n+    fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n }\n \n-fnptr_impls_args! {}\n-fnptr_impls_args! { T }\n-fnptr_impls_args! { A, B }\n-fnptr_impls_args! { A, B, C }\n-fnptr_impls_args! { A, B, C, D }\n-fnptr_impls_args! { A, B, C, D, E }\n-fnptr_impls_args! { A, B, C, D, E, F }\n-fnptr_impls_args! { A, B, C, D, E, F, G }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H, I }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\n-fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n+#[cfg(not(bootstrap))]\n+mod new_fn_ptr_impl {\n+    use super::*;\n+    use crate::marker::FnPtr;\n+\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> PartialEq for F {\n+        #[inline]\n+        fn eq(&self, other: &Self) -> bool {\n+            self.addr() == other.addr()\n+        }\n+    }\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> Eq for F {}\n+\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> PartialOrd for F {\n+        #[inline]\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            self.addr().partial_cmp(&other.addr())\n+        }\n+    }\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> Ord for F {\n+        #[inline]\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            self.addr().cmp(&other.addr())\n+        }\n+    }\n+\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> hash::Hash for F {\n+        fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n+            state.write_usize(self.addr() as _)\n+        }\n+    }\n+\n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> fmt::Pointer for F {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            fmt::pointer_fmt_inner(self.addr() as _, f)\n+        }\n+    }\n \n+    #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n+    impl<F: FnPtr> fmt::Debug for F {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            fmt::pointer_fmt_inner(self.addr() as _, f)\n+        }\n+    }\n+}\n /// Create a `const` raw pointer to a place, without creating an intermediate reference.\n ///\n /// Creating a reference with `&`/`&mut` is only allowed if the pointer is properly aligned"}, {"sha": "45918ae5b6104fe4412156e3efb568385754a99c", "filename": "tests/ui/fn/fn-ptr-trait.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/tests%2Fui%2Ffn%2Ffn-ptr-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/tests%2Fui%2Ffn%2Ffn-ptr-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-ptr-trait.rs?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -0,0 +1,9 @@\n+#![feature(fn_ptr_trait)]\n+// check-pass\n+\n+use std::marker::FnPtr;\n+\n+trait Foo {}\n+impl<T> Foo for Vec<T> where T: FnPtr {}\n+\n+fn main() {}"}, {"sha": "ac8862716c070e1276de636e5c91c2101ff815f5", "filename": "tests/ui/issues/issue-59488.stderr", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/tests%2Fui%2Fissues%2Fissue-59488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bf57e8ada6dc62369d1cee7ab055fb4074bd2d10/tests%2Fui%2Fissues%2Fissue-59488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-59488.stderr?ref=bf57e8ada6dc62369d1cee7ab055fb4074bd2d10", "patch": "@@ -90,16 +90,6 @@ LL |     assert_eq!(Foo::Bar, i);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ `fn(usize) -> Foo {Foo::Bar}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for fn item `fn(usize) -> Foo {Foo::Bar}`\n-   = help: the following other types implement trait `Debug`:\n-             extern \"C\" fn() -> Ret\n-             extern \"C\" fn(A, B) -> Ret\n-             extern \"C\" fn(A, B, ...) -> Ret\n-             extern \"C\" fn(A, B, C) -> Ret\n-             extern \"C\" fn(A, B, C, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D) -> Ret\n-             extern \"C\" fn(A, B, C, D, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D, E) -> Ret\n-           and 118 others\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: `fn(usize) -> Foo {Foo::Bar}` doesn't implement `Debug`\n@@ -109,16 +99,6 @@ LL |     assert_eq!(Foo::Bar, i);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ `fn(usize) -> Foo {Foo::Bar}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for fn item `fn(usize) -> Foo {Foo::Bar}`\n-   = help: the following other types implement trait `Debug`:\n-             extern \"C\" fn() -> Ret\n-             extern \"C\" fn(A, B) -> Ret\n-             extern \"C\" fn(A, B, ...) -> Ret\n-             extern \"C\" fn(A, B, C) -> Ret\n-             extern \"C\" fn(A, B, C, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D) -> Ret\n-             extern \"C\" fn(A, B, C, D, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D, E) -> Ret\n-           and 118 others\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 10 previous errors"}]}