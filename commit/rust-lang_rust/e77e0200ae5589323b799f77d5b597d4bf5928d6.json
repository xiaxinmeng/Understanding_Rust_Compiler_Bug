{"sha": "e77e0200ae5589323b799f77d5b597d4bf5928d6", "node_id": "C_kwDOAAsO6NoAKGU3N2UwMjAwYWU1NTg5MzIzYjc5OWY3N2Q1YjU5N2Q0YmY1OTI4ZDY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-06T14:29:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-06T14:29:44Z"}, "message": "Rollup merge of #102680 - dtolnay:btreesend, r=thomcc\n\nFix overconstrained Send impls in btree internals\n\nFixes https://github.com/dtolnay/async-trait/issues/215.\n\nMinimal repro:\n\n```rust\nuse std::collections::btree_map::Iter;\n\nfn require_send<T: Send>(_: T) {}\n\nfn main() {\n    require_send(async {\n        let _iter = None::<Iter<(), &()>>;\n        async {}.await;\n    });\n}\n```\n\n```console\nerror: higher-ranked lifetime error\n --> src/main.rs:6:5\n  |\n6 | /     require_send(async {\n7 | |         let _iter = None::<Iter<(), &()>>;\n8 | |         async {}.await;\n9 | |     });\n  | |______^\n  |\n  = note: could not prove `impl Future<Output = ()>: Send`\n```\n\nNot-quite-so-minimal repro:\n\n```rust\nuse std::collections::BTreeMap;\nuse std::future::Future;\n\nfn spawn<T: Future + Send>(_: T) {}\n\nasync fn f() {\n    let map = BTreeMap::<u32, Box<dyn Send + Sync>>::new();\n    for _ in &map {\n        async {}.await;\n    }\n}\n\nfn main() {\n    spawn(f());\n}\n```\n\n```console\nerror: higher-ranked lifetime error\n  --> src/main.rs:14:5\n   |\n14 |     spawn(f());\n   |     ^^^^^^^^^^\n   |\n   = note: could not prove `impl Future<Output = ()>: Send`\n```\n\nI am not familiar with the btree internals, but it seems clear to me that the `async fn f` above should return a Send future. Using HashMap instead of BTreeMap in that code makes it already return a Send future.\n\nThe _\"higher-ranked lifetime error\"_ message may be a regression in Rust 1.63. Using older compilers the error message was more detailed:\n\n```console\nerror: implementation of `Send` is not general enough\n  --> src/main.rs:14:5\n   |\n14 |     spawn(f());\n   |     ^^^^^ implementation of `Send` is not general enough\n   |\n   = note: `Send` would have to be implemented for the type `alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Immut<'0>, u32, Box<(dyn Send + Sync + '1)>, alloc::collections::btree::node::marker::LeafOrInternal>`, for any two lifetimes `'0` and `'1`...\n   = note: ...but `Send` is actually implemented for the type `alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Immut<'2>, u32, Box<dyn Send + Sync>, alloc::collections::btree::node::marker::LeafOrInternal>`, for some specific lifetime `'2`\n\nerror: implementation of `Send` is not general enough\n  --> src/main.rs:14:5\n   |\n14 |     spawn(f());\n   |     ^^^^^ implementation of `Send` is not general enough\n   |\n   = note: `Send` would have to be implemented for the type `alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Immut<'0>, u32, Box<(dyn Send + Sync + '1)>, alloc::collections::btree::node::marker::Leaf>`, for any two lifetimes `'0` and `'1`...\n   = note: ...but `Send` is actually implemented for the type `alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Immut<'2>, u32, Box<dyn Send + Sync>, alloc::collections::btree::node::marker::Leaf>`, for some specific lifetime `'2`\n```", "tree": {"sha": "6fe932632a3a05ba3f0439cb8c20fa0ab2118dd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fe932632a3a05ba3f0439cb8c20fa0ab2118dd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e77e0200ae5589323b799f77d5b597d4bf5928d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjPuZYCRBK7hj4Ov3rIwAASKsIAG75RJ1R6AjGN7XGnb/c79eX\nkpawEj4fwGKAs4JUS1MWv4sscsr5fYvyoR/3apqI58mpDVsPq1wR75qcp6ermTlf\nA7NyptzEqylFwErrVlvVfkrSfWYtk90RJlX1j97dBqsEIvqtv65ct2Tt/mth5gqM\nxWacDiU6WrKrWGU6eH4Lq5p5TN+0A8b94PUMj+R3O0ihrcp6zE3x+4Ve+ztf6vv8\nl0lIXcbZuLU8AF3+NTBNBBlP9LTZp26mm2QEvbrDBYDmrS862c7NKQC3FUuRdlTJ\nbBsBEvHzhrxAoxBeUJpwoN44Uly3Ivi8SirgLFxhQtUqryVI/TqJPDj6UbPlz+o=\n=4uCB\n-----END PGP SIGNATURE-----\n", "payload": "tree 6fe932632a3a05ba3f0439cb8c20fa0ab2118dd4\nparent dd0fa6f871cfbf0d206cd66846bb754cae5c60d3\nparent 4fdd0d96757d1ba4bbba0edeff3c8665f324505b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1665066584 +0200\ncommitter GitHub <noreply@github.com> 1665066584 +0200\n\nRollup merge of #102680 - dtolnay:btreesend, r=thomcc\n\nFix overconstrained Send impls in btree internals\n\nFixes https://github.com/dtolnay/async-trait/issues/215.\n\nMinimal repro:\n\n```rust\nuse std::collections::btree_map::Iter;\n\nfn require_send<T: Send>(_: T) {}\n\nfn main() {\n    require_send(async {\n        let _iter = None::<Iter<(), &()>>;\n        async {}.await;\n    });\n}\n```\n\n```console\nerror: higher-ranked lifetime error\n --> src/main.rs:6:5\n  |\n6 | /     require_send(async {\n7 | |         let _iter = None::<Iter<(), &()>>;\n8 | |         async {}.await;\n9 | |     });\n  | |______^\n  |\n  = note: could not prove `impl Future<Output = ()>: Send`\n```\n\nNot-quite-so-minimal repro:\n\n```rust\nuse std::collections::BTreeMap;\nuse std::future::Future;\n\nfn spawn<T: Future + Send>(_: T) {}\n\nasync fn f() {\n    let map = BTreeMap::<u32, Box<dyn Send + Sync>>::new();\n    for _ in &map {\n        async {}.await;\n    }\n}\n\nfn main() {\n    spawn(f());\n}\n```\n\n```console\nerror: higher-ranked lifetime error\n  --> src/main.rs:14:5\n   |\n14 |     spawn(f());\n   |     ^^^^^^^^^^\n   |\n   = note: could not prove `impl Future<Output = ()>: Send`\n```\n\nI am not familiar with the btree internals, but it seems clear to me that the `async fn f` above should return a Send future. Using HashMap instead of BTreeMap in that code makes it already return a Send future.\n\nThe _\"higher-ranked lifetime error\"_ message may be a regression in Rust 1.63. Using older compilers the error message was more detailed:\n\n```console\nerror: implementation of `Send` is not general enough\n  --> src/main.rs:14:5\n   |\n14 |     spawn(f());\n   |     ^^^^^ implementation of `Send` is not general enough\n   |\n   = note: `Send` would have to be implemented for the type `alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Immut<'0>, u32, Box<(dyn Send + Sync + '1)>, alloc::collections::btree::node::marker::LeafOrInternal>`, for any two lifetimes `'0` and `'1`...\n   = note: ...but `Send` is actually implemented for the type `alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Immut<'2>, u32, Box<dyn Send + Sync>, alloc::collections::btree::node::marker::LeafOrInternal>`, for some specific lifetime `'2`\n\nerror: implementation of `Send` is not general enough\n  --> src/main.rs:14:5\n   |\n14 |     spawn(f());\n   |     ^^^^^ implementation of `Send` is not general enough\n   |\n   = note: `Send` would have to be implemented for the type `alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Immut<'0>, u32, Box<(dyn Send + Sync + '1)>, alloc::collections::btree::node::marker::Leaf>`, for any two lifetimes `'0` and `'1`...\n   = note: ...but `Send` is actually implemented for the type `alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Immut<'2>, u32, Box<dyn Send + Sync>, alloc::collections::btree::node::marker::Leaf>`, for some specific lifetime `'2`\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e77e0200ae5589323b799f77d5b597d4bf5928d6", "html_url": "https://github.com/rust-lang/rust/commit/e77e0200ae5589323b799f77d5b597d4bf5928d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e77e0200ae5589323b799f77d5b597d4bf5928d6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "html_url": "https://github.com/rust-lang/rust/commit/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3"}, {"sha": "4fdd0d96757d1ba4bbba0edeff3c8665f324505b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdd0d96757d1ba4bbba0edeff3c8665f324505b", "html_url": "https://github.com/rust-lang/rust/commit/4fdd0d96757d1ba4bbba0edeff3c8665f324505b"}], "stats": {"total": 303, "additions": 300, "deletions": 3}, "files": [{"sha": "da766b67a328f6b0a0356c28d397005768ff8935", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e77e0200ae5589323b799f77d5b597d4bf5928d6/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77e0200ae5589323b799f77d5b597d4bf5928d6/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=e77e0200ae5589323b799f77d5b597d4bf5928d6", "patch": "@@ -206,9 +206,9 @@ impl<'a, K: 'a, V: 'a, Type> Clone for NodeRef<marker::Immut<'a>, K, V, Type> {\n \n unsafe impl<BorrowType, K: Sync, V: Sync, Type> Sync for NodeRef<BorrowType, K, V, Type> {}\n \n-unsafe impl<'a, K: Sync + 'a, V: Sync + 'a, Type> Send for NodeRef<marker::Immut<'a>, K, V, Type> {}\n-unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'a>, K, V, Type> {}\n-unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMut<'a>, K, V, Type> {}\n+unsafe impl<K: Sync, V: Sync, Type> Send for NodeRef<marker::Immut<'_>, K, V, Type> {}\n+unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Mut<'_>, K, V, Type> {}\n+unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::ValMut<'_>, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Dying, K, V, Type> {}\n "}, {"sha": "8ff5f0abe73dd013aa31bc76d3d03f6475c97816", "filename": "library/alloc/tests/autotraits.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/e77e0200ae5589323b799f77d5b597d4bf5928d6/library%2Falloc%2Ftests%2Fautotraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77e0200ae5589323b799f77d5b597d4bf5928d6/library%2Falloc%2Ftests%2Fautotraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fautotraits.rs?ref=e77e0200ae5589323b799f77d5b597d4bf5928d6", "patch": "@@ -0,0 +1,293 @@\n+fn require_sync<T: Sync>(_: T) {}\n+fn require_send_sync<T: Send + Sync>(_: T) {}\n+\n+struct NotSend(*const ());\n+unsafe impl Sync for NotSend {}\n+\n+#[test]\n+fn test_btree_map() {\n+    // Tests of this form are prone to https://github.com/rust-lang/rust/issues/64552.\n+    //\n+    // In theory the async block's future would be Send if the value we hold\n+    // across the await point is Send, and Sync if the value we hold across the\n+    // await point is Sync.\n+    //\n+    // We test autotraits in this convoluted way, instead of a straightforward\n+    // `require_send_sync::<TypeIWantToTest>()`, because the interaction with\n+    // generators exposes some current limitations in rustc's ability to prove a\n+    // lifetime bound on the erased generator witness types. See the above link.\n+    //\n+    // A typical way this would surface in real code is:\n+    //\n+    //     fn spawn<T: Future + Send>(_: T) {}\n+    //\n+    //     async fn f() {\n+    //         let map = BTreeMap::<u32, Box<dyn Send + Sync>>::new();\n+    //         for _ in &map {\n+    //             async {}.await;\n+    //         }\n+    //     }\n+    //\n+    //     fn main() {\n+    //         spawn(f());\n+    //     }\n+    //\n+    // where with some unintentionally overconstrained Send impls in liballoc's\n+    // internals, the future might incorrectly not be Send even though every\n+    // single type involved in the program is Send and Sync.\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    // Testing like this would not catch all issues that the above form catches.\n+    require_send_sync(None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>);\n+\n+    require_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Iter<'_, u32, NotSend>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::BTreeMap<&u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<\n+            alloc::collections::btree_map::DrainFilter<\n+                '_,\n+                &u32,\n+                &u32,\n+                fn(&&u32, &mut &u32) -> bool,\n+            >,\n+        >;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Entry<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::IntoIter<&u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::IntoKeys<&u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::IntoValues<&u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Iter<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::IterMut<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Keys<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::OccupiedEntry<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::OccupiedError<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Range<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::RangeMut<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::VacantEntry<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::Values<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_map::ValuesMut<'_, &u32, &u32>>;\n+        async {}.await;\n+    });\n+}\n+\n+#[test]\n+fn test_btree_set() {\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::BTreeSet<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Difference<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::DrainFilter<'_, &u32, fn(&&u32) -> bool>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Intersection<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::IntoIter<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Iter<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Range<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::SymmetricDifference<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::btree_set::Union<'_, &u32>>;\n+        async {}.await;\n+    });\n+}\n+\n+#[test]\n+fn test_binary_heap() {\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::BinaryHeap<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::Drain<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::DrainSorted<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::IntoIter<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::IntoIterSorted<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::Iter<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::binary_heap::PeekMut<'_, &u32>>;\n+        async {}.await;\n+    });\n+}\n+\n+#[test]\n+fn test_linked_list() {\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::Cursor<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::CursorMut<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    // FIXME\n+    /*\n+    require_send_sync(async {\n+        let _v =\n+            None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n+        async {}.await;\n+    });\n+    */\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::IntoIter<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::Iter<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::IterMut<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::linked_list::LinkedList<&u32>>;\n+        async {}.await;\n+    });\n+}\n+\n+#[test]\n+fn test_vec_deque() {\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::Drain<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::IntoIter<&u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::Iter<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::IterMut<'_, &u32>>;\n+        async {}.await;\n+    });\n+\n+    require_send_sync(async {\n+        let _v = None::<alloc::collections::vec_deque::VecDeque<&u32>>;\n+        async {}.await;\n+    });\n+}"}, {"sha": "ffc5ca7a5c6cc1de574f8a80a86b302c15603014", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e77e0200ae5589323b799f77d5b597d4bf5928d6/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77e0200ae5589323b799f77d5b597d4bf5928d6/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=e77e0200ae5589323b799f77d5b597d4bf5928d6", "patch": "@@ -2,6 +2,7 @@\n #![feature(alloc_layout_extra)]\n #![feature(assert_matches)]\n #![feature(box_syntax)]\n+#![feature(btree_drain_filter)]\n #![feature(cow_is_borrowed)]\n #![feature(const_box)]\n #![feature(const_convert)]\n@@ -14,6 +15,8 @@\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n+#![feature(linked_list_cursors)]\n+#![feature(map_try_insert)]\n #![feature(new_uninit)]\n #![feature(pattern)]\n #![feature(trusted_len)]\n@@ -49,6 +52,7 @@ use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};\n \n mod arc;\n+mod autotraits;\n mod borrow;\n mod boxed;\n mod btree_set_hash;"}]}