{"sha": "c3ab57c99e0e9d017c90a7c0bf76230afcb0c984", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYWI1N2M5OWUwZTlkMDE3YzkwYTdjMGJmNzYyMzBhZmNiMGM5ODQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-12T08:38:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T08:38:38Z"}, "message": "Rollup merge of #37535 - Havvy:graph, r=eddyb\n\nGraph Changes\n\nGeneral cleanup and adding a few methods that I want to use in Clippy.\n\nNeed somebody to bikeshed names.", "tree": {"sha": "b8337cecf6ea3532d793b5dbffae120aa66e2663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8337cecf6ea3532d793b5dbffae120aa66e2663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3ab57c99e0e9d017c90a7c0bf76230afcb0c984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ab57c99e0e9d017c90a7c0bf76230afcb0c984", "html_url": "https://github.com/rust-lang/rust/commit/c3ab57c99e0e9d017c90a7c0bf76230afcb0c984", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3ab57c99e0e9d017c90a7c0bf76230afcb0c984/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29195e26d28f19c8f2629ce320dd9792dc6b27b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/29195e26d28f19c8f2629ce320dd9792dc6b27b6", "html_url": "https://github.com/rust-lang/rust/commit/29195e26d28f19c8f2629ce320dd9792dc6b27b6"}, {"sha": "9ddbb9133c86df9aab7b98a0e6b641b847c800ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ddbb9133c86df9aab7b98a0e6b641b847c800ec", "html_url": "https://github.com/rust-lang/rust/commit/9ddbb9133c86df9aab7b98a0e6b641b847c800ec"}], "stats": {"total": 145, "additions": 126, "deletions": 19}, "files": [{"sha": "f94ed6b7209462dd0d7343492d2de705a9fc358a", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 84, "deletions": 15, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c3ab57c99e0e9d017c90a7c0bf76230afcb0c984/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ab57c99e0e9d017c90a7c0bf76230afcb0c984/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=c3ab57c99e0e9d017c90a7c0bf76230afcb0c984", "patch": "@@ -231,18 +231,30 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n \n     // # Iterating over nodes, edges\n \n+    pub fn enumerated_nodes(&self) -> EnumeratedNodes<N> {\n+        EnumeratedNodes {\n+            iter: self.nodes.iter().enumerate()\n+        }\n+    }\n+\n+    pub fn enumerated_edges(&self) -> EnumeratedEdges<E> {\n+        EnumeratedEdges {\n+            iter: self.edges.iter().enumerate()\n+        }\n+    }\n+\n     pub fn each_node<'a, F>(&'a self, mut f: F) -> bool\n         where F: FnMut(NodeIndex, &'a Node<N>) -> bool\n     {\n         //! Iterates over all edges defined in the graph.\n-        self.nodes.iter().enumerate().all(|(i, node)| f(NodeIndex(i), node))\n+        self.enumerated_nodes().all(|(node_idx, node)| f(node_idx, node))\n     }\n \n     pub fn each_edge<'a, F>(&'a self, mut f: F) -> bool\n         where F: FnMut(EdgeIndex, &'a Edge<E>) -> bool\n     {\n         //! Iterates over all edges defined in the graph\n-        self.edges.iter().enumerate().all(|(i, edge)| f(EdgeIndex(i), edge))\n+        self.enumerated_edges().all(|(edge_idx, edge)| f(edge_idx, edge))\n     }\n \n     pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N, E> {\n@@ -270,14 +282,11 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         self.incoming_edges(target).sources()\n     }\n \n-    // # Fixed-point iteration\n-    //\n-    // A common use for graphs in our compiler is to perform\n-    // fixed-point iteration. In this case, each edge represents a\n-    // constraint, and the nodes themselves are associated with\n-    // variables or other bitsets. This method facilitates such a\n-    // computation.\n-\n+    /// A common use for graphs in our compiler is to perform\n+    /// fixed-point iteration. In this case, each edge represents a\n+    /// constraint, and the nodes themselves are associated with\n+    /// variables or other bitsets. This method facilitates such a\n+    /// computation.\n     pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F)\n         where F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool\n     {\n@@ -286,8 +295,8 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            for (i, edge) in self.edges.iter().enumerate() {\n-                changed |= op(iteration, EdgeIndex(i), edge);\n+            for (edge_index, edge) in self.enumerated_edges() {\n+                changed |= op(iteration, edge_index, edge);\n             }\n         }\n     }\n@@ -298,10 +307,67 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n                               -> DepthFirstTraversal<'a, N, E> {\n         DepthFirstTraversal::with_start_node(self, start, direction)\n     }\n+\n+    /// Whether or not a node can be reached from itself.\n+    pub fn is_node_cyclic(&self, starting_node_index: NodeIndex) -> bool {\n+        // This is similar to depth traversal below, but we\n+        // can't use that, because depth traversal doesn't show\n+        // the starting node a second time.\n+        let mut visited = BitVector::new(self.len_nodes());\n+        let mut stack = vec![starting_node_index];\n+\n+        while let Some(current_node_index) = stack.pop() {\n+            visited.insert(current_node_index.0);\n+\n+            // Directionality doesn't change the answer,\n+            // so just use outgoing edges.\n+            for (_, edge) in self.outgoing_edges(current_node_index) {\n+                let target_node_index = edge.target();\n+\n+                if target_node_index == starting_node_index {\n+                    return true;\n+                }\n+\n+                if !visited.contains(target_node_index.0) {\n+                    stack.push(target_node_index);\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n }\n \n // # Iterators\n \n+pub struct EnumeratedNodes<'g, N>\n+    where N: 'g,\n+{\n+    iter: ::std::iter::Enumerate<::std::slice::Iter<'g, Node<N>>>\n+}\n+\n+impl<'g, N: Debug> Iterator for EnumeratedNodes<'g, N> {\n+    type Item = (NodeIndex, &'g Node<N>);\n+\n+    fn next(&mut self) -> Option<(NodeIndex, &'g Node<N>)> {\n+        self.iter.next().map(|(idx, n)| (NodeIndex(idx), n))\n+    }\n+}\n+\n+pub struct EnumeratedEdges<'g, E>\n+    where E: 'g,\n+{\n+    iter: ::std::iter::Enumerate<::std::slice::Iter<'g, Edge<E>>>\n+}\n+\n+impl<'g, E: Debug> Iterator for EnumeratedEdges<'g, E> {\n+    type Item = (EdgeIndex, &'g Edge<E>);\n+\n+    fn next(&mut self) -> Option<(EdgeIndex, &'g Edge<E>)> {\n+        self.iter.next().map(|(idx, e)| (EdgeIndex(idx), e))\n+    }\n+}\n+\n pub struct AdjacentEdges<'g, N, E>\n     where N: 'g,\n           E: 'g\n@@ -336,7 +402,7 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentEdges<'g, N, E> {\n     }\n }\n \n-pub struct AdjacentTargets<'g, N: 'g, E: 'g>\n+pub struct AdjacentTargets<'g, N, E>\n     where N: 'g,\n           E: 'g\n {\n@@ -351,7 +417,7 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentTargets<'g, N, E> {\n     }\n }\n \n-pub struct AdjacentSources<'g, N: 'g, E: 'g>\n+pub struct AdjacentSources<'g, N, E>\n     where N: 'g,\n           E: 'g\n {\n@@ -366,7 +432,10 @@ impl<'g, N: Debug, E: Debug> Iterator for AdjacentSources<'g, N, E> {\n     }\n }\n \n-pub struct DepthFirstTraversal<'g, N: 'g, E: 'g> {\n+pub struct DepthFirstTraversal<'g, N, E>\n+    where N: 'g,\n+          E: 'g\n+{\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n     visited: BitVector,"}, {"sha": "a87410e6e1c8ce398d1f56c6ea61d4f81ba9d22f", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c3ab57c99e0e9d017c90a7c0bf76230afcb0c984/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ab57c99e0e9d017c90a7c0bf76230afcb0c984/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=c3ab57c99e0e9d017c90a7c0bf76230afcb0c984", "patch": "@@ -20,10 +20,13 @@ fn create_graph() -> TestGraph {\n \n     // Create a simple graph\n     //\n-    //    A -+> B --> C\n-    //       |  |     ^\n-    //       |  v     |\n-    //       F  D --> E\n+    //          F\n+    //          |\n+    //          V\n+    //    A --> B --> C\n+    //          |     ^\n+    //          v     |\n+    //          D --> E\n \n     let a = graph.add_node(\"A\");\n     let b = graph.add_node(\"B\");\n@@ -42,6 +45,29 @@ fn create_graph() -> TestGraph {\n     return graph;\n }\n \n+fn create_graph_with_cycle() -> TestGraph {\n+    let mut graph = Graph::new();\n+\n+    // Create a graph with a cycle.\n+    //\n+    //    A --> B <-- +\n+    //          |     |\n+    //          v     |\n+    //          C --> D\n+\n+    let a = graph.add_node(\"A\");\n+    let b = graph.add_node(\"B\");\n+    let c = graph.add_node(\"C\");\n+    let d = graph.add_node(\"D\");\n+\n+    graph.add_edge(a, b, \"AB\");\n+    graph.add_edge(b, c, \"BC\");\n+    graph.add_edge(c, d, \"CD\");\n+    graph.add_edge(d, b, \"DB\");\n+\n+    return graph;\n+}\n+\n #[test]\n fn each_node() {\n     let graph = create_graph();\n@@ -139,3 +165,15 @@ fn each_adjacent_from_d() {\n     let graph = create_graph();\n     test_adjacent_edges(&graph, NodeIndex(3), \"D\", &[(\"BD\", \"B\")], &[(\"DE\", \"E\")]);\n }\n+\n+#[test]\n+fn is_node_cyclic_a() {\n+    let graph = create_graph_with_cycle();\n+    assert!(!graph.is_node_cyclic(NodeIndex(0)));\n+}\n+\n+#[test]\n+fn is_node_cyclic_b() {\n+    let graph = create_graph_with_cycle();\n+    assert!(graph.is_node_cyclic(NodeIndex(1)));\n+}"}]}