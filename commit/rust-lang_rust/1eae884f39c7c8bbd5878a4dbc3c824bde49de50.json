{"sha": "1eae884f39c7c8bbd5878a4dbc3c824bde49de50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYWU4ODRmMzljN2M4YmJkNTg3OGE0ZGJjM2M4MjRiZGU0OWRlNTA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-05T20:56:01Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-05T20:56:01Z"}, "message": "Rollup merge of #24782 - steveklabnik:doc_ownership, r=nikomatsakis\n\nAlso, as @huonw guessed, move semantics really _does_ make more sense as\r\na sub-chapter of ownership.", "tree": {"sha": "c9f0bd8458ffd6bef401f8ca91cbfceed80c4555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9f0bd8458ffd6bef401f8ca91cbfceed80c4555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eae884f39c7c8bbd5878a4dbc3c824bde49de50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eae884f39c7c8bbd5878a4dbc3c824bde49de50", "html_url": "https://github.com/rust-lang/rust/commit/1eae884f39c7c8bbd5878a4dbc3c824bde49de50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cd748611346dec3181f81ca3aa551cce0529343", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd748611346dec3181f81ca3aa551cce0529343", "html_url": "https://github.com/rust-lang/rust/commit/6cd748611346dec3181f81ca3aa551cce0529343"}, {"sha": "ab3cb8c5ae3b9fe86faa1dfa9402145788a005f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab3cb8c5ae3b9fe86faa1dfa9402145788a005f5", "html_url": "https://github.com/rust-lang/rust/commit/ab3cb8c5ae3b9fe86faa1dfa9402145788a005f5"}], "stats": {"total": 1307, "additions": 740, "deletions": 567}, "files": [{"sha": "31bd1b1d92f43c0984913ab33b078e7389d581c2", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=1eae884f39c7c8bbd5878a4dbc3c824bde49de50", "patch": "@@ -26,7 +26,6 @@\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)\n     * [Mutability](mutability.md)\n-    * [Move semantics](move-semantics.md)\n     * [Enums](enums.md)\n     * [Match](match.md)\n     * [Structs](structs.md)"}, {"sha": "981286c82d7988ee2ba6a2c53b2dc879fe601611", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 295, "deletions": 1, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=1eae884f39c7c8bbd5878a4dbc3c824bde49de50", "patch": "@@ -1,3 +1,297 @@\n % Lifetimes\n \n-Coming Soon! Until then, check out the [ownership](ownership.html) chapter.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. There are a few distinct concepts, each with its own chapter:\n+\n+* [ownership][ownership], ownership, the key concept\n+* [borrowing][borrowing], and their associated feature \u2018references\u2019\n+* lifetimes, which you\u2019re reading now\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[ownership]: ownership.html\n+[borrowing]: references-and-borrowing.html\n+\n+# Meta\n+\n+Before we get to the details, two important notes about the ownership system.\n+\n+Rust has a focus on safety and speed. It accomplishes these goals through many\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n+as possible in order to make them work. The ownership system is a prime example\n+of a zero-cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+is _done at compile time_. You do not pay any run-time cost for any of these\n+features.\n+\n+However, this system does have a certain cost: learning curve. Many new users\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n+You probably will experience similar things at first. There is good news,\n+however: more experienced Rust developers report that once they work with the\n+rules of the ownership system for a period of time, they fight the borrow\n+checker less and less.\n+\n+With that in mind, let\u2019s learn about lifetimes.\n+\n+# Lifetimes\n+\n+Lending out a reference to a resource that someone else owns can be\n+complicated, however. For example, imagine this set of operations:\n+\n+- I acquire a handle to some kind of resource.\n+- I lend you a reference to the resource.\n+- I decide I\u2019m done with the resource, and deallocate it, while you still have\n+  your reference.\n+- You decide to use the resource.\n+\n+Uh oh! Your reference is pointing to an invalid resource. This is called a\n+dangling pointer or \u2018use after free\u2019, when the resource is memory.\n+\n+To fix this, we have to make sure that step four never happens after step\n+three. The ownership system in Rust does this through a concept called\n+lifetimes, which describe the scope that a reference is valid for.\n+\n+When we have a function that takes a reference by argument, we can be implicit\n+or explicit about the lifetime of the reference:\n+\n+```rust\n+// implicit\n+fn foo(x: &i32) {\n+}\n+\n+// explicit\n+fn bar<'a>(x: &'a i32) {\n+}\n+```\n+\n+The `'a` reads \u2018the lifetime a\u2019. Technically, every reference has some lifetime\n+associated with it, but the compiler lets you elide them in common cases.\n+Before we get to that, though, let\u2019s break the explicit example down:\n+\n+```rust,ignore\n+fn bar<'a>(...)\n+```\n+\n+This part declares our lifetimes. This says that `bar` has one lifetime, `'a`.\n+If we had two reference parameters, it would look like this:\n+\n+```rust,ignore\n+fn bar<'a, 'b>(...)\n+```\n+\n+Then in our parameter list, we use the lifetimes we\u2019ve named:\n+\n+```rust,ignore\n+...(x: &'a i32)\n+```\n+\n+If we wanted an `&mut` reference, we\u2019d do this:\n+\n+```rust,ignore\n+...(x: &'a mut i32)\n+```\n+\n+If you compare `&mut i32` to `&'a mut i32`, they\u2019re the same, it\u2019s just that\n+the lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut\n+i32` as \u2018a mutable reference to an i32\u2019 and `&'a mut i32` as \u2018a mutable\n+reference to an `i32` with the lifetime `'a`\u2019.\n+\n+You\u2019ll also need explicit lifetimes when working with [`struct`][structs]s:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n+    let f = Foo { x: y };\n+\n+    println!(\"{}\", f.x);\n+}\n+```\n+\n+[struct]: structs.html\n+\n+As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n+\n+```rust\n+struct Foo<'a> {\n+# x: &'a i32,\n+# }\n+```\n+\n+declares a lifetime, and\n+\n+```rust\n+# struct Foo<'a> {\n+x: &'a i32,\n+# }\n+```\n+\n+uses it. So why do we need a lifetime here? We need to ensure that any reference\n+to a `Foo` cannot outlive the reference to an `i32` it contains.\n+\n+## Thinking in scopes\n+\n+A way to think about lifetimes is to visualize the scope that a reference is\n+valid for. For example:\n+\n+```rust\n+fn main() {\n+    let y = &5;     // -+ y goes into scope\n+                    //  |\n+    // stuff        //  |\n+                    //  |\n+}                   // -+ y goes out of scope\n+```\n+\n+Adding in our `Foo`:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let y = &5;           // -+ y goes into scope\n+    let f = Foo { x: y }; // -+ f goes into scope\n+    // stuff              //  |\n+                          //  |\n+}                         // -+ f and y go out of scope\n+```\n+\n+Our `f` lives within the scope of `y`, so everything works. What if it didn\u2019t?\n+This code won\u2019t work:\n+\n+```rust,ignore\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let x;                    // -+ x goes into scope\n+                              //  |\n+    {                         //  |\n+        let y = &5;           // ---+ y goes into scope\n+        let f = Foo { x: y }; // ---+ f goes into scope\n+        x = &f.x;             //  | | error here\n+    }                         // ---+ f and y go out of scope\n+                              //  |\n+    println!(\"{}\", x);        //  |\n+}                             // -+ x goes out of scope\n+```\n+\n+Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n+of `x`. But when we do `x = &f.x`, we make `x` a reference to something that\u2019s\n+about to go out of scope.\n+\n+Named lifetimes are a way of giving these scopes a name. Giving something a\n+name is the first step towards being able to talk about it.\n+\n+## 'static\n+\n+The lifetime named \u2018static\u2019 is a special lifetime. It signals that something\n+has the lifetime of the entire program. Most Rust programmers first come across\n+`'static` when dealing with strings:\n+\n+```rust\n+let x: &'static str = \"Hello, world.\";\n+```\n+\n+String literals have the type `&'static str` because the reference is always\n+alive: they are baked into the data segment of the final binary. Another\n+example are globals:\n+\n+```rust\n+static FOO: i32 = 5;\n+let x: &'static i32 = &FOO;\n+```\n+\n+This adds an `i32` to the data segment of the binary, and `x` is a reference\n+to it.\n+\n+## Lifetime Elision\n+\n+Rust supports powerful local type inference in function bodies, but it\u2019s\n+forbidden in item signatures to allow reasoning about the types just based in\n+the item signature alone. However, for ergonomic reasons a very restricted\n+secondary inference algorithm called \u201clifetime elision\u201d applies in function\n+signatures. It infers only based on the signature components themselves and not\n+based on the body of the function, only infers lifetime parameters, and does\n+this with only three easily memorizable and unambiguous rules. This makes\n+lifetime elision a shorthand for writing an item signature, while not hiding\n+away the actual types involved as full local inference would if applied to it.\n+\n+When talking about lifetime elision, we use the term *input lifetime* and\n+*output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n+of a function, and an *output lifetime* is a lifetime associated with the return\n+value of a function. For example, this function has an input lifetime:\n+\n+```rust,ignore\n+fn foo<'a>(bar: &'a str)\n+```\n+\n+This one has an output lifetime:\n+\n+```rust,ignore\n+fn foo<'a>() -> &'a str\n+```\n+\n+This one has a lifetime in both positions:\n+\n+```rust,ignore\n+fn foo<'a>(bar: &'a str) -> &'a str\n+```\n+\n+Here are the three rules:\n+\n+* Each elided lifetime in a function\u2019s arguments becomes a distinct lifetime\n+  parameter.\n+\n+* If there is exactly one input lifetime, elided or not, that lifetime is\n+  assigned to all elided lifetimes in the return values of that function.\n+\n+* If there are multiple input lifetimes, but one of them is `&self` or `&mut\n+  self`, the lifetime of `self` is assigned to all elided output lifetimes.\n+\n+Otherwise, it is an error to elide an output lifetime.\n+\n+### Examples\n+\n+Here are some examples of functions with elided lifetimes.  We\u2019ve paired each\n+example of an elided lifetime with its expanded form.\n+\n+```rust,ignore\n+fn print(s: &str); // elided\n+fn print<'a>(s: &'a str); // expanded\n+\n+fn debug(lvl: u32, s: &str); // elided\n+fn debug<'a>(lvl: u32, s: &'a str); // expanded\n+\n+// In the preceding example, `lvl` doesn\u2019t need a lifetime because it\u2019s not a\n+// reference (`&`). Only things relating to references (such as a `struct`\n+// which contains a reference) need lifetimes.\n+\n+fn substr(s: &str, until: u32) -> &str; // elided\n+fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n+\n+fn get_str() -> &str; // ILLEGAL, no inputs\n+\n+fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n+fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear\n+\n+fn get_mut(&mut self) -> &mut T; // elided\n+fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n+\n+fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided\n+fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n+\n+fn new(buf: &mut [u8]) -> BufWriter; // elided\n+fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded\n+```"}, {"sha": "b5bd53e1d75a14bc6ad23ddc81756403916a1fa1", "filename": "src/doc/trpl/move-semantics.md", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6cd748611346dec3181f81ca3aa551cce0529343/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/6cd748611346dec3181f81ca3aa551cce0529343/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmove-semantics.md?ref=6cd748611346dec3181f81ca3aa551cce0529343", "patch": "@@ -1,105 +0,0 @@\n-% Move Semantics\n-\n-An important aspect of [ownership][ownership] is \u2018move semantics\u2019. Move\n-semantics control how and when ownership is transferred between bindings.\n-\n-[ownership]: ownership.html\n-\n-For example, consider a type like `Vec<T>`, which owns its contents:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-```\n-\n-I can assign this vector to another binding:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-```\n-\n-But, if we try to use `v` afterwards, we get an error:\n-\n-```rust,ignore\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-\n-println!(\"v[0] is: {}\", v[0]);\n-```\n-\n-It looks like this:\n-\n-```text\n-error: use of moved value: `v`\n-println!(\"v[0] is: {}\", v[0]);\n-                        ^\n-```\n-\n-A similar thing happens if we define a function which takes ownership, and\n-try to use something after we\u2019ve passed it as an argument:\n-\n-```rust,ignore\n-fn take(v: Vec<i32>) {\n-    // what happens here isn\u2019t important.\n-}\n-\n-let v = vec![1, 2, 3];\n-\n-take(v);\n-\n-println!(\"v[0] is: {}\", v[0]);\n-```\n-\n-Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n-we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n-special annotation here, it\u2019s the default thing that Rust does.\n-\n-# The details\n-\n-The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n-important. When we write code like this:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-```\n-\n-The first line creates some data for the vector on the stack, `v`. The vector\u2019s\n-data, however, is stored on the heap, and so it contains a pointer to that\n-data. When we move `v` to `v2`, it creates a copy of that data, for `v2`. Which\n-would mean two pointers to the contents of the vector on the heap. That would\n-be a problem: it would violate Rust\u2019s safety guarantees by introducing a data\n-race. Therefore, Rust forbids using `v` after we\u2019ve done the move.\n-\n-It\u2019s also important to note that optimizations may remove the actual copy of\n-the bytes, depending on circumstances. So it may not be as inefficient as it\n-initially seems.\n-\n-# `Copy` types\n-\n-We\u2019ve established that when ownership is transferred to another binding, you\n-cannot use the original binding. However, there\u2019s a [trait][traits] that changes this\n-behavior, and it\u2019s called `Copy`. We haven\u2019t discussed traits yet, but for now,\n-you can think of them as an annotation to a particular type that adds extra\n-behavior. For example:\n-\n-```rust\n-let v = 1;\n-\n-let v2 = v;\n-\n-println!(\"v is: {}\", v);\n-```\n-\n-In this case, `v` is an `i32`, which implements the `Copy` trait. This means\n-that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n-But, unlike a move, we can still use `v` afterward. This is because an `i32`\n-has no pointers to data somewhere else, copying it is a full copy.\n-\n-We will discuss how to make your own types `Copy` in the [traits][traits]\n-section.\n-\n-[traits]: traits.html"}, {"sha": "3003156f875aaf1cfd7c198996c656d367fdfc30", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 111, "deletions": 459, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=1eae884f39c7c8bbd5878a4dbc3c824bde49de50", "patch": "@@ -1,555 +1,207 @@\n % Ownership\n \n-This guide presents Rust's ownership system. This is one of Rust's most unique\n-and compelling features, with which Rust developers should become quite\n-acquainted. Ownership is how Rust achieves its largest goal, memory safety.\n-The ownership system has a few distinct concepts: *ownership*, *borrowing*,\n-and *lifetimes*. We'll talk about each one in turn.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. The there are a few distinct concepts, each with its own\n+chapter:\n+\n+* ownership, which you\u2019re reading now.\n+* [borrowing][borrowing], and their associated feature \u2018references\u2019\n+* [lifetimes][lifetimes], an advanced concept of borrowing\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[borrowing]: references-and-borrowing.html\n+[lifetimes]: lifetimes.html\n \n # Meta\n \n Before we get to the details, two important notes about the ownership system.\n \n Rust has a focus on safety and speed. It accomplishes these goals through many\n-*zero-cost abstractions*, which means that in Rust, abstractions cost as little\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n as possible in order to make them work. The ownership system is a prime example\n-of a zero cost abstraction. All of the analysis we'll talk about in this guide\n+of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n is _done at compile time_. You do not pay any run-time cost for any of these\n features.\n \n However, this system does have a certain cost: learning curve. Many new users\n-to Rust experience something we like to call \"fighting with the borrow\n-checker,\" where the Rust compiler refuses to compile a program that the author\n-thinks is valid. This often happens because the programmer's mental model of\n-how ownership should work doesn't match the actual rules that Rust implements.\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n You probably will experience similar things at first. There is good news,\n however: more experienced Rust developers report that once they work with the\n rules of the ownership system for a period of time, they fight the borrow\n checker less and less.\n \n-With that in mind, let's learn about ownership.\n+With that in mind, let\u2019s learn about ownership.\n \n # Ownership\n \n-At its core, ownership is about *resources*. For the purposes of the vast\n-majority of this guide, we will talk about a specific resource: memory. The\n-concept generalizes to any kind of resource, like a file handle, but to make it\n-more concrete, we'll focus on memory.\n-\n-When your program allocates some memory, it needs some way to deallocate that\n-memory. Imagine a function `foo` that allocates four bytes of memory, and then\n-never deallocates that memory. We call this problem *leaking* memory, because\n-each time we call `foo`, we're allocating another four bytes. Eventually, with\n-enough calls to `foo`, we will run our system out of memory. That's no good. So\n-we need some way for `foo` to deallocate those four bytes. It's also important\n-that we don't deallocate too many times, either. Without getting into the\n-details, attempting to deallocate memory multiple times can lead to problems.\n-In other words, any time some memory is allocated, we need to make sure that we\n-deallocate that memory once and only once. Too many times is bad, not enough\n-times is bad. The counts must match.\n-\n-There's one other important detail with regards to allocating memory. Whenever\n-we request some amount of memory, what we are given is a handle to that memory.\n-This handle (often called a *pointer*, when we're referring to memory) is how\n-we interact with the allocated memory. As long as we have that handle, we can\n-do something with the memory. Once we're done with the handle, we're also done\n-with the memory, as we can't do anything useful without a handle to it.\n-\n-Historically, systems programming languages require you to track these\n-allocations, deallocations, and handles yourself. For example, if we want some\n-memory from the heap in a language like C, we do this:\n-\n-```c\n-{\n-    int *x = malloc(sizeof(int));\n-\n-    // we can now do stuff with our handle x\n-    *x = 5;\n-\n-    free(x);\n-}\n-```\n-\n-The call to `malloc` allocates some memory. The call to `free` deallocates the\n-memory. There's also bookkeeping about allocating the correct amount of memory.\n-\n-Rust combines these two aspects of allocating memory (and other resources) into\n-a concept called *ownership*. Whenever we request some memory, that handle we\n-receive is called the *owning handle*. Whenever that handle goes out of scope,\n-Rust knows that you cannot do anything with the memory anymore, and so\n-therefore deallocates the memory for you. Here's the equivalent example in\n-Rust:\n+[`Variable bindings`][bindings] have a property in Rust: they \u2018have ownership\u2019\n+of what they\u2019re bound to. This means that when a binding goes out of scope, the\n+resource that they\u2019re bound to are freed. For example:\n \n ```rust\n-{\n-    let x = Box::new(5);\n-}\n-```\n-\n-The `Box::new` function creates a `Box<T>` (specifically `Box<i32>` in this\n-case) by allocating a small segment of memory on the heap with enough space to\n-fit an `i32`. But where in the code is the box deallocated? We said before that\n-we must have a deallocation for each allocation. Rust handles this for you. It\n-knows that our handle, `x`, is the owning reference to our box. Rust knows that\n-`x` will go out of scope at the end of the block, and so it inserts a call to\n-deallocate the memory at the end of the scope. Because the compiler does this\n-for us, it's impossible to forget. We always have exactly one deallocation\n-  paired with each of our allocations.\n-\n-This is pretty straightforward, but what happens when we want to pass our box\n-to a function? Let's look at some code:\n-\n-```rust\n-fn main() {\n-    let x = Box::new(5);\n-\n-    add_one(x);\n-}\n-\n-fn add_one(mut num: Box<i32>) {\n-    *num += 1;\n+fn foo() {\n+    let v = vec![1, 2, 3];\n }\n ```\n \n-This code works, but it's not ideal. For example, let's add one more line of\n-code, where we print out the value of `x`:\n-\n-```{rust,ignore}\n-fn main() {\n-    let x = Box::new(5);\n+When `v` comes into scope, a new [`Vec<T>`][vect] is created. In this case, the\n+vector also allocates space on [the heap][heap], for the three elements. When\n+`v` goes out of scope at the end of `foo()`, Rust will clean up everything\n+related to the vector, even the heap-allocated memory. This happens\n+deterministically, at the end of the scope.\n \n-    add_one(x);\n-\n-    println!(\"{}\", x);\n-}\n+[vect]: ../std/vec/struct.Vec.html\n+[heap]: the-stack-and-the-heap.html\n \n-fn add_one(mut num: Box<i32>) {\n-    *num += 1;\n-}\n-```\n+# Move semantics\n \n-This does not compile, and gives us an error:\n-\n-```text\n-error: use of moved value: `x`\n-   println!(\"{}\", x);\n-                  ^\n-```\n-\n-Remember, we need one deallocation for every allocation. When we try to pass\n-our box to `add_one`, we would have two handles to the memory: `x` in `main`,\n-and `num` in `add_one`. If we deallocated the memory when each handle went out\n-of scope, we would have two deallocations and one allocation, and that's wrong.\n-So when we call `add_one`, Rust defines `num` as the owner of the handle. And\n-so, now that we've given ownership to `num`, `x` is invalid. `x`'s value has\n-\"moved\" from `x` to `num`. Hence the error: use of moved value `x`.\n-\n-To fix this, we can have `add_one` give ownership back when it's done with the\n-box:\n+There\u2019s some more subtlety here, though: Rust ensures that there is _exactly\n+one_ binding to any given resource. For example, if we have a vector, we can\n+assign it to another binding:\n \n ```rust\n-fn main() {\n-    let x = Box::new(5);\n-\n-    let y = add_one(x);\n-\n-    println!(\"{}\", y);\n-}\n-\n-fn add_one(mut num: Box<i32>) -> Box<i32> {\n-    *num += 1;\n+let v = vec![1, 2, 3];\n \n-    num\n-}\n+let v2 = v;\n ```\n \n-This code will compile and run just fine. Now, we return a `box`, and so the\n-ownership is transferred back to `y` in `main`. We only have ownership for the\n-duration of our function before giving it back. This pattern is very common,\n-and so Rust introduces a concept to describe a handle which temporarily refers\n-to something another handle owns. It's called *borrowing*, and it's done with\n-*references*, designated by the `&` symbol.\n-\n-# Borrowing\n+But, if we try to use `v` afterwards, we get an error:\n \n-Here's the current state of our `add_one` function:\n+```rust,ignore\n+let v = vec![1, 2, 3];\n \n-```rust\n-fn add_one(mut num: Box<i32>) -> Box<i32> {\n-    *num += 1;\n+let v2 = v;\n \n-    num\n-}\n+println!(\"v[0] is: {}\", v[0]);\n ```\n \n-This function takes ownership, because it takes a `Box`, which owns its\n-contents. But then we give ownership right back.\n-\n-In the physical world, you can give one of your possessions to someone for a\n-short period of time. You still own your possession, you're just letting someone\n-else use it for a while. We call that *lending* something to someone, and that\n-person is said to be *borrowing* that something from you.\n-\n-Rust's ownership system also allows an owner to lend out a handle for a limited\n-period. This is also called *borrowing*. Here's a version of `add_one` which\n-borrows its argument rather than taking ownership:\n-\n-```rust\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-This function borrows an `i32` from its caller, and then increments it. When\n-the function is over, and `num` goes out of scope, the borrow is over.\n-\n-We have to change our `main` a bit too:\n-\n-```rust\n-fn main() {\n-    let mut x = 5;\n-\n-    add_one(&mut x);\n+It looks like this:\n \n-    println!(\"{}\", x);\n-}\n-\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-We don't need to assign the result of `add_one()` anymore, because it doesn't\n-return anything anymore. This is because we're not passing ownership back,\n-since we just borrow, not take ownership.\n-\n-# Lifetimes\n-\n-Lending out a reference to a resource that someone else owns can be\n-complicated, however. For example, imagine this set of operations:\n-\n-1. I acquire a handle to some kind of resource.\n-2. I lend you a reference to the resource.\n-3. I decide I'm done with the resource, and deallocate it, while you still have\n-   your reference.\n-4. You decide to use the resource.\n-\n-Uh oh! Your reference is pointing to an invalid resource. This is called a\n-*dangling pointer* or \"use after free,\" when the resource is memory.\n-\n-To fix this, we have to make sure that step four never happens after step\n-three. The ownership system in Rust does this through a concept called\n-*lifetimes*, which describe the scope that a reference is valid for.\n-\n-Remember the function that borrowed an `i32`? Let's look at it again.\n-\n-```rust\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n+```text\n+error: use of moved value: `v`\n+println!(\"v[0] is: {}\", v[0]);\n+                        ^\n ```\n \n-Rust has a feature called *lifetime elision*, which allows you to not write\n-lifetime annotations in certain circumstances. This is one of them. We will\n-cover the others later. Without eliding the lifetimes, `add_one` looks like\n-this:\n+A similar thing happens if we define a function which takes ownership, and\n+try to use something after we\u2019ve passed it as an argument:\n \n-```rust\n-fn add_one<'a>(num: &'a mut i32) {\n-    *num += 1;\n+```rust,ignore\n+fn take(v: Vec<i32>) {\n+    // what happens here isn\u2019t important.\n }\n-```\n-\n-The `'a` is called a *lifetime*. Most lifetimes are used in places where\n-short names like `'a`, `'b` and `'c` are clearest, but it's often useful to\n-have more descriptive names. Let's dig into the syntax in a bit more detail:\n \n-```{rust,ignore}\n-fn add_one<'a>(...)\n-```\n+let v = vec![1, 2, 3];\n \n-This part _declares_ our lifetimes. This says that `add_one` has one lifetime,\n-`'a`. If we had two, it would look like this:\n+take(v);\n \n-```{rust,ignore}\n-fn add_two<'a, 'b>(...)\n+println!(\"v[0] is: {}\", v[0]);\n ```\n \n-Then in our parameter list, we use the lifetimes we've named:\n-\n-```{rust,ignore}\n-...(num: &'a mut i32)\n-```\n+Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n+we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n+special annotation here, it\u2019s the default thing that Rust does.\n \n-If you compare `&mut i32` to `&'a mut i32`, they're the same, it's just that the\n-lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut i32` as \"a\n-mutable reference to an i32\" and `&'a mut i32` as \"a mutable reference to an i32 with the lifetime 'a.'\"\n+## The details\n \n-Why do lifetimes matter? Well, for example, here's some code:\n+The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n+important. When we write code like this:\n \n ```rust\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n+let v = vec![1, 2, 3];\n \n-fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n-    let f = Foo { x: y };\n-\n-    println!(\"{}\", f.x);\n-}\n+let v2 = v;\n ```\n \n-As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n-\n-```{rust}\n-struct Foo<'a> {\n-# x: &'a i32,\n-# }\n-```\n+The first line creates some data for the vector on the [stack][sh], `v`. The\n+vector\u2019s data, however, is stored on the [heap][sh], and so it contains a\n+pointer to that data. When we move `v` to `v2`, it creates a copy of that data,\n+for `v2`. Which would mean two pointers to the contents of the vector on the\n+heap. That would be a problem: it would violate Rust\u2019s safety guarantees by\n+introducing a data race. Therefore, Rust forbids using `v` after we\u2019ve done the\n+move.\n \n-declares a lifetime, and\n-\n-```rust\n-# struct Foo<'a> {\n-x: &'a i32,\n-# }\n-```\n+[sh]: the-stack-and-the-heap.html\n \n-uses it. So why do we need a lifetime here? We need to ensure that any reference\n-to a `Foo` cannot outlive the reference to an `i32` it contains.\n+It\u2019s also important to note that optimizations may remove the actual copy of\n+the bytes, depending on circumstances. So it may not be as inefficient as it\n+initially seems.\n \n-## Thinking in scopes\n+## `Copy` types\n \n-A way to think about lifetimes is to visualize the scope that a reference is\n-valid for. For example:\n+We\u2019ve established that when ownership is transferred to another binding, you\n+cannot use the original binding. However, there\u2019s a [trait][traits] that changes this\n+behavior, and it\u2019s called `Copy`. We haven\u2019t discussed traits yet, but for now,\n+you can think of them as an annotation to a particular type that adds extra\n+behavior. For example:\n \n ```rust\n-fn main() {\n-    let y = &5;     // -+ y goes into scope\n-                    //  |\n-    // stuff        //  |\n-                    //  |\n-}                   // -+ y goes out of scope\n-```\n-\n-Adding in our `Foo`:\n-\n-```rust\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let y = &5;           // -+ y goes into scope\n-    let f = Foo { x: y }; // -+ f goes into scope\n-    // stuff              //  |\n-                          //  |\n-}                         // -+ f and y go out of scope\n-```\n+let v = 1;\n \n-Our `f` lives within the scope of `y`, so everything works. What if it didn't?\n-This code won't work:\n+let v2 = v;\n \n-```{rust,ignore}\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let x;                    // -+ x goes into scope\n-                              //  |\n-    {                         //  |\n-        let y = &5;           // ---+ y goes into scope\n-        let f = Foo { x: y }; // ---+ f goes into scope\n-        x = &f.x;             //  | | error here\n-    }                         // ---+ f and y go out of scope\n-                              //  |\n-    println!(\"{}\", x);        //  |\n-}                             // -+ x goes out of scope\n+println!(\"v is: {}\", v);\n ```\n \n-Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n-of `x`. But when we do `x = &f.x`, we make `x` a reference to something that's\n-about to go out of scope.\n+In this case, `v` is an `i32`, which implements the `Copy` trait. This means\n+that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n+But, unlike a move, we can still use `v` afterward. This is because an `i32`\n+has no pointers to data somewhere else, copying it is a full copy.\n \n-Named lifetimes are a way of giving these scopes a name. Giving something a\n-name is the first step towards being able to talk about it.\n+We will discuss how to make your own types `Copy` in the [traits][traits]\n+section.\n \n-## 'static\n+[traits]: traits.html\n \n-The lifetime named *static* is a special lifetime. It signals that something\n-has the lifetime of the entire program. Most Rust programmers first come across\n-`'static` when dealing with strings:\n+# More than ownership\n \n-```rust\n-let x: &'static str = \"Hello, world.\";\n-```\n-\n-String literals have the type `&'static str` because the reference is always\n-alive: they are baked into the data segment of the final binary. Another\n-example are globals:\n+Of course, if we had to hand ownership back with every function we wrote:\n \n ```rust\n-static FOO: i32 = 5;\n-let x: &'static i32 = &FOO;\n-```\n-\n-This adds an `i32` to the data segment of the binary, and `x` is a reference\n-to it.\n+fn foo(v: Vec<i32>) -> Vec<i32> {\n+    // do stuff with v\n \n-# Shared Ownership\n-\n-In all the examples we've considered so far, we've assumed that each handle has\n-a singular owner. But sometimes, this doesn't work. Consider a car. Cars have\n-four wheels. We would want a wheel to know which car it was attached to. But\n-this won't work:\n-\n-```{rust,ignore}\n-struct Car {\n-    name: String,\n-}\n-\n-struct Wheel {\n-    size: i32,\n-    owner: Car,\n-}\n-\n-fn main() {\n-    let car = Car { name: \"DeLorean\".to_string() };\n-\n-    for _ in 0..4 {\n-        Wheel { size: 360, owner: car };\n-    }\n+    // hand back ownership\n+    v\n }\n ```\n \n-We try to make four `Wheel`s, each with a `Car` that it's attached to. But the\n-compiler knows that on the second iteration of the loop, there's a problem:\n-\n-```text\n-error: use of moved value: `car`\n-    Wheel { size: 360, owner: car };\n-                              ^~~\n-note: `car` moved here because it has type `Car`, which is non-copyable\n-    Wheel { size: 360, owner: car };\n-                              ^~~\n-```\n-\n-We need our `Car` to be pointed to by multiple `Wheel`s. We can't do that with\n-`Box<T>`, because it has a single owner. We can do it with `Rc<T>` instead:\n+This would get very tedius. It gets worse the more things we want to take ownership of:\n \n ```rust\n-use std::rc::Rc;\n+fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n+    // do stuff with v1 and v2\n \n-struct Car {\n-    name: String,\n+    // hand back ownership, and the result of our function\n+    (v1, v2, 42)\n }\n \n-struct Wheel {\n-    size: i32,\n-    owner: Rc<Car>,\n-}\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n \n-fn main() {\n-    let car = Car { name: \"DeLorean\".to_string() };\n-\n-    let car_owner = Rc::new(car);\n-\n-    for _ in 0..4 {\n-        Wheel { size: 360, owner: car_owner.clone() };\n-    }\n-}\n+let (v1, v2, answer) = foo(v1, v2);\n ```\n \n-We wrap our `Car` in an `Rc<T>`, getting an `Rc<Car>`, and then use the\n-`clone()` method to make new references. We've also changed our `Wheel` to have\n-an `Rc<Car>` rather than just a `Car`.\n-\n-This is the simplest kind of multiple ownership possible. For example, there's\n-also `Arc<T>`, which uses more expensive atomic instructions to be the\n-thread-safe counterpart of `Rc<T>`.\n-\n-## Lifetime Elision\n-\n-Rust supports powerful local type inference in function bodies, but it\u2019s\n-forbidden in item signatures to allow reasoning about the types just based in\n-the item signature alone. However, for ergonomic reasons a very restricted\n-secondary inference algorithm called \u201clifetime elision\u201d applies in function\n-signatures. It infers only based on the signature components themselves and not\n-based on the body of the function, only infers lifetime parameters, and does\n-this with only three easily memorizable and unambiguous rules. This makes\n-lifetime elision a shorthand for writing an item signature, while not hiding\n-away the actual types involved as full local inference would if applied to it.\n-\n-When talking about lifetime elision, we use the term *input lifetime* and\n-*output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n-of a function, and an *output lifetime* is a lifetime associated with the return\n-value of a function. For example, this function has an input lifetime:\n-\n-```{rust,ignore}\n-fn foo<'a>(bar: &'a str)\n-```\n-\n-This one has an output lifetime:\n-\n-```{rust,ignore}\n-fn foo<'a>() -> &'a str\n-```\n-\n-This one has a lifetime in both positions:\n-\n-```{rust,ignore}\n-fn foo<'a>(bar: &'a str) -> &'a str\n-```\n+Ugh! The return type, return line, and calling the function gets way more\n+complicated.\n \n-Here are the three rules:\n+Luckily, Rust offers a feature, borrowing, which helps us solve this problem.\n+It\u2019s the topic of the next section!\n \n-* Each elided lifetime in a function's arguments becomes a distinct lifetime\n-  parameter.\n \n-* If there is exactly one input lifetime, elided or not, that lifetime is\n-  assigned to all elided lifetimes in the return values of that function.\n \n-* If there are multiple input lifetimes, but one of them is `&self` or `&mut\n-  self`, the lifetime of `self` is assigned to all elided output lifetimes.\n \n-Otherwise, it is an error to elide an output lifetime.\n \n-### Examples\n \n-Here are some examples of functions with elided lifetimes.  We've paired each\n-example of an elided lifetime with its expanded form.\n \n-```{rust,ignore}\n-fn print(s: &str); // elided\n-fn print<'a>(s: &'a str); // expanded\n \n-fn debug(lvl: u32, s: &str); // elided\n-fn debug<'a>(lvl: u32, s: &'a str); // expanded\n \n-// In the preceding example, `lvl` doesn't need a lifetime because it's not a\n-// reference (`&`). Only things relating to references (such as a `struct`\n-// which contains a reference) need lifetimes.\n-\n-fn substr(s: &str, until: u32) -> &str; // elided\n-fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n-\n-fn get_str() -> &str; // ILLEGAL, no inputs\n-\n-fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n-fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear\n-\n-fn get_mut(&mut self) -> &mut T; // elided\n-fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n-\n-fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided\n-fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n-\n-fn new(buf: &mut [u8]) -> BufWriter; // elided\n-fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded\n-```\n \n-# Related Resources\n \n-Coming Soon."}, {"sha": "21feff73342ce0db1a83a52a7ea98cf70627c6be", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "modified", "additions": 334, "deletions": 1, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/1eae884f39c7c8bbd5878a4dbc3c824bde49de50/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=1eae884f39c7c8bbd5878a4dbc3c824bde49de50", "patch": "@@ -1,3 +1,336 @@\n % References and Borrowing\n \n-Coming Soon! Until then, check out the [ownership](ownership.html) chapter.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. The there are a few distinct concepts, each with its own\n+chapter:\n+\n+* [ownership][ownership], ownership, the key concept\n+* borrowing, which you\u2019re reading now\n+* [lifetimes][lifetimes], an advanced concept of borrowing\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[ownership]: ownership.html\n+[lifetimes]: lifetimes.html\n+\n+# Meta\n+\n+Before we get to the details, two important notes about the ownership system.\n+\n+Rust has a focus on safety and speed. It accomplishes these goals through many\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n+as possible in order to make them work. The ownership system is a prime example\n+of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+is _done at compile time_. You do not pay any run-time cost for any of these\n+features.\n+\n+However, this system does have a certain cost: learning curve. Many new users\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n+You probably will experience similar things at first. There is good news,\n+however: more experienced Rust developers report that once they work with the\n+rules of the ownership system for a period of time, they fight the borrow\n+checker less and less.\n+\n+With that in mind, let\u2019s learn about borrowing.\n+\n+# Borrowing\n+\n+At the end of the [ownership][ownership] section, we had a nasty function that looked\n+like this:\n+\n+```rust\n+fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n+    // do stuff with v1 and v2\n+\n+    // hand back ownership, and the result of our function\n+    (v1, v2, 42)\n+}\n+\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n+\n+let (v1, v2, answer) = foo(v1, v2);\n+```\n+\n+This is not idiomatic Rust, however, as it doesn\u2019t take advantage of borrowing. Here\u2019s\n+the first step:\n+\n+```rust\n+fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n+    // do stuff with v1 and v2\n+\n+    // return the answer\n+    42\n+}\n+\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n+\n+let answer = foo(&v1, &v2);\n+\n+// we can use v1 and v2 here!\n+```\n+\n+Instead of taking `Vec<i32>`s as our arguments, we take a reference:\n+`&Vec<i32>`. And instead of passing `v1` and `v2` directly, we pass `&v1` and\n+`&v2`. We call the `&T` type a \u2018reference\u2019, and rather than owning the resource,\n+it borrows ownership. A binding that borrows something does not deallocate the\n+resource when it goes out of scope. This means that after the call to `foo()`,\n+we can use our original bindings again.\n+\n+References are immutable, just like bindings. This means that inside of `foo()`,\n+the vectors can\u2019t be changed at all:\n+\n+```rust,ignore\n+fn foo(v: &Vec<i32>) {\n+     v.push(5);\n+}\n+\n+let v = vec![];\n+\n+foo(&v);\n+```\n+\n+errors with:\n+\n+```text\n+error: cannot borrow immutable borrowed content `*v` as mutable\n+v.push(5);\n+^\n+```\n+\n+Pushing a value mutates the vector, and so we aren\u2019t allowed to do it.\n+\n+# &mut references\n+\n+There\u2019s a second kind of reference: `&mut T`. A \u2018mutable reference\u2019 allows you\n+to mutate the resource you\u2019re borrowing. For example:\n+\n+```rust\n+let mut x = 5;\n+{\n+    let y = &mut x;\n+    *y += 1;\n+}\n+println!(\"{}\", x);\n+```\n+\n+This will print `6`. We make `y` a mutable reference to `x`, then add one to\n+the thing `y` points at. You\u2019ll notice that `x` had to be marked `mut` as well,\n+if it wasn\u2019t, we couldn\u2019t take a mutable borrow to an immutable value.\n+\n+Otherwise, `&mut` references are just like references. There _is_ a large\n+difference between the two, and how they interact, though. You can tell\n+something is fishy in the above example, because we need that extra scope, with\n+the `{` and `}`. If we remove them, we get an error:\n+\n+```text\n+error: cannot borrow `x` as immutable because it is also borrowed as mutable\n+    println!(\"{}\", x);\n+                   ^\n+note: previous borrow of `x` occurs here; the mutable borrow prevents\n+subsequent moves, borrows, or modification of `x` until the borrow ends\n+        let y = &mut x;\n+                     ^\n+note: previous borrow ends here\n+fn main() {\n+\n+}\n+^\n+```\n+\n+As it turns out, there are rules.\n+\n+# The Rules\n+\n+Here\u2019s the rules about borrowing in Rust:\n+\n+First, any borrow must last for a smaller scope than the owner. Second, you may\n+have one or the other of these two kinds of borrows, but not both at the same\n+time:\n+\n+* 0 to N references (`&T`) to a resource.\n+* exactly one mutable reference (`&mut T`)\n+\n+\n+You may notice that this is very similar, though not exactly the same as,\n+to the definition of a data race:\n+\n+> There is a \u2018data race\u2019 when two or more pointers access the same memory\n+> location at the same time, where at least one of them is writing, and the\n+> operations are not synchronized.\n+\n+With references, you may have as many as you\u2019d like, since none of them are\n+writing. If you are writing, you need two or more pointers to the same memory,\n+and you can only have one `&mut` at a time. This is how Rust prevents data\n+races at compile time: we\u2019ll get errors if we break the rules.\n+\n+With this in mind, let\u2019s consider our example again.\n+\n+## Thinking in scopes\n+\n+Here\u2019s the code:\n+\n+```rust,ignore\n+let mut x = 5;\n+let y = &mut x;\n+\n+*y += 1;\n+\n+println!(\"{}\", x);\n+```\n+\n+This code gives us this error:\n+\n+```text\n+error: cannot borrow `x` as immutable because it is also borrowed as mutable\n+    println!(\"{}\", x);\n+                   ^\n+```\n+\n+This is because we\u2019ve violated the rules: we have a `&mut T` pointing to `x`,\n+and so we aren\u2019t allowed to create any `&T`s. One or the other. The note\n+hints at how to think about this problem:\n+\n+```text\n+note: previous borrow ends here\n+fn main() {\n+\n+}\n+^\n+```\n+\n+In other words, the mutable borow is held through the rest of our example. What\n+we want is for the mutable borrow to end _before_ we try to call `println!` and\n+make an immutable borrow. In Rust, borrowing is tied to the scope that the\n+borrow is valid for. And our scopes look like this:\n+\n+```rust,ignore\n+let mut x = 5;\n+\n+let y = &mut x;    // -+ &mut borrow of x starts here\n+                   //  |\n+*y += 1;           //  |\n+                   //  |\n+println!(\"{}\", x); // -+ - try to borrow x here\n+                   // -+ &mut borrow of x ends here\n+```\n+\n+The scopes conflict: we can\u2019t make an `&x` while `y` is in scope.\n+\n+So when we add the curly braces:\n+\n+```rust\n+let mut x = 5;\n+\n+{                   \n+    let y = &mut x; // -+ &mut borrow starts here\n+    *y += 1;        //  |\n+}                   // -+ ... and ends here\n+\n+println!(\"{}\", x);  // <- try to borrow x here\n+```\n+\n+There\u2019s no problem. Our mutable borrow goes out of scope before we create an\n+immutable one. But scope is the key to seeing how long a borrow lasts for.\n+\n+## Issues borrowing prevents\n+\n+Why have these restrictive rules? Well, as we noted, these rules prevent data\n+races. What kinds of issues do data races cause? Here\u2019s a few.\n+\n+### Iterator invalidation\n+\n+One example is \u2018iterator invalidation\u2019, which happens when you try to mutate a\n+collection that you\u2019re iterating over. Rust\u2019s borrow checker prevents this from\n+happening:\n+\n+```rust\n+let mut v = vec![1, 2, 3];\n+\n+for i in &v {\n+    println!(\"{}\", i);\n+}\n+```\n+\n+This prints out one through three. As we iterate through the vectors, we\u2019re\n+only given references to the elements. And `v` is itself borrowed as immutable,\n+which means we can\u2019t change it while we\u2019re iterating:\n+\n+```rust,ignore\n+let mut v = vec![1, 2, 3];\n+\n+for i in &v {\n+    println!(\"{}\", i);\n+    v.push(34);\n+}\n+```\n+\n+Here\u2019s the error:\n+\n+```text\n+error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    v.push(34);\n+    ^\n+note: previous borrow of `v` occurs here; the immutable borrow prevents\n+subsequent moves or mutable borrows of `v` until the borrow ends\n+for i in &v {\n+          ^\n+note: previous borrow ends here\n+for i in &v {\n+    println!(\u201c{}\u201d, i);\n+    v.push(34);\n+}\n+^\n+```\n+\n+We can\u2019t modify `v` because it\u2019s borrowed by the loop.\n+\n+### use after free\n+\n+References must live as long as the resource they refer to. Rust will check the\n+scopes of your references to ensure that this is true.\n+\n+If Rust didn\u2019t check that this property, we could accidentally use a reference\n+which was invalid. For example:\n+\n+```rust,ignore\n+let y: &i32;\n+{ \n+    let x = 5;\n+    y = &x;\n+}\n+\n+println!(\"{}\", y);\n+```\n+\n+We get this error:\n+\n+error: `x` does not live long enough\n+    y = &x;\n+         ^\n+note: reference must be valid for the block suffix following statement 0 at\n+2:16...\n+let y: &i32;\n+{ \n+    let x = 5;\n+    y = &x;\n+}\n+\n+note: ...but borrowed value is only valid for the block suffix following\n+statement 0 at 4:18\n+    let x = 5;\n+    y = &x;\n+}\n+```\n+\n+In other words, `y` is only valid for the scope where `x` exists. As soon as\n+`x` goes away, it becomes invalid to refer to it. As such, the error says that\n+the borrow \u2018doesn\u2019t live long enough\u2019 because it\u2019s not valid for the right\n+amount of time."}]}