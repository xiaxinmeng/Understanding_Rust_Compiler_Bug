{"sha": "b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "node_id": "C_kwDOAAsO6NoAKGI2ZmMyZmM4MmE5MGVlMWRlYjRhNjVjODExNzY0YzYxMDE1NWI2Yjk", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-05-25T23:28:37Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-08-18T02:53:21Z"}, "message": "basic theading", "tree": {"sha": "ba9865caf53519ea8401800e8392e3bf7502553c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba9865caf53519ea8401800e8392e3bf7502553c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "html_url": "https://github.com/rust-lang/rust/commit/b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af033ea428bd469c027d771a9c9fa34485ac495c", "url": "https://api.github.com/repos/rust-lang/rust/commits/af033ea428bd469c027d771a9c9fa34485ac495c", "html_url": "https://github.com/rust-lang/rust/commit/af033ea428bd469c027d771a9c9fa34485ac495c"}], "stats": {"total": 655, "additions": 448, "deletions": 207}, "files": [{"sha": "73c96b2e59abb3c8decf4904e35d3ca71f095ca0", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -5,6 +5,8 @@\n #![feature(try_blocks)]\n #![feature(let_else)]\n #![feature(io_error_more)]\n+#![feature(int_log)]\n+#![feature(variant_count)]\n #![feature(yeet_expr)]\n #![feature(is_some_with)]\n #![feature(nonzero_ops)]"}, {"sha": "8627d9a044790c1740ed1c5cd9d3f5eb86322bf9", "filename": "src/shims/tls.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -229,25 +229,25 @@ impl<'tcx> TlsData<'tcx> {\n \n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Schedule TLS destructors for the main thread on Windows. The\n-    /// implementation assumes that we do not support concurrency on Windows\n-    /// yet.\n+    /// Schedule TLS destructors for Windows.\n+    /// On windows, TLS destructors are managed by std.\n     fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();\n-        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+\n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),\n         // we specifically look up the static in libstd that we know is placed\n         // in that section.\n-        let thread_callback = this\n-            .eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"thread_local_key\", \"p_thread_callback\"])?\n-            .to_pointer(this)?;\n+        let thread_callback =\n+            this.eval_windows(\"thread_local_key\", \"p_thread_callback\")?.to_pointer(this)?;\n         let thread_callback = this.get_ptr_fn(thread_callback)?.as_instance()?;\n \n+        // Technically, the reason should be `DLL_PROCESS_DETACH` when the main thread exits but std ignores it.\n+        let reason = this.eval_windows(\"c\", \"DLL_THREAD_DETACH\")?;\n+\n         // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n-        let reason = this.eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"c\", \"DLL_THREAD_DETACH\"])?;\n         this.call_function(\n             thread_callback,\n             Abi::System { unwind: false },"}, {"sha": "094183b3e781a12302cd9d3a747ad21fc9eae0ce", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 38, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -13,47 +13,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        // Create the new thread\n-        let new_thread_id = this.create_thread();\n-\n-        // Write the current thread-id, switch to the next thread later\n-        // to treat this write operation as occuring on the current thread.\n-        let thread_info_place = this.deref_operand(thread)?;\n-        this.write_scalar(\n-            Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n-            &thread_info_place.into(),\n-        )?;\n-\n-        // Read the function argument that will be sent to the new thread\n-        // before the thread starts executing since reading after the\n-        // context switch will incorrectly report a data-race.\n-        let fn_ptr = this.read_pointer(start_routine)?;\n-        let func_arg = this.read_immediate(arg)?;\n-\n-        // Finally switch to new thread so that we can push the first stackframe.\n-        // After this all accesses will be treated as occuring in the new thread.\n-        let old_thread_id = this.set_active_thread(new_thread_id);\n-\n-        // Perform the function pointer load in the new thread frame.\n-        let instance = this.get_ptr_fn(fn_ptr)?.as_instance()?;\n-\n-        // Note: the returned value is currently ignored (see the FIXME in\n-        // pthread_join below) because the Rust standard library does not use\n-        // it.\n-        let ret_place =\n-            this.allocate(this.layout_of(this.tcx.types.usize)?, MiriMemoryKind::Machine.into())?;\n-\n-        this.call_function(\n-            instance,\n+        this.start_thread(\n+            Some(thread),\n+            start_routine,\n             Abi::C { unwind: false },\n-            &[*func_arg],\n-            Some(&ret_place.into()),\n-            StackPopCleanup::Root { cleanup: true },\n+            arg,\n+            this.layout_of(this.tcx.types.usize)?,\n         )?;\n \n-        // Restore the old active thread frame.\n-        this.set_active_thread(old_thread_id);\n-\n         Ok(0)\n     }\n "}, {"sha": "f18e27d38c2bc20f2b7abd838c91e5c1a659e8ec", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -5,11 +5,13 @@ use rustc_target::spec::abi::Abi;\n use log::trace;\n \n use crate::helpers::check_arg_count;\n+use crate::shims::windows::handle::Handle;\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n     NtWriteFile,\n+    SetThreadDescription,\n }\n \n impl Dlsym {\n@@ -18,8 +20,8 @@ impl Dlsym {\n     pub fn from_str<'tcx>(name: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n         Ok(match name {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n-            \"SetThreadDescription\" => None,\n             \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n+            \"SetThreadDescription\" => Some(Dlsym::SetThreadDescription),\n             _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n         })\n     }\n@@ -107,6 +109,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     dest,\n                 )?;\n             }\n+            Dlsym::SetThreadDescription => {\n+                let [handle, name] = check_arg_count(args)?;\n+\n+                let name = this.read_wide_str(this.read_pointer(name)?)?;\n+\n+                let thread =\n+                    match Handle::from_scalar(this.read_scalar(handle)?.check_init()?, this)? {\n+                        Some(Handle::Thread(thread)) => thread,\n+                        Some(Handle::CurrentThread) => this.get_active_thread(),\n+                        _ => throw_ub_format!(\"invalid handle\"),\n+                    };\n+\n+                this.set_thread_name_wide(thread, name);\n+\n+                this.write_null(dest)?;\n+            }\n         }\n \n         trace!(\"{:?}\", this.dump_place(**dest));"}, {"sha": "00a80f869751ac4277bd8f0fcbbb6eb0df0ef543", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 61, "deletions": 41, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,12 +1,17 @@\n use std::iter;\n+use std::time::{Duration, Instant};\n \n use rustc_span::Symbol;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n+use crate::thread::Time;\n use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n+use shims::windows::handle::{EvalContextExt as _, Handle};\n use shims::windows::sync::EvalContextExt as _;\n+use shims::windows::thread::EvalContextExt as _;\n+\n use smallvec::SmallVec;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -219,6 +224,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n+            \"Sleep\" => {\n+                let [timeout] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.check_no_isolation(\"`Sleep`\")?;\n+\n+                let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n+\n+                let duration = Duration::from_millis(timeout_ms as u64);\n+                let timeout_time = Time::Monotonic(Instant::now().checked_add(duration).unwrap());\n+\n+                let active_thread = this.get_active_thread();\n+                this.block_thread(active_thread);\n+\n+                this.register_timeout_callback(\n+                    active_thread,\n+                    timeout_time,\n+                    Box::new(move |ecx| {\n+                        ecx.unblock_thread(active_thread);\n+                        Ok(())\n+                    }),\n+                );\n+            }\n \n             // Synchronization primitives\n             \"AcquireSRWLockExclusive\" => {\n@@ -314,10 +342,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // FIXME: we should set last_error, but to what?\n                 this.write_null(dest)?;\n             }\n-            \"SwitchToThread\" => {\n+            // this is only callable from std because we know that std ignores the return value\n+            \"SwitchToThread\" if this.frame_in_std() => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                // Note that once Miri supports concurrency, this will need to return a nonzero\n-                // value if this call does result in switching to another thread.\n+\n+                this.yield_active_thread();\n+\n+                // FIXME: this should return a nonzero value if this call does result in switching to another thread.\n                 this.write_null(dest)?;\n             }\n             \"GetStdHandle\" => {\n@@ -329,14 +360,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // std-only shim.\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n+            \"CloseHandle\" => {\n+                let [handle] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n \n-            // Better error for attempts to create a thread\n+                this.CloseHandle(handle)?;\n+\n+                this.write_scalar(Scalar::from_u32(1), dest)?;\n+            }\n+\n+            // Threading\n             \"CreateThread\" => {\n-                let [_, _, _, _, _, _] =\n+                let [security, stacksize, start, arg, flags, thread] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n \n-                this.handle_unsupported(\"can't create threads on Windows\")?;\n-                return Ok(EmulateByNameResult::AlreadyJumped);\n+                let thread_id =\n+                    this.CreateThread(security, stacksize, start, arg, flags, thread)?;\n+\n+                this.write_scalar(Handle::Thread(thread_id).to_scalar(this), dest)?;\n+            }\n+            \"WaitForSingleObject\" => {\n+                let [handle, timeout] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WaitForSingleObject(handle, timeout)?;\n+\n+                this.write_scalar(Scalar::from_u32(0), dest)?;\n+            }\n+            \"GetCurrentThread\" => {\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.write_scalar(Handle::CurrentThread.to_scalar(this), dest)?;\n             }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n@@ -374,40 +428,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_u32(1), dest)?;\n             }\n-            | \"InitializeCriticalSection\"\n-            | \"EnterCriticalSection\"\n-            | \"LeaveCriticalSection\"\n-            | \"DeleteCriticalSection\"\n-                if this.frame_in_std() =>\n-            {\n-                #[allow(non_snake_case)]\n-                let [_lpCriticalSection] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                assert_eq!(\n-                    this.get_total_thread_count(),\n-                    1,\n-                    \"concurrency on Windows is not supported\"\n-                );\n-                // Nothing to do, not even a return value.\n-                // (Windows locks are reentrant, and we have only 1 thread,\n-                // so not doing any futher checks here is at least not incorrect.)\n-            }\n-            \"TryEnterCriticalSection\" if this.frame_in_std() => {\n-                #[allow(non_snake_case)]\n-                let [_lpCriticalSection] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                assert_eq!(\n-                    this.get_total_thread_count(),\n-                    1,\n-                    \"concurrency on Windows is not supported\"\n-                );\n-                // There is only one thread, so this always succeeds and returns TRUE.\n-                this.write_scalar(Scalar::from_i32(1), dest)?;\n-            }\n-            \"GetCurrentThread\" if this.frame_in_std() => {\n-                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n-            }\n             \"GetCurrentProcessId\" if this.frame_in_std() => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetCurrentProcessId()?;"}, {"sha": "ff64a958da3ee19db3361d94cd512f6903ff0822", "filename": "src/shims/windows/handle.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fhandle.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -0,0 +1,162 @@\n+use rustc_target::abi::HasDataLayout;\n+use std::mem::variant_count;\n+\n+use crate::*;\n+\n+/// A Windows `HANDLE` that represents a resource instead of being null or a pseudohandle.\n+///\n+/// This is a seperate type from [`Handle`] to simplify the packing and unpacking code.\n+#[derive(Clone, Copy)]\n+enum RealHandle {\n+    Thread(ThreadId),\n+}\n+\n+impl RealHandle {\n+    const USABLE_BITS: u32 = 31;\n+\n+    const THREAD_DISCRIMINANT: u32 = 1;\n+\n+    fn discriminant(self) -> u32 {\n+        match self {\n+            // can't use zero here because all zero handle is invalid\n+            Self::Thread(_) => Self::THREAD_DISCRIMINANT,\n+        }\n+    }\n+\n+    fn data(self) -> u32 {\n+        match self {\n+            Self::Thread(thread) => thread.to_u32(),\n+        }\n+    }\n+\n+    fn packed_disc_size() -> u32 {\n+        // log2(x) + 1 is how many bits it takes to store x\n+        // because the discriminants start at 1, the variant count is equal to the highest discriminant\n+        variant_count::<Self>().ilog2() + 1\n+    }\n+\n+    /// This function packs the discriminant and data values into a 31-bit space.\n+    /// None of this layout is guaranteed to applications by Windows or Miri.\n+    /// The sign bit is not used to avoid overlapping any pseudo-handles.\n+    fn to_packed(self) -> i32 {\n+        let disc_size = Self::packed_disc_size();\n+        let data_size = Self::USABLE_BITS - disc_size;\n+\n+        let discriminant = self.discriminant();\n+        let data = self.data();\n+\n+        // make sure the discriminant fits into `disc_size` bits\n+        assert!(discriminant < 2u32.pow(disc_size));\n+\n+        // make sure the data fits into `data_size` bits\n+        assert!(data < 2u32.pow(data_size));\n+\n+        // packs the data into the lower `data_size` bits\n+        // and packs the discriminant right above the data\n+        (discriminant << data_size | data) as i32\n+    }\n+\n+    fn new(discriminant: u32, data: u32) -> Option<Self> {\n+        match discriminant {\n+            Self::THREAD_DISCRIMINANT => Some(Self::Thread(data.into())),\n+            _ => None,\n+        }\n+    }\n+\n+    /// see docs for `to_packed`\n+    fn from_packed(handle: i32) -> Option<Self> {\n+        let handle_bits = handle as u32;\n+\n+        let disc_size = Self::packed_disc_size();\n+        let data_size = Self::USABLE_BITS - disc_size;\n+\n+        // the lower `data_size` bits of this mask are 1\n+        let data_mask = 2u32.pow(data_size) - 1;\n+\n+        // the discriminant is stored right above the lower `data_size` bits\n+        let discriminant = handle_bits >> data_size;\n+\n+        // the data is stored in the lower `data_size` bits\n+        let data = handle_bits & data_mask;\n+\n+        Self::new(discriminant, data)\n+    }\n+}\n+\n+/// Miri representation of a Windows `HANDLE`\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Handle {\n+    Null, // = 0\n+\n+    // pseudo-handles\n+    // The lowest real windows pseudo-handle is -6, so miri pseduo-handles start at -7 to break code hardcoding these values\n+    CurrentThread, // = -7\n+\n+    // real handles\n+    Thread(ThreadId),\n+}\n+\n+impl Handle {\n+    const CURRENT_THREAD_VALUE: i32 = -7;\n+\n+    fn to_packed(self) -> i32 {\n+        match self {\n+            Self::Null => 0,\n+            Self::CurrentThread => Self::CURRENT_THREAD_VALUE,\n+            Self::Thread(thread) => RealHandle::Thread(thread).to_packed(),\n+        }\n+    }\n+\n+    pub fn to_scalar(self, cx: &impl HasDataLayout) -> Scalar<Provenance> {\n+        // 64-bit handles are sign extended 32-bit handles\n+        // see https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication\n+        let handle = self.to_packed().into();\n+\n+        Scalar::from_machine_isize(handle, cx)\n+    }\n+\n+    fn from_packed(handle: i64) -> Option<Self> {\n+        let current_thread_val = Self::CURRENT_THREAD_VALUE as i64;\n+\n+        if handle == 0 {\n+            Some(Self::Null)\n+        } else if handle == current_thread_val {\n+            Some(Self::CurrentThread)\n+        } else if let Ok(handle) = handle.try_into() {\n+            match RealHandle::from_packed(handle)? {\n+                RealHandle::Thread(id) => Some(Self::Thread(id)),\n+            }\n+        } else {\n+            // if a handle doesn't fit in an i32, it isn't valid.\n+            None\n+        }\n+    }\n+\n+    pub fn from_scalar<'tcx>(\n+        handle: Scalar<Provenance>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, Option<Self>> {\n+        let handle = handle.to_machine_isize(cx)?;\n+\n+        Ok(Self::from_packed(handle))\n+    }\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+\n+#[allow(non_snake_case)]\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn CloseHandle(&mut self, handle_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        match Handle::from_scalar(this.read_scalar(handle_op)?.check_init()?, this)? {\n+            Some(Handle::Thread(thread)) => this.detach_thread(thread)?,\n+            _ =>\n+                throw_machine_stop!(TerminationInfo::Abort(\n+                    \"invalid handle passed to `CloseHandle`\".into()\n+                )),\n+        };\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "40fe71b2dbd02c6c01071885d0ab5fcda5ad680a", "filename": "src/shims/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fmod.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,6 @@\n pub mod dlsym;\n pub mod foreign_items;\n \n+mod handle;\n mod sync;\n+mod thread;"}, {"sha": "66cd9dd0348fc67b02041674394d0bc37db72c34", "filename": "src/shims/windows/thread.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fthread.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -0,0 +1,84 @@\n+use std::time::{Duration, Instant};\n+\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::thread::Time;\n+use crate::*;\n+use shims::windows::handle::Handle;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+\n+#[allow(non_snake_case)]\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn CreateThread(\n+        &mut self,\n+        security_op: &OpTy<'tcx, Provenance>,\n+        stacksize_op: &OpTy<'tcx, Provenance>,\n+        start_op: &OpTy<'tcx, Provenance>,\n+        arg_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        thread_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ThreadId> {\n+        let this = self.eval_context_mut();\n+\n+        if !this.ptr_is_null(this.read_pointer(security_op)?)? {\n+            throw_unsup_format!(\"non-null `lpThreadAttributes` in `CreateThread`\")\n+        }\n+\n+        // stacksize is ignored, but still needs to be a valid usize\n+        let _ = this.read_scalar(stacksize_op)?.to_machine_usize(this)?;\n+\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+\n+        let stack_size_param_is_a_reservation =\n+            this.eval_windows(\"c\", \"STACK_SIZE_PARAM_IS_A_RESERVATION\")?.to_u32()?;\n+\n+        if flags != 0 && flags != stack_size_param_is_a_reservation {\n+            throw_unsup_format!(\"unsupported `dwCreationFlags` {} in `CreateThread`\", flags)\n+        }\n+\n+        let thread =\n+            if this.ptr_is_null(this.read_pointer(thread_op)?)? { None } else { Some(thread_op) };\n+\n+        this.start_thread(\n+            thread,\n+            start_op,\n+            Abi::System { unwind: false },\n+            arg_op,\n+            this.layout_of(this.tcx.types.u32)?,\n+        )\n+    }\n+\n+    fn WaitForSingleObject(\n+        &mut self,\n+        handle: &OpTy<'tcx, Provenance>,\n+        timeout: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let thread = match Handle::from_scalar(this.read_scalar(handle)?.check_init()?, this)? {\n+            Some(Handle::Thread(thread)) => thread,\n+            Some(Handle::CurrentThread) => throw_ub_format!(\"trying to wait on itself\"),\n+            _ => throw_ub_format!(\"invalid handle\"),\n+        };\n+\n+        if this.read_scalar(timeout)?.to_u32()? != this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            this.check_no_isolation(\"`WaitForSingleObject` with non-infinite timeout\")?;\n+        }\n+\n+        let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n+\n+        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            None\n+        } else {\n+            let duration = Duration::from_millis(timeout_ms as u64);\n+\n+            Some(Time::Monotonic(Instant::now().checked_add(duration).unwrap()))\n+        };\n+\n+        this.wait_on_thread(timeout_time, thread)?;\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "fa70dcfa2a3de12cbe44d430c80c4a4fbf21988c", "filename": "src/thread.rs", "status": "modified", "additions": 93, "deletions": 20, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -11,6 +11,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_target::spec::abi::Abi;\n \n use crate::concurrency::data_race;\n use crate::sync::SynchronizationState;\n@@ -179,7 +181,7 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n }\n \n /// A specific moment in time.\n-#[derive(Debug)]\n+#[derive(Debug, Copy, Clone)]\n pub enum Time {\n     Monotonic(Instant),\n     RealTime(SystemTime),\n@@ -238,10 +240,7 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n     fn default() -> Self {\n         let mut threads = IndexVec::new();\n         // Create the main thread and add it to the list of threads.\n-        let mut main_thread = Thread::new(\"main\");\n-        // The main thread can *not* be joined on.\n-        main_thread.join_status = ThreadJoinStatus::Detached;\n-        threads.push(main_thread);\n+        threads.push(Thread::new(\"main\"));\n         Self {\n             active_thread: ThreadId::new(0),\n             threads,\n@@ -254,6 +253,13 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n+    pub(crate) fn init(ecx: &mut MiriEvalContext<'mir, 'tcx>) {\n+        if ecx.tcx.sess.target.os.as_ref() != \"windows\" {\n+            // The main thread can *not* be joined on except on windows.\n+            ecx.machine.threads.threads[ThreadId::new(0)].join_status = ThreadJoinStatus::Detached;\n+        }\n+    }\n+\n     /// Check if we have an allocation for the given thread local static for the\n     /// active thread.\n     fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<Pointer<Provenance>> {\n@@ -348,10 +354,23 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Mark the thread as detached, which means that no other thread will try\n     /// to join it and the thread is responsible for cleaning up.\n-    fn detach_thread(&mut self, id: ThreadId) -> InterpResult<'tcx> {\n-        if self.threads[id].join_status != ThreadJoinStatus::Joinable {\n+    ///\n+    /// `allow_terminated_joined` allows detaching joined threads that have already terminated.\n+    /// This matches Windows's behavior for `CloseHandle`.\n+    fn detach_thread(&mut self, id: ThreadId, allow_terminated_joined: bool) -> InterpResult<'tcx> {\n+        trace!(\"detaching {:?}\", id);\n+\n+        let is_ub = if allow_terminated_joined && self.threads[id].state == ThreadState::Terminated\n+        {\n+            self.threads[id].join_status == ThreadJoinStatus::Detached\n+        } else {\n+            self.threads[id].join_status != ThreadJoinStatus::Joinable\n+        };\n+\n+        if is_ub {\n             throw_ub_format!(\"trying to detach thread that was already detached or joined\");\n         }\n+\n         self.threads[id].join_status = ThreadJoinStatus::Detached;\n         Ok(())\n     }\n@@ -362,18 +381,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         joined_thread_id: ThreadId,\n         data_race: Option<&mut data_race::GlobalState>,\n     ) -> InterpResult<'tcx> {\n-        if self.threads[joined_thread_id].join_status != ThreadJoinStatus::Joinable {\n-            throw_ub_format!(\"trying to join a detached or already joined thread\");\n-        }\n-        if joined_thread_id == self.active_thread {\n-            throw_ub_format!(\"trying to join itself\");\n+        if self.threads[joined_thread_id].join_status == ThreadJoinStatus::Detached {\n+            throw_ub_format!(\"trying to join a detached thread\");\n         }\n-        assert!(\n-            self.threads\n-                .iter()\n-                .all(|thread| thread.state != ThreadState::BlockedOnJoin(joined_thread_id)),\n-            \"a joinable thread already has threads waiting for its termination\"\n-        );\n+\n         // Mark the joined thread as being joined so that we detect if other\n         // threads try to join it.\n         self.threads[joined_thread_id].join_status = ThreadJoinStatus::Joined;\n@@ -624,9 +635,62 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn detach_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n+    fn start_thread(\n+        &mut self,\n+        thread: Option<MPlaceTy<'tcx, Provenance>>,\n+        start_routine: Pointer<Option<Provenance>>,\n+        start_abi: Abi,\n+        func_arg: ImmTy<'tcx, Provenance>,\n+        ret_layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ThreadId> {\n+        let this = self.eval_context_mut();\n+\n+        // Create the new thread\n+        let new_thread_id = this.create_thread();\n+\n+        // Write the current thread-id, switch to the next thread later\n+        // to treat this write operation as occuring on the current thread.\n+        if let Some(thread_info_place) = thread {\n+            this.write_scalar(\n+                Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n+                &thread_info_place.into(),\n+            )?;\n+        }\n+\n+        // Finally switch to new thread so that we can push the first stackframe.\n+        // After this all accesses will be treated as occuring in the new thread.\n+        let old_thread_id = this.set_active_thread(new_thread_id);\n+\n+        // Perform the function pointer load in the new thread frame.\n+        let instance = this.get_ptr_fn(start_routine)?.as_instance()?;\n+\n+        // Note: the returned value is currently ignored (see the FIXME in\n+        // pthread_join in shims/unix/thread.rs) because the Rust standard library does not use\n+        // it.\n+        let ret_place = this.allocate(ret_layout, MiriMemoryKind::Machine.into())?;\n+\n+        this.call_function(\n+            instance,\n+            start_abi,\n+            &[*func_arg],\n+            Some(&ret_place.into()),\n+            StackPopCleanup::Root { cleanup: true },\n+        )?;\n+\n+        // Restore the old active thread frame.\n+        this.set_active_thread(old_thread_id);\n+\n+        Ok(new_thread_id)\n+    }\n+\n+    #[inline]\n+    fn detach_thread(\n+        &mut self,\n+        thread_id: ThreadId,\n+        allow_terminated_joined: bool,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.detach_thread(thread_id)\n+        this.machine.threads.detach_thread(thread_id, allow_terminated_joined)\n     }\n \n     #[inline]\n@@ -704,6 +768,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.set_thread_name(thread, new_thread_name);\n     }\n \n+    #[inline]\n+    fn set_thread_name_wide(&mut self, thread: ThreadId, new_thread_name: Vec<u16>) {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.set_thread_name(\n+            thread,\n+            new_thread_name.into_iter().flat_map(u16::to_ne_bytes).collect(),\n+        );\n+    }\n+\n     #[inline]\n     fn get_thread_name<'c>(&'c self, thread: ThreadId) -> &'c [u8]\n     where"}, {"sha": "e1d3704af7c0b54cf7d69d402fbc4bed72e7f8b9", "filename": "tests/fail/concurrency/libc_pthread_create_too_few_args.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: No libc on Windows\n \n //! The thread function must have exactly one argument.\n ", "previous_filename": "tests/fail/concurrency/too_few_args.rs"}, {"sha": "2304b42b2c786e6bb3eff7010147b85c3c6b19a7", "filename": "tests/fail/concurrency/libc_pthread_create_too_few_args.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,5 +1,5 @@\n error: Undefined Behavior: callee has fewer arguments than expected\n-  --> $DIR/too_few_args.rs:LL:CC\n+  --> $DIR/libc_pthread_create_too_few_args.rs:LL:CC\n    |\n LL |     panic!()\n    |     ^^^^^^^^ callee has fewer arguments than expected", "previous_filename": "tests/fail/concurrency/too_few_args.stderr"}, {"sha": "7408634db528fee3540fe7d52e02c2d87fd3130b", "filename": "tests/fail/concurrency/libc_pthread_create_too_many_args.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: No libc on Windows\n \n //! The thread function must have exactly one argument.\n ", "previous_filename": "tests/fail/concurrency/too_many_args.rs"}, {"sha": "49c7f579970f23c8fe158670b5d685fdfe0314c4", "filename": "tests/fail/concurrency/libc_pthread_create_too_many_args.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,5 +1,5 @@\n error: Undefined Behavior: callee has more arguments than expected\n-  --> $DIR/too_many_args.rs:LL:CC\n+  --> $DIR/libc_pthread_create_too_many_args.rs:LL:CC\n    |\n LL |     panic!()\n    |     ^^^^^^^^ callee has more arguments than expected", "previous_filename": "tests/fail/concurrency/too_many_args.stderr"}, {"sha": "0b810dc8c7212e59f0c69b14dc888962a8f0bb96", "filename": "tests/fail/concurrency/libc_pthread_join_detached.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -15,6 +15,6 @@ fn main() {\n         // assert_eq!(libc::pthread_attr_init(&mut attr), 0); FIXME: this function is not yet implemented.\n         assert_eq!(libc::pthread_create(&mut native, &attr, thread_start, ptr::null_mut()), 0);\n         assert_eq!(libc::pthread_detach(native), 0);\n-        assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached or already joined thread\n+        assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached thread\n     }\n }"}, {"sha": "e381a71b252048efde51e936e13c3432f82f89d9", "filename": "tests/fail/concurrency/libc_pthread_join_detached.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -2,7 +2,7 @@ error: Undefined Behavior: trying to join a detached or already joined thread\n   --> $DIR/libc_pthread_join_detached.rs:LL:CC\n    |\n LL | ...   assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached or already joined thread\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "84848e35a0f3e75312564ba48ff27defb1a859f6", "filename": "tests/fail/concurrency/thread-spawn.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af033ea428bd469c027d771a9c9fa34485ac495c/tests%2Ffail%2Fconcurrency%2Fthread-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af033ea428bd469c027d771a9c9fa34485ac495c/tests%2Ffail%2Fconcurrency%2Fthread-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread-spawn.rs?ref=af033ea428bd469c027d771a9c9fa34485ac495c", "patch": "@@ -1,9 +0,0 @@\n-//@only-target-windows: Only Windows is not supported.\n-\n-use std::thread;\n-\n-//@error-pattern: can't create threads on Windows\n-\n-fn main() {\n-    thread::spawn(|| {});\n-}"}, {"sha": "2e4b3a045e6915e2c29853fa95d9878811db1f32", "filename": "tests/fail/concurrency/thread-spawn.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af033ea428bd469c027d771a9c9fa34485ac495c/tests%2Ffail%2Fconcurrency%2Fthread-spawn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af033ea428bd469c027d771a9c9fa34485ac495c/tests%2Ffail%2Fconcurrency%2Fthread-spawn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread-spawn.stderr?ref=af033ea428bd469c027d771a9c9fa34485ac495c", "patch": "@@ -1,30 +0,0 @@\n-error: unsupported operation: can't create threads on Windows\n-  --> RUSTLIB/std/src/sys/PLATFORM/thread.rs:LL:CC\n-   |\n-LL |           let ret = c::CreateThread(\n-   |  ___________________^\n-LL | |             ptr::null_mut(),\n-LL | |             stack,\n-LL | |             thread_start,\n-...  |\n-LL | |             ptr::null_mut(),\n-LL | |         );\n-   | |_________^ can't create threads on Windows\n-   |\n-   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n-   = note: backtrace:\n-   = note: inside `std::sys::PLATFORM::thread::Thread::new` at RUSTLIB/std/src/sys/PLATFORM/thread.rs:LL:CC\n-   = note: inside `std::thread::Builder::spawn_unchecked_::<[closure@$DIR/thread-spawn.rs:LL:CC], ()>` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n-   = note: inside `std::thread::Builder::spawn_unchecked::<[closure@$DIR/thread-spawn.rs:LL:CC], ()>` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n-   = note: inside `std::thread::Builder::spawn::<[closure@$DIR/thread-spawn.rs:LL:CC], ()>` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n-   = note: inside `std::thread::spawn::<[closure@$DIR/thread-spawn.rs:LL:CC], ()>` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n-note: inside `main` at $DIR/thread-spawn.rs:LL:CC\n-  --> $DIR/thread-spawn.rs:LL:CC\n-   |\n-LL |     thread::spawn(|| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "d89c670b632e6d5735fee65270cc2fd7121c6900", "filename": "tests/fail/concurrency/thread_local_static_dealloc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,5 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n-\n //! Ensure that thread-local statics get deallocated when the thread dies.\n \n #![feature(thread_local)]"}, {"sha": "61d3b964e620b4e314dc4863e7144f65bd4fac21", "filename": "tests/fail/concurrency/unwind_top_of_stack.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,5 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-windows: No libc on Windows\n+\n //@compile-flags: -Zmiri-disable-abi-check\n \n //! Unwinding past the top frame of a stack is Undefined Behavior."}, {"sha": "0bd3068af1ffe9995c8db5937ecd70115df08f88", "filename": "tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n #![feature(new_uninit)]\n "}, {"sha": "7991280721e293907d0783a07b62a708e71c1965", "filename": "tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n #![feature(new_uninit)]\n "}, {"sha": "2b0446d724a029e6fb8531ce494a61bafd95b71e", "filename": "tests/fail/data_race/atomic_read_na_write_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "ef5157515c64a3274eff556b247e98b83d52e8f6", "filename": "tests/fail/data_race/atomic_read_na_write_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "8c17e7674843832ca6ba2182584ccb1fab1785c5", "filename": "tests/fail/data_race/atomic_write_na_read_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "f14d7c704dbb18e43df9930a42fb626ed4ccbca7", "filename": "tests/fail/data_race/atomic_write_na_read_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "0804b33407580c8b8e8b96ecadc403b2c15d8e42", "filename": "tests/fail/data_race/atomic_write_na_write_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "658cddcc9c5b609a1dd6a69d9e0c9caa3aa997fb", "filename": "tests/fail/data_race/atomic_write_na_write_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "af2588e923240d43070dafedbf871fbe5f0c68cc", "filename": "tests/fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "1ee619c3f99d573ab20f86f7012f048083b65449", "filename": "tests/fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "cbc02549a2541c72c64fa81588dbe4f3e9988834", "filename": "tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "24cce5d6fac1cb7495ccb7129fda8aebd1670ff5", "filename": "tests/fail/data_race/dealloc_read_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "5484370f35c17bd0a89da9ee08e47c89f516857f", "filename": "tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::ptr::null_mut;"}, {"sha": "23bf73fe8c5adf6d687d4312fddc8b4202823367", "filename": "tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "7c8033e2335e99e3d0d34120ef589a9f742979af", "filename": "tests/fail/data_race/dealloc_write_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "1872abfe021b305d38ba9443332d5a2a17a08933", "filename": "tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::ptr::null_mut;"}, {"sha": "c11239da7febba4710b45d0f7c64a2a2cc7a297f", "filename": "tests/fail/data_race/enable_after_join_to_main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "ae443908598fe59b20f18103fe378d6d7ef5da75", "filename": "tests/fail/data_race/fence_after_load.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n use std::sync::atomic::{fence, AtomicUsize, Ordering};\n use std::sync::Arc;\n use std::thread;"}, {"sha": "482dd2df7df91111604627eec894a169daac832e", "filename": "tests/fail/data_race/read_write_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "1b4932439b010ebbfb0ec476b1e16a04be6b6cac", "filename": "tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n // Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1"}, {"sha": "240b4c90eb225d6f846807fe51d592975cdd58c9", "filename": "tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "5ae801278357b56247c1b7c36374d45eda4d7ef2", "filename": "tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "63e6dc2dd71b9e7f0622d15ab8584ff976b6baff", "filename": "tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "122780d11aa1f612e34e05c968173c70e6d4ff34", "filename": "tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "13c31c87cbbaedd9945f0a4e3516e39cf201f935", "filename": "tests/fail/data_race/write_write_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "731ac8b26aa74fe9eba4aad64ac537537c627788", "filename": "tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::ptr::null_mut;"}, {"sha": "545875a582a462d9909806772749adcd52326fa7", "filename": "tests/fail/should-pass/cpp20_rwc_syncs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks\n \n // https://plv.mpi-sws.org/scfix/paper.pdf"}, {"sha": "7bbb7f9fe7c2a124ce3599f5ec3c63b331573c94", "filename": "tests/fail/weak_memory/racing_mixed_size.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n #![feature(core_intrinsics)]\n "}, {"sha": "73178980b7e5a38214433ab36f11ccaea643f0db", "filename": "tests/fail/weak_memory/racing_mixed_size_read.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::Ordering::*;\n use std::sync::atomic::{AtomicU16, AtomicU32};"}, {"sha": "8c650bca2f36b78426f1dd0256bf159683eddb5c", "filename": "tests/pass/0weak_memory_consistency.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2F0weak_memory_consistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2F0weak_memory_consistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2F0weak_memory_consistency.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks -Zmiri-disable-stacked-borrows\n \n // The following tests check whether our weak memory emulation produces"}, {"sha": "c75c5199bf11d6be6bb3de885552f8068eef6ac3", "filename": "tests/pass/concurrency/channels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fchannels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fchannels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fchannels.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Channels on Windows are not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n use std::sync::mpsc::{channel, sync_channel};"}, {"sha": "0490330a15d8b53337c40b502dd6e257152130aa", "filename": "tests/pass/concurrency/concurrent_caller_location.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,5 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n-\n use std::panic::Location;\n use std::thread::spawn;\n "}, {"sha": "4e3c99058a0df9783bc930e13596a7c195fa2f86", "filename": "tests/pass/concurrency/data_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdata_race.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{fence, AtomicUsize, Ordering};"}, {"sha": "d71e51b038429b0316e9b622005aa40a43aa5528", "filename": "tests/pass/concurrency/disable_data_race_detector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-data-race-detector\n \n use std::thread::spawn;"}, {"sha": "c0956569ad8f918c82e6df267b0f69571b6d1df5", "filename": "tests/pass/concurrency/issue1643.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fissue1643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fissue1643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fissue1643.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,5 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n-\n use std::thread::spawn;\n \n fn initialize() {"}, {"sha": "556e0a24769d7dcea8fc48c8039368a21bcf3e5b", "filename": "tests/pass/concurrency/simple.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsimple.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n use std::thread;"}, {"sha": "019bd44f164888fcf022fe1293c6515d265f13fa", "filename": "tests/pass/concurrency/spin_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread;\n "}, {"sha": "5d8e2ef5f0282deea0f6b18cef1eb4ff973710d7", "filename": "tests/pass/concurrency/spin_loops_nopreempt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Channels on Windows are not supported yet.\n // This specifically tests behavior *without* preemption.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "b19e56312f304ddd60ed2714a48942bed3d45ae0", "filename": "tests/pass/concurrency/thread_locals.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fthread_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Fthread_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fthread_locals.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n //! The main purpose of this test is to check that if we take a pointer to"}, {"sha": "8ce011ede34e031ea1d189f5c0bf03bf9c8555e7", "filename": "tests/pass/concurrency/tls_lib_drop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,5 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n-\n use std::cell::RefCell;\n use std::thread;\n "}, {"sha": "342269c6acbe3e21d420657cd86e1703fd27b45e", "filename": "tests/pass/panic/concurrent-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "23b5ab57efa02e93656bd6982164ec794d49e2a6", "filename": "tests/pass/shims/time.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fshims%2Ftime.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -8,8 +8,6 @@ fn duration_sanity(diff: Duration) {\n     assert!(diff.as_millis() < 500);\n }\n \n-// Sleeping on Windows is not supported yet.\n-#[cfg(unix)]\n fn test_sleep() {\n     let before = Instant::now();\n     std::thread::sleep(Duration::from_millis(100));\n@@ -50,6 +48,5 @@ fn main() {\n     assert_eq!(now2 - diff, now1);\n     duration_sanity(diff);\n \n-    #[cfg(unix)]\n     test_sleep();\n }"}, {"sha": "99bac7aa42a808a23705a231aa8ac96519d25c57", "filename": "tests/pass/threadleak_ignored.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fthreadleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fthreadleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fthreadleak_ignored.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Channels on Windows are not supported yet.\n // FIXME: disallow preemption to work around https://github.com/rust-lang/rust/issues/55005\n //@compile-flags: -Zmiri-ignore-leaks -Zmiri-preemption-rate=0\n "}, {"sha": "07cbb4a803f1f23e03ada83c42030f5735338cf7", "filename": "tests/pass/weak_memory/extra_cpp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks\n \n // Tests operations not perfomable through C++'s atomic API"}, {"sha": "f7e2748408ff8fbff16ad5e8972d1e9bf63727da", "filename": "tests/pass/weak_memory/extra_cpp_unsafe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks\n \n // Tests operations not perfomable through C++'s atomic API"}, {"sha": "4c3be6b3559ae52b45aec6b06a837138a484ce8b", "filename": "tests/pass/weak_memory/weak.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fweak_memory%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6fc2fc82a90ee1deb4a65c811764c610155b6b9/tests%2Fpass%2Fweak_memory%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fweak.rs?ref=b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks -Zmiri-preemption-rate=0\n \n // Tests showing weak memory behaviours are exhibited. All tests"}]}