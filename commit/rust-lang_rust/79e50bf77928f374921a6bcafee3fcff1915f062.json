{"sha": "79e50bf77928f374921a6bcafee3fcff1915f062", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZTUwYmY3NzkyOGYzNzQ5MjFhNmJjYWZlZTNmY2ZmMTkxNWYwNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-10T21:32:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-10T21:32:13Z"}, "message": "Auto merge of #84677 - CDirkx:pal, r=Mark-Simulacrum\n\nFix `tidy` platform-specific code check\n\nI noticed new platform-specific code was introduced outside of `std::sys` ([example](https://github.com/rust-lang/rust/blob/master/library/std/src/thread/available_concurrency.rs)), which should have been checked against by `tidy`. Apparently there are 2 problems with the current check implementation:\n\n- It ignores everything after encountering \"mod tests\", which is often at the very top of a file.\n- There was a bug where when checking the byte immediately before a found string, the first byte of the file was checked instead.\n\nI fixed the bug and made excluding tests a bit more robust by instead adding the following rules:\n- Files with a path containing either `tests` or `benches` are excluded.\n- A `cfg(...)` containing `test` is excluded.\n\n(Tests are excluded because almost all tests have something like `#[cfg(not(target_os = \"emscripten\"))]` somewhere.)\n\nThe fixed check found some more cases of platform-specific code; for now I have explicitly excluded them and added a FIXME stating that the platform-specific code must be moved to `sys`.", "tree": {"sha": "6b110ba76f124b49d08038f30e73093b78e05211", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b110ba76f124b49d08038f30e73093b78e05211"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79e50bf77928f374921a6bcafee3fcff1915f062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79e50bf77928f374921a6bcafee3fcff1915f062", "html_url": "https://github.com/rust-lang/rust/commit/79e50bf77928f374921a6bcafee3fcff1915f062", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79e50bf77928f374921a6bcafee3fcff1915f062/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fd7a6dc0f5c4c8fd51d57c0f4f795d52481f904", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fd7a6dc0f5c4c8fd51d57c0f4f795d52481f904", "html_url": "https://github.com/rust-lang/rust/commit/6fd7a6dc0f5c4c8fd51d57c0f4f795d52481f904"}, {"sha": "4d90635adc953f56d946925e56d189aabd4d3199", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d90635adc953f56d946925e56d189aabd4d3199", "html_url": "https://github.com/rust-lang/rust/commit/4d90635adc953f56d946925e56d189aabd4d3199"}], "stats": {"total": 76, "additions": 28, "deletions": 48}, "files": [{"sha": "db177f75ceae9e906899bbe6a4b03da899cb3cba", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 28, "deletions": 48, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/79e50bf77928f374921a6bcafee3fcff1915f062/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e50bf77928f374921a6bcafee3fcff1915f062/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=79e50bf77928f374921a6bcafee3fcff1915f062", "patch": "@@ -21,8 +21,7 @@\n //! - libunwind may have platform-specific code.\n //! - other crates in the std facade may not.\n //! - std may have platform-specific code in the following places:\n-//!   - `sys/unix/`\n-//!   - `sys/windows/`\n+//!   - `sys/`\n //!   - `os/`\n //!\n //! `std/sys_common` should _not_ contain platform-specific code.\n@@ -36,34 +35,30 @@ use std::path::Path;\n \n // Paths that may contain platform-specific code.\n const EXCEPTION_PATHS: &[&str] = &[\n-    // std crates\n     \"library/panic_abort\",\n     \"library/panic_unwind\",\n     \"library/unwind\",\n-    \"library/std/src/sys/\", // Platform-specific code for std lives here.\n-    // This has the trailing slash so that sys_common is not excepted.\n-    \"library/std/src/os\", // Platform-specific public interfaces\n-    \"library/rtstartup\",  // Not sure what to do about this. magic stuff for mingw\n-    // Integration test for platform-specific run-time feature detection:\n-    \"library/std/tests/run-time-detect.rs\",\n-    \"library/std/src/net/test.rs\",\n-    \"library/std/src/net/addr\",\n-    \"library/std/src/net/udp\",\n-    \"library/std/src/sys_common/remutex.rs\",\n-    \"library/std/src/sync/mutex.rs\",\n-    \"library/std/src/sync/rwlock.rs\",\n-    \"library/term\", // Not sure how to make this crate portable, but test crate needs it.\n-    \"library/test\", // Probably should defer to unstable `std::sys` APIs.\n-    // std testing crates, okay for now at least\n-    \"library/core/tests\",\n-    \"library/alloc/tests/lib.rs\",\n-    \"library/alloc/benches/lib.rs\",\n+    \"library/rtstartup\", // Not sure what to do about this. magic stuff for mingw\n+    \"library/term\",      // Not sure how to make this crate portable, but test crate needs it.\n+    \"library/test\",      // Probably should defer to unstable `std::sys` APIs.\n     // The `VaList` implementation must have platform specific code.\n     // The Windows implementation of a `va_list` is always a character\n     // pointer regardless of the target architecture. As a result,\n     // we must use `#[cfg(windows)]` to conditionally compile the\n     // correct `VaList` structure for windows.\n     \"library/core/src/ffi.rs\",\n+    \"library/std/src/sys/\", // Platform-specific code for std lives here.\n+    \"library/std/src/os\",   // Platform-specific public interfaces\n+    // Temporary `std` exceptions\n+    // FIXME: platform-specific code should be moved to `sys`\n+    \"library/std/src/io/copy.rs\",\n+    \"library/std/src/io/stdio.rs\",\n+    \"library/std/src/f32.rs\",\n+    \"library/std/src/f64.rs\",\n+    \"library/std/src/path.rs\",\n+    \"library/std/src/thread/available_concurrency.rs\",\n+    \"library/std/src/sys_common\", // Should only contain abstractions over platforms\n+    \"library/std/src/net/test.rs\", // Utility helpers for tests\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {\n@@ -82,6 +77,11 @@ pub fn check(path: &Path, bad: &mut bool) {\n             return;\n         }\n \n+        // exclude tests and benchmarks as some platforms do not support all tests\n+        if filestr.contains(\"tests\") || filestr.contains(\"benches\") {\n+            return;\n+        }\n+\n         check_cfgs(contents, &file, bad, &mut saw_target_arch, &mut saw_cfg_bang);\n     });\n \n@@ -96,9 +96,6 @@ fn check_cfgs(\n     saw_target_arch: &mut bool,\n     saw_cfg_bang: &mut bool,\n ) {\n-    // For now it's ok to have platform-specific code after 'mod tests'.\n-    let mod_tests_idx = find_test_mod(contents);\n-    let contents = &contents[..mod_tests_idx];\n     // Pull out all `cfg(...)` and `cfg!(...)` strings.\n     let cfgs = parse_cfgs(contents);\n \n@@ -149,39 +146,22 @@ fn check_cfgs(\n             continue;\n         }\n \n-        err(idx, cfg);\n-    }\n-}\n-\n-fn find_test_mod(contents: &str) -> usize {\n-    if let Some(mod_tests_idx) = contents.find(\"mod tests\") {\n-        // Also capture a previous line indicating that \"mod tests\" is cfg'd out.\n-        let prev_newline_idx = contents[..mod_tests_idx].rfind('\\n').unwrap_or(mod_tests_idx);\n-        let prev_newline_idx = contents[..prev_newline_idx].rfind('\\n');\n-        if let Some(nl) = prev_newline_idx {\n-            let prev_line = &contents[nl + 1..mod_tests_idx];\n-            if prev_line.contains(\"cfg(all(test, not(target_os\")\n-                || prev_line.contains(\"cfg(all(test, not(any(target_os\")\n-            {\n-                nl\n-            } else {\n-                mod_tests_idx\n-            }\n-        } else {\n-            mod_tests_idx\n+        // exclude tests as some platforms do not support all tests\n+        if cfg.contains(\"test\") {\n+            continue;\n         }\n-    } else {\n-        contents.len()\n+\n+        err(idx, cfg);\n     }\n }\n \n-fn parse_cfgs<'a>(contents: &'a str) -> Vec<(usize, &'a str)> {\n+fn parse_cfgs(contents: &str) -> Vec<(usize, &str)> {\n     let candidate_cfgs = contents.match_indices(\"cfg\");\n     let candidate_cfg_idxs = candidate_cfgs.map(|(i, _)| i);\n     // This is puling out the indexes of all \"cfg\" strings\n     // that appear to be tokens followed by a parenthesis.\n     let cfgs = candidate_cfg_idxs.filter(|i| {\n-        let pre_idx = i.saturating_sub(*i);\n+        let pre_idx = i.saturating_sub(1);\n         let succeeds_non_ident = !contents\n             .as_bytes()\n             .get(pre_idx)"}]}