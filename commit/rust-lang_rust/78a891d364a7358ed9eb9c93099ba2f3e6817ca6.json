{"sha": "78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "node_id": "C_kwDOAAsO6NoAKDc4YTg5MWQzNjRhNzM1OGVkOWViOWM5MzA5OWJhMmYzZTY4MTdjYTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-06T18:10:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-06T18:10:14Z"}, "message": "Auto merge of #101485 - GuillaumeGomez:rollup-68p9di4, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #101357 (Include enum path in variant suggestion)\n - #101434 (Update `SessionDiagnostic::into_diagnostic` to take `Handler` instead of `ParseSess`)\n - #101445 (Suggest introducing an explicit lifetime if it does not exist)\n - #101457 (Recover from using `;` as separator between fields)\n - #101462 (Rustdoc-Json: Store Variant Fields as their own item.)\n - #101471 (Report number of delayed bugs properly with `-Ztreat-err-as-bug`)\n - #101473 (Add more size assertions for MIR types.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "70b18f31803977bff2e445b6c26fa7c8e0aba8e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70b18f31803977bff2e445b6c26fa7c8e0aba8e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "html_url": "https://github.com/rust-lang/rust/commit/78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "380addd7d2971447d7f6828c508a93fa8018a9b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/380addd7d2971447d7f6828c508a93fa8018a9b6", "html_url": "https://github.com/rust-lang/rust/commit/380addd7d2971447d7f6828c508a93fa8018a9b6"}, {"sha": "f21b6129a018a5c55b48bad83f50730eca03d02d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f21b6129a018a5c55b48bad83f50730eca03d02d", "html_url": "https://github.com/rust-lang/rust/commit/f21b6129a018a5c55b48bad83f50730eca03d02d"}], "stats": {"total": 1091, "additions": 707, "deletions": 384}, "files": [{"sha": "e1404ab15efa37add14cfed8823837b20c016c7a", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -63,7 +63,12 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n             sess.emit_err(session_diagnostics::MultipleStabilityLevels { span });\n         }\n         AttrError::UnsupportedLiteral(reason, is_bytestr) => {\n-            sess.emit_err(session_diagnostics::UnsupportedLiteral { span, reason, is_bytestr });\n+            sess.emit_err(session_diagnostics::UnsupportedLiteral {\n+                span,\n+                reason,\n+                is_bytestr,\n+                start_point_span: sess.source_map().start_point(span),\n+            });\n         }\n     }\n }"}, {"sha": "085175d4bed1fbbe9669eaa1fa21f51bd1cf082b", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,9 +1,11 @@\n use std::num::IntErrorKind;\n \n use rustc_ast as ast;\n-use rustc_errors::{error_code, fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{\n+    error_code, fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler,\n+};\n use rustc_macros::SessionDiagnostic;\n-use rustc_session::{parse::ParseSess, SessionDiagnostic};\n+use rustc_session::SessionDiagnostic;\n use rustc_span::{Span, Symbol};\n \n use crate::UnsupportedLiteralReason;\n@@ -49,9 +51,9 @@ pub(crate) struct UnknownMetaItem<'a> {\n \n // Manual implementation to be able to format `expected` items correctly.\n impl<'a> SessionDiagnostic<'a> for UnknownMetaItem<'_> {\n-    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let expected = self.expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n-        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+        let mut diag = handler.struct_span_err_with_code(\n             self.span,\n             fluent::attr::unknown_meta_item,\n             error_code!(E0541),\n@@ -204,11 +206,12 @@ pub(crate) struct UnsupportedLiteral {\n     pub span: Span,\n     pub reason: UnsupportedLiteralReason,\n     pub is_bytestr: bool,\n+    pub start_point_span: Span,\n }\n \n impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n-    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n             self.span,\n             match self.reason {\n                 UnsupportedLiteralReason::Generic => fluent::attr::unsupported_literal_generic,\n@@ -224,7 +227,7 @@ impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n         );\n         if self.is_bytestr {\n             diag.span_suggestion(\n-                sess.source_map().start_point(self.span),\n+                self.start_point_span,\n                 fluent::attr::unsupported_literal_suggestion,\n                 \"\",\n                 Applicability::MaybeIncorrect,"}, {"sha": "37ff6dcff7d795c26efaef3eadc111c9ad5ed81d", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1250,14 +1250,14 @@ impl HandlerInner {\n \n     fn treat_err_as_bug(&self) -> bool {\n         self.flags.treat_err_as_bug.map_or(false, |c| {\n-            self.err_count()\n-                + self.lint_err_count\n-                + self.delayed_span_bugs.len()\n-                + self.delayed_good_path_bugs.len()\n-                >= c.get()\n+            self.err_count() + self.lint_err_count + self.delayed_bug_count() >= c.get()\n         })\n     }\n \n+    fn delayed_bug_count(&self) -> usize {\n+        self.delayed_span_bugs.len() + self.delayed_good_path_bugs.len()\n+    }\n+\n     fn print_error_count(&mut self, registry: &Registry) {\n         self.emit_stashed_diagnostics();\n \n@@ -1412,12 +1412,7 @@ impl HandlerInner {\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n         if self.flags.treat_err_as_bug.map_or(false, |c| {\n-            self.err_count()\n-                + self.lint_err_count\n-                + self.delayed_span_bugs.len()\n-                + self.delayed_good_path_bugs.len()\n-                + 1\n-                >= c.get()\n+            self.err_count() + self.lint_err_count + self.delayed_bug_count() + 1 >= c.get()\n         }) {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n@@ -1518,14 +1513,24 @@ impl HandlerInner {\n         if self.treat_err_as_bug() {\n             match (\n                 self.err_count() + self.lint_err_count,\n+                self.delayed_bug_count(),\n                 self.flags.treat_err_as_bug.map(|c| c.get()).unwrap_or(0),\n             ) {\n-                (1, 1) => panic!(\"aborting due to `-Z treat-err-as-bug=1`\"),\n-                (0 | 1, _) => {}\n-                (count, as_bug) => panic!(\n-                    \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n-                    count, as_bug,\n-                ),\n+                (1, 0, 1) => panic!(\"aborting due to `-Z treat-err-as-bug=1`\"),\n+                (0, 1, 1) => panic!(\"aborting due delayed bug with `-Z treat-err-as-bug=1`\"),\n+                (count, delayed_count, as_bug) => {\n+                    if delayed_count > 0 {\n+                        panic!(\n+                            \"aborting after {} errors and {} delayed bugs due to `-Z treat-err-as-bug={}`\",\n+                            count, delayed_count, as_bug,\n+                        )\n+                    } else {\n+                        panic!(\n+                            \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n+                            count, as_bug,\n+                        )\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "d9252d426d82b8ed0aebc06353f08c6eb60f3c04", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -2395,19 +2395,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             type_param_span: Option<(Span, bool)>,\n             bound_kind: GenericKind<'tcx>,\n             sub: S,\n+            add_lt_sugg: Option<(Span, String)>,\n         ) {\n             let msg = \"consider adding an explicit lifetime bound\";\n             if let Some((sp, has_lifetimes)) = type_param_span {\n                 let suggestion =\n                     if has_lifetimes { format!(\" + {}\", sub) } else { format!(\": {}\", sub) };\n-                err.span_suggestion_verbose(\n-                    sp,\n-                    &format!(\"{}...\", msg),\n-                    suggestion,\n+                let mut suggestions = vec![(sp, suggestion)];\n+                if let Some(add_lt_sugg) = add_lt_sugg {\n+                    suggestions.push(add_lt_sugg);\n+                }\n+                err.multipart_suggestion_verbose(\n+                    format!(\"{msg}...\"),\n+                    suggestions,\n                     Applicability::MaybeIncorrect, // Issue #41966\n                 );\n             } else {\n-                let consider = format!(\"{} `{}: {}`...\", msg, bound_kind, sub,);\n+                let consider = format!(\"{} `{}: {}`...\", msg, bound_kind, sub);\n                 err.help(&consider);\n             }\n         }\n@@ -2423,7 +2427,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     };\n                     let mut sugg =\n                         vec![(sp, suggestion), (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n-                    if let Some(lt) = add_lt_sugg {\n+                    if let Some(lt) = add_lt_sugg.clone() {\n                         sugg.push(lt);\n                         sugg.rotate_right(1);\n                     }\n@@ -2529,7 +2533,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // for the bound is not suitable for suggestions when `-Zverbose` is set because it\n                 // uses `Debug` output, so we handle it specially here so that suggestions are\n                 // always correct.\n-                binding_suggestion(&mut err, type_param_span, bound_kind, name);\n+                binding_suggestion(&mut err, type_param_span, bound_kind, name, None);\n                 err\n             }\n \n@@ -2542,7 +2546,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"{} may not live long enough\",\n                     labeled_user_string\n                 );\n-                binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\");\n+                binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\", None);\n                 err\n             }\n \n@@ -2576,7 +2580,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             new_binding_suggestion(&mut err, type_param_span);\n                         }\n                         _ => {\n-                            binding_suggestion(&mut err, type_param_span, bound_kind, new_lt);\n+                            binding_suggestion(\n+                                &mut err,\n+                                type_param_span,\n+                                bound_kind,\n+                                new_lt,\n+                                add_lt_sugg,\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "20ce28fe8d03d966925f174f8c9e8e37893597c0", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n             TypeAnnotationNeeded::E0283 => AmbigousImpl {\n                 span,\n                 source_kind,\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n             TypeAnnotationNeeded::E0284 => AmbigousReturn {\n                 span,\n                 source_kind,\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n         }\n     }\n \n@@ -537,7 +537,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label: None,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n             TypeAnnotationNeeded::E0283 => AmbigousImpl {\n                 span,\n                 source_kind,\n@@ -547,7 +547,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label: None,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n             TypeAnnotationNeeded::E0284 => AmbigousReturn {\n                 span,\n                 source_kind,\n@@ -557,7 +557,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 multi_suggestions,\n                 bad_label: None,\n             }\n-            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n         }\n     }\n \n@@ -575,7 +575,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             span,\n             generator_kind: GeneratorKindAsDiagArg(kind),\n         }\n-        .into_diagnostic(&self.tcx.sess.parse_sess)\n+        .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n     }\n }\n "}, {"sha": "5c183d4091ea9ae7d462deb5e1347b8048062b38", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,6 +1,6 @@\n-use rustc_errors::{fluent, AddSubdiagnostic, ErrorGuaranteed};\n+use rustc_errors::{fluent, AddSubdiagnostic, ErrorGuaranteed, Handler};\n use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n-use rustc_session::{lint::Level, parse::ParseSess, SessionDiagnostic};\n+use rustc_session::{lint::Level, SessionDiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n@@ -122,9 +122,9 @@ pub struct CheckNameUnknown {\n impl SessionDiagnostic<'_> for CheckNameUnknown {\n     fn into_diagnostic(\n         self,\n-        sess: &ParseSess,\n+        handler: &Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = sess.struct_err(fluent::lint::check_name_unknown);\n+        let mut diag = handler.struct_err(fluent::lint::check_name_unknown);\n         diag.code(rustc_errors::error_code!(E0602));\n         if let Some(suggestion) = self.suggestion {\n             diag.help(fluent::lint::help);"}, {"sha": "cf1c5945529144d75425f120697e05da379718a5", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -88,7 +88,7 @@ impl<'a> SessionDiagnosticDerive<'a> {\n             {\n                 fn into_diagnostic(\n                     self,\n-                    #sess: &'__session_diagnostic_sess rustc_session::parse::ParseSess\n+                    #sess: &'__session_diagnostic_sess rustc_errors::Handler\n                 ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, G> {\n                     use rustc_errors::IntoDiagnosticArg;\n                     #implementation"}, {"sha": "8378d2b791d00d63cce0720af0e605c364efb557", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -424,9 +424,9 @@ pub(crate) struct MultipleCandidates {\n impl SessionDiagnostic<'_> for MultipleCandidates {\n     fn into_diagnostic(\n         self,\n-        sess: &'_ rustc_session::parse::ParseSess,\n+        handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::multiple_candidates);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::multiple_candidates);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"flavor\", self.flavor);\n         diag.code(error_code!(E0465));\n@@ -540,9 +540,9 @@ pub struct InvalidMetadataFiles {\n impl SessionDiagnostic<'_> for InvalidMetadataFiles {\n     fn into_diagnostic(\n         self,\n-        sess: &'_ rustc_session::parse::ParseSess,\n+        handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::invalid_meta_files);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::invalid_meta_files);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"add_info\", self.add_info);\n         diag.code(error_code!(E0786));\n@@ -568,9 +568,9 @@ pub struct CannotFindCrate {\n impl SessionDiagnostic<'_> for CannotFindCrate {\n     fn into_diagnostic(\n         self,\n-        sess: &'_ rustc_session::parse::ParseSess,\n+        handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::cannot_find_crate);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::cannot_find_crate);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"add_info\", self.add_info);\n         diag.set_arg(\"locator_triple\", self.locator_triple.triple());"}, {"sha": "c5a450b0e2e5393e6ae2601893cef89e808ae7d8", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -839,10 +839,6 @@ pub struct LocalDecl<'tcx> {\n     pub source_info: SourceInfo,\n }\n \n-// `LocalDecl` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(LocalDecl<'_>, 56);\n-\n /// Extra information about a some locals that's used for diagnostics and for\n /// classifying variables into local variables, statics, etc, which is needed e.g.\n /// for unsafety checking.\n@@ -1317,10 +1313,6 @@ pub struct Statement<'tcx> {\n     pub kind: StatementKind<'tcx>,\n }\n \n-// `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Statement<'_>, 32);\n-\n impl Statement<'_> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n@@ -2900,3 +2892,17 @@ impl Location {\n         }\n     }\n }\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    use rustc_data_structures::static_assert_size;\n+    // These are in alphabetical order, which is easy to maintain.\n+    static_assert_size!(BasicBlockData<'_>, 144);\n+    static_assert_size!(LocalDecl<'_>, 56);\n+    static_assert_size!(Statement<'_>, 32);\n+    static_assert_size!(StatementKind<'_>, 16);\n+    static_assert_size!(Terminator<'_>, 112);\n+    static_assert_size!(TerminatorKind<'_>, 96);\n+}"}, {"sha": "7e543929b0f3ae5bedecfc308368031e62acf9e0", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtDef, Ty, UpvarSubsts};\n use rustc_middle::ty::{CanonicalUserType, CanonicalUserTypeAnnotation};\n use rustc_span::def_id::LocalDefId;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n@@ -695,17 +695,32 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 Ok(())\n             }\n             PatKind::Variant { ref subpatterns, .. } | PatKind::Leaf { ref subpatterns } => {\n-                let variant = match self.kind {\n-                    PatKind::Variant { adt_def, variant_index, .. } => {\n-                        Some(adt_def.variant(variant_index))\n-                    }\n-                    _ => self.ty.ty_adt_def().and_then(|adt| {\n-                        if !adt.is_enum() { Some(adt.non_enum_variant()) } else { None }\n+                let variant_and_name = match self.kind {\n+                    PatKind::Variant { adt_def, variant_index, .. } => ty::tls::with(|tcx| {\n+                        let variant = adt_def.variant(variant_index);\n+                        let adt_did = adt_def.did();\n+                        let name = if tcx.get_diagnostic_item(sym::Option) == Some(adt_did)\n+                            || tcx.get_diagnostic_item(sym::Result) == Some(adt_did)\n+                        {\n+                            variant.name.to_string()\n+                        } else {\n+                            format!(\"{}::{}\", tcx.def_path_str(adt_def.did()), variant.name)\n+                        };\n+                        Some((variant, name))\n+                    }),\n+                    _ => self.ty.ty_adt_def().and_then(|adt_def| {\n+                        if !adt_def.is_enum() {\n+                            ty::tls::with(|tcx| {\n+                                Some((adt_def.non_enum_variant(), tcx.def_path_str(adt_def.did())))\n+                            })\n+                        } else {\n+                            None\n+                        }\n                     }),\n                 };\n \n-                if let Some(variant) = variant {\n-                    write!(f, \"{}\", variant.name)?;\n+                if let Some((variant, name)) = &variant_and_name {\n+                    write!(f, \"{}\", name)?;\n \n                     // Only for Adt we can have `S {...}`,\n                     // which we handle separately here.\n@@ -730,8 +745,9 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                     }\n                 }\n \n-                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n-                if num_fields != 0 || variant.is_none() {\n+                let num_fields =\n+                    variant_and_name.as_ref().map_or(subpatterns.len(), |(v, _)| v.fields.len());\n+                if num_fields != 0 || variant_and_name.is_none() {\n                     write!(f, \"(\")?;\n                     for i in 0..num_fields {\n                         write!(f, \"{}\", start_or_comma())?;"}, {"sha": "115d34ff8fa2c6d1e77192f0206a1a217986ea7d", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -754,8 +754,8 @@ fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n     hir_id: HirId,\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n ) {\n-    let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n     cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, |build| {\n+        let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n         let mut lint = build.build(\"some variants are not matched explicitly\");\n         lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n         lint.help("}, {"sha": "d5f05e790d3883f531e740f8185116ac6309cbc2", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -47,9 +47,10 @@ pub struct UnusedGenericParams {\n impl SessionDiagnostic<'_> for UnusedGenericParams {\n     fn into_diagnostic(\n         self,\n-        sess: &'_ rustc_session::parse::ParseSess,\n+        handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = sess.struct_err(rustc_errors::fluent::monomorphize::unused_generic_params);\n+        let mut diag =\n+            handler.struct_err(rustc_errors::fluent::monomorphize::unused_generic_params);\n         diag.set_span(self.span);\n         for (span, name) in self.param_spans.into_iter().zip(self.param_names) {\n             // FIXME: I can figure out how to do a label with a fluent string with a fixed message,"}, {"sha": "7addf519872f03f82332881aad134a28edd4bb11", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1997,7 +1997,7 @@ impl<'a> Parser<'a> {\n                     return Err(MissingSemicolonBeforeArray {\n                         open_delim: open_delim_span,\n                         semicolon: prev_span.shrink_to_hi(),\n-                    }.into_diagnostic(self.sess));\n+                    }.into_diagnostic(&self.sess.span_diagnostic));\n                 }\n                 Ok(_) => (),\n                 Err(err) => err.cancel(),\n@@ -2745,7 +2745,8 @@ impl<'a> Parser<'a> {\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         if self.eat_keyword(kw::Catch) {\n-            Err(CatchAfterTry { span: self.prev_token.span }.into_diagnostic(self.sess))\n+            Err(CatchAfterTry { span: self.prev_token.span }\n+                .into_diagnostic(&self.sess.span_diagnostic))\n         } else {\n             let span = span_lo.to(body.span);\n             self.sess.gated_spans.gate(sym::try_blocks, span);"}, {"sha": "b190a7062defd642a131debc8f4dab283b962843", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1526,6 +1526,17 @@ impl<'a> Parser<'a> {\n         if self.token == token::Comma {\n             seen_comma = true;\n         }\n+        if self.eat(&token::Semi) {\n+            let sp = self.prev_token.span;\n+            let mut err = self.struct_span_err(sp, format!(\"{adt_ty} fields are separated by `,`\"));\n+            err.span_suggestion_short(\n+                sp,\n+                \"replace `;` with `,`\",\n+                \",\",\n+                Applicability::MachineApplicable,\n+            );\n+            return Err(err);\n+        }\n         match self.token.kind {\n             token::Comma => {\n                 self.bump();"}, {"sha": "45b4079fb54f8067b5e2a937a2dd82a03b71d436", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -572,7 +572,7 @@ pub(crate) fn report_cycle<'a>(\n         stack_count,\n     };\n \n-    cycle_diag.into_diagnostic(&sess.parse_sess)\n+    cycle_diag.into_diagnostic(&sess.parse_sess.span_diagnostic)\n }\n \n pub fn print_query_stack<CTX: QueryContext>("}, {"sha": "9bc7fbfbe149172817d2b4bf39d4e8fd75f6f401", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -343,7 +343,7 @@ impl ParseSess {\n         &'a self,\n         err: impl SessionDiagnostic<'a>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        err.into_diagnostic(self)\n+        err.into_diagnostic(&self.span_diagnostic)\n     }\n \n     pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) -> ErrorGuaranteed {\n@@ -354,7 +354,7 @@ impl ParseSess {\n         &'a self,\n         warning: impl SessionDiagnostic<'a, ()>,\n     ) -> DiagnosticBuilder<'a, ()> {\n-        warning.into_diagnostic(self)\n+        warning.into_diagnostic(&self.span_diagnostic)\n     }\n \n     pub fn emit_warning<'a>(&'a self, warning: impl SessionDiagnostic<'a, ()>) {\n@@ -365,7 +365,7 @@ impl ParseSess {\n         &'a self,\n         fatal: impl SessionDiagnostic<'a, !>,\n     ) -> DiagnosticBuilder<'a, !> {\n-        fatal.into_diagnostic(self)\n+        fatal.into_diagnostic(&self.span_diagnostic)\n     }\n \n     pub fn emit_fatal<'a>(&'a self, fatal: impl SessionDiagnostic<'a, !>) -> ! {"}, {"sha": "557edad548c64a2a3b0de2679bf7e65e41391b1c", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -21,7 +21,7 @@ use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n use rustc_errors::{\n     error_code, fallback_fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n-    EmissionGuarantee, ErrorGuaranteed, FluentBundle, LazyFallbackBundle, MultiSpan,\n+    EmissionGuarantee, ErrorGuaranteed, FluentBundle, Handler, LazyFallbackBundle, MultiSpan,\n };\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n@@ -220,9 +220,9 @@ pub struct PerfStats {\n /// `#[derive(SessionDiagnostic)]` -- see [rustc_macros::SessionDiagnostic].\n #[rustc_diagnostic_item = \"SessionDiagnostic\"]\n pub trait SessionDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n-    /// Write out as a diagnostic out of `sess`.\n+    /// Write out as a diagnostic out of `Handler`.\n     #[must_use]\n-    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, T>;\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, T>;\n }\n \n impl Session {"}, {"sha": "ab0afc545146ec7df255ede3a1cf51169a63fa71", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,7 +1,7 @@\n-use rustc_errors::{fluent, ErrorGuaranteed};\n+use rustc_errors::{fluent, ErrorGuaranteed, Handler};\n use rustc_macros::SessionDiagnostic;\n use rustc_middle::ty::{PolyTraitRef, Ty, Unevaluated};\n-use rustc_session::{parse::ParseSess, Limit, SessionDiagnostic};\n+use rustc_session::{Limit, SessionDiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n@@ -69,9 +69,9 @@ pub struct NegativePositiveConflict<'a> {\n impl SessionDiagnostic<'_> for NegativePositiveConflict<'_> {\n     fn into_diagnostic(\n         self,\n-        sess: &ParseSess,\n+        handler: &Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = sess.struct_err(fluent::trait_selection::negative_positive_conflict);\n+        let mut diag = handler.struct_err(fluent::trait_selection::negative_positive_conflict);\n         diag.set_arg(\"trait_desc\", self.trait_desc);\n         diag.set_arg(\n             \"self_desc\","}, {"sha": "a9152bdc59787a2f586138c43e550ce83178566c", "filename": "compiler/rustc_typeck/src/astconv/errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -29,6 +29,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.tcx().sess.emit_err(MissingTypeParams {\n             span,\n             def_span: self.tcx().def_span(def_id),\n+            span_snippet: self.tcx().sess.source_map().span_to_snippet(span).ok(),\n             missing_type_params,\n             empty_generic_args,\n         });"}, {"sha": "0d2e667458592caf68d1c49212e217ee8be9195d", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n //! Errors emitted by typeck.\n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler};\n use rustc_macros::{LintDiagnostic, SessionDiagnostic, SessionSubdiagnostic};\n use rustc_middle::ty::Ty;\n-use rustc_session::{parse::ParseSess, SessionDiagnostic};\n+use rustc_session::SessionDiagnostic;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n@@ -244,14 +244,15 @@ pub struct UnconstrainedOpaqueType {\n pub struct MissingTypeParams {\n     pub span: Span,\n     pub def_span: Span,\n+    pub span_snippet: Option<String>,\n     pub missing_type_params: Vec<Symbol>,\n     pub empty_generic_args: bool,\n }\n \n // Manual implementation of `SessionDiagnostic` to be able to call `span_to_snippet`.\n impl<'a> SessionDiagnostic<'a> for MissingTypeParams {\n-    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err = sess.span_diagnostic.struct_span_err_with_code(\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut err = handler.struct_span_err_with_code(\n             self.span,\n             rustc_errors::fluent::typeck::missing_type_params,\n             error_code!(E0393),\n@@ -269,12 +270,9 @@ impl<'a> SessionDiagnostic<'a> for MissingTypeParams {\n         err.span_label(self.def_span, rustc_errors::fluent::typeck::label);\n \n         let mut suggested = false;\n-        if let (Ok(snippet), true) = (\n-            sess.source_map().span_to_snippet(self.span),\n-            // Don't suggest setting the type params if there are some already: the order is\n-            // tricky to get right and the user will already know what the syntax is.\n-            self.empty_generic_args,\n-        ) {\n+        // Don't suggest setting the type params if there are some already: the order is\n+        // tricky to get right and the user will already know what the syntax is.\n+        if let Some(snippet) = self.span_snippet && self.empty_generic_args {\n             if snippet.ends_with('>') {\n                 // The user wrote `Trait<'a, T>` or similar. To provide an accurate suggestion\n                 // we would have to preserve the right order. For now, as clearly the user is"}, {"sha": "27fb018aecaddfa399f274705308c93ba181caf5", "filename": "src/etc/check_missing_items.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -144,10 +144,10 @@ def check_type(ty):\n         ) - visited\n     elif item[\"kind\"] == \"variant\":\n         if item[\"inner\"][\"variant_kind\"] == \"tuple\":\n-            for ty in item[\"inner\"][\"variant_inner\"]:\n-                check_type(ty)\n+            for field_id in filter(None, item[\"inner\"][\"variant_inner\"]):\n+                work_list.add(field_id)\n         elif item[\"inner\"][\"variant_kind\"] == \"struct\":\n-            work_list |= set(item[\"inner\"][\"variant_inner\"]) - visited\n+            work_list |= set(item[\"inner\"][\"variant_inner\"][\"fields\"]) - visited\n     elif item[\"kind\"] in (\"function\", \"method\"):\n         check_generics(item[\"inner\"][\"generics\"])\n         check_decl(item[\"inner\"][\"decl\"])"}, {"sha": "c2d3543942db16b02b94080f558271bb6ab2ceb0", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -663,17 +663,11 @@ impl FromWithTcx<clean::Variant> for Variant {\n         use clean::Variant::*;\n         match variant {\n             CLike(disr) => Variant::Plain(disr.map(|disr| disr.into_tcx(tcx))),\n-            Tuple(fields) => Variant::Tuple(\n-                fields\n-                    .into_iter()\n-                    .filter_map(|f| match *f.kind {\n-                        clean::StructFieldItem(ty) => Some(ty.into_tcx(tcx)),\n-                        clean::StrippedItem(_) => None,\n-                        _ => unreachable!(),\n-                    })\n-                    .collect(),\n-            ),\n-            Struct(s) => Variant::Struct(ids(s.fields, tcx)),\n+            Tuple(fields) => Variant::Tuple(ids_keeping_stripped(fields, tcx)),\n+            Struct(s) => Variant::Struct {\n+                fields_stripped: s.has_stripped_entries(),\n+                fields: ids(s.fields, tcx),\n+            },\n         }\n     }\n }\n@@ -796,3 +790,19 @@ fn ids(items: impl IntoIterator<Item = clean::Item>, tcx: TyCtxt<'_>) -> Vec<Id>\n         .map(|i| from_item_id_with_name(i.item_id, tcx, i.name))\n         .collect()\n }\n+\n+fn ids_keeping_stripped(\n+    items: impl IntoIterator<Item = clean::Item>,\n+    tcx: TyCtxt<'_>,\n+) -> Vec<Option<Id>> {\n+    items\n+        .into_iter()\n+        .map(|i| {\n+            if !i.is_stripped() && !i.is_keyword() {\n+                Some(from_item_id_with_name(i.item_id, tcx, i.name))\n+            } else {\n+                None\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "eea62f3af5ab4de437119a3b9b98df9f4a978f91", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -9,7 +9,7 @@ use std::path::PathBuf;\n use serde::{Deserialize, Serialize};\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 19;\n+pub const FORMAT_VERSION: u32 = 20;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -308,9 +308,36 @@ pub struct Enum {\n #[serde(rename_all = \"snake_case\")]\n #[serde(tag = \"variant_kind\", content = \"variant_inner\")]\n pub enum Variant {\n+    /// A variant with no parentheses, and possible discriminant.\n+    ///\n+    /// ```rust\n+    /// enum Demo {\n+    ///     PlainVariant,\n+    ///     PlainWithDiscriminant = 1,\n+    /// }\n+    /// ```\n     Plain(Option<Discriminant>),\n-    Tuple(Vec<Type>),\n-    Struct(Vec<Id>),\n+    /// A variant with unnamed fields.\n+    ///\n+    /// Unlike most of json, `#[doc(hidden)]` fields will be given as `None`\n+    /// instead of being ommited, because order matters.\n+    ///\n+    /// ```rust\n+    /// enum Demo {\n+    ///     TupleVariant(i32),\n+    ///     EmptyTupleVariant(),\n+    /// }\n+    /// ```\n+    Tuple(Vec<Option<Id>>),\n+    /// A variant with named fields.\n+    ///\n+    /// ```rust\n+    /// enum Demo {\n+    ///     StructVariant { x: i32 },\n+    ///     EmptyStructVariant {},\n+    /// }\n+    /// ```\n+    Struct { fields: Vec<Id>, fields_stripped: bool },\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]"}, {"sha": "e6310cc3b997c28860234fd3c461596c8ec9ada7", "filename": "src/test/rustdoc-json/enums/field_hidden.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Frustdoc-json%2Fenums%2Ffield_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Frustdoc-json%2Fenums%2Ffield_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Ffield_hidden.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -6,7 +6,7 @@\n // @has \"$.index[*][?(@.name=='ParseError')]\"\n // @has \"$.index[*][?(@.name=='UnexpectedEndTag')]\"\n // @is \"$.index[*][?(@.name=='UnexpectedEndTag')].inner.variant_kind\" '\"tuple\"'\n-// @is \"$.index[*][?(@.name=='UnexpectedEndTag')].inner.variant_inner\" []\n+// @is \"$.index[*][?(@.name=='UnexpectedEndTag')].inner.variant_inner\" [null]\n \n pub enum ParseError {\n     UnexpectedEndTag(#[doc(hidden)] u32),", "previous_filename": "src/test/rustdoc-json/enum_variant_hidden.rs"}, {"sha": "e9ea3ae23c226808ff861878613b359aca050163", "filename": "src/test/rustdoc-json/enums/kind.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Frustdoc-json%2Fenums%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Frustdoc-json%2Fenums%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Fkind.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -0,0 +1,37 @@\n+// ignore-tidy-linelength\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+pub enum Foo {\n+    // @set Unit = \"$.index[*][?(@.name=='Unit')].id\"\n+    // @is \"$.index[*][?(@.name=='Unit')].inner.variant_kind\" '\"plain\"'\n+    // @is \"$.index[*][?(@.name=='Unit')].inner.variant_inner\" null\n+    Unit,\n+    // @set Named = \"$.index[*][?(@.name=='Named')].id\"\n+    // @is \"$.index[*][?(@.name=='Named')].inner.variant_kind\" '\"struct\"'\n+    // @is \"$.index[*][?(@.name=='Named')].inner.variant_inner\" '{\"fields\": [], \"fields_stripped\": false}'\n+    Named {},\n+    // @set Tuple = \"$.index[*][?(@.name=='Tuple')].id\"\n+    // @is \"$.index[*][?(@.name=='Tuple')].inner.variant_kind\" '\"tuple\"'\n+    // @is \"$.index[*][?(@.name=='Tuple')].inner.variant_inner\" []\n+    Tuple(),\n+    // @set NamedField = \"$.index[*][?(@.name=='NamedField')].id\"\n+    // @set x = \"$.index[*][?(@.name=='x' && @.kind=='struct_field')].id\"\n+    // @is \"$.index[*][?(@.name=='NamedField')].inner.variant_kind\" '\"struct\"'\n+    // @is \"$.index[*][?(@.name=='NamedField')].inner.variant_inner.fields[*]\" $x\n+    // @is \"$.index[*][?(@.name=='NamedField')].inner.variant_inner.fields_stripped\" false\n+    NamedField { x: i32 },\n+    // @set TupleField = \"$.index[*][?(@.name=='TupleField')].id\"\n+    // @is \"$.index[*][?(@.name=='TupleField')].inner.variant_kind\" '\"tuple\"'\n+    // @set tup_field = \"$.index[*][?(@.name=='0' && @.kind=='struct_field')].id\"\n+    // @is \"$.index[*][?(@.name=='TupleField')].inner.variant_inner[*]\" $tup_field\n+    TupleField(i32),\n+}\n+\n+// @is    \"$.index[*][?(@.name=='Foo')].inner.variants[0]\" $Unit\n+// @is    \"$.index[*][?(@.name=='Foo')].inner.variants[1]\" $Named\n+// @is    \"$.index[*][?(@.name=='Foo')].inner.variants[2]\" $Tuple\n+// @is    \"$.index[*][?(@.name=='Foo')].inner.variants[3]\" $NamedField\n+// @is    \"$.index[*][?(@.name=='Foo')].inner.variants[4]\" $TupleField\n+// @count \"$.index[*][?(@.name=='Foo')].inner.variants[*]\" 5"}, {"sha": "f612a34a4927744b55462662c7ee457aef6fa5cf", "filename": "src/test/rustdoc-json/enums/struct_field_hidden.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Frustdoc-json%2Fenums%2Fstruct_field_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Frustdoc-json%2Fenums%2Fstruct_field_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Fstruct_field_hidden.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -0,0 +1,17 @@\n+pub enum Foo {\n+    Variant {\n+        #[doc(hidden)]\n+        a: i32,\n+        // @set b = \"$.index[*][?(@.name=='b')].id\"\n+        b: i32,\n+        #[doc(hidden)]\n+        x: i32,\n+        // @set y = \"$.index[*][?(@.name=='y')].id\"\n+        y: i32,\n+    },\n+    // @is \"$.index[*][?(@.name=='Variant')].inner.variant_kind\" '\"struct\"'\n+    // @is \"$.index[*][?(@.name=='Variant')].inner.variant_inner.fields_stripped\" true\n+    // @is \"$.index[*][?(@.name=='Variant')].inner.variant_inner.fields[0]\" $b\n+    // @is \"$.index[*][?(@.name=='Variant')].inner.variant_inner.fields[1]\" $y\n+    // @count \"$.index[*][?(@.name=='Variant')].inner.variant_inner.fields[*]\" 2\n+}"}, {"sha": "f546eaa0d172df6beb83ecba8d83f213318f50b2", "filename": "src/test/rustdoc-json/enums/tuple_fields_hidden.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Frustdoc-json%2Fenums%2Ftuple_fields_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Frustdoc-json%2Fenums%2Ftuple_fields_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Ftuple_fields_hidden.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -0,0 +1,94 @@\n+#![feature(no_core)]\n+#![no_core]\n+\n+// @set 1.1.0 = \"$.index[*][?(@.docs=='1.1.0')].id\"\n+// @set 2.1.0 = \"$.index[*][?(@.docs=='2.1.0')].id\"\n+// @set 2.1.1 = \"$.index[*][?(@.docs=='2.1.1')].id\"\n+// @set 2.2.1 = \"$.index[*][?(@.docs=='2.2.1')].id\"\n+// @set 2.3.0 = \"$.index[*][?(@.docs=='2.3.0')].id\"\n+// @set 3.1.1 = \"$.index[*][?(@.docs=='3.1.1')].id\"\n+// @set 3.1.2 = \"$.index[*][?(@.docs=='3.1.2')].id\"\n+// @set 3.2.0 = \"$.index[*][?(@.docs=='3.2.0')].id\"\n+// @set 3.2.2 = \"$.index[*][?(@.docs=='3.2.2')].id\"\n+// @set 3.3.0 = \"$.index[*][?(@.docs=='3.3.0')].id\"\n+// @set 3.3.1 = \"$.index[*][?(@.docs=='3.3.1')].id\"\n+\n+pub enum EnumWithStrippedTupleVariants {\n+    // @is    \"$.index[*][?(@.name=='None')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='None')].inner.variant_inner[*]\" 0\n+    None(),\n+\n+    // @is    \"$.index[*][?(@.name=='One')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='One')].inner.variant_inner[*]\" 1\n+    // @is    \"$.index[*][?(@.name=='One')].inner.variant_inner[0]\" $1.1.0\n+    One(/** 1.1.0*/ bool),\n+    // @is    \"$.index[*][?(@.name=='OneHidden')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='OneHidden')].inner.variant_inner[*]\" 1\n+    // @is    \"$.index[*][?(@.name=='OneHidden')].inner.variant_inner[0]\" null\n+    OneHidden(#[doc(hidden)] bool),\n+\n+    // @is    \"$.index[*][?(@.name=='Two')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='Two')].inner.variant_inner[*]\" 2\n+    // @is    \"$.index[*][?(@.name=='Two')].inner.variant_inner[0]\" $2.1.0\n+    // @is    \"$.index[*][?(@.name=='Two')].inner.variant_inner[1]\" $2.1.1\n+    Two(/** 2.1.0*/ bool, /** 2.1.1*/ bool),\n+    // @is    \"$.index[*][?(@.name=='TwoLeftHidden')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='TwoLeftHidden')].inner.variant_inner[*]\" 2\n+    // @is    \"$.index[*][?(@.name=='TwoLeftHidden')].inner.variant_inner[0]\" null\n+    // @is    \"$.index[*][?(@.name=='TwoLeftHidden')].inner.variant_inner[1]\" $2.2.1\n+    TwoLeftHidden(#[doc(hidden)] bool, /** 2.2.1*/ bool),\n+    // @is    \"$.index[*][?(@.name=='TwoRightHidden')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='TwoRightHidden')].inner.variant_inner[*]\" 2\n+    // @is    \"$.index[*][?(@.name=='TwoRightHidden')].inner.variant_inner[0]\" $2.3.0\n+    // @is    \"$.index[*][?(@.name=='TwoRightHidden')].inner.variant_inner[1]\" null\n+    TwoRightHidden(/** 2.3.0*/ bool, #[doc(hidden)] bool),\n+    // @is    \"$.index[*][?(@.name=='TwoBothHidden')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='TwoBothHidden')].inner.variant_inner[*]\" 2\n+    // @is    \"$.index[*][?(@.name=='TwoBothHidden')].inner.variant_inner[0]\" null\n+    // @is    \"$.index[*][?(@.name=='TwoBothHidden')].inner.variant_inner[1]\" null\n+    TwoBothHidden(#[doc(hidden)] bool, #[doc(hidden)] bool),\n+\n+    // @is    \"$.index[*][?(@.name=='Three1')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='Three1')].inner.variant_inner[*]\" 3\n+    // @is    \"$.index[*][?(@.name=='Three1')].inner.variant_inner[0]\" null\n+    // @is    \"$.index[*][?(@.name=='Three1')].inner.variant_inner[1]\" $3.1.1\n+    // @is    \"$.index[*][?(@.name=='Three1')].inner.variant_inner[2]\" $3.1.2\n+    Three1(#[doc(hidden)] bool, /** 3.1.1*/ bool, /** 3.1.2*/ bool),\n+    // @is    \"$.index[*][?(@.name=='Three2')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='Three2')].inner.variant_inner[*]\" 3\n+    // @is    \"$.index[*][?(@.name=='Three2')].inner.variant_inner[0]\" $3.2.0\n+    // @is    \"$.index[*][?(@.name=='Three2')].inner.variant_inner[1]\" null\n+    // @is    \"$.index[*][?(@.name=='Three2')].inner.variant_inner[2]\" $3.2.2\n+    Three2(/** 3.2.0*/ bool, #[doc(hidden)] bool, /** 3.2.2*/ bool),\n+    // @is    \"$.index[*][?(@.name=='Three3')].inner.variant_kind\" '\"tuple\"'\n+    // @count \"$.index[*][?(@.name=='Three3')].inner.variant_inner[*]\" 3\n+    // @is    \"$.index[*][?(@.name=='Three3')].inner.variant_inner[0]\" $3.3.0\n+    // @is    \"$.index[*][?(@.name=='Three3')].inner.variant_inner[1]\" $3.3.1\n+    // @is    \"$.index[*][?(@.name=='Three3')].inner.variant_inner[2]\" null\n+    Three3(/** 3.3.0*/ bool, /** 3.3.1*/ bool, #[doc(hidden)] bool),\n+}\n+\n+\n+// @is \"$.index[*][?(@.docs=='1.1.0')].name\" '\"0\"'\n+// @is \"$.index[*][?(@.docs=='2.1.0')].name\" '\"0\"'\n+// @is \"$.index[*][?(@.docs=='2.1.1')].name\" '\"1\"'\n+// @is \"$.index[*][?(@.docs=='2.2.1')].name\" '\"1\"'\n+// @is \"$.index[*][?(@.docs=='2.3.0')].name\" '\"0\"'\n+// @is \"$.index[*][?(@.docs=='3.1.1')].name\" '\"1\"'\n+// @is \"$.index[*][?(@.docs=='3.1.2')].name\" '\"2\"'\n+// @is \"$.index[*][?(@.docs=='3.2.0')].name\" '\"0\"'\n+// @is \"$.index[*][?(@.docs=='3.2.2')].name\" '\"2\"'\n+// @is \"$.index[*][?(@.docs=='3.3.0')].name\" '\"0\"'\n+// @is \"$.index[*][?(@.docs=='3.3.1')].name\" '\"1\"'\n+\n+// @is \"$.index[*][?(@.docs=='1.1.0')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='2.1.0')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='2.1.1')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='2.2.1')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='2.3.0')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='3.1.1')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='3.1.2')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='3.2.0')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='3.2.2')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='3.3.0')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'\n+// @is \"$.index[*][?(@.docs=='3.3.1')].inner\" '{\"kind\": \"primitive\", \"inner\": \"bool\"}'"}, {"sha": "e9e809fa416178eedda7752d622ca8209ac10e46", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -11,9 +11,11 @@ extern crate rustc_macros;\n extern crate rustc_session;\n extern crate rustc_span;\n \n-use rustc_errors::{AddSubdiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, fluent};\n+use rustc_errors::{\n+    AddSubdiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, Handler, fluent\n+};\n use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n-use rustc_session::{parse::ParseSess, SessionDiagnostic};\n+use rustc_session::SessionDiagnostic;\n use rustc_span::Span;\n \n #[derive(SessionDiagnostic)]\n@@ -33,17 +35,17 @@ struct Note {\n pub struct UntranslatableInSessionDiagnostic;\n \n impl<'a> SessionDiagnostic<'a, ErrorGuaranteed> for UntranslatableInSessionDiagnostic {\n-    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        sess.struct_err(\"untranslatable diagnostic\")\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        handler.struct_err(\"untranslatable diagnostic\")\n         //~^ ERROR diagnostics should be created using translatable messages\n     }\n }\n \n pub struct TranslatableInSessionDiagnostic;\n \n impl<'a> SessionDiagnostic<'a, ErrorGuaranteed> for TranslatableInSessionDiagnostic {\n-    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        sess.struct_err(fluent::parser::expect_path)\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        handler.struct_err(fluent::parser::expect_path)\n     }\n }\n \n@@ -64,18 +66,18 @@ impl AddSubdiagnostic for TranslatableInAddSubdiagnostic {\n     }\n }\n \n-pub fn make_diagnostics<'a>(sess: &'a ParseSess) {\n-    let _diag = sess.struct_err(fluent::parser::expect_path);\n+pub fn make_diagnostics<'a>(handler: &'a Handler) {\n+    let _diag = handler.struct_err(fluent::parser::expect_path);\n     //~^ ERROR diagnostics should only be created in `SessionDiagnostic`/`AddSubdiagnostic` impls\n \n-    let _diag = sess.struct_err(\"untranslatable diagnostic\");\n+    let _diag = handler.struct_err(\"untranslatable diagnostic\");\n     //~^ ERROR diagnostics should only be created in `SessionDiagnostic`/`AddSubdiagnostic` impls\n     //~^^ ERROR diagnostics should be created using translatable messages\n }\n \n // Check that `rustc_lint_diagnostics`-annotated functions aren't themselves linted.\n \n #[rustc_lint_diagnostics]\n-pub fn skipped_because_of_annotation<'a>(sess: &'a ParseSess) {\n-    let _diag = sess.struct_err(\"untranslatable diagnostic\"); // okay!\n+pub fn skipped_because_of_annotation<'a>(handler: &'a Handler) {\n+    let _diag = handler.struct_err(\"untranslatable diagnostic\"); // okay!\n }"}, {"sha": "e5c5bc2e9987e431fdab12cca8919d6fef69ab80", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n error: diagnostics should be created using translatable messages\n-  --> $DIR/diagnostics.rs:37:14\n+  --> $DIR/diagnostics.rs:39:17\n    |\n-LL |         sess.struct_err(\"untranslatable diagnostic\")\n-   |              ^^^^^^^^^^\n+LL |         handler.struct_err(\"untranslatable diagnostic\")\n+   |                 ^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/diagnostics.rs:6:9\n@@ -11,16 +11,16 @@ LL | #![deny(rustc::untranslatable_diagnostic)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostics should be created using translatable messages\n-  --> $DIR/diagnostics.rs:54:14\n+  --> $DIR/diagnostics.rs:56:14\n    |\n LL |         diag.note(\"untranslatable diagnostic\");\n    |              ^^^^\n \n error: diagnostics should only be created in `SessionDiagnostic`/`AddSubdiagnostic` impls\n-  --> $DIR/diagnostics.rs:68:22\n+  --> $DIR/diagnostics.rs:70:25\n    |\n-LL |     let _diag = sess.struct_err(fluent::parser::expect_path);\n-   |                      ^^^^^^^^^^\n+LL |     let _diag = handler.struct_err(fluent::parser::expect_path);\n+   |                         ^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/diagnostics.rs:7:9\n@@ -29,16 +29,16 @@ LL | #![deny(rustc::diagnostic_outside_of_impl)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostics should only be created in `SessionDiagnostic`/`AddSubdiagnostic` impls\n-  --> $DIR/diagnostics.rs:71:22\n+  --> $DIR/diagnostics.rs:73:25\n    |\n-LL |     let _diag = sess.struct_err(\"untranslatable diagnostic\");\n-   |                      ^^^^^^^^^^\n+LL |     let _diag = handler.struct_err(\"untranslatable diagnostic\");\n+   |                         ^^^^^^^^^^\n \n error: diagnostics should be created using translatable messages\n-  --> $DIR/diagnostics.rs:71:22\n+  --> $DIR/diagnostics.rs:73:25\n    |\n-LL |     let _diag = sess.struct_err(\"untranslatable diagnostic\");\n-   |                      ^^^^^^^^^^\n+LL |     let _diag = handler.struct_err(\"untranslatable diagnostic\");\n+   |                         ^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "972c24c23b0195eec8e354f8b8e2a81c480acf3b", "filename": "src/test/ui/closures/2229_closure_analysis/match/non-exhaustive-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     let _a = || { match l1 { L1::A => (), L1::B => () } };\n     // (except if the match is already non-exhaustive)\n     let _b = || { match l1 { L1::A => () } };\n-    //~^ ERROR: non-exhaustive patterns: `B` not covered [E0004]\n+    //~^ ERROR: non-exhaustive patterns: `L1::B` not covered [E0004]\n \n     // l2 should not be captured as it is a non-exhaustive SingleVariant\n     // defined in this crate"}, {"sha": "3a5fad15421c6fda04009f0e295ff2792b9c84f7", "filename": "src/test/ui/closures/2229_closure_analysis/match/non-exhaustive-match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `B` not covered\n+error[E0004]: non-exhaustive patterns: `L1::B` not covered\n   --> $DIR/non-exhaustive-match.rs:26:25\n    |\n LL |     let _b = || { match l1 { L1::A => () } };\n-   |                         ^^ pattern `B` not covered\n+   |                         ^^ pattern `L1::B` not covered\n    |\n note: `L1` defined here\n   --> $DIR/non-exhaustive-match.rs:12:14\n@@ -12,8 +12,8 @@ LL | enum L1 { A, B }\n    = note: the matched value is of type `L1`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     let _b = || { match l1 { L1::A => (), B => todo!() } };\n-   |                                         ++++++++++++++\n+LL |     let _b = || { match l1 { L1::A => (), L1::B => todo!() } };\n+   |                                         ++++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: type `E1` is non-empty\n   --> $DIR/non-exhaustive-match.rs:37:25"}, {"sha": "3de2b1a78a3dadfca2e8c0766d0db69b1eb3f2eb", "filename": "src/test/ui/empty/empty-never-array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -8,7 +8,7 @@ enum Helper<T, U> {\n \n fn transmute<T, U>(t: T) -> U {\n     let Helper::U(u) = Helper::T(t, []);\n-    //~^ ERROR refutable pattern in local binding: `T(_, _)` not covered\n+    //~^ ERROR refutable pattern in local binding: `Helper::T(_, _)` not covered\n     u\n }\n "}, {"sha": "8c80b05ee3aeac9e12835da84e7e33c5ea20527f", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `T(_, _)` not covered\n+error[E0005]: refutable pattern in local binding: `Helper::T(_, _)` not covered\n   --> $DIR/empty-never-array.rs:10:9\n    |\n LL |     let Helper::U(u) = Helper::T(t, []);\n-   |         ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n+   |         ^^^^^^^^^^^^ pattern `Helper::T(_, _)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "4ac8c904f0530d47dba2731b07d86bff2910c370", "filename": "src/test/ui/error-codes/E0004.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n+error[E0004]: non-exhaustive patterns: `Terminator::HastaLaVistaBaby` not covered\n   --> $DIR/E0004.rs:9:11\n    |\n LL |     match x {\n-   |           ^ pattern `HastaLaVistaBaby` not covered\n+   |           ^ pattern `Terminator::HastaLaVistaBaby` not covered\n    |\n note: `Terminator` defined here\n   --> $DIR/E0004.rs:2:5\n@@ -15,7 +15,7 @@ LL |     HastaLaVistaBaby,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         Terminator::TalkToMyHand => {}\n-LL +         HastaLaVistaBaby => todo!()\n+LL +         Terminator::HastaLaVistaBaby => todo!()\n    |\n \n error: aborting due to previous error"}, {"sha": "9b646060adfd9818153df8ffe07225a224b48db1", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive_omitted_patterns_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         Foo::A => {}\n         Foo::B => {}\n     }\n-    //~^^^^ ERROR non-exhaustive patterns: `C` not covered\n+    //~^^^^ ERROR non-exhaustive patterns: `Foo::C` not covered\n \n     match Foo::A {\n         Foo::A => {}"}, {"sha": "3de08e215dada61894269d001e000d7a9670d0fb", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive_omitted_patterns_lint.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -99,11 +99,11 @@ LL |         #[warn(non_exhaustive_omitted_patterns)]\n    = note: see issue #89554 <https://github.com/rust-lang/rust/issues/89554> for more information\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n-error[E0004]: non-exhaustive patterns: `C` not covered\n+error[E0004]: non-exhaustive patterns: `Foo::C` not covered\n   --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:20:11\n    |\n LL |     match Foo::A {\n-   |           ^^^^^^ pattern `C` not covered\n+   |           ^^^^^^ pattern `Foo::C` not covered\n    |\n note: `Foo` defined here\n   --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:12:15\n@@ -116,7 +116,7 @@ LL |         A, B, C,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         Foo::B => {}\n-LL +         C => todo!()\n+LL +         Foo::C => todo!()\n    |\n \n error: aborting due to previous error; 10 warnings emitted"}, {"sha": "b3c17ce8974df3a4a80b2f229c49bff81460a57a", "filename": "src/test/ui/issue-94866.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fissue-94866.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fissue-94866.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-94866.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `B` not covered\n+error[E0004]: non-exhaustive patterns: `Enum::B` not covered\n   --> $DIR/issue-94866.rs:10:11\n    |\n LL |     match Enum::A {\n-   |           ^^^^^^^ pattern `B` not covered\n+   |           ^^^^^^^ pattern `Enum::B` not covered\n    |\n note: `Enum` defined here\n   --> $DIR/issue-94866.rs:7:16\n@@ -13,7 +13,7 @@ LL | enum Enum { A, B }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~     Enum::A => m!(),\n-LL +     B => todo!()\n+LL +     Enum::B => todo!()\n    |\n \n error: aborting due to previous error"}, {"sha": "645bc7db0ddac4644442f98b9d82e18e707a75e5", "filename": "src/test/ui/lifetimes/suggest-introducing-and-adding-missing-lifetime.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -0,0 +1,9 @@\n+fn no_restriction<T>(x: &()) -> &() {\n+    with_restriction::<T>(x) //~ ERROR the parameter type `T` may not live long enough\n+}\n+\n+fn with_restriction<'b, T: 'b>(x: &'b ()) -> &'b () {\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "a8b0996d8b0c71ad404e19ca4b5ff8dc64cd6e69", "filename": "src/test/ui/lifetimes/suggest-introducing-and-adding-missing-lifetime.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fsuggest-introducing-and-adding-missing-lifetime.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -0,0 +1,23 @@\n+error[E0311]: the parameter type `T` may not live long enough\n+  --> $DIR/suggest-introducing-and-adding-missing-lifetime.rs:2:5\n+   |\n+LL |     with_restriction::<T>(x)\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `T` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/suggest-introducing-and-adding-missing-lifetime.rs:1:25\n+   |\n+LL | fn no_restriction<T>(x: &()) -> &() {\n+   |                         ^^^\n+note: ...so that the type `T` will meet its required lifetime bounds\n+  --> $DIR/suggest-introducing-and-adding-missing-lifetime.rs:2:5\n+   |\n+LL |     with_restriction::<T>(x)\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn no_restriction<'a, T: 'a>(x: &()) -> &() {\n+   |                   +++  ++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "f162dd60f50331c57ce164785a29a76a30376065", "filename": "src/test/ui/match/match_non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -21,7 +21,7 @@ fn main() {\n     match l { L::A => (), L::B => () };\n     // (except if the match is already non-exhaustive)\n     match l { L::A => () };\n-    //~^ ERROR: non-exhaustive patterns: `B` not covered [E0004]\n+    //~^ ERROR: non-exhaustive patterns: `L::B` not covered [E0004]\n \n     // E1 is not visibly uninhabited from here\n     let (e1, e2) = bar();"}, {"sha": "46ee8d5179e6bcecb9bf1c0b4ae456f6b295a2d1", "filename": "src/test/ui/match/match_non_exhaustive.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `B` not covered\n+error[E0004]: non-exhaustive patterns: `L::B` not covered\n   --> $DIR/match_non_exhaustive.rs:23:11\n    |\n LL |     match l { L::A => () };\n-   |           ^ pattern `B` not covered\n+   |           ^ pattern `L::B` not covered\n    |\n note: `L` defined here\n   --> $DIR/match_non_exhaustive.rs:10:13\n@@ -12,8 +12,8 @@ LL | enum L { A, B }\n    = note: the matched value is of type `L`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     match l { L::A => (), B => todo!() };\n-   |                         ++++++++++++++\n+LL |     match l { L::A => (), L::B => todo!() };\n+   |                         +++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: type `E1` is non-empty\n   --> $DIR/match_non_exhaustive.rs:28:11"}, {"sha": "b703578860ec105683d0abcdf6eec3d71aa89229", "filename": "src/test/ui/parser/recover-field-semi.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fparser%2Frecover-field-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fparser%2Frecover-field-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-field-semi.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -0,0 +1,16 @@\n+struct Foo {\n+    foo: i32;\n+    //~^ ERROR struct fields are separated by `,`\n+}\n+\n+union Bar { //~ ERROR\n+    foo: i32;\n+    //~^ ERROR union fields are separated by `,`\n+}\n+\n+enum Baz {\n+    Qux { foo: i32; }\n+    //~^ ERROR struct fields are separated by `,`\n+}\n+\n+fn main() {}"}, {"sha": "657366db9b4b75ea996e68d839a9aaa05ae42b74", "filename": "src/test/ui/parser/recover-field-semi.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fparser%2Frecover-field-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fparser%2Frecover-field-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-field-semi.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -0,0 +1,29 @@\n+error: struct fields are separated by `,`\n+  --> $DIR/recover-field-semi.rs:2:13\n+   |\n+LL |     foo: i32;\n+   |             ^ help: replace `;` with `,`\n+\n+error: union fields are separated by `,`\n+  --> $DIR/recover-field-semi.rs:7:13\n+   |\n+LL |     foo: i32;\n+   |             ^ help: replace `;` with `,`\n+\n+error: struct fields are separated by `,`\n+  --> $DIR/recover-field-semi.rs:12:19\n+   |\n+LL |     Qux { foo: i32; }\n+   |                   ^ help: replace `;` with `,`\n+\n+error: unions cannot have zero fields\n+  --> $DIR/recover-field-semi.rs:6:1\n+   |\n+LL | / union Bar {\n+LL | |     foo: i32;\n+LL | |\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "808f2a5cc381c0618d0ce4b8f664726055468f1e", "filename": "src/test/ui/parser/removed-syntax-field-semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-semicolon.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,6 +1,6 @@\n struct S {\n     bar: ();\n-    //~^ ERROR expected `,`, or `}`, found `;`\n+    //~^ ERROR struct fields are separated by `,`\n }\n \n fn main() {}"}, {"sha": "e4f75f672063c1b0fc86914f3f8b38611d9551ba", "filename": "src/test/ui/parser/removed-syntax-field-semicolon.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-field-semicolon.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error: expected `,`, or `}`, found `;`\n+error: struct fields are separated by `,`\n   --> $DIR/removed-syntax-field-semicolon.rs:2:12\n    |\n LL |     bar: ();\n-   |            ^\n+   |            ^ help: replace `;` with `,`\n \n error: aborting due to previous error\n "}, {"sha": "5d4181a30f05220aeca7f1eab0e2cead8dee954b", "filename": "src/test/ui/pattern/usefulness/doc-hidden-non-exhaustive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -22,22 +22,22 @@ fn main() {\n         HiddenEnum::A => {}\n         HiddenEnum::C => {}\n     }\n-    //~^^^^ non-exhaustive patterns: `B` not covered\n+    //~^^^^ non-exhaustive patterns: `HiddenEnum::B` not covered\n \n     match HiddenEnum::A {\n         HiddenEnum::A => {}\n     }\n-    //~^^^ non-exhaustive patterns: `B` and `_` not covered\n+    //~^^^ non-exhaustive patterns: `HiddenEnum::B` and `_` not covered\n \n     match None {\n         None => {}\n         Some(HiddenEnum::A) => {}\n     }\n-    //~^^^^ non-exhaustive patterns: `Some(B)` and `Some(_)` not covered\n+    //~^^^^ non-exhaustive patterns: `Some(HiddenEnum::B)` and `Some(_)` not covered\n \n     match InCrate::A {\n         InCrate::A => {}\n         InCrate::B => {}\n     }\n-    //~^^^^ non-exhaustive patterns: `C` not covered\n+    //~^^^^ non-exhaustive patterns: `InCrate::C` not covered\n }"}, {"sha": "b450a9aeddf8d71f5cfd19de3a4ab80e7e3306c3", "filename": "src/test/ui/pattern/usefulness/doc-hidden-non-exhaustive.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -16,11 +16,11 @@ LL ~         HiddenEnum::B => {}\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `B` not covered\n+error[E0004]: non-exhaustive patterns: `HiddenEnum::B` not covered\n   --> $DIR/doc-hidden-non-exhaustive.rs:21:11\n    |\n LL |     match HiddenEnum::A {\n-   |           ^^^^^^^^^^^^^ pattern `B` not covered\n+   |           ^^^^^^^^^^^^^ pattern `HiddenEnum::B` not covered\n    |\n note: `HiddenEnum` defined here\n   --> $DIR/auxiliary/hidden.rs:3:5\n@@ -34,14 +34,14 @@ LL |     B,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         HiddenEnum::C => {}\n-LL +         B => todo!()\n+LL +         HiddenEnum::B => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `B` and `_` not covered\n+error[E0004]: non-exhaustive patterns: `HiddenEnum::B` and `_` not covered\n   --> $DIR/doc-hidden-non-exhaustive.rs:27:11\n    |\n LL |     match HiddenEnum::A {\n-   |           ^^^^^^^^^^^^^ patterns `B` and `_` not covered\n+   |           ^^^^^^^^^^^^^ patterns `HiddenEnum::B` and `_` not covered\n    |\n note: `HiddenEnum` defined here\n   --> $DIR/auxiliary/hidden.rs:3:5\n@@ -55,14 +55,14 @@ LL |     B,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         HiddenEnum::A => {}\n-LL +         B | _ => todo!()\n+LL +         HiddenEnum::B | _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Some(B)` and `Some(_)` not covered\n+error[E0004]: non-exhaustive patterns: `Some(HiddenEnum::B)` and `Some(_)` not covered\n   --> $DIR/doc-hidden-non-exhaustive.rs:32:11\n    |\n LL |     match None {\n-   |           ^^^^ patterns `Some(B)` and `Some(_)` not covered\n+   |           ^^^^ patterns `Some(HiddenEnum::B)` and `Some(_)` not covered\n    |\n note: `Option<HiddenEnum>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n@@ -76,14 +76,14 @@ LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         Some(HiddenEnum::A) => {}\n-LL +         Some(B) | Some(_) => todo!()\n+LL +         Some(HiddenEnum::B) | Some(_) => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `C` not covered\n+error[E0004]: non-exhaustive patterns: `InCrate::C` not covered\n   --> $DIR/doc-hidden-non-exhaustive.rs:38:11\n    |\n LL |     match InCrate::A {\n-   |           ^^^^^^^^^^ pattern `C` not covered\n+   |           ^^^^^^^^^^ pattern `InCrate::C` not covered\n    |\n note: `InCrate` defined here\n   --> $DIR/doc-hidden-non-exhaustive.rs:11:5\n@@ -97,7 +97,7 @@ LL |     C,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         InCrate::B => {}\n-LL +         C => todo!()\n+LL +         InCrate::C => todo!()\n    |\n \n error: aborting due to 5 previous errors"}, {"sha": "5e12bc1d22f01859a4b944d6a270986f0f91cc64", "filename": "src/test/ui/pattern/usefulness/empty-match.exhaustive_patterns.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -105,11 +105,11 @@ LL | union NonEmptyUnion2 {\n    = note: the matched value is of type `NonEmptyUnion2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n-error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum1::Foo(_)` not covered\n   --> $DIR/empty-match.rs:83:20\n    |\n LL |     match_no_arms!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyEnum1::Foo(_)` not covered\n    |\n note: `NonEmptyEnum1` defined here\n   --> $DIR/empty-match.rs:24:5\n@@ -121,11 +121,11 @@ LL |     Foo(bool),\n    = note: the matched value is of type `NonEmptyEnum1`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern\n \n-error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n   --> $DIR/empty-match.rs:84:20\n    |\n LL |     match_no_arms!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n    |\n note: `NonEmptyEnum2` defined here\n   --> $DIR/empty-match.rs:27:5\n@@ -139,11 +139,11 @@ LL |     Bar,\n    = note: the matched value is of type `NonEmptyEnum2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n-error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n   --> $DIR/empty-match.rs:85:20\n    |\n LL |     match_no_arms!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n    |\n note: `NonEmptyEnum5` defined here\n   --> $DIR/empty-match.rs:30:6\n@@ -238,11 +238,11 @@ LL ~             _ if false => {}\n LL +             NonEmptyUnion2 { .. } => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum1::Foo(_)` not covered\n   --> $DIR/empty-match.rs:92:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum1::Foo(true));\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyEnum1::Foo(_)` not covered\n    |\n note: `NonEmptyEnum1` defined here\n   --> $DIR/empty-match.rs:24:5\n@@ -255,14 +255,14 @@ LL |     Foo(bool),\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~             _ if false => {}\n-LL +             Foo(_) => todo!()\n+LL +             NonEmptyEnum1::Foo(_) => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n   --> $DIR/empty-match.rs:93:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum2::Foo(true));\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n    |\n note: `NonEmptyEnum2` defined here\n   --> $DIR/empty-match.rs:27:5\n@@ -277,14 +277,14 @@ LL |     Bar,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~             _ if false => {}\n-LL +             Foo(_) | Bar => todo!()\n+LL +             NonEmptyEnum2::Foo(_) | NonEmptyEnum2::Bar => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n   --> $DIR/empty-match.rs:94:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum5::V1);\n-   |                        ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |                        ^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n    |\n note: `NonEmptyEnum5` defined here\n   --> $DIR/empty-match.rs:30:6"}, {"sha": "5e12bc1d22f01859a4b944d6a270986f0f91cc64", "filename": "src/test/ui/pattern/usefulness/empty-match.normal.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -105,11 +105,11 @@ LL | union NonEmptyUnion2 {\n    = note: the matched value is of type `NonEmptyUnion2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n-error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum1::Foo(_)` not covered\n   --> $DIR/empty-match.rs:83:20\n    |\n LL |     match_no_arms!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyEnum1::Foo(_)` not covered\n    |\n note: `NonEmptyEnum1` defined here\n   --> $DIR/empty-match.rs:24:5\n@@ -121,11 +121,11 @@ LL |     Foo(bool),\n    = note: the matched value is of type `NonEmptyEnum1`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern\n \n-error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n   --> $DIR/empty-match.rs:84:20\n    |\n LL |     match_no_arms!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n    |\n note: `NonEmptyEnum2` defined here\n   --> $DIR/empty-match.rs:27:5\n@@ -139,11 +139,11 @@ LL |     Bar,\n    = note: the matched value is of type `NonEmptyEnum2`\n    = help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or multiple match arms\n \n-error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n   --> $DIR/empty-match.rs:85:20\n    |\n LL |     match_no_arms!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n    |\n note: `NonEmptyEnum5` defined here\n   --> $DIR/empty-match.rs:30:6\n@@ -238,11 +238,11 @@ LL ~             _ if false => {}\n LL +             NonEmptyUnion2 { .. } => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum1::Foo(_)` not covered\n   --> $DIR/empty-match.rs:92:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum1::Foo(true));\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyEnum1::Foo(_)` not covered\n    |\n note: `NonEmptyEnum1` defined here\n   --> $DIR/empty-match.rs:24:5\n@@ -255,14 +255,14 @@ LL |     Foo(bool),\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~             _ if false => {}\n-LL +             Foo(_) => todo!()\n+LL +             NonEmptyEnum1::Foo(_) => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n   --> $DIR/empty-match.rs:93:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum2::Foo(true));\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n    |\n note: `NonEmptyEnum2` defined here\n   --> $DIR/empty-match.rs:27:5\n@@ -277,14 +277,14 @@ LL |     Bar,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~             _ if false => {}\n-LL +             Foo(_) | Bar => todo!()\n+LL +             NonEmptyEnum2::Foo(_) | NonEmptyEnum2::Bar => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n   --> $DIR/empty-match.rs:94:24\n    |\n LL |     match_guarded_arm!(NonEmptyEnum5::V1);\n-   |                        ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |                        ^^^^^^^^^^^^^^^^^ patterns `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n    |\n note: `NonEmptyEnum5` defined here\n   --> $DIR/empty-match.rs:30:6"}, {"sha": "9cdc0413ba10ff1efb4d427cbc758a2f0f66bc5f", "filename": "src/test/ui/pattern/usefulness/empty-match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -80,16 +80,16 @@ fn main() {\n     match_no_arms!(NonEmptyStruct2(true)); //~ ERROR type `NonEmptyStruct2` is non-empty\n     match_no_arms!((NonEmptyUnion1 { foo: () })); //~ ERROR type `NonEmptyUnion1` is non-empty\n     match_no_arms!((NonEmptyUnion2 { foo: () })); //~ ERROR type `NonEmptyUnion2` is non-empty\n-    match_no_arms!(NonEmptyEnum1::Foo(true)); //~ ERROR `Foo(_)` not covered\n-    match_no_arms!(NonEmptyEnum2::Foo(true)); //~ ERROR `Foo(_)` and `Bar` not covered\n-    match_no_arms!(NonEmptyEnum5::V1); //~ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+    match_no_arms!(NonEmptyEnum1::Foo(true)); //~ ERROR `NonEmptyEnum1::Foo(_)` not covered\n+    match_no_arms!(NonEmptyEnum2::Foo(true)); //~ ERROR `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n+    match_no_arms!(NonEmptyEnum5::V1); //~ ERROR `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n \n     match_guarded_arm!(0u8); //~ ERROR `_` not covered\n     match_guarded_arm!(NonEmptyStruct1); //~ ERROR `NonEmptyStruct1` not covered\n     match_guarded_arm!(NonEmptyStruct2(true)); //~ ERROR `NonEmptyStruct2(_)` not covered\n     match_guarded_arm!((NonEmptyUnion1 { foo: () })); //~ ERROR `NonEmptyUnion1 { .. }` not covered\n     match_guarded_arm!((NonEmptyUnion2 { foo: () })); //~ ERROR `NonEmptyUnion2 { .. }` not covered\n-    match_guarded_arm!(NonEmptyEnum1::Foo(true)); //~ ERROR `Foo(_)` not covered\n-    match_guarded_arm!(NonEmptyEnum2::Foo(true)); //~ ERROR `Foo(_)` and `Bar` not covered\n-    match_guarded_arm!(NonEmptyEnum5::V1); //~ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+    match_guarded_arm!(NonEmptyEnum1::Foo(true)); //~ ERROR `NonEmptyEnum1::Foo(_)` not covered\n+    match_guarded_arm!(NonEmptyEnum2::Foo(true)); //~ ERROR `NonEmptyEnum2::Foo(_)` and `NonEmptyEnum2::Bar` not covered\n+    match_guarded_arm!(NonEmptyEnum5::V1); //~ ERROR `NonEmptyEnum5::V1`, `NonEmptyEnum5::V2`, `NonEmptyEnum5::V3` and 2 more not covered\n }"}, {"sha": "f02e5c0c6f8a765f7c70c93800fe4acde0ba69e1", "filename": "src/test/ui/pattern/usefulness/issue-15129.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -10,7 +10,7 @@ pub enum V {\n \n fn main() {\n     match (T::T1(()), V::V2(true)) {\n-        //~^ ERROR non-exhaustive patterns: `(T1(()), V2(_))` and `(T2(()), V1(_))` not covered\n+        //~^ ERROR non-exhaustive patterns: `(T::T1(()), V::V2(_))` and `(T::T2(()), V::V1(_))` not covered\n         (T::T1(()), V::V1(i)) => (),\n         (T::T2(()), V::V2(b)) => (),\n     }"}, {"sha": "ee8410b7650899532aae145c9858fad7ee9e6cf2", "filename": "src/test/ui/pattern/usefulness/issue-15129.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,14 +1,14 @@\n-error[E0004]: non-exhaustive patterns: `(T1(()), V2(_))` and `(T2(()), V1(_))` not covered\n+error[E0004]: non-exhaustive patterns: `(T::T1(()), V::V2(_))` and `(T::T2(()), V::V1(_))` not covered\n   --> $DIR/issue-15129.rs:12:11\n    |\n LL |     match (T::T1(()), V::V2(true)) {\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `(T1(()), V2(_))` and `(T2(()), V1(_))` not covered\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `(T::T1(()), V::V2(_))` and `(T::T2(()), V::V1(_))` not covered\n    |\n    = note: the matched value is of type `(T, V)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         (T::T2(()), V::V2(b)) => (),\n-LL ~         (T1(()), V2(_)) | (T2(()), V1(_)) => todo!(),\n+LL ~         (T::T1(()), V::V2(_)) | (T::T2(()), V::V1(_)) => todo!(),\n    |\n \n error: aborting due to previous error"}, {"sha": "5b878851a3144f5a5ff6a2291c96c9c79c90ea86", "filename": "src/test/ui/pattern/usefulness/issue-31561.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -6,5 +6,5 @@ enum Thing {\n \n fn main() {\n     let Thing::Foo(y) = Thing::Foo(1);\n-    //~^ ERROR refutable pattern in local binding: `Bar` and `Baz` not covered\n+    //~^ ERROR refutable pattern in local binding: `Thing::Bar` and `Thing::Baz` not covered\n }"}, {"sha": "46aebccc5fffff44328fb2f8cd9fb8a238a2d400", "filename": "src/test/ui/pattern/usefulness/issue-31561.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `Bar` and `Baz` not covered\n+error[E0005]: refutable pattern in local binding: `Thing::Bar` and `Thing::Baz` not covered\n   --> $DIR/issue-31561.rs:8:9\n    |\n LL |     let Thing::Foo(y) = Thing::Foo(1);\n-   |         ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n+   |         ^^^^^^^^^^^^^ patterns `Thing::Bar` and `Thing::Baz` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "c9781d52e6dcf529a79639257c79e9a238be0e5b", "filename": "src/test/ui/pattern/usefulness/issue-35609.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `(Enum::B, _)`, `(Enum::C, _)`, `(Enum::D, _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:10:11\n    |\n LL |     match (A, ()) {\n-   |           ^^^^^^^ patterns `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n+   |           ^^^^^^^ patterns `(Enum::B, _)`, `(Enum::C, _)`, `(Enum::D, _)` and 2 more not covered\n    |\n    = note: the matched value is of type `(Enum, ())`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n@@ -11,11 +11,11 @@ LL ~         (A, _) => {}\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `(_, Enum::B)`, `(_, Enum::C)`, `(_, Enum::D)` and 2 more not covered\n   --> $DIR/issue-35609.rs:14:11\n    |\n LL |     match (A, A) {\n-   |           ^^^^^^ patterns `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n+   |           ^^^^^^ patterns `(_, Enum::B)`, `(_, Enum::C)`, `(_, Enum::D)` and 2 more not covered\n    |\n    = note: the matched value is of type `(Enum, Enum)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n@@ -24,11 +24,11 @@ LL ~         (_, A) => {}\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `((Enum::B, _), _)`, `((Enum::C, _), _)`, `((Enum::D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:18:11\n    |\n LL |     match ((A, ()), ()) {\n-   |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+   |           ^^^^^^^^^^^^^ patterns `((Enum::B, _), _)`, `((Enum::C, _), _)`, `((Enum::D, _), _)` and 2 more not covered\n    |\n    = note: the matched value is of type `((Enum, ()), ())`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n@@ -37,11 +37,11 @@ LL ~         ((A, ()), _) => {}\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `((Enum::B, _), _)`, `((Enum::C, _), _)`, `((Enum::D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:22:11\n    |\n LL |     match ((A, ()), A) {\n-   |           ^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+   |           ^^^^^^^^^^^^ patterns `((Enum::B, _), _)`, `((Enum::C, _), _)`, `((Enum::D, _), _)` and 2 more not covered\n    |\n    = note: the matched value is of type `((Enum, ()), Enum)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n@@ -50,11 +50,11 @@ LL ~         ((A, ()), _) => {}\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `((Enum::B, _), _)`, `((Enum::C, _), _)`, `((Enum::D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:26:11\n    |\n LL |     match ((A, ()), ()) {\n-   |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+   |           ^^^^^^^^^^^^^ patterns `((Enum::B, _), _)`, `((Enum::C, _), _)`, `((Enum::D, _), _)` and 2 more not covered\n    |\n    = note: the matched value is of type `((Enum, ()), ())`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n@@ -63,11 +63,11 @@ LL ~         ((A, _), _) => {}\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `S(Enum::B, _)`, `S(Enum::C, _)`, `S(Enum::D, _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:31:11\n    |\n LL |     match S(A, ()) {\n-   |           ^^^^^^^^ patterns `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n+   |           ^^^^^^^^ patterns `S(Enum::B, _)`, `S(Enum::C, _)`, `S(Enum::D, _)` and 2 more not covered\n    |\n note: `S` defined here\n   --> $DIR/issue-35609.rs:6:8\n@@ -81,11 +81,11 @@ LL ~         S(A, _) => {}\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `Sd { x: Enum::B, .. }`, `Sd { x: Enum::C, .. }`, `Sd { x: Enum::D, .. }` and 2 more not covered\n   --> $DIR/issue-35609.rs:35:11\n    |\n LL |     match (Sd { x: A, y: () }) {\n-   |           ^^^^^^^^^^^^^^^^^^^^ patterns `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n+   |           ^^^^^^^^^^^^^^^^^^^^ patterns `Sd { x: Enum::B, .. }`, `Sd { x: Enum::C, .. }`, `Sd { x: Enum::D, .. }` and 2 more not covered\n    |\n note: `Sd` defined here\n   --> $DIR/issue-35609.rs:7:8\n@@ -99,11 +99,11 @@ LL ~         Sd { x: A, y: _ } => {}\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `Some(Enum::B)`, `Some(Enum::C)`, `Some(Enum::D)` and 2 more not covered\n   --> $DIR/issue-35609.rs:39:11\n    |\n LL |     match Some(A) {\n-   |           ^^^^^^^ patterns `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n+   |           ^^^^^^^ patterns `Some(Enum::B)`, `Some(Enum::C)`, `Some(Enum::D)` and 2 more not covered\n    |\n note: `Option<Enum>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL"}, {"sha": "b8b17918aef8cb69c4b972153e15617f8a2cb0e9", "filename": "src/test/ui/pattern/usefulness/issue-39362.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n+error[E0004]: non-exhaustive patterns: `Foo::Bar { bar: Bar::C, .. }`, `Foo::Bar { bar: Bar::D, .. }`, `Foo::Bar { bar: Bar::E, .. }` and 1 more not covered\n   --> $DIR/issue-39362.rs:10:11\n    |\n LL |     match f {\n-   |           ^ patterns `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n+   |           ^ patterns `Foo::Bar { bar: Bar::C, .. }`, `Foo::Bar { bar: Bar::D, .. }`, `Foo::Bar { bar: Bar::E, .. }` and 1 more not covered\n    |\n note: `Foo` defined here\n   --> $DIR/issue-39362.rs:2:5"}, {"sha": "4973e42b054478ff1c2110fec79427cb25501eea", "filename": "src/test/ui/pattern/usefulness/issue-40221.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `C(QA)` not covered\n+error[E0004]: non-exhaustive patterns: `P::C(PC::QA)` not covered\n   --> $DIR/issue-40221.rs:11:11\n    |\n LL |     match proto {\n-   |           ^^^^^ pattern `C(QA)` not covered\n+   |           ^^^^^ pattern `P::C(PC::QA)` not covered\n    |\n note: `P` defined here\n   --> $DIR/issue-40221.rs:2:5\n@@ -15,7 +15,7 @@ LL |     C(PC),\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         P::C(PC::Q) => (),\n-LL ~         C(QA) => todo!(),\n+LL ~         P::C(PC::QA) => todo!(),\n    |\n \n error: aborting due to previous error"}, {"sha": "9cc760e9a10d73b0a02ef4ba3001c4a4cb3fefcf", "filename": "src/test/ui/pattern/usefulness/issue-50900.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -13,7 +13,7 @@ impl Tag {\n \n fn main() {\n     match Tag::ExifIFDPointer {\n-    //~^ ERROR: non-exhaustive patterns: `Tag(Exif, _)` not covered\n+    //~^ ERROR: non-exhaustive patterns: `Tag(Context::Exif, _)` not covered\n         Tag::ExifIFDPointer => {}\n     }\n }"}, {"sha": "348246d28aacafe901b1f8d71e3e95696c349005", "filename": "src/test/ui/pattern/usefulness/issue-50900.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `Tag(Exif, _)` not covered\n+error[E0004]: non-exhaustive patterns: `Tag(Context::Exif, _)` not covered\n   --> $DIR/issue-50900.rs:15:11\n    |\n LL |     match Tag::ExifIFDPointer {\n-   |           ^^^^^^^^^^^^^^^^^^^ pattern `Tag(Exif, _)` not covered\n+   |           ^^^^^^^^^^^^^^^^^^^ pattern `Tag(Context::Exif, _)` not covered\n    |\n note: `Tag` defined here\n   --> $DIR/issue-50900.rs:2:12\n@@ -13,7 +13,7 @@ LL | pub struct Tag(pub Context, pub u16);\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         Tag::ExifIFDPointer => {}\n-LL +         Tag(Exif, _) => todo!()\n+LL +         Tag(Context::Exif, _) => todo!()\n    |\n \n error: aborting due to previous error"}, {"sha": "097cf98d0126b91a0c8dc9a6bf452a3c1fb28667", "filename": "src/test/ui/pattern/usefulness/issue-56379.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -6,7 +6,7 @@ enum Foo {\n \n fn main() {\n     match Foo::A(true) {\n-        //~^ ERROR non-exhaustive patterns: `A(false)`, `B(false)` and `C(false)` not covered\n+        //~^ ERROR non-exhaustive patterns: `Foo::A(false)`, `Foo::B(false)` and `Foo::C(false)` not covered\n         Foo::A(true) => {}\n         Foo::B(true) => {}\n         Foo::C(true) => {}"}, {"sha": "6eed6bfae4c90d512d72279ad1ae5630e5ea6903", "filename": "src/test/ui/pattern/usefulness/issue-56379.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `A(false)`, `B(false)` and `C(false)` not covered\n+error[E0004]: non-exhaustive patterns: `Foo::A(false)`, `Foo::B(false)` and `Foo::C(false)` not covered\n   --> $DIR/issue-56379.rs:8:11\n    |\n LL |     match Foo::A(true) {\n-   |           ^^^^^^^^^^^^ patterns `A(false)`, `B(false)` and `C(false)` not covered\n+   |           ^^^^^^^^^^^^ patterns `Foo::A(false)`, `Foo::B(false)` and `Foo::C(false)` not covered\n    |\n note: `Foo` defined here\n   --> $DIR/issue-56379.rs:2:5\n@@ -19,7 +19,7 @@ LL |     C(bool),\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         Foo::C(true) => {}\n-LL +         A(false) | B(false) | C(false) => todo!()\n+LL +         Foo::A(false) | Foo::B(false) | Foo::C(false) => todo!()\n    |\n \n error: aborting due to previous error"}, {"sha": "b5ad3075ca725410968cc48b1e97643a84719fe9", "filename": "src/test/ui/pattern/usefulness/issue-72377.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     let y = Some(X::A);\n \n     match (x, y) {\n-        //~^ ERROR non-exhaustive patterns: `(A, Some(A))`, `(A, Some(B))`, `(B, Some(B))` and 2\n+        //~^ ERROR non-exhaustive patterns: `(X::A, Some(X::A))`, `(X::A, Some(X::B))`, `(X::B, Some(X::B))` and 2\n         //~| more not covered\n         (_, None) => false,\n         (v, Some(w)) if v == w => true,"}, {"sha": "123dd051d2495186947691eda34b41a82fd58e5f", "filename": "src/test/ui/pattern/usefulness/issue-72377.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-72377.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `(A, Some(A))`, `(A, Some(B))`, `(B, Some(B))` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `(X::A, Some(X::A))`, `(X::A, Some(X::B))`, `(X::B, Some(X::B))` and 2 more not covered\n   --> $DIR/issue-72377.rs:8:11\n    |\n LL |     match (x, y) {\n-   |           ^^^^^^ patterns `(A, Some(A))`, `(A, Some(B))`, `(B, Some(B))` and 2 more not covered\n+   |           ^^^^^^ patterns `(X::A, Some(X::A))`, `(X::A, Some(X::B))`, `(X::B, Some(X::B))` and 2 more not covered\n    |\n    = note: the matched value is of type `(X, Option<X>)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms"}, {"sha": "3c9c16561c0281526d3fb554302d9de84dd1d315", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -27,7 +27,7 @@ const EAST: Direction = East;\n \n fn nonexhaustive_2() {\n     match Some(Some(North)) {\n-    //~^ ERROR non-exhaustive patterns: `Some(Some(West))` not covered\n+    //~^ ERROR non-exhaustive patterns: `Some(Some(Direction::West))` not covered\n         Some(NONE) => (),\n         Some(Some(North)) => (),\n         Some(Some(EAST)) => (),\n@@ -46,7 +46,7 @@ const STATIC_FOO: Foo = Foo { bar: None, baz: NEW_FALSE };\n \n fn nonexhaustive_3() {\n     match (Foo { bar: Some(North), baz: NewBool(true) }) {\n-    //~^ ERROR non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }`\n+    //~^ ERROR non-exhaustive patterns: `Foo { bar: Some(Direction::North), baz: NewBool(true) }`\n         Foo { bar: None, baz: NewBool(true) } => (),\n         Foo { bar: _, baz: NEW_FALSE } => (),\n         Foo { bar: Some(West), baz: NewBool(true) } => (),"}, {"sha": "b0d7fe5eb6892174c9c92821a39d7abdf9cdbc31", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -11,11 +11,11 @@ LL ~         (false, true) => (),\n LL +         (true, false) => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Some(Some(West))` not covered\n+error[E0004]: non-exhaustive patterns: `Some(Some(Direction::West))` not covered\n   --> $DIR/match-arm-statics-2.rs:29:11\n    |\n LL |     match Some(Some(North)) {\n-   |           ^^^^^^^^^^^^^^^^^ pattern `Some(Some(West))` not covered\n+   |           ^^^^^^^^^^^^^^^^^ pattern `Some(Some(Direction::West))` not covered\n    |\n note: `Option<Option<Direction>>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n@@ -32,14 +32,14 @@ LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         None => (),\n-LL +         Some(Some(West)) => todo!()\n+LL +         Some(Some(Direction::West)) => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n+error[E0004]: non-exhaustive patterns: `Foo { bar: Some(Direction::North), baz: NewBool(true) }` not covered\n   --> $DIR/match-arm-statics-2.rs:48:11\n    |\n LL |     match (Foo { bar: Some(North), baz: NewBool(true) }) {\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { bar: Some(Direction::North), baz: NewBool(true) }` not covered\n    |\n note: `Foo` defined here\n   --> $DIR/match-arm-statics-2.rs:40:8\n@@ -50,7 +50,7 @@ LL | struct Foo {\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         Foo { bar: Some(EAST), .. } => (),\n-LL +         Foo { bar: Some(North), baz: NewBool(true) } => todo!()\n+LL +         Foo { bar: Some(Direction::North), baz: NewBool(true) } => todo!()\n    |\n \n error: aborting due to 3 previous errors"}, {"sha": "af42fc1aeb463ed9da0c86805144f83c4f188c9b", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-defined-here.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -35,43 +35,43 @@ enum E {\n \n fn by_val(e: E) {\n     let e1 = e.clone();\n-    match e1 { //~ ERROR non-exhaustive patterns: `B` and `C` not covered\n-        //~^ NOTE patterns `B` and `C` not covered\n+    match e1 { //~ ERROR non-exhaustive patterns: `E::B` and `E::C` not covered\n+        //~^ NOTE patterns `E::B` and `E::C` not covered\n         //~| NOTE the matched value is of type `E`\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `B` and `C` not covered\n-    //~^ NOTE patterns `B` and `C` not covered\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `E::B` and `E::C` not covered\n+    //~^ NOTE patterns `E::B` and `E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `E`\n }\n \n fn by_ref_once(e: &E) {\n-    match e { //~ ERROR non-exhaustive patterns: `&B` and `&C` not covered\n-    //~^ NOTE patterns `&B` and `&C` not covered\n+    match e { //~ ERROR non-exhaustive patterns: `&E::B` and `&E::C` not covered\n+    //~^ NOTE patterns `&E::B` and `&E::C` not covered\n     //~| NOTE the matched value is of type `&E`\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `&B` and `&C` not covered\n-    //~^ NOTE patterns `&B` and `&C` not covered\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `&E::B` and `&E::C` not covered\n+    //~^ NOTE patterns `&E::B` and `&E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `&E`\n }\n \n fn by_ref_thrice(e: & &mut &E) {\n-    match e { //~ ERROR non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n-    //~^ NOTE patterns `&&mut &B` and `&&mut &C` not covered\n+    match e { //~ ERROR non-exhaustive patterns: `&&mut &E::B` and `&&mut &E::C` not covered\n+    //~^ NOTE patterns `&&mut &E::B` and `&&mut &E::C` not covered\n     //~| NOTE the matched value is of type `&&mut &E`\n         E::A => {}\n     }\n \n     let E::A = e;\n-    //~^ ERROR refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n-    //~| NOTE patterns `&&mut &B` and `&&mut &C` not covered\n+    //~^ ERROR refutable pattern in local binding: `&&mut &E::B` and `&&mut &E::C` not covered\n+    //~| NOTE patterns `&&mut &E::B` and `&&mut &E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `&&mut &E`\n@@ -89,15 +89,15 @@ enum Opt {\n }\n \n fn ref_pat(e: Opt) {\n-    match e {//~ ERROR non-exhaustive patterns: `None` not covered\n-        //~^ NOTE pattern `None` not covered\n+    match e {//~ ERROR non-exhaustive patterns: `Opt::None` not covered\n+        //~^ NOTE pattern `Opt::None` not covered\n         //~| NOTE the matched value is of type `Opt`\n         Opt::Some(ref _x) => {}\n     }\n \n-    let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `None` not covered\n+    let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `Opt::None` not covered\n     //~^ NOTE the matched value is of type `Opt`\n-    //~| NOTE pattern `None` not covered\n+    //~| NOTE pattern `Opt::None` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n }"}, {"sha": "ac2a9713e7d24325d9000524a5fa30fc500d89a2", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `B` and `C` not covered\n+error[E0004]: non-exhaustive patterns: `E::B` and `E::C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:38:11\n    |\n LL |     match e1 {\n-   |           ^^ patterns `B` and `C` not covered\n+   |           ^^ patterns `E::B` and `E::C` not covered\n    |\n note: `E` defined here\n   --> $DIR/non-exhaustive-defined-here.rs:14:5\n@@ -19,14 +19,14 @@ LL |     C\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         E::A => {}\n-LL +         B | C => todo!()\n+LL +         E::B | E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `B` and `C` not covered\n+error[E0005]: refutable pattern in local binding: `E::B` and `E::C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:44:9\n    |\n LL |     let E::A = e;\n-   |         ^^^^ patterns `B` and `C` not covered\n+   |         ^^^^ patterns `E::B` and `E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -47,11 +47,11 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL |     if let E::A = e { todo!() }\n    |     ++              ~~~~~~~~~~~\n \n-error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n+error[E0004]: non-exhaustive patterns: `&E::B` and `&E::C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:52:11\n    |\n LL |     match e {\n-   |           ^ patterns `&B` and `&C` not covered\n+   |           ^ patterns `&E::B` and `&E::C` not covered\n    |\n note: `E` defined here\n   --> $DIR/non-exhaustive-defined-here.rs:14:5\n@@ -68,14 +68,14 @@ LL |     C\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         E::A => {}\n-LL +         &B | &C => todo!()\n+LL +         &E::B | &E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `&B` and `&C` not covered\n+error[E0005]: refutable pattern in local binding: `&E::B` and `&E::C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:58:9\n    |\n LL |     let E::A = e;\n-   |         ^^^^ patterns `&B` and `&C` not covered\n+   |         ^^^^ patterns `&E::B` and `&E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -96,11 +96,11 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL |     if let E::A = e { todo!() }\n    |     ++              ~~~~~~~~~~~\n \n-error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n+error[E0004]: non-exhaustive patterns: `&&mut &E::B` and `&&mut &E::C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:66:11\n    |\n LL |     match e {\n-   |           ^ patterns `&&mut &B` and `&&mut &C` not covered\n+   |           ^ patterns `&&mut &E::B` and `&&mut &E::C` not covered\n    |\n note: `E` defined here\n   --> $DIR/non-exhaustive-defined-here.rs:14:5\n@@ -117,14 +117,14 @@ LL |     C\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         E::A => {}\n-LL +         &&mut &B | &&mut &C => todo!()\n+LL +         &&mut &E::B | &&mut &E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n+error[E0005]: refutable pattern in local binding: `&&mut &E::B` and `&&mut &E::C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:72:9\n    |\n LL |     let E::A = e;\n-   |         ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n+   |         ^^^^ patterns `&&mut &E::B` and `&&mut &E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -145,11 +145,11 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL |     if let E::A = e { todo!() }\n    |     ++              ~~~~~~~~~~~\n \n-error[E0004]: non-exhaustive patterns: `None` not covered\n+error[E0004]: non-exhaustive patterns: `Opt::None` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:92:11\n    |\n LL |     match e {\n-   |           ^ pattern `None` not covered\n+   |           ^ pattern `Opt::None` not covered\n    |\n note: `Opt` defined here\n   --> $DIR/non-exhaustive-defined-here.rs:84:5\n@@ -163,14 +163,14 @@ LL |     None,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         Opt::Some(ref _x) => {}\n-LL +         None => todo!()\n+LL +         Opt::None => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `None` not covered\n+error[E0005]: refutable pattern in local binding: `Opt::None` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:98:9\n    |\n LL |     let Opt::Some(ref _x) = e;\n-   |         ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n+   |         ^^^^^^^^^^^^^^^^^ pattern `Opt::None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "69c3c76580a7a8b6252e95091da0951bb5befbb7", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -12,7 +12,7 @@ fn match_nested_vecs<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'s\n \n fn main() {\n     let x = T::A(U::C);\n-    match x { //~ ERROR non-exhaustive patterns: `A(C)` not covered\n+    match x { //~ ERROR non-exhaustive patterns: `T::A(U::C)` not covered\n         T::A(U::D) => { panic!(\"hello\"); }\n         T::B => { panic!(\"goodbye\"); }\n     }"}, {"sha": "44f327421109a8b79d69f0a30aecf152f5e15f4a", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match-nested.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -11,11 +11,11 @@ LL ~         (None, Ok(&[_, _, ..])) => \"None, Ok(at least two elements)\",\n LL +         (Some(&[]), Err(_)) => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `A(C)` not covered\n+error[E0004]: non-exhaustive patterns: `T::A(U::C)` not covered\n   --> $DIR/non-exhaustive-match-nested.rs:15:11\n    |\n LL |     match x {\n-   |           ^ pattern `A(C)` not covered\n+   |           ^ pattern `T::A(U::C)` not covered\n    |\n note: `T` defined here\n   --> $DIR/non-exhaustive-match-nested.rs:1:10\n@@ -26,7 +26,7 @@ LL | enum T { A(U), B }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         T::B => { panic!(\"goodbye\"); }\n-LL +         A(C) => todo!()\n+LL +         T::A(U::C) => todo!()\n    |\n \n error: aborting due to 2 previous errors"}, {"sha": "1cb58b8cebef71ffa3335b926593b5631825cf8f", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -4,7 +4,7 @@ enum T { A, B }\n \n fn main() {\n     let x = T::A;\n-    match x { T::B => { } } //~ ERROR non-exhaustive patterns: `A` not covered\n+    match x { T::B => { } } //~ ERROR non-exhaustive patterns: `T::A` not covered\n     match true { //~ ERROR non-exhaustive patterns: `false` not covered\n       true => {}\n     }\n@@ -15,11 +15,11 @@ fn main() {\n                       //  and `(_, _, 5_i32..=i32::MAX)` not covered\n       (_, _, 4) => {}\n     }\n-    match (T::A, T::A) { //~ ERROR non-exhaustive patterns: `(A, A)` and `(B, B)` not covered\n+    match (T::A, T::A) { //~ ERROR non-exhaustive patterns: `(T::A, T::A)` and `(T::B, T::B)` not covered\n       (T::A, T::B) => {}\n       (T::B, T::A) => {}\n     }\n-    match T::A { //~ ERROR non-exhaustive patterns: `B` not covered\n+    match T::A { //~ ERROR non-exhaustive patterns: `T::B` not covered\n       T::A => {}\n     }\n     // This is exhaustive, though the algorithm got it wrong at one point"}, {"sha": "4234600d0d02f75144dd41ef900ea1681d522aa6", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `A` not covered\n+error[E0004]: non-exhaustive patterns: `T::A` not covered\n   --> $DIR/non-exhaustive-match.rs:7:11\n    |\n LL |     match x { T::B => { } }\n-   |           ^ pattern `A` not covered\n+   |           ^ pattern `T::A` not covered\n    |\n note: `T` defined here\n   --> $DIR/non-exhaustive-match.rs:3:10\n@@ -12,8 +12,8 @@ LL | enum T { A, B }\n    = note: the matched value is of type `T`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n-LL |     match x { T::B => { }, A => todo!() }\n-   |                          ++++++++++++++\n+LL |     match x { T::B => { }, T::A => todo!() }\n+   |                          +++++++++++++++++\n \n error[E0004]: non-exhaustive patterns: `false` not covered\n   --> $DIR/non-exhaustive-match.rs:8:11\n@@ -62,24 +62,24 @@ LL ~       (_, _, 4) => {}\n LL +       (_, _, i32::MIN..=3_i32) | (_, _, 5_i32..=i32::MAX) => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `(A, A)` and `(B, B)` not covered\n+error[E0004]: non-exhaustive patterns: `(T::A, T::A)` and `(T::B, T::B)` not covered\n   --> $DIR/non-exhaustive-match.rs:18:11\n    |\n LL |     match (T::A, T::A) {\n-   |           ^^^^^^^^^^^^ patterns `(A, A)` and `(B, B)` not covered\n+   |           ^^^^^^^^^^^^ patterns `(T::A, T::A)` and `(T::B, T::B)` not covered\n    |\n    = note: the matched value is of type `(T, T)`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~       (T::B, T::A) => {}\n-LL +       (A, A) | (B, B) => todo!()\n+LL +       (T::A, T::A) | (T::B, T::B) => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `B` not covered\n+error[E0004]: non-exhaustive patterns: `T::B` not covered\n   --> $DIR/non-exhaustive-match.rs:22:11\n    |\n LL |     match T::A {\n-   |           ^^^^ pattern `B` not covered\n+   |           ^^^^ pattern `T::B` not covered\n    |\n note: `T` defined here\n   --> $DIR/non-exhaustive-match.rs:3:13\n@@ -90,7 +90,7 @@ LL | enum T { A, B }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~       T::A => {}\n-LL +       B => todo!()\n+LL +       T::B => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `[]` not covered"}, {"sha": "4bd34421922bd9d83fec8145a2bac4b5ce484731", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -21,7 +21,7 @@ enum Color {\n \n fn enum_with_single_missing_variant() {\n     match Color::Red {\n-    //~^ ERROR non-exhaustive patterns: `Red` not covered\n+    //~^ ERROR non-exhaustive patterns: `Color::Red` not covered\n         Color::CustomRGBA { .. } => (),\n         Color::Green => ()\n     }\n@@ -33,7 +33,7 @@ enum Direction {\n \n fn enum_with_multiple_missing_variants() {\n     match Direction::North {\n-    //~^ ERROR non-exhaustive patterns: `East`, `South` and `West` not covered\n+    //~^ ERROR non-exhaustive patterns: `Direction::East`, `Direction::South` and `Direction::West` not covered\n         Direction::North => ()\n     }\n }\n@@ -44,15 +44,15 @@ enum ExcessiveEnum {\n \n fn enum_with_excessive_missing_variants() {\n     match ExcessiveEnum::First {\n-    //~^ ERROR `Second`, `Third`, `Fourth` and 8 more not covered\n+    //~^ ERROR `ExcessiveEnum::Second`, `ExcessiveEnum::Third`, `ExcessiveEnum::Fourth` and 8 more not covered\n \n         ExcessiveEnum::First => ()\n     }\n }\n \n fn enum_struct_variant() {\n     match Color::Red {\n-    //~^ ERROR non-exhaustive patterns: `CustomRGBA { a: true, .. }` not covered\n+    //~^ ERROR non-exhaustive patterns: `Color::CustomRGBA { a: true, .. }` not covered\n         Color::Red => (),\n         Color::Green => (),\n         Color::CustomRGBA { a: false, r: _, g: _, b: 0 } => (),\n@@ -68,7 +68,7 @@ enum Enum {\n fn vectors_with_nested_enums() {\n     let x: &'static [Enum] = &[Enum::First, Enum::Second(false)];\n     match *x {\n-    //~^ ERROR non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n+    //~^ ERROR non-exhaustive patterns: `[Enum::Second(true), Enum::Second(false)]` not covered\n         [] => (),\n         [_] => (),\n         [Enum::First, _] => (),"}, {"sha": "b8af566de7c680d16faee808d8a37564986932e2", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-pattern-witness.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -16,11 +16,11 @@ LL ~         Foo { first: false, second: Some([1, 2, 3, 4]) } => (),\n LL +         Foo { first: false, second: Some([_, _, _, _]) } => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Red` not covered\n+error[E0004]: non-exhaustive patterns: `Color::Red` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:23:11\n    |\n LL |     match Color::Red {\n-   |           ^^^^^^^^^^ pattern `Red` not covered\n+   |           ^^^^^^^^^^ pattern `Color::Red` not covered\n    |\n note: `Color` defined here\n   --> $DIR/non-exhaustive-pattern-witness.rs:17:5\n@@ -33,14 +33,14 @@ LL |     Red,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         Color::Green => (),\n-LL +         Red => todo!()\n+LL +         Color::Red => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `East`, `South` and `West` not covered\n+error[E0004]: non-exhaustive patterns: `Direction::East`, `Direction::South` and `Direction::West` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:35:11\n    |\n LL |     match Direction::North {\n-   |           ^^^^^^^^^^^^^^^^ patterns `East`, `South` and `West` not covered\n+   |           ^^^^^^^^^^^^^^^^ patterns `Direction::East`, `Direction::South` and `Direction::West` not covered\n    |\n note: `Direction` defined here\n   --> $DIR/non-exhaustive-pattern-witness.rs:31:12\n@@ -56,14 +56,14 @@ LL |     North, East, South, West\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         Direction::North => (),\n-LL +         East | South | West => todo!()\n+LL +         Direction::East | Direction::South | Direction::West => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `Second`, `Third`, `Fourth` and 8 more not covered\n+error[E0004]: non-exhaustive patterns: `ExcessiveEnum::Second`, `ExcessiveEnum::Third`, `ExcessiveEnum::Fourth` and 8 more not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:46:11\n    |\n LL |     match ExcessiveEnum::First {\n-   |           ^^^^^^^^^^^^^^^^^^^^ patterns `Second`, `Third`, `Fourth` and 8 more not covered\n+   |           ^^^^^^^^^^^^^^^^^^^^ patterns `ExcessiveEnum::Second`, `ExcessiveEnum::Third`, `ExcessiveEnum::Fourth` and 8 more not covered\n    |\n note: `ExcessiveEnum` defined here\n   --> $DIR/non-exhaustive-pattern-witness.rs:41:6\n@@ -77,11 +77,11 @@ LL ~         ExcessiveEnum::First => (),\n LL +         _ => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `CustomRGBA { a: true, .. }` not covered\n+error[E0004]: non-exhaustive patterns: `Color::CustomRGBA { a: true, .. }` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:54:11\n    |\n LL |     match Color::Red {\n-   |           ^^^^^^^^^^ pattern `CustomRGBA { a: true, .. }` not covered\n+   |           ^^^^^^^^^^ pattern `Color::CustomRGBA { a: true, .. }` not covered\n    |\n note: `Color` defined here\n   --> $DIR/non-exhaustive-pattern-witness.rs:19:5\n@@ -95,20 +95,20 @@ LL |     CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         Color::CustomRGBA { a: false, r: _, g: _, b: _ } => (),\n-LL +         CustomRGBA { a: true, .. } => todo!()\n+LL +         Color::CustomRGBA { a: true, .. } => todo!()\n    |\n \n-error[E0004]: non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n+error[E0004]: non-exhaustive patterns: `[Enum::Second(true), Enum::Second(false)]` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:70:11\n    |\n LL |     match *x {\n-   |           ^^ pattern `[Second(true), Second(false)]` not covered\n+   |           ^^ pattern `[Enum::Second(true), Enum::Second(false)]` not covered\n    |\n    = note: the matched value is of type `[Enum]`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         [_, _, ref tail @ .., _] => (),\n-LL +         [Second(true), Second(false)] => todo!()\n+LL +         [Enum::Second(true), Enum::Second(false)] => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `((), false)` not covered"}, {"sha": "03db01160ddabe95e6936be4abd65cd3c079358e", "filename": "src/test/ui/pattern/usefulness/stable-gated-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -8,7 +8,7 @@ fn main() {\n     match UnstableEnum::Stable {\n         UnstableEnum::Stable => {}\n     }\n-    //~^^^ non-exhaustive patterns: `Stable2` and `_` not covered\n+    //~^^^ non-exhaustive patterns: `UnstableEnum::Stable2` and `_` not covered\n \n     match UnstableEnum::Stable {\n         UnstableEnum::Stable => {}"}, {"sha": "7b8588a3c73509c7ae0ef416324437757ee7222d", "filename": "src/test/ui/pattern/usefulness/stable-gated-patterns.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `Stable2` and `_` not covered\n+error[E0004]: non-exhaustive patterns: `UnstableEnum::Stable2` and `_` not covered\n   --> $DIR/stable-gated-patterns.rs:8:11\n    |\n LL |     match UnstableEnum::Stable {\n-   |           ^^^^^^^^^^^^^^^^^^^^ patterns `Stable2` and `_` not covered\n+   |           ^^^^^^^^^^^^^^^^^^^^ patterns `UnstableEnum::Stable2` and `_` not covered\n    |\n note: `UnstableEnum` defined here\n   --> $DIR/auxiliary/unstable.rs:9:5\n@@ -16,7 +16,7 @@ LL |     Stable2,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~         UnstableEnum::Stable => {}\n-LL +         Stable2 | _ => todo!()\n+LL +         UnstableEnum::Stable2 | _ => todo!()\n    |\n \n error[E0004]: non-exhaustive patterns: `_` not covered"}, {"sha": "85c97be29d6d795ff270410f938569763fdfd410", "filename": "src/test/ui/pattern/usefulness/struct-like-enum-nonexhaustive.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `B { x: Some(_) }` not covered\n+error[E0004]: non-exhaustive patterns: `A::B { x: Some(_) }` not covered\n   --> $DIR/struct-like-enum-nonexhaustive.rs:8:11\n    |\n LL |     match x {\n-   |           ^ pattern `B { x: Some(_) }` not covered\n+   |           ^ pattern `A::B { x: Some(_) }` not covered\n    |\n note: `A` defined here\n   --> $DIR/struct-like-enum-nonexhaustive.rs:2:5\n@@ -15,7 +15,7 @@ LL |     B { x: Option<isize> },\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         A::B { x: None } => {}\n-LL +         B { x: Some(_) } => todo!()\n+LL +         A::B { x: Some(_) } => todo!()\n    |\n \n error: aborting due to previous error"}, {"sha": "7046555e0d2f0deaed16b9ba9c48a72152beb33a", "filename": "src/test/ui/pattern/usefulness/unstable-gated-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -11,7 +11,7 @@ fn main() {\n         UnstableEnum::Stable => {}\n         UnstableEnum::Stable2 => {}\n     }\n-    //~^^^^ non-exhaustive patterns: `Unstable` not covered\n+    //~^^^^ non-exhaustive patterns: `UnstableEnum::Unstable` not covered\n \n     // Ok: all variants are explicitly matched\n     match UnstableEnum::Stable {"}, {"sha": "6dc9a4058398569a1f37af2f8e72cd045eca1153", "filename": "src/test/ui/pattern/usefulness/unstable-gated-patterns.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `Unstable` not covered\n+error[E0004]: non-exhaustive patterns: `UnstableEnum::Unstable` not covered\n   --> $DIR/unstable-gated-patterns.rs:10:11\n    |\n LL |     match UnstableEnum::Stable {\n-   |           ^^^^^^^^^^^^^^^^^^^^ pattern `Unstable` not covered\n+   |           ^^^^^^^^^^^^^^^^^^^^ pattern `UnstableEnum::Unstable` not covered\n    |\n note: `UnstableEnum` defined here\n   --> $DIR/auxiliary/unstable.rs:11:5\n@@ -16,7 +16,7 @@ LL |     Unstable,\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |\n LL ~         UnstableEnum::Stable2 => {}\n-LL +         Unstable => todo!()\n+LL +         UnstableEnum::Unstable => todo!()\n    |\n \n error: aborting due to previous error"}, {"sha": "69a283c31633d7ae27fd39f02436a1acd8e85f7e", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -31,7 +31,7 @@ fn empty_non_exhaustive(x: EmptyNonExhaustiveEnum) {\n \n fn main() {\n     match NonExhaustiveEnum::Unit {}\n-    //~^ ERROR `Unit`, `Tuple(_)` and `Struct { .. }` not covered [E0004]\n+    //~^ ERROR `NonExhaustiveEnum::Unit`, `NonExhaustiveEnum::Tuple(_)` and `NonExhaustiveEnum::Struct { .. }` not covered [E0004]\n     match NormalEnum::Unit {}\n-    //~^ ERROR `Unit`, `Tuple(_)` and `Struct { .. }` not covered [E0004]\n+    //~^ ERROR `NormalEnum::Unit`, `NormalEnum::Tuple(_)` and `NormalEnum::Struct { .. }` not covered [E0004]\n }"}, {"sha": "de1bf8be8854ec31cd3b9dc4e6b9a1d278ac3b5a", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -10,11 +10,11 @@ note: the lint level is defined here\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+error[E0004]: non-exhaustive patterns: `NonExhaustiveEnum::Unit`, `NonExhaustiveEnum::Tuple(_)` and `NonExhaustiveEnum::Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:33:11\n    |\n LL |     match NonExhaustiveEnum::Unit {}\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^ patterns `NonExhaustiveEnum::Unit`, `NonExhaustiveEnum::Tuple(_)` and `NonExhaustiveEnum::Struct { .. }` not covered\n    |\n note: `NonExhaustiveEnum` defined here\n   --> $DIR/enum_same_crate_empty_match.rs:5:5\n@@ -33,15 +33,15 @@ LL |     Struct { field: u32 }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~     match NonExhaustiveEnum::Unit {\n-LL +         Unit | Tuple(_) | Struct { .. } => todo!(),\n+LL +         NonExhaustiveEnum::Unit | NonExhaustiveEnum::Tuple(_) | NonExhaustiveEnum::Struct { .. } => todo!(),\n LL +     }\n    |\n \n-error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+error[E0004]: non-exhaustive patterns: `NormalEnum::Unit`, `NormalEnum::Tuple(_)` and `NormalEnum::Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:35:11\n    |\n LL |     match NormalEnum::Unit {}\n-   |           ^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+   |           ^^^^^^^^^^^^^^^^ patterns `NormalEnum::Unit`, `NormalEnum::Tuple(_)` and `NormalEnum::Struct { .. }` not covered\n    |\n note: `NormalEnum` defined here\n   --> $DIR/enum_same_crate_empty_match.rs:14:5\n@@ -60,7 +60,7 @@ LL |     Struct { field: u32 }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~     match NormalEnum::Unit {\n-LL +         Unit | Tuple(_) | Struct { .. } => todo!(),\n+LL +         NormalEnum::Unit | NormalEnum::Tuple(_) | NormalEnum::Struct { .. } => todo!(),\n LL +     }\n    |\n "}, {"sha": "4b9f8564d2370cbd56c9ad7b78ac258b1cea4dd7", "filename": "src/test/ui/rfc-2008-non-exhaustive/omitted-patterns.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fomitted-patterns.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -81,7 +81,7 @@ error: some variants are not matched explicitly\n   --> $DIR/omitted-patterns.rs:58:9\n    |\n LL |         _ => {}\n-   |         ^ pattern `Struct { .. }` not covered\n+   |         ^ pattern `NonExhaustiveEnum::Struct { .. }` not covered\n    |\n note: the lint level is defined here\n   --> $DIR/omitted-patterns.rs:57:16\n@@ -95,7 +95,7 @@ error: some variants are not matched explicitly\n   --> $DIR/omitted-patterns.rs:65:9\n    |\n LL |         _ => {}\n-   |         ^ pattern `Tuple(_)` not covered\n+   |         ^ pattern `NonExhaustiveEnum::Tuple(_)` not covered\n    |\n note: the lint level is defined here\n   --> $DIR/omitted-patterns.rs:64:16\n@@ -109,7 +109,7 @@ error: some variants are not matched explicitly\n   --> $DIR/omitted-patterns.rs:75:9\n    |\n LL |         _ => {}\n-   |         ^ pattern `Unit` not covered\n+   |         ^ pattern `NonExhaustiveEnum::Unit` not covered\n    |\n note: the lint level is defined here\n   --> $DIR/omitted-patterns.rs:74:16\n@@ -123,7 +123,7 @@ error: some variants are not matched explicitly\n   --> $DIR/omitted-patterns.rs:92:32\n    |\n LL |         NestedNonExhaustive::A(_) => {}\n-   |                                ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   |                                ^ patterns `NonExhaustiveEnum::Tuple(_)` and `NonExhaustiveEnum::Struct { .. }` not covered\n    |\n note: the lint level is defined here\n   --> $DIR/omitted-patterns.rs:89:12\n@@ -137,7 +137,7 @@ error: some variants are not matched explicitly\n   --> $DIR/omitted-patterns.rs:94:9\n    |\n LL |         _ => {}\n-   |         ^ pattern `C` not covered\n+   |         ^ pattern `NestedNonExhaustive::C` not covered\n    |\n    = help: ensure that all variants are matched explicitly by adding the suggested match arms\n    = note: the matched value is of type `NestedNonExhaustive` and the `non_exhaustive_omitted_patterns` attribute was found\n@@ -146,7 +146,7 @@ error: some variants are not matched explicitly\n   --> $DIR/omitted-patterns.rs:132:9\n    |\n LL |         _ => {}\n-   |         ^ pattern `A(_)` not covered\n+   |         ^ pattern `NonExhaustiveSingleVariant::A(_)` not covered\n    |\n note: the lint level is defined here\n   --> $DIR/omitted-patterns.rs:130:12\n@@ -160,7 +160,7 @@ error: some variants are not matched explicitly\n   --> $DIR/omitted-patterns.rs:144:9\n    |\n LL |         _ => {}\n-   |         ^ pattern `Unstable` not covered\n+   |         ^ pattern `UnstableEnum::Unstable` not covered\n    |\n note: the lint level is defined here\n   --> $DIR/omitted-patterns.rs:143:16\n@@ -174,7 +174,7 @@ error: some variants are not matched explicitly\n   --> $DIR/omitted-patterns.rs:168:9\n    |\n LL |         _ => {}\n-   |         ^ pattern `Unstable2` not covered\n+   |         ^ pattern `OnlyUnstableEnum::Unstable2` not covered\n    |\n note: the lint level is defined here\n   --> $DIR/omitted-patterns.rs:165:12"}, {"sha": "533e8abf2d68acd5850ac3bb5723c5a40c2890c0", "filename": "src/test/ui/rfc-2008-non-exhaustive/stable-omitted-patterns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstable-omitted-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstable-omitted-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstable-omitted-patterns.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -16,7 +16,7 @@ error: some variants are not matched explicitly\n   --> $DIR/stable-omitted-patterns.rs:23:9\n    |\n LL |         _ => {}\n-   |         ^ pattern `Stable2` not covered\n+   |         ^ pattern `UnstableEnum::Stable2` not covered\n    |\n note: the lint level is defined here\n   --> $DIR/stable-omitted-patterns.rs:22:16"}, {"sha": "a9c54af0418a5ce2ca1306678114218a9a491f67", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -55,11 +55,11 @@ LL +         _ => todo!(),\n LL ~     }\n    |\n \n-error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n+error[E0004]: non-exhaustive patterns: `UninhabitedVariants::Tuple(_)` and `UninhabitedVariants::Struct { .. }` not covered\n   --> $DIR/match.rs:31:11\n    |\n LL |     match x {}\n-   |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   |           ^ patterns `UninhabitedVariants::Tuple(_)` and `UninhabitedVariants::Struct { .. }` not covered\n    |\n note: `UninhabitedVariants` defined here\n   --> $DIR/auxiliary/uninhabited.rs:17:23\n@@ -74,7 +74,7 @@ LL |     #[non_exhaustive] Struct { x: ! }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~     match x {\n-LL +         Tuple(_) | Struct { .. } => todo!(),\n+LL +         UninhabitedVariants::Tuple(_) | UninhabitedVariants::Struct { .. } => todo!(),\n LL ~     }\n    |\n "}, {"sha": "ec2a2f6f05531f4b792373fcdf707d1db7837238", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -36,11 +36,11 @@ LL +         _ => todo!(),\n LL ~     }\n    |\n \n-error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n+error[E0004]: non-exhaustive patterns: `UninhabitedVariants::Tuple(_)` and `UninhabitedVariants::Struct { .. }` not covered\n   --> $DIR/match_same_crate.rs:38:11\n    |\n LL |     match x {}\n-   |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   |           ^ patterns `UninhabitedVariants::Tuple(_)` and `UninhabitedVariants::Struct { .. }` not covered\n    |\n note: `UninhabitedVariants` defined here\n   --> $DIR/match_same_crate.rs:16:23\n@@ -55,7 +55,7 @@ LL |     #[non_exhaustive] Struct { x: ! }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~     match x {\n-LL +         Tuple(_) | Struct { .. } => todo!(),\n+LL +         UninhabitedVariants::Tuple(_) | UninhabitedVariants::Struct { .. } => todo!(),\n LL ~     }\n    |\n "}, {"sha": "b6b777ec56c43579d8fbc0527ca64484a346f97c", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -55,11 +55,11 @@ LL +         _ => todo!(),\n LL ~     }\n    |\n \n-error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n+error[E0004]: non-exhaustive patterns: `UninhabitedVariants::Tuple(_)` and `UninhabitedVariants::Struct { .. }` not covered\n   --> $DIR/match_with_exhaustive_patterns.rs:34:11\n    |\n LL |     match x {}\n-   |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   |           ^ patterns `UninhabitedVariants::Tuple(_)` and `UninhabitedVariants::Struct { .. }` not covered\n    |\n note: `UninhabitedVariants` defined here\n   --> $DIR/auxiliary/uninhabited.rs:17:23\n@@ -74,7 +74,7 @@ LL |     #[non_exhaustive] Struct { x: ! }\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |\n LL ~     match x {\n-LL +         Tuple(_) | Struct { .. } => todo!(),\n+LL +         UninhabitedVariants::Tuple(_) | UninhabitedVariants::Struct { .. } => todo!(),\n LL ~     }\n    |\n "}, {"sha": "e5d2ead6ad67cd61d3d8614b923f9dfe8929409d", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature-2.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -22,8 +22,8 @@ LL | |     });\n    | |______^\n help: consider adding an explicit lifetime bound...\n    |\n-LL | fn func<T: Test + 'a>(foo: &Foo, t: T) {\n-   |                 ++++\n+LL | fn func<'a, T: Test + 'a>(foo: &Foo, t: T) {\n+   |         +++         ++++\n \n error: aborting due to previous error\n "}, {"sha": "ed1b91676a2145ab7923a72c6e25a9956e0cf12b", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -47,8 +47,10 @@ LL | |     }\n    | |_____^\n help: consider adding an explicit lifetime bound...\n    |\n-LL |     G: Get<T> + 'a,\n-   |               ++++\n+LL ~ fn bar<'a, G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | where\n+LL ~     G: Get<T> + 'a,\n+   |\n \n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:52:5\n@@ -74,8 +76,8 @@ LL | |     }\n    | |_____^\n help: consider adding an explicit lifetime bound...\n    |\n-LL | fn qux<'a, G: 'a + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |                  ++++\n+LL | fn qux<'b, 'a, G: 'a + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |        +++           ++++\n \n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:61:9\n@@ -101,8 +103,8 @@ LL | |         }\n    | |_________^\n help: consider adding an explicit lifetime bound...\n    |\n-LL |     fn qux<'b, G: Get<T> + 'b + 'c, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n-   |                               ++++\n+LL |     fn qux<'c, 'b, G: Get<T> + 'b + 'c, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |            +++                    ++++\n \n error[E0311]: the parameter type `G` may not live long enough\n   --> $DIR/missing-lifetimes-in-signature.rs:73:5\n@@ -130,8 +132,8 @@ LL | |     }\n    | |_____^\n help: consider adding an explicit lifetime bound...\n    |\n-LL | fn bat<'a, G: 'a + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-   |                  ++++\n+LL | fn bat<'b, 'a, G: 'a + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |        +++           ++++\n \n error[E0621]: explicit lifetime required in the type of `dest`\n   --> $DIR/missing-lifetimes-in-signature.rs:73:5"}, {"sha": "1a0f3c5e5504a8be198cf0a8fdb4c637c1e0be28", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -24,5 +24,5 @@ enum Foo {\n \n fn main() {\n     let x: Foo = Foo::D(123, 456);\n-    let Foo::D(_y, _z) = x; //~ ERROR refutable pattern in local binding: `A(_)` not covered\n+    let Foo::D(_y, _z) = x; //~ ERROR refutable pattern in local binding: `Foo::A(_)` not covered\n }"}, {"sha": "feeaa89e76f11eacd6bfe80aeeb29b2df7891e8e", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78a891d364a7358ed9eb9c93099ba2f3e6817ca6/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=78a891d364a7358ed9eb9c93099ba2f3e6817ca6", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `A(_)` not covered\n+error[E0005]: refutable pattern in local binding: `Foo::A(_)` not covered\n   --> $DIR/uninhabited-irrefutable.rs:27:9\n    |\n LL |     let Foo::D(_y, _z) = x;\n-   |         ^^^^^^^^^^^^^^ pattern `A(_)` not covered\n+   |         ^^^^^^^^^^^^^^ pattern `Foo::A(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}]}