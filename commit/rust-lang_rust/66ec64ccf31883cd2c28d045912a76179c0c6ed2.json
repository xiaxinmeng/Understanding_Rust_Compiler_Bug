{"sha": "66ec64ccf31883cd2c28d045912a76179c0c6ed2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZWM2NGNjZjMxODgzY2QyYzI4ZDA0NTkxMmE3NjE3OWMwYzZlZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-07T02:36:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-07T02:36:07Z"}, "message": "Auto merge of #82851 - JohnTitor:rollup-me5ko8g, r=JohnTitor\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #77916 (Change built-in kernel targets to be os = none throughout)\n - #82130 (Make some Option, Result methods unstably const)\n - #82292 (Prevent specialized ZipImpl from calling `__iterator_get_unchecked` twice with the same index)\n - #82402 (Remove RefCell around `module_trait_cache`)\n - #82592 (Improve transmute docs with further clarifications)\n - #82651 (Cleanup rustdoc warnings)\n - #82720 (Fix diagnostic suggests adding type `[type error]`)\n - #82751 (improve offset_from docs)\n - #82793 (Move some tests to more suitable subdirs)\n - #82803 (rustdoc: Add an unstable option to print all unversioned files)\n - #82808 (Sync rustc_codegen_cranelift)\n - #82822 (Fix typo)\n - #82837 (tweak MaybeUninit docs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c91086d0e3c6cff3ed331adc66931e17281701f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c91086d0e3c6cff3ed331adc66931e17281701f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66ec64ccf31883cd2c28d045912a76179c0c6ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66ec64ccf31883cd2c28d045912a76179c0c6ed2", "html_url": "https://github.com/rust-lang/rust/commit/66ec64ccf31883cd2c28d045912a76179c0c6ed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66ec64ccf31883cd2c28d045912a76179c0c6ed2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfe519b344b60e54a2028d3366ca366a228537e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe519b344b60e54a2028d3366ca366a228537e3", "html_url": "https://github.com/rust-lang/rust/commit/dfe519b344b60e54a2028d3366ca366a228537e3"}, {"sha": "6220e00ea9a790fb83cf391e2093c260db6d47a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6220e00ea9a790fb83cf391e2093c260db6d47a1", "html_url": "https://github.com/rust-lang/rust/commit/6220e00ea9a790fb83cf391e2093c260db6d47a1"}], "stats": {"total": 4336, "additions": 1500, "deletions": 2836}, "files": [{"sha": "0151973eccfda22e2695791e5fa8f6adc91df0e4", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     // Note that we're pulling in a static copy of jemalloc which means that to\n     // pull it in we need to actually reference its symbols for it to get\n     // linked. The two crates we link to here, std and rustc_driver, are both\n-    // dynamic libraries. That means to pull in jemalloc we need to actually\n+    // dynamic libraries. That means to pull in jemalloc we actually need to\n     // reference allocation symbols one way or another (as this file is the only\n     // object code in the rustc executable).\n     #[cfg(feature = \"jemalloc-sys\")]"}, {"sha": "e173df423a76523f092160e138d648ea64c29651", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -0,0 +1,25 @@\n+task:\n+  name: freebsd\n+  freebsd_instance:\n+    image: freebsd-12-1-release-amd64\n+  setup_rust_script:\n+    - pkg install -y curl git bash\n+    - curl https://sh.rustup.rs -sSf --output rustup.sh\n+    - sh rustup.sh --default-toolchain none -y --profile=minimal\n+  cargo_bin_cache:\n+    folder: ~/.cargo/bin\n+  target_cache:\n+    folder: target\n+  prepare_script:\n+    - . $HOME/.cargo/env\n+    - git config --global user.email \"user@example.com\"\n+    - git config --global user.name \"User\"\n+    - ./prepare.sh\n+  test_script:\n+    - . $HOME/.cargo/env\n+    - # Enable backtraces for easier debugging\n+    - export RUST_BACKTRACE=1\n+    - # Reduce amount of benchmark runs as they are slow\n+    - export COMPILE_RUNS=2\n+    - export RUN_RUNS=2\n+    - ./test.sh"}, {"sha": "e6d3375fb1bab6240d6d309259aa84657547a559", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -12,9 +12,6 @@ jobs:\n       fail-fast: false\n       matrix:\n         os: [ubuntu-latest, macos-latest]\n-        env:\n-          - BACKEND: \"\"\n-          - BACKEND: --oldbe\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -54,7 +51,7 @@ jobs:\n         export COMPILE_RUNS=2\n         export RUN_RUNS=2\n \n-        ./test.sh $BACKEND\n+        ./test.sh\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build"}, {"sha": "a13d5931ffa894099e1faee735dbc902244e86fe", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,6 +1,6 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n-    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n+    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"macro-error\"],\n     \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n     \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n     \"rust-analyzer.linkedProjects\": ["}, {"sha": "76d9f0d27ce461a143b28f36e83b161093f1485f", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 41, "deletions": 87, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,5 +1,7 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.38\"\n@@ -29,18 +31,6 @@ version = \"1.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ae44d1a3d5a19df61dd0c8beb138458ac2a53a7ac09eba97d55592540004306b\"\n \n-[[package]]\n-name = \"cc\"\n-version = \"1.0.66\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n-\n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n@@ -49,16 +39,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -75,27 +65,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -105,8 +95,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -123,8 +113,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -135,18 +125,17 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"cranelift-codegen\",\n- \"raw-cpuid\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -162,7 +151,7 @@ version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"81156fece84ab6a9f2afdb109ce3ae577e42b1228441eded99bd77f627953b1a\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -219,27 +208,27 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.82\"\n+version = \"0.2.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"89203f3fba0a3795506acaad8ebce3c80c0af93f994d5a1d7a0b1eeb23271929\"\n+checksum = \"b7282d924be3275cec7f6756ff4121987bc6481325397dde6ba3e7802b1a8b1c\"\n \n [[package]]\n name = \"libloading\"\n version = \"0.6.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"351a32417a12d5f7e82c368a66781e307834dae04c6ce0cd4456d52989229883\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"log\"\n-version = \"0.4.13\"\n+version = \"0.4.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fcf3805d4480bb5b86070dcfeb9e2cb2ebc148adb753c5cca5f884d1d65a42b2\"\n+checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -253,9 +242,9 @@ dependencies = [\n \n [[package]]\n name = \"object\"\n-version = \"0.22.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d3b63360ec3cb337817c2dbd47ab4a0f170d285d8e5a2064600f3def1402397\"\n+checksum = \"a9a7ab5d64814df0fe4a4b5ead45ed6c5f181ee3ff04ba344313a6c80446c5d4\"\n dependencies = [\n  \"crc32fast\",\n  \"indexmap\",\n@@ -272,24 +261,13 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.8\"\n+version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"991431c3519a3f36861882da93630ce66b52918dcf1b8e2fd66b397fc96f28df\"\n+checksum = \"c3d0b9745dc2debf507c8422de05d7226cc1f0644216dfdfead988f9b1ab32a7\"\n dependencies = [\n  \"proc-macro2\",\n ]\n \n-[[package]]\n-name = \"raw-cpuid\"\n-version = \"8.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fdf7d9dbd43f3d81d94a49c1c3df73cc2b3827995147e6cf7f89d4ec5483e73\"\n-dependencies = [\n- \"bitflags\",\n- \"cc\",\n- \"rustc_version\",\n-]\n-\n [[package]]\n name = \"regalloc\"\n version = \"0.0.31\"\n@@ -337,30 +315,6 @@ dependencies = [\n  \"target-lexicon\",\n ]\n \n-[[package]]\n-name = \"rustc_version\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n-dependencies = [\n- \"semver\",\n-]\n-\n-[[package]]\n-name = \"semver\"\n-version = \"0.9.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n-dependencies = [\n- \"semver-parser\",\n-]\n-\n-[[package]]\n-name = \"semver-parser\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\n [[package]]\n name = \"smallvec\"\n version = \"1.6.1\"\n@@ -369,9 +323,9 @@ checksum = \"fe0f37c9e8f3c5a4a66ad655a93c74daac4ad00c441533bf5c6e7990bb42604e\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.58\"\n+version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc60a3d73ea6594cd712d830cc1f0390fd71542d8c8cd24e70cc54cdfd5e05d5\"\n+checksum = \"c700597eca8a5a762beb35753ef6b94df201c81cca676604f547495a0d7f0081\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -380,24 +334,24 @@ dependencies = [\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.11.1\"\n+version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ee5a98e506fb7231a304c3a1bd7c132a55016cf65001e0282480665870dfcb9\"\n+checksum = \"422045212ea98508ae3d28025bc5aaa2bd4a9cdaecd442a08da2ee620ee9ea95\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.23\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"76cc616c6abf8c8928e2fdcc0dbfab37175edd8fb49a4641066ad1364fdab146\"\n+checksum = \"e0f4a65597094d4483ddaed134f409b2cb7c1beccf25201a9f73c719254fa98e\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.23\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9be73a2caec27583d0046ef3796c3794f868a5bc813db689eed00c7631275cd1\"\n+checksum = \"7765189610d8241a44529806d6fd1f2e0a08734313a35d5b3a556f92b381f3c0\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "9861af1f8eae2cfb384cbaee7ad709937835465a", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -9,14 +9,14 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x86\", \"x64\"] }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x64\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n target-lexicon = \"0.11.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.22.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.23.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n@@ -38,7 +38,6 @@ smallvec = \"1.6.1\"\n default = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n-oldbe = []\n \n [profile.dev]\n # By compiling dependencies with optimizations, performing tests gets much faster."}, {"sha": "090349e54b1484a33856b7e18e39179318ef973c", "filename": "compiler/rustc_codegen_cranelift/build.sh", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,11 +1,10 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n # Settings\n export CHANNEL=\"release\"\n build_sysroot=\"clif\"\n target_dir='build'\n-oldbe=''\n while [[ $# != 0 ]]; do\n     case $1 in\n         \"--debug\")\n@@ -19,12 +18,9 @@ while [[ $# != 0 ]]; do\n             target_dir=$2\n             shift\n             ;;\n-        \"--oldbe\")\n-            oldbe='--features oldbe'\n-            ;;\n         *)\n             echo \"Unknown flag '$1'\"\n-            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--oldbe]\"\n+            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR]\"\n             exit 1\n             ;;\n     esac\n@@ -34,19 +30,19 @@ done\n # Build cg_clif\n unset CARGO_TARGET_DIR\n unamestr=$(uname)\n-if [[ \"$unamestr\" == 'Linux' ]]; then\n+if [[ \"$unamestr\" == 'Linux' || \"$unamestr\" == \"FreeBSD\" ]]; then\n    export RUSTFLAGS='-Clink-arg=-Wl,-rpath=$ORIGIN/../lib '$RUSTFLAGS\n elif [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS='-Csplit-debuginfo=unpacked -Clink-arg=-Wl,-rpath,@loader_path/../lib -Zosx-rpath-install-name '$RUSTFLAGS\n    dylib_ext='dylib'\n else\n-   echo \"Unsupported os\"\n+   echo \"Unsupported os $unamestr\"\n    exit 1\n fi\n if [[ \"$CHANNEL\" == \"release\" ]]; then\n-    cargo build $oldbe --release\n+    cargo build --release\n else\n-    cargo build $oldbe\n+    cargo build\n fi\n \n source scripts/ext_config.sh"}, {"sha": "a7650ab995b0fa4466619d9d28d27345b940f9f8", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,5 +1,7 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"addr2line\"\n version = \"0.14.1\"\n@@ -30,15 +32,6 @@ dependencies = [\n  \"core\",\n ]\n \n-[[package]]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"core\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"autocfg\"\n version = \"1.0.1\"\n@@ -47,9 +40,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.66\"\n+version = \"1.0.67\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n+checksum = \"e3c69b077ad434294d3ce9f1f6143a2a4b89a8a2d54ef813d85003a4fd1137fd\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -139,9 +132,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.84\"\n+version = \"0.2.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cca32fa0182e8c0989459524dc356b8f2b5c10f1b9eb521b7d182c03cf8c5ff\"\n+checksum = \"b7282d924be3275cec7f6756ff4121987bc6481325397dde6ba3e7802b1a8b1c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -258,7 +251,6 @@ name = \"sysroot\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"alloc_system\",\n  \"compiler_builtins\",\n  \"core\",\n  \"std\","}, {"sha": "04748d5dbab5951df6ef16995fccdc0f13f2f809", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -9,8 +9,6 @@ alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n-alloc_system = { path = \"./alloc_system\" }\n-\n compiler_builtins = { version = \"0.1.39\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]"}, {"sha": "9fffca843006fa1d936640f1f4280452ef6e8f7e", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfe519b344b60e54a2028d3366ca366a228537e3/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dfe519b344b60e54a2028d3366ca366a228537e3/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml?ref=dfe519b344b60e54a2028d3366ca366a228537e3", "patch": "@@ -1,13 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\", \"bjorn3 (edited to be usable outside the rust source)\"]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-[lib]\n-name = \"alloc_system\"\n-path = \"lib.rs\"\n-test = false\n-doc = false\n-[dependencies]\n-core = { path = \"../sysroot_src/library/core\" }\n-libc = { version = \"0.2.43\", features = ['rustc-dep-of-std'], default-features = false }\n-compiler_builtins = \"0.1\""}, {"sha": "636aa5f3f3dc2d1793f27270e3f270353e7b8f54", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n # Requires the CHANNEL env var to be set to `debug` or `release.`\n "}, {"sha": "c90205db0fbd067af3c33691164486277ddc1b56", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n cd \"$(dirname \"$0\")\"\n \n@@ -33,7 +33,7 @@ git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/\n pushd compiler-builtins\n git checkout -- .\n git checkout 0.1.39\n-git apply ../../crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch\n+git apply ../../crate_patches/000*-compiler-builtins-*.patch\n popd\n \n echo \"Successfully prepared sysroot source for building\""}, {"sha": "a7bbeb05cac5a094bc0103d5f676452cef77f8a5", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n \n rm -rf target/ build/ build_sysroot/{sysroot_src/,target/,compiler-builtins/} perf.data{,.old}"}, {"sha": "7daea99f5794d2103588c152a0ac02ca1b5b14b1", "filename": "compiler/rustc_codegen_cranelift/crate_patches/0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -0,0 +1,48 @@\n+From 1d574bf5e32d51641dcacaf8ef777e95b44f6f2a Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:30:55 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ src/mem/mod.rs | 12 ------------\n+ 1 file changed, 12 deletions(-)\n+\n+diff --git a/src/mem/mod.rs b/src/mem/mod.rs\n+index 107762c..2d1ae10 100644\n+--- a/src/mem/mod.rs\n++++ b/src/mem/mod.rs\n+@@ -137,10 +137,6 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+         memcpy_element_unordered_atomic(dest, src, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-        memcpy_element_unordered_atomic(dest, src, bytes);\n+-    }\n+ \n+     #[cfg(target_has_atomic_load_store = \"8\")]\n+     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_1(dest: *mut u8, src: *const u8, bytes: usize) -> () {\n+@@ -158,10 +154,6 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+         memmove_element_unordered_atomic(dest, src, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-        memmove_element_unordered_atomic(dest, src, bytes);\n+-    }\n+ \n+     #[cfg(target_has_atomic_load_store = \"8\")]\n+     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_1(s: *mut u8, c: u8, bytes: usize) -> () {\n+@@ -179,8 +171,4 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_8(s: *mut u64, c: u8, bytes: usize) -> () {\n+         memset_element_unordered_atomic(s, c, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memset_element_unordered_atomic_16(s: *mut u128, c: u8, bytes: usize) -> () {\n+-        memset_element_unordered_atomic(s, c, bytes);\n+-    }\n+ }\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "71e93e87b6c4135c4d180cedeac7be72f64fabe7", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, alloc_system, core_intrinsics, alloc_prelude, alloc_error_handler)]\n+#![feature(start, box_syntax, core_intrinsics, alloc_prelude, alloc_error_handler)]\n #![no_std]\n \n extern crate alloc;"}, {"sha": "5f66ca67f2d409e9699c49a9fcda047c1e8c6ca9", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "renamed", "additions": 3, "deletions": 133, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -8,66 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![no_std]\n-#![allow(unused_attributes)]\n-#![unstable(feature = \"alloc_system\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"32838\")]\n-#![feature(allocator_api)]\n-#![feature(core_intrinsics)]\n-#![feature(nll)]\n-#![feature(staged_api)]\n-#![feature(rustc_attrs)]\n-#![feature(alloc_layout_extra)]\n-#![cfg_attr(\n-    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-    feature(integer_atomics, stdsimd)\n-)]\n+#![feature(allocator_api, rustc_private)]\n #![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n+\n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values.\n #[cfg(all(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n               target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"asmjs\",\n-              target_arch = \"wasm32\")))]\n-#[allow(dead_code)]\n+              target_arch = \"powerpc64\")))]\n const MIN_ALIGN: usize = 8;\n #[cfg(all(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n               target_arch = \"mips64\",\n               target_arch = \"s390x\",\n               target_arch = \"sparc64\")))]\n-#[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-/// The default memory allocator provided by the operating system.\n-///\n-/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n-/// plus related functions.\n-///\n-/// This type can be used in a `static` item\n-/// with the `#[global_allocator]` attribute\n-/// to force the global allocator to be the system\u2019s one.\n-/// (The default is jemalloc for executables, on some platforms.)\n-///\n-/// ```rust\n-/// use std::alloc::System;\n-///\n-/// #[global_allocator]\n-/// static A: System = System;\n-///\n-/// fn main() {\n-///     let a = Box::new(4); // Allocates from the system allocator.\n-///     println!(\"{}\", a);\n-/// }\n-/// ```\n-///\n-/// It can also be used directly to allocate memory\n-/// independently of the standard library\u2019s global allocator.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n pub struct System;\n #[cfg(any(windows, unix, target_os = \"redox\"))]\n mod realloc_fallback {\n@@ -96,7 +54,6 @@ mod platform {\n     use MIN_ALIGN;\n     use System;\n     use core::alloc::{GlobalAlloc, Layout};\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n         unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n@@ -221,7 +178,6 @@ mod platform {\n         };\n         ptr as *mut u8\n     }\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n         unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n@@ -254,89 +210,3 @@ mod platform {\n         }\n     }\n }\n-// This is an implementation of a global allocator on the wasm32 platform when\n-// emscripten is not in use. In that situation there's no actual runtime for us\n-// to lean on for allocation, so instead we provide our own!\n-//\n-// The wasm32 instruction set has two instructions for getting the current\n-// amount of memory and growing the amount of memory. These instructions are the\n-// foundation on which we're able to build an allocator, so we do so! Note that\n-// the instructions are also pretty \"global\" and this is the \"global\" allocator\n-// after all!\n-//\n-// The current allocator here is the `dlmalloc` crate which we've got included\n-// in the rust-lang/rust repository as a submodule. The crate is a port of\n-// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n-// for now which is currently technically required (can't link with C yet).\n-//\n-// The crate itself provides a global allocator which on wasm has no\n-// synchronization as there are no threads!\n-#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n-mod platform {\n-    extern crate dlmalloc;\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use System;\n-    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.malloc(layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.calloc(layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            let _lock = lock::lock();\n-            DLMALLOC.free(ptr, layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n-        }\n-    }\n-    #[cfg(target_feature = \"atomics\")]\n-    mod lock {\n-        use core::arch::wasm32;\n-        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n-        static LOCKED: AtomicI32 = AtomicI32::new(0);\n-        pub struct DropLock;\n-        pub fn lock() -> DropLock {\n-            loop {\n-                if LOCKED.swap(1, SeqCst) == 0 {\n-                    return DropLock\n-                }\n-                unsafe {\n-                    let r = wasm32::atomic::wait_i32(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1,  // expected value\n-                        -1, // timeout\n-                    );\n-                    debug_assert!(r == 0 || r == 1);\n-                }\n-            }\n-        }\n-        impl Drop for DropLock {\n-            fn drop(&mut self) {\n-                let r = LOCKED.swap(0, SeqCst);\n-                debug_assert_eq!(r, 1);\n-                unsafe {\n-                    wasm32::atomic::wake(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1, // only one thread\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(target_feature = \"atomics\"))]\n-    mod lock {\n-        #[inline]\n-        pub fn lock() {} // no atomics, no threads, that's easy!\n-    }\n-}", "previous_filename": "compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/lib.rs"}, {"sha": "ddeb752f93ed71257d6dd2e39d33b372416eca1a", "filename": "compiler/rustc_codegen_cranelift/example/arbitrary_self_types_pointers_and_wrappers.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,22 +1,12 @@\n // Adapted from rustc run-pass test suite\n \n-#![feature(no_core, arbitrary_self_types, box_syntax)]\n+#![feature(arbitrary_self_types, unsize, coerce_unsized, dispatch_from_dyn)]\n #![feature(rustc_attrs)]\n \n-#![feature(start, lang_items)]\n-#![no_core]\n-\n-extern crate mini_core;\n-\n-use mini_core::*;\n-\n-macro_rules! assert_eq {\n-    ($l:expr, $r: expr) => {\n-        if $l != $r {\n-            panic(stringify!($l != $r));\n-        }\n-    }\n-}\n+use std::{\n+    ops::{Deref, CoerceUnsized, DispatchFromDyn},\n+    marker::Unsize,\n+};\n \n struct Ptr<T: ?Sized>(Box<T>);\n \n@@ -67,16 +57,13 @@ impl Trait for i32 {\n     }\n }\n \n-#[start]\n-fn main(_: isize, _: *const *const u8) -> isize {\n-    let pw = Ptr(box Wrapper(5)) as Ptr<Wrapper<dyn Trait>>;\n+fn main() {\n+    let pw = Ptr(Box::new(Wrapper(5))) as Ptr<Wrapper<dyn Trait>>;\n     assert_eq!(pw.ptr_wrapper(), 5);\n \n-    let wp = Wrapper(Ptr(box 6)) as Wrapper<Ptr<dyn Trait>>;\n+    let wp = Wrapper(Ptr(Box::new(6))) as Wrapper<Ptr<dyn Trait>>;\n     assert_eq!(wp.wrapper_ptr(), 6);\n \n-    let wpw = Wrapper(Ptr(box Wrapper(7))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n+    let wpw = Wrapper(Ptr(Box::new(Wrapper(7)))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n     assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n-\n-    0\n }"}, {"sha": "7c6d7fc106ded4c3ef44ed9f334a36ac1bb1598a", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -365,6 +365,22 @@ impl <T: PartialEq> PartialEq for Option<T> {\n     }\n }\n \n+#[lang = \"shl\"]\n+pub trait Shl<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn shl(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Shl for u128 {\n+    type Output = u128;\n+\n+    fn shl(self, rhs: u128) -> u128 {\n+        self << rhs\n+    }\n+}\n+\n #[lang = \"neg\"]\n pub trait Neg {\n     type Output;"}, {"sha": "237f4d11d57f1c628454ebbb843eda33f9afb5a0", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -264,6 +264,9 @@ fn main() {\n     assert_eq!(f2 as i8, -128);\n     assert_eq!(f2 as u8, 0);\n \n+    let amount = 0;\n+    assert_eq!(1u128 << amount, 1);\n+\n     static ANOTHER_STATIC: &u8 = &A_STATIC;\n     assert_eq!(*ANOTHER_STATIC, 42);\n "}, {"sha": "8cfffe580a1f0ef9be7dc3f207d4d399465de3de", "filename": "compiler/rustc_codegen_cranelift/patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -119,21 +119,5 @@ index 6609bc3..241b497 100644\n  \n  #[test]\n  #[should_panic(expected = \"index 0 greater than length of slice\")]\n-diff --git a/library/core/tests/num/ops.rs b/library/core/tests/num/ops.rs\n-index 9979cc8..d5d1d83 100644\n---- a/library/core/tests/num/ops.rs\n-+++ b/library/core/tests/num/ops.rs\n-@@ -238,7 +238,7 @@ macro_rules! test_shift_assign {\n-         }\n-     };\n- }\n--test_shift!(test_shl_defined, Shl::shl);\n--test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n--test_shift!(test_shr_defined, Shr::shr);\n--test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n-+//test_shift!(test_shl_defined, Shl::shl);\n-+//test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n-+//test_shift!(test_shr_defined, Shr::shr);\n-+//test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "32e5930969061f0231ecc6e89c72eb77be7002cb", "filename": "compiler/rustc_codegen_cranelift/patches/0027-Disable-128bit-atomic-operations.patch", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -0,0 +1,103 @@\n+From 894e07dfec2624ba539129b1c1d63e1d7d812bda Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:45:28 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ library/core/src/sync/atomic.rs | 38 ---------------------------------\n+ library/core/tests/atomic.rs    |  4 ----\n+ library/std/src/panic.rs        |  6 ------\n+ 3 files changed, 48 deletions(-)\n+\n+diff --git a/library/core/src/sync/atomic.rs b/library/core/src/sync/atomic.rs\n+index 81c9e1d..65c9503 100644\n+--- a/library/core/src/sync/atomic.rs\n++++ b/library/core/src/sync/atomic.rs\n+@@ -2228,44 +2228,6 @@ atomic_int! {\n+     \"AtomicU64::new(0)\",\n+     u64 AtomicU64 ATOMIC_U64_INIT\n+ }\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-atomic_int! {\n+-    cfg(target_has_atomic = \"128\"),\n+-    cfg(target_has_atomic_equal_alignment = \"128\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    \"i128\",\n+-    \"#![feature(integer_atomics)]\\n\\n\",\n+-    atomic_min, atomic_max,\n+-    16,\n+-    \"AtomicI128::new(0)\",\n+-    i128 AtomicI128 ATOMIC_I128_INIT\n+-}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-atomic_int! {\n+-    cfg(target_has_atomic = \"128\"),\n+-    cfg(target_has_atomic_equal_alignment = \"128\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    \"u128\",\n+-    \"#![feature(integer_atomics)]\\n\\n\",\n+-    atomic_umin, atomic_umax,\n+-    16,\n+-    \"AtomicU128::new(0)\",\n+-    u128 AtomicU128 ATOMIC_U128_INIT\n+-}\n+ \n+ macro_rules! atomic_int_ptr_sized {\n+     ( $($target_pointer_width:literal $align:literal)* ) => { $(\n+diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+index 2d1e449..cb6da5d 100644\n+--- a/library/core/tests/atomic.rs\n++++ b/library/core/tests/atomic.rs\n+@@ -145,10 +145,6 @@ fn atomic_alignment() {\n+     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n+     #[cfg(target_has_atomic = \"64\")]\n+     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+diff --git a/library/std/src/panic.rs b/library/std/src/panic.rs\n+index 89a822a..779fd88 100644\n+--- a/library/std/src/panic.rs\n++++ b/library/std/src/panic.rs\n+@@ -279,9 +279,6 @@ impl RefUnwindSafe for atomic::AtomicI32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for atomic::AtomicI64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for atomic::AtomicI128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"ptr\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+@@ -298,9 +295,6 @@ impl RefUnwindSafe for atomic::AtomicU32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for atomic::AtomicU64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for atomic::AtomicU128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"8\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "ee995ffcfa9f7df9692746f6ca56506de949ef2b", "filename": "compiler/rustc_codegen_cranelift/prepare.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fprepare.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n \n rustup component add rust-src rustc-dev llvm-tools-preview"}, {"sha": "908ca52135b668b137e29523282b5e467ccecc43", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1 +1 @@\n-nightly-2021-01-30\n+nightly-2021-03-05"}, {"sha": "2bd8f7d1bc15d7a6690a34aad18f968f7af9bd3c", "filename": "compiler/rustc_codegen_cranelift/rustfmt.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -0,0 +1,4 @@\n+# Matches rustfmt.toml of rustc\n+version = \"Two\"\n+use_small_heuristics = \"Max\"\n+merge_derives = false"}, {"sha": "669d2d45b71b5471e874e475e63bcff7108884fc", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n dir=$(dirname \"$0\")\n source \"$dir/config.sh\""}, {"sha": "c2ed2bf256d5980a188421ba69b229777e2c8d16", "filename": "compiler/rustc_codegen_cranelift/scripts/config.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -3,7 +3,7 @@\n set -e\n \n unamestr=$(uname)\n-if [[ \"$unamestr\" == 'Linux' ]]; then\n+if [[ \"$unamestr\" == 'Linux' || \"$unamestr\" == 'FreeBSD' ]]; then\n    dylib_ext='so'\n elif [[ \"$unamestr\" == 'Darwin' ]]; then\n    dylib_ext='dylib'\n@@ -26,7 +26,7 @@ export RUSTC=$dir\"/bin/cg_clif\"\n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n '-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n \n-# FIXME remove once the atomic shim is gone\n+# FIXME fix `#[linkage = \"extern_weak\"]` without this\n if [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi"}, {"sha": "694945a87c268deaa890288ab55ff7b5bbe1f601", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n set -e\n "}, {"sha": "6473c6ad67d2e6e45b31274a172132719943ec24", "filename": "compiler/rustc_codegen_cranelift/scripts/test_bootstrap.sh", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n cd \"$(dirname \"$0\")/../\"\n@@ -14,21 +14,18 @@ git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n git apply - <<EOF\n-diff --git a/.gitmodules b/.gitmodules\n-index 984113151de..c1e9d960d56 100644\n---- a/.gitmodules\n-+++ b/.gitmodules\n-@@ -34,10 +34,6 @@\n- [submodule \"src/doc/edition-guide\"]\n- \tpath = src/doc/edition-guide\n- \turl = https://github.com/rust-lang/edition-guide.git\n--[submodule \"src/llvm-project\"]\n--\tpath = src/llvm-project\n--\turl = https://github.com/rust-lang/llvm-project.git\n--\tbranch = rustc/11.0-2020-10-12\n- [submodule \"src/doc/embedded-book\"]\n- \tpath = src/doc/embedded-book\n- \turl = https://github.com/rust-embedded/book.git\n+diff --git a/Cargo.toml b/Cargo.toml\n+index 5bd1147cad5..10d68a2ff14 100644\n+--- a/Cargo.toml\n++++ b/Cargo.toml\n+@@ -111,5 +111,7 @@ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+ rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n+ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+ \n++compiler_builtins = { path = \"../build_sysroot/compiler-builtins\" }\n++\n+ [patch.\"https://github.com/rust-lang/rust-clippy\"]\n+ clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\n index 23e689fcae7..5f077b765b6 100644\n --- a/compiler/rustc_data_structures/Cargo.toml\n@@ -41,6 +38,19 @@ index 23e689fcae7..5f077b765b6 100644\n \n  [target.'cfg(windows)'.dependencies]\n  winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n+diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n+index d95b5b7f17f..00b6f0e3635 100644\n+--- a/library/alloc/Cargo.toml\n++++ b/library/alloc/Cargo.toml\n+@@ -8,7 +8,7 @@ edition = \"2018\"\n+ \n+ [dependencies]\n+ core = { path = \"../core\" }\n+-compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n++compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std', 'no-asm'] }\n+ \n+ [dev-dependencies]\n+ rand = \"0.7\"\n EOF\n \n cat > config.toml <<EOF"}, {"sha": "f9a9fb091fb4ac0117eec2e9315882e54082d6d6", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n set -e\n \n@@ -27,13 +27,16 @@ function no_sysroot_tests() {\n     $MY_RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n     # (echo \"break set -n main\"; echo \"run\"; sleep 1; echo \"si -c 10\"; sleep 1; echo \"frame variable\") | lldb -- ./target/out/mini_core_hello_world abc bcd\n+}\n \n+function base_sysroot_tests() {\n     echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n     $MY_RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n-}\n \n-function base_sysroot_tests() {\n+    echo \"[AOT] alloc_system\"\n+    $MY_RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n+\n     echo \"[AOT] alloc_example\"\n     $MY_RUSTC example/alloc_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/alloc_example"}, {"sha": "c3cf90e1e70be209295c81096cdfa3dfe5291ab2", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 18, "deletions": 38, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -10,14 +10,14 @@ use cranelift_codegen::entity::EntityRef;\n \n use crate::prelude::*;\n \n-pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n     fx.add_global_comment(\n         \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n     );\n }\n \n pub(super) fn add_arg_comment<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     kind: &str,\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n@@ -42,11 +42,7 @@ pub(super) fn add_arg_comment<'tcx>(\n         [param_a, param_b] => Cow::Owned(format!(\"= {:?},{:?}\", param_a, param_b)),\n         params => Cow::Owned(format!(\n             \"= {}\",\n-            params\n-                .iter()\n-                .map(ToString::to_string)\n-                .collect::<Vec<_>>()\n-                .join(\",\")\n+            params.iter().map(ToString::to_string).collect::<Vec<_>>().join(\",\")\n         )),\n     };\n \n@@ -62,27 +58,21 @@ pub(super) fn add_arg_comment<'tcx>(\n     ));\n }\n \n-pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n     fx.add_global_comment(String::new());\n     fx.add_global_comment(\n         \"kind  local ty                              size align (abi,pref)\".to_string(),\n     );\n }\n \n pub(super) fn add_local_place_comments<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     local: Local,\n ) {\n     let TyAndLayout { ty, layout } = place.layout();\n-    let rustc_target::abi::Layout {\n-        size,\n-        align,\n-        abi: _,\n-        variants: _,\n-        fields: _,\n-        largest_niche: _,\n-    } = layout;\n+    let rustc_target::abi::Layout { size, align, abi: _, variants: _, fields: _, largest_niche: _ } =\n+        layout;\n \n     let (kind, extra) = match *place.inner() {\n         CPlaceInner::Var(place_local, var) => {\n@@ -91,10 +81,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         }\n         CPlaceInner::VarPair(place_local, var1, var2) => {\n             assert_eq!(local, place_local);\n-            (\n-                \"ssa\",\n-                Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())),\n-            )\n+            (\"ssa\", Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())))\n         }\n         CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n         CPlaceInner::Addr(ptr, meta) => {\n@@ -104,18 +91,15 @@ pub(super) fn add_local_place_comments<'tcx>(\n                 Cow::Borrowed(\"\")\n             };\n             match ptr.base_and_offset() {\n-                (crate::pointer::PointerBase::Addr(addr), offset) => (\n-                    \"reuse\",\n-                    format!(\"storage={}{}{}\", addr, offset, meta).into(),\n-                ),\n-                (crate::pointer::PointerBase::Stack(stack_slot), offset) => (\n-                    \"stack\",\n-                    format!(\"storage={}{}{}\", stack_slot, offset, meta).into(),\n-                ),\n-                (crate::pointer::PointerBase::Dangling(align), offset) => (\n-                    \"zst\",\n-                    format!(\"align={},offset={}\", align.bytes(), offset).into(),\n-                ),\n+                (crate::pointer::PointerBase::Addr(addr), offset) => {\n+                    (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n+                    (\"stack\", format!(\"storage={}{}{}\", stack_slot, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Dangling(align), offset) => {\n+                    (\"zst\", format!(\"align={},offset={}\", align.bytes(), offset).into())\n+                }\n             }\n         }\n     };\n@@ -128,11 +112,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         size.bytes(),\n         align.abi.bytes(),\n         align.pref.bytes(),\n-        if extra.is_empty() {\n-            \"\"\n-        } else {\n-            \"              \"\n-        },\n+        if extra.is_empty() { \"\" } else { \"              \" },\n         extra,\n     ));\n }"}, {"sha": "c79889f8ca1da99c5db002f7b19746fad5d1d04d", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 35, "deletions": 109, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -38,25 +38,15 @@ fn clif_sig_from_fn_abi<'tcx>(\n         | Conv::X86VectorCall\n         | Conv::AmdGpuKernel\n         | Conv::AvrInterrupt\n-        | Conv::AvrNonBlockingInterrupt => {\n-            todo!(\"{:?}\", fn_abi.conv)\n-        }\n+        | Conv::AvrNonBlockingInterrupt => todo!(\"{:?}\", fn_abi.conv),\n     };\n-    let inputs = fn_abi\n-        .args\n-        .iter()\n-        .map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter())\n-        .flatten();\n+    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n \n     let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n     // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n     let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n-    Signature {\n-        params,\n-        returns,\n-        call_conv,\n-    }\n+    Signature { params, returns, call_conv }\n }\n \n pub(crate) fn get_function_sig<'tcx>(\n@@ -65,34 +55,25 @@ pub(crate) fn get_function_sig<'tcx>(\n     inst: Instance<'tcx>,\n ) -> Signature {\n     assert!(!inst.substs.needs_infer());\n-    clif_sig_from_fn_abi(\n-        tcx,\n-        triple,\n-        &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]),\n-    )\n+    clif_sig_from_fn_abi(tcx, triple, &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]))\n }\n \n /// Instance must be monomorphized\n pub(crate) fn import_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name.to_string();\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module\n-        .declare_function(&name, Linkage::Import, &sig)\n-        .unwrap()\n+    module.declare_function(&name, Linkage::Import, &sig).unwrap()\n }\n \n-impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, &mut self.cx.module, inst);\n-        let func_ref = self\n-            .cx\n-            .module\n-            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = import_function(self.tcx, self.cx.module, inst);\n+        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n         #[cfg(debug_assertions)]\n         self.add_comment(func_ref, format!(\"{:?}\", inst));\n@@ -107,20 +88,9 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n-        let sig = Signature {\n-            params,\n-            returns,\n-            call_conv: CallConv::triple_default(self.triple()),\n-        };\n-        let func_id = self\n-            .cx\n-            .module\n-            .declare_function(&name, Linkage::Import, &sig)\n-            .unwrap();\n-        let func_ref = self\n-            .cx\n-            .module\n-            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n+        let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         #[cfg(debug_assertions)]\n         {\n@@ -140,17 +110,12 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         let (input_tys, args): (Vec<_>, Vec<_>) = args\n             .iter()\n             .map(|arg| {\n-                (\n-                    AbiParam::new(self.clif_type(arg.layout().ty).unwrap()),\n-                    arg.load_scalar(self),\n-                )\n+                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types()\n-                .map(|ty| AbiParam::new(self.clif_type(ty).unwrap()))\n-                .collect()\n+            tup.types().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n         } else {\n             vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n@@ -169,7 +134,7 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n \n /// Make a [`CPlace`] capable of holding value of the specified type.\n fn make_local_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     local: Local,\n     layout: TyAndLayout<'tcx>,\n     is_ssa: bool,\n@@ -190,10 +155,7 @@ fn make_local_place<'tcx>(\n     place\n }\n \n-pub(crate) fn codegen_fn_prelude<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    start_block: Block,\n-) {\n+pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_block: Block) {\n     fx.bcx.append_block_params_for_function_params(start_block);\n \n     fx.bcx.switch_to_block(start_block);\n@@ -204,13 +166,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n-    let mut block_params_iter = fx\n-        .bcx\n-        .func\n-        .dfg\n-        .block_params(start_block)\n-        .to_vec()\n-        .into_iter();\n+    let mut block_params_iter = fx.bcx.func.dfg.block_params(start_block).to_vec().into_iter();\n     let ret_place =\n         self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n@@ -286,10 +242,10 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n             if let Some((addr, meta)) = val.try_to_ptr() {\n                 let local_decl = &fx.mir.local_decls[local];\n                 //                       v this ! is important\n-                let internally_mutable = !val.layout().ty.is_freeze(\n-                    fx.tcx.at(local_decl.source_info.span),\n-                    ParamEnv::reveal_all(),\n-                );\n+                let internally_mutable = !val\n+                    .layout()\n+                    .ty\n+                    .is_freeze(fx.tcx.at(local_decl.source_info.span), ParamEnv::reveal_all());\n                 if local_decl.mutability == mir::Mutability::Not && !internally_mutable {\n                     // We wont mutate this argument, so it is fine to borrow the backing storage\n                     // of this argument, to prevent a copy.\n@@ -321,9 +277,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n             ArgKind::Spread(params) => {\n                 for (i, param) in params.into_iter().enumerate() {\n                     if let Some(param) = param {\n-                        place\n-                            .place_field(fx, mir::Field::new(i))\n-                            .write_cvalue(fx, param);\n+                        place.place_field(fx, mir::Field::new(i)).write_cvalue(fx, param);\n                     }\n                 }\n             }\n@@ -340,23 +294,20 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         assert_eq!(fx.local_map.push(place), local);\n     }\n \n-    fx.bcx\n-        .ins()\n-        .jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n+    fx.bcx.ins().jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n }\n \n pub(crate) fn codegen_terminator_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n     current_block: Block,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n     destination: Option<(Place<'tcx>, BasicBlock)>,\n ) {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig = fx\n-        .tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let fn_sig =\n+        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n     let destination = destination.map(|(place, bb)| (codegen_place(fx, place), bb));\n \n@@ -404,20 +355,11 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let fn_abi = if let Some(instance) = instance {\n         FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(\n-            &RevealAllLayoutCx(fx.tcx),\n-            fn_ty.fn_sig(fx.tcx),\n-            &extra_args,\n-        )\n+        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n     };\n \n     let is_cold = instance\n-        .map(|inst| {\n-            fx.tcx\n-                .codegen_fn_attrs(inst.def_id())\n-                .flags\n-                .contains(CodegenFnAttrFlags::COLD)\n-        })\n+        .map(|inst| fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD))\n         .unwrap_or(false);\n     if is_cold {\n         fx.cold_blocks.insert(current_block);\n@@ -441,20 +383,15 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         }\n         args\n     } else {\n-        args.iter()\n-            .map(|arg| codegen_operand(fx, arg))\n-            .collect::<Vec<_>>()\n+        args.iter().map(|arg| codegen_operand(fx, arg)).collect::<Vec<_>>()\n     };\n \n     //   | indirect call target\n     //   |         | the first argument to be passed\n     //   v         v\n     let (func_ref, first_arg) = match instance {\n         // Trait object call\n-        Some(Instance {\n-            def: InstanceDef::Virtual(_, idx),\n-            ..\n-        }) => {\n+        Some(Instance { def: InstanceDef::Virtual(_, idx), .. }) => {\n             #[cfg(debug_assertions)]\n             {\n                 let nop_inst = fx.bcx.ins().nop();\n@@ -511,10 +448,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 )\n                 .collect::<Vec<_>>();\n \n-            if instance\n-                .map(|inst| inst.def.requires_caller_location(fx.tcx))\n-                .unwrap_or(false)\n-            {\n+            if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n                 call_args.extend(\n@@ -543,10 +477,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n         if fn_sig.abi != Abi::C {\n-            fx.tcx.sess.span_fatal(\n-                span,\n-                &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n-            );\n+            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n         let abi_params = call_args\n@@ -555,9 +486,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let ty = fx.bcx.func.dfg.value_type(arg);\n                 if !ty.is_int() {\n                     // FIXME set %al to upperbound on float args once floats are supported\n-                    fx.tcx\n-                        .sess\n-                        .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                    fx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n                 }\n                 AbiParam::new(ty)\n             })\n@@ -574,7 +503,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n }\n \n pub(crate) fn codegen_drop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n     drop_place: CPlace<'tcx>,\n ) {\n@@ -611,10 +540,7 @@ pub(crate) fn codegen_drop<'tcx>(\n                     fx,\n                     fx.layout_of(fx.tcx.mk_ref(\n                         &ty::RegionKind::ReErased,\n-                        TypeAndMut {\n-                            ty,\n-                            mutbl: crate::rustc_hir::Mutability::Mut,\n-                        },\n+                        TypeAndMut { ty, mutbl: crate::rustc_hir::Mutability::Mut },\n                     )),\n                 );\n                 let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);"}, {"sha": "d58f952f53c1a6d4087dd81d7d18e5881e217513", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 27, "deletions": 81, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -71,12 +71,7 @@ fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n         .prefix\n         .iter()\n         .flatten()\n-        .map(|&kind| {\n-            reg_to_abi_param(Reg {\n-                kind,\n-                size: cast.prefix_chunk_size,\n-            })\n-        })\n+        .map(|&kind| reg_to_abi_param(Reg { kind, size: cast.prefix_chunk_size }))\n         .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n         .collect::<SmallVec<_>>();\n \n@@ -98,12 +93,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         match self.mode {\n             PassMode::Ignore => smallvec![],\n             PassMode::Direct(attrs) => match &self.layout.abi {\n-                Abi::Scalar(scalar) => {\n-                    smallvec![apply_arg_attrs_to_abi_param(\n-                        AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n-                        attrs\n-                    )]\n-                }\n+                Abi::Scalar(scalar) => smallvec![apply_arg_attrs_to_abi_param(\n+                    AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n+                    attrs\n+                )],\n                 Abi::Vector { .. } => {\n                     let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n                     smallvec![AbiParam::new(vector_ty)]\n@@ -122,29 +115,18 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n             PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n-            PassMode::Indirect {\n-                attrs,\n-                extra_attrs: None,\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     let size = u32::try_from(self.layout.size.bytes()).unwrap();\n                     smallvec![apply_arg_attrs_to_abi_param(\n                         AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructArgument(size),),\n                         attrs\n                     )]\n                 } else {\n-                    smallvec![apply_arg_attrs_to_abi_param(\n-                        AbiParam::new(pointer_ty(tcx)),\n-                        attrs\n-                    )]\n+                    smallvec![apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs)]\n                 }\n             }\n-            PassMode::Indirect {\n-                attrs,\n-                extra_attrs: Some(extra_attrs),\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack } => {\n                 assert!(!on_stack);\n                 smallvec![\n                     apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs),\n@@ -158,10 +140,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         match self.mode {\n             PassMode::Ignore => (None, vec![]),\n             PassMode::Direct(_) => match &self.layout.abi {\n-                Abi::Scalar(scalar) => (\n-                    None,\n-                    vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))],\n-                ),\n+                Abi::Scalar(scalar) => {\n+                    (None, vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))])\n+                }\n                 Abi::Vector { .. } => {\n                     let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n                     (None, vec![AbiParam::new(vector_ty)])\n@@ -177,31 +158,19 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n             PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n-            PassMode::Indirect {\n-                attrs: _,\n-                extra_attrs: None,\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n-                (\n-                    Some(AbiParam::special(\n-                        pointer_ty(tcx),\n-                        ArgumentPurpose::StructReturn,\n-                    )),\n-                    vec![],\n-                )\n+                (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n+            }\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+                unreachable!(\"unsized return value\")\n             }\n-            PassMode::Indirect {\n-                attrs: _,\n-                extra_attrs: Some(_),\n-                on_stack: _,\n-            } => unreachable!(\"unsized return value\"),\n         }\n     }\n }\n \n pub(super) fn to_casted_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     cast: CastTarget,\n ) -> SmallVec<[Value; 2]> {\n@@ -211,26 +180,21 @@ pub(super) fn to_casted_value<'tcx>(\n     cast_target_to_abi_params(cast)\n         .into_iter()\n         .map(|param| {\n-            let val = ptr\n-                .offset_i64(fx, offset)\n-                .load(fx, param.value_type, MemFlags::new());\n+            let val = ptr.offset_i64(fx, offset).load(fx, param.value_type, MemFlags::new());\n             offset += i64::from(param.value_type.bytes());\n             val\n         })\n         .collect()\n }\n \n pub(super) fn from_casted_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n     cast: CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n-    let abi_param_size: u32 = abi_params\n-        .iter()\n-        .map(|param| param.value_type.bytes())\n-        .sum();\n+    let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n     let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n     let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n@@ -260,7 +224,7 @@ pub(super) fn from_casted_value<'tcx>(\n \n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n ) -> SmallVec<[Value; 2]> {\n@@ -283,7 +247,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// Create a [`CValue`] containing the value of a function parameter adding clif function parameters\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n@@ -294,10 +258,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n         .into_iter()\n         .map(|abi_param| {\n             let block_param = block_params_iter.next().unwrap();\n-            assert_eq!(\n-                fx.bcx.func.dfg.value_type(block_param),\n-                abi_param.value_type\n-            );\n+            assert_eq!(fx.bcx.func.dfg.value_type(block_param), abi_param.value_type);\n             block_param\n         })\n         .collect::<SmallVec<[_; 2]>>();\n@@ -321,29 +282,14 @@ pub(super) fn cvalue_for_param<'tcx>(\n         }\n         PassMode::Pair(_, _) => {\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n-            Some(CValue::by_val_pair(\n-                block_params[0],\n-                block_params[1],\n-                arg_abi.layout,\n-            ))\n+            Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n         PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n-            Some(CValue::by_ref(\n-                Pointer::new(block_params[0]),\n-                arg_abi.layout,\n-            ))\n+            Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_ref_unsized(\n                 Pointer::new(block_params[0]),"}, {"sha": "9fa066df69b3cd936b346b28a6bc1213ad633cb9", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 27, "deletions": 63, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -8,14 +8,13 @@ use smallvec::{smallvec, SmallVec};\n \n /// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     func: &mir::Operand<'tcx>,\n     args: &[mir::Operand<'tcx>],\n ) -> bool {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig = fx\n-        .tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let fn_sig =\n+        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n     // Handle special calls like instrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n@@ -42,11 +41,7 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n     let fn_abi = if let Some(instance) = instance {\n         FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(\n-            &RevealAllLayoutCx(fx.tcx),\n-            fn_ty.fn_sig(fx.tcx),\n-            &extra_args,\n-        )\n+        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n     };\n     match fn_abi.ret.mode {\n         PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n@@ -58,15 +53,12 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n /// Return a place where the return value of the current function can be written to. If necessary\n /// this adds an extra parameter pointing to where the return value needs to be stored.\n pub(super) fn codegen_return_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore => (\n-            CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n-            smallvec![],\n-        ),\n+        PassMode::Ignore => (CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout), smallvec![]),\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n@@ -79,26 +71,17 @@ pub(super) fn codegen_return_param<'tcx>(\n                 smallvec![],\n             )\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             let ret_param = block_params_iter.next().unwrap();\n             assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n             (\n-                CPlace::for_ptr(\n-                    Pointer::new(ret_param),\n-                    fx.fn_abi.as_ref().unwrap().ret.layout,\n-                ),\n+                CPlace::for_ptr(Pointer::new(ret_param), fx.fn_abi.as_ref().unwrap().ret.layout),\n                 smallvec![ret_param],\n             )\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n     };\n \n     #[cfg(not(debug_assertions))]\n@@ -120,27 +103,21 @@ pub(super) fn codegen_return_param<'tcx>(\n \n /// Invokes the closure with if necessary a value representing the return pointer. When the closure\n /// returns the call return value(s) if any are written to the correct place.\n-pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n-    f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n+    f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> (Inst, T),\n ) -> (Inst, T) {\n     let return_ptr = match ret_arg_abi.mode {\n         PassMode::Ignore => None,\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => match ret_place {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n@@ -177,37 +154,24 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n                 ret_place.write_cvalue(fx, result);\n             }\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {}\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {}\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n     }\n \n     (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any.\n-pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n     match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore\n-        | PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Ignore | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n         PassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);"}, {"sha": "efb64233ef2c3109104b0dce231dec1d7aca699f", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -66,13 +66,9 @@ fn codegen_inner(\n         let callee_name = kind.fn_name(method.name);\n         //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n-        let func_id = module\n-            .declare_function(&caller_name, Linkage::Export, &sig)\n-            .unwrap();\n+        let func_id = module.declare_function(&caller_name, Linkage::Export, &sig).unwrap();\n \n-        let callee_func_id = module\n-            .declare_function(&callee_name, Linkage::Import, &sig)\n-            .unwrap();\n+        let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig.clone());\n@@ -96,11 +92,7 @@ fn codegen_inner(\n             bcx.finalize();\n         }\n         module\n-            .define_function(\n-                func_id,\n-                &mut ctx,\n-                &mut cranelift_codegen::binemit::NullTrapSink {},\n-            )\n+            .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n             .unwrap();\n         unwind_context.add_function(func_id, &ctx, module.isa());\n     }\n@@ -114,13 +106,10 @@ fn codegen_inner(\n     let callee_name = kind.fn_name(sym::oom);\n     //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n-    let func_id = module\n-        .declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig)\n-        .unwrap();\n+    let func_id =\n+        module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n \n-    let callee_func_id = module\n-        .declare_function(&callee_name, Linkage::Import, &sig)\n-        .unwrap();\n+    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n     ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n@@ -143,11 +132,7 @@ fn codegen_inner(\n         bcx.finalize();\n     }\n     module\n-        .define_function(\n-            func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n+        .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n         .unwrap();\n     unwind_context.add_function(func_id, &ctx, module.isa());\n }"}, {"sha": "efead25552f4d1ca203e35b49a2c4912ab253c4b", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -11,7 +11,7 @@ pub(crate) enum SsaKind {\n     Ssa,\n }\n \n-pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, SsaKind> {\n+pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n     let mut flag_map = fx\n         .mir\n         .local_decls\n@@ -40,12 +40,7 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, S\n         }\n \n         match &bb.terminator().kind {\n-            TerminatorKind::Call {\n-                destination,\n-                func,\n-                args,\n-                ..\n-            } => {\n+            TerminatorKind::Call { destination, func, args, .. } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n                     if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n                         not_ssa(&mut flag_map, dest_place.local)"}, {"sha": "7583fc424071e251cb158c390265c294bbe30836", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -12,10 +12,7 @@ use object::{Object, ObjectSymbol, SymbolKind};\n \n #[derive(Debug)]\n enum ArchiveEntry {\n-    FromArchive {\n-        archive_index: usize,\n-        entry_index: usize,\n-    },\n+    FromArchive { archive_index: usize, entry_index: usize },\n     File(PathBuf),\n }\n \n@@ -30,7 +27,6 @@ pub(crate) struct ArArchiveBuilder<'a> {\n     // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n     // the end of an archive for linkers to not get confused.\n     entries: Vec<(String, ArchiveEntry)>,\n-    update_symbols: bool,\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n@@ -46,10 +42,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 let entry = entry.unwrap();\n                 entries.push((\n                     String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    ArchiveEntry::FromArchive {\n-                        archive_index: 0,\n-                        entry_index: i,\n-                    },\n+                    ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n                 ));\n                 i += 1;\n             }\n@@ -69,7 +62,6 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n             src_archives,\n             entries,\n-            update_symbols: false,\n         }\n     }\n \n@@ -95,14 +87,9 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n     fn add_native_library(&mut self, name: rustc_span::symbol::Symbol) {\n         let location = find_library(name, &self.lib_search_paths, self.sess);\n-        self.add_archive(location.clone(), |_| false)\n-            .unwrap_or_else(|e| {\n-                panic!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                );\n-            });\n+        self.add_archive(location.clone(), |_| false).unwrap_or_else(|e| {\n+            panic!(\"failed to add native library {}: {}\", location.to_string_lossy(), e);\n+        });\n     }\n \n     fn add_rlib(\n@@ -136,9 +123,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         })\n     }\n \n-    fn update_symbols(&mut self) {\n-        self.update_symbols = true;\n-    }\n+    fn update_symbols(&mut self) {}\n \n     fn build(mut self) {\n         enum BuilderKind {\n@@ -156,10 +141,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             // FIXME only read the symbol table of the object files to avoid having to keep all\n             // object files in memory at once, or read them twice.\n             let data = match entry {\n-                ArchiveEntry::FromArchive {\n-                    archive_index,\n-                    entry_index,\n-                } => {\n+                ArchiveEntry::FromArchive { archive_index, entry_index } => {\n                     // FIXME read symbols from symtab\n                     use std::io::Read;\n                     let (ref _src_archive_path, ref mut src_archive) =\n@@ -225,10 +207,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                             err\n                         ));\n                     }),\n-                    entries\n-                        .iter()\n-                        .map(|(name, _)| name.as_bytes().to_vec())\n-                        .collect(),\n+                    entries.iter().map(|(name, _)| name.as_bytes().to_vec()).collect(),\n                     ar::GnuSymbolTableFormat::Size32,\n                     symbol_table,\n                 )\n@@ -271,8 +250,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 .expect(\"Couldn't run ranlib\");\n \n             if !status.success() {\n-                self.sess\n-                    .fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n             }\n         }\n     }\n@@ -292,13 +270,8 @@ impl<'a> ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.header().identifier().to_vec())\n                 .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name,\n-                    ArchiveEntry::FromArchive {\n-                        archive_index,\n-                        entry_index: i,\n-                    },\n-                ));\n+                self.entries\n+                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n             }\n             i += 1;\n         }"}, {"sha": "674e6d907510a8510607cea2c747a66d17238c74", "filename": "compiler/rustc_codegen_cranelift/src/atomic_shim.rs", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/dfe519b344b60e54a2028d3366ca366a228537e3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe519b344b60e54a2028d3366ca366a228537e3/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs?ref=dfe519b344b60e54a2028d3366ca366a228537e3", "patch": "@@ -1,185 +0,0 @@\n-//! Atomic intrinsics are implemented using a global lock for now, as Cranelift doesn't support\n-//! atomic operations yet.\n-\n-// FIXME implement atomic instructions in Cranelift.\n-\n-use crate::prelude::*;\n-\n-#[cfg(all(feature = \"jit\", unix))]\n-#[no_mangle]\n-static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n-\n-pub(crate) fn init_global_lock(\n-    module: &mut impl Module,\n-    bcx: &mut FunctionBuilder<'_>,\n-    use_jit: bool,\n-) {\n-    if use_jit {\n-        // When using JIT, dylibs won't find the __cg_clif_global_atomic_mutex data object defined here,\n-        // so instead we define it in the cg_clif dylib.\n-\n-        return;\n-    }\n-\n-    let mut data_ctx = DataContext::new();\n-    data_ctx.define_zeroinit(1024); // 1024 bytes should be big enough on all platforms.\n-    data_ctx.set_align(16);\n-    let atomic_mutex = module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Export,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-    module.define_data(atomic_mutex, &data_ctx).unwrap();\n-\n-    let pthread_mutex_init = module\n-        .declare_function(\n-            \"pthread_mutex_init\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: module.target_config().default_call_conv,\n-                params: vec![\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                    ),\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *const pthread_mutex_attr_t */\n-                    ),\n-                ],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_init = module.declare_func_in_func(pthread_mutex_init, bcx.func);\n-\n-    let atomic_mutex = module.declare_data_in_func(atomic_mutex, bcx.func);\n-    let atomic_mutex = bcx\n-        .ins()\n-        .global_value(module.target_config().pointer_type(), atomic_mutex);\n-\n-    let nullptr = bcx.ins().iconst(module.target_config().pointer_type(), 0);\n-\n-    bcx.ins().call(pthread_mutex_init, &[atomic_mutex, nullptr]);\n-}\n-\n-pub(crate) fn init_global_lock_constructor(\n-    module: &mut impl Module,\n-    constructor_name: &str,\n-) -> FuncId {\n-    let sig = Signature::new(CallConv::SystemV);\n-    let init_func_id = module\n-        .declare_function(constructor_name, Linkage::Export, &sig)\n-        .unwrap();\n-\n-    let mut ctx = Context::new();\n-    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n-    {\n-        let mut func_ctx = FunctionBuilderContext::new();\n-        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-        let block = bcx.create_block();\n-        bcx.switch_to_block(block);\n-\n-        crate::atomic_shim::init_global_lock(module, &mut bcx, false);\n-\n-        bcx.ins().return_(&[]);\n-        bcx.seal_all_blocks();\n-        bcx.finalize();\n-    }\n-    module\n-        .define_function(\n-            init_func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n-        .unwrap();\n-\n-    init_func_id\n-}\n-\n-pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_lock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n-}\n-\n-pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_unlock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n-}"}, {"sha": "eb7927fc4adebdbd16cf8742b6b8709d3076361e", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -8,7 +8,7 @@ use rustc_session::Session;\n use cranelift_module::FuncId;\n \n use object::write::*;\n-use object::{RelocationEncoding, RelocationKind, SectionKind, SymbolFlags};\n+use object::{RelocationEncoding, SectionKind, SymbolFlags};\n \n use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n \n@@ -22,9 +22,7 @@ pub(crate) trait WriteMetadata {\n \n impl WriteMetadata for object::write::Object {\n     fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, _is_like_osx: bool) {\n-        let segment = self\n-            .segment_name(object::write::StandardSegment::Data)\n-            .to_vec();\n+        let segment = self.segment_name(object::write::StandardSegment::Data).to_vec();\n         let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n         let offset = self.append_section_data(section_id, &data, 1);\n         // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n@@ -74,11 +72,7 @@ impl WriteDebugInfo for ObjectProduct {\n         let section_id = self.object.add_section(\n             segment,\n             name,\n-            if id == SectionId::EhFrame {\n-                SectionKind::ReadOnlyData\n-            } else {\n-                SectionKind::Debug\n-            },\n+            if id == SectionId::EhFrame { SectionKind::ReadOnlyData } else { SectionKind::Debug },\n         );\n         self.object\n             .section_mut(section_id)\n@@ -118,49 +112,6 @@ impl WriteDebugInfo for ObjectProduct {\n     }\n }\n \n-// FIXME remove once atomic instructions are implemented in Cranelift.\n-pub(crate) trait AddConstructor {\n-    fn add_constructor(&mut self, func_id: FuncId);\n-}\n-\n-impl AddConstructor for ObjectProduct {\n-    fn add_constructor(&mut self, func_id: FuncId) {\n-        let symbol = self.function_symbol(func_id);\n-        let segment = self\n-            .object\n-            .segment_name(object::write::StandardSegment::Data);\n-        let init_array_section =\n-            self.object\n-                .add_section(segment.to_vec(), b\".init_array\".to_vec(), SectionKind::Data);\n-        let address_size = self\n-            .object\n-            .architecture()\n-            .address_size()\n-            .expect(\"address_size must be known\")\n-            .bytes();\n-        self.object.append_section_data(\n-            init_array_section,\n-            &std::iter::repeat(0)\n-                .take(address_size.into())\n-                .collect::<Vec<u8>>(),\n-            8,\n-        );\n-        self.object\n-            .add_relocation(\n-                init_array_section,\n-                object::write::Relocation {\n-                    offset: 0,\n-                    size: address_size * 8,\n-                    kind: RelocationKind::Absolute,\n-                    encoding: RelocationEncoding::Generic,\n-                    symbol,\n-                    addend: 0,\n-                },\n-            )\n-            .unwrap();\n-    }\n-}\n-\n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n     let triple = crate::build_isa(sess).triple().clone();\n \n@@ -175,10 +126,9 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n         target_lexicon::Architecture::X86_64 => object::Architecture::X86_64,\n         target_lexicon::Architecture::Arm(_) => object::Architecture::Arm,\n         target_lexicon::Architecture::Aarch64(_) => object::Architecture::Aarch64,\n-        architecture => sess.fatal(&format!(\n-            \"target architecture {:?} is unsupported\",\n-            architecture,\n-        )),\n+        architecture => {\n+            sess.fatal(&format!(\"target architecture {:?} is unsupported\", architecture,))\n+        }\n     };\n     let endian = match triple.endianness().unwrap() {\n         target_lexicon::Endianness::Little => object::Endianness::Little,"}, {"sha": "0a7734d6a0443e6171fa6651b63d79c9f0fec7cd", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 82, "deletions": 189, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -8,7 +8,7 @@ use rustc_target::abi::call::FnAbi;\n use crate::prelude::*;\n \n pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    cx: &mut crate::CodegenCx<'_, 'tcx>,\n     instance: Instance<'tcx>,\n     linkage: Linkage,\n ) {\n@@ -38,9 +38,8 @@ pub(crate) fn codegen_fn<'tcx>(\n \n     // Predefine blocks\n     let start_block = bcx.create_block();\n-    let block_map: IndexVec<BasicBlock, Block> = (0..mir.basic_blocks().len())\n-        .map(|_| bcx.create_block())\n-        .collect();\n+    let block_map: IndexVec<BasicBlock, Block> =\n+        (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n     let pointer_type = cx.module.target_config().pointer_type();\n@@ -68,22 +67,23 @@ pub(crate) fn codegen_fn<'tcx>(\n         inline_asm_index: 0,\n     };\n \n-    let arg_uninhabited = fx.mir.args_iter().any(|arg| {\n-        fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty))\n-            .abi\n-            .is_uninhabited()\n-    });\n+    let arg_uninhabited = fx\n+        .mir\n+        .args_iter()\n+        .any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n \n-    if arg_uninhabited {\n-        fx.bcx\n-            .append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+    if !crate::constant::check_constants(&mut fx) {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        crate::trap::trap_unreachable(&mut fx, \"compilation should have been aborted\");\n+    } else if arg_uninhabited {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n         fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n         crate::trap::trap_unreachable(&mut fx, \"function has uninhabited argument\");\n     } else {\n         tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess.time(\"codegen prelude\", || {\n-                crate::abi::codegen_fn_prelude(&mut fx, start_block)\n-            });\n+            tcx.sess\n+                .time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n             codegen_fn_content(&mut fx);\n         });\n     }\n@@ -131,11 +131,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n-            .define_function(\n-                func_id,\n-                context,\n-                &mut cranelift_codegen::binemit::NullTrapSink {},\n-            )\n+            .define_function(func_id, context, &mut cranelift_codegen::binemit::NullTrapSink {})\n             .unwrap()\n     });\n \n@@ -149,14 +145,12 @@ pub(crate) fn codegen_fn<'tcx>(\n         &clif_comments,\n     );\n \n-    if let Some(mach_compile_result) = &context.mach_compile_result {\n-        if let Some(disasm) = &mach_compile_result.disasm {\n-            crate::pretty_clif::write_ir_file(\n-                tcx,\n-                &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n-                |file| file.write_all(disasm.as_bytes()),\n-            )\n-        }\n+    if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n+        crate::pretty_clif::write_ir_file(\n+            tcx,\n+            &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+            |file| file.write_all(disasm.as_bytes()),\n+        )\n     }\n \n     // Define debuginfo for function\n@@ -199,16 +193,13 @@ pub(crate) fn verify_func(\n                     Some(Box::new(writer)),\n                     err,\n                 );\n-                tcx.sess\n-                    .fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n+                tcx.sess.fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n             }\n         }\n     });\n }\n \n-fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    crate::constant::check_constants(fx);\n-\n+fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n     for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n@@ -231,11 +222,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n         #[cfg(debug_assertions)]\n         {\n             let mut terminator_head = \"\\n\".to_string();\n-            bb_data\n-                .terminator()\n-                .kind\n-                .fmt_head(&mut terminator_head)\n-                .unwrap();\n+            bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n             let inst = fx.bcx.func.layout.last_inst(block).unwrap();\n             fx.add_comment(inst, terminator_head);\n         }\n@@ -267,13 +254,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             TerminatorKind::Return => {\n                 crate::abi::codegen_return(fx);\n             }\n-            TerminatorKind::Assert {\n-                cond,\n-                expected,\n-                msg,\n-                target,\n-                cleanup: _,\n-            } => {\n+            TerminatorKind::Assert { cond, expected, msg, target, cleanup: _ } => {\n                 if !fx.tcx.sess.overflow_checks() {\n                     if let mir::AssertKind::OverflowNeg(_) = *msg {\n                         let target = fx.get_block(*target);\n@@ -319,11 +300,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                 }\n             }\n \n-            TerminatorKind::SwitchInt {\n-                discr,\n-                switch_ty,\n-                targets,\n-            } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty, targets } => {\n                 let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n                 let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n@@ -433,11 +410,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             | TerminatorKind::GeneratorDrop => {\n                 bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n-            TerminatorKind::Drop {\n-                place,\n-                target,\n-                unwind: _,\n-            } => {\n+            TerminatorKind::Drop { place, target, unwind: _ } => {\n                 let drop_place = codegen_place(fx, *place);\n                 crate::abi::codegen_drop(fx, bb_data.terminator().source_info.span, drop_place);\n \n@@ -452,7 +425,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n }\n \n fn codegen_stmt<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     #[allow(unused_variables)] cur_block: Block,\n     stmt: &Statement<'tcx>,\n ) {\n@@ -470,10 +443,7 @@ fn codegen_stmt<'tcx>(\n     }\n \n     match &stmt.kind {\n-        StatementKind::SetDiscriminant {\n-            place,\n-            variant_index,\n-        } => {\n+        StatementKind::SetDiscriminant { place, variant_index } => {\n             let place = codegen_place(fx, **place);\n             crate::discriminant::codegen_set_discriminant(fx, place, *variant_index);\n         }\n@@ -594,19 +564,11 @@ fn codegen_stmt<'tcx>(\n                     let from_ty = operand.layout().ty;\n                     let to_ty = fx.monomorphize(to_ty);\n \n-                    fn is_fat_ptr<'tcx>(\n-                        fx: &FunctionCx<'_, 'tcx, impl Module>,\n-                        ty: Ty<'tcx>,\n-                    ) -> bool {\n+                    fn is_fat_ptr<'tcx>(fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n                         ty.builtin_deref(true)\n-                            .map(\n-                                |ty::TypeAndMut {\n-                                     ty: pointee_ty,\n-                                     mutbl: _,\n-                                 }| {\n-                                    has_ptr_meta(fx.tcx, pointee_ty)\n-                                },\n-                            )\n+                            .map(|ty::TypeAndMut { ty: pointee_ty, mutbl: _ }| {\n+                                has_ptr_meta(fx.tcx, pointee_ty)\n+                            })\n                             .unwrap_or(false)\n                     }\n \n@@ -626,50 +588,22 @@ fn codegen_stmt<'tcx>(\n                             ty::Uint(_) | ty::Int(_) => {}\n                             _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n                         }\n+                        let to_clif_ty = fx.clif_type(to_ty).unwrap();\n \n-                        use rustc_target::abi::{Int, TagEncoding, Variants};\n-\n-                        match operand.layout().variants {\n-                            Variants::Single { index } => {\n-                                let discr = operand\n-                                    .layout()\n-                                    .ty\n-                                    .discriminant_for_variant(fx.tcx, index)\n-                                    .unwrap();\n-                                let discr = if discr.ty.is_signed() {\n-                                    fx.layout_of(discr.ty).size.sign_extend(discr.val)\n-                                } else {\n-                                    discr.val\n-                                };\n-                                let discr = discr.into();\n-\n-                                let discr = CValue::const_val(fx, fx.layout_of(to_ty), discr);\n-                                lval.write_cvalue(fx, discr);\n-                            }\n-                            Variants::Multiple {\n-                                ref tag,\n-                                tag_field,\n-                                tag_encoding: TagEncoding::Direct,\n-                                variants: _,\n-                            } => {\n-                                let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n-\n-                                // Read the tag/niche-encoded discriminant from memory.\n-                                let encoded_discr =\n-                                    operand.value_field(fx, mir::Field::new(tag_field));\n-                                let encoded_discr = encoded_discr.load_scalar(fx);\n-\n-                                // Decode the discriminant (specifically if it's niche-encoded).\n-                                let signed = match tag.value {\n-                                    Int(_, signed) => signed,\n-                                    _ => false,\n-                                };\n-                                let val = clif_intcast(fx, encoded_discr, cast_to, signed);\n-                                let val = CValue::by_val(val, dest_layout);\n-                                lval.write_cvalue(fx, val);\n-                            }\n-                            Variants::Multiple { .. } => unreachable!(),\n-                        }\n+                        let discriminant = crate::discriminant::codegen_get_discriminant(\n+                            fx,\n+                            operand,\n+                            fx.layout_of(operand.layout().ty.discriminant_ty(fx.tcx)),\n+                        )\n+                        .load_scalar(fx);\n+\n+                        let res = crate::cast::clif_intcast(\n+                            fx,\n+                            discriminant,\n+                            to_clif_ty,\n+                            to_ty.is_signed(),\n+                        );\n+                        lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n                     } else {\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n                         let from = operand.load_scalar(fx);\n@@ -730,8 +664,7 @@ fn codegen_stmt<'tcx>(\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx\n-                            .call_memset(fx.cx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.cx.module.target_config(), addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -766,36 +699,31 @@ fn codegen_stmt<'tcx>(\n                     let content_ty = fx.monomorphize(content_ty);\n                     let layout = fx.layout_of(content_ty);\n                     let llsize = fx.bcx.ins().iconst(usize_type, layout.size.bytes() as i64);\n-                    let llalign = fx\n-                        .bcx\n-                        .ins()\n-                        .iconst(usize_type, layout.align.abi.bytes() as i64);\n+                    let llalign = fx.bcx.ins().iconst(usize_type, layout.align.abi.bytes() as i64);\n                     let box_layout = fx.layout_of(fx.tcx.mk_box(content_ty));\n \n                     // Allocate space:\n-                    let def_id = match fx\n-                        .tcx\n-                        .lang_items()\n-                        .require(rustc_hir::LangItem::ExchangeMalloc)\n-                    {\n-                        Ok(id) => id,\n-                        Err(s) => {\n-                            fx.tcx\n-                                .sess\n-                                .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n-                        }\n-                    };\n+                    let def_id =\n+                        match fx.tcx.lang_items().require(rustc_hir::LangItem::ExchangeMalloc) {\n+                            Ok(id) => id,\n+                            Err(s) => {\n+                                fx.tcx\n+                                    .sess\n+                                    .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n+                            }\n+                        };\n                     let instance = ty::Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n                     let func_ref = fx.get_function_ref(instance);\n                     let call = fx.bcx.ins().call(func_ref, &[llsize, llalign]);\n                     let ptr = fx.bcx.inst_results(call)[0];\n                     lval.write_cvalue(fx, CValue::by_val(ptr, box_layout));\n                 }\n                 Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                    assert!(lval\n-                        .layout()\n-                        .ty\n-                        .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n+                    assert!(\n+                        lval.layout()\n+                            .ty\n+                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n+                    );\n                     let ty_size = fx.layout_of(fx.monomorphize(ty)).size.bytes();\n                     let val =\n                         CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), ty_size.into());\n@@ -823,11 +751,7 @@ fn codegen_stmt<'tcx>(\n \n         StatementKind::LlvmInlineAsm(asm) => {\n             use rustc_span::symbol::Symbol;\n-            let LlvmInlineAsm {\n-                asm,\n-                outputs,\n-                inputs,\n-            } = &**asm;\n+            let LlvmInlineAsm { asm, outputs, inputs } = &**asm;\n             let rustc_hir::LlvmInlineAsmInner {\n                 asm: asm_code,         // Name\n                 outputs: output_names, // Vec<LlvmInlineAsmOutput>\n@@ -843,15 +767,9 @@ fn codegen_stmt<'tcx>(\n                     // Black box\n                 }\n                 \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n-                    assert_eq!(\n-                        input_names,\n-                        &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]\n-                    );\n+                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n                     assert_eq!(output_names.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"])\n-                        .iter()\n-                        .enumerate()\n-                    {\n+                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n                         assert_eq!(&output_names[i].constraint.as_str(), c);\n                         assert!(!output_names[i].is_rw);\n                         assert!(!output_names[i].is_indirect);\n@@ -897,12 +815,7 @@ fn codegen_stmt<'tcx>(\n                     crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n                 }\n                 // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fx\n-                    .tcx\n-                    .symbol_name(fx.instance)\n-                    .name\n-                    .starts_with(\"___chkstk\") =>\n-                {\n+                _ if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n                     crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n                 }\n                 _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n@@ -922,27 +835,21 @@ fn codegen_stmt<'tcx>(\n     }\n }\n \n-fn codegen_array_len<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    place: CPlace<'tcx>,\n-) -> Value {\n+fn codegen_array_len<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, place: CPlace<'tcx>) -> Value {\n     match *place.layout().ty.kind() {\n         ty::Array(_elem_ty, len) => {\n-            let len = fx\n-                .monomorphize(len)\n-                .eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n+            let len = fx.monomorphize(len).eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n-        ty::Slice(_elem_ty) => place\n-            .to_ptr_maybe_unsized()\n-            .1\n-            .expect(\"Length metadata for slice place\"),\n+        ty::Slice(_elem_ty) => {\n+            place.to_ptr_maybe_unsized().1.expect(\"Length metadata for slice place\")\n+        }\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n     }\n }\n \n pub(crate) fn codegen_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: Place<'tcx>,\n ) -> CPlace<'tcx> {\n     let mut cplace = fx.get_local_place(place.local);\n@@ -959,11 +866,7 @@ pub(crate) fn codegen_place<'tcx>(\n                 let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n                 cplace = cplace.place_index(fx, index);\n             }\n-            PlaceElem::ConstantIndex {\n-                offset,\n-                min_length: _,\n-                from_end,\n-            } => {\n+            PlaceElem::ConstantIndex { offset, min_length: _, from_end } => {\n                 let offset: u64 = offset;\n                 let index = if !from_end {\n                     fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n@@ -1014,7 +917,7 @@ pub(crate) fn codegen_place<'tcx>(\n }\n \n pub(crate) fn codegen_operand<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> CValue<'tcx> {\n     match operand {\n@@ -1026,34 +929,24 @@ pub(crate) fn codegen_operand<'tcx>(\n     }\n }\n \n-pub(crate) fn codegen_panic<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    msg_str: &str,\n-    span: Span,\n-) {\n+pub(crate) fn codegen_panic<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, msg_str: &str, span: Span) {\n     let location = fx.get_caller_location(span).load_scalar(fx);\n \n     let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n-    let msg_len = fx\n-        .bcx\n-        .ins()\n-        .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+    let msg_len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n     let args = [msg_ptr, msg_len, location];\n \n     codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, span);\n }\n \n pub(crate) fn codegen_panic_inner<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     lang_item: rustc_hir::LangItem,\n     args: &[Value],\n     span: Span,\n ) {\n-    let def_id = fx\n-        .tcx\n-        .lang_items()\n-        .require(lang_item)\n-        .unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n+    let def_id =\n+        fx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n \n     let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n     let symbol_name = fx.tcx.symbol_name(instance).name;"}, {"sha": "983839d48d2d756ab0bbf5760668eac6854d4329", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -27,13 +27,7 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n         config.opts.cg.panic = Some(PanicStrategy::Abort);\n         config.opts.debugging_opts.panic_abort_tests = true;\n         config.opts.maybe_sysroot = Some(config.opts.maybe_sysroot.clone().unwrap_or_else(|| {\n-            std::env::current_exe()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .to_owned()\n+            std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_owned()\n         }));\n     }\n }"}, {"sha": "e7cd5edbbf654a2888e6b0ba4965da554f37f4a1", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -46,15 +46,8 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n \n         config.opts.cg.panic = Some(PanicStrategy::Abort);\n         config.opts.debugging_opts.panic_abort_tests = true;\n-        config.opts.maybe_sysroot = Some(\n-            std::env::current_exe()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .to_owned(),\n-        );\n+        config.opts.maybe_sysroot =\n+            Some(std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_owned());\n     }\n }\n "}, {"sha": "74c5e09f08da008decbad6a70710b106adb4b0bf", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -3,7 +3,7 @@\n use crate::prelude::*;\n \n pub(crate) fn clif_intcast(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     val: Value,\n     to: Type,\n     signed: bool,\n@@ -40,18 +40,14 @@ pub(crate) fn clif_intcast(\n         // reduce\n         (types::I128, _) => {\n             let (lsb, _msb) = fx.bcx.ins().isplit(val);\n-            if to == types::I64 {\n-                lsb\n-            } else {\n-                fx.bcx.ins().ireduce(to, lsb)\n-            }\n+            if to == types::I64 { lsb } else { fx.bcx.ins().ireduce(to, lsb) }\n         }\n         (_, _) => fx.bcx.ins().ireduce(to, val),\n     }\n }\n \n pub(crate) fn clif_int_or_float_cast(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     from: Value,\n     from_signed: bool,\n     to_ty: Type,\n@@ -87,11 +83,7 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n \n             let to_rust_ty = match to_ty {\n                 types::F32 => fx.tcx.types.f32,\n@@ -100,11 +92,7 @@ pub(crate) fn clif_int_or_float_cast(\n             };\n \n             return fx\n-                .easy_call(\n-                    &name,\n-                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                    to_rust_ty,\n-                )\n+                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n                 .load_scalar(fx);\n         }\n \n@@ -138,18 +126,10 @@ pub(crate) fn clif_int_or_float_cast(\n                 _ => unreachable!(),\n             };\n \n-            let to_rust_ty = if to_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n \n             return fx\n-                .easy_call(\n-                    &name,\n-                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                    to_rust_ty,\n-                )\n+                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n                 .load_scalar(fx);\n         }\n "}, {"sha": "ae75e6508cb0bac04150342c238c9453221e85a4", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 17, "deletions": 68, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -5,13 +5,17 @@ use cranelift_codegen::ir::ArgumentPurpose;\n use crate::prelude::*;\n \n pub(crate) fn maybe_codegen<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     checked: bool,\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n ) -> Option<CValue<'tcx>> {\n-    if lhs.layout().ty != fx.tcx.types.u128 && lhs.layout().ty != fx.tcx.types.i128 {\n+    if lhs.layout().ty != fx.tcx.types.u128\n+        && lhs.layout().ty != fx.tcx.types.i128\n+        && rhs.layout().ty != fx.tcx.types.u128\n+        && rhs.layout().ty != fx.tcx.types.i128\n+    {\n         return None;\n     }\n \n@@ -27,11 +31,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked => {\n-            let val_ty = if is_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n             Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n@@ -43,11 +43,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 AbiParam::new(types::I128),\n                 AbiParam::new(types::I128),\n             ];\n-            let args = [\n-                out_place.to_ptr().get_addr(fx),\n-                lhs.load_scalar(fx),\n-                rhs.load_scalar(fx),\n-            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -97,70 +93,23 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 None\n             };\n \n-            // Optimize `val >> 64`, because compiler_builtins uses it to deconstruct an 128bit\n-            // integer into its lsb and msb.\n-            // https://github.com/rust-lang-nursery/compiler-builtins/blob/79a6a1603d5672cbb9187ff41ff4d9b5048ac1cb/src/int/mod.rs#L217\n-            if resolve_value_imm(fx.bcx.func, rhs_val) == Some(64) {\n-                let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n-                let all_zeros = fx.bcx.ins().iconst(types::I64, 0);\n-                let val = match (bin_op, is_signed) {\n-                    (BinOp::Shr, false) => {\n-                        let val = fx.bcx.ins().iconcat(lhs_msb, all_zeros);\n-                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.u128)))\n-                    }\n-                    (BinOp::Shr, true) => {\n-                        let sign = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, lhs_msb, 0);\n-                        let all_ones = fx.bcx.ins().iconst(types::I64, u64::MAX as i64);\n-                        let all_sign_bits = fx.bcx.ins().select(sign, all_zeros, all_ones);\n-\n-                        let val = fx.bcx.ins().iconcat(lhs_msb, all_sign_bits);\n-                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.i128)))\n-                    }\n-                    (BinOp::Shl, _) => {\n-                        let val_ty = if is_signed {\n-                            fx.tcx.types.i128\n-                        } else {\n-                            fx.tcx.types.u128\n-                        };\n-                        let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n-                        Some(CValue::by_val(val, fx.layout_of(val_ty)))\n-                    }\n-                    _ => None,\n-                };\n-                if let Some(val) = val {\n-                    if let Some(is_overflow) = is_overflow {\n-                        let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                        let val = val.load_scalar(fx);\n-                        return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)));\n+            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n+            let val = match bin_op {\n+                BinOp::Shl => fx.bcx.ins().ishl(lhs_val, truncated_rhs),\n+                BinOp::Shr => {\n+                    if is_signed {\n+                        fx.bcx.ins().sshr(lhs_val, truncated_rhs)\n                     } else {\n-                        return Some(val);\n+                        fx.bcx.ins().ushr(lhs_val, truncated_rhs)\n                     }\n                 }\n-            }\n-\n-            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n-            let truncated_rhs = CValue::by_val(truncated_rhs, fx.layout_of(fx.tcx.types.u32));\n-            let val = match (bin_op, is_signed) {\n-                (BinOp::Shl, false) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n-                }\n-                (BinOp::Shl, true) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n-                }\n-                (BinOp::Shr, false) => {\n-                    fx.easy_call(\"__lshrti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n-                }\n-                (BinOp::Shr, true) => {\n-                    fx.easy_call(\"__ashrti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n-                }\n-                (_, _) => unreachable!(),\n+                _ => unreachable!(),\n             };\n             if let Some(is_overflow) = is_overflow {\n                 let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                let val = val.load_scalar(fx);\n                 Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n             } else {\n-                Some(val)\n+                Some(CValue::by_val(val, lhs.layout()))\n             }\n         }\n     }"}, {"sha": "6a4a6744a5cf7bc469c1f01f00437f9b38cdad37", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 21, "deletions": 90, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -3,8 +3,6 @@ use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n-use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n-\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -56,11 +54,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n             FloatTy::F64 => types::F64,\n         },\n         ty::FnPtr(_) => pointer_ty(tcx),\n-        ty::RawPtr(TypeAndMut {\n-            ty: pointee_ty,\n-            mutbl: _,\n-        })\n-        | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 return None;\n             } else {\n@@ -99,11 +93,7 @@ fn clif_pair_type_from_ty<'tcx>(\n             }\n             (a, b)\n         }\n-        ty::RawPtr(TypeAndMut {\n-            ty: pointee_ty,\n-            mutbl: _,\n-        })\n-        | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 (pointer_ty(tcx), pointer_ty(tcx))\n             } else {\n@@ -116,23 +106,16 @@ fn clif_pair_type_from_ty<'tcx>(\n \n /// Is a pointer to this type a fat ptr?\n pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    let ptr_ty = tcx.mk_ptr(TypeAndMut {\n-        ty,\n-        mutbl: rustc_hir::Mutability::Not,\n-    });\n-    match &tcx\n-        .layout_of(ParamEnv::reveal_all().and(ptr_ty))\n-        .unwrap()\n-        .abi\n-    {\n+    let ptr_ty = tcx.mk_ptr(TypeAndMut { ty, mutbl: rustc_hir::Mutability::Not });\n+    match &tcx.layout_of(ParamEnv::reveal_all().and(ptr_ty)).unwrap().abi {\n         Abi::Scalar(_) => false,\n         Abi::ScalarPair(_, _) => true,\n         abi => unreachable!(\"Abi of ptr to {:?} is {:?}???\", ty, abi),\n     }\n }\n \n pub(crate) fn codegen_icmp_imm(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     intcc: IntCC,\n     lhs: Value,\n     rhs: i128,\n@@ -175,51 +158,6 @@ pub(crate) fn codegen_icmp_imm(\n     }\n }\n \n-fn resolve_normal_value_imm(func: &Function, val: Value) -> Option<i64> {\n-    if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n-        if let InstructionData::UnaryImm {\n-            opcode: Opcode::Iconst,\n-            imm,\n-        } = func.dfg[inst]\n-        {\n-            Some(imm.into())\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn resolve_128bit_value_imm(func: &Function, val: Value) -> Option<u128> {\n-    let (lsb, msb) = if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n-        if let InstructionData::Binary {\n-            opcode: Opcode::Iconcat,\n-            args: [lsb, msb],\n-        } = func.dfg[inst]\n-        {\n-            (lsb, msb)\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        return None;\n-    };\n-\n-    let lsb = u128::from(resolve_normal_value_imm(func, lsb)? as u64);\n-    let msb = u128::from(resolve_normal_value_imm(func, msb)? as u64);\n-\n-    Some(msb << 64 | lsb)\n-}\n-\n-pub(crate) fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n-    if func.dfg.value_type(val) == types::I128 {\n-        resolve_128bit_value_imm(func, val)\n-    } else {\n-        resolve_normal_value_imm(func, val).map(|imm| u128::from(imm as u64))\n-    }\n-}\n-\n pub(crate) fn type_min_max_value(\n     bcx: &mut FunctionBuilder<'_>,\n     ty: Type,\n@@ -288,8 +226,8 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n-pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx, M>,\n+pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'m, 'tcx>,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n \n@@ -316,7 +254,7 @@ pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n     pub(crate) inline_asm_index: u32,\n }\n \n-impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> LayoutOf for FunctionCx<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n@@ -325,31 +263,31 @@ impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n     }\n }\n \n-impl<'tcx, M: Module> layout::HasTyCtxt<'tcx> for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> layout::HasTyCtxt<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'tcx, M: Module> rustc_target::abi::HasDataLayout for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> rustc_target::abi::HasDataLayout for FunctionCx<'_, '_, 'tcx> {\n     fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'tcx, M: Module> layout::HasParamEnv<'tcx> for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> layout::HasParamEnv<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn param_env(&self) -> ParamEnv<'tcx> {\n         ParamEnv::reveal_all()\n     }\n }\n \n-impl<'tcx, M: Module> HasTargetSpec for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> HasTargetSpec for FunctionCx<'_, '_, 'tcx> {\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target\n     }\n }\n \n-impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     pub(crate) fn monomorphize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n@@ -416,12 +354,7 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         let msg_id = self\n             .cx\n             .module\n-            .declare_data(\n-                &format!(\"__{}_{:08x}\", prefix, msg_hash),\n-                Linkage::Local,\n-                false,\n-                false,\n-            )\n+            .declare_data(&format!(\"__{}_{:08x}\", prefix, msg_hash), Linkage::Local, false, false)\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n@@ -444,15 +377,13 @@ impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n         assert!(!ty.still_further_specializable());\n-        self.0\n-            .layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| {\n-                if let layout::LayoutError::SizeOverflow(_) = e {\n-                    self.0.sess.fatal(&e.to_string())\n-                } else {\n-                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n+        self.0.layout_of(ParamEnv::reveal_all().and(&ty)).unwrap_or_else(|e| {\n+            if let layout::LayoutError::SizeOverflow(_) = e {\n+                self.0.sess.fatal(&e.to_string())\n+            } else {\n+                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+            }\n+        })\n     }\n }\n "}, {"sha": "b0639cf9e15fe70839956ee2e18dbcdea2120d6f", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 40, "deletions": 78, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -28,29 +28,28 @@ enum TodoItem {\n }\n \n impl ConstantCx {\n-    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut impl Module) {\n+    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut dyn Module) {\n         //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n         //println!(\"done {:?}\", self.done);\n         self.done.clear();\n     }\n }\n \n-pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n+    let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n         let const_ = fx.monomorphize(constant.literal);\n         match const_.val {\n             ConstKind::Value(_) => {}\n             ConstKind::Unevaluated(def, ref substs, promoted) => {\n                 if let Err(err) =\n-                    fx.tcx\n-                        .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n+                    fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n                 {\n+                    all_constants_ok = false;\n                     match err {\n                         ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n-                            fx.tcx\n-                                .sess\n-                                .span_err(constant.span, \"erroneous constant encountered\");\n+                            fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n                         }\n                         ErrorHandled::TooGeneric => {\n                             span_bug!(\n@@ -69,18 +68,19 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n         }\n     }\n+    all_constants_ok\n }\n \n pub(crate) fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n     constants_cx.todo.push(TodoItem::Static(def_id));\n }\n \n pub(crate) fn codegen_tls_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n@@ -89,11 +89,11 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n }\n \n fn codegen_static_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n@@ -110,7 +110,7 @@ fn codegen_static_ref<'tcx>(\n }\n \n pub(crate) fn codegen_constant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n     let const_ = fx.monomorphize(constant.literal);\n@@ -128,20 +128,10 @@ pub(crate) fn codegen_constant<'tcx>(\n             .to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(def, ref substs, promoted) => {\n-            match fx\n-                .tcx\n-                .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n-            {\n+            match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n                 Ok(const_val) => const_val,\n                 Err(_) => {\n-                    fx.tcx\n-                        .sess\n-                        .span_err(constant.span, \"erroneous constant encountered\");\n-                    return crate::trap::trap_unreachable_ret_value(\n-                        fx,\n-                        fx.layout_of(const_.ty),\n-                        \"erroneous constant encountered\",\n-                    );\n+                    span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n                 }\n             }\n         }\n@@ -156,7 +146,7 @@ pub(crate) fn codegen_constant<'tcx>(\n }\n \n pub(crate) fn codegen_const_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     const_val: ConstValue<'tcx>,\n     ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n@@ -172,9 +162,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n             if fx.clif_type(layout.ty).is_none() {\n                 let (size, align) = (layout.size, layout.align.pref);\n                 let mut alloc = Allocation::from_bytes(\n-                    std::iter::repeat(0)\n-                        .take(size.bytes_usize())\n-                        .collect::<Vec<u8>>(),\n+                    std::iter::repeat(0).take(size.bytes_usize()).collect::<Vec<u8>>(),\n                     align,\n                 );\n                 let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n@@ -190,11 +178,8 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id = data_id_for_alloc_id(\n-                                &mut fx.cx.module,\n-                                ptr.alloc_id,\n-                                alloc.mutability,\n-                            );\n+                            let data_id =\n+                                data_id_for_alloc_id(fx.cx.module, ptr.alloc_id, alloc.mutability);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n@@ -203,15 +188,14 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n                             let func_id =\n-                                crate::abi::import_function(fx.tcx, &mut fx.cx.module, instance);\n+                                crate::abi::import_function(fx.tcx, fx.cx.module, instance);\n                             let local_func_id =\n                                 fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id =\n-                                data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+                            let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n@@ -221,9 +205,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n                     };\n                     let val = if ptr.offset.bytes() != 0 {\n-                        fx.bcx\n-                            .ins()\n-                            .iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n+                        fx.bcx.ins().iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n                     } else {\n                         base_addr\n                     };\n@@ -240,22 +222,22 @@ pub(crate) fn codegen_const_value<'tcx>(\n             let ptr = pointer_for_allocation(fx, data)\n                 .offset_i64(fx, i64::try_from(start).unwrap())\n                 .get_addr(fx);\n-            let len = fx.bcx.ins().iconst(\n-                fx.pointer_type,\n-                i64::try_from(end.checked_sub(start).unwrap()).unwrap(),\n-            );\n+            let len = fx\n+                .bcx\n+                .ins()\n+                .iconst(fx.pointer_type, i64::try_from(end.checked_sub(start).unwrap()).unwrap());\n             CValue::by_val_pair(ptr, len, layout)\n         }\n     }\n }\n \n fn pointer_for_allocation<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n     fx.cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-    let data_id = data_id_for_alloc_id(&mut fx.cx.module, alloc_id, alloc.mutability);\n+    let data_id = data_id_for_alloc_id(fx.cx.module, alloc_id, alloc.mutability);\n \n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n@@ -265,7 +247,7 @@ fn pointer_for_allocation<'tcx>(\n }\n \n fn data_id_for_alloc_id(\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     alloc_id: AllocId,\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n@@ -281,7 +263,7 @@ fn data_id_for_alloc_id(\n \n fn data_id_for_static(\n     tcx: TyCtxt<'_>,\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     def_id: DefId,\n     definition: bool,\n ) -> DataId {\n@@ -304,12 +286,7 @@ fn data_id_for_static(\n     } else {\n         !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n     };\n-    let align = tcx\n-        .layout_of(ParamEnv::reveal_all().and(ty))\n-        .unwrap()\n-        .align\n-        .pref\n-        .bytes();\n+    let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n \n     let attrs = tcx.codegen_fn_attrs(def_id);\n \n@@ -332,17 +309,11 @@ fn data_id_for_static(\n         // zero.\n \n         let ref_name = format!(\"_rust_extern_with_linkage_{}\", symbol_name);\n-        let ref_data_id = module\n-            .declare_data(&ref_name, Linkage::Local, false, false)\n-            .unwrap();\n+        let ref_data_id = module.declare_data(&ref_name, Linkage::Local, false, false).unwrap();\n         let mut data_ctx = DataContext::new();\n         data_ctx.set_align(align);\n         let data = module.declare_data_in_data(data_id, &mut data_ctx);\n-        data_ctx.define(\n-            std::iter::repeat(0)\n-                .take(pointer_ty(tcx).bytes() as usize)\n-                .collect(),\n-        );\n+        data_ctx.define(std::iter::repeat(0).take(pointer_ty(tcx).bytes() as usize).collect());\n         data_ctx.write_data_addr(0, data, 0);\n         match module.define_data(ref_data_id, &data_ctx) {\n             // Every time the static is referenced there will be another definition of this global,\n@@ -356,7 +327,7 @@ fn data_id_for_static(\n     }\n }\n \n-fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut ConstantCx) {\n+fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut ConstantCx) {\n     while let Some(todo_item) = cx.todo.pop() {\n         let (data_id, alloc, section_name) = match todo_item {\n             TodoItem::Alloc(alloc_id) => {\n@@ -371,10 +342,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             TodoItem::Static(def_id) => {\n                 //println!(\"static {:?}\", def_id);\n \n-                let section_name = tcx\n-                    .codegen_fn_attrs(def_id)\n-                    .link_section\n-                    .map(|s| s.as_str());\n+                let section_name = tcx.codegen_fn_attrs(def_id).link_section.map(|s| s.as_str());\n \n                 let alloc = tcx.eval_static_initializer(def_id).unwrap();\n \n@@ -396,9 +364,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             data_ctx.set_segment_section(\"\", &*section_name);\n         }\n \n-        let bytes = alloc\n-            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n-            .to_vec();\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n         for &(offset, (_tag, reloc)) in alloc.relocations().iter() {\n@@ -426,10 +392,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n                     data_id_for_alloc_id(module, reloc, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n-                    if tcx\n-                        .codegen_fn_attrs(def_id)\n-                        .flags\n-                        .contains(CodegenFnAttrFlags::THREAD_LOCAL)\n+                    if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n                     {\n                         tcx.sess.fatal(&format!(\n                             \"Allocation {:?} contains reference to TLS value {:?}\",\n@@ -457,14 +420,13 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n }\n \n pub(crate) fn mir_operand_get_const_val<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> Option<&'tcx Const<'tcx>> {\n     match operand {\n         Operand::Copy(_) | Operand::Move(_) => None,\n-        Operand::Constant(const_) => Some(\n-            fx.monomorphize(const_.literal)\n-                .eval(fx.tcx, ParamEnv::reveal_all()),\n-        ),\n+        Operand::Constant(const_) => {\n+            Some(fx.monomorphize(const_.literal).eval(fx.tcx, ParamEnv::reveal_all()))\n+        }\n     }\n }"}, {"sha": "6018eefcd42fb4ae4b196729bed6ecbe19d33dc8", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -14,10 +14,7 @@ impl DebugContext<'_> {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();\n         let root = self.dwarf.unit.get_mut(root);\n-        root.set(\n-            gimli::DW_AT_ranges,\n-            AttributeValue::RangeListRef(unit_range_list_id),\n-        );\n+        root.set(gimli::DW_AT_ranges, AttributeValue::RangeListRef(unit_range_list_id));\n \n         let mut sections = Sections::new(WriterRelocate::new(self.endian));\n         self.dwarf.write(&mut sections).unwrap();\n@@ -66,10 +63,7 @@ pub(super) struct WriterRelocate {\n \n impl WriterRelocate {\n     pub(super) fn new(endian: RunTimeEndian) -> Self {\n-        WriterRelocate {\n-            relocs: Vec::new(),\n-            writer: EndianVec::new(endian),\n-        }\n+        WriterRelocate { relocs: Vec::new(), writer: EndianVec::new(endian) }\n     }\n \n     /// Perform the collected relocations to be usable for JIT usage.\n@@ -85,9 +79,7 @@ impl WriterRelocate {\n                         cranelift_module::FuncId::from_u32(sym.try_into().unwrap()),\n                     );\n                     let val = (addr as u64 as i64 + reloc.addend) as u64;\n-                    self.writer\n-                        .write_udata_at(reloc.offset as usize, val, reloc.size)\n-                        .unwrap();\n+                    self.writer.write_udata_at(reloc.offset as usize, val, reloc.size).unwrap();\n                 }\n             }\n         }"}, {"sha": "30ed356c7627f65b9ec6da55b3ca4a8a6094997b", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 18, "deletions": 57, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -53,11 +53,7 @@ pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n-        Some(FileInfo {\n-            timestamp: 0,\n-            size: 0,\n-            md5: buf,\n-        })\n+        Some(FileInfo { timestamp: 0, size: 0, md5: buf })\n     } else {\n         None\n     }\n@@ -112,24 +108,14 @@ impl<'tcx> DebugContext<'tcx> {\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n \n-        entry.set(\n-            gimli::DW_AT_decl_file,\n-            AttributeValue::FileIndex(Some(file_id)),\n-        );\n-        entry.set(\n-            gimli::DW_AT_decl_line,\n-            AttributeValue::Udata(loc.line as u64),\n-        );\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n         // FIXME: probably omit this\n-        entry.set(\n-            gimli::DW_AT_decl_column,\n-            AttributeValue::Udata(loc.col.to_usize() as u64),\n-        );\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n     }\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n-        isa: &dyn cranelift_codegen::isa::TargetIsa,\n         symbol: usize,\n         entry_id: UnitEntryId,\n         context: &Context,\n@@ -138,7 +124,6 @@ impl<'tcx> DebugContext<'tcx> {\n     ) -> CodeOffset {\n         let tcx = self.tcx;\n         let line_program = &mut self.dwarf.unit.line_program;\n-        let func = &context.func;\n \n         let line_strings = &mut self.dwarf.line_strings;\n         let mut last_span = None;\n@@ -202,54 +187,30 @@ impl<'tcx> DebugContext<'tcx> {\n \n         let mut func_end = 0;\n \n-        if let Some(ref mcr) = &context.mach_compile_result {\n-            for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-                line_program.row().address_offset = u64::from(start);\n-                if !loc.is_default() {\n-                    let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                    create_row_for_span(line_program, source_info.span);\n-                } else {\n-                    create_row_for_span(line_program, function_span);\n-                }\n-                func_end = end;\n-            }\n-\n-            line_program.end_sequence(u64::from(func_end));\n-\n-            func_end = mcr.buffer.total_size();\n-        } else {\n-            let encinfo = isa.encoding_info();\n-            let mut blocks = func.layout.blocks().collect::<Vec<_>>();\n-            blocks.sort_by_key(|block| func.offsets[*block]); // Ensure inst offsets always increase\n-\n-            for block in blocks {\n-                for (offset, inst, size) in func.inst_offsets(block, &encinfo) {\n-                    let srcloc = func.srclocs[inst];\n-                    line_program.row().address_offset = u64::from(offset);\n-                    if !srcloc.is_default() {\n-                        let source_info =\n-                            *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n-                        create_row_for_span(line_program, source_info.span);\n-                    } else {\n-                        create_row_for_span(line_program, function_span);\n-                    }\n-                    func_end = offset + size;\n-                }\n+        let mcr = context.mach_compile_result.as_ref().unwrap();\n+        for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n+            line_program.row().address_offset = u64::from(start);\n+            if !loc.is_default() {\n+                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(line_program, source_info.span);\n+            } else {\n+                create_row_for_span(line_program, function_span);\n             }\n-            line_program.end_sequence(u64::from(func_end));\n+            func_end = end;\n         }\n \n+        line_program.end_sequence(u64::from(func_end));\n+\n+        let func_end = mcr.buffer.total_size();\n+\n         assert_ne!(func_end, 0);\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n-        entry.set(\n-            gimli::DW_AT_high_pc,\n-            AttributeValue::Udata(u64::from(func_end)),\n-        );\n+        entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n         self.emit_location(entry_id, function_span);\n "}, {"sha": "dc8bc8d9cb74147814e27809f1e7e20457df6885", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 26, "deletions": 131, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -9,7 +9,7 @@ use crate::prelude::*;\n use rustc_index::vec::IndexVec;\n \n use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{StackSlots, ValueLabel, ValueLoc};\n+use cranelift_codegen::ir::{LabelValueLoc, StackSlots, ValueLabel, ValueLoc};\n use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::ValueLocRange;\n \n@@ -39,7 +39,6 @@ pub(crate) struct DebugContext<'tcx> {\n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n \n-    clif_types: FxHashMap<Type, UnitEntryId>,\n     types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n }\n \n@@ -91,20 +90,11 @@ impl<'tcx> DebugContext<'tcx> {\n \n             let root = dwarf.unit.root();\n             let root = dwarf.unit.get_mut(root);\n-            root.set(\n-                gimli::DW_AT_producer,\n-                AttributeValue::StringRef(dwarf.strings.add(producer)),\n-            );\n-            root.set(\n-                gimli::DW_AT_language,\n-                AttributeValue::Language(gimli::DW_LANG_Rust),\n-            );\n+            root.set(gimli::DW_AT_producer, AttributeValue::StringRef(dwarf.strings.add(producer)));\n+            root.set(gimli::DW_AT_language, AttributeValue::Language(gimli::DW_LANG_Rust));\n             root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n             root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n-            root.set(\n-                gimli::DW_AT_low_pc,\n-                AttributeValue::Address(Address::Constant(0)),\n-            );\n+            root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n         DebugContext {\n@@ -115,48 +105,10 @@ impl<'tcx> DebugContext<'tcx> {\n             dwarf,\n             unit_range_list: RangeList(Vec::new()),\n \n-            clif_types: FxHashMap::default(),\n             types: FxHashMap::default(),\n         }\n     }\n \n-    fn dwarf_ty_for_clif_ty(&mut self, ty: Type) -> UnitEntryId {\n-        if let Some(type_id) = self.clif_types.get(&ty) {\n-            return *type_id;\n-        }\n-\n-        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n-\n-        let primitive = |dwarf: &mut DwarfUnit, ate| {\n-            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n-            let type_entry = dwarf.unit.get_mut(type_id);\n-            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n-            type_id\n-        };\n-\n-        let type_id = if ty.is_bool() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_boolean)\n-        } else if ty.is_int() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_address)\n-        } else if ty.is_float() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_float)\n-        } else {\n-            new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type)\n-        };\n-\n-        let type_entry = self.dwarf.unit.get_mut(type_id);\n-        type_entry.set(\n-            gimli::DW_AT_name,\n-            AttributeValue::String(format!(\"{}\", ty).replace('i', \"u\").into_bytes()),\n-        );\n-        type_entry.set(\n-            gimli::DW_AT_byte_size,\n-            AttributeValue::Udata(u64::from(ty.bytes())),\n-        );\n-\n-        type_id\n-    }\n-\n     fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n         if let Some(type_id) = self.types.get(ty) {\n             return *type_id;\n@@ -181,10 +133,7 @@ impl<'tcx> DebugContext<'tcx> {\n             ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n             ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n             ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut {\n-                ty: pointee_ty,\n-                mutbl: _mutbl,\n-            }) => {\n+            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n                 let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n \n                 // Ensure that type is inserted before recursing to avoid duplicates\n@@ -211,10 +160,7 @@ impl<'tcx> DebugContext<'tcx> {\n                     let field_offset = layout.fields.offset(field_idx);\n                     let field_layout = layout\n                         .field(\n-                            &layout::LayoutCx {\n-                                tcx: self.tcx,\n-                                param_env: ParamEnv::reveal_all(),\n-                            },\n+                            &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n                             field_idx,\n                         )\n                         .unwrap();\n@@ -243,10 +189,7 @@ impl<'tcx> DebugContext<'tcx> {\n         let type_entry = self.dwarf.unit.get_mut(type_id);\n \n         type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(\n-            gimli::DW_AT_byte_size,\n-            AttributeValue::Udata(layout.size.bytes()),\n-        );\n+        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n \n         self.types.insert(ty, type_id);\n \n@@ -286,23 +229,15 @@ impl<'tcx> DebugContext<'tcx> {\n         let name_id = self.dwarf.strings.add(name);\n         // Gdb requires DW_AT_name. Otherwise the DW_TAG_subprogram is skipped.\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n-        entry.set(\n-            gimli::DW_AT_linkage_name,\n-            AttributeValue::StringRef(name_id),\n-        );\n+        entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n-        let end =\n-            self.create_debug_lines(isa, symbol, entry_id, context, mir.span, source_info_set);\n+        let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n \n         self.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },\n             length: u64::from(end),\n         });\n \n-        if isa.get_mach_backend().is_some() {\n-            return; // Not yet implemented for the AArch64 backend.\n-        }\n-\n         let func_entry = self.dwarf.unit.get_mut(entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n         func_entry.set(\n@@ -312,51 +247,6 @@ impl<'tcx> DebugContext<'tcx> {\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n \n-        // FIXME Remove once actual debuginfo for locals works.\n-        for (i, (param, &val)) in context\n-            .func\n-            .signature\n-            .params\n-            .iter()\n-            .zip(\n-                context\n-                    .func\n-                    .dfg\n-                    .block_params(context.func.layout.entry_block().unwrap()),\n-            )\n-            .enumerate()\n-        {\n-            use cranelift_codegen::ir::ArgumentPurpose;\n-            let base_name = match param.purpose {\n-                ArgumentPurpose::Normal => \"arg\",\n-                ArgumentPurpose::StructArgument(_) => \"struct_arg\",\n-                ArgumentPurpose::StructReturn => \"sret\",\n-                ArgumentPurpose::Link\n-                | ArgumentPurpose::FramePointer\n-                | ArgumentPurpose::CalleeSaved => continue,\n-                ArgumentPurpose::VMContext\n-                | ArgumentPurpose::SignatureId\n-                | ArgumentPurpose::CallerTLS\n-                | ArgumentPurpose::CalleeTLS\n-                | ArgumentPurpose::StackLimit => unreachable!(),\n-            };\n-            let name = format!(\"{}{}\", base_name, i);\n-\n-            let dw_ty = self.dwarf_ty_for_clif_ty(param.value_type);\n-            let loc =\n-                translate_loc(isa, context.func.locations[val], &context.func.stack_slots).unwrap();\n-\n-            let arg_id = self\n-                .dwarf\n-                .unit\n-                .add(entry_id, gimli::DW_TAG_formal_parameter);\n-            let var_entry = self.dwarf.unit.get_mut(arg_id);\n-\n-            var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-            var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n-            var_entry.set(gimli::DW_AT_location, AttributeValue::Exprloc(loc));\n-        }\n-\n         // FIXME make it more reliable and implement scopes before re-enabling this.\n         if false {\n             let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n@@ -376,10 +266,7 @@ impl<'tcx> DebugContext<'tcx> {\n                     context,\n                     &local_map,\n                     &value_labels_ranges,\n-                    Place {\n-                        local,\n-                        projection: ty::List::empty(),\n-                    },\n+                    Place { local, projection: ty::List::empty() },\n                 );\n \n                 let var_entry = self.dwarf.unit.get_mut(var_id);\n@@ -417,10 +304,7 @@ fn place_location<'tcx>(\n                                 symbol,\n                                 addend: i64::from(value_loc_range.start),\n                             },\n-                            end: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.end),\n-                            },\n+                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n                             data: translate_loc(\n                                 isa,\n                                 value_loc_range.loc,\n@@ -463,17 +347,17 @@ fn place_location<'tcx>(\n // Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n fn translate_loc(\n     isa: &dyn TargetIsa,\n-    loc: ValueLoc,\n+    loc: LabelValueLoc,\n     stack_slots: &StackSlots,\n ) -> Option<Expression> {\n     match loc {\n-        ValueLoc::Reg(reg) => {\n+        LabelValueLoc::ValueLoc(ValueLoc::Reg(reg)) => {\n             let machine_reg = isa.map_dwarf_register(reg).unwrap();\n             let mut expr = Expression::new();\n             expr.op_reg(gimli::Register(machine_reg));\n             Some(expr)\n         }\n-        ValueLoc::Stack(ss) => {\n+        LabelValueLoc::ValueLoc(ValueLoc::Stack(ss)) => {\n             if let Some(ss_offset) = stack_slots[ss].offset {\n                 let mut expr = Expression::new();\n                 expr.op_breg(X86_64::RBP, i64::from(ss_offset) + 16);\n@@ -482,6 +366,17 @@ fn translate_loc(\n                 None\n             }\n         }\n-        _ => None,\n+        LabelValueLoc::ValueLoc(ValueLoc::Unassigned) => unreachable!(),\n+        LabelValueLoc::Reg(reg) => {\n+            let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n+            let mut expr = Expression::new();\n+            expr.op_reg(gimli::Register(machine_reg));\n+            Some(expr)\n+        }\n+        LabelValueLoc::SPOffset(offset) => {\n+            let mut expr = Expression::new();\n+            expr.op_breg(X86_64::RSP, offset);\n+            Some(expr)\n+        }\n     }\n }"}, {"sha": "357c9fe6ed83a08e19e022c259a84b1b1a23ed36", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -28,11 +28,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             None\n         };\n \n-        UnwindContext {\n-            tcx,\n-            frame_table,\n-            cie_id,\n-        }\n+        UnwindContext { tcx, frame_table, cie_id }\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n@@ -46,10 +42,8 @@ impl<'tcx> UnwindContext<'tcx> {\n             UnwindInfo::SystemV(unwind_info) => {\n                 self.frame_table.add_fde(\n                     self.cie_id.unwrap(),\n-                    unwind_info.to_fde(Address::Symbol {\n-                        symbol: func_id.as_u32() as usize,\n-                        addend: 0,\n-                    }),\n+                    unwind_info\n+                        .to_fde(Address::Symbol { symbol: func_id.as_u32() as usize, addend: 0 }),\n                 );\n             }\n             UnwindInfo::WindowsX64(_) => {\n@@ -60,9 +54,8 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n-            self.tcx,\n-        )));\n+        let mut eh_frame =\n+            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -82,9 +75,8 @@ impl<'tcx> UnwindContext<'tcx> {\n         self,\n         jit_module: &cranelift_jit::JITModule,\n     ) -> Option<UnwindRegistry> {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n-            self.tcx,\n-        )));\n+        let mut eh_frame =\n+            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {\n@@ -130,10 +122,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             registrations.push(ptr as usize);\n         }\n \n-        Some(UnwindRegistry {\n-            _frame_table: eh_frame,\n-            registrations,\n-        })\n+        Some(UnwindRegistry { _frame_table: eh_frame, registrations })\n     }\n }\n "}, {"sha": "3326f87f000757099e3a9940de6677609889b533", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -7,7 +7,7 @@ use rustc_target::abi::{Int, TagEncoding, Variants};\n use crate::prelude::*;\n \n pub(crate) fn codegen_set_discriminant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     variant_index: VariantIdx,\n ) {\n@@ -26,11 +26,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             variants: _,\n         } => {\n             let ptr = place.place_field(fx, mir::Field::new(tag_field));\n-            let to = layout\n-                .ty\n-                .discriminant_for_variant(fx.tcx, variant_index)\n-                .unwrap()\n-                .val;\n+            let to = layout.ty.discriminant_for_variant(fx.tcx, variant_index).unwrap().val;\n             let to = if ptr.layout().abi.is_signed() {\n                 ty::ScalarInt::try_from_int(\n                     ptr.layout().size.sign_extend(to) as i128,\n@@ -46,12 +42,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         Variants::Multiple {\n             tag: _,\n             tag_field,\n-            tag_encoding:\n-                TagEncoding::Niche {\n-                    dataful_variant,\n-                    ref niche_variants,\n-                    niche_start,\n-                },\n+            tag_encoding: TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n             variants: _,\n         } => {\n             if variant_index != dataful_variant {\n@@ -70,7 +61,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n }\n \n pub(crate) fn codegen_get_discriminant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     value: CValue<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n@@ -101,12 +92,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             };\n             return CValue::const_val(fx, dest_layout, discr_val);\n         }\n-        Variants::Multiple {\n-            tag,\n-            tag_field,\n-            tag_encoding,\n-            variants: _,\n-        } => (tag, *tag_field, tag_encoding),\n+        Variants::Multiple { tag, tag_field, tag_encoding, variants: _ } => {\n+            (tag, *tag_field, tag_encoding)\n+        }\n     };\n \n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n@@ -125,11 +113,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             let val = clif_intcast(fx, tag, cast_to, signed);\n             CValue::by_val(val, dest_layout)\n         }\n-        TagEncoding::Niche {\n-            dataful_variant,\n-            ref niche_variants,\n-            niche_start,\n-        } => {\n+        TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n             // whether the result is in range for the niche variants.\n \n@@ -146,9 +130,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 tag\n             } else {\n                 // FIXME handle niche_start > i64::MAX\n-                fx.bcx\n-                    .ins()\n-                    .iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n+                fx.bcx.ins().iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n             };\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n             let is_niche = {\n@@ -176,15 +158,10 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 } else {\n                     clif_intcast(fx, relative_discr, cast_to, false)\n                 };\n-                fx.bcx\n-                    .ins()\n-                    .iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n+                fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n             };\n \n-            let dataful_variant = fx\n-                .bcx\n-                .ins()\n-                .iconst(cast_to, i64::from(dataful_variant.as_u32()));\n+            let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n             let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n             CValue::by_val(discr, dest_layout)\n         }"}, {"sha": "b87dcc41928b699b27f7e905a69f83f23299e894", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 25, "deletions": 89, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -12,11 +12,9 @@ use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n \n-use cranelift_object::{ObjectModule, ObjectProduct};\n+use cranelift_object::ObjectModule;\n \n-use crate::prelude::*;\n-\n-use crate::backend::AddConstructor;\n+use crate::{prelude::*, BackendConfig};\n \n fn new_module(tcx: TyCtxt<'_>, name: String) -> ObjectModule {\n     let module = crate::backend::make_module(tcx.sess, name);\n@@ -39,7 +37,6 @@ fn emit_module(\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n     unwind_context: UnwindContext<'_>,\n-    map_product: impl FnOnce(ObjectProduct) -> ObjectProduct,\n ) -> ModuleCodegenResult {\n     let mut product = module.finish();\n \n@@ -49,15 +46,10 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let product = map_product(product);\n-\n-    let tmp_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .temp_path(OutputType::Object, Some(&name));\n+    let tmp_file = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&name));\n     let obj = product.object.write().unwrap();\n     if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess\n-            .fatal(&format!(\"error writing object file: {}\", err));\n+        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n     }\n \n     let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n@@ -71,13 +63,7 @@ fn emit_module(\n     };\n \n     ModuleCodegenResult(\n-        CompiledModule {\n-            name,\n-            kind,\n-            object: Some(tmp_file),\n-            dwarf_object: None,\n-            bytecode: None,\n-        },\n+        CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None },\n         work_product,\n     )\n }\n@@ -117,49 +103,27 @@ fn reuse_workproduct_for_cgu(\n     }\n }\n \n-fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n+fn module_codegen(\n+    tcx: TyCtxt<'_>,\n+    (backend_config, cgu_name): (BackendConfig, rustc_span::Symbol),\n+) -> ModuleCodegenResult {\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n     let mut module = new_module(tcx, cgu_name.as_str().to_string());\n \n-    // Initialize the global atomic mutex using a constructor for proc-macros.\n-    // FIXME implement atomic instructions in Cranelift.\n-    let mut init_atomics_mutex_from_constructor = None;\n-    if tcx\n-        .sess\n-        .crate_types()\n-        .contains(&rustc_session::config::CrateType::ProcMacro)\n-    {\n-        if mono_items.iter().any(|(mono_item, _)| match mono_item {\n-            rustc_middle::mir::mono::MonoItem::Static(def_id) => tcx\n-                .symbol_name(Instance::mono(tcx, *def_id))\n-                .name\n-                .contains(\"__rustc_proc_macro_decls_\"),\n-            _ => false,\n-        }) {\n-            init_atomics_mutex_from_constructor =\n-                Some(crate::atomic_shim::init_global_lock_constructor(\n-                    &mut module,\n-                    &format!(\"{}_init_atomics_mutex\", cgu_name.as_str()),\n-                ));\n-        }\n-    }\n-\n     let mut cx = crate::CodegenCx::new(\n         tcx,\n-        module,\n+        backend_config,\n+        &mut module,\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n-        true,\n     );\n     super::predefine_mono_items(&mut cx, &mono_items);\n     for (mono_item, (linkage, visibility)) in mono_items {\n         let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || {\n-                    crate::base::codegen_fn(&mut cx, inst, linkage)\n-                });\n+                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n             }\n             MonoItem::Static(def_id) => {\n                 crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n@@ -175,9 +139,9 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n             }\n         }\n     }\n-    let (mut module, global_asm, debug, mut unwind_context) =\n+    let (global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context, false);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n \n     let codegen_result = emit_module(\n         tcx,\n@@ -186,13 +150,6 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n         module,\n         debug,\n         unwind_context,\n-        |mut product| {\n-            if let Some(func_id) = init_atomics_mutex_from_constructor {\n-                product.add_constructor(func_id);\n-            }\n-\n-            product\n-        },\n     );\n \n     codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n@@ -202,6 +159,7 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n \n pub(super) fn run_aot(\n     tcx: TyCtxt<'_>,\n+    backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n ) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n@@ -225,9 +183,7 @@ pub(super) fn run_aot(\n         cgus.iter()\n             .map(|cgu| {\n                 let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n-                tcx.sess\n-                    .cgu_reuse_tracker\n-                    .set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+                tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n                     _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n@@ -242,7 +198,7 @@ pub(super) fn run_aot(\n                 let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n                     dep_node,\n                     tcx,\n-                    cgu.name(),\n+                    (backend_config, cgu.name()),\n                     module_codegen,\n                     rustc_middle::dep_graph::hash_result,\n                 );\n@@ -271,7 +227,6 @@ pub(super) fn run_aot(\n             allocator_module,\n             None,\n             allocator_unwind_context,\n-            |product| product,\n         );\n         if let Some((id, product)) = work_product {\n             work_products.insert(id, product);\n@@ -301,8 +256,7 @@ pub(super) fn run_aot(\n             });\n \n             if let Err(err) = std::fs::write(&tmp_file, obj) {\n-                tcx.sess\n-                    .fatal(&format!(\"error writing metadata object file: {}\", err));\n+                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n             }\n \n             (metadata_cgu_name, tmp_file)\n@@ -356,8 +310,7 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n                 \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n             );\n         } else {\n-            tcx.sess\n-                .fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n+            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n         }\n     }\n \n@@ -367,19 +320,12 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n     // Remove all LLVM style comments\n     let global_asm = global_asm\n         .lines()\n-        .map(|line| {\n-            if let Some(index) = line.find(\"//\") {\n-                &line[0..index]\n-            } else {\n-                line\n-            }\n-        })\n+        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n \n-    let output_object_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .temp_path(OutputType::Object, Some(cgu_name));\n+    let output_object_file =\n+        tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(cgu_name));\n \n     // Assemble `global_asm`\n     let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n@@ -389,16 +335,10 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n         .stdin(Stdio::piped())\n         .spawn()\n         .expect(\"Failed to spawn `as`.\");\n-    child\n-        .stdin\n-        .take()\n-        .unwrap()\n-        .write_all(global_asm.as_bytes())\n-        .unwrap();\n+    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n     let status = child.wait().expect(\"Failed to wait for `as`.\");\n     if !status.success() {\n-        tcx.sess\n-            .fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n+        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n     }\n \n     // Link the global asm and main object file together\n@@ -442,11 +382,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n     }\n \n     let work_product_id = &cgu.work_product_id();\n-    if tcx\n-        .dep_graph\n-        .previous_work_product(work_product_id)\n-        .is_none()\n-    {\n+    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n         // We don't have anything cached for this CGU. This can happen\n         // if the CGU did not exist in the previous session.\n         return CguReuse::No;"}, {"sha": "245df03ffb84de600b7d127369f0e8b602ca9824", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 45, "deletions": 74, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -10,43 +10,24 @@ use rustc_middle::mir::mono::MonoItem;\n \n use cranelift_jit::{JITBuilder, JITModule};\n \n-use crate::prelude::*;\n+use crate::{prelude::*, BackendConfig};\n use crate::{CodegenCx, CodegenMode};\n \n thread_local! {\n+    pub static BACKEND_CONFIG: RefCell<Option<BackendConfig>> = RefCell::new(None);\n     pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n }\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n+pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n \n-    #[cfg(unix)]\n-    unsafe {\n-        // When not using our custom driver rustc will open us without the RTLD_GLOBAL flag, so\n-        // __cg_clif_global_atomic_mutex will not be exported. We fix this by opening ourself again\n-        // as global.\n-        // FIXME remove once atomic_shim is gone\n-\n-        let mut dl_info: libc::Dl_info = std::mem::zeroed();\n-        assert_ne!(\n-            libc::dladdr(run_jit as *const libc::c_void, &mut dl_info),\n-            0\n-        );\n-        assert_ne!(\n-            libc::dlopen(dl_info.dli_fname, libc::RTLD_NOW | libc::RTLD_GLOBAL),\n-            std::ptr::null_mut(),\n-        );\n-    }\n-\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder = JITBuilder::with_isa(\n-        crate::build_isa(tcx.sess),\n-        cranelift_module::default_libcall_names(),\n-    );\n-    jit_builder.hotswap(matches!(codegen_mode, CodegenMode::JitLazy));\n+    let mut jit_builder =\n+        JITBuilder::with_isa(crate::build_isa(tcx.sess), cranelift_module::default_libcall_names());\n+    jit_builder.hotswap(matches!(backend_config.codegen_mode, CodegenMode::JitLazy));\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n     assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n@@ -56,14 +37,10 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n             AbiParam::new(jit_module.target_config().pointer_type()),\n             AbiParam::new(jit_module.target_config().pointer_type()),\n         ],\n-        returns: vec![AbiParam::new(\n-            jit_module.target_config().pointer_type(), /*isize*/\n-        )],\n+        returns: vec![AbiParam::new(jit_module.target_config().pointer_type() /*isize*/)],\n         call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n     };\n-    let main_func_id = jit_module\n-        .declare_function(\"main\", Linkage::Import, &sig)\n-        .unwrap();\n+    let main_func_id = jit_module.declare_function(\"main\", Linkage::Import, &sig).unwrap();\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     let mono_items = cgus\n@@ -74,19 +51,19 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+    let mut cx = crate::CodegenCx::new(tcx, backend_config, &mut jit_module, false);\n \n     super::time(tcx, \"codegen mono items\", || {\n         super::predefine_mono_items(&mut cx, &mono_items);\n         for (mono_item, (linkage, visibility)) in mono_items {\n             let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n             match mono_item {\n-                MonoItem::Fn(inst) => match codegen_mode {\n+                MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_fn(&mut cx, inst, linkage)\n-                        });\n+                        cx.tcx\n+                            .sess\n+                            .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n                     }\n                     CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n                 },\n@@ -101,15 +78,15 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n         }\n     });\n \n-    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+    let (global_asm, _debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n     jit_module.finalize_definitions();\n \n     if !global_asm.is_empty() {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n     tcx.sess.abort_if_errors();\n@@ -120,7 +97,9 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n \n     let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n \n-    println!(\"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\");\n+    println!(\n+        \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n+    );\n \n     let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n         unsafe { ::std::mem::transmute(finalized_main) };\n@@ -136,6 +115,9 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n+    BACKEND_CONFIG.with(|tls_backend_config| {\n+        assert!(tls_backend_config.borrow_mut().replace(backend_config).is_none())\n+    });\n     CURRENT_MODULE\n         .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n \n@@ -153,21 +135,19 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n         CURRENT_MODULE.with(|jit_module| {\n             let mut jit_module = jit_module.borrow_mut();\n             let jit_module = jit_module.as_mut().unwrap();\n-            let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+            let backend_config =\n+                BACKEND_CONFIG.with(|backend_config| backend_config.borrow().clone().unwrap());\n \n             let name = tcx.symbol_name(instance).name.to_string();\n-            let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), instance);\n-            let func_id = cx\n-                .module\n-                .declare_function(&name, Linkage::Export, &sig)\n-                .unwrap();\n-            cx.module.prepare_for_function_redefine(func_id).unwrap();\n-\n-            tcx.sess.time(\"codegen fn\", || {\n-                crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n-            });\n-\n-            let (jit_module, global_asm, _debug_context, unwind_context) = cx.finalize();\n+            let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n+            let func_id = jit_module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+            jit_module.prepare_for_function_redefine(func_id).unwrap();\n+\n+            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n+            tcx.sess\n+                .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance, Linkage::Export));\n+\n+            let (global_asm, _debug_context, unwind_context) = cx.finalize();\n             assert!(global_asm.is_empty());\n             jit_module.finalize_definitions();\n             std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n@@ -194,9 +174,8 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n                 let name = tcx.crate_name(cnum);\n-                let mut err = tcx\n-                    .sess\n-                    .struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n+                let mut err =\n+                    tcx.sess.struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n                 err.note(\"rustc_codegen_cranelift can only load dylibs in JIT mode.\");\n                 err.emit();\n             }\n@@ -217,6 +196,11 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n             if name.is_empty() || !symbol.is_global() || symbol.is_undefined() {\n                 return None;\n             }\n+            if name.starts_with(\"rust_metadata_\") {\n+                // The metadata is part of a section that is not loaded by the dynamic linker in\n+                // case of cg_llvm.\n+                return None;\n+            }\n             let dlsym_name = if cfg!(target_os = \"macos\") {\n                 // On macOS `dlsym` expects the name without leading `_`.\n                 assert!(name.starts_with('_'), \"{:?}\", name);\n@@ -236,17 +220,14 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: Instance<'tcx>) {\n+pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n     let pointer_type = cx.module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name.to_string();\n     let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n-    let func_id = cx\n-        .module\n-        .declare_function(&name, Linkage::Export, &sig)\n-        .unwrap();\n+    let func_id = cx.module.declare_function(&name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));\n \n@@ -267,28 +248,18 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: In\n     let mut builder_ctx = FunctionBuilderContext::new();\n     let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n \n-    let jit_fn = cx\n-        .module\n-        .declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let jit_fn = cx.module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n     let entry_block = trampoline_builder.create_block();\n     trampoline_builder.append_block_params_for_function_params(entry_block);\n-    let fn_args = trampoline_builder\n-        .func\n-        .dfg\n-        .block_params(entry_block)\n-        .to_vec();\n+    let fn_args = trampoline_builder.func.dfg.block_params(entry_block).to_vec();\n \n     trampoline_builder.switch_to_block(entry_block);\n-    let instance_ptr = trampoline_builder\n-        .ins()\n-        .iconst(pointer_type, instance_ptr as u64 as i64);\n+    let instance_ptr = trampoline_builder.ins().iconst(pointer_type, instance_ptr as u64 as i64);\n     let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n     let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n-    let call_inst = trampoline_builder\n-        .ins()\n-        .call_indirect(sig_ref, jitted_fn, &fn_args);\n+    let call_inst = trampoline_builder.ins().call_indirect(sig_ref, jitted_fn, &fn_args);\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n "}, {"sha": "b994f28ffef5b39fe832355a3d4ac570d96b9601", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -17,33 +17,30 @@ pub(crate) fn codegen_crate(\n     tcx: TyCtxt<'_>,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-    config: crate::BackendConfig,\n+    backend_config: crate::BackendConfig,\n ) -> Box<dyn Any> {\n     tcx.sess.abort_if_errors();\n \n-    match config.codegen_mode {\n-        CodegenMode::Aot => aot::run_aot(tcx, metadata, need_metadata_module),\n+    match backend_config.codegen_mode {\n+        CodegenMode::Aot => aot::run_aot(tcx, backend_config, metadata, need_metadata_module),\n         CodegenMode::Jit | CodegenMode::JitLazy => {\n-            let is_executable = tcx\n-                .sess\n-                .crate_types()\n-                .contains(&rustc_session::config::CrateType::Executable);\n+            let is_executable =\n+                tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable);\n             if !is_executable {\n                 tcx.sess.fatal(\"can't jit non-executable crate\");\n             }\n \n             #[cfg(feature = \"jit\")]\n-            let _: ! = jit::run_jit(tcx, config.codegen_mode);\n+            let _: ! = jit::run_jit(tcx, backend_config);\n \n             #[cfg(not(feature = \"jit\"))]\n-            tcx.sess\n-                .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n         }\n     }\n }\n \n fn predefine_mono_items<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    cx: &mut crate::CodegenCx<'_, 'tcx>,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n     cx.tcx.sess.time(\"predefine functions\", || {\n@@ -63,21 +60,12 @@ fn predefine_mono_items<'tcx>(\n }\n \n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n-        .as_ref()\n-        .map(|val| &**val)\n-        == Ok(\"1\")\n-    {\n+    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").as_ref().map(|val| &**val) == Ok(\"1\") {\n         println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n         let before = std::time::Instant::now();\n         let res = tcx.sess.time(name, f);\n         let after = std::time::Instant::now();\n-        println!(\n-            \"[{:<30}: {}] end time: {:?}\",\n-            tcx.crate_name(LOCAL_CRATE),\n-            name,\n-            after - before\n-        );\n+        println!(\"[{:<30}: {}] end time: {:?}\", tcx.crate_name(LOCAL_CRATE), name, after - before);\n         res\n     } else {\n         tcx.sess.time(name, f)"}, {"sha": "5b3df2bd382808c908a94907c90dbbc8d3737139", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 13, "deletions": 44, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::InlineAsmOperand;\n use rustc_target::asm::*;\n \n pub(crate) fn codegen_inline_asm<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     _span: Span,\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n@@ -53,11 +53,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     crate::base::codegen_operand(fx, value).load_scalar(fx),\n                 ));\n             }\n-            InlineAsmOperand::Out {\n-                reg,\n-                late: _,\n-                place,\n-            } => {\n+            InlineAsmOperand::Out { reg, late: _, place } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 if let Some(place) = place {\n@@ -68,12 +64,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     ));\n                 }\n             }\n-            InlineAsmOperand::InOut {\n-                reg,\n-                late: _,\n-                ref in_value,\n-                out_place,\n-            } => {\n+            InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 inputs.push((\n@@ -97,11 +88,8 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n \n     let inline_asm_index = fx.inline_asm_index;\n     fx.inline_asm_index += 1;\n-    let asm_name = format!(\n-        \"{}__inline_asm_{}\",\n-        fx.tcx.symbol_name(fx.instance).name,\n-        inline_asm_index\n-    );\n+    let asm_name =\n+        format!(\"{}__inline_asm_{}\", fx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n \n     let generated_asm = generate_asm_wrapper(\n         &asm_name,\n@@ -129,12 +117,7 @@ fn generate_asm_wrapper(\n     let mut generated_asm = String::new();\n     writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n     writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n-    writeln!(\n-        generated_asm,\n-        \".section .text.{},\\\"ax\\\",@progbits\",\n-        asm_name\n-    )\n-    .unwrap();\n+    writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n     writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n \n     generated_asm.push_str(\".intel_syntax noprefix\\n\");\n@@ -164,11 +147,7 @@ fn generate_asm_wrapper(\n             InlineAsmTemplatePiece::String(s) => {\n                 generated_asm.push_str(s);\n             }\n-            InlineAsmTemplatePiece::Placeholder {\n-                operand_idx: _,\n-                modifier: _,\n-                span: _,\n-            } => todo!(),\n+            InlineAsmTemplatePiece::Placeholder { operand_idx: _, modifier: _, span: _ } => todo!(),\n         }\n     }\n     generated_asm.push('\\n');\n@@ -203,7 +182,7 @@ fn generate_asm_wrapper(\n }\n \n fn call_inline_asm<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     asm_name: &str,\n     slot_size: Size,\n     inputs: Vec<(InlineAsmReg, Size, Value)>,\n@@ -230,28 +209,20 @@ fn call_inline_asm<'tcx>(\n             },\n         )\n         .unwrap();\n-    let inline_asm_func = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(inline_asm_func, asm_name);\n \n     for (_reg, offset, value) in inputs {\n-        fx.bcx\n-            .ins()\n-            .stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n     }\n \n     let stack_slot_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n     fx.bcx.ins().call(inline_asm_func, &[stack_slot_addr]);\n \n     for (_reg, offset, place) in outputs {\n         let ty = fx.clif_type(place.layout().ty).unwrap();\n-        let value = fx\n-            .bcx\n-            .ins()\n-            .stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        let value = fx.bcx.ins().stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n         place.write_cvalue(fx, CValue::by_val(value, place.layout()));\n     }\n }\n@@ -267,8 +238,7 @@ fn save_register(generated_asm: &mut String, arch: InlineAsmArch, reg: InlineAsm\n     match arch {\n         InlineAsmArch::X86_64 => {\n             write!(generated_asm, \"    mov [rbp+0x{:x}], \", offset.bytes()).unwrap();\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n-                .unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n             generated_asm.push('\\n');\n         }\n         _ => unimplemented!(\"save_register for {:?}\", arch),\n@@ -284,8 +254,7 @@ fn restore_register(\n     match arch {\n         InlineAsmArch::X86_64 => {\n             generated_asm.push_str(\"    mov \");\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n-                .unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n             writeln!(generated_asm, \", [rbp+0x{:x}]\", offset.bytes()).unwrap();\n         }\n         _ => unimplemented!(\"restore_register for {:?}\", arch),"}, {"sha": "b27b0eddfbad6f6d4ad4e763fc37249dced899bc", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -6,7 +6,7 @@ use crate::prelude::*;\n ///\n /// This emulates an intel cpu with sse and sse2 support, but which doesn't support anything else.\n pub(crate) fn codegen_cpuid_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     leaf: Value,\n     _subleaf: Value,\n ) -> (Value, Value, Value, Value) {\n@@ -31,54 +31,28 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n \n     fx.bcx.switch_to_block(leaf_0);\n     let max_basic_leaf = fx.bcx.ins().iconst(types::I32, 1);\n-    let vend0 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n-    let vend2 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n-    let vend1 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n+    let vend0 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n+    let vend2 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n+    let vend1 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n+    fx.bcx.ins().jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n \n     fx.bcx.switch_to_block(leaf_1);\n     let cpu_signature = fx.bcx.ins().iconst(types::I32, 0);\n     let additional_information = fx.bcx.ins().iconst(types::I32, 0);\n     let ecx_features = fx.bcx.ins().iconst(types::I32, 0);\n-    let edx_features = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n-    fx.bcx.ins().jump(\n-        dest,\n-        &[\n-            cpu_signature,\n-            additional_information,\n-            ecx_features,\n-            edx_features,\n-        ],\n-    );\n+    let edx_features = fx.bcx.ins().iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n+    fx.bcx.ins().jump(dest, &[cpu_signature, additional_information, ecx_features, edx_features]);\n \n     fx.bcx.switch_to_block(leaf_8000_0000);\n     let extended_max_basic_leaf = fx.bcx.ins().iconst(types::I32, 0);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n+    fx.bcx.ins().jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n \n     fx.bcx.switch_to_block(leaf_8000_0001);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_ecx = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_edx = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n+    fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n     crate::trap::trap_unreachable("}, {"sha": "0692da397eb9465c2e44c1f70173bfe7c28e82bf", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -6,7 +6,7 @@ use crate::prelude::*;\n use rustc_middle::ty::subst::SubstsRef;\n \n pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     intrinsic: &str,\n     substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],"}, {"sha": "39e047a98f9eb660d25054e898ac824d959ba6ad", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 141, "deletions": 135, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -9,6 +9,7 @@ pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use crate::prelude::*;\n+use cranelift_codegen::ir::AtomicRmwOp;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n macro intrinsic_pat {\n@@ -112,38 +113,6 @@ macro call_intrinsic_match {\n     }\n }\n \n-macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-    let new = $fx.bcx.ins().$op(old, $src);\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-    $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n-macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    // Read old\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-\n-    // Compare\n-    let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n-    let new = $fx.bcx.ins().select(is_eq, old, $src);\n-\n-    // Write new\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-\n-    let ret_val = CValue::by_val(old, $ret.layout());\n-    $ret.write_cvalue($fx, ret_val);\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     match $ty.kind() {\n         ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n@@ -184,12 +153,12 @@ pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx\n     }\n }\n \n-fn simd_for_each_lane<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_for_each_lane<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(\n-        &mut FunctionCx<'_, 'tcx, M>,\n+        &mut FunctionCx<'_, '_, 'tcx>,\n         TyAndLayout<'tcx>,\n         TyAndLayout<'tcx>,\n         Value,\n@@ -213,13 +182,13 @@ fn simd_for_each_lane<'tcx, M: Module>(\n     }\n }\n \n-fn simd_pair_for_each_lane<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_pair_for_each_lane<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     x: CValue<'tcx>,\n     y: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(\n-        &mut FunctionCx<'_, 'tcx, M>,\n+        &mut FunctionCx<'_, '_, 'tcx>,\n         TyAndLayout<'tcx>,\n         TyAndLayout<'tcx>,\n         Value,\n@@ -246,42 +215,40 @@ fn simd_pair_for_each_lane<'tcx, M: Module>(\n     }\n }\n \n-fn simd_reduce<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_reduce<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, TyAndLayout<'tcx>, Value, Value) -> Value,\n+    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n     let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     for lane_idx in 1..lane_count {\n-        let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n-            .load_scalar(fx);\n+        let lane =\n+            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n     let res = CValue::by_val(res_val, lane_layout);\n     ret.write_cvalue(fx, res);\n }\n \n-fn simd_reduce_bool<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_reduce_bool<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, Value, Value) -> Value,\n+    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n     let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n-        let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n-            .load_scalar(fx);\n+        let lane =\n+            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n     }\n@@ -290,7 +257,7 @@ fn simd_reduce_bool<'tcx, M: Module>(\n }\n \n fn bool_to_zero_or_max_uint<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     val: Value,\n ) -> CValue<'tcx> {\n@@ -424,7 +391,7 @@ macro simd_flt_binop($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n }\n \n pub(crate) fn codegen_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n@@ -912,136 +879,175 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         _ if intrinsic.starts_with(\"atomic_fence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().fence();\n         };\n         _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            // FIXME use a compiler fence once Cranelift supports it\n+            fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_load\"), <T> (v ptr) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+            let ty = fx.clif_type(T).unwrap();\n \n-            let inner_layout =\n-                fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            validate_atomic_type!(fx, intrinsic, span, inner_layout.ty);\n-            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n-            ret.write_cvalue(fx, val);\n+            let val = fx.bcx.ins().atomic_load(ty, MemFlags::trusted(), ptr);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let val = CValue::by_val(val, fx.layout_of(T));\n+            ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n             validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n-            dest.write_cvalue(fx, val);\n+            let val = val.load_scalar(fx);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n-\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_xchg\"), (v ptr, c new) {\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let new = new.load_scalar(fx);\n \n-            // Write new\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), src.layout());\n-            dest.write_cvalue(fx, src);\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xchg, ptr, new);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n \n             let test_old = test_old.load_scalar(fx);\n             let new = new.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-\n-            // Compare\n+            let old = fx.bcx.ins().atomic_cas(MemFlags::trusted(), ptr, test_old, new);\n             let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n-            let new = fx.bcx.ins().select(is_eq, new, old); // Keep old if not equal to test_old\n-\n-            // Write new\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n \n             let ret_val = CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n-            ret.write_cvalue(fx, ret_val);\n-\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            ret.write_cvalue(fx, ret_val)\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Add, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Sub, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_and\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::And, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_or\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            let and = fx.bcx.ins().band(old, src);\n-            let new = fx.bcx.ins().bnot(and);\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Or, ptr, src);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xor\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xor, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+\n+        // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n+        _ if intrinsic.starts_with(\"atomic_nand\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Nand, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n+        _ if intrinsic.starts_with(\"atomic_max\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umax\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_min\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umin\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n \n         minnumf32, (v a, v b) {"}, {"sha": "1f8eeb1e714913c072e2c303594501d33011bc4a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -4,7 +4,7 @@ use super::*;\n use crate::prelude::*;\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,"}, {"sha": "e1927ad3a69200ecc7668a60ec71886bf53e01ba", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -11,8 +11,6 @@\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n-#[cfg(feature = \"jit\")]\n-extern crate libc;\n extern crate snap;\n #[macro_use]\n extern crate rustc_middle;\n@@ -53,7 +51,6 @@ mod abi;\n mod allocator;\n mod analyze;\n mod archive;\n-mod atomic_shim;\n mod backend;\n mod base;\n mod cast;\n@@ -129,9 +126,9 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n     }\n }\n \n-struct CodegenCx<'tcx, M: Module> {\n+struct CodegenCx<'m, 'tcx: 'm> {\n     tcx: TyCtxt<'tcx>,\n-    module: M,\n+    module: &'m mut dyn Module,\n     global_asm: String,\n     constants_cx: ConstantCx,\n     cached_context: Context,\n@@ -140,14 +137,20 @@ struct CodegenCx<'tcx, M: Module> {\n     unwind_context: UnwindContext<'tcx>,\n }\n \n-impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n-    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool, pic_eh_frame: bool) -> Self {\n-        let unwind_context = UnwindContext::new(tcx, module.isa(), pic_eh_frame);\n-        let debug_context = if debug_info {\n-            Some(DebugContext::new(tcx, module.isa()))\n-        } else {\n-            None\n-        };\n+impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        backend_config: BackendConfig,\n+        module: &'m mut dyn Module,\n+        debug_info: bool,\n+    ) -> Self {\n+        let unwind_context = UnwindContext::new(\n+            tcx,\n+            module.isa(),\n+            matches!(backend_config.codegen_mode, CodegenMode::Aot),\n+        );\n+        let debug_context =\n+            if debug_info { Some(DebugContext::new(tcx, module.isa())) } else { None };\n         CodegenCx {\n             tcx,\n             module,\n@@ -160,14 +163,9 @@ impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n         }\n     }\n \n-    fn finalize(mut self) -> (M, String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n-        self.constants_cx.finalize(self.tcx, &mut self.module);\n-        (\n-            self.module,\n-            self.global_asm,\n-            self.debug_context,\n-            self.unwind_context,\n-        )\n+    fn finalize(self) -> (String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n+        self.constants_cx.finalize(self.tcx, self.module);\n+        (self.global_asm, self.debug_context, self.unwind_context)\n     }\n }\n \n@@ -302,14 +300,7 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     flags_builder\n-        .set(\n-            \"enable_verifier\",\n-            if cfg!(debug_assertions) {\n-                \"true\"\n-            } else {\n-                \"false\"\n-            },\n-        )\n+        .set(\"enable_verifier\", if cfg!(debug_assertions) { \"true\" } else { \"false\" })\n         .unwrap();\n \n     let tls_model = match target_triple.binary_format {\n@@ -338,11 +329,7 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n \n     let flags = settings::Flags::new(flags_builder);\n \n-    let variant = if cfg!(feature = \"oldbe\") {\n-        cranelift_codegen::isa::BackendVariant::Legacy\n-    } else {\n-        cranelift_codegen::isa::BackendVariant::MachInst\n-    };\n+    let variant = cranelift_codegen::isa::BackendVariant::MachInst;\n     let mut isa_builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n     // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n     // is interpreted as `bsr`."}, {"sha": "62e551b186ff7c8cb96350eb8e4977496dce9193", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -9,7 +9,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext<'_>,\n-    use_jit: bool,\n ) {\n     let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, entry_ty)) => (\n@@ -27,22 +26,14 @@ pub(crate) fn maybe_create_entry_wrapper(\n         return;\n     }\n \n-    create_entry_fn(\n-        tcx,\n-        module,\n-        unwind_context,\n-        main_def_id,\n-        use_start_lang_item,\n-        use_jit,\n-    );\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, use_start_lang_item);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n         m: &mut impl Module,\n         unwind_context: &mut UnwindContext<'_>,\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n-        use_jit: bool,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -57,23 +48,17 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 AbiParam::new(m.target_config().pointer_type()),\n                 AbiParam::new(m.target_config().pointer_type()),\n             ],\n-            returns: vec![AbiParam::new(\n-                m.target_config().pointer_type(), /*isize*/\n-            )],\n+            returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n             call_conv: CallConv::triple_default(m.isa().triple()),\n         };\n \n-        let cmain_func_id = m\n-            .declare_function(\"main\", Linkage::Export, &cmain_sig)\n-            .unwrap();\n+        let cmain_func_id = m.declare_function(\"main\", Linkage::Export, &cmain_sig).unwrap();\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n         let main_name = tcx.symbol_name(instance).name.to_string();\n         let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n-        let main_func_id = m\n-            .declare_function(&main_name, Linkage::Import, &main_sig)\n-            .unwrap();\n+        let main_func_id = m.declare_function(&main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig);\n@@ -86,8 +71,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n             let arg_argc = bcx.append_block_param(block, m.target_config().pointer_type());\n             let arg_argv = bcx.append_block_param(block, m.target_config().pointer_type());\n \n-            crate::atomic_shim::init_global_lock(m, &mut bcx, use_jit);\n-\n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n             let call_inst = if use_start_lang_item {\n@@ -103,9 +86,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 .polymorphize(tcx);\n                 let start_func_id = import_function(tcx, m, start_instance);\n \n-                let main_val = bcx\n-                    .ins()\n-                    .func_addr(m.target_config().pointer_type(), main_func_ref);\n+                let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n                 bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])"}, {"sha": "190c4f45ccafdefe6ca1f55662e57c4fddc39a3b", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -94,9 +94,7 @@ pub(crate) fn write_metadata<P: WriteMetadata>(\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n-    FrameEncoder::new(&mut compressed)\n-        .write_all(&metadata.raw_data)\n-        .unwrap();\n+    FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n     product.add_rustc_section(\n         rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx),"}, {"sha": "da49e1c6c91dbacaa5df5900ed8abe5fa8f59a8a", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -41,7 +41,7 @@ pub(crate) fn bin_op_to_intcc(bin_op: BinOp, signed: bool) -> Option<IntCC> {\n }\n \n fn codegen_compare_bin_op<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     signed: bool,\n     lhs: Value,\n@@ -54,7 +54,7 @@ fn codegen_compare_bin_op<'tcx>(\n }\n \n pub(crate) fn codegen_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -93,17 +93,12 @@ pub(crate) fn codegen_binop<'tcx>(\n         ty::Uint(_) | ty::Int(_) => crate::num::codegen_int_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::Float(_) => crate::num::codegen_float_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::RawPtr(..) | ty::FnPtr(..) => crate::num::codegen_ptr_binop(fx, bin_op, in_lhs, in_rhs),\n-        _ => unreachable!(\n-            \"{:?}({:?}, {:?})\",\n-            bin_op,\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty\n-        ),\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     }\n }\n \n pub(crate) fn codegen_bool_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -124,7 +119,7 @@ pub(crate) fn codegen_bool_binop<'tcx>(\n }\n \n pub(crate) fn codegen_int_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -185,19 +180,14 @@ pub(crate) fn codegen_int_binop<'tcx>(\n             }\n         }\n         // Compare binops handles by `codegen_binop`.\n-        _ => unreachable!(\n-            \"{:?}({:?}, {:?})\",\n-            bin_op,\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty\n-        ),\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     };\n \n     CValue::by_val(val, in_lhs.layout())\n }\n \n pub(crate) fn codegen_checked_int_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -268,9 +258,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                     let rhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), rhs);\n                     let val = fx.bcx.ins().imul(lhs, rhs);\n                     let has_underflow =\n-                        fx.bcx\n-                            .ins()\n-                            .icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n+                        fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n                     let has_overflow = fx.bcx.ins().icmp_imm(\n                         IntCC::SignedGreaterThan,\n                         val,\n@@ -309,10 +297,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             let val = fx.bcx.ins().ishl(lhs, actual_shift);\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx\n-                .bcx\n-                .ins()\n-                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         BinOp::Shr => {\n@@ -326,38 +311,20 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             };\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx\n-                .bcx\n-                .ins()\n-                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n-        _ => bug!(\n-            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n-            bin_op,\n-            in_lhs,\n-            in_rhs\n-        ),\n+        _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n     let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n \n-    // FIXME directly write to result place instead\n-    let out_place = CPlace::new_stack_slot(\n-        fx,\n-        fx.layout_of(\n-            fx.tcx\n-                .mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()),\n-        ),\n-    );\n-    let out_layout = out_place.layout();\n-    out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n-\n-    out_place.to_cvalue(fx)\n+    let out_layout = fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n+    CValue::by_val_pair(res, has_overflow, out_layout)\n }\n \n pub(crate) fn codegen_float_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -402,7 +369,7 @@ pub(crate) fn codegen_float_binop<'tcx>(\n }\n \n pub(crate) fn codegen_ptr_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -452,9 +419,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n \n                 let ptr_cmp =\n-                    fx.bcx\n-                        .ins()\n-                        .icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n+                    fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n                 let extra_cmp = fx.bcx.ins().icmp(\n                     bin_op_to_intcc(bin_op, false).unwrap(),\n                     lhs_extra,\n@@ -466,9 +431,6 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        CValue::by_val(\n-            fx.bcx.ins().bint(types::I8, res),\n-            fx.layout_of(fx.tcx.types.bool),\n-        )\n+        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n     }\n }"}, {"sha": "ca9ff15ec10ffee9967d95ccf086ab0e345ba1fe", "filename": "compiler/rustc_codegen_cranelift/src/optimize/code_layout.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -15,10 +15,7 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     // bytecodealliance/cranelift#1339 is implemented.\n \n     let mut block_insts = FxHashMap::default();\n-    for block in cold_blocks\n-        .keys()\n-        .filter(|&block| cold_blocks.contains(block))\n-    {\n+    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n         let insts = ctx.func.layout.block_insts(block).collect::<Vec<_>>();\n         for &inst in &insts {\n             ctx.func.layout.remove_inst(inst);\n@@ -28,10 +25,7 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     }\n \n     // And then append them at the back again.\n-    for block in cold_blocks\n-        .keys()\n-        .filter(|&block| cold_blocks.contains(block))\n-    {\n+    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n         ctx.func.layout.append_block(block);\n         for inst in block_insts.remove(&block).unwrap() {\n             ctx.func.layout.append_inst(inst, block);"}, {"sha": "389f50e797e890795c5512321eddef538e303511", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -19,7 +19,12 @@ pub(crate) fn optimize_function<'tcx>(\n     if tcx.sess.opts.optimize == rustc_session::config::OptLevel::No {\n         return; // FIXME classify optimizations over opt levels\n     }\n-    self::stack2reg::optimize_function(ctx, clif_comments);\n+\n+    // FIXME(#1142) stack2reg miscompiles lewton\n+    if false {\n+        self::stack2reg::optimize_function(ctx, clif_comments);\n+    }\n+\n     crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", None, instance, &ctx, &*clif_comments);\n     crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n }"}, {"sha": "b95e2d72877d992f35622873a25270f624d635e0", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -10,10 +10,7 @@ use cranelift_frontend::FunctionBuilder;\n pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n     if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n         match bcx.func.dfg[arg_inst] {\n-            InstructionData::Unary {\n-                opcode: Opcode::Bint,\n-                arg,\n-            } => arg,\n+            InstructionData::Unary { opcode: Opcode::Bint, arg } => arg,\n             _ => arg,\n         }\n     } else {\n@@ -54,12 +51,7 @@ pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n \n         match bcx.func.dfg[arg_inst] {\n             // This is the lowering of Rvalue::Not\n-            InstructionData::Load {\n-                opcode: Opcode::Load,\n-                arg: ptr,\n-                flags,\n-                offset,\n-            } => {\n+            InstructionData::Load { opcode: Opcode::Load, arg: ptr, flags, offset } => {\n                 // Using `load.i8 + uextend.i32` would legalize to `uload8 + ireduce.i8 +\n                 // uextend.i32`. Just `uload8` is much faster.\n                 match bcx.func.dfg.ctrl_typevar(arg_inst) {\n@@ -95,20 +87,14 @@ pub(crate) fn maybe_known_branch_taken(\n     };\n \n     match bcx.func.dfg[arg_inst] {\n-        InstructionData::UnaryBool {\n-            opcode: Opcode::Bconst,\n-            imm,\n-        } => {\n+        InstructionData::UnaryBool { opcode: Opcode::Bconst, imm } => {\n             if test_zero {\n                 Some(!imm)\n             } else {\n                 Some(imm)\n             }\n         }\n-        InstructionData::UnaryImm {\n-            opcode: Opcode::Iconst,\n-            imm,\n-        } => {\n+        InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)\n             } else {"}, {"sha": "d111f37f5e4552a3d582636e73026b07f31364ac", "filename": "compiler/rustc_codegen_cranelift/src/optimize/stack2reg.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -175,16 +175,14 @@ impl<'a> OptimizeContext<'a> {\n             }\n         }\n \n-        OptimizeContext {\n-            ctx,\n-            stack_slot_usage_map,\n-        }\n+        OptimizeContext { ctx, stack_slot_usage_map }\n     }\n }\n \n pub(super) fn optimize_function(\n     ctx: &mut Context,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] clif_comments: &mut crate::pretty_clif::CommentWriter,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n+    clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n     combine_stack_addr_with_load_store(&mut ctx.func);\n \n@@ -296,12 +294,7 @@ fn combine_stack_addr_with_load_store(func: &mut Function) {\n     while let Some(_block) = cursor.next_block() {\n         while let Some(inst) = cursor.next_inst() {\n             match cursor.func.dfg[inst] {\n-                InstructionData::Load {\n-                    opcode: Opcode::Load,\n-                    arg: addr,\n-                    flags: _,\n-                    offset,\n-                } => {\n+                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n                     if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n                         || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n                     {\n@@ -391,20 +384,14 @@ fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n         stack_slot_users\n             .stack_addr\n             .drain_filter(|inst| {\n-                stack_addr_load_insts_users\n-                    .get(inst)\n-                    .map(|users| users.is_empty())\n-                    .unwrap_or(true)\n+                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n             })\n             .for_each(|inst| StackSlotUsage::remove_unused_stack_addr(&mut func, inst));\n \n         stack_slot_users\n             .stack_load\n             .drain_filter(|inst| {\n-                stack_addr_load_insts_users\n-                    .get(inst)\n-                    .map(|users| users.is_empty())\n-                    .unwrap_or(true)\n+                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n             })\n             .for_each(|inst| StackSlotUsage::remove_unused_load(&mut func, inst));\n     }\n@@ -415,11 +402,8 @@ fn try_get_stack_slot_and_offset_for_addr(\n     addr: Value,\n ) -> Option<(StackSlot, Offset32)> {\n     if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n-        if let InstructionData::StackLoad {\n-            opcode: Opcode::StackAddr,\n-            stack_slot,\n-            offset,\n-        } = func.dfg[addr_inst]\n+        if let InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset } =\n+            func.dfg[addr_inst]\n         {\n             return Some((stack_slot, offset));\n         }\n@@ -437,16 +421,8 @@ enum SpatialOverlap {\n fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     fn inst_info(func: &Function, inst: Inst) -> (StackSlot, Offset32, u32) {\n         match func.dfg[inst] {\n-            InstructionData::StackLoad {\n-                opcode: Opcode::StackAddr,\n-                stack_slot,\n-                offset,\n-            }\n-            | InstructionData::StackLoad {\n-                opcode: Opcode::StackLoad,\n-                stack_slot,\n-                offset,\n-            }\n+            InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset }\n+            | InstructionData::StackLoad { opcode: Opcode::StackLoad, stack_slot, offset }\n             | InstructionData::StackStore {\n                 opcode: Opcode::StackStore,\n                 stack_slot,\n@@ -471,10 +447,7 @@ fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     }\n \n     let src_end: i64 = src_offset.try_add_i64(i64::from(src_size)).unwrap().into();\n-    let dest_end: i64 = dest_offset\n-        .try_add_i64(i64::from(dest_size))\n-        .unwrap()\n-        .into();\n+    let dest_end: i64 = dest_offset.try_add_i64(i64::from(dest_size)).unwrap().into();\n     if src_end <= dest_offset.into() || dest_end <= src_offset.into() {\n         return SpatialOverlap::No;\n     }"}, {"sha": "88a78f3214d87b054efdb0281dde5d557009d6ee", "filename": "compiler/rustc_codegen_cranelift/src/pointer.rs", "status": "modified", "additions": 26, "deletions": 97, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -23,82 +23,49 @@ pub(crate) enum PointerBase {\n \n impl Pointer {\n     pub(crate) fn new(addr: Value) -> Self {\n-        Pointer {\n-            base: PointerBase::Addr(addr),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn stack_slot(stack_slot: StackSlot) -> Self {\n-        Pointer {\n-            base: PointerBase::Stack(stack_slot),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n-    pub(crate) fn const_addr<'a, 'tcx>(\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        addr: i64,\n-    ) -> Self {\n+    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n         let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer {\n-            base: PointerBase::Addr(addr),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn dangling(align: Align) -> Self {\n-        Pointer {\n-            base: PointerBase::Dangling(align),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }\n \n     #[cfg(debug_assertions)]\n     pub(crate) fn base_and_offset(self) -> (PointerBase, Offset32) {\n         (self.base, self.offset)\n     }\n \n-    pub(crate) fn get_addr<'a, 'tcx>(self, fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> Value {\n+    pub(crate) fn get_addr(self, fx: &mut FunctionCx<'_, '_, '_>) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 let offset: i64 = self.offset.into();\n-                if offset == 0 {\n-                    base_addr\n-                } else {\n-                    fx.bcx.ins().iadd_imm(base_addr, offset)\n-                }\n+                if offset == 0 { base_addr } else { fx.bcx.ins().iadd_imm(base_addr, offset) }\n             }\n             PointerBase::Stack(stack_slot) => {\n-                fx.bcx\n-                    .ins()\n-                    .stack_addr(fx.pointer_type, stack_slot, self.offset)\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset)\n+            }\n+            PointerBase::Dangling(align) => {\n+                fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n             }\n-            PointerBase::Dangling(align) => fx\n-                .bcx\n-                .ins()\n-                .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n         }\n     }\n \n-    pub(crate) fn offset<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: Offset32,\n-    ) -> Self {\n+    pub(crate) fn offset(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: Offset32) -> Self {\n         self.offset_i64(fx, extra_offset.into())\n     }\n \n-    pub(crate) fn offset_i64<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: i64,\n-    ) -> Self {\n+    pub(crate) fn offset_i64(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: i64) -> Self {\n         if let Some(new_offset) = self.offset.try_add_i64(extra_offset) {\n-            Pointer {\n-                base: self.base,\n-                offset: new_offset,\n-            }\n+            Pointer { base: self.base, offset: new_offset }\n         } else {\n             let base_offset: i64 = self.offset.into();\n             if let Some(new_offset) = base_offset.checked_add(extra_offset) {\n@@ -107,16 +74,12 @@ impl Pointer {\n                     PointerBase::Stack(stack_slot) => {\n                         fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)\n                     }\n-                    PointerBase::Dangling(align) => fx\n-                        .bcx\n-                        .ins()\n-                        .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n+                    PointerBase::Dangling(align) => {\n+                        fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n+                    }\n                 };\n                 let addr = fx.bcx.ins().iadd_imm(base_addr, new_offset);\n-                Pointer {\n-                    base: PointerBase::Addr(addr),\n-                    offset: Offset32::new(0),\n-                }\n+                Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n             } else {\n                 panic!(\n                     \"self.offset ({}) + extra_offset ({}) not representable in i64\",\n@@ -126,31 +89,22 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn offset_value<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: Value,\n-    ) -> Self {\n+    pub(crate) fn offset_value(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: Value) -> Self {\n         match self.base {\n             PointerBase::Addr(addr) => Pointer {\n                 base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n                 offset: self.offset,\n             },\n             PointerBase::Stack(stack_slot) => {\n-                let base_addr = fx\n-                    .bcx\n-                    .ins()\n-                    .stack_addr(fx.pointer_type, stack_slot, self.offset);\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset);\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(base_addr, extra_offset)),\n                     offset: Offset32::new(0),\n                 }\n             }\n             PointerBase::Dangling(align) => {\n-                let addr = fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n+                let addr =\n+                    fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n                     offset: self.offset,\n@@ -159,46 +113,21 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn load<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        ty: Type,\n-        flags: MemFlags,\n-    ) -> Value {\n+    pub(crate) fn load(self, fx: &mut FunctionCx<'_, '_, '_>, ty: Type, flags: MemFlags) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n-            PointerBase::Stack(stack_slot) => {\n-                if ty == types::I128 || ty.is_vector() {\n-                    // WORKAROUND for stack_load.i128 and stack_load.iXxY not being implemented\n-                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                    fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n-                } else {\n-                    fx.bcx.ins().stack_load(ty, stack_slot, self.offset)\n-                }\n-            }\n+            PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_load(ty, stack_slot, self.offset),\n             PointerBase::Dangling(_align) => unreachable!(),\n         }\n     }\n \n-    pub(crate) fn store<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        value: Value,\n-        flags: MemFlags,\n-    ) {\n+    pub(crate) fn store(self, fx: &mut FunctionCx<'_, '_, '_>, value: Value, flags: MemFlags) {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 fx.bcx.ins().store(flags, value, base_addr, self.offset);\n             }\n             PointerBase::Stack(stack_slot) => {\n-                let val_ty = fx.bcx.func.dfg.value_type(value);\n-                if val_ty == types::I128 || val_ty.is_vector() {\n-                    // WORKAROUND for stack_store.i128 and stack_store.iXxY not being implemented\n-                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                    fx.bcx.ins().store(flags, value, base_addr, self.offset);\n-                } else {\n-                    fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n-                }\n+                fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n             }\n             PointerBase::Dangling(_align) => unreachable!(),\n         }"}, {"sha": "9c91b92e515b1b0ffc22a06fc81a4452a488db1d", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -79,20 +79,14 @@ impl CommentWriter {\n             vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n-                format!(\n-                    \"abi {:?}\",\n-                    FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])\n-                ),\n+                format!(\"abi {:?}\", FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n                 String::new(),\n             ]\n         } else {\n             vec![]\n         };\n \n-        CommentWriter {\n-            global_comments,\n-            entity_comments: FxHashMap::default(),\n-        }\n+        CommentWriter { global_comments, entity_comments: FxHashMap::default() }\n     }\n }\n \n@@ -186,7 +180,7 @@ impl FuncWriter for &'_ CommentWriter {\n }\n \n #[cfg(debug_assertions)]\n-impl<M: Module> FunctionCx<'_, '_, M> {\n+impl FunctionCx<'_, '_, '_> {\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n         self.clif_comments.add_global_comment(comment);\n     }\n@@ -201,12 +195,7 @@ impl<M: Module> FunctionCx<'_, '_, M> {\n }\n \n pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n-    cfg!(debug_assertions)\n-        || tcx\n-            .sess\n-            .opts\n-            .output_types\n-            .contains_key(&OutputType::LlvmAssembly)\n+    tcx.sess.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n }\n \n pub(crate) fn write_ir_file<'tcx>(\n@@ -245,40 +234,33 @@ pub(crate) fn write_clif_file<'tcx>(\n     context: &cranelift_codegen::Context,\n     mut clif_comments: &CommentWriter,\n ) {\n-    write_ir_file(\n-        tcx,\n-        &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n-        |file| {\n-            let value_ranges = isa.map(|isa| {\n-                context\n-                    .build_value_labels_ranges(isa)\n-                    .expect(\"value location ranges\")\n-            });\n+    write_ir_file(tcx, &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix), |file| {\n+        let value_ranges =\n+            isa.map(|isa| context.build_value_labels_ranges(isa).expect(\"value location ranges\"));\n \n-            let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(\n-                &mut clif_comments,\n-                &mut clif,\n-                &context.func,\n-                &DisplayFunctionAnnotations {\n-                    isa: Some(&*crate::build_isa(tcx.sess)),\n-                    value_ranges: value_ranges.as_ref(),\n-                },\n-            )\n-            .unwrap();\n+        let mut clif = String::new();\n+        cranelift_codegen::write::decorate_function(\n+            &mut clif_comments,\n+            &mut clif,\n+            &context.func,\n+            &DisplayFunctionAnnotations {\n+                isa: Some(&*crate::build_isa(tcx.sess)),\n+                value_ranges: value_ranges.as_ref(),\n+            },\n+        )\n+        .unwrap();\n \n-            writeln!(file, \"test compile\")?;\n-            writeln!(file, \"set is_pic\")?;\n-            writeln!(file, \"set enable_simd\")?;\n-            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n-            writeln!(file)?;\n-            file.write_all(clif.as_bytes())?;\n-            Ok(())\n-        },\n-    );\n+        writeln!(file, \"test compile\")?;\n+        writeln!(file, \"set is_pic\")?;\n+        writeln!(file, \"set enable_simd\")?;\n+        writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+        writeln!(file)?;\n+        file.write_all(clif.as_bytes())?;\n+        Ok(())\n+    });\n }\n \n-impl<M: Module> fmt::Debug for FunctionCx<'_, '_, M> {\n+impl fmt::Debug for FunctionCx<'_, '_, '_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(f, \"{:?}\", self.instance.substs)?;\n         writeln!(f, \"{:?}\", self.local_map)?;"}, {"sha": "484a9b699a0aa41aa73c412610bae16e2155d456", "filename": "compiler/rustc_codegen_cranelift/src/toolchain.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -71,12 +71,9 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 flavor,\n             )),\n             (Some(linker), None) => {\n-                let stem = linker\n-                    .file_stem()\n-                    .and_then(|stem| stem.to_str())\n-                    .unwrap_or_else(|| {\n-                        sess.fatal(\"couldn't extract file stem from specified linker\")\n-                    });\n+                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n+                    sess.fatal(\"couldn't extract file stem from specified linker\")\n+                });\n \n                 let flavor = if stem == \"emcc\" {\n                     LinkerFlavor::Em\n@@ -105,11 +102,7 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     // linker and linker flavor specified via command line have precedence over what the target\n     // specification specifies\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.opts.cg.linker.clone(),\n-        sess.opts.cg.linker_flavor,\n-    ) {\n+    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), sess.opts.cg.linker_flavor) {\n         return ret;\n     }\n "}, {"sha": "bb63d72addf9842f32c3cf1af965fb80824c7bc3", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -2,7 +2,7 @@\n \n use crate::prelude::*;\n \n-fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n+fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     let puts = fx\n         .cx\n         .module\n@@ -29,7 +29,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n }\n \n /// Trap code: user1\n-pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::User(1));\n }\n@@ -38,7 +38,7 @@ pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsR\n /// so you can **not** add instructions to it afterwards.\n ///\n /// Trap code: user65535\n-pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n@@ -47,7 +47,7 @@ pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: im\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unreachable_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {\n@@ -62,7 +62,7 @@ pub(crate) fn trap_unreachable_ret_value<'tcx>(\n /// to it afterwards.\n ///\n /// Trap code: user65535\n-pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     let true_ = fx.bcx.ins().iconst(types::I32, 1);\n     fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n@@ -72,7 +72,7 @@ pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg:\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unimplemented_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {"}, {"sha": "042583cd5720fa07b7cac71d3928a302f7d3be0b", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 25, "deletions": 50, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -13,19 +13,18 @@ use crate::prelude::*;\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n pub(crate) fn unsized_info<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n     old_info: Option<Value>,\n ) -> Value {\n     let (source, target) =\n-        fx.tcx\n-            .struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n+        fx.tcx.struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n     match (&source.kind(), &target.kind()) {\n-        (&ty::Array(_, len), &ty::Slice(_)) => fx.bcx.ins().iconst(\n-            fx.pointer_type,\n-            len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64,\n-        ),\n+        (&ty::Array(_, len), &ty::Slice(_)) => fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n@@ -35,17 +34,13 @@ pub(crate) fn unsized_info<'tcx>(\n         (_, &ty::Dynamic(ref data, ..)) => {\n             crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n         }\n-        _ => bug!(\n-            \"unsized_info: invalid unsizing {:?} -> {:?}\",\n-            source,\n-            target\n-        ),\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n fn unsize_thin_ptr<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: Value,\n     src_layout: TyAndLayout<'tcx>,\n     dst_layout: TyAndLayout<'tcx>,\n@@ -89,24 +84,22 @@ fn unsize_thin_ptr<'tcx>(\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub(crate) fn coerce_unsized_into<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: CValue<'tcx>,\n     dst: CPlace<'tcx>,\n ) {\n     let src_ty = src.layout().ty;\n     let dst_ty = dst.layout().ty;\n     let mut coerce_ptr = || {\n-        let (base, info) = if fx\n-            .layout_of(src.layout().ty.builtin_deref(true).unwrap().ty)\n-            .is_unsized()\n-        {\n-            // fat-ptr to fat-ptr unsize preserves the vtable\n-            // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-            src.load_scalar_pair(fx)\n-        } else {\n-            let base = src.load_scalar(fx);\n-            unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n-        };\n+        let (base, info) =\n+            if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+                src.load_scalar_pair(fx)\n+            } else {\n+                let base = src.load_scalar(fx);\n+                unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n+            };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };\n     match (&src_ty.kind(), &dst_ty.kind()) {\n@@ -131,49 +124,34 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n                 }\n             }\n         }\n-        _ => bug!(\n-            \"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-            src_ty,\n-            dst_ty\n-        ),\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\", src_ty, dst_ty),\n     }\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n \n pub(crate) fn size_and_align_of_dst<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     info: Value,\n ) -> (Value, Value) {\n     if !layout.is_unsized() {\n-        let size = fx\n-            .bcx\n-            .ins()\n-            .iconst(fx.pointer_type, layout.size.bytes() as i64);\n-        let align = fx\n-            .bcx\n-            .ins()\n-            .iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n+        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n+        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n         return (size, align);\n     }\n     match layout.ty.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n-            (\n-                crate::vtable::size_of_obj(fx, info),\n-                crate::vtable::min_align_of_obj(fx, info),\n-            )\n+            (crate::vtable::size_of_obj(fx, info), crate::vtable::min_align_of_obj(fx, info))\n         }\n         ty::Slice(_) | ty::Str => {\n             let unit = layout.field(fx, 0);\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             (\n                 fx.bcx.ins().imul_imm(info, unit.size.bytes() as i64),\n-                fx.bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n+                fx.bcx.ins().iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n             )\n         }\n         _ => {\n@@ -211,10 +189,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let cmp = fx\n-                .bcx\n-                .ins()\n-                .icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n+            let cmp = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n             let align = fx.bcx.ins().select(cmp, sized_align, unsized_align);\n \n             // Issue #27023: must add any necessary padding to `size`"}, {"sha": "cffaf79ded10b8ebfaae7e4ea0a2db31b85579ab", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 52, "deletions": 135, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -6,7 +6,7 @@ use cranelift_codegen::entity::EntityRef;\n use cranelift_codegen::ir::immediates::Offset32;\n \n fn codegen_field<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     base: Pointer,\n     extra: Option<Value>,\n     layout: TyAndLayout<'tcx>,\n@@ -15,11 +15,8 @@ fn codegen_field<'tcx>(\n     let field_offset = layout.fields.offset(field.index());\n     let field_layout = layout.field(&*fx, field.index());\n \n-    let simple = |fx: &mut FunctionCx<'_, '_, _>| {\n-        (\n-            base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()),\n-            field_layout,\n-        )\n+    let simple = |fx: &mut FunctionCx<'_, '_, '_>| {\n+        (base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()), field_layout)\n     };\n \n     if let Some(extra) = extra {\n@@ -58,10 +55,7 @@ fn scalar_pair_calculate_b_offset(\n     a_scalar: &Scalar,\n     b_scalar: &Scalar,\n ) -> Offset32 {\n-    let b_offset = a_scalar\n-        .value\n-        .size(&tcx)\n-        .align_to(b_scalar.value.align(&tcx).abi);\n+    let b_offset = a_scalar.value.size(&tcx).align_to(b_scalar.value.align(&tcx).abi);\n     Offset32::new(b_offset.bytes().try_into().unwrap())\n }\n \n@@ -106,10 +100,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    pub(crate) fn force_stack(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    ) -> (Pointer, Option<Value>) {\n+    pub(crate) fn force_stack(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> (Pointer, Option<Value>) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, meta) => (ptr, meta),\n@@ -129,7 +120,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value with layout.abi of scalar\n-    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> Value {\n+    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> Value {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n@@ -153,10 +144,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value pair with layout.abi of scalar pair\n-    pub(crate) fn load_scalar_pair(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    ) -> (Value, Value) {\n+    pub(crate) fn load_scalar_pair(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> (Value, Value) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n@@ -183,7 +171,7 @@ impl<'tcx> CValue<'tcx> {\n \n     pub(crate) fn value_field(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         field: mir::Field,\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n@@ -219,21 +207,17 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub(crate) fn unsize_value(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-        dest: CPlace<'tcx>,\n-    ) {\n+    pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub(crate) fn const_val(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n         const_val: ty::ScalarInt,\n     ) -> CValue<'tcx> {\n-        assert_eq!(const_val.size(), layout.size);\n+        assert_eq!(const_val.size(), layout.size, \"{:#?}: {:?}\", const_val, layout);\n         use cranelift_codegen::ir::immediates::{Ieee32, Ieee64};\n \n         let clif_ty = fx.clif_type(layout.ty).unwrap();\n@@ -250,18 +234,11 @@ impl<'tcx> CValue<'tcx> {\n             ty::Uint(UintTy::U128) | ty::Int(IntTy::I128) => {\n                 let const_val = const_val.to_bits(layout.size).unwrap();\n                 let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n-                let msb = fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(types::I64, (const_val >> 64) as u64 as i64);\n+                let msb = fx.bcx.ins().iconst(types::I64, (const_val >> 64) as u64 as i64);\n                 fx.bcx.ins().iconcat(lsb, msb)\n             }\n-            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..)\n-            | ty::RawPtr(..) => {\n-                fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n+            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..) | ty::RawPtr(..) => {\n+                fx.bcx.ins().iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n             }\n             ty::Float(FloatTy::F32) => {\n                 fx.bcx.ins().f32const(Ieee32::with_bits(u32::try_from(const_val).unwrap()))\n@@ -279,14 +256,8 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     pub(crate) fn cast_pointer_to(self, layout: TyAndLayout<'tcx>) -> Self {\n-        assert!(matches!(\n-            self.layout().ty.kind(),\n-            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n-        ));\n-        assert!(matches!(\n-            layout.ty.kind(),\n-            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n-        ));\n+        assert!(matches!(self.layout().ty.kind(), ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n+        assert!(matches!(layout.ty.kind(), ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n         assert_eq!(self.layout().abi, layout.abi);\n         CValue(self.0, layout)\n     }\n@@ -317,14 +288,11 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn no_place(layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None), layout }\n     }\n \n     pub(crate) fn new_stack_slot(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n         assert!(!layout.is_unsized());\n@@ -339,28 +307,22 @@ impl<'tcx> CPlace<'tcx> {\n             size: (u32::try_from(layout.size.bytes()).unwrap() + 15) / 16 * 16,\n             offset: None,\n         });\n-        CPlace {\n-            inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None), layout }\n     }\n \n     pub(crate) fn new_var(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n         let var = Variable::with_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n         fx.bcx.declare_var(var, fx.clif_type(layout.ty).unwrap());\n-        CPlace {\n-            inner: CPlaceInner::Var(local, var),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Var(local, var), layout }\n     }\n \n     pub(crate) fn new_var_pair(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n@@ -372,52 +334,39 @@ impl<'tcx> CPlace<'tcx> {\n         let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n         fx.bcx.declare_var(var1, ty1);\n         fx.bcx.declare_var(var2, ty2);\n-        CPlace {\n-            inner: CPlaceInner::VarPair(local, var1, var2),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::VarPair(local, var1, var2), layout }\n     }\n \n     pub(crate) fn for_ptr(ptr: Pointer, layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(ptr, None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(ptr, None), layout }\n     }\n \n     pub(crate) fn for_ptr_with_extra(\n         ptr: Pointer,\n         extra: Value,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(ptr, Some(extra)),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(ptr, Some(extra)), layout }\n     }\n \n-    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CValue<'tcx> {\n+    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CValue<'tcx> {\n         let layout = self.layout();\n         match self.inner {\n             CPlaceInner::Var(_local, var) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 CValue::by_val(val, layout)\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n                 let val1 = fx.bcx.use_var(var1);\n-                fx.bcx\n-                    .set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                //fx.bcx.set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n                 let val2 = fx.bcx.use_var(var2);\n-                fx.bcx\n-                    .set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                //fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n                 CValue::by_val_pair(val1, val2, layout)\n             }\n             CPlaceInner::VarLane(_local, var, lane) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 let val = fx.bcx.ins().extractlane(val, lane);\n                 CValue::by_val(val, layout)\n             }\n@@ -447,32 +396,28 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub(crate) fn write_cvalue(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-        from: CValue<'tcx>,\n-    ) {\n+    pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>, from: CValue<'tcx>) {\n         assert_assignable(fx, from.layout().ty, self.layout().ty);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n     }\n \n     pub(crate) fn write_cvalue_transmute(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n     ) {\n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue_transmute\");\n     }\n \n     fn write_cvalue_maybe_transmute(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n         #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n     ) {\n         fn transmute_value<'tcx>(\n-            fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+            fx: &mut FunctionCx<'_, '_, 'tcx>,\n             var: Variable,\n             data: Value,\n             dst_ty: Type,\n@@ -511,8 +456,7 @@ impl<'tcx> CPlace<'tcx> {\n                 }\n                 _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n             };\n-            fx.bcx\n-                .set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+            //fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n             fx.bcx.def_var(var, data);\n         }\n \n@@ -558,15 +502,13 @@ impl<'tcx> CPlace<'tcx> {\n \n                 // First get the old vector\n                 let vector = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n \n                 // Next insert the written lane into the vector\n                 let vector = fx.bcx.ins().insertlane(vector, data, lane);\n \n                 // Finally write the new vector\n-                fx.bcx\n-                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 fx.bcx.def_var(var, vector);\n \n                 return;\n@@ -604,10 +546,7 @@ impl<'tcx> CPlace<'tcx> {\n                 to_ptr.store(fx, val, flags);\n             }\n             CValueInner::ByValPair(_, _) => {\n-                bug!(\n-                    \"Non ScalarPair abi {:?} for ByValPair CValue\",\n-                    dst_layout.abi\n-                );\n+                bug!(\"Non ScalarPair abi {:?} for ByValPair CValue\", dst_layout.abi);\n             }\n             CValueInner::ByRef(from_ptr, None) => {\n                 let from_addr = from_ptr.get_addr(fx);\n@@ -632,7 +571,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_field(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n@@ -650,18 +589,8 @@ impl<'tcx> CPlace<'tcx> {\n                 let layout = layout.field(&*fx, field.index());\n \n                 match field.as_u32() {\n-                    0 => {\n-                        return CPlace {\n-                            inner: CPlaceInner::Var(local, var1),\n-                            layout,\n-                        }\n-                    }\n-                    1 => {\n-                        return CPlace {\n-                            inner: CPlaceInner::Var(local, var2),\n-                            layout,\n-                        }\n-                    }\n+                    0 => return CPlace { inner: CPlaceInner::Var(local, var1), layout },\n+                    1 => return CPlace { inner: CPlaceInner::Var(local, var2), layout },\n                     _ => unreachable!(\"field should be 0 or 1\"),\n                 }\n             }\n@@ -680,7 +609,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_index(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n@@ -689,30 +618,24 @@ impl<'tcx> CPlace<'tcx> {\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n-        let offset = fx\n-            .bcx\n-            .ins()\n-            .imul_imm(index, elem_layout.size.bytes() as i64);\n+        let offset = fx.bcx.ins().imul_imm(index, elem_layout.size.bytes() as i64);\n \n         CPlace::for_ptr(ptr.offset_value(fx, offset), elem_layout)\n     }\n \n-    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CPlace<'tcx> {\n+    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CPlace<'tcx> {\n         let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n         if has_ptr_meta(fx.tcx, inner_layout.ty) {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n             CPlace::for_ptr_with_extra(Pointer::new(addr), extra, inner_layout)\n         } else {\n-            CPlace::for_ptr(\n-                Pointer::new(self.to_cvalue(fx).load_scalar(fx)),\n-                inner_layout,\n-            )\n+            CPlace::for_ptr(Pointer::new(self.to_cvalue(fx).load_scalar(fx)), inner_layout)\n         }\n     }\n \n     pub(crate) fn place_ref(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CValue<'tcx> {\n         if has_ptr_meta(fx.tcx, self.layout().ty) {\n@@ -729,21 +652,18 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn downcast_variant(\n         self,\n-        fx: &FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &FunctionCx<'_, '_, 'tcx>,\n         variant: VariantIdx,\n     ) -> Self {\n         assert!(!self.layout().is_unsized());\n         let layout = self.layout().for_variant(fx, variant);\n-        CPlace {\n-            inner: self.inner,\n-            layout,\n-        }\n+        CPlace { inner: self.inner, layout }\n     }\n }\n \n #[track_caller]\n pub(crate) fn assert_assignable<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) {\n@@ -776,12 +696,9 @@ pub(crate) fn assert_assignable<'tcx>(\n         }\n         (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n             for (from, to) in from_traits.iter().zip(to_traits) {\n-                let from = fx\n-                    .tcx\n-                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n-                let to = fx\n-                    .tcx\n-                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                let from =\n+                    fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                let to = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n                 assert_eq!(\n                     from, to,\n                     \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\","}, {"sha": "4d2551a061b99b5e1b74e55d0f53d15b76ce2f04", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -15,7 +15,7 @@ fn vtable_memflags() -> MemFlags {\n     flags\n }\n \n-pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -25,7 +25,7 @@ pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: V\n     )\n }\n \n-pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -35,7 +35,7 @@ pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Valu\n     )\n }\n \n-pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -46,7 +46,7 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable:\n }\n \n pub(crate) fn get_ptr_and_method_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     idx: usize,\n ) -> (Value, Value) {\n@@ -68,7 +68,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n }\n \n pub(crate) fn get_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n@@ -85,7 +85,7 @@ pub(crate) fn get_vtable<'tcx>(\n }\n \n fn build_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> DataId {\n@@ -94,7 +94,7 @@ fn build_vtable<'tcx>(\n \n     let drop_in_place_fn = import_function(\n         tcx,\n-        &mut fx.cx.module,\n+        fx.cx.module,\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n@@ -111,7 +111,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map(|(def_id, substs)| {\n             import_function(\n                 tcx,\n-                &mut fx.cx.module,\n+                fx.cx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n                     .unwrap()\n                     .polymorphize(fx.tcx),\n@@ -165,11 +165,8 @@ fn build_vtable<'tcx>(\n }\n \n fn write_usize(tcx: TyCtxt<'_>, buf: &mut [u8], idx: usize, num: u64) {\n-    let pointer_size = tcx\n-        .layout_of(ParamEnv::reveal_all().and(tcx.types.usize))\n-        .unwrap()\n-        .size\n-        .bytes() as usize;\n+    let pointer_size =\n+        tcx.layout_of(ParamEnv::reveal_all().and(tcx.types.usize)).unwrap().size.bytes() as usize;\n     let target = &mut buf[idx * pointer_size..(idx + 1) * pointer_size];\n \n     match tcx.data_layout.endian {"}, {"sha": "e222adc7b80582ec7169a0c65f2fd9d34af00341", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n ./build.sh --sysroot none \"$@\""}, {"sha": "6cc649c1180c515b55a34983be30599599747e0c", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -576,7 +576,8 @@ impl CheckAttrVisitor<'tcx> {\n                             sym::masked,\n                             sym::no_default_passes, // deprecated\n                             sym::no_inline,\n-                            sym::passes, // deprecated\n+                            sym::passes,  // deprecated\n+                            sym::plugins, // removed, but rustdoc warns about it itself\n                             sym::primitive,\n                             sym::spotlight,\n                             sym::test,"}, {"sha": "eb1916637529b2c7cdd052a2f0a15e4c0deb8b69", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -679,7 +679,7 @@ supported_targets! {\n     (\"thumbv7neon-linux-androideabi\", thumbv7neon_linux_androideabi),\n     (\"aarch64-linux-android\", aarch64_linux_android),\n \n-    (\"x86_64-linux-kernel\", x86_64_linux_kernel),\n+    (\"x86_64-unknown-none-linuxkernel\", x86_64_unknown_none_linuxkernel),\n \n     (\"aarch64-unknown-freebsd\", aarch64_unknown_freebsd),\n     (\"armv6-unknown-freebsd\", armv6_unknown_freebsd),\n@@ -777,7 +777,8 @@ supported_targets! {\n \n     (\"aarch64-unknown-hermit\", aarch64_unknown_hermit),\n     (\"x86_64-unknown-hermit\", x86_64_unknown_hermit),\n-    (\"x86_64-unknown-hermit-kernel\", x86_64_unknown_hermit_kernel),\n+\n+    (\"x86_64-unknown-none-hermitkernel\", x86_64_unknown_none_hermitkernel),\n \n     (\"riscv32i-unknown-none-elf\", riscv32i_unknown_none_elf),\n     (\"riscv32imc-unknown-none-elf\", riscv32imc_unknown_none_elf),"}, {"sha": "a357def190b83f489947272205f852986488a607", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_none_hermitkernel.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_hermitkernel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_hermitkernel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_hermitkernel.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -10,7 +10,7 @@ pub fn target() -> Target {\n     base.stack_probes = StackProbeType::InlineOrCall { min_llvm_version_for_inline: (11, 0, 1) };\n \n     Target {\n-        llvm_target: \"x86_64-unknown-hermit\".to_string(),\n+        llvm_target: \"x86_64-unknown-none-elf\".to_string(),\n         pointer_width: 64,\n         data_layout: \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n             .to_string(),", "previous_filename": "compiler/rustc_target/src/spec/x86_64_unknown_hermit_kernel.rs"}, {"sha": "68d80205e14724e2f8b862eabe979e63c1549771", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_none_linuxkernel.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_linuxkernel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_linuxkernel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_linuxkernel.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -14,8 +14,11 @@ pub fn target() -> Target {\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n \n     Target {\n-        // FIXME: Some dispute, the linux-on-clang folks think this should use \"Linux\"\n-        llvm_target: \"x86_64-elf\".to_string(),\n+        // FIXME: Some dispute, the linux-on-clang folks think this should use\n+        // \"Linux\". We disagree because running *on* Linux is nothing like\n+        // running *as\" linux, and historically the \"os\" component as has always\n+        // been used to mean the \"on\" part.\n+        llvm_target: \"x86_64-unknown-none-elf\".to_string(),\n         pointer_width: 64,\n         data_layout: \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n             .to_string(),", "previous_filename": "compiler/rustc_target/src/spec/x86_64_linux_kernel.rs"}, {"sha": "3f2f244e44fd29125a9157c5afa65650c807ac9f", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -722,18 +722,20 @@ fn infer_placeholder_type(\n                 format!(\"{}: {}\", item_ident, ty),\n                 Applicability::MachineApplicable,\n             )\n-            .emit();\n+            .emit_unless(ty.references_error());\n         }\n         None => {\n             let mut diag = bad_placeholder_type(tcx, vec![span]);\n-            if !matches!(ty.kind(), ty::Error(_)) {\n+\n+            if !ty.references_error() {\n                 diag.span_suggestion(\n                     span,\n                     \"replace `_` with the correct type\",\n                     ty.to_string(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n+\n             diag.emit();\n         }\n     }"}, {"sha": "634ed87b0910e69d4ca86d5aefcaa2ad0571534a", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -846,6 +846,12 @@ extern \"rust-intrinsic\" {\n     /// destination value, then forgets the original. It's equivalent to C's\n     /// `memcpy` under the hood, just like `transmute_copy`.\n     ///\n+    /// Because `transmute` is a by-value operation, alignment of the *transmuted values\n+    /// themselves* is not a concern. As with any other function, the compiler already ensures\n+    /// both `T` and `U` are properly aligned. However, when transmuting values that *point\n+    /// elsewhere* (such as pointers, references, boxes\u2026), the caller has to ensure proper\n+    /// alignment of the pointed-to values.\n+    ///\n     /// `transmute` is **incredibly** unsafe. There are a vast number of ways to\n     /// cause [undefined behavior][ub] with this function. `transmute` should be\n     /// the absolute last resort.\n@@ -965,7 +971,13 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n     /// ```\n     ///\n-    /// Turning a `Vec<&T>` into a `Vec<Option<&T>>`:\n+    /// Turning a `Vec<&T>` into a `Vec<Option<&T>>`.\n+    ///\n+    /// To transmute the inner type of the contents of a container, you must make sure to not\n+    /// violate any of the container's invariants. For `Vec`, this means that both the size\n+    /// *and alignment* of the inner types have to match. Other containers might rely on the\n+    /// size of the type, alignment, or even the `TypeId`, in which case transmuting wouldn't\n+    /// be possible at all without violating the container invariants.\n     ///\n     /// ```\n     /// let store = [0, 1, 2, 3];\n@@ -991,14 +1003,11 @@ extern \"rust-intrinsic\" {\n     ///\n     /// let v_clone = v_orig.clone();\n     ///\n-    /// // The no-copy, unsafe way, still using transmute, but not relying on the data layout.\n-    /// // Like the first approach, this reuses the `Vec` internals.\n-    /// // Therefore, the new inner type must have the\n-    /// // exact same size, *and the same alignment*, as the old type.\n-    /// // The same caveats exist for this method as transmute, for\n-    /// // the original inner type (`&i32`) to the converted inner type\n-    /// // (`Option<&i32>`), so read the nomicon pages linked above and also\n-    /// // consult the [`from_raw_parts`] documentation.\n+    /// // This is the proper no-copy, unsafe way of \"transmuting\" a `Vec`, without relying on the\n+    /// // data layout. Instead of literally calling `transmute`, we perform a pointer cast, but\n+    /// // in terms of converting the original inner type (`&i32`) to the new one (`Option<&i32>`),\n+    /// // this has all the same caveats. Besides the information provided above, also consult the\n+    /// // [`from_raw_parts`] documentation.\n     /// let v_from_raw = unsafe {\n     // FIXME Update this when vec_into_raw_parts is stabilized\n     ///     // Ensure the original vector is not dropped."}, {"sha": "ea7a809c6badb61f34f55ee3bd82ab25a2bf2fb9", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -13,9 +13,10 @@ use crate::iter::{InPlaceIterable, SourceIter, TrustedLen};\n pub struct Zip<A, B> {\n     a: A,\n     b: B,\n-    // index and len are only used by the specialized version of zip\n+    // index, len and a_len are only used by the specialized version of zip\n     index: usize,\n     len: usize,\n+    a_len: usize,\n }\n impl<A: Iterator, B: Iterator> Zip<A, B> {\n     pub(in crate::iter) fn new(a: A, b: B) -> Zip<A, B> {\n@@ -110,6 +111,7 @@ where\n             b,\n             index: 0, // unused\n             len: 0,   // unused\n+            a_len: 0, // unused\n         }\n     }\n \n@@ -184,8 +186,9 @@ where\n     B: TrustedRandomAccess + Iterator,\n {\n     fn new(a: A, b: B) -> Self {\n-        let len = cmp::min(a.size(), b.size());\n-        Zip { a, b, index: 0, len }\n+        let a_len = a.size();\n+        let len = cmp::min(a_len, b.size());\n+        Zip { a, b, index: 0, len, a_len }\n     }\n \n     #[inline]\n@@ -197,7 +200,7 @@ where\n             unsafe {\n                 Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))\n             }\n-        } else if A::MAY_HAVE_SIDE_EFFECT && self.index < self.a.size() {\n+        } else if A::MAY_HAVE_SIDE_EFFECT && self.index < self.a_len {\n             let i = self.index;\n             self.index += 1;\n             self.len += 1;\n@@ -262,6 +265,7 @@ where\n                     for _ in 0..sz_a - self.len {\n                         self.a.next_back();\n                     }\n+                    self.a_len = self.len;\n                 }\n                 let sz_b = self.b.size();\n                 if B::MAY_HAVE_SIDE_EFFECT && sz_b > self.len {\n@@ -273,6 +277,7 @@ where\n         }\n         if self.index < self.len {\n             self.len -= 1;\n+            self.a_len -= 1;\n             let i = self.len;\n             // SAFETY: `i` is smaller than the previous value of `self.len`,\n             // which is also smaller than or equal to `self.a.len()` and `self.b.len()`"}, {"sha": "cb072931232de22f8243ae0bf1fa9bd2d0c3796e", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -39,10 +39,11 @@ use crate::ptr;\n /// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! \u26a0\ufe0f\n /// ```\n ///\n-/// Moreover, uninitialized memory is special in that the compiler knows that\n-/// it does not have a fixed value. This makes it undefined behavior to have\n-/// uninitialized data in a variable even if that variable has an integer type,\n-/// which otherwise can hold any *fixed* bit pattern:\n+/// Moreover, uninitialized memory is special in that it does not have a fixed value (\"fixed\"\n+/// meaning \"it won't change without being written to\"). Reading the same uninitialized byte\n+/// multiple times can give different results. This makes it undefined behavior to have\n+/// uninitialized data in a variable even if that variable has an integer type, which otherwise can\n+/// hold any *fixed* bit pattern:\n ///\n /// ```rust,no_run\n /// # #![allow(invalid_value)]"}, {"sha": "e3c812a047c8c4b7f85f9d440247f38309855601", "filename": "library/core/src/option.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -150,7 +150,7 @@\n use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n use crate::pin::Pin;\n use crate::{\n-    convert, fmt, hint, mem,\n+    fmt, hint, mem,\n     ops::{self, Deref, DerefMut},\n };\n \n@@ -1275,7 +1275,8 @@ impl<T, E> Option<Result<T, E>> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"transpose_result\", since = \"1.33.0\")]\n-    pub fn transpose(self) -> Result<Option<T>, E> {\n+    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n+    pub const fn transpose(self) -> Result<Option<T>, E> {\n         match self {\n             Some(Ok(x)) => Ok(Some(x)),\n             Some(Err(e)) => Err(e),\n@@ -1750,7 +1751,11 @@ impl<T> Option<Option<T>> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_flattening\", since = \"1.40.0\")]\n-    pub fn flatten(self) -> Option<T> {\n-        self.and_then(convert::identity)\n+    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n+    pub const fn flatten(self) -> Option<T> {\n+        match self {\n+            Some(inner) => inner,\n+            None => None,\n+        }\n     }\n }"}, {"sha": "62ca07fc5a4e20f677f2e4c10d2f8c6725d2e3d5", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -320,25 +320,31 @@ impl<T: ?Sized> *const T {\n     /// * Both pointers must be *derived from* a pointer to the same object.\n     ///   (See below for an example.)\n     ///\n-    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n-    ///\n     /// * The distance between the pointers, in bytes, must be an exact multiple\n     ///   of the size of `T`.\n     ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n     /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n     ///\n-    /// The compiler and standard library generally try to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    /// Rust types are never larger than `isize::MAX` and Rust allocations never wrap around the\n+    /// address space, so two pointers within some value of any Rust type `T` will always satisfy\n+    /// the last two conditions. The standard library also generally ensures that allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec` and `Box` ensure they\n+    /// never allocate more than `isize::MAX` bytes, so `ptr_into_vec.offset_from(vec.as_ptr())`\n+    /// always satisfies the last two conditions.\n     ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// Most platforms fundamentally can't even construct such a large allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n     /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n+    /// (Note that [`offset`] and [`add`] also have a similar limitation and hence cannot be used on\n+    /// such large allocations either.)\n+    ///\n+    /// [`add`]: #method.add\n     ///\n     /// # Panics\n     ///"}, {"sha": "a365b66d8fcf4d072fcc2ce5156f4ec4c4660465", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -491,25 +491,31 @@ impl<T: ?Sized> *mut T {\n     /// * Both pointers must be *derived from* a pointer to the same object.\n     ///   (See below for an example.)\n     ///\n-    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n-    ///\n     /// * The distance between the pointers, in bytes, must be an exact multiple\n     ///   of the size of `T`.\n     ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n     /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n     ///\n-    /// The compiler and standard library generally try to ensure allocations\n-    /// never reach a size where an offset is a concern. For instance, `Vec`\n-    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n-    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    /// Rust types are never larger than `isize::MAX` and Rust allocations never wrap around the\n+    /// address space, so two pointers within some value of any Rust type `T` will always satisfy\n+    /// the last two conditions. The standard library also generally ensures that allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec` and `Box` ensure they\n+    /// never allocate more than `isize::MAX` bytes, so `ptr_into_vec.offset_from(vec.as_ptr())`\n+    /// always satisfies the last two conditions.\n     ///\n-    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// Most platforms fundamentally can't even construct such a large allocation.\n     /// For instance, no known 64-bit platform can ever serve a request\n     /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n     /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n     /// more than `isize::MAX` bytes with things like Physical Address\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n+    /// (Note that [`offset`] and [`add`] also have a similar limitation and hence cannot be used on\n+    /// such large allocations either.)\n+    ///\n+    /// [`add`]: #method.add\n     ///\n     /// # Panics\n     ///"}, {"sha": "2ce8a703c123ef165e5268e1b9d47e284d8e97e9", "filename": "library/core/src/result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1233,7 +1233,8 @@ impl<T, E> Result<Option<T>, E> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"transpose_result\", since = \"1.33.0\")]\n-    pub fn transpose(self) -> Option<Result<T, E>> {\n+    #[rustc_const_unstable(feature = \"const_result\", issue = \"82814\")]\n+    pub const fn transpose(self) -> Option<Result<T, E>> {\n         match self {\n             Ok(Some(x)) => Some(Ok(x)),\n             Ok(None) => None,"}, {"sha": "000c15f72c886d35df0fb64dc6958c3bf9df621b", "filename": "library/core/tests/iter/adapters/zip.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -265,3 +265,26 @@ fn test_issue_82282() {\n         panic!();\n     }\n }\n+\n+#[test]\n+fn test_issue_82291() {\n+    use std::cell::Cell;\n+\n+    let mut v1 = [()];\n+    let v2 = [()];\n+\n+    let called = Cell::new(0);\n+\n+    let mut zip = v1\n+        .iter_mut()\n+        .map(|r| {\n+            called.set(called.get() + 1);\n+            r\n+        })\n+        .zip(&v2);\n+\n+    zip.next_back();\n+    assert_eq!(called.get(), 1);\n+    zip.next();\n+    assert_eq!(called.get(), 1);\n+}"}, {"sha": "be5e56c71e36f1fee0c97c09313eeee3e0e124ae", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -15,7 +15,7 @@ cfg_if::cfg_if! {\n         target_os = \"none\",\n     ))] {\n         // These \"unix\" family members do not have unwinder.\n-        // Note this also matches x86_64-linux-kernel.\n+        // Note this also matches x86_64-unknown-none-linuxkernel.\n     } else if #[cfg(any(\n         unix,\n         windows,"}, {"sha": "611117788da88bc7b884b36ad462cdc0b003cd93", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -217,13 +217,13 @@ target | std | host | notes\n `thumbv4t-none-eabi` | * |  | ARMv4T T32\n `x86_64-apple-ios-macabi` | \u2713 |  | Apple Catalyst on x86_64\n `x86_64-apple-tvos` | * | | x86 64-bit tvOS\n-`x86_64-linux-kernel` | * |  | Linux kernel modules\n+`x86_64-unknown-none-linuxkernel` | * |  | Linux kernel modules\n `x86_64-sun-solaris` | ? |  | Deprecated target for 64-bit Solaris 10/11, illumos\n `x86_64-pc-windows-msvc` | \u2713 |  | 64-bit Windows XP support\n `x86_64-unknown-dragonfly` | \u2713 | \u2713 | 64-bit DragonFlyBSD\n `x86_64-unknown-haiku` | \u2713 | \u2713 | 64-bit Haiku\n `x86_64-unknown-hermit` | ? |  |\n-`x86_64-unknown-hermit-kernel` | ? |  | HermitCore kernel\n+`x86_64-unknown-none-hermitkernel` | ? |  | HermitCore kernel\n `x86_64-unknown-l4re-uclibc` | ? |  |\n `x86_64-unknown-openbsd` | \u2713 | \u2713 | 64-bit OpenBSD\n `x86_64-unknown-uefi` | ? |  |"}, {"sha": "a94ee918c24672d37ba9c2ec7770de0ec796f797", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1615,24 +1615,6 @@ impl PrimitiveType {\n         CELL.get_or_init(move || {\n             use self::PrimitiveType::*;\n \n-            /// A macro to create a FxHashMap.\n-            ///\n-            /// Example:\n-            ///\n-            /// ```\n-            /// let letters = map!{\"a\" => \"b\", \"c\" => \"d\"};\n-            /// ```\n-            ///\n-            /// Trailing commas are allowed.\n-            /// Commas between elements are required (even if the expression is a block).\n-            macro_rules! map {\n-                ($( $key: expr => $val: expr ),* $(,)*) => {{\n-                    let mut map = ::rustc_data_structures::fx::FxHashMap::default();\n-                    $( map.insert($key, $val); )*\n-                    map\n-                }}\n-            }\n-\n             let single = |a: Option<DefId>| a.into_iter().collect();\n             let both = |a: Option<DefId>, b: Option<DefId>| -> ArrayVec<_> {\n                 a.into_iter().chain(b).collect()"}, {"sha": "ecb6378f31fb452fe61e588fe82f3f0493c5b007", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -315,6 +315,13 @@ impl Options {\n             return Err(0);\n         }\n \n+        if matches.opt_strs(\"print\").iter().any(|opt| opt == \"unversioned-files\") {\n+            for file in crate::html::render::FILES_UNVERSIONED.keys() {\n+                println!(\"{}\", file);\n+            }\n+            return Err(0);\n+        }\n+\n         let color = config::parse_color(&matches);\n         let (json_rendered, _artifacts) = config::parse_json(&matches);\n         let error_format = config::parse_error_format(&matches, color, json_rendered);\n@@ -658,9 +665,8 @@ fn check_deprecated_options(matches: &getopts::Matches, diag: &rustc_errors::Han\n             {\n                 continue;\n             }\n-            let mut err =\n-                diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\", flag));\n-            err.warn(\n+            let mut err = diag.struct_warn(&format!(\"the `{}` flag is deprecated\", flag));\n+            err.note(\n                 \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n                  for more information\",\n             );"}, {"sha": "e9c32396e845975d3b9bc4e0ac57deaf95b9cc5f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -22,7 +22,7 @@ use rustc_session::DiagnosticOutput;\n use rustc_session::Session;\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{Span, DUMMY_SP};\n \n use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n@@ -76,7 +76,7 @@ crate struct DocContext<'tcx> {\n     ///\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     /// `map<module, set<trait>>`\n-    crate module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n+    crate module_trait_cache: FxHashMap<DefId, FxHashSet<DefId>>,\n     /// This same cache is used throughout rustdoc, including in [`crate::html::render`].\n     crate cache: Cache,\n     /// Used by [`clean::inline`] to tell if an item has already been inlined.\n@@ -169,13 +169,13 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<HirId> {\n         if MAX_DEF_IDX.with(|m| {\n             m.borrow().get(&def_id.krate).map(|&idx| idx <= def_id.index).unwrap_or(false)\n         }) {\n             None\n         } else {\n-            def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n+            def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n         }\n     }\n }\n@@ -389,7 +389,7 @@ crate fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n     resolver: Rc<RefCell<interface::BoxedResolver>>,\n     mut default_passes: passes::DefaultPassOption,\n-    mut manual_passes: Vec<String>,\n+    manual_passes: Vec<String>,\n     render_options: RenderOptions,\n     output_format: OutputFormat,\n ) -> (clean::Crate, RenderOptions, Cache) {\n@@ -450,7 +450,7 @@ crate fn run_global_ctxt(\n             .cloned()\n             .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n             .collect(),\n-        module_trait_cache: RefCell::new(FxHashMap::default()),\n+        module_trait_cache: FxHashMap::default(),\n         cache: Cache::new(access_levels, render_options.document_private),\n         inlined: FxHashSet::default(),\n         output_format,\n@@ -479,7 +479,7 @@ crate fn run_global_ctxt(\n                 https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation.html\";\n             tcx.struct_lint_node(\n                 crate::lint::MISSING_CRATE_LEVEL_DOCS,\n-                ctxt.as_local_hir_id(m.def_id).unwrap(),\n+                DocContext::as_local_hir_id(tcx, m.def_id).unwrap(),\n                 |lint| {\n                     let mut diag =\n                         lint.build(\"no documentation found for this crate's top-level module\");\n@@ -490,21 +490,44 @@ crate fn run_global_ctxt(\n         }\n     }\n \n-    fn report_deprecated_attr(name: &str, diag: &rustc_errors::Handler) {\n-        let mut msg = diag\n-            .struct_warn(&format!(\"the `#![doc({})]` attribute is considered deprecated\", name));\n-        msg.warn(\n+    fn report_deprecated_attr(name: &str, diag: &rustc_errors::Handler, sp: Span) {\n+        let mut msg =\n+            diag.struct_span_warn(sp, &format!(\"the `#![doc({})]` attribute is deprecated\", name));\n+        msg.note(\n             \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n              for more information\",\n         );\n \n         if name == \"no_default_passes\" {\n             msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n+        } else if name.starts_with(\"plugins\") {\n+            msg.warn(\"`#![doc(plugins = \\\"...\\\")]` no longer functions; see CVE-2018-1000622 <https://nvd.nist.gov/vuln/detail/CVE-2018-1000622>\");\n         }\n \n         msg.emit();\n     }\n \n+    let parse_pass = |name: &str, sp: Option<Span>| {\n+        if let Some(pass) = passes::find_pass(name) {\n+            Some(ConditionalPass::always(pass))\n+        } else {\n+            let msg = &format!(\"ignoring unknown pass `{}`\", name);\n+            let mut warning = if let Some(sp) = sp {\n+                tcx.sess.struct_span_warn(sp, msg)\n+            } else {\n+                tcx.sess.struct_warn(msg)\n+            };\n+            if name == \"collapse-docs\" {\n+                warning.note(\"the `collapse-docs` pass was removed in #80261 <https://github.com/rust-lang/rust/pull/80261>\");\n+            }\n+            warning.emit();\n+            None\n+        }\n+    };\n+\n+    let mut manual_passes: Vec<_> =\n+        manual_passes.into_iter().flat_map(|name| parse_pass(&name, None)).collect();\n+\n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run.\n     for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n@@ -513,29 +536,25 @@ crate fn run_global_ctxt(\n         let name = attr.name_or_empty();\n         if attr.is_word() {\n             if name == sym::no_default_passes {\n-                report_deprecated_attr(\"no_default_passes\", diag);\n+                report_deprecated_attr(\"no_default_passes\", diag, attr.span());\n                 if default_passes == passes::DefaultPassOption::Default {\n                     default_passes = passes::DefaultPassOption::None;\n                 }\n             }\n         } else if let Some(value) = attr.value_str() {\n-            let sink = match name {\n+            match name {\n                 sym::passes => {\n-                    report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n-                    &mut manual_passes\n+                    report_deprecated_attr(\"passes = \\\"...\\\"\", diag, attr.span());\n                 }\n                 sym::plugins => {\n-                    report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n-                    eprintln!(\n-                        \"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n-                         no longer functions; see CVE-2018-1000622\"\n-                    );\n+                    report_deprecated_attr(\"plugins = \\\"...\\\"\", diag, attr.span());\n                     continue;\n                 }\n                 _ => continue,\n             };\n             for name in value.as_str().split_whitespace() {\n-                sink.push(name.to_string());\n+                let span = attr.name_value_literal_span().unwrap_or(attr.span());\n+                manual_passes.extend(parse_pass(name, Some(span)));\n             }\n         }\n \n@@ -544,17 +563,7 @@ crate fn run_global_ctxt(\n         }\n     }\n \n-    let passes = passes::defaults(default_passes).iter().copied().chain(\n-        manual_passes.into_iter().flat_map(|name| {\n-            if let Some(pass) = passes::find_pass(&name) {\n-                Some(ConditionalPass::always(pass))\n-            } else {\n-                error!(\"unknown pass {}, skipping\", name);\n-                None\n-            }\n-        }),\n-    );\n-\n+    let passes = passes::defaults(default_passes).iter().copied().chain(manual_passes);\n     info!(\"Executing passes\");\n \n     for p in passes {"}, {"sha": "9b9ec2581cfc2c1531aa25293b7f98d09d8197e2", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -33,6 +33,7 @@ mod print_item;\n mod write_shared;\n \n crate use context::*;\n+crate use write_shared::FILES_UNVERSIONED;\n \n use std::cell::{Cell, RefCell};\n use std::collections::VecDeque;"}, {"sha": "02ad01aa29a02e2d8c74ef0f94678c303fe67fda", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -3,6 +3,7 @@ use std::fmt::Write;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n+use std::lazy::SyncLazy as Lazy;\n use std::path::{Component, Path, PathBuf};\n \n use itertools::Itertools;\n@@ -18,6 +19,26 @@ use crate::error::Error;\n use crate::formats::FormatRenderer;\n use crate::html::{layout, static_files};\n \n+crate static FILES_UNVERSIONED: Lazy<FxHashMap<&str, &[u8]>> = Lazy::new(|| {\n+    map! {\n+        \"FiraSans-Regular.woff2\" => static_files::fira_sans::REGULAR2,\n+        \"FiraSans-Medium.woff2\" => static_files::fira_sans::MEDIUM2,\n+        \"FiraSans-Regular.woff\" => static_files::fira_sans::REGULAR,\n+        \"FiraSans-Medium.woff\" => static_files::fira_sans::MEDIUM,\n+        \"FiraSans-LICENSE.txt\" => static_files::fira_sans::LICENSE,\n+        \"SourceSerifPro-Regular.ttf.woff\" => static_files::source_serif_pro::REGULAR,\n+        \"SourceSerifPro-Bold.ttf.woff\" => static_files::source_serif_pro::BOLD,\n+        \"SourceSerifPro-It.ttf.woff\" => static_files::source_serif_pro::ITALIC,\n+        \"SourceSerifPro-LICENSE.md\" => static_files::source_serif_pro::LICENSE,\n+        \"SourceCodePro-Regular.woff\" => static_files::source_code_pro::REGULAR,\n+        \"SourceCodePro-Semibold.woff\" => static_files::source_code_pro::SEMIBOLD,\n+        \"SourceCodePro-LICENSE.txt\" => static_files::source_code_pro::LICENSE,\n+        \"LICENSE-MIT.txt\" => static_files::LICENSE_MIT,\n+        \"LICENSE-APACHE.txt\" => static_files::LICENSE_APACHE,\n+        \"COPYRIGHT.txt\" => static_files::COPYRIGHT,\n+    }\n+});\n+\n pub(super) fn write_shared(\n     cx: &Context<'_>,\n     krate: &Crate,\n@@ -212,21 +233,9 @@ themePicker.onblur = handleThemeButtonsBlur;\n         static_files::NORMALIZE_CSS,\n         options.enable_minification,\n     )?;\n-    write(cx.dst.join(\"FiraSans-Regular.woff2\"), static_files::fira_sans::REGULAR2)?;\n-    write(cx.dst.join(\"FiraSans-Medium.woff2\"), static_files::fira_sans::MEDIUM2)?;\n-    write(cx.dst.join(\"FiraSans-Regular.woff\"), static_files::fira_sans::REGULAR)?;\n-    write(cx.dst.join(\"FiraSans-Medium.woff\"), static_files::fira_sans::MEDIUM)?;\n-    write(cx.dst.join(\"FiraSans-LICENSE.txt\"), static_files::fira_sans::LICENSE)?;\n-    write(cx.dst.join(\"SourceSerifPro-Regular.ttf.woff\"), static_files::source_serif_pro::REGULAR)?;\n-    write(cx.dst.join(\"SourceSerifPro-Bold.ttf.woff\"), static_files::source_serif_pro::BOLD)?;\n-    write(cx.dst.join(\"SourceSerifPro-It.ttf.woff\"), static_files::source_serif_pro::ITALIC)?;\n-    write(cx.dst.join(\"SourceSerifPro-LICENSE.md\"), static_files::source_serif_pro::LICENSE)?;\n-    write(cx.dst.join(\"SourceCodePro-Regular.woff\"), static_files::source_code_pro::REGULAR)?;\n-    write(cx.dst.join(\"SourceCodePro-Semibold.woff\"), static_files::source_code_pro::SEMIBOLD)?;\n-    write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"), static_files::source_code_pro::LICENSE)?;\n-    write(cx.dst.join(\"LICENSE-MIT.txt\"), static_files::LICENSE_MIT)?;\n-    write(cx.dst.join(\"LICENSE-APACHE.txt\"), static_files::LICENSE_APACHE)?;\n-    write(cx.dst.join(\"COPYRIGHT.txt\"), static_files::COPYRIGHT)?;\n+    for (file, contents) in &*FILES_UNVERSIONED {\n+        write(cx.dst.join(file), contents)?;\n+    }\n \n     fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();"}, {"sha": "9e8432454429fcfd6c93420e5d5e39b9e3369a97", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -71,6 +71,24 @@ use rustc_session::config::{make_crate_type_option, ErrorOutputType, RustcOptGro\n use rustc_session::getopts;\n use rustc_session::{early_error, early_warn};\n \n+/// A macro to create a FxHashMap.\n+///\n+/// Example:\n+///\n+/// ```\n+/// let letters = map!{\"a\" => \"b\", \"c\" => \"d\"};\n+/// ```\n+///\n+/// Trailing commas are allowed.\n+/// Commas between elements are required (even if the expression is a block).\n+macro_rules! map {\n+    ($( $key: expr => $val: expr ),* $(,)*) => {{\n+        let mut map = ::rustc_data_structures::fx::FxHashMap::default();\n+        $( map.insert($key, $val); )*\n+        map\n+    }}\n+}\n+\n #[macro_use]\n mod externalfiles;\n \n@@ -506,6 +524,9 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"Generate JSON file at the top level instead of generating HTML redirection files\",\n             )\n         }),\n+        unstable(\"print\", |o| {\n+            o.optmulti(\"\", \"print\", \"Rustdoc information to print on stdout\", \"[unversioned-files]\")\n+        }),\n     ]\n }\n "}, {"sha": "98886139f30882bf45efaf803eab359e03d54180", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -48,9 +48,12 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n         let buffer = buffer.borrow();\n \n         if buffer.has_errors || is_empty {\n-            let mut diag = if let Some(sp) =\n-                super::source_span_for_markdown_range(self.cx, &dox, &code_block.range, &item.attrs)\n-            {\n+            let mut diag = if let Some(sp) = super::source_span_for_markdown_range(\n+                self.cx.tcx,\n+                &dox,\n+                &code_block.range,\n+                &item.attrs,\n+            ) {\n                 let (warning_message, suggest_using_text) = if buffer.has_errors {\n                     (\"could not parse code block as Rust code\", true)\n                 } else {"}, {"sha": "ec5994b762b8a9e385344e4c264cc87f2d795bf4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -484,21 +484,23 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// Resolves a string as a path within a particular namespace. Returns an\n     /// optional URL fragment in the case of variants and methods.\n     fn resolve<'path>(\n-        &self,\n+        &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = &self.cx;\n+        let tcx = self.cx.tcx;\n \n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n                 // item a separate function.\n                 Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => assert_eq!(ns, ValueNS),\n                 Res::Def(DefKind::AssocTy, _) => assert_eq!(ns, TypeNS),\n-                Res::Def(DefKind::Variant, _) => return handle_variant(cx, res, extra_fragment),\n+                Res::Def(DefKind::Variant, _) => {\n+                    return handle_variant(self.cx, res, extra_fragment);\n+                }\n                 // Not a trait item; just return what we found.\n                 Res::Primitive(ty) => {\n                     if extra_fragment.is_some() {\n@@ -565,13 +567,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ) => {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                 // Checks if item_name belongs to `impl SomeItem`\n-                let assoc_item = cx\n-                    .tcx\n+                let assoc_item = tcx\n                     .inherent_impls(did)\n                     .iter()\n                     .flat_map(|&imp| {\n-                        cx.tcx.associated_items(imp).find_by_name_and_namespace(\n-                            cx.tcx,\n+                        tcx.associated_items(imp).find_by_name_and_namespace(\n+                            tcx,\n                             Ident::with_dummy_span(item_name),\n                             ns,\n                             imp,\n@@ -587,7 +588,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n                         let kind =\n-                            resolve_associated_trait_item(did, module_id, item_name, ns, &self.cx);\n+                            resolve_associated_trait_item(did, module_id, item_name, ns, self.cx);\n                         debug!(\"got associated item kind {:?}\", kind);\n                         kind\n                     });\n@@ -611,7 +612,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n                     // FIXME(jynelson): why is this different from\n                     // `variant_field`?\n-                    match cx.tcx.type_of(did).kind() {\n+                    match tcx.type_of(did).kind() {\n                         ty::Adt(def, _) => {\n                             let field = if def.is_enum() {\n                                 def.all_fields().find(|item| item.ident.name == item_name)\n@@ -652,10 +653,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     None\n                 }\n             }\n-            Res::Def(DefKind::Trait, did) => cx\n-                .tcx\n+            Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n-                .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n+                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n                     let kind = match item.kind {\n                         ty::AssocKind::Const => \"associatedconstant\",\n@@ -699,7 +699,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// This returns the `Res` even if it was erroneous for some reason\n     /// (such as having invalid URL fragments or being in the wrong namespace).\n     fn check_full_res(\n-        &self,\n+        &mut self,\n         ns: Namespace,\n         path_str: &str,\n         module_id: DefId,\n@@ -733,7 +733,7 @@ fn resolve_associated_trait_item(\n     module: DefId,\n     item_name: Symbol,\n     ns: Namespace,\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n ) -> Option<(ty::AssocKind, DefId)> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n@@ -758,10 +758,10 @@ fn resolve_associated_trait_item(\n ///\n /// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n /// So it is not stable to serialize cross-crate.\n-fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n-    let mut cache = cx.module_trait_cache.borrow_mut();\n-    let in_scope_traits = cache.entry(module).or_insert_with(|| {\n-        cx.enter_resolver(|resolver| {\n+fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n+    let mut resolver = cx.resolver.borrow_mut();\n+    let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n+        resolver.access(|resolver| {\n             let parent_scope = &ParentScope::module(resolver.get_module(module), resolver);\n             resolver\n                 .traits_in_scope(None, parent_scope, SyntaxContext::root(), None)\n@@ -771,13 +771,14 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n         })\n     });\n \n-    let ty = cx.tcx.type_of(type_);\n+    let tcx = cx.tcx;\n+    let ty = tcx.type_of(type_);\n     let iter = in_scope_traits.iter().flat_map(|&trait_| {\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n         // Look at each trait implementation to see if it's an impl for `did`\n-        cx.tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n-            let trait_ref = cx.tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n+        tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n+            let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.self_ty();\n             trace!(\n@@ -1146,7 +1147,7 @@ impl LinkCollector<'_, '_> {\n                 suggest_disambiguator(resolved, diag, path_str, dox, sp, &ori_link.range);\n             };\n             report_diagnostic(\n-                self.cx,\n+                self.cx.tcx,\n                 BROKEN_INTRA_DOC_LINKS,\n                 &msg,\n                 &item,\n@@ -1220,7 +1221,7 @@ impl LinkCollector<'_, '_> {\n                         && !self.cx.tcx.features().intra_doc_pointers\n                     {\n                         let span = super::source_span_for_markdown_range(\n-                            self.cx,\n+                            self.cx.tcx,\n                             dox,\n                             &ori_link.range,\n                             &item.attrs,\n@@ -1308,7 +1309,7 @@ impl LinkCollector<'_, '_> {\n     /// After parsing the disambiguator, resolve the main part of the link.\n     // FIXME(jynelson): wow this is just so much\n     fn resolve_with_disambiguator(\n-        &self,\n+        &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n     ) -> Option<(Res, Option<String>)> {\n@@ -1674,15 +1675,15 @@ impl Suggestion {\n /// parameter of the callback will contain it, and the primary span of the diagnostic will be set\n /// to it.\n fn report_diagnostic(\n-    cx: &DocContext<'_>,\n+    tcx: TyCtxt<'_>,\n     lint: &'static Lint,\n     msg: &str,\n     item: &Item,\n     dox: &str,\n     link_range: &Range<usize>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n-    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+    let hir_id = match DocContext::as_local_hir_id(tcx, item.def_id) {\n         Some(hir_id) => hir_id,\n         None => {\n             // If non-local, no need to check anything.\n@@ -1694,10 +1695,10 @@ fn report_diagnostic(\n     let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs).unwrap_or(item.source.span());\n \n-    cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n+    tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n         let mut diag = lint.build(msg);\n \n-        let span = super::source_span_for_markdown_range(cx, dox, link_range, attrs);\n+        let span = super::source_span_for_markdown_range(tcx, dox, link_range, attrs);\n \n         if let Some(sp) = span {\n             diag.set_span(sp);\n@@ -1732,7 +1733,7 @@ fn report_diagnostic(\n /// handled earlier. For example, if passed `Item::Crate(std)` and `path_str`\n /// `std::io::Error::x`, this will resolve `std::io::Error`.\n fn resolution_failure(\n-    collector: &LinkCollector<'_, '_>,\n+    collector: &mut LinkCollector<'_, '_>,\n     item: &Item,\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n@@ -1742,7 +1743,7 @@ fn resolution_failure(\n ) {\n     let tcx = collector.cx.tcx;\n     report_diagnostic(\n-        collector.cx,\n+        tcx,\n         BROKEN_INTRA_DOC_LINKS,\n         &format!(\"unresolved link to `{}`\", path_str),\n         item,\n@@ -1973,7 +1974,7 @@ fn anchor_failure(\n         ),\n     };\n \n-    report_diagnostic(cx, BROKEN_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"contains invalid anchor\");\n         }\n@@ -2013,7 +2014,7 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx, BROKEN_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n@@ -2066,7 +2067,7 @@ fn privacy_error(cx: &DocContext<'_>, item: &Item, path_str: &str, dox: &str, li\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx, PRIVATE_INTRA_DOC_LINKS, &msg, item, dox, &link.range, |diag, sp| {\n+    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, &msg, item, dox, &link.range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }"}, {"sha": "951258db9e2a28edf79a366aafbf37408f0f0aea", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -82,7 +82,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n }\n \n crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n-    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+    let hir_id = match DocContext::as_local_hir_id(cx.tcx, item.def_id) {\n         Some(hir_id) => hir_id,\n         None => {\n             // If non-local, no need to check anything."}, {"sha": "23364b6fec9d139de44c4ed212a0d4d2acaadceb", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -167,7 +167,8 @@ fn extract_tags(\n \n impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        let hir_id = match self.cx.as_local_hir_id(item.def_id) {\n+        let tcx = self.cx.tcx;\n+        let hir_id = match DocContext::as_local_hir_id(tcx, item.def_id) {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything.\n@@ -176,13 +177,13 @@ impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n         };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n         if !dox.is_empty() {\n-            let cx = &self.cx;\n             let report_diag = |msg: &str, range: &Range<usize>| {\n-                let sp = match super::source_span_for_markdown_range(cx, &dox, range, &item.attrs) {\n+                let sp = match super::source_span_for_markdown_range(tcx, &dox, range, &item.attrs)\n+                {\n                     Some(sp) => sp,\n                     None => span_of_attrs(&item.attrs).unwrap_or(item.source.span()),\n                 };\n-                cx.tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, |lint| {\n+                tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, |lint| {\n                     lint.build(msg).emit()\n                 });\n             };"}, {"sha": "4c639c8496db30108b4e468d0769fafd89deaf08", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,6 +1,7 @@\n //! Contains information about \"passes\", used to modify crate information during the documentation\n //! process.\n \n+use rustc_middle::ty::TyCtxt;\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use std::ops::Range;\n \n@@ -167,7 +168,7 @@ crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n /// attributes are not all sugared doc comments. It's difficult to calculate the correct span in\n /// that case due to escaping and other source features.\n crate fn source_span_for_markdown_range(\n-    cx: &DocContext<'_>,\n+    tcx: TyCtxt<'_>,\n     markdown: &str,\n     md_range: &Range<usize>,\n     attrs: &clean::Attributes,\n@@ -179,7 +180,7 @@ crate fn source_span_for_markdown_range(\n         return None;\n     }\n \n-    let snippet = cx.sess().source_map().span_to_snippet(span_of_attrs(attrs)?).ok()?;\n+    let snippet = tcx.sess.source_map().span_to_snippet(span_of_attrs(attrs)?).ok()?;\n \n     let starting_line = markdown[..md_range.start].matches('\\n').count();\n     let ending_line = starting_line + markdown[md_range.start..md_range.end].matches('\\n').count();"}, {"sha": "16ad940c627173d04b7d56142934c81d7e139dc7", "filename": "src/librustdoc/passes/non_autolinks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -60,7 +60,7 @@ crate fn check_non_autolinks(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n \n impl<'a, 'tcx> DocFolder for NonAutolinksLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        let hir_id = match self.cx.as_local_hir_id(item.def_id) {\n+        let hir_id = match DocContext::as_local_hir_id(self.cx.tcx, item.def_id) {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything.\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> DocFolder for NonAutolinksLinter<'a, 'tcx> {\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n         if !dox.is_empty() {\n             let report_diag = |cx: &DocContext<'_>, msg: &str, url: &str, range: Range<usize>| {\n-                let sp = super::source_span_for_markdown_range(cx, &dox, &range, &item.attrs)\n+                let sp = super::source_span_for_markdown_range(cx.tcx, &dox, &range, &item.attrs)\n                     .or_else(|| span_of_attrs(&item.attrs))\n                     .unwrap_or(item.source.span());\n                 cx.tcx.struct_span_lint_hir(crate::lint::NON_AUTOLINKS, hir_id, sp, |lint| {"}, {"sha": "e368f61cddfc3f5bc7e74e2f6484b55388a6b5b4", "filename": "src/test/run-make-fulldeps/print-unversioned-files/Makefile", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Frun-make-fulldeps%2Fprint-unversioned-files%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Frun-make-fulldeps%2Fprint-unversioned-files%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fprint-unversioned-files%2FMakefile?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -0,0 +1,4 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTDOC) -Z unstable-options --print unversioned-files | sort | diff - unversioned-files.txt"}, {"sha": "c5a9bf24381602004ff898faf449f89614bf053f", "filename": "src/test/run-make-fulldeps/print-unversioned-files/unversioned-files.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Frun-make-fulldeps%2Fprint-unversioned-files%2Funversioned-files.txt", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Frun-make-fulldeps%2Fprint-unversioned-files%2Funversioned-files.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fprint-unversioned-files%2Funversioned-files.txt?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -0,0 +1,15 @@\n+COPYRIGHT.txt\n+FiraSans-LICENSE.txt\n+FiraSans-Medium.woff\n+FiraSans-Medium.woff2\n+FiraSans-Regular.woff\n+FiraSans-Regular.woff2\n+LICENSE-APACHE.txt\n+LICENSE-MIT.txt\n+SourceCodePro-LICENSE.txt\n+SourceCodePro-Regular.woff\n+SourceCodePro-Semibold.woff\n+SourceSerifPro-Bold.ttf.woff\n+SourceSerifPro-It.ttf.woff\n+SourceSerifPro-LICENSE.md\n+SourceSerifPro-Regular.ttf.woff"}, {"sha": "5febc5eb9cd543221f6836b897d332f06005ca48", "filename": "src/test/rustdoc-ui/deprecated-attrs.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,7 +1,17 @@\n // check-pass\n+// compile-flags: --passes unknown-pass\n+// error-pattern: ignoring unknown pass `unknown-pass`\n \n-#![doc(no_default_passes, passes = \"unindent-comments\")]\n-\n-struct SomeStruct;\n-\n-pub struct OtherStruct;\n+#![doc(no_default_passes)]\n+//~^ WARNING attribute is deprecated\n+//~| NOTE see issue #44136\n+//~| HELP use `#![doc(document_private_items)]`\n+#![doc(passes = \"collapse-docs unindent-comments\")]\n+//~^ WARNING attribute is deprecated\n+//~| NOTE see issue #44136\n+//~| WARNING ignoring unknown pass\n+//~| NOTE `collapse-docs` pass was removed\n+#![doc(plugins = \"xxx\")]\n+//~^ WARNING attribute is deprecated\n+//~| NOTE see issue #44136\n+//~| WARNING no longer functions; see CVE"}, {"sha": "b855cedf5223e246222b2e3a35baa02dd21e97e7", "filename": "src/test/rustdoc-ui/deprecated-attrs.stderr", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -1,11 +1,42 @@\n-warning: the `#![doc(no_default_passes)]` attribute is considered deprecated\n+warning: the `passes` flag is deprecated\n    |\n-   = warning: see issue #44136 <https://github.com/rust-lang/rust/issues/44136> for more information\n+   = note: see issue #44136 <https://github.com/rust-lang/rust/issues/44136> for more information\n+\n+warning: ignoring unknown pass `unknown-pass`\n+\n+warning: the `#![doc(no_default_passes)]` attribute is deprecated\n+  --> $DIR/deprecated-attrs.rs:5:8\n+   |\n+LL | #![doc(no_default_passes)]\n+   |        ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #44136 <https://github.com/rust-lang/rust/issues/44136> for more information\n    = help: you may want to use `#![doc(document_private_items)]`\n \n-warning: the `#![doc(passes = \"...\")]` attribute is considered deprecated\n+warning: the `#![doc(passes = \"...\")]` attribute is deprecated\n+  --> $DIR/deprecated-attrs.rs:9:8\n+   |\n+LL | #![doc(passes = \"collapse-docs unindent-comments\")]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #44136 <https://github.com/rust-lang/rust/issues/44136> for more information\n+\n+warning: ignoring unknown pass `collapse-docs`\n+  --> $DIR/deprecated-attrs.rs:9:17\n+   |\n+LL | #![doc(passes = \"collapse-docs unindent-comments\")]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `collapse-docs` pass was removed in #80261 <https://github.com/rust-lang/rust/pull/80261>\n+\n+warning: the `#![doc(plugins = \"...\")]` attribute is deprecated\n+  --> $DIR/deprecated-attrs.rs:14:8\n+   |\n+LL | #![doc(plugins = \"xxx\")]\n+   |        ^^^^^^^^^^^^^^^\n    |\n-   = warning: see issue #44136 <https://github.com/rust-lang/rust/issues/44136> for more information\n+   = note: see issue #44136 <https://github.com/rust-lang/rust/issues/44136> for more information\n+   = warning: `#![doc(plugins = \"...\")]` no longer functions; see CVE-2018-1000622 <https://nvd.nist.gov/vuln/detail/CVE-2018-1000622>\n \n-warning: 2 warnings emitted\n+warning: 5 warnings emitted\n "}, {"sha": "0647a18c3c45deaba05685417397e815fd623a51", "filename": "src/test/ui/abi/nullable-pointer-ffi-compat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fabi%2Fnullable-pointer-ffi-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fabi%2Fnullable-pointer-ffi-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fnullable-pointer-ffi-compat.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/nullable-pointer-ffi-compat.rs"}, {"sha": "0e086968b90562fd06d6d682b0e52d7ca48860d7", "filename": "src/test/ui/associated-types/issue-76179.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fassociated-types%2Fissue-76179.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fassociated-types%2Fissue-76179.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-76179.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-76179.rs"}, {"sha": "2e4f3e675c3b1bcd6b50bd44c70dbf64044faf2e", "filename": "src/test/ui/async-await/issue-74047.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fasync-await%2Fissue-74047.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fasync-await%2Fissue-74047.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74047.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issue-74047.rs"}, {"sha": "28174825d8bce23c79a2749aa8461692f8f9ed49", "filename": "src/test/ui/async-await/issue-74047.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fasync-await%2Fissue-74047.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fasync-await%2Fissue-74047.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74047.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issue-74047.stderr"}, {"sha": "a7636edf2f8db063c20d24a44ab4d7d1e818b8ae", "filename": "src/test/ui/borrowck/issue-42344.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fborrowck%2Fissue-42344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fborrowck%2Fissue-42344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-42344.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-42344.rs"}, {"sha": "5cffa1b51219ff37fba6adbaf4d666f174c743d9", "filename": "src/test/ui/borrowck/issue-42344.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fborrowck%2Fissue-42344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fborrowck%2Fissue-42344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-42344.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-42344.stderr"}, {"sha": "91abdbff868fe04a6dedcc8dbff2f98815fac205", "filename": "src/test/ui/consts/auxiliary/issue-17718-aux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fissue-17718-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fissue-17718-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fissue-17718-aux.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/auxiliary/issue-17718-aux.rs"}, {"sha": "c6341d80844b378bc70b3fcf220c8e951ad8eaa8", "filename": "src/test/ui/consts/issue-17718.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-17718.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-17718.rs"}, {"sha": "f76106dfff1871a6b784208db9e5561297fd6956", "filename": "src/test/ui/consts/issue-3521.fixed", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.fixed?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-3521.fixed"}, {"sha": "c425a22df91737afb327b28247611b3093c96def", "filename": "src/test/ui/consts/issue-3521.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-3521.rs"}, {"sha": "aa42772f12d8a4c0f5b528ff5c1bb112294afaa6", "filename": "src/test/ui/consts/issue-3521.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-3521.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-3521.stderr"}, {"sha": "02c1a166301eb3e0684445c749a90c7b5798a055", "filename": "src/test/ui/issues/issue-2633-2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfe519b344b60e54a2028d3366ca366a228537e3/src%2Ftest%2Fui%2Fissues%2Fissue-2633-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe519b344b60e54a2028d3366ca366a228537e3/src%2Ftest%2Fui%2Fissues%2Fissue-2633-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2633-2.rs?ref=dfe519b344b60e54a2028d3366ca366a228537e3", "patch": "@@ -1,14 +0,0 @@\n-// run-pass\n-// pretty-expanded FIXME #23616\n-\n-#![feature(box_syntax)]\n-\n-\n-fn a_val(x: Box<isize>, y: Box<isize>) -> isize {\n-    *x + *y\n-}\n-\n-pub fn main() {\n-    let z: Box<_> = box 22;\n-    a_val(z.clone(), z.clone());\n-}"}, {"sha": "7e8cea75fc8db8198dd41ba1d3f4ef33334cd80c", "filename": "src/test/ui/issues/issue-2633.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dfe519b344b60e54a2028d3366ca366a228537e3/src%2Ftest%2Fui%2Fissues%2Fissue-2633.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe519b344b60e54a2028d3366ca366a228537e3/src%2Ftest%2Fui%2Fissues%2Fissue-2633.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2633.rs?ref=dfe519b344b60e54a2028d3366ca366a228537e3", "patch": "@@ -1,31 +0,0 @@\n-// run-pass\n-#![allow(dead_code)]\n-#![allow(non_camel_case_types)]\n-\n-#[derive(Copy, Clone)]\n-struct cat {\n-    meow: extern \"Rust\" fn(),\n-}\n-\n-fn meow() {\n-    println!(\"meow\")\n-}\n-\n-fn cat() -> cat {\n-    cat {\n-        meow: meow,\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-struct KittyInfo {kitty: cat}\n-\n-// Code compiles and runs successfully if we add a + before the first arg\n-fn nyan(kitty: cat, _kitty_info: KittyInfo) {\n-    (kitty.meow)();\n-}\n-\n-pub fn main() {\n-    let kitty = cat();\n-    nyan(kitty, KittyInfo {kitty: kitty});\n-}"}, {"sha": "07a32904a5e64408e13fe67ef9fb2c265b37b1cb", "filename": "src/test/ui/lint/lint-expr-stmt-attrs-for-early-lints.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Flint%2Flint-expr-stmt-attrs-for-early-lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Flint%2Flint-expr-stmt-attrs-for-early-lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-expr-stmt-attrs-for-early-lints.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/lint-expr-stmt-attrs-for-early-lints.rs"}, {"sha": "530d1a61b3176572caca4b152937f419d5f1a4d7", "filename": "src/test/ui/nll/issue-52992.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fnll%2Fissue-52992.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fnll%2Fissue-52992.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52992.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-52992.rs"}, {"sha": "64907316626647bc9f7a80c8ef754edae8d956b5", "filename": "src/test/ui/parser/issue-7222.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fissue-7222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fissue-7222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-7222.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-7222.rs"}, {"sha": "15a15a207b1cafd52c363e812cea1fa527bd1d2f", "filename": "src/test/ui/parser/item-free-const-no-body-semantic-fail.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -4,4 +4,3 @@ fn main() {}\n \n const A: u8; //~ ERROR free constant item without body\n const B; //~ ERROR free constant item without body\n-//~^ ERROR missing type for `const` item"}, {"sha": "aa75e5cee01d4985a3a0ae9ea5bad60cf114f5e8", "filename": "src/test/ui/parser/item-free-const-no-body-semantic-fail.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -14,11 +14,5 @@ LL | const B;\n    |        |\n    |        help: provide a definition for the constant: `= <expr>;`\n \n-error: missing type for `const` item\n-  --> $DIR/item-free-const-no-body-semantic-fail.rs:6:7\n-   |\n-LL | const B;\n-   |       ^ help: provide a type for the item: `B: [type error]`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "61d3eab24d8c7b9c257776f39f865b2133b463be", "filename": "src/test/ui/parser/item-free-static-no-body-semantic-fail.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -4,8 +4,6 @@ fn main() {}\n \n static A: u8; //~ ERROR free static item without body\n static B; //~ ERROR free static item without body\n-//~^ ERROR missing type for `static` item\n \n static mut C: u8; //~ ERROR free static item without body\n static mut D; //~ ERROR free static item without body\n-//~^ ERROR missing type for `static mut` item"}, {"sha": "7b408323674de40721d4a158602d93f2509bf677", "filename": "src/test/ui/parser/item-free-static-no-body-semantic-fail.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -15,32 +15,20 @@ LL | static B;\n    |         help: provide a definition for the static: `= <expr>;`\n \n error: free static item without body\n-  --> $DIR/item-free-static-no-body-semantic-fail.rs:9:1\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:8:1\n    |\n LL | static mut C: u8;\n    | ^^^^^^^^^^^^^^^^-\n    |                 |\n    |                 help: provide a definition for the static: `= <expr>;`\n \n error: free static item without body\n-  --> $DIR/item-free-static-no-body-semantic-fail.rs:10:1\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:9:1\n    |\n LL | static mut D;\n    | ^^^^^^^^^^^^-\n    |             |\n    |             help: provide a definition for the static: `= <expr>;`\n \n-error: missing type for `static` item\n-  --> $DIR/item-free-static-no-body-semantic-fail.rs:6:8\n-   |\n-LL | static B;\n-   |        ^ help: provide a type for the item: `B: [type error]`\n-\n-error: missing type for `static mut` item\n-  --> $DIR/item-free-static-no-body-semantic-fail.rs:10:12\n-   |\n-LL | static mut D;\n-   |            ^ help: provide a type for the item: `D: [type error]`\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "b7a44ed86239584cca3d8013e72b8024c67a07c3", "filename": "src/test/ui/regions/issue-6157.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fregions%2Fissue-6157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fregions%2Fissue-6157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-6157.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issue-6157.rs"}, {"sha": "4560caba0cfab040f590d69f6e34a48f39656586", "filename": "src/test/ui/resolve/issue-2330.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fresolve%2Fissue-2330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fresolve%2Fissue-2330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-2330.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-2330.rs"}, {"sha": "877cf68b5866c4f451f4f231aaa8fbddf8bd80dc", "filename": "src/test/ui/resolve/issue-2330.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fresolve%2Fissue-2330.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fresolve%2Fissue-2330.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-2330.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-2330.stderr"}, {"sha": "ec413f6d1d2be527e86b69938d84699128c7e165", "filename": "src/test/ui/statics/issue-15261.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fstatics%2Fissue-15261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fstatics%2Fissue-15261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Fissue-15261.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-15261.rs"}, {"sha": "194ce1dca778913eb8eff173aa3e8ddb9fa539e2", "filename": "src/test/ui/statics/issue-44373-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fstatics%2Fissue-44373-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fstatics%2Fissue-44373-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Fissue-44373-2.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-44373-2.rs"}, {"sha": "0d011d096bd1f210d6ff2f75a43a1c56951dfa0c", "filename": "src/test/ui/statics/issue-44373.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fstatics%2Fissue-44373.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fstatics%2Fissue-44373.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Fissue-44373.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-44373.rs"}, {"sha": "6f92fbb1eb689f81c3c6bd45c83720265d458b8a", "filename": "src/test/ui/statics/issue-44373.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fstatics%2Fissue-44373.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Fstatics%2Fissue-44373.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Fissue-44373.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-44373.stderr"}, {"sha": "5e65a27bf14f5fb18eb087fe5ade3bd3c237e2aa", "filename": "src/test/ui/traits/impl-bounds-checking.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fimpl-bounds-checking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fimpl-bounds-checking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fimpl-bounds-checking.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/impl-bounds-checking.rs"}, {"sha": "8698ed6e875f306f1a4227c789b7eedab51d3351", "filename": "src/test/ui/traits/impl-bounds-checking.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fimpl-bounds-checking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fimpl-bounds-checking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fimpl-bounds-checking.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/impl-bounds-checking.stderr"}, {"sha": "972c839b648032a8f5cdd483e0836f78c0a6a5a8", "filename": "src/test/ui/traits/issue-28576.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fissue-28576.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fissue-28576.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-28576.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-28576.rs"}, {"sha": "203cd0630ebd006af0c87b6c7b83e54c1aec7964", "filename": "src/test/ui/traits/issue-28576.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fissue-28576.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fissue-28576.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-28576.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-28576.stderr"}, {"sha": "9bdac4b8375c265bdcb41f1b3c5f9a1a2fdbdeb9", "filename": "src/test/ui/traits/issue-33140.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fissue-33140.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fissue-33140.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-33140.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-33140.rs"}, {"sha": "9a900d2fc9404b108d038512d9691a11c459b5e3", "filename": "src/test/ui/traits/issue-33140.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fissue-33140.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fissue-33140.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-33140.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-33140.stderr"}, {"sha": "46b68f1c9fe07821b32f4b195d4e19216a1db1b4", "filename": "src/test/ui/traits/object/issue-33140-traitobject-crate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fissue-33140-traitobject-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fissue-33140-traitobject-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fissue-33140-traitobject-crate.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-33140-traitobject-crate.rs"}, {"sha": "781decb5ae2813cc6b2dd1eef21853537bf4b834", "filename": "src/test/ui/traits/object/issue-33140-traitobject-crate.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fissue-33140-traitobject-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fissue-33140-traitobject-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fobject%2Fissue-33140-traitobject-crate.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-33140-traitobject-crate.stderr"}, {"sha": "c29ccc704277ffe188d68e7d1598a3d84f01bc8e", "filename": "src/test/ui/try-block/try-block.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftry-block%2Ftry-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftry-block%2Ftry-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/try-block.rs"}, {"sha": "160477b0b0a6b64786496a4a4ea924585c461ae5", "filename": "src/test/ui/tuple/tup.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftuple%2Ftup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftuple%2Ftup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Ftup.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/tup.rs"}, {"sha": "af2a9c1ba87ef971739ee9667ada685843c789cf", "filename": "src/test/ui/typeck/issue-79040.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    const FOO = \"hello\" + 1; //~ ERROR cannot add `{integer}` to `&str`\n+    //~^ ERROR cannot add `{integer}` to `&str`\n+    println!(\"{}\", FOO);\n+}"}, {"sha": "32049e5d96860a27af505035e8a71aba2b593ab4", "filename": "src/test/ui/typeck/issue-79040.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.stderr?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -0,0 +1,19 @@\n+error[E0369]: cannot add `{integer}` to `&str`\n+  --> $DIR/issue-79040.rs:2:25\n+   |\n+LL |     const FOO = \"hello\" + 1;\n+   |                 ------- ^ - {integer}\n+   |                 |\n+   |                 &str\n+\n+error[E0369]: cannot add `{integer}` to `&str`\n+  --> $DIR/issue-79040.rs:2:25\n+   |\n+LL |     const FOO = \"hello\" + 1;\n+   |                 ------- ^ - {integer}\n+   |                 |\n+   |                 &str\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "e2427243235058d1fbddffb8eb38788614777ada", "filename": "src/test/ui/unboxed-closures/issue-18661.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-18661.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-18661.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-18661.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "previous_filename": "src/test/ui/issues/issue-18661.rs"}, {"sha": "c69bdca7611814786842acc4f96982ae3c84bd13", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec64ccf31883cd2c28d045912a76179c0c6ed2/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=66ec64ccf31883cd2c28d045912a76179c0c6ed2", "patch": "@@ -8,7 +8,7 @@ use std::path::Path;\n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n const ROOT_ENTRY_LIMIT: usize = 1418;\n-const ISSUES_ENTRY_LIMIT: usize = 2582;\n+const ISSUES_ENTRY_LIMIT: usize = 2565;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n     let dirs = walkdir::WalkDir::new(&path.join(\"test/ui\"))"}]}