{"sha": "1adb6643928dd3bacdd079f87f7f4cdacf510823", "node_id": "C_kwDOAAsO6NoAKDFhZGI2NjQzOTI4ZGQzYmFjZGQwNzlmODdmN2Y0Y2RhY2Y1MTA4MjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-10-30T22:33:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-30T22:33:24Z"}, "message": "Rollup merge of #89899 - jkugelman:must-use-alloc, r=joshtriplett\n\nAdd #[must_use] to remaining alloc functions\n\nI've run out of compelling reasons to group functions together across crates so I'm just going to go module-by-module. This is everything remaining from the `alloc` crate.\n\nI ignored these because they might be used to purposefully leak memory... or other allocator shenanigans? I dunno. I'll add them if y'all tell me to.\n\n```rust\nalloc::alloc          unsafe fn alloc(layout: Layout) -> *mut u8;\nalloc::alloc          unsafe fn alloc_zeroed(layout: Layout) -> *mut u8;\nalloc::sync::Arc<T>   fn into_raw(this: Self) -> *const T;\n```\n\nI don't know why clippy ignored these. I added them myself:\n\n```rust\nalloc::collections::btree_map::BTreeMap<K, V>   fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>;\nalloc::collections::btree_set::BTreeSet<T>      fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>;\n```\n\nI added these non-mutating `mut` functions:\n\n```rust\nalloc::collections::btree_map::BTreeMap<K, V>     fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<'_, K, V>;\nalloc::collections::btree_map::BTreeMap<K, V>     fn iter_mut(&mut self) -> IterMut<'_, K, V>;\nalloc::collections::btree_map::BTreeMap<K, V>     fn values_mut(&mut self) -> ValuesMut<'_, K, V>;\nalloc::collections::linked_list::LinkedList<T>    fn iter_mut(&mut self) -> IterMut<'_, T>;\nalloc::collections::linked_list::LinkedList<T>    fn cursor_front_mut(&mut self) -> CursorMut<'_, T>;\nalloc::collections::linked_list::LinkedList<T>    fn cursor_back_mut(&mut self) -> CursorMut<'_, T>;\nalloc::collections::linked_list::LinkedList<T>    fn front_mut(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::LinkedList<T>    fn back_mut(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn current(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn peek_next(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn peek_prev(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn front_mut(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn back_mut(&mut self) -> Option<&mut T>;\n```\n\nI moved a few existing `#[must_use]`s from functions onto the iterator types they return: `IntoIterSorted`, `IntoKeys`, `IntoValues`.\n\nParent issue: #89692\n\nr? `@joshtriplett`", "tree": {"sha": "2d6df739edd26c0d7fee0cc834d4fd441b9a36ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d6df739edd26c0d7fee0cc834d4fd441b9a36ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1adb6643928dd3bacdd079f87f7f4cdacf510823", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhfcg0CRBK7hj4Ov3rIwAAGgIIAHPjjcjIdW4YyEXp0Aehv6WC\nsZ0MdysYvD63MhJHWCv4wmU0IZ/I9y3Lv/jYYAzFvieHyg5r+sM5bXC2Qa7eeI4g\nZmcFL6IfYz2dB+O9vdluCbSHZQ199+LzuTAHBbdCSwlbE6ZpRm4lRtqzRpT3KUc0\nJk6wwGfG7gRI2LRhs0ZVyA+B/1480GHVz58MT3mgmC7QXOEuXw6Id7RuCbbqG864\ncS0gKkJY9hykJom8hlrb91z0ne+Nov0/n2d/m5BwON9119bEY7NIO24N7yJ/UCLc\nwUp4iZEuJE6zF55CHpSAXnacYZVX3FpBojLR0vyNYclspmNBF0AdoF6wGE9g9VA=\n=8eE8\n-----END PGP SIGNATURE-----\n", "payload": "tree 2d6df739edd26c0d7fee0cc834d4fd441b9a36ea\nparent d872d7fd00ead540d13bdf5d51d093e2c8e0b052\nparent fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1635633204 +0200\ncommitter GitHub <noreply@github.com> 1635633204 +0200\n\nRollup merge of #89899 - jkugelman:must-use-alloc, r=joshtriplett\n\nAdd #[must_use] to remaining alloc functions\n\nI've run out of compelling reasons to group functions together across crates so I'm just going to go module-by-module. This is everything remaining from the `alloc` crate.\n\nI ignored these because they might be used to purposefully leak memory... or other allocator shenanigans? I dunno. I'll add them if y'all tell me to.\n\n```rust\nalloc::alloc          unsafe fn alloc(layout: Layout) -> *mut u8;\nalloc::alloc          unsafe fn alloc_zeroed(layout: Layout) -> *mut u8;\nalloc::sync::Arc<T>   fn into_raw(this: Self) -> *const T;\n```\n\nI don't know why clippy ignored these. I added them myself:\n\n```rust\nalloc::collections::btree_map::BTreeMap<K, V>   fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>;\nalloc::collections::btree_set::BTreeSet<T>      fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>;\n```\n\nI added these non-mutating `mut` functions:\n\n```rust\nalloc::collections::btree_map::BTreeMap<K, V>     fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<'_, K, V>;\nalloc::collections::btree_map::BTreeMap<K, V>     fn iter_mut(&mut self) -> IterMut<'_, K, V>;\nalloc::collections::btree_map::BTreeMap<K, V>     fn values_mut(&mut self) -> ValuesMut<'_, K, V>;\nalloc::collections::linked_list::LinkedList<T>    fn iter_mut(&mut self) -> IterMut<'_, T>;\nalloc::collections::linked_list::LinkedList<T>    fn cursor_front_mut(&mut self) -> CursorMut<'_, T>;\nalloc::collections::linked_list::LinkedList<T>    fn cursor_back_mut(&mut self) -> CursorMut<'_, T>;\nalloc::collections::linked_list::LinkedList<T>    fn front_mut(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::LinkedList<T>    fn back_mut(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn current(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn peek_next(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn peek_prev(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn front_mut(&mut self) -> Option<&mut T>;\nalloc::collections::linked_list::CursorMut<'a, T> fn back_mut(&mut self) -> Option<&mut T>;\n```\n\nI moved a few existing `#[must_use]`s from functions onto the iterator types they return: `IntoIterSorted`, `IntoKeys`, `IntoValues`.\n\nParent issue: #89692\n\nr? `@joshtriplett`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1adb6643928dd3bacdd079f87f7f4cdacf510823", "html_url": "https://github.com/rust-lang/rust/commit/1adb6643928dd3bacdd079f87f7f4cdacf510823", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1adb6643928dd3bacdd079f87f7f4cdacf510823/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d872d7fd00ead540d13bdf5d51d093e2c8e0b052", "url": "https://api.github.com/repos/rust-lang/rust/commits/d872d7fd00ead540d13bdf5d51d093e2c8e0b052", "html_url": "https://github.com/rust-lang/rust/commit/d872d7fd00ead540d13bdf5d51d093e2c8e0b052"}, {"sha": "fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb", "html_url": "https://github.com/rust-lang/rust/commit/fb2d0f5c03d2f699eb87bc1986386bdcf6a3f6eb"}], "stats": {"total": 101, "additions": 78, "deletions": 23}, "files": [{"sha": "89c21929dbcda121f7e1183515775682a492e472", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -290,7 +290,7 @@ where\n         let mut c = 0;\n         for i in 0..BENCH_RANGE_SIZE {\n             for j in i + 1..BENCH_RANGE_SIZE {\n-                black_box(map.range(f(i, j)));\n+                let _ = black_box(map.range(f(i, j)));\n                 c += 1;\n             }\n         }\n@@ -322,7 +322,7 @@ fn bench_iter(b: &mut Bencher, repeats: i32, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n         for _ in 0..repeats {\n-            black_box(map.iter());\n+            let _ = black_box(map.iter());\n         }\n     });\n }"}, {"sha": "4e991018bb4413b886971a8990cdcde4e971c9f3", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -512,6 +512,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let vec = heap.into_sorted_vec();\n     /// assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);\n     /// ```\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n     pub fn into_sorted_vec(mut self) -> Vec<T> {\n         let mut end = self.len();\n@@ -850,7 +851,6 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// assert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), vec![5, 4]);\n     /// ```\n-    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n     pub fn into_iter_sorted(self) -> IntoIterSorted<T> {\n         IntoIterSorted { inner: self }\n@@ -877,6 +877,7 @@ impl<T> BinaryHeap<T> {\n     /// # Time complexity\n     ///\n     /// Cost is *O*(1) in the worst case.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n@@ -894,6 +895,7 @@ impl<T> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4);\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n         self.data.capacity()\n@@ -1203,6 +1205,7 @@ impl<T> Drop for Hole<'_, T> {\n /// documentation for more.\n ///\n /// [`iter`]: BinaryHeap::iter\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n@@ -1337,6 +1340,7 @@ impl<I> AsIntoIter for IntoIter<I> {\n     }\n }\n \n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n #[derive(Clone, Debug)]\n pub struct IntoIterSorted<T> {"}, {"sha": "224795876fe5bd5b952067a5b9f85371332923f0", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -288,6 +288,7 @@ where\n /// documentation for more.\n ///\n /// [`iter`]: BTreeMap::iter\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     range: LazyLeafRange<marker::Immut<'a>, K, V>,\n@@ -316,6 +317,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n     _marker: PhantomData<&'a mut (K, V)>,\n }\n \n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IterMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -359,6 +361,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n /// documentation for more.\n ///\n /// [`keys`]: BTreeMap::keys\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -377,6 +380,7 @@ impl<K: fmt::Debug, V> fmt::Debug for Keys<'_, K, V> {\n /// documentation for more.\n ///\n /// [`values`]: BTreeMap::values\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -395,6 +399,7 @@ impl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n /// documentation for more.\n ///\n /// [`values_mut`]: BTreeMap::values_mut\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n@@ -413,6 +418,7 @@ impl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n /// See its documentation for more.\n ///\n /// [`into_keys`]: BTreeMap::into_keys\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n pub struct IntoKeys<K, V> {\n     inner: IntoIter<K, V>,\n@@ -431,6 +437,7 @@ impl<K: fmt::Debug, V> fmt::Debug for IntoKeys<K, V> {\n /// See its documentation for more.\n ///\n /// [`into_values`]: BTreeMap::into_values\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n pub struct IntoValues<K, V> {\n     inner: IntoIter<K, V>,\n@@ -449,6 +456,7 @@ impl<K, V: fmt::Debug> fmt::Debug for IntoValues<K, V> {\n /// documentation for more.\n ///\n /// [`range`]: BTreeMap::range\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, K: 'a, V: 'a> {\n     inner: LeafRange<marker::Immut<'a>, K, V>,\n@@ -467,6 +475,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// documentation for more.\n ///\n /// [`range_mut`]: BTreeMap::range_mut\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n     inner: LeafRange<marker::ValMut<'a>, K, V>,\n@@ -1265,7 +1274,6 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(keys, [1, 2]);\n     /// ```\n     #[inline]\n-    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n     pub fn into_keys(self) -> IntoKeys<K, V> {\n         IntoKeys { inner: self.into_iter() }\n@@ -1288,7 +1296,6 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(values, [\"hello\", \"goodbye\"]);\n     /// ```\n     #[inline]\n-    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"map_into_keys_values\", since = \"1.54.0\")]\n     pub fn into_values(self) -> IntoValues<K, V> {\n         IntoValues { inner: self.into_iter() }"}, {"sha": "5cef007a46f0d1ea9d725fd87c3b8f703288426c", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -347,6 +347,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// map.entry(\"poneyland\").or_insert(12);\n     /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.handle.reborrow().into_kv().0\n@@ -391,6 +392,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     ///     assert_eq!(o.get(), &12);\n     /// }\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.handle.reborrow().into_kv().1"}, {"sha": "17389657afb92564e0371865ff1f5a43f707446a", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -744,35 +744,35 @@ fn test_range_equal_empty_cases() {\n #[should_panic]\n fn test_range_equal_excluded() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Excluded(2), Excluded(2)));\n+    let _ = map.range((Excluded(2), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_1() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Included(3), Included(2)));\n+    let _ = map.range((Included(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_2() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Included(3), Excluded(2)));\n+    let _ = map.range((Included(3), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_3() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Excluded(3), Included(2)));\n+    let _ = map.range((Excluded(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_4() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n-    map.range((Excluded(3), Excluded(2)));\n+    let _ = map.range((Excluded(3), Excluded(2)));\n }\n \n #[test]\n@@ -783,7 +783,7 @@ fn test_range_finding_ill_order_in_map() {\n     // we cause a different panic than `test_range_backwards_1` does.\n     // A more refined `should_panic` would be welcome.\n     if Cyclic3::C < Cyclic3::A {\n-        map.range(Cyclic3::C..=Cyclic3::A);\n+        let _ = map.range(Cyclic3::C..=Cyclic3::A);\n     }\n }\n \n@@ -824,7 +824,7 @@ fn test_range_finding_ill_order_in_range_ord() {\n     }\n \n     let map = (0..12).map(|i| (CompositeKey(i, EvilTwin(i)), ())).collect::<BTreeMap<_, _>>();\n-    map.range(EvilTwin(5)..=EvilTwin(7));\n+    let _ = map.range(EvilTwin(5)..=EvilTwin(7));\n }\n \n #[test]\n@@ -1239,32 +1239,32 @@ fn test_borrow() {\n \n     #[allow(dead_code)]\n     fn get<T: Ord>(v: &BTreeMap<Box<T>, ()>, t: &T) {\n-        v.get(t);\n+        let _ = v.get(t);\n     }\n \n     #[allow(dead_code)]\n     fn get_mut<T: Ord>(v: &mut BTreeMap<Box<T>, ()>, t: &T) {\n-        v.get_mut(t);\n+        let _ = v.get_mut(t);\n     }\n \n     #[allow(dead_code)]\n     fn get_key_value<T: Ord>(v: &BTreeMap<Box<T>, ()>, t: &T) {\n-        v.get_key_value(t);\n+        let _ = v.get_key_value(t);\n     }\n \n     #[allow(dead_code)]\n     fn contains_key<T: Ord>(v: &BTreeMap<Box<T>, ()>, t: &T) {\n-        v.contains_key(t);\n+        let _ = v.contains_key(t);\n     }\n \n     #[allow(dead_code)]\n     fn range<T: Ord>(v: &BTreeMap<Box<T>, ()>, t: T) {\n-        v.range(t..);\n+        let _ = v.range(t..);\n     }\n \n     #[allow(dead_code)]\n     fn range_mut<T: Ord>(v: &mut BTreeMap<Box<T>, ()>, t: T) {\n-        v.range_mut(t..);\n+        let _ = v.range_mut(t..);\n     }\n \n     #[allow(dead_code)]"}, {"sha": "f120ec6848c9857e106d588a43f76d032c853621", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -92,6 +92,7 @@ impl<T: Clone> Clone for BTreeSet<T> {\n /// See its documentation for more.\n ///\n /// [`iter`]: BTreeSet::iter\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>,\n@@ -123,6 +124,7 @@ pub struct IntoIter<T> {\n /// See its documentation for more.\n ///\n /// [`range`]: BTreeSet::range\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n@@ -668,6 +670,7 @@ impl<T> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.first(), Some(&1));\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first(&self) -> Option<&T>\n     where\n@@ -694,6 +697,7 @@ impl<T> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.last(), Some(&2));\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last(&self) -> Option<&T>\n     where"}, {"sha": "01cf62b32eccd5f02cb6ae204c8beb71d548174d", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -613,8 +613,8 @@ fn test_ord_absence() {\n         set.is_empty();\n         set.len();\n         set.clear();\n-        set.iter();\n-        set.into_iter();\n+        let _ = set.iter();\n+        let _ = set.into_iter();\n     }\n \n     fn set_debug<K: Debug>(set: BTreeSet<K>) {"}, {"sha": "4c74113338774a92f1e77b4852d2842cbefc59e8", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -64,6 +64,7 @@ struct Node<T> {\n ///\n /// This `struct` is created by [`LinkedList::iter()`]. See its\n /// documentation for more.\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     head: Option<NonNull<Node<T>>>,\n@@ -99,6 +100,7 @@ impl<T> Clone for Iter<'_, T> {\n ///\n /// This `struct` is created by [`LinkedList::iter_mut()`]. See its\n /// documentation for more.\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     head: Option<NonNull<Node<T>>>,\n@@ -529,6 +531,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n     #[inline]\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn cursor_front(&self) -> Cursor<'_, T> {\n         Cursor { index: 0, current: self.head, list: self }\n@@ -538,6 +541,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n     #[inline]\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T> {\n         CursorMut { index: 0, current: self.head, list: self }\n@@ -547,6 +551,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n     #[inline]\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn cursor_back(&self) -> Cursor<'_, T> {\n         Cursor { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n@@ -556,6 +561,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n     #[inline]\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T> {\n         CursorMut { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n@@ -678,6 +684,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(dl.front(), Some(&1));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         unsafe { self.head.as_ref().map(|node| &node.as_ref().element) }\n@@ -706,6 +713,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(dl.front(), Some(&5));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         unsafe { self.head.as_mut().map(|node| &mut node.as_mut().element) }\n@@ -728,6 +736,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(dl.back(), Some(&1));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         unsafe { self.tail.as_ref().map(|node| &node.as_ref().element) }\n@@ -1178,6 +1187,7 @@ impl<'a, T> Cursor<'a, T> {\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n     /// \"ghost\" non-element.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn index(&self) -> Option<usize> {\n         let _ = self.current?;\n@@ -1232,6 +1242,7 @@ impl<'a, T> Cursor<'a, T> {\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n     /// \"ghost\" non-element.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn current(&self) -> Option<&'a T> {\n         unsafe { self.current.map(|current| &(*current.as_ptr()).element) }\n@@ -1242,6 +1253,7 @@ impl<'a, T> Cursor<'a, T> {\n     /// If the cursor is pointing to the \"ghost\" non-element then this returns\n     /// the first element of the `LinkedList`. If it is pointing to the last\n     /// element of the `LinkedList` then this returns `None`.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn peek_next(&self) -> Option<&'a T> {\n         unsafe {\n@@ -1258,6 +1270,7 @@ impl<'a, T> Cursor<'a, T> {\n     /// If the cursor is pointing to the \"ghost\" non-element then this returns\n     /// the last element of the `LinkedList`. If it is pointing to the first\n     /// element of the `LinkedList` then this returns `None`.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn peek_prev(&self) -> Option<&'a T> {\n         unsafe {\n@@ -1271,13 +1284,15 @@ impl<'a, T> Cursor<'a, T> {\n \n     /// Provides a reference to the front element of the cursor's parent list,\n     /// or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn front(&self) -> Option<&'a T> {\n         self.list.front()\n     }\n \n     /// Provides a reference to the back element of the cursor's parent list,\n     /// or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn back(&self) -> Option<&'a T> {\n         self.list.back()\n@@ -1289,6 +1304,7 @@ impl<'a, T> CursorMut<'a, T> {\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n     /// \"ghost\" non-element.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn index(&self) -> Option<usize> {\n         let _ = self.current?;\n@@ -1343,6 +1359,7 @@ impl<'a, T> CursorMut<'a, T> {\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n     /// \"ghost\" non-element.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn current(&mut self) -> Option<&mut T> {\n         unsafe { self.current.map(|current| &mut (*current.as_ptr()).element) }\n@@ -1631,20 +1648,23 @@ impl<'a, T> CursorMut<'a, T> {\n \n     /// Provides a reference to the front element of the cursor's parent list,\n     /// or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn front(&self) -> Option<&T> {\n         self.list.front()\n     }\n \n     /// Provides a mutable reference to the front element of the cursor's\n     /// parent list, or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list.front_mut()\n     }\n \n     /// Provides a reference to the back element of the cursor's parent list,\n     /// or None if the list is empty.\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn back(&self) -> Option<&T> {\n         self.list.back()\n@@ -1671,6 +1691,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// assert_eq!(contents.next(), Some(0));\n     /// assert_eq!(contents.next(), None);\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list.back_mut()"}, {"sha": "1ea135a2aed82aaa12d71598a977e7737eda0277", "filename": "library/alloc/src/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -65,6 +65,7 @@ pub struct TryReserveError {\n impl TryReserveError {\n     /// Details about the allocation that caused the error\n     #[inline]\n+    #[must_use]\n     #[unstable(\n         feature = \"try_reserve_kind\",\n         reason = \"Uncertain how much info should be exposed\","}, {"sha": "50e789d76b7f3b951bf2f581f8d74e3f7ebdc633", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -572,6 +572,7 @@ use crate::string;\n /// [`format_args!`]: core::format_args\n /// [`format!`]: crate::format\n #[cfg(not(no_global_oom_handling))]\n+#[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();"}, {"sha": "2950ec421da9ed58cebedb38ee7757b5f0898b36", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -2246,6 +2246,7 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n+    #[must_use]\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() { inner.strong() } else { 0 }\n@@ -2254,6 +2255,7 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n     /// If no strong pointers remain, this will return zero.\n+    #[must_use]\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn weak_count(&self) -> usize {\n         self.inner()\n@@ -2324,6 +2326,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n         self.ptr.as_ptr() == other.ptr.as_ptr()"}, {"sha": "3b875477df3b86f2e21509d64755e6662033b5e9", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -243,6 +243,7 @@ impl str {\n     /// assert_eq!(*boxed_bytes, *s.as_bytes());\n     /// ```\n     #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n         self.into()\n@@ -484,6 +485,7 @@ impl str {\n     /// assert_eq!(boxed_str.into_string(), string);\n     /// ```\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub fn into_string(self: Box<str>) -> String {\n         let slice = Box::<[u8]>::from(self);\n@@ -508,9 +510,10 @@ impl str {\n     ///\n     /// ```should_panic\n     /// // this will panic at runtime\n-    /// \"0123456789abcdef\".repeat(usize::MAX);\n+    /// let huge = \"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[must_use]\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n         unsafe { String::from_utf8_unchecked(self.as_bytes().repeat(n)) }"}, {"sha": "d2471f164fc4a80eb684f955b7e2f228b7d46f58", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -898,6 +898,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n         self.vec.capacity()\n@@ -1823,6 +1824,7 @@ impl FromUtf8Error {\n     /// // the first byte is invalid here\n     /// assert_eq!(1, error.valid_up_to());\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn utf8_error(&self) -> Utf8Error {\n         self.error"}, {"sha": "039971a17654883ec0bee66bcf6773d4cf5e30d8", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -953,6 +953,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(1, Arc::weak_count(&five));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n     pub fn weak_count(this: &Self) -> usize {\n         let cnt = this.inner().weak.load(SeqCst);\n@@ -982,6 +983,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(2, Arc::strong_count(&five));\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n     pub fn strong_count(this: &Self) -> usize {\n         this.inner().strong.load(SeqCst)\n@@ -1079,8 +1081,6 @@ impl<T: ?Sized> Arc<T> {\n         drop(Weak { ptr: self.ptr });\n     }\n \n-    #[inline]\n-    #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     /// Returns `true` if the two `Arc`s point to the same allocation\n     /// (in a vein similar to [`ptr::eq`]).\n     ///\n@@ -1098,6 +1098,9 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     ///\n     /// [`ptr::eq`]: core::ptr::eq \"ptr::eq\"\n+    #[inline]\n+    #[must_use]\n+    #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -1904,6 +1907,7 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n+    #[must_use]\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() { inner.strong.load(SeqCst) } else { 0 }\n@@ -1920,6 +1924,7 @@ impl<T: ?Sized> Weak<T> {\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n     /// `Weak`s pointing to the same allocation.\n+    #[must_use]\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn weak_count(&self) -> usize {\n         self.inner()\n@@ -1999,6 +2004,7 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// [`ptr::eq`]: core::ptr::eq \"ptr::eq\"\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n         self.ptr.as_ptr() == other.ptr.as_ptr()"}, {"sha": "ff98091a0d2abf18924b663e78634c827fce6e38", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1adb6643928dd3bacdd079f87f7f4cdacf510823/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=1adb6643928dd3bacdd079f87f7f4cdacf510823", "patch": "@@ -60,6 +60,7 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n \n     /// Returns a reference to the underlying allocator.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[must_use]\n     #[inline]\n     pub fn allocator(&self) -> &A {\n         unsafe { self.vec.as_ref().allocator() }"}]}