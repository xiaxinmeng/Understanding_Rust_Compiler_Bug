{"sha": "5f9a5825e0755fe3072679bb6ca59bf3672be343", "node_id": "C_kwDOAAsO6NoAKDVmOWE1ODI1ZTA3NTVmZTMwNzI2NzliYjZjYTU5YmYzNjcyYmUzNDM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-21T07:23:30Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-21T07:23:30Z"}, "message": "Use ItemTree for crate root attr_query collection", "tree": {"sha": "903a83972cfb17d97e02c623267510a1e79f066d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/903a83972cfb17d97e02c623267510a1e79f066d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f9a5825e0755fe3072679bb6ca59bf3672be343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f9a5825e0755fe3072679bb6ca59bf3672be343", "html_url": "https://github.com/rust-lang/rust/commit/5f9a5825e0755fe3072679bb6ca59bf3672be343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f9a5825e0755fe3072679bb6ca59bf3672be343/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aadd9da92624f758ceff02571d6d87420980b13", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aadd9da92624f758ceff02571d6d87420980b13", "html_url": "https://github.com/rust-lang/rust/commit/1aadd9da92624f758ceff02571d6d87420980b13"}], "stats": {"total": 57, "additions": 37, "deletions": 20}, "files": [{"sha": "8222cc97f0ead385c57f4d5b80d40c6e56df524b", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5f9a5825e0755fe3072679bb6ca59bf3672be343/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f9a5825e0755fe3072679bb6ca59bf3672be343/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=5f9a5825e0755fe3072679bb6ca59bf3672be343", "patch": "@@ -19,8 +19,8 @@ use tt::Subtree;\n use crate::{\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{Fields, ItemTreeId, ItemTreeNode},\n-    nameres::ModuleSource,\n+    item_tree::{AttrOwner, Fields, ItemTreeId, ItemTreeNode},\n+    nameres::{ModuleOrigin, ModuleSource},\n     path::{ModPath, PathKind},\n     src::{HasChildSource, HasSource},\n     AdtId, AttrDefId, EnumId, GenericParamId, LocalEnumVariantId, LocalFieldId, Lookup, MacroId,\n@@ -201,6 +201,7 @@ impl Attrs {\n         db: &dyn DefDatabase,\n         e: EnumId,\n     ) -> Arc<ArenaMap<LocalEnumVariantId, Attrs>> {\n+        // FIXME: There should be some proper form of mapping between item tree enum variant ids and hir enum variant ids\n         let mut res = ArenaMap::default();\n \n         let loc = e.lookup(db);\n@@ -226,6 +227,7 @@ impl Attrs {\n         db: &dyn DefDatabase,\n         v: VariantId,\n     ) -> Arc<ArenaMap<LocalFieldId, Attrs>> {\n+        // FIXME: There should be some proper form of mapping between item tree field ids and hir field ids\n         let mut res = ArenaMap::default();\n \n         let crate_graph = db.crate_graph();\n@@ -295,11 +297,14 @@ impl Attrs {\n \n impl Attrs {\n     pub fn cfg(&self) -> Option<CfgExpr> {\n-        let mut cfgs = self.by_key(\"cfg\").tt_values().map(CfgExpr::parse).collect::<Vec<_>>();\n-        match cfgs.len() {\n-            0 => None,\n-            1 => Some(cfgs.pop().unwrap()),\n-            _ => Some(CfgExpr::All(cfgs)),\n+        let mut cfgs = self.by_key(\"cfg\").tt_values().map(CfgExpr::parse);\n+        let first = cfgs.next()?;\n+        match cfgs.next() {\n+            Some(second) => {\n+                let cfgs = [first, second].into_iter().chain(cfgs);\n+                Some(CfgExpr::All(cfgs.collect()))\n+            }\n+            None => Some(first),\n         }\n     }\n     pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n@@ -367,25 +372,37 @@ impl AttrsWithOwner {\n             AttrDefId::ModuleId(module) => {\n                 let def_map = module.def_map(db);\n                 let mod_data = &def_map[module.local_id];\n-                match mod_data.declaration_source(db) {\n-                    Some(it) => {\n+\n+                match mod_data.origin {\n+                    // FIXME: We should be able to leverage the item tree instead of parsing declaration here\n+                    // but we don't save the module's item tree id anywhere\n+                    ModuleOrigin::File { definition, declaration, .. } => {\n+                        let value = declaration.to_node(db.upcast());\n+                        let it = InFile { file_id: declaration.file_id, value };\n                         let raw_attrs = RawAttrs::from_attrs_owner(\n                             db,\n                             it.as_ref().map(|it| it as &dyn ast::HasAttrs),\n                         );\n-                        match mod_data.definition_source(db) {\n-                            InFile { file_id, value: ModuleSource::SourceFile(file) } => raw_attrs\n-                                .merge(RawAttrs::from_attrs_owner(db, InFile::new(file_id, &file))),\n-                            _ => raw_attrs,\n-                        }\n+                        let tree = db.file_item_tree(definition.into());\n+                        raw_attrs.merge(tree.raw_attrs(AttrOwner::TopLevel).clone())\n+                    }\n+                    ModuleOrigin::CrateRoot { definition } => {\n+                        let tree = db.file_item_tree(definition.into());\n+                        tree.raw_attrs(AttrOwner::TopLevel).clone()\n                     }\n-                    None => RawAttrs::from_attrs_owner(\n+                    // FIXME: We should be able to leverage the item tree instead of parsing here\n+                    // but we don't save the module's item tree id anywhere\n+                    ModuleOrigin::Inline { definition } => RawAttrs::from_attrs_owner(\n                         db,\n-                        mod_data.definition_source(db).as_ref().map(|src| match src {\n-                            ModuleSource::SourceFile(file) => file as &dyn ast::HasAttrs,\n-                            ModuleSource::Module(module) => module as &dyn ast::HasAttrs,\n-                            ModuleSource::BlockExpr(block) => block as &dyn ast::HasAttrs,\n-                        }),\n+                        InFile::new(definition.file_id, definition.to_node(db.upcast()))\n+                            .as_ref()\n+                            .map(|it| it as &dyn ast::HasAttrs),\n+                    ),\n+                    ModuleOrigin::BlockExpr { block } => RawAttrs::from_attrs_owner(\n+                        db,\n+                        InFile::new(block.file_id, block.to_node(db.upcast()))\n+                            .as_ref()\n+                            .map(|it| it as &dyn ast::HasAttrs),\n                     ),\n                 }\n             }"}]}