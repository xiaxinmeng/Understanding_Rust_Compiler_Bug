{"sha": "c1cad03c4e2a9041708d3d136b89ad0c848fe497", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxY2FkMDNjNGUyYTkwNDE3MDhkM2QxMzZiODlhZDBjODQ4ZmU0OTc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-11-01T13:44:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-01T13:44:25Z"}, "message": "Merge pull request #1100 from mominul/trans->codegen\n\nRename trans to codegen", "tree": {"sha": "4d920ce049fafaa2353124387f3bec096b85c05b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d920ce049fafaa2353124387f3bec096b85c05b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1cad03c4e2a9041708d3d136b89ad0c848fe497", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfnru5CRBK7hj4Ov3rIwAAdHIIAIRxpTliiH/5A/OtpTtCesxs\ngrI2PktMFDgit/ByMwGdiim7/CMjQLJHsR0eFS8YXs4xBnseDHKqLaWTaor0GB4+\ndNwC4aYgx3Ju3WFnxIbgXj8JU68+1lyZQjvmPE5Mlnmv26TnoNST5D7yDVdLtZqk\neAqX9w7pHNIpOhvmjfOrazCkhGV3Y48j8l5021CZ1/BxyI+cu+wevbVlH6l65fr+\ndsOVFs/1iBxsVGLzVs8juFPQgb1K7wIV643lFW+pTDBuRaXo1LswUol2vSQFHCxl\nmnILCvSJnfZddNcAP7lfaK4vczIpzWHWNQn8u1xn+jJKF8/8B2IvK8cHuIcRWn8=\n=fq6w\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d920ce049fafaa2353124387f3bec096b85c05b\nparent 8063c37b7e84dc69ab2c7ca6fe2a6f05c483c387\nparent d27f2f093258c145f2db6ee6c3ee636a767e6e01\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1604238265 +0100\ncommitter GitHub <noreply@github.com> 1604238265 +0100\n\nMerge pull request #1100 from mominul/trans->codegen\n\nRename trans to codegen"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cad03c4e2a9041708d3d136b89ad0c848fe497", "html_url": "https://github.com/rust-lang/rust/commit/c1cad03c4e2a9041708d3d136b89ad0c848fe497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1cad03c4e2a9041708d3d136b89ad0c848fe497/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8063c37b7e84dc69ab2c7ca6fe2a6f05c483c387", "url": "https://api.github.com/repos/rust-lang/rust/commits/8063c37b7e84dc69ab2c7ca6fe2a6f05c483c387", "html_url": "https://github.com/rust-lang/rust/commit/8063c37b7e84dc69ab2c7ca6fe2a6f05c483c387"}, {"sha": "d27f2f093258c145f2db6ee6c3ee636a767e6e01", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27f2f093258c145f2db6ee6c3ee636a767e6e01", "html_url": "https://github.com/rust-lang/rust/commit/d27f2f093258c145f2db6ee6c3ee636a767e6e01"}], "stats": {"total": 154, "additions": 77, "deletions": 77}, "files": [{"sha": "81091728692f3f4d21017fb04a977bcb7066e1ca", "filename": "src/abi/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -497,7 +497,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         .tcx\n         .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n-    let destination = destination.map(|(place, bb)| (trans_place(fx, place), bb));\n+    let destination = destination.map(|(place, bb)| (codegen_place(fx, place), bb));\n \n     // Handle special calls like instrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n@@ -550,8 +550,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     // Unpack arguments tuple for closures\n     let args = if fn_sig.abi == Abi::RustCall {\n         assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n-        let self_arg = trans_operand(fx, &args[0]);\n-        let pack_arg = trans_operand(fx, &args[1]);\n+        let self_arg = codegen_operand(fx, &args[0]);\n+        let pack_arg = codegen_operand(fx, &args[1]);\n \n         let tupled_arguments = match pack_arg.layout().ty.kind() {\n             ty::Tuple(ref tupled_arguments) => tupled_arguments,\n@@ -566,7 +566,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         args\n     } else {\n         args.iter()\n-            .map(|arg| trans_operand(fx, arg))\n+            .map(|arg| codegen_operand(fx, arg))\n             .collect::<Vec<_>>()\n     };\n \n@@ -610,7 +610,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }\n-            let func = trans_operand(fx, func).load_scalar(fx);\n+            let func = codegen_operand(fx, func).load_scalar(fx);\n             (\n                 Some(func),\n                 args.get(0)"}, {"sha": "5474e5960f100a03f9626a8ff3e504db380adf41", "filename": "src/base.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -5,7 +5,7 @@ use rustc_middle::ty::adjustment::PointerCast;\n \n use crate::prelude::*;\n \n-pub(crate) fn trans_fn<'tcx>(\n+pub(crate) fn codegen_fn<'tcx>(\n     cx: &mut crate::CodegenCx<'tcx, impl Module>,\n     instance: Instance<'tcx>,\n     linkage: Linkage,\n@@ -202,7 +202,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n         fx.bcx.ins().nop();\n         for stmt in &bb_data.statements {\n             fx.set_debug_loc(stmt.source_info);\n-            trans_stmt(fx, block, stmt);\n+            codegen_stmt(fx, block, stmt);\n         }\n \n         #[cfg(debug_assertions)]\n@@ -258,7 +258,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                         continue;\n                     }\n                 }\n-                let cond = trans_operand(fx, cond).load_scalar(fx);\n+                let cond = codegen_operand(fx, cond).load_scalar(fx);\n \n                 let target = fx.get_block(*target);\n                 let failure = fx.bcx.create_block();\n@@ -276,8 +276,8 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n \n                 match msg {\n                     AssertKind::BoundsCheck { ref len, ref index } => {\n-                        let len = trans_operand(fx, len).load_scalar(fx);\n-                        let index = trans_operand(fx, index).load_scalar(fx);\n+                        let len = codegen_operand(fx, len).load_scalar(fx);\n+                        let index = codegen_operand(fx, index).load_scalar(fx);\n                         let location = fx\n                             .get_caller_location(bb_data.terminator().source_info.span)\n                             .load_scalar(fx);\n@@ -301,7 +301,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                 switch_ty,\n                 targets,\n             } => {\n-                let discr = trans_operand(fx, discr).load_scalar(fx);\n+                let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n                 if switch_ty.kind() == fx.tcx.types.bool.kind() {\n                     assert_eq!(targets.iter().count(), 1);\n@@ -396,14 +396,14 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::GeneratorDrop => {\n-                bug!(\"shouldn't exist at trans {:?}\", bb_data.terminator());\n+                bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n             TerminatorKind::Drop {\n                 place,\n                 target,\n                 unwind: _,\n             } => {\n-                let drop_place = trans_place(fx, *place);\n+                let drop_place = codegen_place(fx, *place);\n                 crate::abi::codegen_drop(fx, bb_data.terminator().source_info.span, drop_place);\n \n                 let target_block = fx.get_block(*target);\n@@ -416,7 +416,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n     fx.bcx.finalize();\n }\n \n-fn trans_stmt<'tcx>(\n+fn codegen_stmt<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     #[allow(unused_variables)] cur_block: Block,\n     stmt: &Statement<'tcx>,\n@@ -439,19 +439,19 @@ fn trans_stmt<'tcx>(\n             place,\n             variant_index,\n         } => {\n-            let place = trans_place(fx, **place);\n+            let place = codegen_place(fx, **place);\n             crate::discriminant::codegen_set_discriminant(fx, place, *variant_index);\n         }\n         StatementKind::Assign(to_place_and_rval) => {\n-            let lval = trans_place(fx, to_place_and_rval.0);\n+            let lval = codegen_place(fx, to_place_and_rval.0);\n             let dest_layout = lval.layout();\n             match &to_place_and_rval.1 {\n                 Rvalue::Use(operand) => {\n-                    let val = trans_operand(fx, operand);\n+                    let val = codegen_operand(fx, operand);\n                     lval.write_cvalue(fx, val);\n                 }\n                 Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n-                    let place = trans_place(fx, *place);\n+                    let place = codegen_place(fx, *place);\n                     let ref_ = place.place_ref(fx, lval.layout());\n                     lval.write_cvalue(fx, ref_);\n                 }\n@@ -460,29 +460,29 @@ fn trans_stmt<'tcx>(\n                     lval.write_cvalue(fx, val);\n                 }\n                 Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n-                    let lhs = trans_operand(fx, lhs);\n-                    let rhs = trans_operand(fx, rhs);\n+                    let lhs = codegen_operand(fx, lhs);\n+                    let rhs = codegen_operand(fx, rhs);\n \n                     let res = crate::num::codegen_binop(fx, *bin_op, lhs, rhs);\n                     lval.write_cvalue(fx, res);\n                 }\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n-                    let lhs = trans_operand(fx, lhs);\n-                    let rhs = trans_operand(fx, rhs);\n+                    let lhs = codegen_operand(fx, lhs);\n+                    let rhs = codegen_operand(fx, rhs);\n \n                     let res = if !fx.tcx.sess.overflow_checks() {\n                         let val =\n-                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs).load_scalar(fx);\n+                            crate::num::codegen_int_binop(fx, *bin_op, lhs, rhs).load_scalar(fx);\n                         let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n                         CValue::by_val_pair(val, is_overflow, lval.layout())\n                     } else {\n-                        crate::num::trans_checked_int_binop(fx, *bin_op, lhs, rhs)\n+                        crate::num::codegen_checked_int_binop(fx, *bin_op, lhs, rhs)\n                     };\n \n                     lval.write_cvalue(fx, res);\n                 }\n                 Rvalue::UnaryOp(un_op, operand) => {\n-                    let operand = trans_operand(fx, operand);\n+                    let operand = codegen_operand(fx, operand);\n                     let layout = operand.layout();\n                     let val = operand.load_scalar(fx);\n                     let res = match un_op {\n@@ -500,7 +500,7 @@ fn trans_stmt<'tcx>(\n                             ty::Int(IntTy::I128) => {\n                                 // FIXME remove this case once ineg.i128 works\n                                 let zero = CValue::const_val(fx, layout, 0);\n-                                crate::num::trans_int_binop(fx, BinOp::Sub, zero, operand)\n+                                crate::num::codegen_int_binop(fx, BinOp::Sub, zero, operand)\n                             }\n                             ty::Int(_) => CValue::by_val(fx.bcx.ins().ineg(val), layout),\n                             ty::Float(_) => CValue::by_val(fx.bcx.ins().fneg(val), layout),\n@@ -534,11 +534,11 @@ fn trans_stmt<'tcx>(\n                 | Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer), operand, to_ty)\n                 | Rvalue::Cast(CastKind::Pointer(PointerCast::ArrayToPointer), operand, to_ty) => {\n                     let to_layout = fx.layout_of(fx.monomorphize(to_ty));\n-                    let operand = trans_operand(fx, operand);\n+                    let operand = codegen_operand(fx, operand);\n                     lval.write_cvalue(fx, operand.cast_pointer_to(to_layout));\n                 }\n                 Rvalue::Cast(CastKind::Misc, operand, to_ty) => {\n-                    let operand = trans_operand(fx, operand);\n+                    let operand = codegen_operand(fx, operand);\n                     let from_ty = operand.layout().ty;\n                     let to_ty = fx.monomorphize(to_ty);\n \n@@ -639,7 +639,7 @@ fn trans_stmt<'tcx>(\n                     operand,\n                     _to_ty,\n                 ) => {\n-                    let operand = trans_operand(fx, operand);\n+                    let operand = codegen_operand(fx, operand);\n                     match *operand.layout().ty.kind() {\n                         ty::Closure(def_id, substs) => {\n                             let instance = Instance::resolve_closure(\n@@ -657,18 +657,18 @@ fn trans_stmt<'tcx>(\n                     }\n                 }\n                 Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), operand, _to_ty) => {\n-                    let operand = trans_operand(fx, operand);\n+                    let operand = codegen_operand(fx, operand);\n                     operand.unsize_value(fx, lval);\n                 }\n                 Rvalue::Discriminant(place) => {\n-                    let place = trans_place(fx, *place);\n+                    let place = codegen_place(fx, *place);\n                     let value = place.to_cvalue(fx);\n                     let discr =\n                         crate::discriminant::codegen_get_discriminant(fx, value, dest_layout);\n                     lval.write_cvalue(fx, discr);\n                 }\n                 Rvalue::Repeat(operand, times) => {\n-                    let operand = trans_operand(fx, operand);\n+                    let operand = codegen_operand(fx, operand);\n                     let times = fx\n                         .monomorphize(times)\n                         .eval(fx.tcx, ParamEnv::reveal_all())\n@@ -706,7 +706,7 @@ fn trans_stmt<'tcx>(\n                     }\n                 }\n                 Rvalue::Len(place) => {\n-                    let place = trans_place(fx, *place);\n+                    let place = codegen_place(fx, *place);\n                     let usize_layout = fx.layout_of(fx.tcx.types.usize);\n                     let len = codegen_array_len(fx, place);\n                     lval.write_cvalue(fx, CValue::by_val(len, usize_layout));\n@@ -754,13 +754,13 @@ fn trans_stmt<'tcx>(\n                 Rvalue::Aggregate(kind, operands) => match **kind {\n                     AggregateKind::Array(_ty) => {\n                         for (i, operand) in operands.iter().enumerate() {\n-                            let operand = trans_operand(fx, operand);\n+                            let operand = codegen_operand(fx, operand);\n                             let index = fx.bcx.ins().iconst(fx.pointer_type, i as i64);\n                             let to = lval.place_index(fx, index);\n                             to.write_cvalue(fx, operand);\n                         }\n                     }\n-                    _ => unreachable!(\"shouldn't exist at trans {:?}\", to_place_and_rval.1),\n+                    _ => unreachable!(\"shouldn't exist at codegen {:?}\", to_place_and_rval.1),\n                 },\n             }\n         }\n@@ -813,20 +813,20 @@ fn trans_stmt<'tcx>(\n                     assert!(!alignstack);\n \n                     assert_eq!(inputs.len(), 2);\n-                    let leaf = trans_operand(fx, &inputs[0].1).load_scalar(fx); // %eax\n-                    let subleaf = trans_operand(fx, &inputs[1].1).load_scalar(fx); // %ecx\n+                    let leaf = codegen_operand(fx, &inputs[0].1).load_scalar(fx); // %eax\n+                    let subleaf = codegen_operand(fx, &inputs[1].1).load_scalar(fx); // %ecx\n \n                     let (eax, ebx, ecx, edx) =\n                         crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n \n                     assert_eq!(outputs.len(), 4);\n-                    trans_place(fx, outputs[0])\n+                    codegen_place(fx, outputs[0])\n                         .write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-                    trans_place(fx, outputs[1])\n+                    codegen_place(fx, outputs[1])\n                         .write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-                    trans_place(fx, outputs[2])\n+                    codegen_place(fx, outputs[2])\n                         .write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-                    trans_place(fx, outputs[3])\n+                    codegen_place(fx, outputs[3])\n                         .write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n                 }\n                 \"xgetbv\" => {\n@@ -892,7 +892,7 @@ fn codegen_array_len<'tcx>(\n     }\n }\n \n-pub(crate) fn trans_place<'tcx>(\n+pub(crate) fn codegen_place<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     place: Place<'tcx>,\n ) -> CPlace<'tcx> {\n@@ -964,16 +964,16 @@ pub(crate) fn trans_place<'tcx>(\n     cplace\n }\n \n-pub(crate) fn trans_operand<'tcx>(\n+pub(crate) fn codegen_operand<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     operand: &Operand<'tcx>,\n ) -> CValue<'tcx> {\n     match operand {\n         Operand::Move(place) | Operand::Copy(place) => {\n-            let cplace = trans_place(fx, *place);\n+            let cplace = codegen_place(fx, *place);\n             cplace.to_cvalue(fx)\n         }\n-        Operand::Constant(const_) => crate::constant::trans_constant(fx, const_),\n+        Operand::Constant(const_) => crate::constant::codegen_constant(fx, const_),\n     }\n }\n "}, {"sha": "eda77bf19d3547f4b3e18b5b03d81d478ab6b412", "filename": "src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -406,7 +406,7 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n             caller.line as u32,\n             caller.col_display as u32 + 1,\n         ));\n-        crate::constant::trans_const_value(self, const_loc, self.tcx.caller_location_ty())\n+        crate::constant::codegen_const_value(self, const_loc, self.tcx.caller_location_ty())\n     }\n \n     pub(crate) fn triple(&self) -> &target_lexicon::Triple {"}, {"sha": "dbe2bb73a4f7398adba947f6acc672be2ae9253e", "filename": "src/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -106,7 +106,7 @@ fn codegen_static_ref<'tcx>(\n     CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n }\n \n-pub(crate) fn trans_constant<'tcx>(\n+pub(crate) fn codegen_constant<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n@@ -151,10 +151,10 @@ pub(crate) fn trans_constant<'tcx>(\n         | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n     };\n \n-    trans_const_value(fx, const_val, const_.ty)\n+    codegen_const_value(fx, const_val, const_.ty)\n }\n \n-pub(crate) fn trans_const_value<'tcx>(\n+pub(crate) fn codegen_const_value<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     const_val: ConstValue<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "a11dc57ee64536ce9893d0033e77932bff09e133", "filename": "src/driver/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -64,11 +64,11 @@ fn codegen_mono_items<'tcx>(\n \n     for (mono_item, (linkage, visibility)) in mono_items {\n         let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-        trans_mono_item(cx, mono_item, linkage);\n+        codegen_mono_item(cx, mono_item, linkage);\n     }\n }\n \n-fn trans_mono_item<'tcx, M: Module>(\n+fn codegen_mono_item<'tcx, M: Module>(\n     cx: &mut crate::CodegenCx<'tcx, M>,\n     mono_item: MonoItem<'tcx>,\n     linkage: Linkage,\n@@ -80,7 +80,7 @@ fn trans_mono_item<'tcx, M: Module>(\n                 crate::PrintOnPanic(|| format!(\"{:?} {}\", inst, tcx.symbol_name(inst).name));\n             debug_assert!(!inst.substs.needs_infer());\n             tcx.sess\n-                .time(\"codegen fn\", || crate::base::trans_fn(cx, inst, linkage));\n+                .time(\"codegen fn\", || crate::base::codegen_fn(cx, inst, linkage));\n         }\n         MonoItem::Static(def_id) => {\n             crate::constant::codegen_static(&mut cx.constants_cx, def_id);"}, {"sha": "04aac780125d93a354eff2a1f5ef18a69e5fda16", "filename": "src/inline_asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -50,7 +50,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                 inputs.push((\n                     reg,\n                     new_slot(reg.reg_class()),\n-                    crate::base::trans_operand(fx, value).load_scalar(fx),\n+                    crate::base::codegen_operand(fx, value).load_scalar(fx),\n                 ));\n             }\n             InlineAsmOperand::Out {\n@@ -64,7 +64,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     outputs.push((\n                         reg,\n                         new_slot(reg.reg_class()),\n-                        crate::base::trans_place(fx, place),\n+                        crate::base::codegen_place(fx, place),\n                     ));\n                 }\n             }\n@@ -79,13 +79,13 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                 inputs.push((\n                     reg,\n                     new_slot(reg.reg_class()),\n-                    crate::base::trans_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n                 ));\n                 if let Some(out_place) = out_place {\n                     outputs.push((\n                         reg,\n                         new_slot(reg.reg_class()),\n-                        crate::base::trans_place(fx, out_place),\n+                        crate::base::codegen_place(fx, out_place),\n                     ));\n                 }\n             }"}, {"sha": "a5f45b7abf4c802118edab6131b5a16303163ed6", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -31,10 +31,10 @@ macro intrinsic_arg {\n         $arg\n     },\n     (c $fx:expr, $arg:ident) => {\n-        trans_operand($fx, $arg)\n+        codegen_operand($fx, $arg)\n     },\n     (v $fx:expr, $arg:ident) => {\n-        trans_operand($fx, $arg).load_scalar($fx)\n+        codegen_operand($fx, $arg).load_scalar($fx)\n     }\n }\n \n@@ -90,7 +90,7 @@ macro call_intrinsic_match {\n                     assert!($substs.is_noop());\n                     if let [$(ref $arg),*] = *$args {\n                         let ($($arg,)*) = (\n-                            $(trans_operand($fx, $arg),)*\n+                            $(codegen_operand($fx, $arg),)*\n                         );\n                         let res = $fx.easy_call(stringify!($func), &[$($arg),*], $fx.tcx.types.$ty);\n                         $ret.write_cvalue($fx, res);\n@@ -577,7 +577,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 \"unchecked_shr\" => BinOp::Shr,\n                 _ => unreachable!(\"intrinsic {}\", intrinsic),\n             };\n-            let res = crate::num::trans_int_binop(fx, bin_op, x, y);\n+            let res = crate::num::codegen_int_binop(fx, bin_op, x, y);\n             ret.write_cvalue(fx, res);\n         };\n         _ if intrinsic.ends_with(\"_with_overflow\"), (c x, c y) {\n@@ -589,7 +589,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 _ => unreachable!(\"intrinsic {}\", intrinsic),\n             };\n \n-            let res = crate::num::trans_checked_int_binop(\n+            let res = crate::num::codegen_checked_int_binop(\n                 fx,\n                 bin_op,\n                 x,\n@@ -605,7 +605,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 \"wrapping_mul\" => BinOp::Mul,\n                 _ => unreachable!(\"intrinsic {}\", intrinsic),\n             };\n-            let res = crate::num::trans_int_binop(\n+            let res = crate::num::codegen_int_binop(\n                 fx,\n                 bin_op,\n                 x,\n@@ -623,7 +623,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n             let signed = type_sign(T);\n \n-            let checked_res = crate::num::trans_checked_int_binop(\n+            let checked_res = crate::num::codegen_checked_int_binop(\n                 fx,\n                 bin_op,\n                 lhs,\n@@ -867,7 +867,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         size_of | pref_align_of | min_align_of | needs_drop | type_id | type_name | variant_count, () {\n             let const_val =\n                 fx.tcx.const_eval_instance(ParamEnv::reveal_all(), instance, None).unwrap();\n-            let val = crate::constant::trans_const_value(\n+            let val = crate::constant::codegen_const_value(\n                 fx,\n                 const_val,\n                 ret.layout().ty,\n@@ -886,12 +886,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         ptr_guaranteed_eq, (c a, c b) {\n-            let val = crate::num::trans_ptr_binop(fx, BinOp::Eq, a, b);\n+            let val = crate::num::codegen_ptr_binop(fx, BinOp::Eq, a, b);\n             ret.write_cvalue(fx, val);\n         };\n \n         ptr_guaranteed_ne, (c a, c b) {\n-            let val = crate::num::trans_ptr_binop(fx, BinOp::Ne, a, b);\n+            let val = crate::num::codegen_ptr_binop(fx, BinOp::Ne, a, b);\n             ret.write_cvalue(fx, val);\n         };\n \n@@ -1069,7 +1069,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         fadd_fast | fsub_fast | fmul_fast | fdiv_fast | frem_fast, (c x, c y) {\n-            let res = crate::num::trans_float_binop(fx, match intrinsic {\n+            let res = crate::num::codegen_float_binop(fx, match intrinsic {\n                 \"fadd_fast\" => BinOp::Add,\n                 \"fsub_fast\" => BinOp::Sub,\n                 \"fmul_fast\" => BinOp::Mul,"}, {"sha": "ba9ee0d450ee66c68821acab3f094304f92c0ba3", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -111,7 +111,7 @@ mod prelude {\n     pub(crate) use cranelift_module::{self, DataContext, DataId, FuncId, Linkage, Module};\n \n     pub(crate) use crate::abi::*;\n-    pub(crate) use crate::base::{trans_operand, trans_place};\n+    pub(crate) use crate::base::{codegen_operand, codegen_place};\n     pub(crate) use crate::cast::*;\n     pub(crate) use crate::common::*;\n     pub(crate) use crate::debuginfo::{DebugContext, UnwindContext};"}, {"sha": "41f4a9b9662bcfc8ce9d9f722dd9e8df96ebb829", "filename": "src/num.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cad03c4e2a9041708d3d136b89ad0c848fe497/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=c1cad03c4e2a9041708d3d136b89ad0c848fe497", "patch": "@@ -89,10 +89,10 @@ pub(crate) fn codegen_binop<'tcx>(\n     }\n \n     match in_lhs.layout().ty.kind() {\n-        ty::Bool => crate::num::trans_bool_binop(fx, bin_op, in_lhs, in_rhs),\n-        ty::Uint(_) | ty::Int(_) => crate::num::trans_int_binop(fx, bin_op, in_lhs, in_rhs),\n-        ty::Float(_) => crate::num::trans_float_binop(fx, bin_op, in_lhs, in_rhs),\n-        ty::RawPtr(..) | ty::FnPtr(..) => crate::num::trans_ptr_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::Bool => crate::num::codegen_bool_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::Uint(_) | ty::Int(_) => crate::num::codegen_int_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::Float(_) => crate::num::codegen_float_binop(fx, bin_op, in_lhs, in_rhs),\n+        ty::RawPtr(..) | ty::FnPtr(..) => crate::num::codegen_ptr_binop(fx, bin_op, in_lhs, in_rhs),\n         _ => unreachable!(\n             \"{:?}({:?}, {:?})\",\n             bin_op,\n@@ -102,7 +102,7 @@ pub(crate) fn codegen_binop<'tcx>(\n     }\n }\n \n-pub(crate) fn trans_bool_binop<'tcx>(\n+pub(crate) fn codegen_bool_binop<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n@@ -123,7 +123,7 @@ pub(crate) fn trans_bool_binop<'tcx>(\n     CValue::by_val(res, fx.layout_of(fx.tcx.types.bool))\n }\n \n-pub(crate) fn trans_int_binop<'tcx>(\n+pub(crate) fn codegen_int_binop<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n@@ -196,7 +196,7 @@ pub(crate) fn trans_int_binop<'tcx>(\n     CValue::by_val(val, in_lhs.layout())\n }\n \n-pub(crate) fn trans_checked_int_binop<'tcx>(\n+pub(crate) fn codegen_checked_int_binop<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n@@ -357,7 +357,7 @@ pub(crate) fn trans_checked_int_binop<'tcx>(\n     out_place.to_cvalue(fx)\n }\n \n-pub(crate) fn trans_float_binop<'tcx>(\n+pub(crate) fn codegen_float_binop<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n@@ -402,7 +402,7 @@ pub(crate) fn trans_float_binop<'tcx>(\n     CValue::by_val(res, in_lhs.layout())\n }\n \n-pub(crate) fn trans_ptr_binop<'tcx>(\n+pub(crate) fn codegen_ptr_binop<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,"}]}