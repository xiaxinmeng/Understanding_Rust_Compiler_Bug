{"sha": "317da0bf2a868e0b946b78268d7b2414b865c2a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxN2RhMGJmMmE4NjhlMGI5NDZiNzgyNjhkN2IyNDE0Yjg2NWMyYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T06:31:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T06:31:02Z"}, "message": "Merge pull request #21181 from nick29581/save-fix\n\nTwo minor fixes for save-analysis\n\nReviewed-by: huonw", "tree": {"sha": "1807914b71867e15c7e10afc0885077630bb0427", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1807914b71867e15c7e10afc0885077630bb0427"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/317da0bf2a868e0b946b78268d7b2414b865c2a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/317da0bf2a868e0b946b78268d7b2414b865c2a9", "html_url": "https://github.com/rust-lang/rust/commit/317da0bf2a868e0b946b78268d7b2414b865c2a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/317da0bf2a868e0b946b78268d7b2414b865c2a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b565501ad8b4e371e0aca0069c3f4781bd209254", "url": "https://api.github.com/repos/rust-lang/rust/commits/b565501ad8b4e371e0aca0069c3f4781bd209254", "html_url": "https://github.com/rust-lang/rust/commit/b565501ad8b4e371e0aca0069c3f4781bd209254"}, {"sha": "33fd10d5e0bac969b522b0a9b1bcc1518d1554b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/33fd10d5e0bac969b522b0a9b1bcc1518d1554b2", "html_url": "https://github.com/rust-lang/rust/commit/33fd10d5e0bac969b522b0a9b1bcc1518d1554b2"}], "stats": {"total": 55, "additions": 36, "deletions": 19}, "files": [{"sha": "b12903c814cbf83db5e50deac0fda6bc6e189175", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/317da0bf2a868e0b946b78268d7b2414b865c2a9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/317da0bf2a868e0b946b78268d7b2414b865c2a9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=317da0bf2a868e0b946b78268d7b2414b865c2a9", "patch": "@@ -278,7 +278,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in followed by the method's name.\n         let mut qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                ast_util::local_def(method.id)) {\n+                                                    ast_util::local_def(method.id)) {\n             Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n@@ -349,7 +349,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             .and_then(|def_id| {\n                 if match def_id {\n                     ty::MethodTraitItemId(def_id) => {\n-                        method.id != 0 && def_id.node == 0\n+                        def_id.node != 0 && def_id != ast_util::local_def(method.id)\n                     }\n                     ty::TypeTraitItemId(_) => false,\n                 } {\n@@ -392,8 +392,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_trait_ref(&mut self,\n-                         trait_ref: &ast::TraitRef,\n-                         impl_id: Option<NodeId>) {\n+                         trait_ref: &ast::TraitRef) {\n         match self.lookup_type_ref(trait_ref.ref_id) {\n             Some(id) => {\n                 let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n@@ -402,14 +401,6 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                  sub_span,\n                                  id,\n                                  self.cur_scope);\n-                match impl_id {\n-                    Some(impl_id) => self.fmt.impl_str(trait_ref.path.span,\n-                                                       sub_span,\n-                                                       impl_id,\n-                                                       id,\n-                                                       self.cur_scope),\n-                    None => (),\n-                }\n                 visit::walk_path(self, &trait_ref.path);\n             },\n             None => ()\n@@ -652,7 +643,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: &ast::Ty,\n                     impl_items: &Vec<ast::ImplItem>) {\n+        let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n         match typ.node {\n+            // Common case impl for a struct or something basic.\n             ast::TyPath(ref path, id) => {\n                 match self.lookup_type_ref(id) {\n                     Some(id) => {\n@@ -665,17 +658,29 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.fmt.impl_str(path.span,\n                                           sub_span,\n                                           item.id,\n-                                          id,\n+                                          Some(id),\n+                                          trait_id,\n                                           self.cur_scope);\n                     },\n                     None => ()\n                 }\n             },\n-            _ => self.visit_ty(&*typ),\n+            _ => {\n+                // Less useful case, impl for a compound type.\n+                self.visit_ty(&*typ);\n+\n+                let sub_span = self.span.sub_span_for_type_name(typ.span);\n+                self.fmt.impl_str(typ.span,\n+                                  sub_span,\n+                                  item.id,\n+                                  None,\n+                                  trait_id,\n+                                  self.cur_scope);\n+            }\n         }\n \n         match *trait_ref {\n-            Some(ref trait_ref) => self.process_trait_ref(trait_ref, Some(item.id)),\n+            Some(ref trait_ref) => self.process_trait_ref(trait_ref),\n             None => (),\n         }\n \n@@ -1076,7 +1081,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         for param in generics.ty_params.iter() {\n             for bound in param.bounds.iter() {\n                 if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n-                    self.process_trait_ref(&trait_ref.trait_ref, None);\n+                    self.process_trait_ref(&trait_ref.trait_ref);\n                 }\n             }\n             if let Some(ref ty) = param.default {"}, {"sha": "eefaeca8306c638cd6a57017785dd502a75c7ed2", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/317da0bf2a868e0b946b78268d7b2414b865c2a9/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/317da0bf2a868e0b946b78268d7b2414b865c2a9/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=317da0bf2a868e0b946b78268d7b2414b865c2a9", "patch": "@@ -19,6 +19,8 @@ use syntax::ast;\n use syntax::ast::{NodeId,DefId};\n use syntax::codemap::*;\n \n+const ZERO_DEF_ID: DefId = DefId { node: 0, krate: 0 };\n+\n pub struct Recorder {\n     // output file\n     pub out: Box<Writer+'static>,\n@@ -121,7 +123,9 @@ impl<'a> FmtStrs<'a> {\n             MethodDecl => (\"method_decl\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n             Struct => (\"struct\", vec!(\"id\",\"ctor_id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n             Trait => (\"trait\", vec!(\"id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n-            Impl => (\"impl\", vec!(\"id\",\"refid\",\"refidcrate\",\"scopeid\"), true, true),\n+            Impl => (\"impl\",\n+                     vec!(\"id\",\"refid\",\"refidcrate\",\"traitid\",\"traitidcrate\",\"scopeid\"),\n+                     true, true),\n             Module => (\"module\", vec!(\"id\",\"qualname\",\"scopeid\",\"def_file\"), true, false),\n             UseAlias => (\"use_alias\",\n                          vec!(\"id\",\"refid\",\"refidcrate\",\"name\",\"scopeid\"),\n@@ -444,12 +448,20 @@ impl<'a> FmtStrs<'a> {\n                     span: Span,\n                     sub_span: Option<Span>,\n                     id: NodeId,\n-                    ref_id: DefId,\n+                    ref_id: Option<DefId>,\n+                    trait_id: Option<DefId>,\n                     scope_id: NodeId) {\n+        let ref_id = ref_id.unwrap_or(ZERO_DEF_ID);\n+        let trait_id = trait_id.unwrap_or(ZERO_DEF_ID);\n         self.check_and_record(Impl,\n                               span,\n                               sub_span,\n-                              svec!(id, ref_id.node, ref_id.krate, scope_id));\n+                              svec!(id,\n+                                    ref_id.node,\n+                                    ref_id.krate,\n+                                    trait_id.node,\n+                                    trait_id.krate,\n+                                    scope_id));\n     }\n \n     pub fn mod_str(&mut self,"}]}