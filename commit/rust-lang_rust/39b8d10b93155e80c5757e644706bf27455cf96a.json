{"sha": "39b8d10b93155e80c5757e644706bf27455cf96a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YjhkMTBiOTMxNTVlODBjNTc1N2U2NDQ3MDZiZjI3NDU1Y2Y5NmE=", "commit": {"author": {"name": "Alex Good", "email": "alex@memoryandthought.me", "date": "2021-07-10T14:12:41Z"}, "committer": {"name": "Alex Good", "email": "alex@memoryandthought.me", "date": "2021-07-12T15:05:45Z"}, "message": "Use rustc version of dylib to choose which proc macro ABI to use", "tree": {"sha": "23fe752f48e4e9e48a011dfa3d48cd484042b3a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23fe752f48e4e9e48a011dfa3d48cd484042b3a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39b8d10b93155e80c5757e644706bf27455cf96a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39b8d10b93155e80c5757e644706bf27455cf96a", "html_url": "https://github.com/rust-lang/rust/commit/39b8d10b93155e80c5757e644706bf27455cf96a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39b8d10b93155e80c5757e644706bf27455cf96a/comments", "author": {"login": "alexjg", "id": 224635, "node_id": "MDQ6VXNlcjIyNDYzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/224635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexjg", "html_url": "https://github.com/alexjg", "followers_url": "https://api.github.com/users/alexjg/followers", "following_url": "https://api.github.com/users/alexjg/following{/other_user}", "gists_url": "https://api.github.com/users/alexjg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexjg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexjg/subscriptions", "organizations_url": "https://api.github.com/users/alexjg/orgs", "repos_url": "https://api.github.com/users/alexjg/repos", "events_url": "https://api.github.com/users/alexjg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexjg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexjg", "id": 224635, "node_id": "MDQ6VXNlcjIyNDYzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/224635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexjg", "html_url": "https://github.com/alexjg", "followers_url": "https://api.github.com/users/alexjg/followers", "following_url": "https://api.github.com/users/alexjg/following{/other_user}", "gists_url": "https://api.github.com/users/alexjg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexjg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexjg/subscriptions", "organizations_url": "https://api.github.com/users/alexjg/orgs", "repos_url": "https://api.github.com/users/alexjg/repos", "events_url": "https://api.github.com/users/alexjg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexjg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8b0a9101192b28cbcd4e2ee495613a5f07acbf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8b0a9101192b28cbcd4e2ee495613a5f07acbf2", "html_url": "https://github.com/rust-lang/rust/commit/a8b0a9101192b28cbcd4e2ee495613a5f07acbf2"}], "stats": {"total": 364, "additions": 290, "deletions": 74}, "files": [{"sha": "c5ac2c402cb9a918728209783ab5600574ef487b", "filename": "crates/proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 281, "deletions": 72, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/39b8d10b93155e80c5757e644706bf27455cf96a/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b8d10b93155e80c5757e644706bf27455cf96a/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs?ref=39b8d10b93155e80c5757e644706bf27455cf96a", "patch": "@@ -1,6 +1,8 @@\n //! Handles dynamic library loading for proc macro\n \n use std::{\n+    convert::{TryFrom, TryInto},\n+    fmt,\n     fs::File,\n     io,\n     path::{Path, PathBuf},\n@@ -9,9 +11,16 @@ use std::{\n use libloading::Library;\n use memmap2::Mmap;\n use object::Object;\n-use proc_macro_api::ProcMacroKind;\n+use proc_macro_api::{read_dylib_info, ProcMacroKind, RustCInfo};\n \n-use crate::{proc_macro::bridge, rustc_server::TokenStream};\n+use crate::{\n+    proc_macro::bridge::{self as stable_bridge, client::ProcMacro as StableProcMacro},\n+    rustc_server::TokenStream as StableTokenStream,\n+};\n+use crate::{\n+    proc_macro_nightly::bridge::{self as nightly_bridge, client::ProcMacro as NightlyProcMacro},\n+    rustc_server_nightly::TokenStream as NightlyTokenStream,\n+};\n \n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n \n@@ -74,26 +83,117 @@ fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n     unsafe { UnixLibrary::open(Some(file), RTLD_NOW | RTLD_DEEPBIND).map(|lib| lib.into()) }\n }\n \n-struct ProcMacroLibraryLibloading {\n-    // Hold the dylib to prevent it from unloading\n-    _lib: Library,\n-    exported_macros: Vec<bridge::client::ProcMacro>,\n+enum ProcMacroABI {\n+    Stable,\n+    Nightly,\n+}\n+\n+impl TryFrom<RustCInfo> for ProcMacroABI {\n+    type Error = LoadProcMacroDylibError;\n+\n+    fn try_from(info: RustCInfo) -> Result<Self, Self::Error> {\n+        if info.version.0 < 1 {\n+            Err(LoadProcMacroDylibError::UnsupportedABI)\n+        } else if info.version.1 < 47 {\n+            Err(LoadProcMacroDylibError::UnsupportedABI)\n+        } else if info.version.1 < 54 {\n+            Ok(ProcMacroABI::Stable)\n+        } else {\n+            Ok(ProcMacroABI::Nightly)\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum LoadProcMacroDylibError {\n+    Io(io::Error),\n+    UnsupportedABI,\n+}\n+\n+impl fmt::Display for LoadProcMacroDylibError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Io(e) => e.fmt(f),\n+            Self::UnsupportedABI => write!(f, \"unsupported ABI version\"),\n+        }\n+    }\n+}\n+\n+impl From<io::Error> for LoadProcMacroDylibError {\n+    fn from(e: io::Error) -> Self {\n+        LoadProcMacroDylibError::Io(e)\n+    }\n+}\n+\n+enum ProcMacroLibraryLibloading {\n+    StableProcMacroLibrary {\n+        _lib: Library,\n+        exported_macros: Vec<crate::proc_macro::bridge::client::ProcMacro>,\n+    },\n+    NightlyProcMacroLibrary {\n+        _lib: Library,\n+        exported_macros: Vec<crate::proc_macro_nightly::bridge::client::ProcMacro>,\n+    },\n }\n \n impl ProcMacroLibraryLibloading {\n-    fn open(file: &Path) -> io::Result<Self> {\n+    fn open(file: &Path) -> Result<Self, LoadProcMacroDylibError> {\n         let symbol_name = find_registrar_symbol(file)?.ok_or_else(|| {\n             invalid_data_err(format!(\"Cannot find registrar symbol in file {}\", file.display()))\n         })?;\n \n+        let version_info = read_dylib_info(file)?;\n+        let macro_abi: ProcMacroABI = version_info.try_into()?;\n+\n         let lib = load_library(file).map_err(invalid_data_err)?;\n-        let exported_macros = {\n-            let macros: libloading::Symbol<&&[bridge::client::ProcMacro]> =\n-                unsafe { lib.get(symbol_name.as_bytes()) }.map_err(invalid_data_err)?;\n-            macros.to_vec()\n-        };\n+        match macro_abi {\n+            ProcMacroABI::Stable => {\n+                let macros: libloading::Symbol<&&[crate::proc_macro::bridge::client::ProcMacro]> =\n+                    unsafe { lib.get(symbol_name.as_bytes()) }.map_err(invalid_data_err)?;\n+                let macros_vec = macros.to_vec();\n+                Ok(ProcMacroLibraryLibloading::StableProcMacroLibrary {\n+                    _lib: lib,\n+                    exported_macros: macros_vec,\n+                })\n+            }\n+            ProcMacroABI::Nightly => {\n+                let macros: libloading::Symbol<\n+                    &&[crate::proc_macro_nightly::bridge::client::ProcMacro],\n+                > = unsafe { lib.get(symbol_name.as_bytes()) }.map_err(invalid_data_err)?;\n+                let macros_vec = macros.to_vec();\n+                Ok(ProcMacroLibraryLibloading::NightlyProcMacroLibrary {\n+                    _lib: lib,\n+                    exported_macros: macros_vec,\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum PanicMessage {\n+    Stable(stable_bridge::PanicMessage),\n+    Nightly(nightly_bridge::PanicMessage),\n+}\n+\n+impl From<stable_bridge::PanicMessage> for PanicMessage {\n+    fn from(p: stable_bridge::PanicMessage) -> Self {\n+        PanicMessage::Stable(p)\n+    }\n+}\n+\n+impl From<nightly_bridge::PanicMessage> for PanicMessage {\n+    fn from(p: nightly_bridge::PanicMessage) -> Self {\n+        PanicMessage::Nightly(p)\n+    }\n+}\n \n-        Ok(ProcMacroLibraryLibloading { _lib: lib, exported_macros })\n+impl PanicMessage {\n+    pub fn as_str(&self) -> Option<&str> {\n+        match self {\n+            Self::Stable(p) => p.as_str(),\n+            Self::Nightly(p) => p.as_str(),\n+        }\n     }\n }\n \n@@ -102,7 +202,7 @@ pub struct Expander {\n }\n \n impl Expander {\n-    pub fn new(lib: &Path) -> io::Result<Expander> {\n+    pub fn new(lib: &Path) -> Result<Expander, LoadProcMacroDylibError> {\n         // Some libraries for dynamic loading require canonicalized path even when it is\n         // already absolute\n         let lib = lib.canonicalize()?;\n@@ -119,69 +219,28 @@ impl Expander {\n         macro_name: &str,\n         macro_body: &tt::Subtree,\n         attributes: Option<&tt::Subtree>,\n-    ) -> Result<tt::Subtree, bridge::PanicMessage> {\n-        let parsed_body = TokenStream::with_subtree(macro_body.clone());\n-\n-        let parsed_attributes = attributes\n-            .map_or(crate::rustc_server::TokenStream::new(), |attr| {\n-                TokenStream::with_subtree(attr.clone())\n-            });\n-\n-        for proc_macro in &self.inner.exported_macros {\n-            match proc_macro {\n-                bridge::client::ProcMacro::CustomDerive { trait_name, client, .. }\n-                    if *trait_name == macro_name =>\n-                {\n-                    let res = client.run(\n-                        &crate::proc_macro::bridge::server::SameThread,\n-                        crate::rustc_server::Rustc::default(),\n-                        parsed_body,\n-                        false,\n-                    );\n-                    return res.map(|it| it.into_subtree());\n-                }\n-                bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n-                    let res = client.run(\n-                        &crate::proc_macro::bridge::server::SameThread,\n-                        crate::rustc_server::Rustc::default(),\n-                        parsed_body,\n-                        false,\n-                    );\n-                    return res.map(|it| it.into_subtree());\n-                }\n-                bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n-                    let res = client.run(\n-                        &crate::proc_macro::bridge::server::SameThread,\n-                        crate::rustc_server::Rustc::default(),\n-                        parsed_attributes,\n-                        parsed_body,\n-                        false,\n-                    );\n-                    return res.map(|it| it.into_subtree());\n-                }\n-                _ => continue,\n+    ) -> Result<tt::Subtree, PanicMessage> {\n+        match &self.inner {\n+            ProcMacroLibraryLibloading::StableProcMacroLibrary { exported_macros, .. } => {\n+                expand_stable(macro_name, macro_body, attributes, &exported_macros[..])\n+                    .map_err(PanicMessage::from)\n+            }\n+            ProcMacroLibraryLibloading::NightlyProcMacroLibrary { exported_macros, .. } => {\n+                expand_nightly(macro_name, macro_body, attributes, &exported_macros[..])\n+                    .map_err(PanicMessage::from)\n             }\n         }\n-\n-        Err(bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n     }\n \n     pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        self.inner\n-            .exported_macros\n-            .iter()\n-            .map(|proc_macro| match proc_macro {\n-                bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n-                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n-                }\n-                bridge::client::ProcMacro::Bang { name, .. } => {\n-                    (name.to_string(), ProcMacroKind::FuncLike)\n-                }\n-                bridge::client::ProcMacro::Attr { name, .. } => {\n-                    (name.to_string(), ProcMacroKind::Attr)\n-                }\n-            })\n-            .collect()\n+        match &self.inner {\n+            ProcMacroLibraryLibloading::StableProcMacroLibrary { exported_macros, .. } => {\n+                list_macros_stable(&exported_macros[..])\n+            }\n+            ProcMacroLibraryLibloading::NightlyProcMacroLibrary { exported_macros, .. } => {\n+                list_macros_nightly(&exported_macros[..])\n+            }\n+        }\n     }\n }\n \n@@ -217,3 +276,153 @@ fn ensure_file_with_lock_free_access(path: &Path) -> io::Result<PathBuf> {\n fn ensure_file_with_lock_free_access(path: &Path) -> io::Result<PathBuf> {\n     Ok(path.to_path_buf())\n }\n+\n+fn expand_nightly(\n+    macro_name: &str,\n+    macro_body: &tt::Subtree,\n+    attributes: Option<&tt::Subtree>,\n+    macros: &[NightlyProcMacro],\n+) -> Result<tt::Subtree, crate::proc_macro_nightly::bridge::PanicMessage> {\n+    let parsed_body = NightlyTokenStream::with_subtree(macro_body.clone());\n+\n+    let parsed_attributes = attributes\n+        .map_or(crate::rustc_server_nightly::TokenStream::new(), |attr| {\n+            NightlyTokenStream::with_subtree(attr.clone())\n+        });\n+\n+    for proc_macro in macros {\n+        match proc_macro {\n+            crate::proc_macro_nightly::bridge::client::ProcMacro::CustomDerive {\n+                trait_name,\n+                client,\n+                ..\n+            } if *trait_name == macro_name => {\n+                let res = client.run(\n+                    &crate::proc_macro_nightly::bridge::server::SameThread,\n+                    crate::rustc_server_nightly::Rustc::default(),\n+                    parsed_body,\n+                    false,\n+                );\n+                return res.map(|it| it.into_subtree());\n+            }\n+            crate::proc_macro_nightly::bridge::client::ProcMacro::Bang { name, client }\n+                if *name == macro_name =>\n+            {\n+                let res = client.run(\n+                    &crate::proc_macro_nightly::bridge::server::SameThread,\n+                    crate::rustc_server_nightly::Rustc::default(),\n+                    parsed_body,\n+                    false,\n+                );\n+                return res.map(|it| it.into_subtree());\n+            }\n+            crate::proc_macro_nightly::bridge::client::ProcMacro::Attr { name, client }\n+                if *name == macro_name =>\n+            {\n+                let res = client.run(\n+                    &crate::proc_macro_nightly::bridge::server::SameThread,\n+                    crate::rustc_server_nightly::Rustc::default(),\n+                    parsed_attributes,\n+                    parsed_body,\n+                    false,\n+                );\n+                return res.map(|it| it.into_subtree());\n+            }\n+            _ => continue,\n+        }\n+    }\n+\n+    Err(crate::proc_macro_nightly::bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n+}\n+\n+fn expand_stable(\n+    macro_name: &str,\n+    macro_body: &tt::Subtree,\n+    attributes: Option<&tt::Subtree>,\n+    macros: &[StableProcMacro],\n+) -> Result<tt::Subtree, crate::proc_macro::bridge::PanicMessage> {\n+    let parsed_body = StableTokenStream::with_subtree(macro_body.clone());\n+\n+    let parsed_attributes = attributes.map_or(crate::rustc_server::TokenStream::new(), |attr| {\n+        StableTokenStream::with_subtree(attr.clone())\n+    });\n+\n+    for proc_macro in macros {\n+        match proc_macro {\n+            crate::proc_macro::bridge::client::ProcMacro::CustomDerive {\n+                trait_name,\n+                client,\n+                ..\n+            } if *trait_name == macro_name => {\n+                let res = client.run(\n+                    &crate::proc_macro::bridge::server::SameThread,\n+                    crate::rustc_server::Rustc::default(),\n+                    parsed_body,\n+                    false,\n+                );\n+                return res.map(|it| it.into_subtree());\n+            }\n+            crate::proc_macro::bridge::client::ProcMacro::Bang { name, client }\n+                if *name == macro_name =>\n+            {\n+                let res = client.run(\n+                    &crate::proc_macro::bridge::server::SameThread,\n+                    crate::rustc_server::Rustc::default(),\n+                    parsed_body,\n+                    false,\n+                );\n+                return res.map(|it| it.into_subtree());\n+            }\n+            crate::proc_macro::bridge::client::ProcMacro::Attr { name, client }\n+                if *name == macro_name =>\n+            {\n+                let res = client.run(\n+                    &crate::proc_macro::bridge::server::SameThread,\n+                    crate::rustc_server::Rustc::default(),\n+                    parsed_attributes,\n+                    parsed_body,\n+                    false,\n+                );\n+                return res.map(|it| it.into_subtree());\n+            }\n+            _ => continue,\n+        }\n+    }\n+\n+    Err(crate::proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n+}\n+\n+pub fn list_macros_stable(macros: &[StableProcMacro]) -> Vec<(String, ProcMacroKind)> {\n+    macros\n+        .iter()\n+        .map(|proc_macro| match proc_macro {\n+            crate::proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+            }\n+            crate::proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n+                (name.to_string(), ProcMacroKind::FuncLike)\n+            }\n+            crate::proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n+                (name.to_string(), ProcMacroKind::Attr)\n+            }\n+        })\n+        .collect()\n+}\n+\n+pub fn list_macros_nightly(macros: &[NightlyProcMacro]) -> Vec<(String, ProcMacroKind)> {\n+    macros\n+        .iter()\n+        .map(|proc_macro| match proc_macro {\n+            crate::proc_macro_nightly::bridge::client::ProcMacro::CustomDerive {\n+                trait_name,\n+                ..\n+            } => (trait_name.to_string(), ProcMacroKind::CustomDerive),\n+            crate::proc_macro_nightly::bridge::client::ProcMacro::Bang { name, .. } => {\n+                (name.to_string(), ProcMacroKind::FuncLike)\n+            }\n+            crate::proc_macro_nightly::bridge::client::ProcMacro::Attr { name, .. } => {\n+                (name.to_string(), ProcMacroKind::Attr)\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "deb1d1e526ebcd457817ba67a642cce5859fc24f", "filename": "crates/proc_macro_srv/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/39b8d10b93155e80c5757e644706bf27455cf96a/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b8d10b93155e80c5757e644706bf27455cf96a/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs?ref=39b8d10b93155e80c5757e644706bf27455cf96a", "patch": "@@ -15,9 +15,16 @@\n #[doc(hidden)]\n mod proc_macro;\n \n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod proc_macro_nightly;\n+\n #[doc(hidden)]\n mod rustc_server;\n \n+#[doc(hidden)]\n+mod rustc_server_nightly;\n+\n mod dylib;\n \n use proc_macro::bridge::client::TokenStream;"}, {"sha": "1565db187c6d704dc4113cdad0d712dd03867b24", "filename": "crates/proc_macro_srv/src/proc_macro_nightly/bridge/buffer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39b8d10b93155e80c5757e644706bf27455cf96a/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro_nightly%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b8d10b93155e80c5757e644706bf27455cf96a/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro_nightly%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro_nightly%2Fbridge%2Fbuffer.rs?ref=39b8d10b93155e80c5757e644706bf27455cf96a", "patch": "@@ -91,7 +91,7 @@ impl<T: Copy> Buffer<T> {\n             self.len += xs.len();\n         }\n     }\n-    \n+\n     pub(super) fn push(&mut self, v: T) {\n         // The code here is taken from Vec::push, and we know that reserve()\n         // will panic if we're exceeding isize::MAX bytes and so there's no need\n@@ -145,7 +145,7 @@ impl<T: Copy> From<Vec<T>> for Buffer<T> {\n             }\n         }\n \n-         extern \"C\" fn reserve<T: Copy>(b: Buffer<T>, additional: usize) -> Buffer<T> {\n+        extern \"C\" fn reserve<T: Copy>(b: Buffer<T>, additional: usize) -> Buffer<T> {\n             let mut v = to_vec(b);\n             v.reserve(additional);\n             Buffer::from(v)"}]}