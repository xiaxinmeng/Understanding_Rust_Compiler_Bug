{"sha": "24b37a737467ccb4ef93a95f822b9933f3aa56b0", "node_id": "C_kwDOAAsO6NoAKDI0YjM3YTczNzQ2N2NjYjRlZjkzYTk1ZjgyMmI5OTMzZjNhYTU2YjA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-08T20:50:56Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-12T17:51:46Z"}, "message": "Pass last_import_segment and unusable_binding as parameters.", "tree": {"sha": "f6101d2f7774fde1e7f83e55efb15909731c8396", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6101d2f7774fde1e7f83e55efb15909731c8396"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24b37a737467ccb4ef93a95f822b9933f3aa56b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24b37a737467ccb4ef93a95f822b9933f3aa56b0", "html_url": "https://github.com/rust-lang/rust/commit/24b37a737467ccb4ef93a95f822b9933f3aa56b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24b37a737467ccb4ef93a95f822b9933f3aa56b0/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb7f5673d9992b1dccc1bc97460267e630fc4ca0", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb7f5673d9992b1dccc1bc97460267e630fc4ca0", "html_url": "https://github.com/rust-lang/rust/commit/eb7f5673d9992b1dccc1bc97460267e630fc4ca0"}], "stats": {"total": 256, "additions": 177, "deletions": 79}, "files": [{"sha": "54e8c03156d558448b64e58721c885d99457b7bd", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=24b37a737467ccb4ef93a95f822b9933f3aa56b0", "patch": "@@ -297,6 +297,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     Some(TypeNS),\n                     parent_scope,\n                     if finalize { Finalize::SimplePath(id, path.span) } else { Finalize::No },\n+                    None,\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         let res = module.res().expect(\"visibility resolved to unnamed block\");\n@@ -1124,12 +1125,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {\n-                let result = self.r.resolve_ident_in_module(\n+                let result = self.r.maybe_resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n                     &self.parent_scope,\n-                    None,\n                 );\n                 if let Ok(binding) = result {\n                     let import = macro_use_import(self, ident.span);"}, {"sha": "fdcc045efd81592e1afe302e3028d64f069085d4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=24b37a737467ccb4ef93a95f822b9933f3aa56b0", "patch": "@@ -25,7 +25,7 @@ use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot};\n-use crate::{Finalize, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n+use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -1076,6 +1076,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 None,\n                 false,\n+                false,\n+                None,\n             ) {\n                 let desc = match binding.res() {\n                     Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n@@ -1422,7 +1424,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1441,7 +1443,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1472,7 +1474,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1506,7 +1508,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+            let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n             debug!(\n                 \"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                 name, path, result"}, {"sha": "e528a50d1475474267407e617093d19e56e8ff67", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 102, "deletions": 9, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=24b37a737467ccb4ef93a95f822b9933f3aa56b0", "patch": "@@ -280,13 +280,15 @@ impl<'a> Resolver<'a> {\n     ///\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n+    #[tracing::instrument(level = \"debug\", skip(self, ribs))]\n     crate fn resolve_ident_in_lexical_scope(\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n         finalize_full: Finalize,\n         ribs: &[Rib<'a>],\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n         let orig_ident = ident;\n@@ -349,6 +351,8 @@ impl<'a> Resolver<'a> {\n                 ns,\n                 parent_scope,\n                 finalize,\n+                false,\n+                unusable_binding,\n             );\n             if let Ok(binding) = item {\n                 // The ident resolves to an item.\n@@ -361,6 +365,8 @@ impl<'a> Resolver<'a> {\n             parent_scope,\n             finalize,\n             finalize.is_some(),\n+            false,\n+            unusable_binding,\n         )\n         .ok()\n         .map(LexicalScopeBinding::Item)\n@@ -371,13 +377,16 @@ impl<'a> Resolver<'a> {\n     /// expansion and import resolution (perhaps they can be merged in the future).\n     /// The function is used for resolving initial segments of macro paths (e.g., `foo` in\n     /// `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n+    #[tracing::instrument(level = \"debug\", skip(self, scope_set))]\n     crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         orig_ident: Ident,\n         scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n         finalize: Option<Span>,\n         force: bool,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         bitflags::bitflags! {\n             struct Flags: u8 {\n@@ -497,6 +506,8 @@ impl<'a> Resolver<'a> {\n                             ns,\n                             parent_scope,\n                             finalize,\n+                            last_import_segment,\n+                            unusable_binding,\n                         );\n                         match binding {\n                             Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n@@ -518,6 +529,8 @@ impl<'a> Resolver<'a> {\n                             adjusted_parent_scope,\n                             !matches!(scope_set, ScopeSet::Late(..)),\n                             finalize,\n+                            last_import_segment,\n+                            unusable_binding,\n                         );\n                         match binding {\n                             Ok(binding) => {\n@@ -602,6 +615,8 @@ impl<'a> Resolver<'a> {\n                                 ns,\n                                 parent_scope,\n                                 None,\n+                                last_import_segment,\n+                                unusable_binding,\n                             ) {\n                                 if use_prelude || this.is_builtin_macro(binding.res()) {\n                                     result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n@@ -715,25 +730,54 @@ impl<'a> Resolver<'a> {\n         Err(Determinacy::determined(determinacy == Determinacy::Determined || force))\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn maybe_resolve_ident_in_module(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, None, false, None)\n+            .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     crate fn resolve_ident_in_module(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n         finalize: Option<Span>,\n+        // We are resolving a last import segment during import validation.\n+        last_import_segment: bool,\n+        // This binding should be ignored during in-module resolution, so that we don't get\n+        // \"self-confirming\" import resolutions during import validation.\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize)\n-            .map_err(|(determinacy, _)| determinacy)\n+        self.resolve_ident_in_module_ext(\n+            module,\n+            ident,\n+            ns,\n+            parent_scope,\n+            finalize,\n+            last_import_segment,\n+            unusable_binding,\n+        )\n+        .map_err(|(determinacy, _)| determinacy)\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_ident_in_module_ext(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n         finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let tmp_parent_scope;\n         let mut adjusted_parent_scope = parent_scope;\n@@ -759,16 +803,21 @@ impl<'a> Resolver<'a> {\n             adjusted_parent_scope,\n             false,\n             finalize,\n+            last_import_segment,\n+            unusable_binding,\n         )\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_ident_in_module_unadjusted(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n         finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.resolve_ident_in_module_unadjusted_ext(\n             module,\n@@ -777,12 +826,15 @@ impl<'a> Resolver<'a> {\n             parent_scope,\n             false,\n             finalize,\n+            last_import_segment,\n+            unusable_binding,\n         )\n         .map_err(|(determinacy, _)| determinacy)\n     }\n \n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_ident_in_module_unadjusted_ext(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n@@ -791,6 +843,8 @@ impl<'a> Resolver<'a> {\n         parent_scope: &ParentScope<'a>,\n         restricted_shadowing: bool,\n         finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n@@ -802,6 +856,8 @@ impl<'a> Resolver<'a> {\n                     parent_scope,\n                     finalize,\n                     finalize.is_some(),\n+                    last_import_segment,\n+                    unusable_binding,\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n@@ -841,6 +897,8 @@ impl<'a> Resolver<'a> {\n                     parent_scope,\n                     finalize,\n                     finalize.is_some(),\n+                    last_import_segment,\n+                    unusable_binding,\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n@@ -865,7 +923,7 @@ impl<'a> Resolver<'a> {\n             // binding if it exists. What we really want here is having two separate scopes in\n             // a module - one for non-globs and one for globs, but until that's done use this\n             // hack to avoid inconsistent resolution ICEs during import validation.\n-            if let Some(unusable_binding) = self.unusable_binding\n+            if let Some(unusable_binding) = unusable_binding\n                 && ptr::eq(binding, unusable_binding)\n             {\n                 let Some(shadowed) = resolution.shadowed_glob else {\n@@ -880,7 +938,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             if !self.is_accessible_from(binding.vis, parent_scope.module) {\n-                if self.last_import_segment {\n+                if last_import_segment {\n                     return Err((Determined, Weak::No));\n                 } else {\n                     self.privacy_errors.push(PrivacyError {\n@@ -912,7 +970,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            if let Some(unusable_binding) = this.unusable_binding {\n+            if let Some(unusable_binding) = unusable_binding {\n                 if ptr::eq(binding, unusable_binding) {\n                     return Err((Determined, Weak::No));\n                 }\n@@ -942,8 +1000,15 @@ impl<'a> Resolver<'a> {\n             let ImportKind::Single { source: ident, .. } = single_import.kind else {\n                 unreachable!();\n             };\n-            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope, None)\n-            {\n+            match self.resolve_ident_in_module(\n+                module,\n+                ident,\n+                ns,\n+                &single_import.parent_scope,\n+                None,\n+                last_import_segment,\n+                unusable_binding,\n+            ) {\n                 Err(Determined) => continue,\n                 Ok(binding)\n                     if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n@@ -1018,6 +1083,8 @@ impl<'a> Resolver<'a> {\n                 ns,\n                 adjusted_parent_scope,\n                 None,\n+                last_import_segment,\n+                unusable_binding,\n             );\n \n             match result {\n@@ -1036,6 +1103,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Validate a local resolution (from ribs).\n+    #[tracing::instrument(level = \"debug\", skip(self, all_ribs))]\n     fn validate_res_from_ribs(\n         &mut self,\n         rib_index: usize,\n@@ -1268,14 +1336,26 @@ impl<'a> Resolver<'a> {\n         res\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn maybe_resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+    ) -> PathResult<'a> {\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, Finalize::No, None, None)\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     crate fn resolve_path(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n         finalize: Finalize,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None)\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None, unusable_binding)\n     }\n \n     crate fn resolve_path_with_ribs(\n@@ -1285,6 +1365,7 @@ impl<'a> Resolver<'a> {\n         parent_scope: &ParentScope<'a>,\n         finalize_full: Finalize,\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> PathResult<'a> {\n         debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n \n@@ -1382,7 +1463,15 @@ impl<'a> Resolver<'a> {\n             }\n             let find_binding_in_ns = |this: &mut Self, ns| {\n                 let binding = if let Some(module) = module {\n-                    this.resolve_ident_in_module(module, ident, ns, parent_scope, finalize)\n+                    this.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        finalize,\n+                        false,\n+                        unusable_binding,\n+                    )\n                 } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                     let scopes = ScopeSet::All(ns, opt_ns.is_none());\n                     this.early_resolve_ident_in_lexical_scope(\n@@ -1391,6 +1480,8 @@ impl<'a> Resolver<'a> {\n                         parent_scope,\n                         finalize,\n                         finalize.is_some(),\n+                        false,\n+                        unusable_binding,\n                     )\n                 } else {\n                     match this.resolve_ident_in_lexical_scope(\n@@ -1399,6 +1490,7 @@ impl<'a> Resolver<'a> {\n                         parent_scope,\n                         finalize_full,\n                         &ribs.unwrap()[ns],\n+                        unusable_binding,\n                     ) {\n                         // we found a locally-imported or available item/module\n                         Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n@@ -1514,6 +1606,7 @@ impl<'a> Resolver<'a> {\n                                         parent_scope,\n                                         Finalize::No,\n                                         &ribs.unwrap()[ValueNS],\n+                                        unusable_binding,\n                                     ) {\n                                         // Name matches a local variable. For example:\n                                         // ```"}, {"sha": "aab0c1f97717c79b6fe3117c2543838181858dbf", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=24b37a737467ccb4ef93a95f822b9933f3aa56b0", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // not define any names while resolving its module path.\n             let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n             let path_res =\n-                self.r.resolve_path(&import.module_path, None, &import.parent_scope, Finalize::No);\n+                self.r.maybe_resolve_path(&import.module_path, None, &import.parent_scope);\n             import.vis.set(orig_vis);\n \n             match path_res {\n@@ -539,6 +539,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ns,\n                         &import.parent_scope,\n                         None,\n+                        false,\n+                        None,\n                     );\n                     import.vis.set(orig_vis);\n                     source_bindings[ns].set(binding);\n@@ -584,10 +586,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n     fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n         let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-        let orig_unusable_binding = match &import.kind {\n-            ImportKind::Single { target_bindings, .. } => {\n-                Some(mem::replace(&mut self.r.unusable_binding, target_bindings[TypeNS].get()))\n-            }\n+        let unusable_binding = match &import.kind {\n+            ImportKind::Single { target_bindings, .. } => target_bindings[TypeNS].get(),\n             _ => None,\n         };\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n@@ -596,12 +596,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             root_span: import.root_span,\n             path_span: import.span,\n         };\n-        let path_res =\n-            self.r.resolve_path(&import.module_path, None, &import.parent_scope, finalize);\n+        let path_res = self.r.resolve_path(\n+            &import.module_path,\n+            None,\n+            &import.parent_scope,\n+            finalize,\n+            unusable_binding,\n+        );\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n-        if let Some(orig_unusable_binding) = orig_unusable_binding {\n-            self.r.unusable_binding = orig_unusable_binding;\n-        }\n         import.vis.set(orig_vis);\n         if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n             // Consider erroneous imports used to avoid duplicate diagnostics.\n@@ -714,18 +716,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-                let orig_unusable_binding =\n-                    mem::replace(&mut this.unusable_binding, target_bindings[ns].get());\n-                let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n                 let binding = this.resolve_ident_in_module(\n                     module,\n                     ident,\n                     ns,\n                     &import.parent_scope,\n                     Some(import.span),\n+                    true,\n+                    target_bindings[ns].get(),\n                 );\n-                this.last_import_segment = orig_last_import_segment;\n-                this.unusable_binding = orig_unusable_binding;\n                 import.vis.set(orig_vis);\n \n                 match binding {\n@@ -784,6 +783,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ns,\n                         &import.parent_scope,\n                         Some(import.span),\n+                        false,\n+                        None,\n                     );\n                     if binding.is_ok() {\n                         all_ns_failed = false;\n@@ -998,15 +999,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     return;\n                 }\n \n-                let orig_unusable_binding =\n-                    mem::replace(&mut this.unusable_binding, target_bindings[ns].get());\n-\n                 match this.early_resolve_ident_in_lexical_scope(\n                     target,\n                     ScopeSet::All(ns, false),\n                     &import.parent_scope,\n                     None,\n                     false,\n+                    false,\n+                    target_bindings[ns].get(),\n                 ) {\n                     Ok(other_binding) => {\n                         is_redundant[ns] = Some(\n@@ -1016,8 +1016,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     }\n                     Err(_) => is_redundant[ns] = Some(false),\n                 }\n-\n-                this.unusable_binding = orig_unusable_binding;\n             }\n         });\n "}, {"sha": "9084e659ae4958dec4cdfc0bb4ff7e284d710b2a", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=24b37a737467ccb4ef93a95f822b9933f3aa56b0", "patch": "@@ -8,7 +8,7 @@\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, Finalize, LexicalScopeBinding};\n-use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n+use crate::{Module, ModuleOrUniformRoot, NameBinding, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use rustc_ast::ptr::P;\n@@ -487,6 +487,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         self_ty,\n                         TypeNS,\n                         Finalize::SimplePath(ty.id, ty.span),\n+                        None,\n                     )\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n@@ -676,12 +677,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     // checking.\n                     if path.segments.len() == 1 && path.segments[0].args.is_none() {\n                         let mut check_ns = |ns| {\n-                            self.resolve_ident_in_lexical_scope(\n-                                path.segments[0].ident,\n-                                ns,\n-                                Finalize::No,\n-                            )\n-                            .is_some()\n+                            self.maybe_resolve_ident_in_lexical_scope(path.segments[0].ident, ns)\n+                                .is_some()\n                         };\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n                             // This must be equivalent to `visit_anon_const`, but we cannot call it\n@@ -750,18 +747,35 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n+    fn maybe_resolve_ident_in_lexical_scope(\n+        &mut self,\n+        ident: Ident,\n+        ns: Namespace,\n+    ) -> Option<LexicalScopeBinding<'a>> {\n+        self.r.resolve_ident_in_lexical_scope(\n+            ident,\n+            ns,\n+            &self.parent_scope,\n+            Finalize::No,\n+            &self.ribs[ns],\n+            None,\n+        )\n+    }\n+\n     fn resolve_ident_in_lexical_scope(\n         &mut self,\n         ident: Ident,\n         ns: Namespace,\n         finalize: Finalize,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         self.r.resolve_ident_in_lexical_scope(\n             ident,\n             ns,\n             &self.parent_scope,\n             finalize,\n             &self.ribs[ns],\n+            unusable_binding,\n         )\n     }\n \n@@ -771,7 +785,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         finalize: Finalize,\n     ) -> PathResult<'a> {\n-        self.r.resolve_path_with_ribs(path, opt_ns, &self.parent_scope, finalize, Some(&self.ribs))\n+        self.r.resolve_path_with_ribs(\n+            path,\n+            opt_ns,\n+            &self.parent_scope,\n+            finalize,\n+            Some(&self.ribs),\n+            None,\n+        )\n     }\n \n     // AST resolution\n@@ -934,19 +955,16 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n             for &ns in nss {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No) {\n+                match self.maybe_resolve_ident_in_lexical_scope(ident, ns) {\n                     Some(LexicalScopeBinding::Res(..)) => {\n                         report_error(self, ns);\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n-                        let orig_unusable_binding =\n-                            replace(&mut self.r.unusable_binding, Some(binding));\n-                        if let Some(LexicalScopeBinding::Res(..)) =\n-                            self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No)\n+                        if let Some(LexicalScopeBinding::Res(..)) = self\n+                            .resolve_ident_in_lexical_scope(ident, ns, Finalize::No, Some(binding))\n                         {\n                             report_error(self, ns);\n                         }\n-                        self.r.unusable_binding = orig_unusable_binding;\n                     }\n                     None => {}\n                 }\n@@ -1802,7 +1820,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n-        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No)?;\n+        let ls_binding = self.maybe_resolve_ident_in_lexical_scope(ident, ValueNS)?;\n         let (res, binding) = match ls_binding {\n             LexicalScopeBinding::Item(binding)\n                 if is_syntactic_ambiguity && binding.is_ambiguity() =>\n@@ -2071,17 +2089,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn self_type_is_available(&mut self) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(\n-            Ident::with_dummy_span(kw::SelfUpper),\n-            TypeNS,\n-            Finalize::No,\n-        );\n+        let binding = self\n+            .maybe_resolve_ident_in_lexical_scope(Ident::with_dummy_span(kw::SelfUpper), TypeNS);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span) -> bool {\n         let ident = Ident::new(kw::SelfLower, self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No);\n+        let binding = self.maybe_resolve_ident_in_lexical_scope(ident, ValueNS);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n "}, {"sha": "eae9e846c8b7747ae30de00cdac5b3d58f739c65", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=24b37a737467ccb4ef93a95f822b9933f3aa56b0", "patch": "@@ -1271,12 +1271,11 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) = self.r.resolve_ident_in_module(\n+            if let Ok(binding) = self.r.maybe_resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n                 &self.parent_scope,\n-                None,\n             ) {\n                 let res = binding.res();\n                 if filter_fn(res) {"}, {"sha": "c0875bf547a00177cfde6dc2083740154824cedf", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=24b37a737467ccb4ef93a95f822b9933f3aa56b0", "patch": "@@ -925,13 +925,6 @@ pub struct Resolver<'a> {\n     /// All non-determined imports.\n     indeterminate_imports: Vec<&'a Import<'a>>,\n \n-    /// FIXME: Refactor things so that these fields are passed through arguments and not resolver.\n-    /// We are resolving a last import segment during import validation.\n-    last_import_segment: bool,\n-    /// This binding should be ignored during in-module resolution, so that we don't get\n-    /// \"self-confirming\" import resolutions during import validation.\n-    unusable_binding: Option<&'a NameBinding<'a>>,\n-\n     // Spans for local variables found during pattern resolution.\n     // Used for suggestions during error reporting.\n     pat_span_map: NodeMap<Span>,\n@@ -1339,9 +1332,6 @@ impl<'a> Resolver<'a> {\n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n \n-            last_import_segment: false,\n-            unusable_binding: None,\n-\n             pat_span_map: Default::default(),\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n@@ -2294,12 +2284,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let module = self.expect_module(module_id);\n-        match self.resolve_path(\n-            &segments,\n-            Some(ns),\n-            &ParentScope::module(module, self),\n-            Finalize::No,\n-        ) {\n+        match self.maybe_resolve_path(&segments, Some(ns), &ParentScope::module(module, self)) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                 Some(path_res.base_res())\n@@ -2389,12 +2374,11 @@ impl<'a> Resolver<'a> {\n         let ident = Ident::with_dummy_span(sym::main);\n         let parent_scope = &ParentScope::module(module, self);\n \n-        let Ok(name_binding) = self.resolve_ident_in_module(\n+        let Ok(name_binding) = self.maybe_resolve_ident_in_module(\n             ModuleOrUniformRoot::Module(module),\n             ident,\n             ValueNS,\n             parent_scope,\n-            None\n         ) else {\n             return;\n         };"}, {"sha": "01f0b11f1ac3beb0030649a55e360f50bb7d09c9", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b37a737467ccb4ef93a95f822b9933f3aa56b0/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=24b37a737467ccb4ef93a95f822b9933f3aa56b0", "patch": "@@ -412,7 +412,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n         let mut indeterminate = false;\n         for ns in [TypeNS, ValueNS, MacroNS].iter().copied() {\n-            match self.resolve_path(path, Some(ns), &parent_scope, Finalize::No) {\n+            match self.maybe_resolve_path(path, Some(ns), &parent_scope) {\n                 PathResult::Module(ModuleOrUniformRoot::Module(_)) => return Ok(true),\n                 PathResult::NonModule(partial_res) if partial_res.unresolved_segments() == 0 => {\n                     return Ok(true);\n@@ -572,7 +572,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let res = if path.len() > 1 {\n-            let res = match self.resolve_path(&path, Some(MacroNS), parent_scope, Finalize::No) {\n+            let res = match self.maybe_resolve_path(&path, Some(MacroNS), parent_scope) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     Ok(path_res.base_res())\n                 }\n@@ -604,6 +604,8 @@ impl<'a> Resolver<'a> {\n                 parent_scope,\n                 None,\n                 force,\n+                false,\n+                None,\n             );\n             if let Err(Determinacy::Undetermined) = binding {\n                 return Err(Determinacy::Undetermined);\n@@ -672,6 +674,7 @@ impl<'a> Resolver<'a> {\n                 Some(MacroNS),\n                 &parent_scope,\n                 Finalize::SimplePath(ast::CRATE_NODE_ID, path_span),\n+                None,\n             ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     let res = path_res.base_res();\n@@ -707,6 +710,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 Some(ident.span),\n                 true,\n+                false,\n+                None,\n             ) {\n                 Ok(binding) => {\n                     let initial_res = initial_binding.map(|initial_binding| {\n@@ -748,6 +753,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 Some(ident.span),\n                 true,\n+                false,\n+                None,\n             );\n         }\n     }"}]}