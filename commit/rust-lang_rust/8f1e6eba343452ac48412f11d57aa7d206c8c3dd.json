{"sha": "8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "node_id": "C_kwDOAAsO6NoAKDhmMWU2ZWJhMzQzNDUyYWM0ODQxMmYxMWQ1N2FhN2QyMDZjOGMzZGQ", "commit": {"author": {"name": "John Millikin", "email": "john@john-millikin.com", "date": "2022-09-18T07:20:11Z"}, "committer": {"name": "John Millikin", "email": "john@john-millikin.com", "date": "2022-09-18T07:20:11Z"}, "message": "Move `unix_socket_abstract` feature API to `SocketAddrExt`.", "tree": {"sha": "079a3ebd2d6530bd01823b5c01abeb8e1f4504ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/079a3ebd2d6530bd01823b5c01abeb8e1f4504ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "html_url": "https://github.com/rust-lang/rust/commit/8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/comments", "author": {"login": "jmillikin", "id": 646128, "node_id": "MDQ6VXNlcjY0NjEyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/646128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jmillikin", "html_url": "https://github.com/jmillikin", "followers_url": "https://api.github.com/users/jmillikin/followers", "following_url": "https://api.github.com/users/jmillikin/following{/other_user}", "gists_url": "https://api.github.com/users/jmillikin/gists{/gist_id}", "starred_url": "https://api.github.com/users/jmillikin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jmillikin/subscriptions", "organizations_url": "https://api.github.com/users/jmillikin/orgs", "repos_url": "https://api.github.com/users/jmillikin/repos", "events_url": "https://api.github.com/users/jmillikin/events{/privacy}", "received_events_url": "https://api.github.com/users/jmillikin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jmillikin", "id": 646128, "node_id": "MDQ6VXNlcjY0NjEyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/646128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jmillikin", "html_url": "https://github.com/jmillikin", "followers_url": "https://api.github.com/users/jmillikin/followers", "following_url": "https://api.github.com/users/jmillikin/following{/other_user}", "gists_url": "https://api.github.com/users/jmillikin/gists{/gist_id}", "starred_url": "https://api.github.com/users/jmillikin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jmillikin/subscriptions", "organizations_url": "https://api.github.com/users/jmillikin/orgs", "repos_url": "https://api.github.com/users/jmillikin/repos", "events_url": "https://api.github.com/users/jmillikin/events{/privacy}", "received_events_url": "https://api.github.com/users/jmillikin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc380ecd13f0a16519ebf1df64648d006a4985fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc380ecd13f0a16519ebf1df64648d006a4985fc", "html_url": "https://github.com/rust-lang/rust/commit/fc380ecd13f0a16519ebf1df64648d006a4985fc"}], "stats": {"total": 206, "additions": 123, "deletions": 83}, "files": [{"sha": "7cecd1bbfaa95bf360b839c5dbfb2ae0584c40b2", "filename": "library/std/src/os/android/net.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fandroid%2Fnet.rs?ref=8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "patch": "@@ -1,4 +1,9 @@\n //! Android-specific networking functionality.\n \n #![unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n+\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub use crate::os::net::linux_ext::addr::SocketAddrExt;\n+\n+#[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n pub use crate::os::net::linux_ext::tcp::TcpStreamExt;"}, {"sha": "94081c8dd31c50773dec4d5dc160c5c945170928", "filename": "library/std/src/os/linux/net.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fnet.rs?ref=8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "patch": "@@ -1,4 +1,9 @@\n //! Linux-specific networking functionality.\n \n #![unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n+\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub use crate::os::net::linux_ext::addr::SocketAddrExt;\n+\n+#[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n pub use crate::os::net::linux_ext::tcp::TcpStreamExt;"}, {"sha": "df3fc8e6a3b660cfa61f85ccc38fff7501a95f9c", "filename": "library/std/src/os/net/linux_ext/addr.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs?ref=8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "patch": "@@ -0,0 +1,64 @@\n+//! Linux and Android-specific extensions to socket addresses.\n+\n+use crate::os::unix::net::SocketAddr;\n+use crate::sealed::Sealed;\n+\n+/// Platform-specific extensions to [`SocketAddr`].\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub trait SocketAddrExt: Sealed {\n+    /// Creates a Unix socket address in the abstract namespace.\n+    ///\n+    /// The abstract namespace is a Linux-specific extension that allows Unix\n+    /// sockets to be bound without creating an entry in the filesystem.\n+    /// Abstract sockets are unaffected by filesystem layout or permissions,\n+    /// and no cleanup is necessary when the socket is closed.\n+    ///\n+    /// An abstract socket address name may contain any bytes, including zero.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns an error if the name is longer than `SUN_LEN - 1`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    /// use std::os::linux::net::SocketAddrExt;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_name(b\"hidden\")?;\n+    ///     let listener = match UnixListener::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {err:?}\");\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    fn from_abstract_name<N>(name: &N) -> crate::io::Result<SocketAddr>\n+    where\n+        N: AsRef<[u8]>;\n+\n+    /// Returns the contents of this address if it is in the abstract namespace.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    /// use std::os::linux::net::SocketAddrExt;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let name = b\"hidden\";\n+    ///     let name_addr = SocketAddr::from_abstract_name(name)?;\n+    ///     let socket = UnixListener::bind_addr(&name_addr)?;\n+    ///     let local_addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(local_addr.as_abstract_name(), Some(&name[..]));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    fn as_abstract_name(&self) -> Option<&[u8]>;\n+}"}, {"sha": "318ebacfd7a08d774d6e2a01f86807df45fde3de", "filename": "library/std/src/os/net/linux_ext/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Fmod.rs?ref=8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "patch": "@@ -2,6 +2,9 @@\n \n #![doc(cfg(any(target_os = \"linux\", target_os = \"android\")))]\n \n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+pub(crate) mod addr;\n+\n #[unstable(feature = \"tcp_quickack\", issue = \"96256\")]\n pub(crate) mod tcp;\n "}, {"sha": "81ac829d21bc81164006a02f55a81a32b0ad35c7", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 25, "deletions": 68, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "patch": "@@ -1,6 +1,9 @@\n use crate::ffi::OsStr;\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\"))]\n+use crate::os::net::linux_ext;\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::Path;\n+use crate::sealed::Sealed;\n use crate::sys::cvt;\n use crate::{fmt, io, mem, ptr};\n \n@@ -224,31 +227,6 @@ impl SocketAddr {\n         if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n     }\n \n-    /// Returns the contents of this address if it is an abstract namespace\n-    /// without the leading null byte.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_abstract)]\n-    /// use std::os::unix::net::{UnixListener, SocketAddr};\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let namespace = b\"hidden\";\n-    ///     let namespace_addr = SocketAddr::from_abstract_namespace(&namespace[..])?;\n-    ///     let socket = UnixListener::bind_addr(&namespace_addr)?;\n-    ///     let local_addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(local_addr.as_abstract_namespace(), Some(&namespace[..]));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n-    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n-    pub fn as_abstract_namespace(&self) -> Option<&[u8]> {\n-        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n-    }\n-\n     fn address(&self) -> AddressKind<'_> {\n         let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n@@ -265,62 +243,41 @@ impl SocketAddr {\n             AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n         }\n     }\n+}\n \n-    /// Creates an abstract domain socket address from a namespace\n-    ///\n-    /// An abstract address does not create a file unlike traditional path-based\n-    /// Unix sockets. The advantage of this is that the address will disappear when\n-    /// the socket bound to it is closed, so no filesystem clean up is required.\n-    ///\n-    /// The leading null byte for the abstract namespace is automatically added.\n-    ///\n-    /// This is a Linux-specific extension. See more at [`unix(7)`].\n-    ///\n-    /// [`unix(7)`]: https://man7.org/linux/man-pages/man7/unix.7.html\n-    ///\n-    /// # Errors\n-    ///\n-    /// This will return an error if the given namespace is too long\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_abstract)]\n-    /// use std::os::unix::net::{UnixListener, SocketAddr};\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?;\n-    ///     let listener = match UnixListener::bind_addr(&addr) {\n-    ///         Ok(sock) => sock,\n-    ///         Err(err) => {\n-    ///             println!(\"Couldn't bind: {err:?}\");\n-    ///             return Err(err);\n-    ///         }\n-    ///     };\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n-    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n-    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n-    pub fn from_abstract_namespace(namespace: &[u8]) -> io::Result<SocketAddr> {\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+impl Sealed for SocketAddr {}\n+\n+#[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\"))]\n+#[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+impl linux_ext::addr::SocketAddrExt for SocketAddr {\n+    fn as_abstract_name(&self) -> Option<&[u8]> {\n+        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n+    }\n+\n+    fn from_abstract_name<N>(name: &N) -> crate::io::Result<Self>\n+    where\n+        N: AsRef<[u8]>,\n+    {\n+        let name = name.as_ref();\n         unsafe {\n             let mut addr: libc::sockaddr_un = mem::zeroed();\n             addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n \n-            if namespace.len() + 1 > addr.sun_path.len() {\n+            if name.len() + 1 > addr.sun_path.len() {\n                 return Err(io::const_io_error!(\n                     io::ErrorKind::InvalidInput,\n-                    \"namespace must be shorter than SUN_LEN\",\n+                    \"abstract socket name must be shorter than SUN_LEN\",\n                 ));\n             }\n \n             crate::ptr::copy_nonoverlapping(\n-                namespace.as_ptr(),\n+                name.as_ptr(),\n                 addr.sun_path.as_mut_ptr().add(1) as *mut u8,\n-                namespace.len(),\n+                name.len(),\n             );\n-            let len = (sun_path_offset(&addr) + 1 + namespace.len()) as libc::socklen_t;\n+            let len = (sun_path_offset(&addr) + 1 + name.len()) as libc::socklen_t;\n             SocketAddr::from_parts(addr, len)\n         }\n     }"}, {"sha": "37fcfa8446b0e00ebcb8b6a530bce8f1b854107f", "filename": "library/std/src/os/unix/net/tests.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1e6eba343452ac48412f11d57aa7d206c8c3dd/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs?ref=8f1e6eba343452ac48412f11d57aa7d206c8c3dd", "patch": "@@ -7,6 +7,12 @@ use crate::sys_common::io::test::tmpdir;\n use crate::thread;\n use crate::time::Duration;\n \n+#[cfg(target_os = \"android\")]\n+use crate::os::android::net::SocketAddrExt;\n+\n+#[cfg(target_os = \"linux\")]\n+use crate::os::linux::net::SocketAddrExt;\n+\n macro_rules! or_panic {\n     ($e:expr) => {\n         match $e {\n@@ -404,7 +410,7 @@ fn test_abstract_stream_connect() {\n     let msg1 = b\"hello\";\n     let msg2 = b\"world\";\n \n-    let socket_addr = or_panic!(SocketAddr::from_abstract_namespace(b\"namespace\"));\n+    let socket_addr = or_panic!(SocketAddr::from_abstract_name(b\"name\"));\n     let listener = or_panic!(UnixListener::bind_addr(&socket_addr));\n \n     let thread = thread::spawn(move || {\n@@ -418,7 +424,7 @@ fn test_abstract_stream_connect() {\n     let mut stream = or_panic!(UnixStream::connect_addr(&socket_addr));\n \n     let peer = or_panic!(stream.peer_addr());\n-    assert_eq!(peer.as_abstract_namespace().unwrap(), b\"namespace\");\n+    assert_eq!(peer.as_abstract_name().unwrap(), b\"name\");\n \n     or_panic!(stream.write_all(msg1));\n     let mut buf = vec![];\n@@ -432,7 +438,7 @@ fn test_abstract_stream_connect() {\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_stream_iter() {\n-    let addr = or_panic!(SocketAddr::from_abstract_namespace(b\"hidden\"));\n+    let addr = or_panic!(SocketAddr::from_abstract_name(b\"hidden\"));\n     let listener = or_panic!(UnixListener::bind_addr(&addr));\n \n     let thread = thread::spawn(move || {\n@@ -454,13 +460,13 @@ fn test_abstract_stream_iter() {\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_datagram_bind_send_to_addr() {\n-    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns1\"));\n+    let addr1 = or_panic!(SocketAddr::from_abstract_name(b\"ns1\"));\n     let sock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n \n     let local = or_panic!(sock1.local_addr());\n-    assert_eq!(local.as_abstract_namespace().unwrap(), b\"ns1\");\n+    assert_eq!(local.as_abstract_name().unwrap(), b\"ns1\");\n \n-    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns2\"));\n+    let addr2 = or_panic!(SocketAddr::from_abstract_name(b\"ns2\"));\n     let sock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n \n     let msg = b\"hello world\";\n@@ -469,13 +475,13 @@ fn test_abstract_datagram_bind_send_to_addr() {\n     let (len, addr) = or_panic!(sock2.recv_from(&mut buf));\n     assert_eq!(msg, &buf[..]);\n     assert_eq!(len, 11);\n-    assert_eq!(addr.as_abstract_namespace().unwrap(), b\"ns1\");\n+    assert_eq!(addr.as_abstract_name().unwrap(), b\"ns1\");\n }\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n fn test_abstract_datagram_connect_addr() {\n-    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns3\"));\n+    let addr1 = or_panic!(SocketAddr::from_abstract_name(b\"ns3\"));\n     let bsock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n \n     let sock = or_panic!(UnixDatagram::unbound());\n@@ -489,7 +495,7 @@ fn test_abstract_datagram_connect_addr() {\n     assert_eq!(addr.is_unnamed(), true);\n     assert_eq!(msg, &buf[..]);\n \n-    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns4\"));\n+    let addr2 = or_panic!(SocketAddr::from_abstract_name(b\"ns4\"));\n     let bsock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n \n     or_panic!(sock.connect_addr(&addr2));\n@@ -499,8 +505,8 @@ fn test_abstract_datagram_connect_addr() {\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n-fn test_abstract_namespace_too_long() {\n-    match SocketAddr::from_abstract_namespace(\n+fn test_abstract_name_too_long() {\n+    match SocketAddr::from_abstract_name(\n         b\"abcdefghijklmnopqrstuvwxyzabcdefghijklmn\\\n         opqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghi\\\n         jklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\",\n@@ -513,11 +519,11 @@ fn test_abstract_namespace_too_long() {\n \n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n #[test]\n-fn test_abstract_namespace_no_pathname_and_not_unnamed() {\n-    let namespace = b\"local\";\n-    let addr = or_panic!(SocketAddr::from_abstract_namespace(&namespace[..]));\n+fn test_abstract_no_pathname_and_not_unnamed() {\n+    let name = b\"local\";\n+    let addr = or_panic!(SocketAddr::from_abstract_name(name));\n     assert_eq!(addr.as_pathname(), None);\n-    assert_eq!(addr.as_abstract_namespace(), Some(&namespace[..]));\n+    assert_eq!(addr.as_abstract_name(), Some(&name[..]));\n     assert_eq!(addr.is_unnamed(), false);\n }\n "}]}