{"sha": "757d7ba9c9e66320f8ff22d435ad30d6048585e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1N2Q3YmE5YzllNjYzMjBmOGZmMjJkNDM1YWQzMGQ2MDQ4NTg1ZTE=", "commit": {"author": {"name": "Georg Semmler", "email": "georg_semmler_05@web.de", "date": "2018-11-20T22:37:19Z"}, "committer": {"name": "Georg Semmler", "email": "georg_semmler_05@web.de", "date": "2019-01-03T21:26:40Z"}, "message": "Implement the re-rebalance coherence rfc", "tree": {"sha": "7425b787aa4e51388898e641f4b3cde2bd08ec4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7425b787aa4e51388898e641f4b3cde2bd08ec4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/757d7ba9c9e66320f8ff22d435ad30d6048585e1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEt/EOFp+yWvA8Dk28qHvO5SBc5IkFAlwufhAACgkQqHvO5SBc\n5In5JAf/Z38Vd5MijDC/SOhiu35vYTIJu4VKCxTjFOvpc0rXYiovk1xqaf17URGr\nC9aWSiLkuMQXck1ctJDzI8I18FHEBCly7FAhL7f2ZHDBA6oeEI8o4ZL+jv7SK0P2\n3b/b5u3sBGkSCRQJwjTumyTqz0WgV3eXtnpUIJY8NWu5EiCKSWcSd3YkHPmInixx\n7s+KgxmfaH7gNgGUnHN5Wl5EnFdH72cFfWbFktzlKuLkeeHEoFqNsqPVrEFL6aiv\nrSTCCI401X1O07KL0wrf5qnoUm0k2Yt7+DIkczVtyux6xfhBsupcfjDrq7t3/N0b\ngUS0Oo+q2PF2tN85k09shYFf5WAKww==\n=+S+K\n-----END PGP SIGNATURE-----", "payload": "tree 7425b787aa4e51388898e641f4b3cde2bd08ec4b\nparent c0bbc3927e28c22edefe6a1353b5ecc95ea9a104\nauthor Georg Semmler <georg_semmler_05@web.de> 1542753439 +0100\ncommitter Georg Semmler <georg_semmler_05@web.de> 1546550800 +0100\n\nImplement the re-rebalance coherence rfc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/757d7ba9c9e66320f8ff22d435ad30d6048585e1", "html_url": "https://github.com/rust-lang/rust/commit/757d7ba9c9e66320f8ff22d435ad30d6048585e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/757d7ba9c9e66320f8ff22d435ad30d6048585e1/comments", "author": {"login": "weiznich", "id": 1674512, "node_id": "MDQ6VXNlcjE2NzQ1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1674512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weiznich", "html_url": "https://github.com/weiznich", "followers_url": "https://api.github.com/users/weiznich/followers", "following_url": "https://api.github.com/users/weiznich/following{/other_user}", "gists_url": "https://api.github.com/users/weiznich/gists{/gist_id}", "starred_url": "https://api.github.com/users/weiznich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weiznich/subscriptions", "organizations_url": "https://api.github.com/users/weiznich/orgs", "repos_url": "https://api.github.com/users/weiznich/repos", "events_url": "https://api.github.com/users/weiznich/events{/privacy}", "received_events_url": "https://api.github.com/users/weiznich/received_events", "type": "User", "site_admin": false}, "committer": {"login": "weiznich", "id": 1674512, "node_id": "MDQ6VXNlcjE2NzQ1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1674512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weiznich", "html_url": "https://github.com/weiznich", "followers_url": "https://api.github.com/users/weiznich/followers", "following_url": "https://api.github.com/users/weiznich/following{/other_user}", "gists_url": "https://api.github.com/users/weiznich/gists{/gist_id}", "starred_url": "https://api.github.com/users/weiznich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weiznich/subscriptions", "organizations_url": "https://api.github.com/users/weiznich/orgs", "repos_url": "https://api.github.com/users/weiznich/repos", "events_url": "https://api.github.com/users/weiznich/events{/privacy}", "received_events_url": "https://api.github.com/users/weiznich/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104", "html_url": "https://github.com/rust-lang/rust/commit/c0bbc3927e28c22edefe6a1353b5ecc95ea9a104"}], "stats": {"total": 128, "additions": 98, "deletions": 30}, "files": [{"sha": "90e09763019ae4394204cd081a0bcf763a50f4f2", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 95, "deletions": 30, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/757d7ba9c9e66320f8ff22d435ad30d6048585e1/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757d7ba9c9e66320f8ff22d435ad30d6048585e1/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=757d7ba9c9e66320f8ff22d435ad30d6048585e1", "patch": "@@ -371,43 +371,108 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt<'_, '_, '_>,\n              trait_ref);\n     }\n \n-    // First, create an ordered iterator over all the type parameters to the trait, with the self\n-    // type appearing first.\n-    // Find the first input type that either references a type parameter OR\n-    // some local type.\n-    for input_ty in trait_ref.input_types() {\n-        if ty_is_local(tcx, input_ty, in_crate) {\n-            debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n-\n-            // First local input type. Check that there are no\n-            // uncovered type parameters.\n-            let uncovered_tys = uncovered_tys(tcx, input_ty, in_crate);\n-            for uncovered_ty in uncovered_tys {\n-                if let Some(param) = uncovered_ty.walk()\n-                    .find(|t| is_possibly_remote_type(t, in_crate))\n-                {\n-                    debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n-                    return Err(OrphanCheckErr::UncoveredTy(param));\n+    if tcx.features().re_rebalance_coherence {\n+        // Given impl<P1..=Pn> Trait<T1..=Tn> for T0, an impl is valid only\n+        // if at least one of the following is true:\n+        //\n+        // - Trait is a local trait\n+        // (already checked in orphan_check prior to calling this function)\n+        // - All of\n+        //     - At least one of the types T0..=Tn must be a local type.\n+        //      Let Ti be the first such type.\n+        //     - No uncovered type parameters P1..=Pn may appear in T0..Ti (excluding Ti)\n+        //\n+        for input_ty in trait_ref.input_types() {\n+            debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n+            if ty_is_local(tcx, input_ty, in_crate) {\n+                debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n+                return Ok(());\n+            } else if is_uncovered_ty(input_ty) {\n+                debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n+                return Err(OrphanCheckErr::UncoveredTy(input_ty))\n+            }\n+        }\n+        // If we exit above loop, never found a local type.\n+        debug!(\"orphan_check_trait_ref: no local type\");\n+        Err(OrphanCheckErr::NoLocalInputType)\n+    } else {\n+        // First, create an ordered iterator over all the type parameters to the trait, with the self\n+        // type appearing first.\n+        // Find the first input type that either references a type parameter OR\n+        // some local type.\n+        for input_ty in trait_ref.input_types() {\n+            if ty_is_local(tcx, input_ty, in_crate) {\n+                debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n+\n+                // First local input type. Check that there are no\n+                // uncovered type parameters.\n+                let uncovered_tys = uncovered_tys(tcx, input_ty, in_crate);\n+                for uncovered_ty in uncovered_tys {\n+                    if let Some(param) = uncovered_ty.walk()\n+                        .find(|t| is_possibly_remote_type(t, in_crate))\n+                    {\n+                        debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n+                        return Err(OrphanCheckErr::UncoveredTy(param));\n+                    }\n                 }\n+\n+                // OK, found local type, all prior types upheld invariant.\n+                return Ok(());\n             }\n \n-            // OK, found local type, all prior types upheld invariant.\n-            return Ok(());\n+            // Otherwise, enforce invariant that there are no type\n+            // parameters reachable.\n+            if let Some(param) = input_ty.walk()\n+                .find(|t| is_possibly_remote_type(t, in_crate))\n+            {\n+                debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n+                return Err(OrphanCheckErr::UncoveredTy(param));\n+            }\n+        }\n+        // If we exit above loop, never found a local type.\n+        debug!(\"orphan_check_trait_ref: no local type\");\n+        Err(OrphanCheckErr::NoLocalInputType)\n+    }\n+}\n+\n+fn is_uncovered_ty(ty: Ty<'_>) -> bool {\n+    match ty.sty {\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(..) |\n+        ty::Uint(..) |\n+        ty::Float(..) |\n+        ty::Str |\n+        ty::FnDef(..) |\n+        ty::FnPtr(_) |\n+        ty::Array(..) |\n+        ty::Slice(..) |\n+        ty::RawPtr(..) |\n+        ty::Ref(..) |\n+        ty::Never |\n+        ty::Tuple(..) |\n+        ty::Bound(..) |\n+        ty::Infer(..) |\n+        ty::Adt(..) |\n+        ty::Foreign(..) |\n+        ty::Dynamic(..) |\n+        ty::Error |\n+        ty::Projection(..) => {\n+            false\n+        }\n+\n+        ty::Param(..)  => {\n+            true\n         }\n \n-        // Otherwise, enforce invariant that there are no type\n-        // parameters reachable.\n-        if let Some(param) = input_ty.walk()\n-            .find(|t| is_possibly_remote_type(t, in_crate))\n-        {\n-            debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n-            return Err(OrphanCheckErr::UncoveredTy(param));\n+        ty::UnnormalizedProjection(..) |\n+        ty::Closure(..) |\n+        ty::Generator(..) |\n+        ty::GeneratorWitness(..) |\n+        ty::Opaque(..) => {\n+            bug!(\"is_uncovered_ty invoked on unexpected type: {:?}\", ty)\n         }\n     }\n-\n-    // If we exit above loop, never found a local type.\n-    debug!(\"orphan_check_trait_ref: no local type\");\n-    return Err(OrphanCheckErr::NoLocalInputType);\n }\n \n fn uncovered_tys<'tcx>(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>, in_crate: InCrate)"}, {"sha": "8362c86f8bab9c7b16119d9adf98c2b4cb8dda02", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/757d7ba9c9e66320f8ff22d435ad30d6048585e1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757d7ba9c9e66320f8ff22d435ad30d6048585e1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=757d7ba9c9e66320f8ff22d435ad30d6048585e1", "patch": "@@ -479,6 +479,9 @@ declare_features! (\n \n     // Allows paths to enum variants on type aliases.\n     (active, type_alias_enum_variants, \"1.31.0\", Some(49683), None),\n+\n+    // Re-Rebalance coherence\n+    (active, re_rebalance_coherence, \"1.32.0\", Some(55437), None),\n );\n \n declare_features! ("}]}