{"sha": "5bc328fdeff50b742a8136d0633924514d4d76b8", "node_id": "C_kwDOAAsO6NoAKDViYzMyOGZkZWZmNTBiNzQyYTgxMzZkMDYzMzkyNDUxNGQ0ZDc2Yjg", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-02-03T11:27:51Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-02-05T00:44:51Z"}, "message": "Allow canonicalizing the `array::map` loop in trusted cases", "tree": {"sha": "09d950684bda2a834a15b40d275f11752dcb6743", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09d950684bda2a834a15b40d275f11752dcb6743"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc328fdeff50b742a8136d0633924514d4d76b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc328fdeff50b742a8136d0633924514d4d76b8", "html_url": "https://github.com/rust-lang/rust/commit/5bc328fdeff50b742a8136d0633924514d4d76b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc328fdeff50b742a8136d0633924514d4d76b8/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52df0558ea349fa65036e61f0a647ea8072ec3f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/52df0558ea349fa65036e61f0a647ea8072ec3f5", "html_url": "https://github.com/rust-lang/rust/commit/52df0558ea349fa65036e61f0a647ea8072ec3f5"}], "stats": {"total": 379, "additions": 237, "deletions": 142}, "files": [{"sha": "5fadf907b6219cdf25be26364fc41e1c86b70f84", "filename": "library/core/src/array/drain.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -1,11 +1,21 @@\n-use crate::iter::TrustedLen;\n+use crate::iter::{TrustedLen, UncheckedIterator};\n use crate::mem::ManuallyDrop;\n use crate::ptr::drop_in_place;\n use crate::slice;\n \n-// INVARIANT: It's ok to drop the remainder of the inner iterator.\n-pub(crate) struct Drain<'a, T>(slice::IterMut<'a, T>);\n-\n+/// A situationally-optimized version of `array.into_iter().for_each(func)`.\n+///\n+/// [`crate::array::IntoIter`]s are great when you need an owned iterator, but\n+/// storing the entire array *inside* the iterator like that can sometimes\n+/// pessimize code.  Notable, it can be more bytes than you really want to move\n+/// around, and because the array accesses index into it SRoA has a harder time\n+/// optimizing away the type than it does iterators that just hold a couple pointers.\n+///\n+/// Thus this function exists, which gives a way to get *moved* access to the\n+/// elements of an array using a small iterator -- no bigger than a slice iterator.\n+///\n+/// The function-taking-a-closure structure makes it safe, as it keeps callers\n+/// from looking at already-dropped elements.\n pub(crate) fn drain_array_with<T, R, const N: usize>(\n     array: [T; N],\n     func: impl for<'a> FnOnce(Drain<'a, T>) -> R,\n@@ -16,6 +26,11 @@ pub(crate) fn drain_array_with<T, R, const N: usize>(\n     func(drain)\n }\n \n+/// See [`drain_array_with`] -- this is `pub(crate)` only so it's allowed to be\n+/// mentioned in the signature of that method.  (Otherwise it hits `E0446`.)\n+// INVARIANT: It's ok to drop the remainder of the inner iterator.\n+pub(crate) struct Drain<'a, T>(slice::IterMut<'a, T>);\n+\n impl<T> Drop for Drain<'_, T> {\n     fn drop(&mut self) {\n         // SAFETY: By the type invariant, we're allowed to drop all these.\n@@ -49,3 +64,13 @@ impl<T> ExactSizeIterator for Drain<'_, T> {\n \n // SAFETY: This is a 1:1 wrapper for a slice iterator, which is also `TrustedLen`.\n unsafe impl<T> TrustedLen for Drain<'_, T> {}\n+\n+impl<T> UncheckedIterator for Drain<'_, T> {\n+    unsafe fn next_unchecked(&mut self) -> T {\n+        // SAFETY: `Drain` is 1:1 with the inner iterator, so if the caller promised\n+        // that there's an element left, the inner iterator has one too.\n+        let p: *const T = unsafe { self.0.next_unchecked() };\n+        // SAFETY: The iterator was already advanced, so we won't drop this later.\n+        unsafe { p.read() }\n+    }\n+}"}, {"sha": "ae9f6e70f43c6472e1ff64cea79097f818aa405c", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 101, "deletions": 123, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -10,7 +10,7 @@ use crate::convert::{Infallible, TryFrom};\n use crate::error::Error;\n use crate::fmt;\n use crate::hash::{self, Hash};\n-use crate::iter::TrustedLen;\n+use crate::iter::UncheckedIterator;\n use crate::mem::{self, MaybeUninit};\n use crate::ops::{\n     ChangeOutputType, ControlFlow, FromResidual, Index, IndexMut, NeverShortCircuit, Residual, Try,\n@@ -55,16 +55,11 @@ pub use iter::IntoIter;\n /// ```\n #[inline]\n #[stable(feature = \"array_from_fn\", since = \"1.63.0\")]\n-pub fn from_fn<T, const N: usize, F>(mut cb: F) -> [T; N]\n+pub fn from_fn<T, const N: usize, F>(cb: F) -> [T; N]\n where\n     F: FnMut(usize) -> T,\n {\n-    let mut idx = 0;\n-    [(); N].map(|_| {\n-        let res = cb(idx);\n-        idx += 1;\n-        res\n-    })\n+    try_from_fn(NeverShortCircuit::wrap_mut_1(cb)).0\n }\n \n /// Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.\n@@ -104,9 +99,14 @@ where\n     R: Try,\n     R::Residual: Residual<[R::Output; N]>,\n {\n-    // SAFETY: we know for certain that this iterator will yield exactly `N`\n-    // items.\n-    unsafe { try_collect_into_array_unchecked(&mut (0..N).map(cb)) }\n+    let mut array = MaybeUninit::uninit_array::<N>();\n+    match try_from_fn_erased(&mut array, cb) {\n+        ControlFlow::Break(r) => FromResidual::from_residual(r),\n+        ControlFlow::Continue(()) => {\n+            // SAFETY: All elements of the array were populated.\n+            try { unsafe { MaybeUninit::array_assume_init(array) } }\n+        }\n+    }\n }\n \n /// Converts a reference to `T` into a reference to an array of length 1 (without copying).\n@@ -430,9 +430,7 @@ trait SpecArrayClone: Clone {\n impl<T: Clone> SpecArrayClone for T {\n     #[inline]\n     default fn clone<const N: usize>(array: &[T; N]) -> [T; N] {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut array.iter().cloned()) }\n+        from_trusted_iterator(array.iter().cloned())\n     }\n }\n \n@@ -516,12 +514,7 @@ impl<T, const N: usize> [T; N] {\n     where\n         F: FnMut(T) -> U,\n     {\n-        drain_array_with(self, |iter| {\n-            let mut iter = iter.map(f);\n-            // SAFETY: we know for certain that this iterator will yield exactly `N`\n-            // items.\n-            unsafe { collect_into_array_unchecked(&mut iter) }\n-        })\n+        self.try_map(NeverShortCircuit::wrap_mut_1(f)).0\n     }\n \n     /// A fallible function `f` applied to each element on array `self` in order to\n@@ -558,12 +551,7 @@ impl<T, const N: usize> [T; N] {\n         R: Try,\n         R::Residual: Residual<[R::Output; N]>,\n     {\n-        drain_array_with(self, |iter| {\n-            let mut iter = iter.map(f);\n-            // SAFETY: we know for certain that this iterator will yield exactly `N`\n-            // items.\n-            unsafe { try_collect_into_array_unchecked(&mut iter) }\n-        })\n+        drain_array_with(self, |iter| try_from_trusted_iterator(iter.map(f)))\n     }\n \n     /// 'Zips up' two arrays into a single array of pairs.\n@@ -585,12 +573,7 @@ impl<T, const N: usize> [T; N] {\n     #[unstable(feature = \"array_zip\", issue = \"80094\")]\n     pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n         drain_array_with(self, |lhs| {\n-            drain_array_with(rhs, |rhs| {\n-                let mut iter = crate::iter::zip(lhs, rhs);\n-                // SAFETY: we know for certain that this iterator will yield exactly `N`\n-                // items.\n-                unsafe { collect_into_array_unchecked(&mut iter) }\n-            })\n+            drain_array_with(rhs, |rhs| from_trusted_iterator(crate::iter::zip(lhs, rhs)))\n         })\n     }\n \n@@ -638,9 +621,7 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_methods\", issue = \"76118\")]\n     pub fn each_ref(&self) -> [&T; N] {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut self.iter()) }\n+        from_trusted_iterator(self.iter())\n     }\n \n     /// Borrows each element mutably and returns an array of mutable references\n@@ -660,9 +641,7 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_methods\", issue = \"76118\")]\n     pub fn each_mut(&mut self) -> [&mut T; N] {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut self.iter_mut()) }\n+        from_trusted_iterator(self.iter_mut())\n     }\n \n     /// Divides one array reference into two at an index.\n@@ -822,99 +801,71 @@ impl<T, const N: usize> [T; N] {\n     }\n }\n \n-/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n-/// yields fewer than `N` items, this function exhibits undefined behavior.\n+/// Populate an array from the first `N` elements of `iter`\n ///\n-/// # Safety\n+/// # Panics\n ///\n-/// It is up to the caller to guarantee that `iter` yields at least `N` items.\n-/// Violating this condition causes undefined behavior.\n-unsafe fn try_collect_into_array_unchecked<I, T, R, const N: usize>(\n-    iter: &mut I,\n-) -> ChangeOutputType<I::Item, [T; N]>\n-where\n-    // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n-    // internal function, so feel free to remove if this bound turns out to be a\n-    // bad idea. In that case, remember to also remove the lower bound\n-    // `debug_assert!` below!\n-    I: Iterator + TrustedLen,\n-    I::Item: Try<Output = T, Residual = R>,\n-    R: Residual<[T; N]>,\n-{\n-    debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n-    debug_assert!(N <= iter.size_hint().0);\n-\n-    let mut array = MaybeUninit::uninit_array::<N>();\n-    let cf = try_collect_into_array_erased(iter, &mut array);\n-    match cf {\n-        ControlFlow::Break(r) => FromResidual::from_residual(r),\n-        ControlFlow::Continue(initialized) => {\n-            debug_assert_eq!(initialized, N);\n-            // SAFETY: because of our function contract, all the elements\n-            // must have been initialized.\n-            let output = unsafe { MaybeUninit::array_assume_init(array) };\n-            Try::from_output(output)\n-        }\n-    }\n+/// If the iterator doesn't actually have enough items.\n+///\n+/// By depending on `TrustedLen`, however, we can do that check up-front (where\n+/// it easily optimizes away) so it doesn't impact the loop that fills the array.\n+#[inline]\n+fn from_trusted_iterator<T, const N: usize>(iter: impl UncheckedIterator<Item = T>) -> [T; N] {\n+    try_from_trusted_iterator(iter.map(NeverShortCircuit)).0\n }\n \n-/// Infallible version of [`try_collect_into_array_unchecked`].\n-unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n+#[inline]\n+fn try_from_trusted_iterator<T, R, const N: usize>(\n+    iter: impl UncheckedIterator<Item = R>,\n+) -> ChangeOutputType<R, [T; N]>\n where\n-    I: Iterator + TrustedLen,\n+    R: Try<Output = T>,\n+    R::Residual: Residual<[T; N]>,\n {\n-    let mut map = iter.map(NeverShortCircuit);\n-\n-    // SAFETY: The same safety considerations w.r.t. the iterator length\n-    // apply for `try_collect_into_array_unchecked` as for\n-    // `collect_into_array_unchecked`\n-    match unsafe { try_collect_into_array_unchecked(&mut map) } {\n-        NeverShortCircuit(array) => array,\n+    assert!(iter.size_hint().0 >= N);\n+    fn next<T>(mut iter: impl UncheckedIterator<Item = T>) -> impl FnMut(usize) -> T {\n+        move |_| {\n+            // SAFETY: We know that `from_fn` will call this at most N times,\n+            // and we checked to ensure that we have at least that many items.\n+            unsafe { iter.next_unchecked() }\n+        }\n     }\n+\n+    try_from_fn(next(iter))\n }\n \n-/// Rather than *returning* the array, this fills in a passed-in buffer.\n-/// If any of the iterator elements short-circuit, it drops everything in the\n-/// buffer and return the error.  Otherwise it returns the number of items\n-/// which were initialized in the buffer.\n+/// Version of [`try_from_fn`] using a passed-in slice in order to avoid\n+/// needing to monomorphize for every array length.\n ///\n-/// (The caller is responsible for dropping those items on success, but not\n-/// doing that is just a leak, not UB, so this function is itself safe.)\n+/// This takes a generator rather than an iterator so that *at the type level*\n+/// it never needs to worry about running out of items.  When combined with\n+/// an infallible `Try` type, that means the loop canonicalizes easily, allowing\n+/// it to optimize well.\n ///\n-/// This means less monomorphization, but more importantly it means that the\n-/// returned array doesn't need to be copied into the `Result`, since returning\n-/// the result seemed (2023-01) to cause in an extra `N + 1`-length `alloca`\n-/// even if it's always `unwrap_unchecked` later.\n+/// It would be *possible* to unify this and [`iter_next_chunk_erased`] into one\n+/// function that does the union of both things, but last time it was that way\n+/// it resulted in poor codegen from the \"are there enough source items?\" checks\n+/// not optimizing away.  So if you give it a shot, make sure to watch what\n+/// happens in the codegen tests.\n #[inline]\n-fn try_collect_into_array_erased<I, T, R>(\n-    iter: &mut I,\n+fn try_from_fn_erased<T, R>(\n     buffer: &mut [MaybeUninit<T>],\n-) -> ControlFlow<R, usize>\n+    mut generator: impl FnMut(usize) -> R,\n+) -> ControlFlow<R::Residual>\n where\n-    I: Iterator,\n-    I::Item: Try<Output = T, Residual = R>,\n+    R: Try<Output = T>,\n {\n-    let n = buffer.len();\n     let mut guard = Guard { array_mut: buffer, initialized: 0 };\n \n-    for _ in 0..n {\n-        match iter.next() {\n-            Some(item_rslt) => {\n-                let item = item_rslt.branch()?;\n+    while guard.initialized < guard.array_mut.len() {\n+        let item = generator(guard.initialized).branch()?;\n \n-                // SAFETY: `guard.initialized` starts at 0, which means push can be called\n-                // at most `n` times, which this loop does.\n-                unsafe {\n-                    guard.push_unchecked(item);\n-                }\n-            }\n-            None => break,\n-        }\n+        // SAFETY: The loop condition ensures we have space to push the item\n+        unsafe { guard.push_unchecked(item) };\n     }\n \n-    let initialized = guard.initialized;\n     mem::forget(guard);\n-    ControlFlow::Continue(initialized)\n+    ControlFlow::Continue(())\n }\n \n /// Panic guard for incremental initialization of arrays.\n@@ -928,7 +879,7 @@ where\n ///\n /// To minimize indirection fields are still pub but callers should at least use\n /// `push_unchecked` to signal that something unsafe is going on.\n-pub(crate) struct Guard<'a, T> {\n+struct Guard<'a, T> {\n     /// The array to be initialized.\n     pub array_mut: &'a mut [MaybeUninit<T>],\n     /// The number of items that have been initialized so far.\n@@ -960,7 +911,7 @@ impl<T> Drop for Guard<'_, T> {\n         // SAFETY: this slice will contain only initialized objects.\n         unsafe {\n             crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n-                &mut self.array_mut.get_unchecked_mut(..self.initialized),\n+                self.array_mut.get_unchecked_mut(..self.initialized),\n             ));\n         }\n     }\n@@ -982,17 +933,44 @@ impl<T> Drop for Guard<'_, T> {\n pub(crate) fn iter_next_chunk<T, const N: usize>(\n     iter: &mut impl Iterator<Item = T>,\n ) -> Result<[T; N], IntoIter<T, N>> {\n-    let mut map = iter.map(NeverShortCircuit);\n     let mut array = MaybeUninit::uninit_array::<N>();\n-    let ControlFlow::Continue(initialized) = try_collect_into_array_erased(&mut map, &mut array);\n-    if initialized == N {\n-        // SAFETY: All elements of the array were populated.\n-        let output = unsafe { MaybeUninit::array_assume_init(array) };\n-        Ok(output)\n-    } else {\n-        let alive = 0..initialized;\n-        // SAFETY: `array` was initialized with exactly `initialized`\n-        // number of elements.\n-        return Err(unsafe { IntoIter::new_unchecked(array, alive) });\n+    let r = iter_next_chunk_erased(&mut array, iter);\n+    match r {\n+        Ok(()) => {\n+            // SAFETY: All elements of `array` were populated.\n+            Ok(unsafe { MaybeUninit::array_assume_init(array) })\n+        }\n+        Err(initialized) => {\n+            // SAFETY: Only the first `initialized` elements were populated\n+            Err(unsafe { IntoIter::new_unchecked(array, 0..initialized) })\n+        }\n+    }\n+}\n+\n+/// Version of [`iter_next_chunk`] using a passed-in slice in order to avoid\n+/// needing to monomorphize for every array length.\n+///\n+/// Unfortunately this loop has two exit conditions, the buffer filling up\n+/// or the iterator running out of items, making it tend to optimize poorly.\n+#[inline]\n+fn iter_next_chunk_erased<T>(\n+    buffer: &mut [MaybeUninit<T>],\n+    iter: &mut impl Iterator<Item = T>,\n+) -> Result<(), usize> {\n+    let mut guard = Guard { array_mut: buffer, initialized: 0 };\n+    while guard.initialized < guard.array_mut.len() {\n+        let Some(item) = iter.next() else {\n+            // Unlike `try_from_fn_erased`, we want to keep the partial results,\n+            // so we need to defuse the guard instead of using `?`.\n+            let initialized = guard.initialized;\n+            mem::forget(guard);\n+            return Err(initialized)\n+        };\n+\n+        // SAFETY: The loop condition ensures we have space to push the item\n+        unsafe { guard.push_unchecked(item) };\n     }\n+\n+    mem::forget(guard);\n+    Ok(())\n }"}, {"sha": "13719c727e93f700d7cf754db55965cf6bfa76c0", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -1,6 +1,5 @@\n use crate::array;\n use crate::iter::{ByRefSized, FusedIterator, Iterator, TrustedRandomAccessNoCoerce};\n-use crate::mem::{self, MaybeUninit};\n use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n \n /// An iterator over `N` elements of the iterator at a time.\n@@ -212,19 +211,14 @@ where\n         let mut i = 0;\n         // Use a while loop because (0..len).step_by(N) doesn't optimize well.\n         while inner_len - i >= N {\n-            let mut chunk = MaybeUninit::uninit_array();\n-            let mut guard = array::Guard { array_mut: &mut chunk, initialized: 0 };\n-            while guard.initialized < N {\n+            let chunk = crate::array::from_fn(|local| {\n                 // SAFETY: The method consumes the iterator and the loop condition ensures that\n                 // all accesses are in bounds and only happen once.\n                 unsafe {\n-                    let idx = i + guard.initialized;\n-                    guard.push_unchecked(self.iter.__iterator_get_unchecked(idx));\n+                    let idx = i + local;\n+                    self.iter.__iterator_get_unchecked(idx)\n                 }\n-            }\n-            mem::forget(guard);\n-            // SAFETY: The loop above initialized all elements\n-            let chunk = unsafe { MaybeUninit::array_assume_init(chunk) };\n+            });\n             accum = f(accum, chunk);\n             i += N;\n         }"}, {"sha": "914ff86c1a95972dbe708215944a4c3831a31104", "filename": "library/core/src/iter/adapters/cloned.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -1,7 +1,7 @@\n use crate::iter::adapters::{\n     zip::try_get_unchecked, TrustedRandomAccess, TrustedRandomAccessNoCoerce,\n };\n-use crate::iter::{FusedIterator, TrustedLen};\n+use crate::iter::{FusedIterator, TrustedLen, UncheckedIterator};\n use crate::ops::Try;\n \n /// An iterator that clones the elements of an underlying iterator.\n@@ -140,3 +140,16 @@ where\n     T: Clone,\n {\n }\n+\n+impl<'a, I, T: 'a> UncheckedIterator for Cloned<I>\n+where\n+    I: UncheckedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    unsafe fn next_unchecked(&mut self) -> T {\n+        // SAFETY: `Cloned` is 1:1 with the inner iterator, so if the caller promised\n+        // that there's an element left, the inner iterator has one too.\n+        let item = unsafe { self.it.next_unchecked() };\n+        item.clone()\n+    }\n+}"}, {"sha": "31d02a4da6ea53ab9b11f4b54544bf866fcf128c", "filename": "library/core/src/iter/adapters/map.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -2,7 +2,7 @@ use crate::fmt;\n use crate::iter::adapters::{\n     zip::try_get_unchecked, SourceIter, TrustedRandomAccess, TrustedRandomAccessNoCoerce,\n };\n-use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen, UncheckedIterator};\n use crate::ops::Try;\n \n /// An iterator that maps the values of `iter` with `f`.\n@@ -187,6 +187,19 @@ where\n {\n }\n \n+impl<B, I, F> UncheckedIterator for Map<I, F>\n+where\n+    I: UncheckedIterator,\n+    F: FnMut(I::Item) -> B,\n+{\n+    unsafe fn next_unchecked(&mut self) -> B {\n+        // SAFETY: `Map` is 1:1 with the inner iterator, so if the caller promised\n+        // that there's an element left, the inner iterator has one too.\n+        let item = unsafe { self.iter.next_unchecked() };\n+        (self.f)(item)\n+    }\n+}\n+\n #[doc(hidden)]\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n unsafe impl<I, F> TrustedRandomAccess for Map<I, F> where I: TrustedRandomAccess {}"}, {"sha": "b6b0c90cb7d146a1a03a8d95a126718a57f5214c", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -1,7 +1,7 @@\n use crate::cmp;\n use crate::fmt::{self, Debug};\n use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n-use crate::iter::{InPlaceIterable, SourceIter, TrustedLen};\n+use crate::iter::{InPlaceIterable, SourceIter, TrustedLen, UncheckedIterator};\n \n /// An iterator that iterates two other iterators simultaneously.\n ///\n@@ -417,6 +417,13 @@ where\n {\n }\n \n+impl<A, B> UncheckedIterator for Zip<A, B>\n+where\n+    A: UncheckedIterator,\n+    B: UncheckedIterator,\n+{\n+}\n+\n // Arbitrarily selects the left side of the zip iteration as extractable \"source\"\n // it would require negative trait bounds to be able to try both\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]"}, {"sha": "156b925de773f177f192acf559098a4633efcf4b", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -450,6 +450,7 @@ pub use self::adapters::{\n pub use self::adapters::{Intersperse, IntersperseWith};\n \n pub(crate) use self::adapters::try_process;\n+pub(crate) use self::traits::UncheckedIterator;\n \n mod adapters;\n mod range;"}, {"sha": "41ea29e6a84d98f178fd59ca8e06bc5d95cac7c7", "filename": "library/core/src/iter/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -4,6 +4,7 @@ mod double_ended;\n mod exact_size;\n mod iterator;\n mod marker;\n+mod unchecked_iterator;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::{\n@@ -19,3 +20,5 @@ pub use self::{\n pub use self::marker::InPlaceIterable;\n #[unstable(feature = \"trusted_step\", issue = \"85731\")]\n pub use self::marker::TrustedStep;\n+\n+pub(crate) use self::unchecked_iterator::UncheckedIterator;"}, {"sha": "ae4bfcad4e68f8222878708f28b994b09a8fe5e7", "filename": "library/core/src/iter/traits/unchecked_iterator.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Funchecked_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Funchecked_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Funchecked_iterator.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -0,0 +1,36 @@\n+use crate::iter::TrustedLen;\n+\n+/// [`TrustedLen`] cannot have methods, so this allows augmenting it.\n+///\n+/// It currently requires `TrustedLen` because it's unclear whether it's\n+/// reasonably possible to depend on the `size_hint` of anything else.\n+pub(crate) trait UncheckedIterator: TrustedLen {\n+    /// Gets the next item from a non-empty iterator.\n+    ///\n+    /// Because there's always a value to return, that means it can return\n+    /// the `Item` type directly, without wrapping it in an `Option`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This can only be called if `size_hint().0 != 0`, guaranteeing that\n+    /// there's at least one item available.\n+    ///\n+    /// Otherwise (aka when `size_hint().1 == Some(0)`), this is UB.\n+    ///\n+    /// # Note to Implementers\n+    ///\n+    /// This has a default implementation using [`Option::unwrap_unchecked`].\n+    /// That's probably sufficient if your `next` *always* returns `Some`,\n+    /// such as for infinite iterators.  In more complicated situations, however,\n+    /// sometimes there can still be `insertvalue`/`assume`/`extractvalue`\n+    /// instructions remaining in the IR from the `Option` handling, at which\n+    /// point you might want to implement this manually instead.\n+    #[unstable(feature = \"trusted_len_next_unchecked\", issue = \"37572\")]\n+    #[inline]\n+    unsafe fn next_unchecked(&mut self) -> Self::Item {\n+        let opt = self.next();\n+        // SAFETY: The caller promised that we're not empty, and\n+        // `Self: TrustedLen` so we can actually trust the `size_hint`.\n+        unsafe { opt.unwrap_unchecked() }\n+    }\n+}"}, {"sha": "86aa1e4fd20ba48ce698ca58edcfe40daebb187b", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -379,6 +379,15 @@ pub(crate) type ChangeOutputType<T, V> = <<T as Try>::Residual as Residual<V>>::\n pub(crate) struct NeverShortCircuit<T>(pub T);\n \n impl<T> NeverShortCircuit<T> {\n+    /// Wraps a unary function to produce one that wraps the output into a `NeverShortCircuit`.\n+    ///\n+    /// This is useful for implementing infallible functions in terms of the `try_` ones,\n+    /// without accidentally capturing extra generic parameters in a closure.\n+    #[inline]\n+    pub fn wrap_mut_1<A>(mut f: impl FnMut(A) -> T) -> impl FnMut(A) -> NeverShortCircuit<T> {\n+        move |a| NeverShortCircuit(f(a))\n+    }\n+\n     #[inline]\n     pub fn wrap_mut_2<A, B>(\n         mut f: impl ~const FnMut(A, B) -> T,"}, {"sha": "c4317799bcc68958e8b7e4dc2409a4753cfaca1c", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -7,7 +7,9 @@ use crate::cmp;\n use crate::cmp::Ordering;\n use crate::fmt;\n use crate::intrinsics::assume;\n-use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n+use crate::iter::{\n+    FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce, UncheckedIterator,\n+};\n use crate::marker::{PhantomData, Send, Sized, Sync};\n use crate::mem::{self, SizedTypeProperties};\n use crate::num::NonZeroUsize;"}, {"sha": "89b92a7d5975fb2fe582bd4495881c5dca17c78c", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -384,6 +384,15 @@ macro_rules! iterator {\n \n         #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n         unsafe impl<T> TrustedLen for $name<'_, T> {}\n+\n+        impl<'a, T> UncheckedIterator for $name<'a, T> {\n+            unsafe fn next_unchecked(&mut self) -> $elem {\n+                // SAFETY: The caller promised there's at least one more item.\n+                unsafe {\n+                    next_unchecked!(self)\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "62566a9502d046a4bee0c58d71221203f3ef3107", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -582,6 +582,9 @@ fn test_next_chunk() {\n     assert_eq!(it.next_chunk().unwrap(), []);\n     assert_eq!(it.next_chunk().unwrap(), [4, 5, 6, 7, 8, 9]);\n     assert_eq!(it.next_chunk::<4>().unwrap_err().as_slice(), &[10, 11]);\n+\n+    let mut it = std::iter::repeat_with(|| panic!());\n+    assert_eq!(it.next_chunk::<0>().unwrap(), []);\n }\n \n // just tests by whether or not this compiles"}, {"sha": "9298e89e397d0ccd91a41fcfdf37ea0698d69573", "filename": "tests/codegen/array-map.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bc328fdeff50b742a8136d0633924514d4d76b8/tests%2Fcodegen%2Farray-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc328fdeff50b742a8136d0633924514d4d76b8/tests%2Fcodegen%2Farray-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-map.rs?ref=5bc328fdeff50b742a8136d0633924514d4d76b8", "patch": "@@ -43,5 +43,7 @@ pub fn long_integer_map(x: [u32; 64]) -> [u32; 64] {\n     // CHECK-NEXT: alloca [64 x i32]\n     // CHECK-NEXT: alloca %\"core::mem::manually_drop::ManuallyDrop<[u32; 64]>\"\n     // CHECK-NOT: alloca\n-    x.map(|x| 2 * x + 1)\n+    // CHECK: mul <{{[0-9]+}} x i32>\n+    // CHECK: add <{{[0-9]+}} x i32>\n+    x.map(|x| 13 * x + 7)\n }"}]}