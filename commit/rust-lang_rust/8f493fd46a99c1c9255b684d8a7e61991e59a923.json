{"sha": "8f493fd46a99c1c9255b684d8a7e61991e59a923", "node_id": "C_kwDOAAsO6NoAKDhmNDkzZmQ0NmE5OWMxYzkyNTViNjg0ZDhhN2U2MTk5MWU1OWE5MjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-04-01T04:59:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-01T04:59:42Z"}, "message": "Rollup merge of #95293 - compiler-errors:braces, r=davidtwco\n\nsuggest wrapping single-expr blocks in square brackets\n\nSuggests a fix in cases like:\n\n```diff\n- const A: [i32; 1] = { 1 };\n\n+ const A: [i32; 1] = [ 1 ];\n                      ^   ^\n```\n\nAlso edit the message for the same suggestion in the parser (e.g. `{ 1, 2 }`).\n\nFixes #95289", "tree": {"sha": "6189e7050d91ec0572ee8b54fb98f11aa3f5be25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6189e7050d91ec0572ee8b54fb98f11aa3f5be25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f493fd46a99c1c9255b684d8a7e61991e59a923", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiRoa+CRBK7hj4Ov3rIwAAtFsIAIG9rvMgktR8My2YD0Q17aqX\nXa3qLr00uOIJ52sQhFcDp5UPqVL/TYHpR9ELvAAvtwbIMrCIgBqBYUIcA/BJ6zaS\nZbOz5Gf63LKGLkyk1jjrnqbhROw6Vd8yiHzYf3GY4qvUsBVj2WH99STK5kHew62J\n2uLe44SpOXMYLucvhC1ucaxy9eDvOVOxVqupALmww5sXTvaGm2Ai4cAf1yN6ZMHs\nQDhrivQeRzvxWWjDc7+/+qTqyOHZncIWPKjQZONCVrSUg5TPMfguahPLYzCqDdD1\nlDY9WbtGWZfVHmsLfAwjTbhJZsla8tfbH5EzsS3ofUxgGaQa3B7m6s7Bil99vlg=\n=aNtB\n-----END PGP SIGNATURE-----\n", "payload": "tree 6189e7050d91ec0572ee8b54fb98f11aa3f5be25\nparent 94b1960535b79bc211a1a9c9967a972e8306e7ae\nparent 91ac9cf5952ef00218c215c564ec7f56c479019d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1648789182 +0200\ncommitter GitHub <noreply@github.com> 1648789182 +0200\n\nRollup merge of #95293 - compiler-errors:braces, r=davidtwco\n\nsuggest wrapping single-expr blocks in square brackets\n\nSuggests a fix in cases like:\n\n```diff\n- const A: [i32; 1] = { 1 };\n\n+ const A: [i32; 1] = [ 1 ];\n                      ^   ^\n```\n\nAlso edit the message for the same suggestion in the parser (e.g. `{ 1, 2 }`).\n\nFixes #95289\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f493fd46a99c1c9255b684d8a7e61991e59a923", "html_url": "https://github.com/rust-lang/rust/commit/8f493fd46a99c1c9255b684d8a7e61991e59a923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f493fd46a99c1c9255b684d8a7e61991e59a923/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94b1960535b79bc211a1a9c9967a972e8306e7ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/94b1960535b79bc211a1a9c9967a972e8306e7ae", "html_url": "https://github.com/rust-lang/rust/commit/94b1960535b79bc211a1a9c9967a972e8306e7ae"}, {"sha": "91ac9cf5952ef00218c215c564ec7f56c479019d", "url": "https://api.github.com/repos/rust-lang/rust/commits/91ac9cf5952ef00218c215c564ec7f56c479019d", "html_url": "https://github.com/rust-lang/rust/commit/91ac9cf5952ef00218c215c564ec7f56c479019d"}], "stats": {"total": 313, "additions": 222, "deletions": 91}, "files": [{"sha": "20d035fba195a7219e62568ae977841e9fc9d51f", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f493fd46a99c1c9255b684d8a7e61991e59a923/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f493fd46a99c1c9255b684d8a7e61991e59a923/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=8f493fd46a99c1c9255b684d8a7e61991e59a923", "patch": "@@ -1919,17 +1919,13 @@ impl<'a> Parser<'a> {\n         match snapshot.parse_array_or_repeat_expr(attrs, token::Brace) {\n             Ok(arr) => {\n                 let hi = snapshot.prev_token.span;\n-                self.struct_span_err(\n-                    arr.span,\n-                    \"this code is interpreted as a block expression, not an array\",\n-                )\n-                .multipart_suggestion(\n-                    \"try using [] instead of {}\",\n-                    vec![(lo, \"[\".to_owned()), (hi, \"]\".to_owned())],\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .note(\"to define an array, one would use square brackets instead of curly braces\")\n-                .emit();\n+                self.struct_span_err(arr.span, \"this is a block expression, not an array\")\n+                    .multipart_suggestion(\n+                        \"to make an array, use square brackets instead of curly braces\",\n+                        vec![(lo, \"[\".to_owned()), (hi, \"]\".to_owned())],\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n \n                 self.restore_snapshot(snapshot);\n                 Some(self.mk_expr_err(arr.span))"}, {"sha": "00bc16452b9b9e741c001de5a867b1bc4179ae13", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f493fd46a99c1c9255b684d8a7e61991e59a923/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f493fd46a99c1c9255b684d8a7e61991e59a923/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=8f493fd46a99c1c9255b684d8a7e61991e59a923", "patch": "@@ -39,6 +39,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.suggest_no_capture_closure(err, expected, expr_ty);\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n         self.suggest_missing_parentheses(err, expr);\n+        self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n         self.report_closure_inferred_return_type(err, expected);"}, {"sha": "2a1b7a5ab47ba6f696adb1293813718acb549987", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 80, "deletions": 65, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/8f493fd46a99c1c9255b684d8a7e61991e59a923/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f493fd46a99c1c9255b684d8a7e61991e59a923/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=8f493fd46a99c1c9255b684d8a7e61991e59a923", "patch": "@@ -774,57 +774,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let prev_diverges = self.diverges.get();\n         let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n \n-        let (ctxt, ()) =\n-            self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-                for (pos, s) in blk.stmts.iter().enumerate() {\n-                    self.check_stmt(s, blk.stmts.len() - 1 == pos);\n-                }\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n+            for (pos, s) in blk.stmts.iter().enumerate() {\n+                self.check_stmt(s, blk.stmts.len() - 1 == pos);\n+            }\n \n-                // check the tail expression **without** holding the\n-                // `enclosing_breakables` lock below.\n-                let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n-\n-                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n-                let coerce = ctxt.coerce.as_mut().unwrap();\n-                if let Some(tail_expr_ty) = tail_expr_ty {\n-                    let tail_expr = tail_expr.unwrap();\n-                    let span = self.get_expr_coercion_span(tail_expr);\n-                    let cause =\n-                        self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n-                    coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n-                } else {\n-                    // Subtle: if there is no explicit tail expression,\n-                    // that is typically equivalent to a tail expression\n-                    // of `()` -- except if the block diverges. In that\n-                    // case, there is no value supplied from the tail\n-                    // expression (assuming there are no other breaks,\n-                    // this implies that the type of the block will be\n-                    // `!`).\n-                    //\n-                    // #41425 -- label the implicit `()` as being the\n-                    // \"found type\" here, rather than the \"expected type\".\n-                    if !self.diverges.get().is_always() {\n-                        // #50009 -- Do not point at the entire fn block span, point at the return type\n-                        // span, as it is the cause of the requirement, and\n-                        // `consider_hint_about_removing_semicolon` will point at the last expression\n-                        // if it were a relevant part of the error. This improves usability in editors\n-                        // that highlight errors inline.\n-                        let mut sp = blk.span;\n-                        let mut fn_span = None;\n-                        if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n-                            let ret_sp = decl.output.span();\n-                            if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n-                                // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n-                                // output would otherwise be incorrect and even misleading. Make sure\n-                                // the span we're aiming at correspond to a `fn` body.\n-                                if block_sp == blk.span {\n-                                    sp = ret_sp;\n-                                    fn_span = Some(ident.span);\n-                                }\n+            // check the tail expression **without** holding the\n+            // `enclosing_breakables` lock below.\n+            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n+\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n+            let coerce = ctxt.coerce.as_mut().unwrap();\n+            if let Some(tail_expr_ty) = tail_expr_ty {\n+                let tail_expr = tail_expr.unwrap();\n+                let span = self.get_expr_coercion_span(tail_expr);\n+                let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n+                let ty_for_diagnostic = coerce.merged_ty();\n+                // We use coerce_inner here because we want to augment the error\n+                // suggesting to wrap the block in square brackets if it might've\n+                // been mistaken array syntax\n+                coerce.coerce_inner(\n+                    self,\n+                    &cause,\n+                    Some(tail_expr),\n+                    tail_expr_ty,\n+                    Some(&mut |diag: &mut Diagnostic| {\n+                        self.suggest_block_to_brackets(diag, blk, tail_expr_ty, ty_for_diagnostic);\n+                    }),\n+                    false,\n+                );\n+            } else {\n+                // Subtle: if there is no explicit tail expression,\n+                // that is typically equivalent to a tail expression\n+                // of `()` -- except if the block diverges. In that\n+                // case, there is no value supplied from the tail\n+                // expression (assuming there are no other breaks,\n+                // this implies that the type of the block will be\n+                // `!`).\n+                //\n+                // #41425 -- label the implicit `()` as being the\n+                // \"found type\" here, rather than the \"expected type\".\n+                if !self.diverges.get().is_always() {\n+                    // #50009 -- Do not point at the entire fn block span, point at the return type\n+                    // span, as it is the cause of the requirement, and\n+                    // `consider_hint_about_removing_semicolon` will point at the last expression\n+                    // if it were a relevant part of the error. This improves usability in editors\n+                    // that highlight errors inline.\n+                    let mut sp = blk.span;\n+                    let mut fn_span = None;\n+                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n+                        let ret_sp = decl.output.span();\n+                        if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n+                            // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n+                            // output would otherwise be incorrect and even misleading. Make sure\n+                            // the span we're aiming at correspond to a `fn` body.\n+                            if block_sp == blk.span {\n+                                sp = ret_sp;\n+                                fn_span = Some(ident.span);\n                             }\n                         }\n-                        coerce.coerce_forced_unit(\n+                    }\n+                    coerce.coerce_forced_unit(\n                         self,\n                         &self.misc(sp),\n                         &mut |err| {\n@@ -837,21 +848,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // Our block must be a `assign desugar local; assignment`\n                                     if let Some(hir::Node::Block(hir::Block {\n                                         stmts:\n-                                            [hir::Stmt {\n-                                                kind:\n-                                                    hir::StmtKind::Local(hir::Local {\n-                                                        source: hir::LocalSource::AssignDesugar(_),\n-                                                        ..\n-                                                    }),\n-                                                ..\n-                                            }, hir::Stmt {\n-                                                kind:\n-                                                    hir::StmtKind::Expr(hir::Expr {\n-                                                        kind: hir::ExprKind::Assign(..),\n-                                                        ..\n-                                                    }),\n-                                                ..\n-                                            }],\n+                                            [\n+                                                hir::Stmt {\n+                                                    kind:\n+                                                        hir::StmtKind::Local(hir::Local {\n+                                                            source:\n+                                                                hir::LocalSource::AssignDesugar(_),\n+                                                            ..\n+                                                        }),\n+                                                    ..\n+                                                },\n+                                                hir::Stmt {\n+                                                    kind:\n+                                                        hir::StmtKind::Expr(hir::Expr {\n+                                                            kind: hir::ExprKind::Assign(..),\n+                                                            ..\n+                                                        }),\n+                                                    ..\n+                                                },\n+                                            ],\n                                         ..\n                                     })) = self.tcx.hir().find(blk.hir_id)\n                                     {\n@@ -871,9 +886,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         },\n                         false,\n                     );\n-                    }\n                 }\n-            });\n+            }\n+        });\n \n         if ctxt.may_break {\n             // If we can break from the block, then the block's exit is always reachable"}, {"sha": "68d555b3a651d224a2dbb0f16592b916aed2d0b2", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8f493fd46a99c1c9255b684d8a7e61991e59a923/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f493fd46a99c1c9255b684d8a7e61991e59a923/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=8f493fd46a99c1c9255b684d8a7e61991e59a923", "patch": "@@ -766,6 +766,77 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Given an expression type mismatch, peel any `&` expressions until we get to\n+    /// a block expression, and then suggest replacing the braces with square braces\n+    /// if it was possibly mistaken array syntax.\n+    pub(crate) fn suggest_block_to_brackets_peeling_refs(\n+        &self,\n+        diag: &mut Diagnostic,\n+        mut expr: &hir::Expr<'_>,\n+        mut expr_ty: Ty<'tcx>,\n+        mut expected_ty: Ty<'tcx>,\n+    ) {\n+        loop {\n+            match (&expr.kind, expr_ty.kind(), expected_ty.kind()) {\n+                (\n+                    hir::ExprKind::AddrOf(_, _, inner_expr),\n+                    ty::Ref(_, inner_expr_ty, _),\n+                    ty::Ref(_, inner_expected_ty, _),\n+                ) => {\n+                    expr = *inner_expr;\n+                    expr_ty = *inner_expr_ty;\n+                    expected_ty = *inner_expected_ty;\n+                }\n+                (hir::ExprKind::Block(blk, _), _, _) => {\n+                    self.suggest_block_to_brackets(diag, *blk, expr_ty, expected_ty);\n+                    break;\n+                }\n+                _ => break,\n+            }\n+        }\n+    }\n+\n+    /// Suggest wrapping the block in square brackets instead of curly braces\n+    /// in case the block was mistaken array syntax, e.g. `{ 1 }` -> `[ 1 ]`.\n+    pub(crate) fn suggest_block_to_brackets(\n+        &self,\n+        diag: &mut Diagnostic,\n+        blk: &hir::Block<'_>,\n+        blk_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) {\n+        if let ty::Slice(elem_ty) | ty::Array(elem_ty, _) = expected_ty.kind() {\n+            if self.can_coerce(blk_ty, *elem_ty)\n+                && blk.stmts.is_empty()\n+                && blk.rules == hir::BlockCheckMode::DefaultBlock\n+            {\n+                let source_map = self.tcx.sess.source_map();\n+                if let Ok(snippet) = source_map.span_to_snippet(blk.span) {\n+                    if snippet.starts_with('{') && snippet.ends_with('}') {\n+                        diag.multipart_suggestion_verbose(\n+                            \"to create an array, use square brackets instead of curly braces\",\n+                            vec![\n+                                (\n+                                    blk.span\n+                                        .shrink_to_lo()\n+                                        .with_hi(rustc_span::BytePos(blk.span.lo().0 + 1)),\n+                                    \"[\".to_string(),\n+                                ),\n+                                (\n+                                    blk.span\n+                                        .shrink_to_hi()\n+                                        .with_lo(rustc_span::BytePos(blk.span.hi().0 - 1)),\n+                                    \"]\".to_string(),\n+                                ),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn is_loop(&self, id: hir::HirId) -> bool {\n         let node = self.tcx.hir().get(id);\n         matches!(node, Node::Expr(Expr { kind: ExprKind::Loop(..), .. }))"}, {"sha": "4d0109767fc0f245813c943456d311869a639bb6", "filename": "src/test/ui/did_you_mean/brackets-to-braces-single-element.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f493fd46a99c1c9255b684d8a7e61991e59a923/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f493fd46a99c1c9255b684d8a7e61991e59a923/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.rs?ref=8f493fd46a99c1c9255b684d8a7e61991e59a923", "patch": "@@ -0,0 +1,10 @@\n+const A: [&str; 1] = { \"hello\" };\n+//~^ ERROR mismatched types\n+\n+const B: &[u32] = &{ 1 };\n+//~^ ERROR mismatched types\n+\n+const C: &&[u32; 1] = &&{ 1 };\n+//~^ ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "6ded03e45b55e9bc1e608468b533d0c9e83d02b0", "filename": "src/test/ui/did_you_mean/brackets-to-braces-single-element.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8f493fd46a99c1c9255b684d8a7e61991e59a923/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f493fd46a99c1c9255b684d8a7e61991e59a923/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbrackets-to-braces-single-element.stderr?ref=8f493fd46a99c1c9255b684d8a7e61991e59a923", "patch": "@@ -0,0 +1,38 @@\n+error[E0308]: mismatched types\n+  --> $DIR/brackets-to-braces-single-element.rs:1:24\n+   |\n+LL | const A: [&str; 1] = { \"hello\" };\n+   |                        ^^^^^^^ expected array `[&'static str; 1]`, found `&str`\n+   |\n+help: to create an array, use square brackets instead of curly braces\n+   |\n+LL | const A: [&str; 1] = [ \"hello\" ];\n+   |                      ~         ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/brackets-to-braces-single-element.rs:4:19\n+   |\n+LL | const B: &[u32] = &{ 1 };\n+   |                   ^^^^^^ expected slice `[u32]`, found integer\n+   |\n+   = note: expected reference `&'static [u32]`\n+              found reference `&{integer}`\n+help: to create an array, use square brackets instead of curly braces\n+   |\n+LL | const B: &[u32] = &[ 1 ];\n+   |                    ~   ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/brackets-to-braces-single-element.rs:7:27\n+   |\n+LL | const C: &&[u32; 1] = &&{ 1 };\n+   |                           ^ expected array `[u32; 1]`, found integer\n+   |\n+help: to create an array, use square brackets instead of curly braces\n+   |\n+LL | const C: &&[u32; 1] = &&[ 1 ];\n+   |                         ~   ~\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "070ffaa1eff00fb2bc0116b39df25924ca49070a", "filename": "src/test/ui/did_you_mean/issue-87830-try-brackets-for-arrays.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f493fd46a99c1c9255b684d8a7e61991e59a923/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f493fd46a99c1c9255b684d8a7e61991e59a923/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.rs?ref=8f493fd46a99c1c9255b684d8a7e61991e59a923", "patch": "@@ -1,15 +1,16 @@\n fn main() {}\n \n-const FOO: [u8; 3] = { //~ ERROR this code is interpreted as a block expression\n+const FOO: [u8; 3] = {\n+    //~^ ERROR this is a block expression, not an array\n     1, 2, 3\n };\n \n const BAR: [&str; 3] = {\"one\", \"two\", \"three\"};\n-//~^ ERROR this code is interpreted as a block expression\n+//~^ ERROR this is a block expression, not an array\n \n fn foo() {\n     {1, 2, 3};\n-    //~^ ERROR this code is interpreted as a block expression\n+    //~^ ERROR this is a block expression, not an array\n }\n \n fn bar() {"}, {"sha": "d5ad1a72b8250444ba5cd6a9a7e97b38af8584fd", "filename": "src/test/ui/did_you_mean/issue-87830-try-brackets-for-arrays.stderr", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8f493fd46a99c1c9255b684d8a7e61991e59a923/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f493fd46a99c1c9255b684d8a7e61991e59a923/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-87830-try-brackets-for-arrays.stderr?ref=8f493fd46a99c1c9255b684d8a7e61991e59a923", "patch": "@@ -1,46 +1,45 @@\n-error: this code is interpreted as a block expression, not an array\n+error: this is a block expression, not an array\n   --> $DIR/issue-87830-try-brackets-for-arrays.rs:3:22\n    |\n LL |   const FOO: [u8; 3] = {\n    |  ______________________^\n+LL | |\n LL | |     1, 2, 3\n LL | | };\n    | |_^\n    |\n-   = note: to define an array, one would use square brackets instead of curly braces\n-help: try using [] instead of {}\n+help: to make an array, use square brackets instead of curly braces\n    |\n LL ~ const FOO: [u8; 3] = [\n+LL |\n LL |     1, 2, 3\n LL ~ ];\n    |\n \n-error: this code is interpreted as a block expression, not an array\n-  --> $DIR/issue-87830-try-brackets-for-arrays.rs:7:24\n+error: this is a block expression, not an array\n+  --> $DIR/issue-87830-try-brackets-for-arrays.rs:8:24\n    |\n LL | const BAR: [&str; 3] = {\"one\", \"two\", \"three\"};\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: to define an array, one would use square brackets instead of curly braces\n-help: try using [] instead of {}\n+help: to make an array, use square brackets instead of curly braces\n    |\n LL | const BAR: [&str; 3] = [\"one\", \"two\", \"three\"];\n    |                        ~                     ~\n \n-error: this code is interpreted as a block expression, not an array\n-  --> $DIR/issue-87830-try-brackets-for-arrays.rs:11:5\n+error: this is a block expression, not an array\n+  --> $DIR/issue-87830-try-brackets-for-arrays.rs:12:5\n    |\n LL |     {1, 2, 3};\n    |     ^^^^^^^^^\n    |\n-   = note: to define an array, one would use square brackets instead of curly braces\n-help: try using [] instead of {}\n+help: to make an array, use square brackets instead of curly braces\n    |\n LL |     [1, 2, 3];\n    |     ~       ~\n \n error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n-  --> $DIR/issue-87830-try-brackets-for-arrays.rs:16:6\n+  --> $DIR/issue-87830-try-brackets-for-arrays.rs:17:6\n    |\n LL |     1, 2, 3\n    |      ^ expected one of `.`, `;`, `?`, `}`, or an operator"}]}