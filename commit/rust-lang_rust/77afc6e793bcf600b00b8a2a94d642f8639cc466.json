{"sha": "77afc6e793bcf600b00b8a2a94d642f8639cc466", "node_id": "C_kwDOAAsO6NoAKDc3YWZjNmU3OTNiY2Y2MDBiMDBiOGEyYTk0ZDY0MmY4NjM5Y2M0NjY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-22T09:24:50Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-22T09:49:00Z"}, "message": "fix: Report remaining macro errors in assoc item collection", "tree": {"sha": "03897dcfb32a3de04df691280aed4f531068a305", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03897dcfb32a3de04df691280aed4f531068a305"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77afc6e793bcf600b00b8a2a94d642f8639cc466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77afc6e793bcf600b00b8a2a94d642f8639cc466", "html_url": "https://github.com/rust-lang/rust/commit/77afc6e793bcf600b00b8a2a94d642f8639cc466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77afc6e793bcf600b00b8a2a94d642f8639cc466/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2aa44c8e37b0230e05e0d8e32687685c28fb8f8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa44c8e37b0230e05e0d8e32687685c28fb8f8d", "html_url": "https://github.com/rust-lang/rust/commit/2aa44c8e37b0230e05e0d8e32687685c28fb8f8d"}], "stats": {"total": 213, "additions": 132, "deletions": 81}, "files": [{"sha": "58becd603b250ae43276c9ed080a10aae1a2addb", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 128, "deletions": 79, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/77afc6e793bcf600b00b8a2a94d642f8639cc466/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77afc6e793bcf600b00b8a2a94d642f8639cc466/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=77afc6e793bcf600b00b8a2a94d642f8639cc466", "patch": "@@ -4,7 +4,9 @@ pub mod adt;\n \n use std::sync::Arc;\n \n-use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n+use hir_expand::{\n+    name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefKind,\n+};\n use intern::Interned;\n use smallvec::SmallVec;\n use syntax::{ast, Parse};\n@@ -13,7 +15,9 @@ use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n     expander::{Expander, Mark},\n-    item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n+    item_tree::{\n+        self, AssocItem, FnFlags, ItemTree, ItemTreeId, MacroCall, ModItem, Param, TreeId,\n+    },\n     macro_call_as_call_id, macro_id_to_def_id,\n     nameres::{\n         attr_resolution::ResolvedAttr,\n@@ -520,7 +524,7 @@ struct AssocItemCollector<'a> {\n     db: &'a dyn DefDatabase,\n     module_id: ModuleId,\n     def_map: Arc<DefMap>,\n-    inactive_diagnostics: Vec<DefDiagnostic>,\n+    diagnostics: Vec<DefDiagnostic>,\n     container: ItemContainerId,\n     expander: Expander,\n \n@@ -543,7 +547,7 @@ impl<'a> AssocItemCollector<'a> {\n             expander: Expander::new(db, file_id, module_id),\n             items: Vec::new(),\n             attr_calls: Vec::new(),\n-            inactive_diagnostics: Vec::new(),\n+            diagnostics: Vec::new(),\n         }\n     }\n \n@@ -557,19 +561,18 @@ impl<'a> AssocItemCollector<'a> {\n         (\n             self.items,\n             if self.attr_calls.is_empty() { None } else { Some(Box::new(self.attr_calls)) },\n-            self.inactive_diagnostics,\n+            self.diagnostics,\n         )\n     }\n \n-    // FIXME: proc-macro diagnostics\n     fn collect(&mut self, item_tree: &ItemTree, tree_id: TreeId, assoc_items: &[AssocItem]) {\n         let container = self.container;\n         self.items.reserve(assoc_items.len());\n \n         'items: for &item in assoc_items {\n             let attrs = item_tree.attrs(self.db, self.module_id.krate, ModItem::from(item).into());\n             if !attrs.is_cfg_enabled(self.expander.cfg_options()) {\n-                self.inactive_diagnostics.push(DefDiagnostic::unconfigured_code(\n+                self.diagnostics.push(DefDiagnostic::unconfigured_code(\n                     self.module_id.local_id,\n                     InFile::new(self.expander.current_file_id(), item.ast_id(item_tree).upcast()),\n                     attrs.cfg().unwrap(),\n@@ -583,91 +586,126 @@ impl<'a> AssocItemCollector<'a> {\n                     AstId::new(self.expander.current_file_id(), item.ast_id(item_tree).upcast());\n                 let ast_id_with_path = AstIdWithPath { path: (*attr.path).clone(), ast_id };\n \n-                if let Ok(ResolvedAttr::Macro(call_id)) = self.def_map.resolve_attr_macro(\n+                match self.def_map.resolve_attr_macro(\n                     self.db,\n                     self.module_id.local_id,\n                     ast_id_with_path,\n                     attr,\n                 ) {\n-                    self.attr_calls.push((ast_id, call_id));\n-                    // If proc attribute macro expansion is disabled, skip expanding it here\n-                    if !self.db.expand_proc_attr_macros() {\n-                        continue 'attrs;\n-                    }\n-                    let loc = self.db.lookup_intern_macro_call(call_id);\n-                    if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n-                        // If there's no expander for the proc macro (e.g. the\n-                        // proc macro is ignored, or building the proc macro\n-                        // crate failed), skip expansion like we would if it was\n-                        // disabled. This is analogous to the handling in\n-                        // `DefCollector::collect_macros`.\n-                        if exp.is_dummy() {\n+                    Ok(ResolvedAttr::Macro(call_id)) => {\n+                        self.attr_calls.push((ast_id, call_id));\n+                        // If proc attribute macro expansion is disabled, skip expanding it here\n+                        if !self.db.expand_proc_attr_macros() {\n                             continue 'attrs;\n                         }\n-                    }\n+                        let loc = self.db.lookup_intern_macro_call(call_id);\n+                        if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n+                            // If there's no expander for the proc macro (e.g. the\n+                            // proc macro is ignored, or building the proc macro\n+                            // crate failed), skip expansion like we would if it was\n+                            // disabled. This is analogous to the handling in\n+                            // `DefCollector::collect_macros`.\n+                            if exp.is_dummy() {\n+                                continue 'attrs;\n+                            }\n+                        }\n \n-                    let res = self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id);\n-                    self.collect_macro_items(res, &|| loc.kind.clone());\n-                    continue 'items;\n+                        let res =\n+                            self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id);\n+                        self.collect_macro_items(res, &|| loc.kind.clone());\n+                        continue 'items;\n+                    }\n+                    Ok(_) => (),\n+                    Err(_) => {\n+                        self.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                            self.module_id.local_id,\n+                            MacroCallKind::Attr {\n+                                ast_id,\n+                                attr_args: Arc::new((tt::Subtree::empty(), Default::default())),\n+                                invoc_attr_index: attr.id,\n+                                is_derive: false,\n+                            },\n+                            attr.path().clone(),\n+                        ));\n+                    }\n                 }\n             }\n \n-            match item {\n-                AssocItem::Function(id) => {\n-                    let item = &item_tree[id];\n+            self.collect_item(item_tree, tree_id, container, item);\n+        }\n+    }\n \n-                    let def =\n-                        FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n-                    self.items.push((item.name.clone(), def.into()));\n-                }\n-                AssocItem::Const(id) => {\n-                    let item = &item_tree[id];\n-\n-                    let name = match item.name.clone() {\n-                        Some(name) => name,\n-                        None => continue,\n-                    };\n-                    let def =\n-                        ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n-                    self.items.push((name, def.into()));\n-                }\n-                AssocItem::TypeAlias(id) => {\n-                    let item = &item_tree[id];\n+    fn collect_item(\n+        &mut self,\n+        item_tree: &ItemTree,\n+        tree_id: TreeId,\n+        container: ItemContainerId,\n+        item: AssocItem,\n+    ) {\n+        match item {\n+            AssocItem::Function(id) => {\n+                let item = &item_tree[id];\n \n-                    let def = TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }\n-                        .intern(self.db);\n-                    self.items.push((item.name.clone(), def.into()));\n-                }\n-                AssocItem::MacroCall(call) => {\n-                    let file_id = self.expander.current_file_id();\n-                    let call = &item_tree[call];\n-                    let module = self.expander.module.local_id;\n-\n-                    if let Ok(Some(call_id)) = macro_call_as_call_id(\n-                        self.db.upcast(),\n-                        &AstIdWithPath::new(file_id, call.ast_id, Clone::clone(&call.path)),\n-                        call.expand_to,\n-                        self.expander.module.krate(),\n-                        |path| {\n-                            self.def_map\n-                                .resolve_path(\n-                                    self.db,\n-                                    module,\n-                                    &path,\n-                                    crate::item_scope::BuiltinShadowMode::Other,\n-                                )\n-                                .0\n-                                .take_macros()\n-                                .map(|it| macro_id_to_def_id(self.db, it))\n-                        },\n-                    ) {\n+                let def =\n+                    FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n+                self.items.push((item.name.clone(), def.into()));\n+            }\n+            AssocItem::Const(id) => {\n+                let item = &item_tree[id];\n+                let Some(name) = item.name.clone() else { return };\n+                let def = ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n+                self.items.push((name, def.into()));\n+            }\n+            AssocItem::TypeAlias(id) => {\n+                let item = &item_tree[id];\n+\n+                let def =\n+                    TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n+                self.items.push((item.name.clone(), def.into()));\n+            }\n+            AssocItem::MacroCall(call) => {\n+                let file_id = self.expander.current_file_id();\n+                let MacroCall { ast_id, expand_to, ref path } = item_tree[call];\n+                let module = self.expander.module.local_id;\n+\n+                let resolver = |path| {\n+                    self.def_map\n+                        .resolve_path(\n+                            self.db,\n+                            module,\n+                            &path,\n+                            crate::item_scope::BuiltinShadowMode::Other,\n+                        )\n+                        .0\n+                        .take_macros()\n+                        .map(|it| macro_id_to_def_id(self.db, it))\n+                };\n+                match macro_call_as_call_id(\n+                    self.db.upcast(),\n+                    &AstIdWithPath::new(file_id, ast_id, Clone::clone(path)),\n+                    expand_to,\n+                    self.expander.module.krate(),\n+                    resolver,\n+                ) {\n+                    Ok(Some(call_id)) => {\n                         let res =\n                             self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id);\n                         self.collect_macro_items(res, &|| hir_expand::MacroCallKind::FnLike {\n-                            ast_id: InFile::new(file_id, call.ast_id),\n+                            ast_id: InFile::new(file_id, ast_id),\n                             expand_to: hir_expand::ExpandTo::Items,\n                         });\n                     }\n+                    Ok(None) => (),\n+                    Err(_) => {\n+                        self.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                            self.module_id.local_id,\n+                            MacroCallKind::FnLike {\n+                                ast_id: InFile::new(file_id, ast_id),\n+                                expand_to,\n+                            },\n+                            Clone::clone(path),\n+                        ));\n+                    }\n                 }\n             }\n         }\n@@ -681,14 +719,25 @@ impl<'a> AssocItemCollector<'a> {\n         let Some((mark, parse)) = value else { return };\n \n         if let Some(err) = err {\n-            self.inactive_diagnostics.push(DefDiagnostic::macro_error(\n-                self.module_id.local_id,\n-                error_call_kind(),\n-                err.to_string(),\n-            ));\n+            let diag = match err {\n+                // why is this reported here?\n+                hir_expand::ExpandError::UnresolvedProcMacro(krate) => {\n+                    DefDiagnostic::unresolved_proc_macro(\n+                        self.module_id.local_id,\n+                        error_call_kind(),\n+                        krate,\n+                    )\n+                }\n+                _ => DefDiagnostic::macro_error(\n+                    self.module_id.local_id,\n+                    error_call_kind(),\n+                    err.to_string(),\n+                ),\n+            };\n+            self.diagnostics.push(diag);\n         }\n         if let errors @ [_, ..] = parse.errors() {\n-            self.inactive_diagnostics.push(DefDiagnostic::macro_expansion_parse_error(\n+            self.diagnostics.push(DefDiagnostic::macro_expansion_parse_error(\n                 self.module_id.local_id,\n                 error_call_kind(),\n                 errors.into(),"}, {"sha": "18b424255cd6bc3fbe0fd5cc92414d0db0e59664", "filename": "crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77afc6e793bcf600b00b8a2a94d642f8639cc466/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77afc6e793bcf600b00b8a2a94d642f8639cc466/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=77afc6e793bcf600b00b8a2a94d642f8639cc466", "patch": "@@ -88,7 +88,8 @@ impl DefDiagnostic {\n         Self { in_module: container, kind: DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } }\n     }\n \n-    pub(super) fn unresolved_proc_macro(\n+    // FIXME: Whats the difference between this and unresolved_macro_call\n+    pub(crate) fn unresolved_proc_macro(\n         container: LocalModuleId,\n         ast: MacroCallKind,\n         krate: CrateId,\n@@ -118,7 +119,8 @@ impl DefDiagnostic {\n         }\n     }\n \n-    pub(super) fn unresolved_macro_call(\n+    // FIXME: Whats the difference between this and unresolved_proc_macro\n+    pub(crate) fn unresolved_macro_call(\n         container: LocalModuleId,\n         ast: MacroCallKind,\n         path: ModPath,"}]}