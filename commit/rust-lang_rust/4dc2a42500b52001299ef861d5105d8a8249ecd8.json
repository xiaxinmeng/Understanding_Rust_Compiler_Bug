{"sha": "4dc2a42500b52001299ef861d5105d8a8249ecd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYzJhNDI1MDBiNTIwMDEyOTllZjg2MWQ1MTA1ZDhhODI0OWVjZDg=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-04T23:14:32Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-04T23:14:32Z"}, "message": "document extract_function assist implementation", "tree": {"sha": "8a15d1a667c4c714c17982f1d080442d18298a32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a15d1a667c4c714c17982f1d080442d18298a32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dc2a42500b52001299ef861d5105d8a8249ecd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dc2a42500b52001299ef861d5105d8a8249ecd8", "html_url": "https://github.com/rust-lang/rust/commit/4dc2a42500b52001299ef861d5105d8a8249ecd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dc2a42500b52001299ef861d5105d8a8249ecd8/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff74467c0d107a0b9472e928f9f0845f68be088", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff74467c0d107a0b9472e928f9f0845f68be088", "html_url": "https://github.com/rust-lang/rust/commit/0ff74467c0d107a0b9472e928f9f0845f68be088"}], "stats": {"total": 148, "additions": 126, "deletions": 22}, "files": [{"sha": "dfb3da7a5ee164e08b28c9e56a66dd399ba499fa", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 126, "deletions": 22, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4dc2a42500b52001299ef861d5105d8a8249ecd8/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc2a42500b52001299ef861d5105d8a8249ecd8/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=4dc2a42500b52001299ef861d5105d8a8249ecd8", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n     let body = extraction_target(&node, ctx.frange.range)?;\n \n-    let vars_used_in_body = vars_used_in_body(&body, &ctx);\n+    let vars_used_in_body = vars_used_in_body(ctx, &body);\n     let self_param = self_param_from_usages(ctx, &body, &vars_used_in_body);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n@@ -74,6 +74,9 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let vars_defined_in_body_and_outlive = vars_defined_in_body_and_outlive(ctx, &body);\n     let ret_ty = body_return_ty(ctx, &body)?;\n \n+    // FIXME: we compute variables that outlive here just to check `never!` condition\n+    //        this requires traversing whole `body` (cheap) and finding all references (expensive)\n+    //        maybe we can move this check to `edit` closure somehow?\n     if stdx::never!(!vars_defined_in_body_and_outlive.is_empty() && !ret_ty.is_unit()) {\n         // We should not have variables that outlive body if we have expression block\n         return None;\n@@ -201,6 +204,7 @@ impl RetType {\n     }\n }\n \n+/// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n #[derive(Debug)]\n enum FunctionBody {\n     Expr(ast::Expr),\n@@ -334,27 +338,53 @@ impl HasTokenAtOffset for FunctionBody {\n     }\n }\n \n+/// node or token's parent\n fn element_to_node(node: SyntaxElement) -> SyntaxNode {\n     match node {\n         syntax::NodeOrToken::Node(n) => n,\n         syntax::NodeOrToken::Token(t) => t.parent(),\n     }\n }\n \n+/// Try to guess what user wants to extract\n+///\n+/// We have basically have two cases:\n+/// * We want whole node, like `loop {}`, `2 + 2`, `{ let n = 1; }` exprs.\n+///   Then we can use `ast::Expr`\n+/// * We want a few statements for a block. E.g.\n+///   ```rust,no_run\n+///   fn foo() -> i32 {\n+///     let m = 1;\n+///     $0\n+///     let n = 2;\n+///     let k = 3;\n+///     k + n\n+///     $0\n+///   }\n+///   ```\n+///\n fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<FunctionBody> {\n+    // we have selected exactly the expr node\n+    // wrap it before anything else\n     if node.text_range() == selection_range {\n         let body = FunctionBody::from_whole_node(node.clone());\n         if body.is_some() {\n             return body;\n         }\n     }\n \n+    // we have selected a few statements in a block\n+    // so covering_element returns the whole block\n     if node.kind() == BLOCK_EXPR {\n         let body = FunctionBody::from_range(&node, selection_range);\n         if body.is_some() {\n             return body;\n         }\n     }\n+\n+    // we have selected single statement\n+    // `from_whole_node` failed because (let) statement is not and expression\n+    // so we try to expand covering_element to parent and repeat the previous\n     if let Some(parent) = node.parent() {\n         if parent.kind() == BLOCK_EXPR {\n             let body = FunctionBody::from_range(&parent, selection_range);\n@@ -364,21 +394,13 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n         }\n     }\n \n-    let body = FunctionBody::from_whole_node(node.clone());\n-    if body.is_some() {\n-        return body;\n-    }\n-\n-    let body = node.ancestors().find_map(FunctionBody::from_whole_node);\n-    if body.is_some() {\n-        return body;\n-    }\n-\n-    None\n+    // select the closest containing expr (both ifs are used)\n+    std::iter::once(node.clone()).chain(node.ancestors()).find_map(FunctionBody::from_whole_node)\n }\n \n-/// Returns a vector of local variables that are referenced in `body`\n-fn vars_used_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+/// list local variables that are referenced in `body`\n+fn vars_used_in_body(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n+    // FIXME: currently usages inside macros are not found\n     body.descendants()\n         .filter_map(ast::NameRef::cast)\n         .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n@@ -391,6 +413,9 @@ fn vars_used_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n         .collect()\n }\n \n+/// find `self` param, that was not defined inside `body`\n+///\n+/// It should skip `self` params from impls inside `body`\n fn self_param_from_usages(\n     ctx: &AssistContext,\n     body: &FunctionBody,\n@@ -412,12 +437,15 @@ fn self_param_from_usages(\n     let self_param = iter.next();\n     stdx::always!(\n         iter.next().is_none(),\n-        \"body references two different self params both defined outside\"\n+        \"body references two different self params, both defined outside\"\n     );\n \n     self_param\n }\n \n+/// find variables that should be extracted as params\n+///\n+/// Computes additional info that affects param type and mutability\n fn extracted_function_params(\n     ctx: &AssistContext,\n     body: &FunctionBody,\n@@ -455,34 +483,42 @@ fn has_usages_after_body(usages: &LocalUsages, body: &FunctionBody) -> bool {\n     usages.iter().any(|reference| body.preceedes_range(reference.range))\n }\n \n+/// checks if relevant var is used with `&mut` access inside body\n fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &FunctionBody) -> bool {\n     usages\n         .iter()\n         .filter(|reference| body.contains_range(reference.range))\n         .any(|reference| reference_is_exclusive(reference, body, ctx))\n }\n \n+/// checks if this reference requires `&mut` access inside body\n fn reference_is_exclusive(\n     reference: &FileReference,\n     body: &FunctionBody,\n     ctx: &AssistContext,\n ) -> bool {\n+    // we directly modify variable with set: `n = 0`, `n += 1`\n     if reference.access == Some(ReferenceAccess::Write) {\n         return true;\n     }\n \n-    let path = path_at_offset(body, reference);\n+    // we take `&mut` reference to variable: `&mut v`\n+    let path = path_element_of_reference(body, reference);\n     if is_mut_ref_expr(path.as_ref()).unwrap_or(false) {\n         return true;\n     }\n \n-    if is_mut_method_call(ctx, path.as_ref()).unwrap_or(false) {\n+    // we call method with `&mut self` receiver\n+    if is_mut_method_call_receiver(ctx, path.as_ref()).unwrap_or(false) {\n         return true;\n     }\n \n     false\n }\n \n+/// Container of local varaible usages\n+///\n+/// Semanticall same as `UsageSearchResult`, but provides more convenient interface\n struct LocalUsages(ide_db::search::UsageSearchResult);\n \n impl LocalUsages {\n@@ -510,7 +546,15 @@ impl HasTokenAtOffset for SyntaxNode {\n     }\n }\n \n-fn path_at_offset(node: &dyn HasTokenAtOffset, reference: &FileReference) -> Option<ast::Expr> {\n+/// find relevant `ast::PathExpr` for reference\n+///\n+/// # Preconditions\n+///\n+/// `node` must cover `reference`, that is `node.text_range().contains_range(reference.range)`\n+fn path_element_of_reference(\n+    node: &dyn HasTokenAtOffset,\n+    reference: &FileReference,\n+) -> Option<ast::Expr> {\n     let token = node.token_at_offset(reference.range.start()).right_biased().or_else(|| {\n         stdx::never!(false, \"cannot find token at variable usage: {:?}\", reference);\n         None\n@@ -529,7 +573,8 @@ fn is_mut_ref_expr(path: Option<&ast::Expr>) -> Option<bool> {\n     Some(ref_expr.mut_token().is_some())\n }\n \n-fn is_mut_method_call(ctx: &AssistContext, path: Option<&ast::Expr>) -> Option<bool> {\n+/// checks if `path` is the receiver in method call that requires `&mut self` access\n+fn is_mut_method_call_receiver(ctx: &AssistContext, path: Option<&ast::Expr>) -> Option<bool> {\n     let path = path?;\n     let method_call = path.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n \n@@ -540,21 +585,25 @@ fn is_mut_method_call(ctx: &AssistContext, path: Option<&ast::Expr>) -> Option<b\n     Some(matches!(access, hir::Access::Exclusive))\n }\n \n-/// Returns a vector of local variables that are defined in `body`\n+/// list local variables defined inside `body`\n fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+    // FIXME: this doesn't work well with macros\n+    //        see https://github.com/rust-analyzer/rust-analyzer/pull/7535#discussion_r570048550\n     body.descendants()\n         .filter_map(ast::IdentPat::cast)\n         .filter_map(|let_stmt| ctx.sema.to_def(&let_stmt))\n         .unique()\n         .collect()\n }\n \n+/// list local variables defined inside `body` that should be returned from extracted function\n fn vars_defined_in_body_and_outlive(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n     let mut vars_defined_in_body = vars_defined_in_body(&body, ctx);\n     vars_defined_in_body.retain(|var| var_outlives_body(ctx, body, var));\n     vars_defined_in_body\n }\n \n+/// checks if the relevant local was defined before(outside of) body\n fn is_defined_before(\n     ctx: &AssistContext,\n     body: &FunctionBody,\n@@ -571,6 +620,7 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     }\n }\n \n+/// checks if local variable is used after(outside of) body\n fn var_outlives_body(ctx: &AssistContext, body: &FunctionBody, var: &Local) -> bool {\n     let usages = Definition::Local(*var)\n         .usages(&ctx.sema)\n@@ -590,12 +640,18 @@ fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n         None => Some(RetType::Stmt),\n     }\n }\n+/// Where to put extracted function definition\n #[derive(Debug)]\n enum Anchor {\n+    /// Extract free function and put right after current top-level function\n     Freestanding,\n+    /// Extract method and put right after current function in the impl-block\n     Method,\n }\n \n+/// find where to put extracted function definition\n+///\n+/// Function should be put right after returned node\n fn scope_for_fn_insertion(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n     match body {\n         FunctionBody::Expr(e) => scope_for_fn_insertion_node(e.syntax(), anchor),\n@@ -801,6 +857,7 @@ fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> Stri\n     ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n }\n \n+/// change all usages to account for added `&`/`&mut` for some params\n fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n     let mut rewriter = SyntaxRewriter::default();\n     for param in params {\n@@ -812,7 +869,7 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n         let usages = usages\n             .iter()\n             .filter(|reference| syntax.text_range().contains_range(reference.range))\n-            .filter_map(|reference| path_at_offset(syntax, reference));\n+            .filter_map(|reference| path_element_of_reference(syntax, reference));\n         for path in usages {\n             match path.syntax().ancestors().skip(1).find_map(ast::Expr::cast) {\n                 Some(ast::Expr::MethodCallExpr(_)) => {\n@@ -1424,6 +1481,54 @@ fn $0fun_name(n: i32) -> (i32, i32) {\n         );\n     }\n \n+    #[test]\n+    fn nontrivial_patterns_define_variables() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct Counter(i32);\n+fn foo() {\n+    $0let Counter(n) = Counter(0);$0\n+    let m = n;\n+}\",\n+            r\"\n+struct Counter(i32);\n+fn foo() {\n+    let n = fun_name();\n+    let m = n;\n+}\n+\n+fn $0fun_name() -> i32 {\n+    let Counter(n) = Counter(0);\n+    n\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_with_two_fields_pattern_define_variables() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+struct Counter { n: i32, m: i32 };\n+fn foo() {\n+    $0let Counter { n, m: k } = Counter { n: 1, m: 2 };$0\n+    let h = n + k;\n+}\",\n+            r\"\n+struct Counter { n: i32, m: i32 };\n+fn foo() {\n+    let (n, k) = fun_name();\n+    let h = n + k;\n+}\n+\n+fn $0fun_name() -> (i32, i32) {\n+    let Counter { n, m: k } = Counter { n: 1, m: 2 };\n+    (n, k)\n+}\",\n+        );\n+    }\n+\n     #[test]\n     fn mut_var_from_outer_scope() {\n         check_assist(\n@@ -1754,7 +1859,6 @@ fn $0fun_name(c: Counter) {\n         );\n     }\n \n-\n     #[test]\n     fn non_copy_used_after() {\n         check_assist("}]}