{"sha": "a906f6cb698df6d29093e14984878446c269082d", "node_id": "C_kwDOAAsO6NoAKGE5MDZmNmNiNjk4ZGY2ZDI5MDkzZTE0OTg0ODc4NDQ2YzI2OTA4MmQ", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-10-22T15:31:07Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:47:42Z"}, "message": "don't call `align_offset` during const eval, ever", "tree": {"sha": "46f5e40331b7465538709f80172d1d0715752dcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46f5e40331b7465538709f80172d1d0715752dcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a906f6cb698df6d29093e14984878446c269082d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a906f6cb698df6d29093e14984878446c269082d", "html_url": "https://github.com/rust-lang/rust/commit/a906f6cb698df6d29093e14984878446c269082d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a906f6cb698df6d29093e14984878446c269082d/comments", "author": null, "committer": null, "parents": [{"sha": "24e88066dc702da8fbe0381044645a91669bf02f", "url": "https://api.github.com/repos/rust-lang/rust/commits/24e88066dc702da8fbe0381044645a91669bf02f", "html_url": "https://github.com/rust-lang/rust/commit/24e88066dc702da8fbe0381044645a91669bf02f"}], "stats": {"total": 140, "additions": 90, "deletions": 50}, "files": [{"sha": "6cf8a581d71a65e4f233a259bde6333f5a060f65", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 88, "deletions": 43, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/a906f6cb698df6d29093e14984878446c269082d/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a906f6cb698df6d29093e14984878446c269082d/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=a906f6cb698df6d29093e14984878446c269082d", "patch": "@@ -1,11 +1,10 @@\n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::PointerArithmetic;\n-use rustc_middle::ty::layout::FnAbiOf;\n+use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::borrow::Borrow;\n use std::hash::Hash;\n-use std::ops::ControlFlow;\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::fx::IndexEntry;\n@@ -20,8 +19,8 @@ use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi as CallAbi;\n \n use crate::interpret::{\n-    self, compile_time_machine, AllocId, ConstAllocation, FnVal, Frame, ImmTy, InterpCx,\n-    InterpResult, OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n+    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n+    OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n };\n \n use super::error::*;\n@@ -156,7 +155,6 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n     fn hook_special_const_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        _abi: CallAbi,\n         args: &[OpTy<'tcx>],\n         dest: &PlaceTy<'tcx>,\n         ret: Option<mir::BasicBlock>,\n@@ -194,24 +192,21 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n \n             return Ok(Some(new_instance));\n         } else if Some(def_id) == self.tcx.lang_items().align_offset_fn() {\n-            // For align_offset, we replace the function call if the pointer has no address.\n-            match self.align_offset(instance, args, dest, ret)? {\n-                ControlFlow::Continue(()) => return Ok(Some(instance)),\n-                ControlFlow::Break(()) => return Ok(None),\n-            }\n+            // For align_offset, we replace the function call entirely.\n+            self.align_offset(instance, args, dest, ret)?;\n+            return Ok(None);\n         }\n         Ok(Some(instance))\n     }\n \n-    /// `align_offset(ptr, target_align)` needs special handling in const eval, because the pointer\n-    /// may not have an address.\n+    /// This function replaces `align_offset(ptr, target_align)` in const eval, because the\n+    /// pointer may not have an address.\n     ///\n-    /// If `ptr` does have a known address, then we return `CONTINUE` and the function call should\n-    /// proceed as normal.\n+    /// If `ptr` does have a known address, we forward it to [`Self::align_offset_impl`].\n     ///\n     /// If `ptr` doesn't have an address, but its underlying allocation's alignment is at most\n-    /// `target_align`, then we call the function again with an dummy address relative to the\n-    /// allocation.\n+    /// `target_align`, then we call [`Self::align_offset_impl`] with an dummy address relative\n+    /// to the allocation.\n     ///\n     /// If `ptr` doesn't have an address and `target_align` is stricter than the underlying\n     /// allocation's alignment, then we return `usize::MAX` immediately.\n@@ -221,50 +216,100 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n         args: &[OpTy<'tcx>],\n         dest: &PlaceTy<'tcx>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx, ControlFlow<()>> {\n+    ) -> InterpResult<'tcx> {\n         assert_eq!(args.len(), 2);\n \n         let ptr = self.read_pointer(&args[0])?;\n         let target_align = self.read_scalar(&args[1])?.to_machine_usize(self)?;\n \n+        let pointee_ty = instance.substs.type_at(0);\n+        let stride = self.layout_of(pointee_ty)?.size.bytes();\n+\n         if !target_align.is_power_of_two() {\n             throw_ub_format!(\"`align_offset` called with non-power-of-two align: {}\", target_align);\n         }\n \n-        match self.ptr_try_get_alloc_id(ptr) {\n+        let mut align_offset = match self.ptr_try_get_alloc_id(ptr) {\n             Ok((alloc_id, offset, _extra)) => {\n+                // Extract the address relative to a base that is definitely sufficiently aligned.\n                 let (_size, alloc_align, _kind) = self.get_alloc_info(alloc_id);\n \n                 if target_align <= alloc_align.bytes() {\n-                    // Extract the address relative to the allocation base that is definitely\n-                    // sufficiently aligned and call `align_offset` again.\n-                    let addr = ImmTy::from_uint(offset.bytes(), args[0].layout).into();\n-                    let align = ImmTy::from_uint(target_align, args[1].layout).into();\n-\n-                    let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n-                    self.eval_fn_call(\n-                        FnVal::Instance(instance),\n-                        (CallAbi::Rust, fn_abi),\n-                        &[addr, align],\n-                        false,\n-                        dest,\n-                        ret,\n-                        StackPopUnwind::NotAllowed,\n-                    )?;\n-                    Ok(ControlFlow::BREAK)\n+                    // The pointer *is* alignable in const. We use an address relative to the\n+                    // allocation base that is definitely sufficiently aligned.\n+                    let addr = offset.bytes();\n+                    Self::align_offset_impl(addr, stride, target_align)\n                 } else {\n-                    // Not alignable in const, return `usize::MAX`.\n-                    let usize_max = Scalar::from_machine_usize(self.machine_usize_max(), self);\n-                    self.write_scalar(usize_max, dest)?;\n-                    self.return_to_block(ret)?;\n-                    Ok(ControlFlow::BREAK)\n+                    // The pointer *is not* alignable in const, return `usize::MAX`.\n+                    // (We clamp this to machine `usize` below.)\n+                    u64::MAX\n                 }\n             }\n-            Err(_addr) => {\n-                // The pointer has an address, continue with function call.\n-                Ok(ControlFlow::CONTINUE)\n+            Err(addr) => {\n+                // The pointer has a known address.\n+                Self::align_offset_impl(addr, stride, target_align)\n             }\n+        };\n+\n+        let usize_max = self.machine_usize_max();\n+        if align_offset > usize_max {\n+            align_offset = usize_max;\n+        }\n+\n+        self.write_scalar(Scalar::from_machine_usize(align_offset, self), dest)?;\n+        self.return_to_block(ret)?;\n+\n+        Ok(())\n+    }\n+\n+    /// Const eval implementation of `#[lang = \"align_offset\"]`.\n+    /// See the runtime version for a detailed explanation how this works.\n+    fn align_offset_impl(addr: u64, stride: u64, align: u64) -> u64 {\n+        assert!(align.is_power_of_two());\n+\n+        let addr_mod_align = addr % align;\n+\n+        if addr_mod_align == 0 {\n+            // The address is already sufficiently aligned.\n+            return 0;\n         }\n+\n+        if stride == 0 {\n+            // The address cannot be aligned.\n+            return u64::MAX;\n+        }\n+\n+        let byte_offset = align - addr_mod_align;\n+\n+        if align % stride == 0 {\n+            if byte_offset % stride == 0 {\n+                return byte_offset / stride;\n+            } else {\n+                return u64::MAX;\n+            }\n+        }\n+\n+        // This only works, because `align` is a power of two.\n+        let gcd = 1u64 << (stride | align).trailing_zeros();\n+\n+        if addr % gcd != 0 {\n+            // The address cannot be aligned.\n+            return u64::MAX;\n+        }\n+\n+        let align2 = align / gcd;\n+        let stride2 = (stride / gcd) % align2;\n+\n+        let mut stride_inv = 1u64;\n+        let mut mod_gate = 2u64;\n+        let mut overflow = false;\n+        while !overflow && mod_gate < align2 {\n+            stride_inv =\n+                stride_inv.wrapping_mul(2u64.wrapping_sub(stride2.wrapping_mul(stride_inv)));\n+            (mod_gate, overflow) = mod_gate.overflowing_mul(mod_gate);\n+        }\n+\n+        byte_offset.wrapping_mul(stride_inv) % align2\n     }\n \n     /// See documentation on the `ptr_guaranteed_cmp` intrinsic.\n@@ -367,7 +412,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 }\n             }\n \n-            let Some(new_instance) = ecx.hook_special_const_fn(instance, _abi, args, dest, ret)? else {\n+            let Some(new_instance) = ecx.hook_special_const_fn(instance, args, dest, ret)? else {\n                 return Ok(None);\n             };\n "}, {"sha": "e762837ff90a96a1986578178442d33ae896f09e", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a906f6cb698df6d29093e14984878446c269082d/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a906f6cb698df6d29093e14984878446c269082d/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a906f6cb698df6d29093e14984878446c269082d", "patch": "@@ -1590,9 +1590,8 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n /// than trying to adapt this to accommodate that change.\n ///\n /// Any questions go to @nagisa.\n-// #[cfg(not(bootstrap))] -- Calling this function in a const context from the bootstrap\n-// compiler will always cause an error.\n #[lang = \"align_offset\"]\n+#[rustc_do_not_const_check] // hooked by const-eval\n pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n     // 1, where the method versions of these operations are not inlined.\n@@ -1652,13 +1651,9 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n         inverse & m_minus_one\n     }\n \n+    let addr = p.addr();\n     let stride = mem::size_of::<T>();\n \n-    // SAFETY: At runtime transmuting a pointer to `usize` is always safe, because they have the\n-    // same layout. During const eval we hook this function to ensure that the pointer always has\n-    // an address (only the standard library can do this).\n-    let addr = unsafe { mem::transmute(p) };\n-\n     // SAFETY: `a` is a power-of-two, therefore non-zero.\n     let a_minus_one = unsafe { unchecked_sub(a, 1) };\n "}]}