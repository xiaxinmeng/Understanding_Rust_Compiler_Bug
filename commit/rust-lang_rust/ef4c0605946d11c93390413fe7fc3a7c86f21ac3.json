{"sha": "ef4c0605946d11c93390413fe7fc3a7c86f21ac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNGMwNjA1OTQ2ZDExYzkzMzkwNDEzZmU3ZmMzYTdjODZmMjFhYzM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T17:55:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T18:01:59Z"}, "message": "Address @catamorphism's comments regarding docs", "tree": {"sha": "9fcec7716bd412c7c0c6d10ca5815602b01865dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fcec7716bd412c7c0c6d10ca5815602b01865dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef4c0605946d11c93390413fe7fc3a7c86f21ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4c0605946d11c93390413fe7fc3a7c86f21ac3", "html_url": "https://github.com/rust-lang/rust/commit/ef4c0605946d11c93390413fe7fc3a7c86f21ac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef4c0605946d11c93390413fe7fc3a7c86f21ac3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b15bfde8133768d8fc517eeb8064bd2f9bcddd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b15bfde8133768d8fc517eeb8064bd2f9bcddd5", "html_url": "https://github.com/rust-lang/rust/commit/4b15bfde8133768d8fc517eeb8064bd2f9bcddd5"}], "stats": {"total": 80, "additions": 50, "deletions": 30}, "files": [{"sha": "43c1cb78166945d92e4af946172e5a7d8c903fdd", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c0605946d11c93390413fe7fc3a7c86f21ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c0605946d11c93390413fe7fc3a7c86f21ac3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=ef4c0605946d11c93390413fe7fc3a7c86f21ac3", "patch": "@@ -485,17 +485,16 @@ mod guarantor {\n     /*!\n      *\n      * The routines in this module are aiming to deal with the case\n-     * where the lifetime resulting from a borrow is linked to the\n-     * lifetime of the thing being borrowed.  Imagine you have a\n-     * borrowed pointer `b` with lifetime L1 and you have an\n-     * expression `&*b`.  The result of this borrow will be another\n-     * borrowed pointer with lifetime L2 (which is an inference\n-     * variable).  The borrow checker is going to enforce the\n-     * constraint that L2 < L1, because otherwise you are re-borrowing\n-     * data for a lifetime larger than the original loan.  However,\n-     * without the routines in this module, the region inferencer would\n-     * not know of this dependency and thus it might infer the\n-     * lifetime of L2 to be greater than L1 (issue #3148).\n+     * where a the contents of a borrowed pointer are re-borrowed.\n+     * Imagine you have a borrowed pointer `b` with lifetime L1 and\n+     * you have an expression `&*b`.  The result of this borrow will\n+     * be another borrowed pointer with lifetime L2 (which is an\n+     * inference variable).  The borrow checker is going to enforce\n+     * the constraint that L2 < L1, because otherwise you are\n+     * re-borrowing data for a lifetime larger than the original loan.\n+     * However, without the routines in this module, the region\n+     * inferencer would not know of this dependency and thus it might\n+     * infer the lifetime of L2 to be greater than L1 (issue #3148).\n      *\n      * There are a number of troublesome scenarios in the test\n      * `region-dependent-addr-of.rs`, but here is one example:\n@@ -515,16 +514,17 @@ mod guarantor {\n      * is \"guaranteed\" by a borrowed pointer, you must link the\n      * lifetime of that borrowed pointer (L1, here) to the lifetime of\n      * the borrow itself (L2).  What do I mean by \"guaranteed\" by a\n-     * borrowed pointer? Well, I would say the data \"owned\" by the\n-     * borrowed pointer, except that a borrowed pointer never owns its\n-     * contents, but the relation is the same.  That is, I mean any\n-     * data that is reached by first derefencing a borrowed pointer\n-     * and then either traversing interior offsets or owned pointers.\n-     * We say that the guarantor of such data it the region of the borrowed\n-     * pointer that was traversed.\n+     * borrowed pointer? I mean any data that is reached by first\n+     * dereferencing a borrowed pointer and then either traversing\n+     * interior offsets or owned pointers.  We say that the guarantor\n+     * of such data it the region of the borrowed pointer that was\n+     * traversed.  This is essentially the same as the ownership\n+     * relation, except that a borrowed pointer never owns its\n+     * contents.\n      *\n      * NB: I really wanted to use the `mem_categorization` code here\n-     * but I cannot because final type resolution hasn't happened yet.\n+     * but I cannot because final type resolution hasn't happened yet,\n+     * and `mem_categorization` requires that all types be known.\n      * So this is very similar logic to what you would find there,\n      * but more special purpose.\n      */\n@@ -540,7 +540,8 @@ mod guarantor {\n         /*!\n          *\n          * Computes the guarantor for an expression `&base` and then\n-         * ensures that the lifetime of the resulting pointer is linked.\n+         * ensures that the lifetime of the resulting pointer is linked\n+         * to the lifetime of its guarantor (if any).\n          */\n \n         debug!(\"guarantor::for_addr_of(base=%s)\", rcx.fcx.expr_to_str(base));\n@@ -555,7 +556,7 @@ mod guarantor {\n          *\n          * Computes the guarantors for any ref bindings in a match and\n          * then ensures that the lifetime of the resulting pointer is\n-         * linked.\n+         * linked to the lifetime of its guarantor (if any).\n          */\n \n         let discr_guarantor = guarantor(rcx, discr);\n@@ -599,13 +600,18 @@ mod guarantor {\n         /*!\n          *\n          * Links the lifetime of the borrowed pointer resulting from a borrow\n-         * to the lifetime of its guarantor.\n+         * to the lifetime of its guarantor (if any).\n          */\n \n         debug!(\"opt_constrain_region(id=%?, guarantor=%?)\", id, guarantor);\n \n         let bound = match guarantor {\n-            None => { return; }\n+            None => {\n+                // If guarantor is None, then the value being borrowed\n+                // is not guaranteed by a region pointer, so there are\n+                // no lifetimes to link.\n+                return;\n+            }\n             Some(r) => { r }\n         };\n \n@@ -620,24 +626,38 @@ mod guarantor {\n         }\n     }\n \n-    enum PointerCat {\n+    /// Categorizes types based on what kind of pointer they are.\n+    /// Note that we don't bother to distinguish between rptrs (&T)\n+    /// and slices (&[T], &str)---they are all just `BorrowedPointer`.\n+    enum PointerCategorization {\n         NotPointer,\n         OwnedPointer,\n         BorrowedPointer(ty::Region),\n         OtherPointer\n     }\n \n+    /// Guarantor of an expression paired with the\n+    /// PointerCategorization` of its type.\n     struct ExprCategorization {\n         guarantor: Option<ty::Region>,\n-        pointer: PointerCat\n+        pointer: PointerCategorization\n     }\n \n+    /// ExprCategorization paired with the full type of the expr\n     struct ExprCategorizationType {\n         cat: ExprCategorization,\n         ty: ty::t\n     }\n \n     fn guarantor(rcx: @rcx, expr: @ast::expr) -> Option<ty::Region> {\n+        /*!\n+         *\n+         * Computes the guarantor of `expr`, or None if `expr` is\n+         * not guaranteed by any region.  Here `expr` is some expression\n+         * whose address is being taken (e.g., there is an expression\n+         * `&expr`).\n+         */\n+\n         debug!(\"guarantor(expr=%s)\", rcx.fcx.expr_to_str(expr));\n         match expr.node {\n             ast::expr_unary(ast::deref, b) => {\n@@ -706,9 +726,7 @@ mod guarantor {\n         }\n     }\n \n-    fn categorize(rcx: @rcx,\n-                  expr: @ast::expr) -> ExprCategorization\n-    {\n+    fn categorize(rcx: @rcx, expr: @ast::expr) -> ExprCategorization {\n         debug!(\"categorize(expr=%s)\", rcx.fcx.expr_to_str(expr));\n         let _i = ::util::common::indenter();\n \n@@ -722,6 +740,8 @@ mod guarantor {\n                 rcx, expr, adjustment.autoderefs, expr_ct);\n \n             for adjustment.autoref.each |autoref| {\n+                // If there is an autoref, then the result of this\n+                // expression will be some sort of borrowed pointer.\n                 expr_ct.cat.guarantor = None;\n                 expr_ct.cat.pointer = BorrowedPointer(autoref.region);\n                 debug!(\"autoref, cat=%?\", expr_ct.cat);\n@@ -784,7 +804,7 @@ mod guarantor {\n         return ct;\n     }\n \n-    fn pointer_categorize(ty: ty::t) -> PointerCat {\n+    fn pointer_categorize(ty: ty::t) -> PointerCategorization {\n         match ty::get(ty).sty {\n             ty::ty_rptr(r, _) | ty::ty_evec(_, ty::vstore_slice(r)) |\n             ty::ty_estr(ty::vstore_slice(r)) => {\n@@ -911,7 +931,7 @@ fn infallibly_mk_subr(rcx: @rcx,\n {\n     /*!\n      *\n-     * Constraints `a` to be a subregion of `b`.  In many cases, we\n+     * Constrains `a` to be a subregion of `b`.  In many cases, we\n      * know that this can never yield an error due to the way that\n      * region inferencing works.  Therefore just report a bug if we\n      * ever see `Err(_)`."}]}