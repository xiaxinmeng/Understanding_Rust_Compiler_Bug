{"sha": "8cef6785bf29f98f49dce5fa62e54606e7f5b948", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZWY2Nzg1YmYyOWY5OGY0OWRjZTVmYTYyZTU0NjA2ZTdmNWI5NDg=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-06-25T21:18:19Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-06-25T21:18:19Z"}, "message": "Merge pull request #93 from marcusklaas/tuple-structs\n\nFormat tuple like structs", "tree": {"sha": "a3f752f1f523647d1f286b4caa935df1b809b5dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3f752f1f523647d1f286b4caa935df1b809b5dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cef6785bf29f98f49dce5fa62e54606e7f5b948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cef6785bf29f98f49dce5fa62e54606e7f5b948", "html_url": "https://github.com/rust-lang/rust/commit/8cef6785bf29f98f49dce5fa62e54606e7f5b948", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cef6785bf29f98f49dce5fa62e54606e7f5b948/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb", "html_url": "https://github.com/rust-lang/rust/commit/66c6fe53346c575cd6d7a4ce581b1e7ecda5e7bb"}, {"sha": "28f7bd42059be794ad8ceb05d564f5e2b14676b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/28f7bd42059be794ad8ceb05d564f5e2b14676b5", "html_url": "https://github.com/rust-lang/rust/commit/28f7bd42059be794ad8ceb05d564f5e2b14676b5"}], "stats": {"total": 1794, "additions": 1214, "deletions": 580}, "files": [{"sha": "a1338d5b369825820e590b5f0f43b76c1fdd0c7b", "filename": "src/comment.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -0,0 +1,202 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Format comments.\n+\n+use string::{StringFormat, rewrite_string};\n+use utils::make_indent;\n+\n+pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usize) -> String {\n+    let s = orig.trim();\n+\n+    // Edge case: block comments. Let's not trim their lines (for now).\n+    let opener = if block_style { \"/* \" } else { \"// \" };\n+    let closer = if block_style { \" */\" } else { \"\" };\n+    let line_start = if block_style { \" * \" } else { \"// \" };\n+\n+    let max_chars = width.checked_sub(closer.len()).unwrap_or(1)\n+                         .checked_sub(opener.len()).unwrap_or(1);\n+\n+    let fmt = StringFormat {\n+        opener: \"\",\n+        closer: \"\",\n+        line_start: line_start,\n+        line_end: \"\",\n+        width: max_chars,\n+        offset: offset + opener.len() - line_start.len(),\n+        trim_end: true\n+    };\n+\n+    let indent_str = make_indent(offset);\n+    let line_breaks = s.chars().filter(|&c| c == '\\n').count();\n+\n+    let (_, mut s) = s.lines().enumerate()\n+        .map(|(i, mut line)| {\n+            line = line.trim();\n+\n+            // Drop old closer.\n+            if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n+                line = &line[..(line.len() - 2)];\n+            }\n+\n+            line.trim_right_matches(' ')\n+        })\n+        .map(left_trim_comment_line)\n+        .fold((true, opener.to_owned()), |(first, mut acc), line| {\n+            if !first {\n+                acc.push('\\n');\n+                acc.push_str(&indent_str);\n+                acc.push_str(line_start);\n+            }\n+\n+            if line.len() > max_chars {\n+                acc.push_str(&rewrite_string(line, &fmt));\n+            } else {\n+                acc.push_str(line);\n+            }\n+\n+            (false, acc)\n+        });\n+\n+    s.push_str(closer);\n+\n+    s\n+}\n+\n+fn left_trim_comment_line<'a>(line: &'a str) -> &'a str {\n+    if line.starts_with(\"/* \") || line.starts_with(\"// \") {\n+        &line[3..]\n+    } else if line.starts_with(\"/*\") || line.starts_with(\"* \") || line.starts_with(\"//\") {\n+        &line[2..]\n+    } else if line.starts_with(\"*\") {\n+        &line[1..]\n+    } else {\n+        line\n+    }\n+}\n+\n+#[test]\n+fn format_comments() {\n+    assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, 100));\n+    assert_eq!(\"// comment\\n// on a\", rewrite_comment(\"// comment on a\", false, 10, 0));\n+\n+    assert_eq!(\"//  A multi line comment\\n            // between args.\",\n+               rewrite_comment(\"//  A multi line comment\\n             // between args.\",\n+                               false,\n+                               60,\n+                               12));\n+\n+    let input = \"// comment\";\n+    let expected_output = \"/* com\\n                                                                      \\\n+                            * men\\n                                                                      \\\n+                            * t */\";\n+    assert_eq!(expected_output, rewrite_comment(input, true, 9, 69));\n+}\n+\n+\n+pub trait FindUncommented {\n+    fn find_uncommented(&self, pat: &str) -> Option<usize>;\n+}\n+\n+impl FindUncommented for str {\n+    fn find_uncommented(&self, pat: &str) -> Option<usize> {\n+        let mut needle_iter = pat.chars();\n+        let mut possible_comment = false;\n+\n+        for (i, b) in self.char_indices() {\n+            match needle_iter.next() {\n+                Some(c) => {\n+                    if b != c {\n+                        needle_iter = pat.chars();\n+                    }\n+                },\n+                None => return Some(i - pat.len())\n+            }\n+\n+            if possible_comment && (b == '/' || b == '*') {\n+                return find_comment_end(&self[(i-1)..])\n+                    .and_then(|end| {\n+                        self[(end + i - 1)..].find_uncommented(pat)\n+                                             .map(|idx| idx + end + i - 1)\n+                    });\n+            }\n+\n+            possible_comment = b == '/';\n+        }\n+\n+        // Handle case where the pattern is a suffix of the search string\n+        match needle_iter.next() {\n+            Some(_) => None,\n+            None => Some(self.len() - pat.len())\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_find_uncommented() {\n+    fn check(haystack: &str, needle: &str, expected: Option<usize>) {\n+        println!(\"haystack {:?}, needle: {:?}\", haystack, needle);\n+        assert_eq!(expected, haystack.find_uncommented(needle));\n+    }\n+\n+    check(\"/*/ */test\", \"test\", Some(6));\n+    check(\"//test\\ntest\", \"test\", Some(7));\n+    check(\"/* comment only */\", \"whatever\", None);\n+    check(\"/* comment */ some text /* more commentary */ result\", \"result\", Some(46));\n+    check(\"sup // sup\", \"p\", Some(2));\n+    check(\"sup\", \"x\", None);\n+    check(\"\u03c0? /**/ \u03c0 is nice!\", \"\u03c0 is nice\", Some(9));\n+    check(\"/*sup yo? \\n sup*/ sup\", \"p\", Some(20));\n+    check(\"hel/*lohello*/lo\", \"hello\", None);\n+    check(\"acb\", \"ab\", None);\n+}\n+\n+// Returns the first byte position after the first comment. The given string\n+// is expected to be prefixed by a comment, including delimiters.\n+// Good: \"/* /* inner */ outer */ code();\"\n+// Bad:  \"code(); // hello\\n world!\"\n+pub fn find_comment_end(s: &str) -> Option<usize> {\n+    if s.starts_with(\"//\") {\n+        s.find('\\n').map(|idx| idx + 1)\n+    } else {\n+        // Block comment\n+        let mut levels = 0;\n+        let mut prev_char = 'a';\n+\n+        for (i, mut c) in s.char_indices() {\n+            if c == '*' && prev_char == '/' {\n+                levels += 1;\n+                c = 'a'; // Invalidate prev_char\n+            } else if c == '/' && prev_char == '*' {\n+                levels -= 1;\n+\n+                if levels == 0 {\n+                    return Some(i + 1);\n+                }\n+                c = 'a';\n+            }\n+\n+            prev_char = c;\n+        }\n+\n+        None\n+    }\n+}\n+\n+#[test]\n+fn comment_end() {\n+    assert_eq!(Some(6), find_comment_end(\"// hi\\n\"));\n+    assert_eq!(Some(9), find_comment_end(\"/* sup */ \"));\n+    assert_eq!(Some(9), find_comment_end(\"/*/**/ */ \"));\n+    assert_eq!(Some(6), find_comment_end(\"/*/ */ weird!\"));\n+    assert_eq!(None, find_comment_end(\"/* hi /* test */\"));\n+    assert_eq!(None, find_comment_end(\"// hi /* test */\"));\n+    assert_eq!(Some(9), find_comment_end(\"// hi /*\\n.\"));\n+}"}, {"sha": "8bcf12854a8972d2adc2240041051261d775a12a", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -24,7 +24,7 @@ pub struct Config {\n     pub fn_brace_style: BraceStyle,\n     pub fn_return_indent: ReturnIndent,\n     pub fn_args_paren_newline: bool,\n-    pub struct_trailing_comma: bool,\n+    pub struct_trailing_comma: SeparatorTactic,\n     pub struct_lit_trailing_comma: SeparatorTactic,\n     pub enum_trailing_comma: bool,\n     pub report_todo: ReportTactic,"}, {"sha": "2d5ba9c03eea781c539277a59c75f0bf97ae9ad3", "filename": "src/default.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fdefault.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fdefault.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdefault.toml?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -6,7 +6,7 @@ newline_style = \"Unix\"\n fn_brace_style = \"SameLineWhere\"\n fn_return_indent = \"WithArgs\"\n fn_args_paren_newline = true\n-struct_trailing_comma = true\n+struct_trailing_comma = \"Vertical\"\n struct_lit_trailing_comma = \"Vertical\"\n enum_trailing_comma = true\n report_todo = \"Always\""}, {"sha": "d66630e5179fc414fa4eeab561901847601720fa", "filename": "src/expr.rs", "status": "modified", "additions": 155, "deletions": 153, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use utils::*;\n-use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n use rewrite::{Rewrite, RewriteContext};\n+use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n+use string::{StringFormat, rewrite_string};\n+use utils::span_after;\n \n use syntax::{ast, ptr};\n-use syntax::codemap::{Pos, Span};\n+use syntax::codemap::{Pos, Span, BytePos};\n use syntax::parse::token;\n use syntax::print::pprust;\n \n-use MIN_STRING;\n-\n impl Rewrite for ast::Expr {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         match self.node {\n@@ -33,20 +32,22 @@ impl Rewrite for ast::Expr {\n                 }\n             }\n             ast::Expr_::ExprCall(ref callee, ref args) => {\n-                return rewrite_call(context, callee, args, width, offset);\n+                return rewrite_call(context, callee, args, self.span, width, offset);\n             }\n             ast::Expr_::ExprParen(ref subexpr) => {\n                 return rewrite_paren(context, subexpr, width, offset);\n             }\n             ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n-                return rewrite_struct_lit(context, path,\n-                                               fields,\n-                                               base.as_ref().map(|e| &**e),\n-                                               width,\n-                                               offset);\n+                return rewrite_struct_lit(context,\n+                                          path,\n+                                          fields,\n+                                          base.as_ref().map(|e| &**e),\n+                                          self.span,\n+                                          width,\n+                                          offset);\n             }\n             ast::Expr_::ExprTup(ref items) => {\n-                return rewrite_tuple_lit(context, items, width, offset);\n+                return rewrite_tuple_lit(context, items, self.span, width, offset);\n             }\n             _ => {}\n         }\n@@ -55,112 +56,78 @@ impl Rewrite for ast::Expr {\n     }\n }\n \n-fn rewrite_string_lit(context: &RewriteContext, s: &str, span: Span, width: usize, offset: usize) -> Option<String> {\n-    // FIXME I bet this stomps unicode escapes in the source string\n-\n+fn rewrite_string_lit(context: &RewriteContext,\n+                      s: &str,\n+                      span: Span,\n+                      width: usize,\n+                      offset: usize)\n+    -> Option<String> {\n     // Check if there is anything to fix: we always try to fixup multi-line\n     // strings, or if the string is too long for the line.\n     let l_loc = context.codemap.lookup_char_pos(span.lo);\n     let r_loc = context.codemap.lookup_char_pos(span.hi);\n     if l_loc.line == r_loc.line && r_loc.col.to_usize() <= context.config.max_width {\n         return context.codemap.span_to_snippet(span).ok();\n     }\n+    let fmt = StringFormat {\n+        opener: \"\\\"\",\n+        closer: \"\\\"\",\n+        line_start: \" \",\n+        line_end: \"\\\\\",\n+        width: width,\n+        offset: offset,\n+        trim_end: false\n+    };\n \n-    // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n-\n-    let s = s.escape_default();\n-\n-    let offset = offset + 1;\n-    let indent = make_indent(offset);\n-    let indent = &indent;\n-\n-    let mut cur_start = 0;\n-    let mut result = String::with_capacity(round_up_to_power_of_two(s.len()));\n-    result.push('\"');\n-    loop {\n-        let max_chars = if cur_start == 0 {\n-            // First line.\n-            width - 2 // 2 = \" + \\\n-        } else {\n-            context.config.max_width - offset - 1 // 1 = either \\ or ;\n-        };\n-\n-        let mut cur_end = cur_start + max_chars;\n-\n-        if cur_end >= s.len() {\n-            result.push_str(&s[cur_start..]);\n-            break;\n-        }\n-\n-        // Make sure we're on a char boundary.\n-        cur_end = next_char(&s, cur_end);\n-\n-        // Push cur_end left until we reach whitespace\n-        while !s.char_at(cur_end-1).is_whitespace() {\n-            cur_end = prev_char(&s, cur_end);\n-\n-            if cur_end - cur_start < MIN_STRING {\n-                // We can't break at whitespace, fall back to splitting\n-                // anywhere that doesn't break an escape sequence\n-                cur_end = next_char(&s, cur_start + max_chars);\n-                while s.char_at(prev_char(&s, cur_end)) == '\\\\' {\n-                    cur_end = prev_char(&s, cur_end);\n-                }\n-                break;\n-            }\n-        }\n-        // Make sure there is no whitespace to the right of the break.\n-        while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n-            cur_end = next_char(&s, cur_end+1);\n-        }\n-        result.push_str(&s[cur_start..cur_end]);\n-        result.push_str(\"\\\\\\n\");\n-        result.push_str(indent);\n-\n-        cur_start = cur_end;\n-    }\n-    result.push('\"');\n-\n-    Some(result)\n+    Some(rewrite_string(&s.escape_default(), &fmt))\n }\n \n fn rewrite_call(context: &RewriteContext,\n                 callee: &ast::Expr,\n                 args: &[ptr::P<ast::Expr>],\n+                span: Span,\n                 width: usize,\n                 offset: usize)\n-        -> Option<String>\n-{\n+        -> Option<String> {\n     debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n \n     // TODO using byte lens instead of char lens (and probably all over the place too)\n     let callee_str = try_opt!(callee.rewrite(context, width, offset));\n-    debug!(\"rewrite_call, callee_str: `{:?}`\", callee_str);\n+    debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n+\n+    if args.len() == 0 {\n+        return Some(format!(\"{}()\", callee_str));\n+    }\n+\n     // 2 is for parens.\n     let remaining_width = width - callee_str.len() - 2;\n     let offset = callee_str.len() + 1 + offset;\n-    let arg_count = args.len();\n \n-    let args_str = if arg_count > 0 {\n-        let args_rewritten: Vec<_> =\n-            try_opt!(args.iter()\n-                         .map(|arg| arg.rewrite(context, remaining_width, offset)\n-                                       .map(|arg_str| (arg_str, String::new())))\n-                         .collect());\n-        let fmt = ListFormatting {\n-            tactic: ListTactic::HorizontalVertical,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: offset,\n-            h_width: remaining_width,\n-            v_width: remaining_width,\n-        };\n-        write_list(&args_rewritten, &fmt)\n-    } else {\n-        String::new()\n+    let items = itemize_list(context.codemap,\n+                             Vec::new(),\n+                             args.iter(),\n+                             \",\",\n+                             \")\",\n+                             |item| item.span.lo,\n+                             |item| item.span.hi,\n+                             // Take old span when rewrite fails.\n+                             |item| item.rewrite(context, remaining_width, offset)\n+                                        .unwrap_or(context.codemap.span_to_snippet(item.span)\n+                                                                  .unwrap()),\n+                             callee.span.hi + BytePos(1),\n+                             span.hi);\n+\n+    let fmt = ListFormatting {\n+        tactic: ListTactic::HorizontalVertical,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: offset,\n+        h_width: remaining_width,\n+        v_width: remaining_width,\n+        ends_with_newline: true,\n     };\n \n-    Some(format!(\"{}({})\", callee_str, args_str))\n+    Some(format!(\"{}({})\", callee_str, write_list(&items, &fmt)))\n }\n \n fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, width: usize, offset: usize) -> Option<String> {\n@@ -172,34 +139,68 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, width: usize, of\n     subexpr_str.map(|s| format!(\"({})\", s))\n }\n \n-fn rewrite_struct_lit(context: &RewriteContext,\n-                      path: &ast::Path,\n-                      fields: &[ast::Field],\n-                      base: Option<&ast::Expr>,\n-                      width: usize,\n-                      offset: usize)\n+fn rewrite_struct_lit<'a>(context: &RewriteContext,\n+                          path: &ast::Path,\n+                          fields: &'a [ast::Field],\n+                          base: Option<&'a ast::Expr>,\n+                          span: Span,\n+                          width: usize,\n+                          offset: usize)\n         -> Option<String>\n {\n     debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n     assert!(fields.len() > 0 || base.is_some());\n \n+    enum StructLitField<'a> {\n+        Regular(&'a ast::Field),\n+        Base(&'a ast::Expr)\n+    }\n+\n     let path_str = pprust::path_to_string(path);\n     // Foo { a: Foo } - indent is +3, width is -5.\n     let indent = offset + path_str.len() + 3;\n     let budget = width - (path_str.len() + 5);\n \n-    let field_strs: Vec<_> =\n-        try_opt!(fields.iter()\n-                       .map(|field| rewrite_field(context, field, budget, indent))\n-                       .chain(base.iter()\n-                                  .map(|expr| expr.rewrite(context,\n-                                                           // 2 = \"..\"\n-                                                           budget - 2,\n-                                                           indent + 2)\n-                                                  .map(|s| format!(\"..{}\", s))))\n-                       .collect());\n-    // FIXME comments\n-    let field_strs: Vec<_> = field_strs.into_iter().map(|s| (s, String::new())).collect();\n+    let field_iter = fields.into_iter().map(StructLitField::Regular)\n+                           .chain(base.into_iter().map(StructLitField::Base));\n+\n+    let items = itemize_list(context.codemap,\n+                             Vec::new(),\n+                             field_iter,\n+                             \",\",\n+                             \"}\",\n+                             |item| {\n+                                 match *item {\n+                                     StructLitField::Regular(ref field) => field.span.lo,\n+                                     // 2 = ..\n+                                     StructLitField::Base(ref expr) => expr.span.lo - BytePos(2)\n+                                 }\n+                             },\n+                             |item| {\n+                                 match *item {\n+                                     StructLitField::Regular(ref field) => field.span.hi,\n+                                     StructLitField::Base(ref expr) => expr.span.hi\n+                                 }\n+                             },\n+                             |item| {\n+                                 match *item {\n+                                     StructLitField::Regular(ref field) => {\n+                                         rewrite_field(context, &field, budget, indent)\n+                                            .unwrap_or(context.codemap.span_to_snippet(field.span)\n+                                                                      .unwrap())\n+                                     },\n+                                     StructLitField::Base(ref expr) => {\n+                                         // 2 = ..\n+                                         expr.rewrite(context, budget - 2, indent + 2)\n+                                             .map(|s| format!(\"..{}\", s))\n+                                             .unwrap_or(context.codemap.span_to_snippet(expr.span)\n+                                                                       .unwrap())\n+                                     }\n+                                 }\n+                             },\n+                             span_after(span, \"{\", context.codemap),\n+                             span.hi);\n+\n     let fmt = ListFormatting {\n         tactic: ListTactic::HorizontalVertical,\n         separator: \",\",\n@@ -211,14 +212,15 @@ fn rewrite_struct_lit(context: &RewriteContext,\n         indent: indent,\n         h_width: budget,\n         v_width: budget,\n+        ends_with_newline: true,\n     };\n-    let fields_str = write_list(&field_strs, &fmt);\n+    let fields_str = write_list(&items, &fmt);\n     Some(format!(\"{} {{ {} }}\", path_str, fields_str))\n \n-        // FIXME if the usual multi-line layout is too wide, we should fall back to\n-        // Foo {\n-        //     a: ...,\n-        // }\n+    // FIXME if the usual multi-line layout is too wide, we should fall back to\n+    // Foo {\n+    //     a: ...,\n+    // }\n }\n \n fn rewrite_field(context: &RewriteContext, field: &ast::Field, width: usize, offset: usize) -> Option<String> {\n@@ -230,43 +232,43 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, width: usize, off\n \n fn rewrite_tuple_lit(context: &RewriteContext,\n                      items: &[ptr::P<ast::Expr>],\n+                     span: Span,\n                      width: usize,\n                      offset: usize)\n     -> Option<String> {\n-        // opening paren\n-        let indent = offset + 1;\n-        // In case of length 1, need a trailing comma\n-        if items.len() == 1 {\n-            return items[0].rewrite(context, width - 3, indent).map(|s| format!(\"({},)\", s));\n-        }\n-        // Only last line has width-1 as budget, other may take max_width\n-        let item_strs: Vec<_> =\n-            try_opt!(items.iter()\n-                          .enumerate()\n-                          .map(|(i, item)| {\n-                              let rem_width = if i == items.len() - 1 {\n-                                  width - 2\n-                              } else {\n-                                  context.config.max_width - indent - 2\n-                              };\n-                              item.rewrite(context, rem_width, indent)\n-                          })\n-                          .collect());\n-        let tactics = if item_strs.iter().any(|s| s.contains('\\n')) {\n-            ListTactic::Vertical\n-        } else {\n-            ListTactic::HorizontalVertical\n-        };\n-        // FIXME handle comments\n-        let item_strs: Vec<_> = item_strs.into_iter().map(|s| (s, String::new())).collect();\n-        let fmt = ListFormatting {\n-            tactic: tactics,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: indent,\n-            h_width: width - 2,\n-            v_width: width - 2,\n-        };\n-        let item_str = write_list(&item_strs, &fmt);\n-        Some(format!(\"({})\", item_str))\n-    }\n+    let indent = offset + 1;\n+\n+    let items = itemize_list(context.codemap,\n+                             Vec::new(),\n+                             items.into_iter(),\n+                             \",\",\n+                             \")\",\n+                             |item| item.span.lo,\n+                             |item| item.span.hi,\n+                             |item| item.rewrite(context,\n+                                                 context.config.max_width - indent - 2,\n+                                                 indent)\n+                                        .unwrap_or(context.codemap.span_to_snippet(item.span)\n+                                                                  .unwrap()),\n+                             span.lo + BytePos(1), // Remove parens\n+                             span.hi - BytePos(1));\n+\n+    // In case of length 1, need a trailing comma\n+    let trailing_separator_tactic = if items.len() == 1 {\n+        SeparatorTactic::Always\n+    } else {\n+        SeparatorTactic::Never\n+    };\n+\n+    let fmt = ListFormatting {\n+        tactic: ListTactic::HorizontalVertical,\n+        separator: \",\",\n+        trailing_separator: trailing_separator_tactic,\n+        indent: indent,\n+        h_width: width - 2,\n+        v_width: width - 2,\n+        ends_with_newline: true,\n+    };\n+\n+    Some(format!(\"({})\", write_list(&items, &fmt)))\n+}"}, {"sha": "de33be849baede44fc765961fcd542431c0fb783", "filename": "src/imports.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use visitor::FmtVisitor;\n-use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+use lists::{write_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n use utils::format_visibility;\n \n use syntax::ast;\n@@ -65,16 +65,8 @@ impl<'a> FmtVisitor<'a> {\n         let used_width = indent + 2;\n \n         // Break as early as possible when we've blown our budget.\n-        let remaining_line_budget = if used_width > one_line_budget {\n-            0\n-        } else {\n-            one_line_budget - used_width\n-        };\n-        let remaining_multi_budget = if used_width > multi_line_budget {\n-            0\n-        } else {\n-            multi_line_budget - used_width\n-        };\n+        let remaining_line_budget = one_line_budget.checked_sub(used_width).unwrap_or(0);\n+        let remaining_multi_budget = multi_line_budget.checked_sub(used_width).unwrap_or(0);\n \n         let fmt = ListFormatting {\n             tactic: ListTactic::Mixed,\n@@ -83,6 +75,7 @@ impl<'a> FmtVisitor<'a> {\n             indent: block_indent + indent,\n             h_width: remaining_line_budget,\n             v_width: remaining_multi_budget,\n+            ends_with_newline: true,\n         };\n \n         // TODO handle any comments inbetween items.\n@@ -94,20 +87,21 @@ impl<'a> FmtVisitor<'a> {\n                 false\n             }\n         ) {\n-            Some((\"self\".to_owned(), String::new()))\n+            Some(ListItem::from_str(\"self\"))\n         } else {\n             None\n         };\n \n         let items: Vec<_> = head.into_iter().chain(path_list.iter().filter_map(|vpi| {\n             match vpi.node {\n                 ast::PathListItem_::PathListIdent{ name, .. } => {\n-                    Some((token::get_ident(name).to_string(), String::new()))\n+                    Some(ListItem::from_str(token::get_ident(name).to_string()))\n                 }\n                 // Skip `self`, because we added it above.\n                 ast::PathListItem_::PathListMod{ .. } => None,\n             }\n         })).collect();\n+\n         Some(if path_str.len() == 0 {\n             format!(\"{}use {{{}}};\", vis, write_list(&items, &fmt))\n         } else {"}, {"sha": "0efe0c31c78a1f0dc6c862e273db765bf0ff28b4", "filename": "src/issues.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -223,7 +223,6 @@ impl BadIssueSeeker {\n #[test]\n fn find_unnumbered_issue() {\n     fn check_fail(text: &str, failing_pos: usize) {\n-        println!(\"{:?}\", text);\n         let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n         assert_eq!(Some(failing_pos), text.chars().position(|c| seeker.inspect(c).is_some()));\n     }"}, {"sha": "17941dcd242e24f52f85be9978d8606391450711", "filename": "src/items.rs", "status": "modified", "additions": 280, "deletions": 238, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -11,9 +11,11 @@\n // Formatting top-level items - functions, structs, enums, traits, impls.\n \n use {ReturnIndent, BraceStyle};\n-use utils::{format_visibility, make_indent, FindUncommented};\n-use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+use utils::{format_visibility, make_indent, contains_skip, span_after};\n+use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n+use comment::FindUncommented;\n use visitor::FmtVisitor;\n+\n use syntax::{ast, abi};\n use syntax::codemap::{self, Span, BytePos};\n use syntax::print::pprust;\n@@ -30,7 +32,7 @@ impl<'a> FmtVisitor<'a> {\n                       constness: &ast::Constness,\n                       abi: &abi::Abi,\n                       vis: ast::Visibility,\n-                      span_end: BytePos)\n+                      span: Span)\n         -> String\n     {\n         let newline_brace = self.newline_for_brace(&generics.where_clause);\n@@ -44,7 +46,7 @@ impl<'a> FmtVisitor<'a> {\n                                               constness,\n                                               abi,\n                                               vis,\n-                                              span_end,\n+                                              span,\n                                               newline_brace);\n \n         // Prepare for the function body by possibly adding a newline and indent.\n@@ -68,7 +70,7 @@ impl<'a> FmtVisitor<'a> {\n         -> String\n     {\n         // Drop semicolon or it will be interpreted as comment\n-        let span_end = span.hi - BytePos(1);\n+        let span = codemap::mk_sp(span.lo, span.hi - BytePos(1));\n \n         let mut result = self.rewrite_fn_base(indent,\n                                               ident,\n@@ -79,7 +81,7 @@ impl<'a> FmtVisitor<'a> {\n                                               &sig.constness,\n                                               &sig.abi,\n                                               ast::Visibility::Inherited,\n-                                              span_end,\n+                                              span,\n                                               false);\n \n         // Re-attach semicolon\n@@ -98,7 +100,7 @@ impl<'a> FmtVisitor<'a> {\n                        constness: &ast::Constness,\n                        abi: &abi::Abi,\n                        vis: ast::Visibility,\n-                       span_end: BytePos,\n+                       span: Span,\n                        newline_brace: bool)\n         -> String\n     {\n@@ -131,7 +133,8 @@ impl<'a> FmtVisitor<'a> {\n         let generics_indent = indent + result.len();\n         result.push_str(&self.rewrite_generics(generics,\n                                                generics_indent,\n-                                               span_for_return(&fd.output).lo));\n+                                               codemap::mk_sp(span.lo,\n+                                                              span_for_return(&fd.output).lo)));\n \n         let ret_str = self.rewrite_return(&fd.output);\n \n@@ -162,7 +165,8 @@ impl<'a> FmtVisitor<'a> {\n                                            one_line_budget,\n                                            multi_line_budget,\n                                            arg_indent,\n-                                           span_for_return(&fd.output)));\n+                                           codemap::mk_sp(span_after(span, \"(\", self.codemap),\n+                                                          span_for_return(&fd.output).lo)));\n         result.push(')');\n \n         // Return type.\n@@ -189,7 +193,7 @@ impl<'a> FmtVisitor<'a> {\n             // Comment between return type and the end of the decl.\n             let snippet_lo = fd.output.span().hi;\n             if where_clause.predicates.len() == 0 {\n-                let snippet_hi = span_end;\n+                let snippet_hi = span.hi;\n                 let snippet = self.snippet(codemap::mk_sp(snippet_lo, snippet_hi));\n                 let snippet = snippet.trim();\n                 if snippet.len() > 0 {\n@@ -204,7 +208,9 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         // Where clause.\n-        result.push_str(&self.rewrite_where_clause(where_clause, indent, span_end));\n+        result.push_str(&self.rewrite_where_clause(where_clause,\n+                                                   indent,\n+                                                   span.hi));\n \n         result\n     }\n@@ -215,7 +221,7 @@ impl<'a> FmtVisitor<'a> {\n                     one_line_budget: usize,\n                     multi_line_budget: usize,\n                     arg_indent: usize,\n-                    ret_span: Span)\n+                    span: Span)\n         -> String\n     {\n         let mut arg_item_strs: Vec<_> = args.iter().map(|a| self.rewrite_fn_input(a)).collect();\n@@ -262,89 +268,50 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         // Comments between args\n-        let mut arg_comments = Vec::new();\n+        let mut arg_items = Vec::new();\n         if min_args == 2 {\n-            arg_comments.push(\"\".to_owned());\n+            arg_items.push(ListItem::from_str(\"\"));\n         }\n+\n         // TODO if there are no args, there might still be a comment, but without\n         // spans for the comment or parens, there is no chance of getting it right.\n         // You also don't get to put a comment on self, unless it is explicit.\n         if args.len() >= min_args {\n-            arg_comments = self.make_comments_for_list(arg_comments,\n-                                                       args[min_args-1..].iter(),\n-                                                       \",\",\n-                                                       \")\",\n-                                                       |arg| arg.pat.span.lo,\n-                                                       |arg| arg.ty.span.hi,\n-                                                       ret_span.lo);\n+            let comment_span_start = if min_args == 2 {\n+                span_after(span, \",\", self.codemap)\n+            } else {\n+                span.lo\n+            };\n+\n+            arg_items = itemize_list(self.codemap,\n+                                     arg_items,\n+                                     args[min_args-1..].iter(),\n+                                     \",\",\n+                                     \")\",\n+                                     |arg| arg.pat.span.lo,\n+                                     |arg| arg.ty.span.hi,\n+                                     |_| String::new(),\n+                                     comment_span_start,\n+                                     span.hi);\n         }\n \n-        debug!(\"comments: {:?}\", arg_comments);\n+        assert_eq!(arg_item_strs.len(), arg_items.len());\n \n-        // If there are // comments, keep them multi-line.\n-        let mut list_tactic = ListTactic::HorizontalVertical;\n-        if arg_comments.iter().any(|c| c.contains(\"//\")) {\n-            list_tactic = ListTactic::Vertical;\n+        for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n+            item.item = arg;\n         }\n \n-        assert_eq!(arg_item_strs.len(), arg_comments.len());\n-        let arg_strs: Vec<_> = arg_item_strs.into_iter().zip(arg_comments.into_iter()).collect();\n-\n         let fmt = ListFormatting {\n-            tactic: list_tactic,\n+            tactic: ListTactic::HorizontalVertical,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::Never,\n             indent: arg_indent,\n             h_width: one_line_budget,\n             v_width: multi_line_budget,\n+            ends_with_newline: true,\n         };\n \n-        write_list(&arg_strs, &fmt)\n-    }\n-\n-    // Gets comments in between items of a list.\n-    fn make_comments_for_list<T, I, F1, F2>(&self,\n-                                            prefix: Vec<String>,\n-                                            mut it: I,\n-                                            separator: &str,\n-                                            terminator: &str,\n-                                            get_lo: F1,\n-                                            get_hi: F2,\n-                                            next_span_start: BytePos)\n-        -> Vec<String>\n-        where I: Iterator<Item=T>,\n-              F1: Fn(&T) -> BytePos,\n-              F2: Fn(&T) -> BytePos\n-    {\n-        let mut result = prefix;\n-\n-        let mut prev_end = get_hi(&it.next().unwrap());\n-        for item in it {\n-            let cur_start = get_lo(&item);\n-            let snippet = self.snippet(codemap::mk_sp(prev_end, cur_start));\n-            let mut snippet = snippet.trim();\n-            let white_space: &[_] = &[' ', '\\t'];\n-            if snippet.starts_with(separator) {\n-                snippet = snippet[separator.len()..].trim_matches(white_space);\n-            } else if snippet.ends_with(separator) {\n-                snippet = snippet[..snippet.len()-separator.len()].trim_matches(white_space);\n-            }\n-            result.push(snippet.to_owned());\n-            prev_end = get_hi(&item);\n-        }\n-        // Get the last commment.\n-        // FIXME If you thought the crap with the commas was ugly, just wait.\n-        // This is awful. We're going to look from the last item span to the\n-        // start of the return type span, then we drop everything after the\n-        // first closing paren.\n-        // The fix is comments in the AST or a span for the closing paren.\n-        let snippet = self.snippet(codemap::mk_sp(prev_end, next_span_start));\n-        let snippet = snippet.trim();\n-        let snippet = &snippet[..snippet.find_uncommented(terminator).unwrap_or(snippet.len())];\n-        let snippet = snippet.trim();\n-        result.push(snippet.to_owned());\n-\n-        result\n+        write_list(&arg_items, &fmt)\n     }\n \n     fn compute_budgets_for_args(&self,\n@@ -412,12 +379,16 @@ impl<'a> FmtVisitor<'a> {\n                       generics: &ast::Generics,\n                       span: Span)\n     {\n-        let header_str = self.format_header(\"enum\", ident, vis);\n+        let header_str = self.format_header(\"enum \", ident, vis);\n         self.changes.push_str_span(span, &header_str);\n \n         let enum_snippet = self.snippet(span);\n         let body_start = span.lo + BytePos(enum_snippet.find_uncommented(\"{\").unwrap() as u32 + 1);\n-        let generics_str = self.format_generics(generics, body_start);\n+        let generics_str = self.format_generics(generics,\n+                                                \" {\",\n+                                                self.block_indent + self.config.tab_spaces,\n+                                                codemap::mk_sp(span.lo,\n+                                                               body_start));\n         self.changes.push_str_span(span, &generics_str);\n \n         self.last_pos = body_start;\n@@ -447,73 +418,183 @@ impl<'a> FmtVisitor<'a> {\n             return;\n         }\n \n-        if let ast::VariantKind::TupleVariantKind(ref types) = field.node.kind {\n-            self.format_missing_with_indent(field.span.lo);\n-\n-            let vis = format_visibility(field.node.vis);\n-            self.changes.push_str_span(field.span, vis);\n-            let name = field.node.name.to_string();\n-            self.changes.push_str_span(field.span, &name);\n+        self.format_missing_with_indent(field.span.lo);\n \n-            let mut result = String::new();\n+        match field.node.kind {\n+            ast::VariantKind::TupleVariantKind(ref types) => {\n+                let vis = format_visibility(field.node.vis);\n+                self.changes.push_str_span(field.span, vis);\n+                let name = field.node.name.to_string();\n+                self.changes.push_str_span(field.span, &name);\n+\n+                let mut result = String::new();\n+\n+                if types.len() > 0 {\n+                    let items = itemize_list(self.codemap,\n+                                             Vec::new(),\n+                                             types.iter(),\n+                                             \",\",\n+                                             \")\",\n+                                             |arg| arg.ty.span.lo,\n+                                             |arg| arg.ty.span.hi,\n+                                             |arg| pprust::ty_to_string(&arg.ty),\n+                                             span_after(field.span, \"(\", self.codemap),\n+                                             next_span_start);\n+\n+                    result.push('(');\n+\n+                    let indent = self.block_indent\n+                                 + vis.len()\n+                                 + field.node.name.to_string().len()\n+                                 + 1; // Open paren\n+\n+                    let comma_cost = if self.config.enum_trailing_comma { 1 } else { 0 };\n+                    let budget = self.config.ideal_width - indent - comma_cost - 1; // 1 = )\n+\n+                    let fmt = ListFormatting {\n+                        tactic: ListTactic::HorizontalVertical,\n+                        separator: \",\",\n+                        trailing_separator: SeparatorTactic::Never,\n+                        indent: indent,\n+                        h_width: budget,\n+                        v_width: budget,\n+                        ends_with_newline: false,\n+                    };\n+                    result.push_str(&write_list(&items, &fmt));\n+                    result.push(')');\n+                }\n \n-            if types.len() > 0 {\n-                let comments = self.make_comments_for_list(Vec::new(),\n-                                                           types.iter().map(|arg| arg.ty.span),\n-                                                           \",\",\n-                                                           \")\",\n-                                                           |span| span.lo,\n-                                                           |span| span.hi,\n-                                                           next_span_start);\n+                if let Some(ref expr) = field.node.disr_expr {\n+                    result.push_str(\" = \");\n+                    let expr_snippet = self.snippet(expr.span);\n+                    result.push_str(&expr_snippet);\n \n-                let type_strings: Vec<_> = types.iter()\n-                                                .map(|arg| pprust::ty_to_string(&arg.ty))\n-                                                .zip(comments.into_iter())\n-                                                .collect();\n+                    // Make sure we do not exceed column limit\n+                    // 4 = \" = ,\"\n+                    assert!(self.config.max_width >= vis.len() + name.len() + expr_snippet.len() + 4,\n+                            \"Enum variant exceeded column limit\");\n+                }\n \n-                result.push('(');\n+                self.changes.push_str_span(field.span, &result);\n \n-                let indent = self.block_indent\n-                             + vis.len()\n-                             + field.node.name.to_string().len()\n-                             + 1; // 1 = (\n-\n-                let comma_cost = if self.config.enum_trailing_comma { 1 } else { 0 };\n-                let budget = self.config.ideal_width - indent - comma_cost - 1; // 1 = )\n-\n-                let fmt = ListFormatting {\n-                    tactic: ListTactic::HorizontalVertical,\n-                    separator: \",\",\n-                    trailing_separator: SeparatorTactic::Never,\n-                    indent: indent,\n-                    h_width: budget,\n-                    v_width: budget,\n-                };\n-                result.push_str(&write_list(&type_strings, &fmt));\n-                result.push(')');\n+                if !last_field || self.config.enum_trailing_comma {\n+                    self.changes.push_str_span(field.span, \",\");\n+                }\n+            },\n+            ast::VariantKind::StructVariantKind(ref struct_def) => {\n+                let result = self.format_struct(\"\",\n+                                                field.node.name,\n+                                                field.node.vis,\n+                                                struct_def,\n+                                                None,\n+                                                field.span,\n+                                                self.block_indent);\n+\n+                self.changes.push_str_span(field.span, &result)\n             }\n+        }\n \n-            if let Some(ref expr) = field.node.disr_expr {\n-                result.push_str(\" = \");\n-                let expr_snippet = self.snippet(expr.span);\n-                result.push_str(&expr_snippet);\n+        self.last_pos = field.span.hi + BytePos(1);\n+    }\n \n-                // Make sure we do not exceed column limit\n-                // 4 = \" = ,\"\n-                assert!(self.config.max_width >= vis.len() + name.len() + expr_snippet.len() + 4,\n-                        \"Enum variant exceeded column limit\");\n-            }\n+    fn format_struct(&self,\n+                     item_name: &str,\n+                     ident: ast::Ident,\n+                     vis: ast::Visibility,\n+                     struct_def: &ast::StructDef,\n+                     generics: Option<&ast::Generics>,\n+                     span: Span,\n+                     offset: usize) -> String\n+    {\n+        let mut result = String::with_capacity(1024);\n \n-            self.changes.push_str_span(field.span, &result);\n+        let header_str = self.format_header(item_name, ident, vis);\n+        result.push_str(&header_str);\n \n-            if !last_field || self.config.enum_trailing_comma {\n-                self.changes.push_str_span(field.span, \",\");\n-            }\n+        if struct_def.fields.len() == 0 {\n+            result.push(';');\n+            return result;\n         }\n \n-        // TODO: deal with struct-like variants\n+        let is_tuple = match struct_def.fields[0].node.kind {\n+            ast::StructFieldKind::NamedField(..) => false,\n+            ast::StructFieldKind::UnnamedField(..) => true\n+        };\n \n-        self.last_pos = field.span.hi + BytePos(1);\n+        let (opener, terminator) = if is_tuple { (\"(\", \")\") } else { (\" {\", \"}\") };\n+\n+        let generics_str = match generics {\n+            Some(g) => self.format_generics(g,\n+                                            opener,\n+                                            offset + header_str.len(),\n+                                            codemap::mk_sp(span.lo,\n+                                                           struct_def.fields[0].span.lo)),\n+            None => opener.to_owned()\n+        };\n+        result.push_str(&generics_str);\n+\n+        let items = itemize_list(self.codemap,\n+                                 Vec::new(),\n+                                 struct_def.fields.iter(),\n+                                 \",\",\n+                                 terminator,\n+                                 |field| {\n+                                      // Include attributes and doc comments,\n+                                      // if present\n+                                      if field.node.attrs.len() > 0 {\n+                                          field.node.attrs[0].span.lo\n+                                      } else {\n+                                          field.span.lo\n+                                      }\n+                                 },\n+                                 |field| field.node.ty.span.hi,\n+                                 |field| self.format_field(field),\n+                                 span_after(span, opener.trim(), self.codemap),\n+                                 span.hi);\n+\n+        // 2 terminators and a semicolon\n+        let used_budget = offset + header_str.len() + generics_str.len() + 3;\n+\n+        // Conservative approximation\n+        let single_line_cost = (span.hi - struct_def.fields[0].span.lo).0;\n+        let break_line = !is_tuple ||\n+                         generics_str.contains('\\n') ||\n+                         single_line_cost as usize + used_budget > self.config.max_width;\n+\n+        if break_line {\n+            let indentation = make_indent(offset + self.config.tab_spaces);\n+            result.push('\\n');\n+            result.push_str(&indentation);\n+        }\n+\n+        let tactic = if break_line { ListTactic::Vertical } else { ListTactic::Horizontal };\n+\n+        // 1 = ,\n+        let budget = self.config.ideal_width - offset + self.config.tab_spaces - 1;\n+        let fmt = ListFormatting {\n+            tactic: tactic,\n+            separator: \",\",\n+            trailing_separator: self.config.struct_trailing_comma,\n+            indent: offset + self.config.tab_spaces,\n+            h_width: self.config.max_width,\n+            v_width: budget,\n+            ends_with_newline: false,\n+        };\n+\n+        result.push_str(&write_list(&items, &fmt));\n+\n+        if break_line {\n+            result.push('\\n');\n+            result.push_str(&make_indent(offset));\n+        }\n+\n+        result.push_str(terminator);\n+\n+        if is_tuple {\n+            result.push(';');\n+        }\n+\n+        result\n     }\n \n     pub fn visit_struct(&mut self,\n@@ -523,34 +604,16 @@ impl<'a> FmtVisitor<'a> {\n                         generics: &ast::Generics,\n                         span: Span)\n     {\n-        let header_str = self.format_header(\"struct\", ident, vis);\n-        self.changes.push_str_span(span, &header_str);\n-\n-        if struct_def.fields.len() == 0 {\n-            assert!(generics.where_clause.predicates.len() == 0,\n-                    \"No-field struct with where clause?\");\n-            assert!(generics.lifetimes.len() == 0, \"No-field struct with generics?\");\n-            assert!(generics.ty_params.len() == 0, \"No-field struct with generics?\");\n-\n-            self.changes.push_str_span(span, \";\");\n-            return;\n-        }\n-\n-        let generics_str = self.format_generics(generics, struct_def.fields[0].span.lo);\n-        self.changes.push_str_span(span, &generics_str);\n-\n-        let struct_snippet = self.snippet(span);\n-        // This will drop the comment in between the header and body.\n-        self.last_pos = span.lo + BytePos(struct_snippet.find_uncommented(\"{\").unwrap() as u32 + 1);\n-\n-        self.block_indent += self.config.tab_spaces;\n-        for (i, f) in struct_def.fields.iter().enumerate() {\n-            self.visit_field(f, i == struct_def.fields.len() - 1, span.lo, &struct_snippet);\n-        }\n-        self.block_indent -= self.config.tab_spaces;\n-\n-        self.format_missing_with_indent(span.lo + BytePos(struct_snippet.rfind('}').unwrap() as u32));\n-        self.changes.push_str_span(span, \"}\");\n+        let indent = self.block_indent;\n+        let result = self.format_struct(\"struct \",\n+                                        ident,\n+                                        vis,\n+                                        struct_def,\n+                                        Some(generics),\n+                                        span,\n+                                        indent);\n+        self.changes.push_str_span(span, &result);\n+        self.last_pos = span.hi;\n     }\n \n     fn format_header(&self,\n@@ -559,42 +622,37 @@ impl<'a> FmtVisitor<'a> {\n                      vis: ast::Visibility)\n         -> String\n     {\n-        format!(\"{}{} {}\", format_visibility(vis), item_name, &token::get_ident(ident))\n+        format!(\"{}{}{}\", format_visibility(vis), item_name, &token::get_ident(ident))\n     }\n \n     fn format_generics(&self,\n                        generics: &ast::Generics,\n-                       span_end: BytePos)\n+                       opener: &str,\n+                       offset: usize,\n+                       span: Span)\n         -> String\n     {\n-        let mut result = self.rewrite_generics(generics, self.block_indent, span_end);\n+        let mut result = self.rewrite_generics(generics, offset, span);\n \n-        if generics.where_clause.predicates.len() > 0 {\n+        if generics.where_clause.predicates.len() > 0 || result.contains('\\n') {\n             result.push_str(&self.rewrite_where_clause(&generics.where_clause,\n-                                                             self.block_indent,\n-                                                             span_end));\n+                                                       self.block_indent,\n+                                                       span.hi));\n             result.push_str(&make_indent(self.block_indent));\n-            result.push_str(\"\\n{\");\n-\n+            result.push('\\n');\n+            result.push_str(opener.trim());\n         } else {\n-            result.push_str(\" {\");\n+            result.push_str(opener);\n         }\n \n         result\n     }\n \n     // Field of a struct\n-    fn visit_field(&mut self,\n-                   field: &ast::StructField,\n-                   last_field: bool,\n-                   // These two args are for missing spans hacks.\n-                   struct_start: BytePos,\n-                   struct_snippet: &str)\n-    {\n-        if self.visit_attrs(&field.node.attrs) {\n-            return;\n+    fn format_field(&self, field: &ast::StructField) -> String {\n+        if contains_skip(&field.node.attrs) {\n+            return self.snippet(codemap::mk_sp(field.node.attrs[0].span.lo, field.span.hi));\n         }\n-        self.format_missing_with_indent(field.span.lo);\n \n         let name = match field.node.kind {\n             ast::StructFieldKind::NamedField(ident, _) => Some(token::get_ident(ident)),\n@@ -606,38 +664,20 @@ impl<'a> FmtVisitor<'a> {\n         };\n         let typ = pprust::ty_to_string(&field.node.ty);\n \n-        let mut field_str = match name {\n-            Some(name) => {\n-                let budget = self.config.ideal_width - self.block_indent;\n-                // 3 is being conservative and assuming that there will be a trailing comma.\n-                if self.block_indent + vis.len() + name.len() + typ.len() + 3 > budget {\n-                    format!(\"{}{}:\\n{}{}\",\n-                            vis,\n-                            name,\n-                            &make_indent(self.block_indent + self.config.tab_spaces),\n-                            typ)\n-                } else {\n-                    format!(\"{}{}: {}\", vis, name, typ)\n-                }\n-            }\n-            None => format!(\"{}{}\", vis, typ),\n-        };\n-        if !last_field || self.config.struct_trailing_comma {\n-            field_str.push(',');\n+        let indent = self.block_indent + self.config.tab_spaces;\n+        let mut attr_str = self.rewrite_attrs(&field.node.attrs, indent);\n+        if attr_str.len() > 0 {\n+            attr_str.push('\\n');\n+            attr_str.push_str(&make_indent(indent));\n+        }\n+\n+        match name {\n+            Some(name) => format!(\"{}{}{}: {}\", attr_str, vis, name, typ),\n+            None => format!(\"{}{}{}\", attr_str, vis, typ)\n         }\n-        self.changes.push_str_span(field.span, &field_str);\n-\n-        // This hack makes sure we only add comments etc. after the comma, and\n-        // makes sure we don't repeat any commas.\n-        let hi = field.span.hi;\n-        let comma_pos = match struct_snippet[(hi.0 - struct_start.0) as usize..].find_uncommented(\",\") {\n-            Some(i) => i,\n-            None => 0,\n-        };\n-        self.last_pos = hi + BytePos(comma_pos as u32 + 1);\n     }\n \n-    fn rewrite_generics(&self, generics: &ast::Generics, indent: usize, span_end: BytePos) -> String {\n+    fn rewrite_generics(&self, generics: &ast::Generics, offset: usize, span: Span) -> String {\n         // FIXME convert bounds to where clauses where they get too big or if\n         // there is a where clause at all.\n         let mut result = String::new();\n@@ -647,7 +687,7 @@ impl<'a> FmtVisitor<'a> {\n             return result;\n         }\n \n-        let budget = self.config.max_width - indent - 2;\n+        let budget = self.config.max_width - offset - 2;\n         // TODO might need to insert a newline if the generics are really long\n         result.push('<');\n \n@@ -665,30 +705,32 @@ impl<'a> FmtVisitor<'a> {\n             codemap::mk_sp(l.lifetime.span.lo, hi)\n         });\n         let ty_spans = tys.iter().map(span_for_ty_param);\n-        let comments = self.make_comments_for_list(Vec::new(),\n-                                                   lt_spans.chain(ty_spans),\n-                                                   \",\",\n-                                                   \">\",\n-                                                   |sp| sp.lo,\n-                                                   |sp| sp.hi,\n-                                                   span_end);\n-\n-        // If there are // comments, keep them multi-line.\n-        let mut list_tactic = ListTactic::HorizontalVertical;\n-        if comments.iter().any(|c| c.contains(\"//\")) {\n-            list_tactic = ListTactic::Vertical;\n+\n+        let mut items = itemize_list(self.codemap,\n+                                     Vec::new(),\n+                                     lt_spans.chain(ty_spans),\n+                                     \",\",\n+                                     \">\",\n+                                     |sp| sp.lo,\n+                                     |sp| sp.hi,\n+                                     |_| String::new(),\n+                                     span_after(span, \"<\", self.codemap),\n+                                     span.hi);\n+\n+        for (item, ty) in items.iter_mut().zip(lt_strs.chain(ty_strs)) {\n+            item.item = ty;\n         }\n \n-        let generics_strs: Vec<_> = lt_strs.chain(ty_strs).zip(comments.into_iter()).collect();\n         let fmt = ListFormatting {\n-            tactic: list_tactic,\n+            tactic: ListTactic::HorizontalVertical,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::Never,\n-            indent: indent + 1,\n+            indent: offset + 1,\n             h_width: budget,\n             v_width: budget,\n+            ends_with_newline: true,\n         };\n-        result.push_str(&write_list(&generics_strs, &fmt));\n+        result.push_str(&write_list(&items, &fmt));\n \n         result.push('>');\n \n@@ -710,18 +752,17 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&make_indent(indent + 4));\n         result.push_str(\"where \");\n \n-        let comments = self.make_comments_for_list(Vec::new(),\n-                                                   where_clause.predicates.iter(),\n-                                                   \",\",\n-                                                   \"{\",\n-                                                   |pred| span_for_where_pred(pred).lo,\n-                                                   |pred| span_for_where_pred(pred).hi,\n-                                                   span_end);\n-\n-        let where_strs: Vec<_> = where_clause.predicates.iter()\n-                                                        .map(|p| (self.rewrite_pred(p)))\n-                                                        .zip(comments.into_iter())\n-                                                        .collect();\n+        let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n+        let items = itemize_list(self.codemap,\n+                                 Vec::new(),\n+                                 where_clause.predicates.iter(),\n+                                 \",\",\n+                                 \"{\",\n+                                 |pred| span_for_where_pred(pred).lo,\n+                                 |pred| span_for_where_pred(pred).hi,\n+                                 |pred| self.rewrite_pred(pred),\n+                                 span_start,\n+                                 span_end);\n \n         let budget = self.config.ideal_width + self.config.leeway - indent - 10;\n         let fmt = ListFormatting {\n@@ -731,8 +772,9 @@ impl<'a> FmtVisitor<'a> {\n             indent: indent + 10,\n             h_width: budget,\n             v_width: budget,\n+            ends_with_newline: true,\n         };\n-        result.push_str(&write_list(&where_strs, &fmt));\n+        result.push_str(&write_list(&items, &fmt));\n \n         result\n     }"}, {"sha": "5ee68e70cf5560e4da889e2c3c62e06b13e3d1a1", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -62,6 +62,8 @@ mod expr;\n mod imports;\n mod issues;\n mod rewrite;\n+mod string;\n+mod comment;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip."}, {"sha": "adabb00566c5b6f899030aff6254721d107e7cbc", "filename": "src/lists.rs", "status": "modified", "additions": 206, "deletions": 34, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -8,7 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use utils::make_indent;\n+use std::cmp;\n+\n+use syntax::codemap::{self, CodeMap, BytePos};\n+\n+use utils::{round_up_to_power_of_two, make_indent};\n+use comment::{FindUncommented, rewrite_comment, find_comment_end};\n+use string::before;\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum ListTactic {\n@@ -41,11 +47,38 @@ pub struct ListFormatting<'a> {\n     pub h_width: usize,\n     // Available width if we layout vertically\n     pub v_width: usize,\n+    // Non-expressions, e.g. items, will have a new line at the end of the list.\n+    // Important for comment styles.\n+    pub ends_with_newline: bool\n+}\n+\n+pub struct ListItem {\n+    pub pre_comment: Option<String>,\n+    // Item should include attributes and doc comments\n+    pub item: String,\n+    pub post_comment: Option<String>\n }\n \n-// Format a list of strings into a string.\n-// Precondition: all strings in items are trimmed.\n-pub fn write_list<'b>(items: &[(String, String)], formatting: &ListFormatting<'b>) -> String {\n+impl ListItem {\n+    pub fn is_multiline(&self) -> bool {\n+        self.item.contains('\\n') ||\n+        self.pre_comment.is_some() ||\n+        self.post_comment.as_ref().map(|s| s.contains('\\n')).unwrap_or(false)\n+    }\n+\n+    pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n+        ListItem {\n+            pre_comment: None,\n+            item: s.into(),\n+            post_comment: None\n+        }\n+    }\n+}\n+\n+// Format a list of commented items into a string.\n+// FIXME: this has grown into a monstrosity\n+// TODO: add unit tests\n+pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> String {\n     if items.len() == 0 {\n         return String::new();\n     }\n@@ -68,7 +101,7 @@ pub fn write_list<'b>(items: &[(String, String)], formatting: &ListFormatting<'b\n         debug!(\"write_list: total_width: {}, total_sep_len: {}, h_width: {}\",\n                total_width, total_sep_len, formatting.h_width);\n         tactic = if fits_single &&\n-                    !items.iter().any(|&(ref s, _)| s.contains('\\n')) {\n+                    !items.iter().any(ListItem::is_multiline) {\n             ListTactic::Horizontal\n         } else {\n             ListTactic::Vertical\n@@ -81,6 +114,11 @@ pub fn write_list<'b>(items: &[(String, String)], formatting: &ListFormatting<'b\n         tactic = ListTactic::Horizontal;\n     }\n \n+    // Switch to vertical mode if we find non-block comments.\n+    if items.iter().any(has_line_pre_comment) {\n+        tactic = ListTactic::Vertical;\n+    }\n+\n     // Now that we know how we will layout, we can decide for sure if there\n     // will be a trailing separator.\n     let trailing_separator = needs_trailing_separator(formatting.trailing_separator, tactic);\n@@ -92,13 +130,16 @@ pub fn write_list<'b>(items: &[(String, String)], formatting: &ListFormatting<'b\n     } else {\n         total_width + items.len() * (formatting.indent + 1)\n     };\n-    let mut result = String::with_capacity(alloc_width);\n+    let mut result = String::with_capacity(round_up_to_power_of_two(alloc_width));\n \n     let mut line_len = 0;\n     let indent_str = &make_indent(formatting.indent);\n-    for (i, &(ref item, ref comment)) in items.iter().enumerate() {\n+    for (i, item) in items.iter().enumerate() {\n         let first = i == 0;\n-        let separate = i != items.len() - 1 || trailing_separator;\n+        let last = i == items.len() - 1;\n+        let separate = !last || trailing_separator;\n+        let item_sep_len = if separate { sep_len } else { 0 };\n+        let item_width = item.item.len() + item_sep_len;\n \n         match tactic {\n             ListTactic::Horizontal if !first => {\n@@ -109,12 +150,9 @@ pub fn write_list<'b>(items: &[(String, String)], formatting: &ListFormatting<'b\n                 result.push_str(indent_str);\n             }\n             ListTactic::Mixed => {\n-                let mut item_width = item.len();\n-                if separate {\n-                    item_width += sep_len;\n-                }\n+                let total_width = total_item_width(item) + item_sep_len;\n \n-                if line_len > 0 && line_len + item_width > formatting.v_width {\n+                if line_len > 0 && line_len + total_width > formatting.v_width {\n                     result.push('\\n');\n                     result.push_str(indent_str);\n                     line_len = 0;\n@@ -125,30 +163,155 @@ pub fn write_list<'b>(items: &[(String, String)], formatting: &ListFormatting<'b\n                     line_len += 1;\n                 }\n \n-                line_len += item_width;\n+                line_len += total_width;\n             }\n             _ => {}\n         }\n \n-        result.push_str(item);\n+        // Pre-comments\n+        if let Some(ref comment) = item.pre_comment {\n+            result.push_str(&rewrite_comment(comment,\n+                                             // Block style in non-vertical mode\n+                                             tactic != ListTactic::Vertical,\n+                                             // Width restriction is only\n+                                             // relevant in vertical mode.\n+                                             formatting.v_width,\n+                                             formatting.indent));\n \n-        if tactic != ListTactic::Vertical && comment.len() > 0 {\n-            if !comment.starts_with('\\n') {\n+            if tactic == ListTactic::Vertical {\n+                result.push('\\n');\n+                result.push_str(indent_str);\n+            } else {\n                 result.push(' ');\n             }\n-            result.push_str(comment);\n+        }\n+\n+        result.push_str(&item.item);\n+\n+        // Post-comments\n+        if tactic != ListTactic::Vertical && item.post_comment.is_some() {\n+            let formatted_comment = rewrite_comment(item.post_comment.as_ref().unwrap(),\n+                                                    true,\n+                                                    formatting.v_width,\n+                                                    0);\n+\n+            result.push(' ');\n+            result.push_str(&formatted_comment);\n         }\n \n         if separate {\n             result.push_str(formatting.separator);\n         }\n \n-        if tactic == ListTactic::Vertical && comment.len() > 0 {\n-            if !comment.starts_with('\\n') {\n-                result.push(' ');\n+        if tactic == ListTactic::Vertical && item.post_comment.is_some() {\n+            // 1 = space between item and comment.\n+            let width = formatting.v_width.checked_sub(item_width + 1).unwrap_or(1);\n+            let offset = formatting.indent + item_width + 1;\n+            let comment = item.post_comment.as_ref().unwrap();\n+            // Use block-style only for the last item or multiline comments.\n+            let block_style = formatting.ends_with_newline && last ||\n+                              comment.trim().contains('\\n') ||\n+                              comment.trim().len() > width;\n+\n+            let formatted_comment = rewrite_comment(comment, block_style, width, offset);\n+\n+            result.push(' ');\n+            result.push_str(&formatted_comment);\n+        }\n+    }\n+\n+    result\n+}\n+\n+fn has_line_pre_comment(item: &ListItem) -> bool {\n+    match item.pre_comment {\n+        Some(ref comment) => comment.starts_with(\"//\"),\n+        None => false\n+    }\n+}\n+\n+// Turns a list into a vector of items with associated comments.\n+// TODO: we probably do not want to take a terminator any more. Instead, we\n+// should demand a proper span end.\n+pub fn itemize_list<T, I, F1, F2, F3>(codemap: &CodeMap,\n+                                      prefix: Vec<ListItem>,\n+                                      it: I,\n+                                      separator: &str,\n+                                      terminator: &str,\n+                                      get_lo: F1,\n+                                      get_hi: F2,\n+                                      get_item_string: F3,\n+                                      mut prev_span_end: BytePos,\n+                                      next_span_start: BytePos)\n+    -> Vec<ListItem>\n+    where I: Iterator<Item=T>,\n+          F1: Fn(&T) -> BytePos,\n+          F2: Fn(&T) -> BytePos,\n+          F3: Fn(&T) -> String\n+{\n+    let mut result = prefix;\n+    let mut new_it = it.peekable();\n+    let white_space: &[_] = &[' ', '\\t'];\n+\n+    while let Some(item) = new_it.next() {\n+        // Pre-comment\n+        let pre_snippet = codemap.span_to_snippet(codemap::mk_sp(prev_span_end,\n+                                                                get_lo(&item)))\n+                                 .unwrap();\n+        let pre_snippet = pre_snippet.trim();\n+        let pre_comment = if pre_snippet.len() > 0 {\n+            Some(pre_snippet.to_owned())\n+        } else {\n+            None\n+        };\n+\n+        // Post-comment\n+        let next_start = match new_it.peek() {\n+            Some(ref next_item) => get_lo(next_item),\n+            None => next_span_start\n+        };\n+        let post_snippet = codemap.span_to_snippet(codemap::mk_sp(get_hi(&item),\n+                                                                  next_start))\n+                                  .unwrap();\n+\n+        let comment_end = match new_it.peek() {\n+            Some(..) => {\n+                if let Some(start) = before(&post_snippet, \"/*\", \"\\n\") {\n+                    // Block-style post-comment. Either before or after the separator.\n+                    cmp::max(find_comment_end(&post_snippet[start..]).unwrap() + start,\n+                             post_snippet.find_uncommented(separator).unwrap() + separator.len())\n+                } else if let Some(idx) = post_snippet.find('\\n') {\n+                    idx + 1\n+                } else {\n+                    post_snippet.len()\n+                }\n+            },\n+            None => {\n+                post_snippet.find_uncommented(terminator)\n+                            .unwrap_or(post_snippet.len())\n             }\n-            result.push_str(comment);\n+        };\n+\n+        prev_span_end = get_hi(&item) + BytePos(comment_end as u32);\n+        let mut post_snippet = post_snippet[..comment_end].trim();\n+\n+        if post_snippet.starts_with(separator) {\n+            post_snippet = post_snippet[separator.len()..]\n+                .trim_matches(white_space);\n+        } else if post_snippet.ends_with(separator) {\n+            post_snippet = post_snippet[..post_snippet.len()-separator.len()]\n+                .trim_matches(white_space);\n         }\n+\n+        result.push(ListItem {\n+            pre_comment: pre_comment,\n+            item: get_item_string(&item),\n+            post_comment: if post_snippet.len() > 0 {\n+                Some(post_snippet.to_owned())\n+            } else {\n+                None\n+            }\n+        });\n     }\n \n     result\n@@ -162,16 +325,25 @@ fn needs_trailing_separator(separator_tactic: SeparatorTactic, list_tactic: List\n     }\n }\n \n-fn calculate_width(items:&[(String, String)]) -> usize {\n-    let missed_width = items.iter().map(|&(_, ref s)| {\n-        let text_len = s.trim().len();\n-        if text_len > 0 {\n-            // We'll put a space before any comment.\n-            text_len + 1\n-        } else {\n-            text_len\n-        }\n-    }).fold(0, |a, l| a + l);\n-    let item_width = items.iter().map(|&(ref s, _)| s.len()).fold(0, |a, l| a + l);\n-    missed_width + item_width\n+fn calculate_width(items: &[ListItem]) -> usize {\n+    items.iter().map(total_item_width).fold(0, |a, l| a + l)\n+}\n+\n+fn total_item_width(item: &ListItem) -> usize {\n+    comment_len(&item.pre_comment) + comment_len(&item.post_comment) + item.item.len()\n+}\n+\n+fn comment_len(comment: &Option<String>) -> usize {\n+    match comment {\n+        &Some(ref s) => {\n+            let text_len = s.trim().len();\n+            if text_len > 0 {\n+                // We'll put \" /*\" before and \" */\" after inline comments.\n+                text_len + 6\n+            } else {\n+                text_len\n+            }\n+        },\n+        &None => 0\n+    }\n }"}, {"sha": "d474fdb468efcf5f63f0d2946e1bc7edb01f942f", "filename": "src/string.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Format string literals.\n+\n+use utils::{make_indent, next_char, prev_char, round_up_to_power_of_two};\n+\n+use MIN_STRING;\n+\n+pub struct StringFormat<'a> {\n+    pub opener: &'a str,\n+    pub closer: &'a str,\n+    pub line_start: &'a str,\n+    pub line_end: &'a str,\n+    pub width: usize,\n+    pub offset: usize,\n+    pub trim_end: bool,\n+}\n+\n+// TODO: simplify this!\n+pub fn rewrite_string<'a>(s: &str, fmt: &StringFormat<'a>) -> String {\n+    // FIXME I bet this stomps unicode escapes in the source string\n+    // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n+\n+    let indent = make_indent(fmt.offset);\n+    let indent = &indent;\n+\n+    let mut cur_start = 0;\n+    let mut result = String::with_capacity(round_up_to_power_of_two(s.len()));\n+    result.push_str(fmt.opener);\n+\n+    let ender_length = fmt.line_end.len();\n+    let max_chars = fmt.width.checked_sub(fmt.opener.len()).unwrap_or(0)\n+                             .checked_sub(ender_length).unwrap_or(1);\n+\n+    loop {\n+        let mut cur_end = cur_start + max_chars;\n+\n+        if cur_end >= s.len() {\n+            result.push_str(&s[cur_start..]);\n+            break;\n+        }\n+\n+        // Make sure we're on a char boundary.\n+        cur_end = next_char(&s, cur_end);\n+\n+        // Push cur_end left until we reach whitespace.\n+        while !s.char_at(cur_end - 1).is_whitespace() {\n+            cur_end = prev_char(&s, cur_end);\n+\n+            if cur_end - cur_start < MIN_STRING {\n+                // We can't break at whitespace, fall back to splitting\n+                // anywhere that doesn't break an escape sequence.\n+                cur_end = next_char(&s, cur_start + max_chars);\n+                while s.char_at(prev_char(&s, cur_end)) == '\\\\' {\n+                    cur_end = prev_char(&s, cur_end);\n+                }\n+                break;\n+            }\n+        }\n+        // Make sure there is no whitespace to the right of the break.\n+        while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n+            cur_end = next_char(&s, cur_end + 1);\n+        }\n+\n+        let line: &str = if fmt.trim_end {\n+            &s[cur_start..cur_end].trim_right_matches(char::is_whitespace)\n+        } else {\n+            &s[cur_start..cur_end]\n+        };\n+\n+        result.push_str(line);\n+        result.push_str(fmt.line_end);\n+        result.push('\\n');\n+        result.push_str(indent);\n+        result.push_str(fmt.line_start);\n+\n+        cur_start = cur_end;\n+    }\n+    result.push_str(fmt.closer);\n+\n+    result\n+}\n+\n+#[inline]\n+// Checks if a appears before b in given string and, if so, returns the index of\n+// a.\n+// FIXME: could be more generic\n+pub fn before<'x>(s: &'x str, a: &str, b: &str) -> Option<usize> {\n+    s.find(a).and_then(|i| {\n+        match s.find(b) {\n+            Some(j) if j <= i => None,\n+            _ => Some(i)\n+        }\n+    })\n+}"}, {"sha": "de17f989f7a9f6ce130fc6f6c7b6175f70afdd41", "filename": "src/utils.rs", "status": "modified", "additions": 20, "deletions": 62, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -8,72 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast::Visibility;\n+use syntax::ast::{Visibility, Attribute, MetaItem, MetaItem_};\n+use syntax::codemap::{CodeMap, Span, BytePos};\n \n-pub trait FindUncommented {\n-    fn find_uncommented(&self, pat: &str) -> Option<usize>;\n-}\n-\n-impl FindUncommented for str {\n-    fn find_uncommented(&self, pat: &str) -> Option<usize> {\n-        let mut needle_iter = pat.chars();\n-        let mut possible_comment = false;\n-\n-        for (i, b) in self.char_indices() {\n-            match needle_iter.next() {\n-                Some(c) => {\n-                    if b != c {\n-                        needle_iter = pat.chars();\n-                    }\n-                },\n-                None => return Some(i - pat.len())\n-            }\n-\n-            if possible_comment {\n-                if b == '/' {\n-                    return self[(i+1)..].find('\\n')\n-                                        .and_then(|end| {\n-                                            self[(end + i + 2)..].find_uncommented(pat)\n-                                                                 .map(|idx| idx + end + i + 2)\n-                                        });\n-                } else if b == '*' {\n-                    return self[(i+1)..].find(\"*/\")\n-                                        .and_then(|end| {\n-                                            self[(end + i + 3)..].find_uncommented(pat)\n-                                                                 .map(|idx| idx + end + i + 3)\n-                                        });\n-                } else {\n-                    possible_comment = false;\n-                }\n-            } else {\n-                possible_comment = b == '/';\n-            }\n-        }\n+use comment::FindUncommented;\n \n-        // Handle case where the pattern is a suffix of the search string\n-        match needle_iter.next() {\n-            Some(_) => None,\n-            None => Some(self.len() - pat.len())\n-        }\n-    }\n-}\n+use SKIP_ANNOTATION;\n \n-#[test]\n-fn test_find_uncommented() {\n-    fn check(haystack: &str, needle: &str, expected: Option<usize>) {\n-        assert_eq!(expected, haystack.find_uncommented(needle));\n-    }\n+#[inline]\n+pub fn span_after(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n+    let snippet = codemap.span_to_snippet(original).unwrap();\n \n-    check(\"/*//*/test\", \"test\", Some(6));\n-    check(\"//test\\ntest\", \"test\", Some(7));\n-    check(\"/* comment only */\", \"whatever\", None);\n-    check(\"/* comment */ some text /* more commentary */ result\", \"result\", Some(46));\n-    check(\"sup // sup\", \"p\", Some(2));\n-    check(\"sup\", \"x\", None);\n-    check(\"\u03c0? /**/ \u03c0 is nice!\", \"\u03c0 is nice\", Some(9));\n-    check(\"/*sup yo? \\n sup*/ sup\", \"p\", Some(20));\n-    check(\"hel/*lohello*/lo\", \"hello\", None);\n-    check(\"acb\", \"ab\", None);\n+    original.lo + BytePos(snippet.find_uncommented(needle).unwrap() as u32 + 1)\n }\n \n #[inline]\n@@ -114,6 +60,18 @@ pub fn format_visibility(vis: Visibility) -> &'static str {\n     }\n }\n \n+fn is_skip(meta_item: &MetaItem) -> bool {\n+    match meta_item.node {\n+        MetaItem_::MetaWord(ref s) => *s == SKIP_ANNOTATION,\n+        _ => false,\n+    }\n+}\n+\n+#[inline]\n+pub fn contains_skip(attrs: &[Attribute]) -> bool {\n+    attrs.iter().any(|a| is_skip(&a.node.value))\n+}\n+\n #[inline]\n #[cfg(target_pointer_width=\"64\")]\n // Based on the trick layed out at"}, {"sha": "ebd59f0cf20670e73b2d08d904cc153eb0e873cf", "filename": "src/visitor.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -15,7 +15,6 @@ use syntax::visit;\n use utils;\n use config::Config;\n \n-use SKIP_ANNOTATION;\n use changes::ChangeSet;\n use rewrite::{Rewrite, RewriteContext};\n \n@@ -120,7 +119,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                              constness,\n                                              abi,\n                                              vis,\n-                                             b.span.lo);\n+                                             codemap::mk_sp(s.lo, b.span.lo));\n                 self.changes.push_str_span(s, &new_fn);\n             }\n             visit::FkMethod(ident, ref sig, vis) => {\n@@ -133,7 +132,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                              &sig.constness,\n                                              &sig.abi,\n                                              vis.unwrap_or(ast::Visibility::Inherited),\n-                                             b.span.lo);\n+                                             codemap::mk_sp(s.lo, b.span.lo));\n                 self.changes.push_str_span(s, &new_fn);\n             }\n             visit::FkFnBlock(..) => {}\n@@ -305,26 +304,22 @@ impl<'a> FmtVisitor<'a> {\n         let first = &attrs[0];\n         self.format_missing_with_indent(first.span.lo);\n \n-        match self.rewrite_attrs(attrs, self.block_indent) {\n-            Some(s) => {\n-                self.changes.push_str_span(first.span, &s);\n-                let last = attrs.last().unwrap();\n-                self.last_pos = last.span.hi;\n-                false\n-            }\n-            None => true\n+        if utils::contains_skip(attrs) {\n+            true\n+        } else {\n+            let rewrite = self.rewrite_attrs(attrs, self.block_indent);\n+            self.changes.push_str_span(first.span, &rewrite);\n+            let last = attrs.last().unwrap();\n+            self.last_pos = last.span.hi;\n+            false\n         }\n     }\n \n-    fn rewrite_attrs(&self, attrs: &[ast::Attribute], indent: usize) -> Option<String> {\n+    pub fn rewrite_attrs(&self, attrs: &[ast::Attribute], indent: usize) -> String {\n         let mut result = String::new();\n         let indent = utils::make_indent(indent);\n \n         for (i, a) in attrs.iter().enumerate() {\n-            if is_skip(&a.node.value) {\n-                return None;\n-            }\n-\n             let a_str = self.snippet(a.span);\n \n             if i > 0 {\n@@ -351,13 +346,6 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n \n-        Some(result)\n-    }\n-}\n-\n-fn is_skip(meta_item: &ast::MetaItem) -> bool {\n-    match meta_item.node {\n-        ast::MetaItem_::MetaWord(ref s) => *s == SKIP_ANNOTATION,\n-        _ => false,\n+        result\n     }\n }"}, {"sha": "da39ac1a8f4463803f244cfb66ff4ad97c1e3762", "filename": "tests/config/small_tabs.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconfig%2Fsmall_tabs.toml?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -6,7 +6,7 @@ newline_style = \"Unix\"\n fn_brace_style = \"SameLineWhere\"\n fn_return_indent = \"WithArgs\"\n fn_args_paren_newline = true\n-struct_trailing_comma = true\n+struct_trailing_comma = \"Vertical\"\n struct_lit_trailing_comma = \"Vertical\"\n enum_trailing_comma = true\n report_todo = \"Always\""}, {"sha": "9bcf31667222b8af75706bf2a1f8c6e320163db4", "filename": "tests/source/fn-simple.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fsource%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fsource%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ffn-simple.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -0,0 +1,11 @@\n+\n+fn simple(/*pre-comment on a function!?*/ i: i32/*yes, it's possible!  */   \n+                                        ,response: NoWay /* hose */) {\"cool\"}\n+\n+\n+fn weird_comment(/* /*/ double level */ comment */ x: Hello /*/*/* tripple, even */*/*/,\n+// Does this work?\n+y: World\n+) {\n+        simple(/* does this preserve comments now? */ 42, NoWay)\n+}"}, {"sha": "04ecb2bc7341f3b665a44fa6754c416a8836ebf3", "filename": "tests/source/multiple.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fsource%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fsource%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmultiple.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -43,7 +43,7 @@ fn qux(a: dadsfa,   // Comment 1\n \n /// Blah blah blah.\n impl Bar {\n-    fn foo(&mut self, a: sdfsdfcccccccccccccccccccccccccccccccccccccccccccccccccccccccc, // comment on a\n+    fn foo(&mut self, a: sdfsdfcccccccccccccccccccccccccccccccccccccccccccccccccc, // comment on a\n            b: sdfasdfsdfasfs /*closing comment*/ ) -> isize {}\n \n     /// Blah blah blah.\n@@ -107,21 +107,3 @@ fn main() {\n       let x = \"Hello!!!!!!!!! abcd  abcd abcd abcd abcd abcd\\n abcd abcd abcd abcd abcd abcd abcd abcd abcd \\\n                    abcd  abcd abcd abcd abcd abcd abcd abcd abcd abcd \\\n                     abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd\";  }\n-\n-\n-fn struct_lits() {\n-    let x = Bar;\n-    // Comment\n-    let y = Foo { a: x };\n-    Foo { a: foo() /* comment*/, /* comment*/ b: bar(), ..something };\n-    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(), b: bar(), };\n-    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo {\n-        // Comment\n-        a: foo(), // Comment\n-        // Comment\n-        b: bar(), // Comment\n-    };\n-\n-    Foo { a: Bar,\n-          b: foo() };\n-}"}, {"sha": "b7e1a854b0ba3e62d056161a703d64ec985df78f", "filename": "tests/source/struct_lits.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fsource%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fsource%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstruct_lits.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -0,0 +1,37 @@\n+// Struct literal expressions.\n+\n+fn main() {\n+    let x = Bar;\n+\n+    // Comment\n+    let y = Foo {a: x };\n+\n+    Foo { a: foo() /* comment*/, /* comment*/ b: bar(), ..something };\n+\n+    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(), b: bar(), };\n+\n+    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo {\n+        // Comment\n+        a: foo(), // Comment\n+        // Comment\n+        b: bar(), // Comment\n+    };\n+\n+    Foo { a:Bar,\n+          b:foo() };\n+\n+    A { \n+    // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor.\n+    first: item(),\n+        // Praesent et diam eget libero egestas mattis sit amet vitae augue.\n+        // Nam tincidunt congue enim, ut porta lorem lacinia consectetur.\n+        second: Item\n+    };\n+\n+    Diagram { /*                 o        This graph demonstrates how                  \n+               *                / \\       significant whitespace is           \n+               *               o   o      preserved.  \n+               *              /|\\   \\\n+               *             o o o   o */\n+              graph: G, }\n+}"}, {"sha": "ace13fe2889de9c66f0dc48e65d36dc247d166e8", "filename": "tests/source/structs.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fsource%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Fsource%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstructs.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -0,0 +1,70 @@\n+\n+                                                                       /// A Doc comment\n+#[AnAttribute]\n+pub struct Foo {\n+    #[rustfmt_skip]\n+    f :   SomeType, // Comment beside a field\n+    f: SomeType, // Comment beside a field\n+    // Comment on a field\n+    #[AnAttribute]\n+    g: SomeOtherType,\n+      /// A doc comment on a field\n+    h: AThirdType,\n+    pub i: TypeForPublicField\n+}\n+\n+struct Bar;\n+\n+struct NewType(Type,       OtherType);\n+\n+struct\n+NewInt     <T: Copy>(pub i32, SomeType /* inline comment */, T /* sup */\n+\n+\n+    );\n+\n+struct Qux<'a,\n+           N: Clone + 'a,\n+           E: Clone + 'a,\n+           G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n+           W: Write + Copy>\n+(\n+    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // Comment\n+    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\n+    #[AnAttr]    \n+    // Comment\n+    /// Testdoc\n+    G,\n+    pub W,\n+);\n+\n+struct Tuple(/*Comment 1*/ AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n+             /* Comment 2   */ BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,);\n+\n+// With a where clause and generics.\n+pub struct Foo<'a, Y: Baz>\n+    where X: Whatever\n+{\n+    f: SomeType, // Comment beside a field\n+}\n+\n+struct Baz {\n+    a: A,  // Comment A\n+    b: B, // Comment B\n+    c: C,   // Comment C\n+}\n+\n+struct Baz\n+{\n+    // Comment A\n+    a: A,\n+    // Comment B\n+b: B,\n+    // Comment C\n+      c: C,}\n+\n+// Will this be a one-liner?\n+struct Tuple(\n+    A, //Comment\n+    B\n+);"}, {"sha": "0b21d84074a2d38a06d3021167446660f53cf398", "filename": "tests/target/comments-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fcomments-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fcomments-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomments-fn.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -2,13 +2,13 @@\n \n // Comment on foo.\n fn foo<F, G>(a: aaaaaaaaaaaaa, // A comment\n-             b: bbbbbbbbbbbbb, /* a second comment */\n+             b: bbbbbbbbbbbbb, // a second comment\n              c: ccccccccccccc,\n              // Newline comment\n              d: ddddddddddddd,\n              //  A multi line comment\n              // between args.\n-             e: eeeeeeeeeeeee /* comment before paren*/)\n+             e: eeeeeeeeeeeee /* comment before paren */)\n              -> bar\n     where F: Foo, // COmment after where clause\n           G: Goo /* final comment */"}, {"sha": "8c534ef89c80fee68aee6aa7735c94d867472b69", "filename": "tests/target/enum.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -3,7 +3,7 @@\n #[atrr]\n pub enum Test {\n     A,\n-    B(u32, A /* comment */),\n+    B(u32, A /* comment */, SomeType),\n     /// Doc comment\n     C,\n }\n@@ -27,8 +27,18 @@ enum Bar {\n }\n \n enum LongVariants {\n-    First(LOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOONG, // small comment\n+    First(LOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOONG, // comment\n           VARIANT),\n     // This is the second variant\n     Second,\n }\n+\n+enum StructLikeVariants {\n+    Normal(u32, String),\n+    StructLike {\n+        x: i32, // Test comment\n+        // Pre-comment\n+        #[Attr50]\n+        y: SomeType, // Aanother Comment\n+    }\n+}"}, {"sha": "eb133d568ede8463fa1a19ef4db0639edb9d4341", "filename": "tests/target/fn-simple.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-simple.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -0,0 +1,16 @@\n+\n+fn simple(// pre-comment on a function!?\n+          i: i32, // yes, it's possible!\n+          response: NoWay /* hose */) {\n+    \"cool\"\n+}\n+\n+\n+fn weird_comment(// /*/ double level */ comment\n+                 x: Hello, // /*/* tripple, even */*/\n+                 // Does this work?\n+                 y: World) {\n+    simple(// does this preserve comments now?\n+           42,\n+           NoWay)\n+}"}, {"sha": "0fb0c94e3a8319c1a576f09e86439cacc99b329e", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -36,10 +36,10 @@ fn foo()\n     hello!()\n }\n \n-fn baz<'a: 'b, /* comment on 'a */\n+fn baz<'a: 'b, // comment on 'a\n        T: SomsssssssssssssssssssssssssssssssssssssssssssssssssssssseType /* comment on T */>\n     (a: A,\n-     b: B, /* comment on b */\n+     b: B, // comment on b\n      c: C)\n      -> Bob {\n     #[attr1]\n@@ -65,8 +65,9 @@ fn qux(a: dadsfa,   // Comment 1\n /// Blah blah blah.\n impl Bar {\n     fn foo(&mut self,\n-           a: sdfsdfcccccccccccccccccccccccccccccccccccccccccccccccccccccccc, // comment on a\n-           b: sdfasdfsdfasfs /*closing comment*/)\n+           a: sdfsdfcccccccccccccccccccccccccccccccccccccccccccccccccc, /* commen\n+                                                                         * t on a */\n+           b: sdfasdfsdfasfs /* closing comment */)\n            -> isize {\n     }\n \n@@ -138,17 +139,3 @@ fn main() {\n              abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd \\\n              abcd\";\n }\n-\n-\n-fn struct_lits() {\n-    let x = Bar;\n-    // Comment\n-    let y = Foo { a: x };\n-    Foo { a: foo(), b: bar(), ..something };\n-    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n-                                                                               b: bar(), };\n-    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n-                                                                                         b: bar(), };\n-\n-    Foo { a: Bar, b: foo() };\n-}"}, {"sha": "c46909825a1cb7c9c838f880fafe3db7da42706a", "filename": "tests/target/struct_lits.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstruct_lits.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -6,19 +6,45 @@ fn main() {\n     // Comment\n     let y = Foo { a: x };\n \n-    Foo { a: Bar, b: foo() };\n-\n-    Foo { a: foo(), b: bar(), ..something };\n+    Foo { a: foo(), // comment\n+          // comment\n+          b: bar(),\n+          ..something };\n \n-    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(), b: bar() };\n     Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n                                                                                b: bar(), };\n \n-    Fooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n-                                                             b: bar(),\n-                                                             c: bar(),\n-                                                             d: bar(),\n-                                                             e: bar(),\n-                                                             f: bar(),\n-                                                             ..baz() };\n+    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { // Comment\n+                                                                                        a: foo(), /* C\n+                                                                                                   * o\n+                                                                                                   * m\n+                                                                                                   * m\n+                                                                                                   * e\n+                                                                                                   * n\n+                                                                                                   * t */\n+                                                                                        // Comment\n+                                                                                        b: bar(), /* C\n+                                                                                                   * o\n+                                                                                                   * m\n+                                                                                                   * m\n+                                                                                                   * e\n+                                                                                                   * n\n+                                                                                                   * t */ };\n+\n+    Foo { a: Bar, b: foo() };\n+\n+    A { // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit\n+        // amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante\n+        // hendrerit. Donec et mollis dolor.\n+        first: item(),\n+        // Praesent et diam eget libero egestas mattis sit amet vitae augue.\n+        // Nam tincidunt congue enim, ut porta lorem lacinia consectetur.\n+        second: Item, };\n+\n+    Diagram { //                 o        This graph demonstrates how\n+              //                / \\       significant whitespace is\n+              //               o   o      preserved.\n+              //              /|\\   \\\n+              //             o o o   o\n+              graph: G, }\n }"}, {"sha": "84b7334008dafbad1b8376e1f8c3856b2b473bca", "filename": "tests/target/structs.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstructs.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -15,6 +15,32 @@ pub struct Foo {\n \n struct Bar;\n \n+struct NewType(Type, OtherType);\n+\n+struct NewInt<T: Copy>(pub i32, SomeType /* inline comment */, T /* sup */);\n+\n+struct Qux<'a,\n+           N: Clone + 'a,\n+           E: Clone + 'a,\n+           G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n+           W: Write + Copy>\n+(\n+    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // Comment\n+    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\n+    #[AnAttr]\n+    // Comment\n+    /// Testdoc\n+    G,\n+    pub W,\n+);\n+\n+struct Tuple(\n+    // Comment 1\n+    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n+    // Comment 2\n+    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\n+);\n+\n // With a where clause and generics.\n pub struct Foo<'a, Y: Baz>\n     where X: Whatever\n@@ -36,3 +62,6 @@ struct Baz {\n     // Comment C\n     c: C,\n }\n+\n+// Will this be a one-liner?\n+struct Tuple(A /* Comment */, B);"}, {"sha": "2d126cacf964e0029f6ea9ba918dfe69f924e164", "filename": "tests/target/tuple.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cef6785bf29f98f49dce5fa62e54606e7f5b948/tests%2Ftarget%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftuple.rs?ref=8cef6785bf29f98f49dce5fa62e54606e7f5b948", "patch": "@@ -8,4 +8,8 @@ fn foo() {\n                                   aaaaaaaaaaaaaaaaaaaaaaaaa,\n                                   aaaa);\n     let a = (a,);\n+\n+    let b = (// This is a comment\n+             b, // Comment\n+             b /* Trailing comment */);\n }"}]}