{"sha": "a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YzVhNTk5ZTNmMWNkNTJmOWZkNzQ1YWE3NWJkYjdhZmUwYmI0ZjQ=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:54Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:54Z"}, "message": "literal representation restructure 9\n\nOnly store valid suffixes (and not mistyped suffixes) in DigitInfo.\nCheck for mistyped suffixes later and not when DigitInfo is created.\nThis opens the door to more sophisticated mistyped suffix checks later.", "tree": {"sha": "ad58203007e5cad5fe6d0d3cf25290cd534b8289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad58203007e5cad5fe6d0d3cf25290cd534b8289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4", "html_url": "https://github.com/rust-lang/rust/commit/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4/comments", "author": null, "committer": null, "parents": [{"sha": "a58b980bd88651bc3bb85ef465848e0c08253444", "url": "https://api.github.com/repos/rust-lang/rust/commits/a58b980bd88651bc3bb85ef465848e0c08253444", "html_url": "https://github.com/rust-lang/rust/commit/a58b980bd88651bc3bb85ef465848e0c08253444"}], "stats": {"total": 163, "additions": 86, "deletions": 77}, "files": [{"sha": "137261cab82b67cd6d78f921f37efe7d49b9c506", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4", "patch": "@@ -86,7 +86,7 @@ impl ExcessivePrecision {\n             if sym_str == s {\n                 None\n             } else {\n-                let di = super::literal_representation::DigitInfo::new(&s, true);\n+                let di = super::literal_representation::DigitInfo::new(&s, None, true);\n                 Some(di.grouping_hint())\n             }\n         } else {"}, {"sha": "d2df2c731f4296e73ff38c3e7e61aaaaf55a1ba5", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 85, "deletions": 76, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=a9c5a599e3f1cd52f9fd745aa75bdb7afe0bb4f4", "patch": "@@ -138,13 +138,21 @@ pub(super) struct DigitInfo<'a> {\n \n     /// The type suffix, including preceding underscore if present.\n     crate suffix: Option<&'a str>,\n-    /// True for floating-point literals.\n-    crate float: bool,\n }\n \n impl<'a> DigitInfo<'a> {\n+    fn from_lit(src: &'a str, lit: &Lit) -> Option<DigitInfo<'a>> {\n+        if lit.kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n+            let (unsuffixed, suffix) = split_suffix(&src, &lit.kind);\n+            let float = if let LitKind::Float(..) = lit.kind { true } else { false };\n+            Some(DigitInfo::new(unsuffixed, suffix, float))\n+        } else {\n+            None\n+        }\n+    }\n+\n     #[must_use]\n-    crate fn new(lit: &'a str, float: bool) -> Self {\n+    crate fn new(lit: &'a str, suffix: Option<&'a str>, float: bool) -> Self {\n         // Determine delimiter for radix prefix, if present, and radix.\n         let radix = if lit.starts_with(\"0x\") {\n             Radix::Hexadecimal\n@@ -157,35 +165,19 @@ impl<'a> DigitInfo<'a> {\n         };\n \n         // Grab part of the literal after prefix, if present.\n-        let (prefix, sans_prefix) = if let Radix::Decimal = radix {\n+        let (prefix, mut sans_prefix) = if let Radix::Decimal = radix {\n             (None, lit)\n         } else {\n             let (p, s) = lit.split_at(2);\n             (Some(p), s)\n         };\n \n-        let mut digits = sans_prefix;\n-        let mut suffix = None;\n-\n-        let len = sans_prefix.len();\n-        let mut last_d = '\\0';\n-        for (d_idx, d) in sans_prefix.char_indices() {\n-            let suffix_start = if last_d == '_' { d_idx - 1 } else { d_idx };\n-            if float\n-                && (d == 'f'\n-                    || is_possible_float_suffix_index(&sans_prefix, suffix_start, len)\n-                    || ((d == 'E' || d == 'e') && !has_possible_float_suffix(&sans_prefix)))\n-                || !float && (d == 'i' || d == 'u' || is_possible_suffix_index(&sans_prefix, suffix_start, len))\n-            {\n-                let (d, s) = sans_prefix.split_at(suffix_start);\n-                digits = d;\n-                suffix = Some(s);\n-                break;\n-            }\n-            last_d = d\n+        if suffix.is_some() && sans_prefix.ends_with('_') {\n+            // The '_' before the suffix isn't part of the digits\n+            sans_prefix = &sans_prefix[..sans_prefix.len() - 1];\n         }\n \n-        let (integer, fraction, exponent) = Self::split_digit_parts(digits, float);\n+        let (integer, fraction, exponent) = Self::split_digit_parts(sans_prefix, float);\n \n         Self {\n             radix,\n@@ -194,7 +186,6 @@ impl<'a> DigitInfo<'a> {\n             fraction,\n             exponent,\n             suffix,\n-            float,\n         }\n     }\n \n@@ -256,15 +247,8 @@ impl<'a> DigitInfo<'a> {\n         }\n \n         if let Some(suffix) = self.suffix {\n-            if self.float && is_mistyped_float_suffix(suffix) {\n-                output.push_str(\"_f\");\n-                output.push_str(&suffix[1..]);\n-            } else if is_mistyped_suffix(suffix) {\n-                output.push_str(\"_i\");\n-                output.push_str(&suffix[1..]);\n-            } else {\n-                output.push_str(suffix);\n-            }\n+            output.push('_');\n+            output.push_str(suffix);\n         }\n \n         output\n@@ -303,6 +287,34 @@ impl<'a> DigitInfo<'a> {\n     }\n }\n \n+fn split_suffix<'a>(src: &'a str, lit_kind: &LitKind) -> (&'a str, Option<&'a str>) {\n+    debug_assert!(lit_kind.is_numeric());\n+    if let Some(suffix_length) = lit_suffix_length(lit_kind) {\n+        let (unsuffixed, suffix) = src.split_at(src.len() - suffix_length);\n+        (unsuffixed, Some(suffix))\n+    } else {\n+        (src, None)\n+    }\n+}\n+\n+fn lit_suffix_length(lit_kind: &LitKind) -> Option<usize> {\n+    debug_assert!(lit_kind.is_numeric());\n+    let suffix = match lit_kind {\n+        LitKind::Int(_, int_lit_kind) => match int_lit_kind {\n+            LitIntType::Signed(int_ty) => Some(int_ty.name_str()),\n+            LitIntType::Unsigned(uint_ty) => Some(uint_ty.name_str()),\n+            LitIntType::Unsuffixed => None,\n+        },\n+        LitKind::Float(_, float_lit_kind) => match float_lit_kind {\n+            LitFloatType::Suffixed(float_ty) => Some(float_ty.name_str()),\n+            LitFloatType::Unsuffixed => None,\n+        },\n+        _ => None,\n+    };\n+\n+    suffix.map(str::len)\n+}\n+\n enum WarningType {\n     UnreadableLiteral,\n     InconsistentDigitGrouping,\n@@ -388,22 +400,13 @@ impl LiteralDigitGrouping {\n \n         if_chain! {\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(firstch) = src.chars().next();\n-            if char::is_digit(firstch, 10);\n+            if let Some(mut digit_info) = DigitInfo::from_lit(&src, &lit);\n             then {\n-\n-                let digit_info = match lit.kind {\n-                        LitKind::Int(..) => DigitInfo::new(&src, false),\n-                        LitKind::Float(..) => DigitInfo::new(&src, true),\n-                        _ => return,\n-                };\n+                if !Self::check_for_mistyped_suffix(cx, lit.span, &mut digit_info) {\n+                    return;\n+                }\n \n                 let result = (|| {\n-                    if let Some(suffix) = digit_info.suffix {\n-                        if is_mistyped_suffix(suffix) {\n-                            return Err(WarningType::MistypedLiteralSuffix);\n-                        }\n-                    }\n \n                     let integral_group_size = Self::get_group_size(digit_info.integer.split('_'), in_macro)?;\n                     if let Some(fraction) = digit_info.fraction {\n@@ -428,6 +431,39 @@ impl LiteralDigitGrouping {\n         }\n     }\n \n+    // Returns `false` if the check fails\n+    fn check_for_mistyped_suffix(\n+        cx: &EarlyContext<'_>,\n+        span: syntax_pos::Span,\n+        digit_info: &mut DigitInfo<'_>,\n+    ) -> bool {\n+        if digit_info.suffix.is_some() {\n+            return true;\n+        }\n+\n+        let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut digit_info.exponent {\n+            (exponent, &[\"32\", \"64\"][..], 'f')\n+        } else if let Some(fraction) = &mut digit_info.fraction {\n+            (fraction, &[\"32\", \"64\"][..], 'f')\n+        } else {\n+            (&mut digit_info.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n+        };\n+\n+        let mut split = part.rsplit('_');\n+        let last_group = split.next().expect(\"At least one group\");\n+        if split.next().is_some() && mistyped_suffixes.contains(&last_group) {\n+            *part = &part[..part.len() - last_group.len()];\n+            let mut hint = digit_info.grouping_hint();\n+            hint.push('_');\n+            hint.push(missing_char);\n+            hint.push_str(last_group);\n+            WarningType::MistypedLiteralSuffix.display(&hint, cx, span);\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n     /// Given the sizes of the digit groups of both integral and fractional\n     /// parts, and the length\n     /// of both parts, determine if the digits have been grouped consistently.\n@@ -503,14 +539,12 @@ impl DecimalLiteralRepresentation {\n         if_chain! {\n             if let LitKind::Int(val, _) = lit.kind;\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(firstch) = src.chars().next();\n-            if char::is_digit(firstch, 10);\n-            let digit_info = DigitInfo::new(&src, false);\n+            if let Some(digit_info) = DigitInfo::from_lit(&src, &lit);\n             if digit_info.radix == Radix::Decimal;\n             if val >= u128::from(self.threshold);\n             then {\n                 let hex = format!(\"{:#X}\", val);\n-                let digit_info = DigitInfo::new(&hex, false);\n+                let digit_info = DigitInfo::new(&hex, None, false);\n                 let _ = Self::do_lint(digit_info.integer).map_err(|warning_type| {\n                     warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n                 });\n@@ -563,28 +597,3 @@ impl DecimalLiteralRepresentation {\n         Ok(())\n     }\n }\n-\n-#[must_use]\n-fn is_mistyped_suffix(suffix: &str) -> bool {\n-    [\"_8\", \"_16\", \"_32\", \"_64\"].contains(&suffix)\n-}\n-\n-#[must_use]\n-fn is_possible_suffix_index(lit: &str, idx: usize, len: usize) -> bool {\n-    ((len > 3 && idx == len - 3) || (len > 2 && idx == len - 2)) && is_mistyped_suffix(lit.split_at(idx).1)\n-}\n-\n-#[must_use]\n-fn is_mistyped_float_suffix(suffix: &str) -> bool {\n-    [\"_32\", \"_64\"].contains(&suffix)\n-}\n-\n-#[must_use]\n-fn is_possible_float_suffix_index(lit: &str, idx: usize, len: usize) -> bool {\n-    (len > 3 && idx == len - 3) && is_mistyped_float_suffix(lit.split_at(idx).1)\n-}\n-\n-#[must_use]\n-fn has_possible_float_suffix(lit: &str) -> bool {\n-    lit.ends_with(\"_32\") || lit.ends_with(\"_64\")\n-}"}]}