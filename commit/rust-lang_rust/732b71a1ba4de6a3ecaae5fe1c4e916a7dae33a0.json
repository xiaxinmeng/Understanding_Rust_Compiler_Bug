{"sha": "732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMmI3MWExYmE0ZGU2YTNlY2FhZTVmZTFjNGU5MTZhN2RhZTMzYTA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-12T07:47:45Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc: add a ty::RegionKind::display_outputs_anything method to avoid printing to a string.", "tree": {"sha": "f80bf6e40b4f1a5e19c2a1a2525ce2ea98b9d4f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f80bf6e40b4f1a5e19c2a1a2525ce2ea98b9d4f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0", "html_url": "https://github.com/rust-lang/rust/commit/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "329b8ca8180ef8aa7314bd0bff9d9cd61f8dad40", "url": "https://api.github.com/repos/rust-lang/rust/commits/329b8ca8180ef8aa7314bd0bff9d9cd61f8dad40", "html_url": "https://github.com/rust-lang/rust/commit/329b8ca8180ef8aa7314bd0bff9d9cd61f8dad40"}], "stats": {"total": 157, "additions": 120, "deletions": 37}, "files": [{"sha": "7085a3beb1ceb5f202849f76293ce1c3626f74d3", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0", "patch": "@@ -59,11 +59,6 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n \n pub trait Print<'tcx> {\n     fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, 'tcx>) -> fmt::Result;\n-    fn print_to_string(&self, cx: &mut PrintCx<'_, '_, 'tcx>) -> String {\n-        let mut result = String::new();\n-        let _ = self.print(&mut result, cx);\n-        result\n-    }\n     fn print_display<F: fmt::Write>(\n         &self,\n         f: &mut F,\n@@ -75,21 +70,11 @@ pub trait Print<'tcx> {\n         cx.is_debug = old_debug;\n         result\n     }\n-    fn print_display_to_string(&self, cx: &mut PrintCx<'_, '_, 'tcx>) -> String {\n-        let mut result = String::new();\n-        let _ = self.print_display(&mut result, cx);\n-        result\n-    }\n     fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, 'tcx>) -> fmt::Result {\n         let old_debug = cx.is_debug;\n         cx.is_debug = true;\n         let result = self.print(f, cx);\n         cx.is_debug = old_debug;\n         result\n     }\n-    fn print_debug_to_string(&self, cx: &mut PrintCx<'_, '_, 'tcx>) -> String {\n-        let mut result = String::new();\n-        let _ = self.print_debug(&mut result, cx);\n-        result\n-    }\n }"}, {"sha": "a0feeae0a0cc881e255715e0e49a8e597fe14d0a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 120, "deletions": 22, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=732b71a1ba4de6a3ecaae5fe1c4e916a7dae33a0", "patch": "@@ -396,20 +396,15 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n                         continue;\n                     }\n                     start_or_continue(f, start, \", \")?;\n-                    if self.is_verbose {\n-                        write!(f, \"{:?}\", region)?;\n+                    if !region.display_outputs_anything(self) {\n+                        // This happens when the value of the region\n+                        // parameter is not easily serialized. This may be\n+                        // because the user omitted it in the first place,\n+                        // or because it refers to some block in the code,\n+                        // etc. I'm not sure how best to serialize this.\n+                        write!(f, \"'_\")?;\n                     } else {\n-                        let s = region.print_display_to_string(self);\n-                        if s.is_empty() {\n-                            // This happens when the value of the region\n-                            // parameter is not easily serialized. This may be\n-                            // because the user omitted it in the first place,\n-                            // or because it refers to some block in the code,\n-                            // etc. I'm not sure how best to serialize this.\n-                            write!(f, \"'_\")?;\n-                        } else {\n-                            write!(f, \"{}\", s)?;\n-                        }\n+                        region.print_display(f, self)?;\n                     }\n                 }\n                 UnpackedKind::Type(ty) => {\n@@ -727,6 +722,32 @@ define_print! {\n     }\n }\n \n+// HACK(eddyb) (see `ty::RegionKind::display_outputs_anything`)\n+//\n+// NB: this must be kept in sync with the printing logic above.\n+impl ty::BoundRegion {\n+    fn display_outputs_anything(&self, cx: &mut PrintCx<'_, '_, '_>) -> bool {\n+        if cx.is_verbose {\n+            return true;\n+        }\n+\n+        if let BrNamed(_, name) = *self {\n+            if name != \"\" && name != \"'_\" {\n+                return true;\n+            }\n+        }\n+\n+        let highlight = RegionHighlightMode::get();\n+        if let Some((region, _)) = highlight.highlight_bound_region {\n+            if *self == region {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+}\n+\n define_print! {\n     () ty::PlaceholderRegion, (self, f, cx) {\n         display {\n@@ -744,6 +765,24 @@ define_print! {\n     }\n }\n \n+// HACK(eddyb) (see `ty::RegionKind::display_outputs_anything`)\n+//\n+// NB: this must be kept in sync with the printing logic above.\n+impl ty::PlaceholderRegion {\n+    fn display_outputs_anything(&self, cx: &mut PrintCx<'_, '_, '_>) -> bool {\n+        if cx.is_verbose {\n+            return true;\n+        }\n+\n+        let highlight = RegionHighlightMode::get();\n+        if highlight.placeholder_highlight(*self).is_some() {\n+            return true;\n+        }\n+\n+        self.name.display_outputs_anything(cx)\n+    }\n+}\n+\n define_print! {\n     () ty::RegionKind, (self, f, cx) {\n         display {\n@@ -851,6 +890,49 @@ define_print! {\n     }\n }\n \n+// HACK(eddyb) Trying to print a lifetime might not print anything, which\n+// may need special handling in the caller (of `ty::RegionKind::print`).\n+// To avoid printing to a temporary string, the `display_outputs_anything`\n+// method can instead be used to determine this, ahead of time.\n+//\n+// NB: this must be kept in sync with the printing logic above.\n+impl ty::RegionKind {\n+    fn display_outputs_anything(&self, cx: &mut PrintCx<'_, '_, '_>) -> bool {\n+        if cx.is_verbose {\n+            return true;\n+        }\n+\n+        if RegionHighlightMode::get().region_highlighted(self).is_some() {\n+            return true;\n+        }\n+\n+        match *self {\n+            ty::ReEarlyBound(ref data) => {\n+                data.name != \"\" && data.name != \"'_\"\n+            }\n+\n+            ty::ReLateBound(_, br) |\n+            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) => {\n+                br.display_outputs_anything(cx)\n+            }\n+\n+            ty::RePlaceholder(p) => p.display_outputs_anything(cx),\n+\n+            ty::ReScope(_) |\n+            ty::ReVar(_) if cx.identify_regions => true,\n+\n+            ty::ReVar(region_vid) => region_vid.display_outputs_anything(cx),\n+\n+            ty::ReScope(_) |\n+            ty::ReErased => false,\n+\n+            ty::ReStatic |\n+            ty::ReEmpty |\n+            ty::ReClosureBound(_) => true,\n+        }\n+    }\n+}\n+\n define_print! {\n     () ty::FreeRegion, (self, f, cx) {\n         debug {\n@@ -943,6 +1025,24 @@ define_print! {\n     }\n }\n \n+// HACK(eddyb) (see `ty::RegionKind::display_outputs_anything`)\n+//\n+// NB: this must be kept in sync with the printing logic above.\n+impl ty::RegionVid {\n+    fn display_outputs_anything(&self, cx: &mut PrintCx<'_, '_, '_>) -> bool {\n+        if cx.is_verbose {\n+            return true;\n+        }\n+\n+        let highlight = RegionHighlightMode::get();\n+        if highlight.region_highlighted(&ty::ReVar(*self)).is_some() {\n+            return true;\n+        }\n+\n+        false\n+    }\n+}\n+\n define_print! {\n     () ty::InferTy, (self, f, cx) {\n         display {\n@@ -1053,9 +1153,8 @@ define_print! {\n                 }\n                 Ref(r, ty, mutbl) => {\n                     write!(f, \"&\")?;\n-                    let s = r.print_display_to_string(cx);\n-                    if !s.is_empty() {\n-                        write!(f, \"{} \", s)?;\n+                    if r.display_outputs_anything(cx) {\n+                        print!(f, cx, print_display(r), write(\" \"))?;\n                     }\n                     ty::TypeAndMut { ty, mutbl }.print(f, cx)\n                 }\n@@ -1101,17 +1200,16 @@ define_print! {\n                 }\n                 Adt(def, substs) => cx.parameterized(f, def.did, substs, iter::empty()),\n                 Dynamic(data, r) => {\n-                    let r = r.print_display_to_string(cx);\n-                    if !r.is_empty() {\n+                    let print_r = r.display_outputs_anything(cx);\n+                    if print_r {\n                         write!(f, \"(\")?;\n                     }\n                     write!(f, \"dyn \")?;\n                     data.print(f, cx)?;\n-                    if !r.is_empty() {\n-                        write!(f, \" + {})\", r)\n-                    } else {\n-                        Ok(())\n+                    if print_r {\n+                        print!(f, cx, write(\" + \"), print_display(r), write(\")\"))?;\n                     }\n+                    Ok(())\n                 }\n                 Foreign(def_id) => {\n                     cx.parameterized(f, def_id, subst::InternalSubsts::empty(), iter::empty())"}]}