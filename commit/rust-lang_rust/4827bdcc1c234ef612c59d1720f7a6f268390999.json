{"sha": "4827bdcc1c234ef612c59d1720f7a6f268390999", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MjdiZGNjMWMyMzRlZjYxMmM1OWQxNzIwZjdhNmYyNjgzOTA5OTk=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-06-26T05:46:56Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-06-26T05:46:56Z"}, "message": "Merge branch 'master' into issue_2741", "tree": {"sha": "d790a4d43cba6e8a9cf4a6d308d575f64a57e487", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d790a4d43cba6e8a9cf4a6d308d575f64a57e487"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4827bdcc1c234ef612c59d1720f7a6f268390999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4827bdcc1c234ef612c59d1720f7a6f268390999", "html_url": "https://github.com/rust-lang/rust/commit/4827bdcc1c234ef612c59d1720f7a6f268390999", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4827bdcc1c234ef612c59d1720f7a6f268390999/comments", "author": null, "committer": null, "parents": [{"sha": "7df5601f5c8b84a73a14e5a3d16100d43573740a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7df5601f5c8b84a73a14e5a3d16100d43573740a", "html_url": "https://github.com/rust-lang/rust/commit/7df5601f5c8b84a73a14e5a3d16100d43573740a"}, {"sha": "9f8624e5bf6f4feb99ebe0d62b83a30c9e2747c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8624e5bf6f4feb99ebe0d62b83a30c9e2747c4", "html_url": "https://github.com/rust-lang/rust/commit/9f8624e5bf6f4feb99ebe0d62b83a30c9e2747c4"}], "stats": {"total": 2279, "additions": 1563, "deletions": 716}, "files": [{"sha": "97f31b18684d1de8e6529b5ac80d45995bf4611b", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -48,7 +48,6 @@ matrix:\n     - env: INTEGRATION=serde-rs/serde\n     - env: INTEGRATION=Geal/nom\n     - env: INTEGRATION=hyperium/hyper\n-  allow_failures:\n     - env: INTEGRATION=rust-lang/cargo\n     - env: INTEGRATION=rust-lang-nursery/rls\n "}, {"sha": "22c043d876d9bb7162eed76e3a6689cb4f44797c", "filename": "CHANGELOG.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -1,6 +1,12 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.210\n+* Rustup to *rustc 1.28.0-nightly (01cc982e9 2018-06-24)*\n+\n+## 0.0.209\n+* Rustup to *rustc 1.28.0-nightly (523097979 2018-06-18)*\n+\n ## 0.0.208\n * Rustup to *rustc 1.28.0-nightly (86a8f1a63 2018-06-17)*\n \n@@ -635,6 +641,7 @@ All notable changes to this project will be documented in this file.\n [`crosspointer_transmute`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#crosspointer_transmute\n [`cyclomatic_complexity`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#cyclomatic_complexity\n [`decimal_literal_representation`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#decimal_literal_representation\n+[`default_trait_access`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#default_trait_access\n [`deprecated_semver`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#deref_addrof\n [`derive_hash_xor_eq`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n@@ -775,6 +782,7 @@ All notable changes to this project will be documented in this file.\n [`out_of_bounds_indexing`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#out_of_bounds_indexing\n [`overflow_check_conditional`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#overflow_check_conditional\n [`panic_params`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#panic_params\n+[`panicking_unwrap`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#panicking_unwrap\n [`partialeq_ne_impl`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n [`possible_missing_comma`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#possible_missing_comma\n [`precedence`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#precedence"}, {"sha": "b7cfcb68065a668cb66238be92d81d1641513011", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -2,7 +2,7 @@ cargo-features = [\"edition\"]\n \n [package]\n name = \"clippy\"\n-version = \"0.0.208\"\n+version = \"0.0.210\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -40,7 +40,7 @@ path = \"src/driver.rs\"\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.208\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.210\", path = \"clippy_lints\" }\n # end automatic update\n regex = \"1\"\n semver = \"0.9\""}, {"sha": "f836183786ae7c9934e072e47fccfb021bb5bf11", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -1,13 +1,15 @@\n+We are currently in the process of discussing Clippy 1.0 via the RFC process in https://github.com/rust-lang/rfcs/pull/2476 . The RFC's goal is to clarify policies around lint categorizations and the policy around which lints should be in the compiler and which lints should be in clippy. Please leave your thoughts on the RFC PR.\n+\n # rust-clippy\n \n [![Build Status](https://travis-ci.org/rust-lang-nursery/rust-clippy.svg?branch=master)](https://travis-ci.org/rust-lang-nursery/rust-clippy)\n-[![Windows build status](https://ci.appveyor.com/api/projects/status/github/rust-lang-nursery/rust-clippy?svg=true)](https://ci.appveyor.com/project/rust-lang-nursery/rust-clippy)\n+[![Windows Build status](https://ci.appveyor.com/api/projects/status/id677xpw1dguo7iw?svg=true)](https://ci.appveyor.com/project/rust-lang-libs/rust-clippy)\n [![Current Version](https://meritbadge.herokuapp.com/clippy)](https://crates.io/crates/clippy)\n [![License: MPL-2.0](https://img.shields.io/crates/l/clippy.svg)](#license)\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 268 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n+[There are 270 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "1f62b479ba74c84230a7ceed6e8d8c2f339cda96", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -3,7 +3,7 @@ cargo-features = [\"edition\"]\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.208\"\n+version = \"0.0.210\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "77aa5e834258d685851e4f2a4d4aa6d995fbffe0", "filename": "clippy_lints/src/array_indexing.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7df5601f5c8b84a73a14e5a3d16100d43573740a/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7df5601f5c8b84a73a14e5a3d16100d43573740a/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=7df5601f5c8b84a73a14e5a3d16100d43573740a", "patch": "@@ -1,123 +0,0 @@\n-use crate::consts::{constant, Constant};\n-use crate::utils::higher::Range;\n-use crate::utils::{self, higher};\n-use rustc::hir;\n-use rustc::lint::*;\n-use rustc::ty;\n-use syntax::ast::RangeLimits;\n-\n-/// **What it does:** Checks for out of bounds array indexing with a constant\n-/// index.\n-///\n-/// **Why is this bad?** This will always panic at runtime.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = [1,2,3,4];\n-/// ...\n-/// x[9];\n-/// &x[2..9];\n-/// ```\n-declare_clippy_lint! {\n-    pub OUT_OF_BOUNDS_INDEXING,\n-    correctness,\n-    \"out of bounds constant indexing\"\n-}\n-\n-/// **What it does:** Checks for usage of indexing or slicing.\n-///\n-/// **Why is this bad?** Usually, this can be safely allowed. However, in some\n-/// domains such as kernel development, a panic can cause the whole operating\n-/// system to crash.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// ...\n-/// x[2];\n-/// &x[0..2];\n-/// ```\n-declare_clippy_lint! {\n-    pub INDEXING_SLICING,\n-    restriction,\n-    \"indexing/slicing usage\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct ArrayIndexing;\n-\n-impl LintPass for ArrayIndexing {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING)\n-    }\n-}\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n-        if let hir::ExprIndex(ref array, ref index) = e.node {\n-            // Array with known size can be checked statically\n-            let ty = cx.tables.expr_ty(array);\n-            if let ty::TyArray(_, size) = ty.sty {\n-                let size = size.assert_usize(cx.tcx).unwrap().into();\n-\n-                // Index is a constant uint\n-                if let Some((Constant::Int(const_index), _)) = constant(cx, cx.tables, index) {\n-                    if size <= const_index {\n-                        utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n-                    }\n-\n-                    return;\n-                }\n-\n-                // Index is a constant range\n-                if let Some(range) = higher::range(cx, index) {\n-                    if let Some((start, end)) = to_const_range(cx, range, size) {\n-                        if start > size || end > size {\n-                            utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"range is out of bounds\");\n-                        }\n-                        return;\n-                    }\n-                }\n-            }\n-\n-            if let Some(range) = higher::range(cx, index) {\n-                // Full ranges are always valid\n-                if range.start.is_none() && range.end.is_none() {\n-                    return;\n-                }\n-\n-                // Impossible to know if indexing or slicing is correct\n-                utils::span_lint(cx, INDEXING_SLICING, e.span, \"slicing may panic\");\n-            } else {\n-                utils::span_lint(cx, INDEXING_SLICING, e.span, \"indexing may panic\");\n-            }\n-        }\n-    }\n-}\n-\n-/// Returns an option containing a tuple with the start and end (exclusive) of\n-/// the range.\n-fn to_const_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, range: Range, array_size: u128) -> Option<(u128, u128)> {\n-    let s = range.start.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n-    let start = match s {\n-        Some(Some(Constant::Int(x))) => x,\n-        Some(_) => return None,\n-        None => 0,\n-    };\n-\n-    let e = range.end.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n-    let end = match e {\n-        Some(Some(Constant::Int(x))) => if range.limits == RangeLimits::Closed {\n-            x + 1\n-        } else {\n-            x\n-        },\n-        Some(_) => return None,\n-        None => array_size,\n-    };\n-\n-    Some((start, end))\n-}"}, {"sha": "c861e4ee4e263fd7d8abc0e6bee897e89c33cdf7", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n }\n \n fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n-    if let ItemFn(_, _, _, _, _, eid) = item.node {\n+    if let ItemFn(_, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         true"}, {"sha": "d96ed8db78653e4779db10ed83aaf3e97c980798", "filename": "clippy_lints/src/default_trait_access.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -0,0 +1,68 @@\n+use rustc::hir::*;\n+use rustc::lint::*;\n+use rustc::ty::TypeVariants;\n+\n+use crate::utils::{any_parent_is_automatically_derived, match_def_path, opt_def_id, paths, span_lint_and_sugg};\n+\n+\n+/// **What it does:** Checks for literal calls to `Default::default()`.\n+///\n+/// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n+/// being gotten than the generic `Default`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// // Bad\n+/// let s: String = Default::default();\n+///\n+/// // Good\n+/// let s = String::default();\n+/// ```\n+declare_clippy_lint! {\n+    pub DEFAULT_TRAIT_ACCESS,\n+    style,\n+    \"checks for literal calls to Default::default()\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct DefaultTraitAccess;\n+\n+impl LintPass for DefaultTraitAccess {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DEFAULT_TRAIT_ACCESS)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if_chain! {\n+            if let ExprCall(ref path, ..) = expr.node;\n+            if !any_parent_is_automatically_derived(cx.tcx, expr.id);\n+            if let ExprPath(ref qpath) = path.node;\n+            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n+            if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+            then {\n+                match qpath {\n+                    QPath::Resolved(..) => {\n+                        // TODO: Work out a way to put \"whatever the imported way of referencing\n+                        // this type in this file\" rather than a fully-qualified type.\n+                        let expr_ty = cx.tables.expr_ty(expr);\n+                        if let TypeVariants::TyAdt(..) = expr_ty.sty {\n+                            let replacement = format!(\"{}::default()\", expr_ty);\n+                            span_lint_and_sugg(\n+                                cx,\n+                                DEFAULT_TRAIT_ACCESS,\n+                                expr.span,\n+                                &format!(\"Calling {} is more clear than this expression\", replacement),\n+                                \"try\",\n+                                replacement);\n+                         }\n+                    },\n+                    QPath::TypeRelative(..) => {},\n+                }\n+            }\n+         }\n+    }\n+}"}, {"sha": "d773289263ef0df78bd8831215f01f4dfb365218", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprAgain(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n+            ExprContinue(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n             ExprCall(ref func, _) => {\n                 let typ = self.cx.tables.expr_ty(func);\n                 match typ.sty {"}, {"sha": "554c983d7c514748cbc4982f33effe3b3c8c37cd", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -92,17 +92,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         };\n \n         let unsafety = match kind {\n-            hir::intravisit::FnKind::ItemFn(_, _, unsafety, _, _, _, _) => unsafety,\n-            hir::intravisit::FnKind::Method(_, sig, _, _) => sig.unsafety,\n+            hir::intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _, _) => unsafety,\n+            hir::intravisit::FnKind::Method(_, sig, _, _) => sig.header.unsafety,\n             hir::intravisit::FnKind::Closure(_) => return,\n         };\n \n         // don't warn for implementations, it's not their fault\n         if !is_impl {\n             // don't lint extern functions decls, it's not their fault either\n             match kind {\n-                hir::intravisit::FnKind::Method(_, &hir::MethodSig { abi: Abi::Rust, .. }, _, _) |\n-                hir::intravisit::FnKind::ItemFn(_, _, _, _, Abi::Rust, _, _) => self.check_arg_number(cx, decl, span),\n+                hir::intravisit::FnKind::Method(_, &hir::MethodSig { header: hir::FnHeader { abi: Abi::Rust, .. }, .. }, _, _) |\n+                hir::intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _, _) => self.check_arg_number(cx, decl, span),\n                 _ => {},\n             }\n         }\n@@ -113,13 +113,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n         if let hir::TraitItemKind::Method(ref sig, ref eid) = item.node {\n             // don't lint extern functions decls, it's not their fault\n-            if sig.abi == Abi::Rust {\n+            if sig.header.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n             }\n \n             if let hir::TraitMethod::Provided(eid) = *eid {\n                 let body = cx.tcx.hir.body(eid);\n-                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, body, item.id);\n+                self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.id);\n             }\n         }\n     }"}, {"sha": "7dd72a5383cd5123e561578446d7b7071b87ac23", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -0,0 +1,183 @@\n+//! lint on indexing and slicing operations\n+\n+use crate::consts::{constant, Constant};\n+use crate::utils;\n+use crate::utils::higher;\n+use crate::utils::higher::Range;\n+use rustc::hir::*;\n+use rustc::lint::*;\n+use rustc::ty;\n+use syntax::ast::RangeLimits;\n+\n+/// **What it does:** Checks for out of bounds array indexing with a constant\n+/// index.\n+///\n+/// **Why is this bad?** This will always panic at runtime.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let x = [1,2,3,4];\n+///\n+/// // Bad\n+/// x[9];\n+/// &x[2..9];\n+///\n+/// // Good\n+/// x[0];\n+/// x[3];\n+/// ```\n+declare_clippy_lint! {\n+    pub OUT_OF_BOUNDS_INDEXING,\n+    correctness,\n+    \"out of bounds constant indexing\"\n+}\n+\n+/// **What it does:** Checks for usage of indexing or slicing. Arrays are special cased, this lint\n+/// does report on arrays if we can tell that slicing operations are in bounds and does not\n+/// lint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n+///\n+/// **Why is this bad?** Indexing and slicing can panic at runtime and there are\n+/// safe alternatives.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:**\n+/// ```rust\n+/// // Vector\n+/// let x = vec![0; 5];\n+///\n+/// // Bad\n+/// x[2];\n+/// &x[2..100];\n+/// &x[2..];\n+/// &x[..100];\n+///\n+/// // Good\n+/// x.get(2);\n+/// x.get(2..100);\n+/// x.get(2..);\n+/// x.get(..100);\n+///\n+/// // Array\n+/// let y = [0, 1, 2, 3];\n+///\n+/// // Bad\n+/// &y[10..100];\n+/// &y[10..];\n+/// &y[..100];\n+///\n+/// // Good\n+/// &y[2..];\n+/// &y[..2];\n+/// &y[0..3];\n+/// y.get(10);\n+/// y.get(10..100);\n+/// y.get(10..);\n+/// y.get(..100);\n+/// ```\n+declare_clippy_lint! {\n+    pub INDEXING_SLICING,\n+    pedantic,\n+    \"indexing/slicing usage\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct IndexingSlicing;\n+\n+impl LintPass for IndexingSlicing {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if let ExprIndex(ref array, ref index) = &expr.node {\n+            let ty = cx.tables.expr_ty(array);\n+            if let Some(range) = higher::range(cx, index) {\n+                // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]\n+                if let ty::TyArray(_, s) = ty.sty {\n+                    let size: u128 = s.assert_usize(cx.tcx).unwrap().into();\n+                    // Index is a constant range.\n+                    if let Some((start, end)) = to_const_range(cx, range, size) {\n+                        if start > size || end > size {\n+                            utils::span_lint(\n+                                cx,\n+                                OUT_OF_BOUNDS_INDEXING,\n+                                expr.span,\n+                                \"range is out of bounds\",\n+                            );\n+                        }\n+                        return;\n+                    }\n+                }\n+\n+                let help_msg = match (range.start, range.end) {\n+                    (None, Some(_)) => \"Consider using `.get(..n)`or `.get_mut(..n)` instead\",\n+                    (Some(_), None) => \"Consider using `.get(n..)` or .get_mut(n..)` instead\",\n+                    (Some(_), Some(_)) => \"Consider using `.get(n..m)` or `.get_mut(n..m)` instead\",\n+                    (None, None) => return, // [..] is ok.\n+                };\n+\n+                utils::span_help_and_lint(\n+                    cx,\n+                    INDEXING_SLICING,\n+                    expr.span,\n+                    \"slicing may panic.\",\n+                    help_msg,\n+                );\n+            } else {\n+                // Catchall non-range index, i.e. [n] or [n << m]\n+                if let ty::TyArray(..) = ty.sty {\n+                    // Index is a constant uint.\n+                    if let Some(..) = constant(cx, cx.tables, index) {\n+                        // Let rustc's `const_err` lint handle constant `usize` indexing on arrays.\n+                        return;\n+                    }\n+                }\n+\n+                utils::span_help_and_lint(\n+                    cx,\n+                    INDEXING_SLICING,\n+                    expr.span,\n+                    \"indexing may panic.\",\n+                    \"Consider using `.get(n)` or `.get_mut(n)` instead\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns an option containing a tuple with the start and end (exclusive) of\n+/// the range.\n+fn to_const_range<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    range: Range,\n+    array_size: u128,\n+) -> Option<(u128, u128)> {\n+    let s = range\n+        .start\n+        .map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let start = match s {\n+        Some(Some(Constant::Int(x))) => x,\n+        Some(_) => return None,\n+        None => 0,\n+    };\n+\n+    let e = range\n+        .end\n+        .map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let end = match e {\n+        Some(Some(Constant::Int(x))) => if range.limits == RangeLimits::Closed {\n+            x + 1\n+        } else {\n+            x\n+        },\n+        Some(_) => return None,\n+        None => array_size,\n+    };\n+\n+    Some((start, end))\n+}"}, {"sha": "347996358847f644996844354aadbbd70f13c378", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -6,7 +6,7 @@\n #![feature(stmt_expr_attributes)]\n #![feature(range_contains)]\n #![feature(macro_vis_matcher)]\n-#![allow(unknown_lints, indexing_slicing, shadow_reuse, missing_docs_in_private_items)]\n+#![allow(unknown_lints, shadow_reuse, missing_docs_in_private_items)]\n #![recursion_limit = \"256\"]\n #![allow(stable_features)]\n #![feature(iterator_find_map)]\n@@ -99,7 +99,6 @@ pub mod utils;\n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n pub mod approx_const;\n pub mod arithmetic;\n-pub mod array_indexing;\n pub mod assign_ops;\n pub mod attrs;\n pub mod bit_mask;\n@@ -111,6 +110,7 @@ pub mod collapsible_if;\n pub mod const_static_lifetime;\n pub mod copies;\n pub mod cyclomatic_complexity;\n+pub mod default_trait_access;\n pub mod derive;\n pub mod doc;\n pub mod double_comparison;\n@@ -138,6 +138,7 @@ pub mod identity_conversion;\n pub mod identity_op;\n pub mod if_let_redundant_pattern_matching;\n pub mod if_not_else;\n+pub mod indexing_slicing;\n pub mod infallible_destructuring_match;\n pub mod infinite_iter;\n pub mod inherent_impl;\n@@ -354,7 +355,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     );\n     reg.register_late_lint_pass(box escape::Pass{too_large_for_stack: conf.too_large_for_stack});\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n-    reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n     reg.register_late_lint_pass(box panic_unimplemented::Pass);\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n     reg.register_late_lint_pass(box derive::Derive);\n@@ -430,12 +430,12 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n     reg.register_late_lint_pass(box unwrap::Pass);\n     reg.register_late_lint_pass(box duration_subsec::DurationSubsec);\n-\n+    reg.register_late_lint_pass(box default_trait_access::DefaultTraitAccess);\n+    reg.register_late_lint_pass(box indexing_slicing::IndexingSlicing);\n \n     reg.register_lint_group(\"clippy_restriction\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n         arithmetic::INTEGER_ARITHMETIC,\n-        array_indexing::INDEXING_SLICING,\n         assign_ops::ASSIGN_OPS,\n         else_if_without_else::ELSE_IF_WITHOUT_ELSE,\n         inherent_impl::MULTIPLE_INHERENT_IMPL,\n@@ -466,6 +466,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         enum_variants::PUB_ENUM_VARIANT_NAMES,\n         enum_variants::STUTTER,\n         if_not_else::IF_NOT_ELSE,\n+        indexing_slicing::INDEXING_SLICING,\n         infinite_iter::MAYBE_INFINITE_ITER,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n         matches::SINGLE_MATCH_ELSE,\n@@ -498,7 +499,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n \n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n-        array_indexing::OUT_OF_BOUNDS_INDEXING,\n         assign_ops::ASSIGN_OP_PATTERN,\n         assign_ops::MISREFACTORED_ASSIGN_OP,\n         attrs::DEPRECATED_SEMVER,\n@@ -517,6 +517,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         copies::IF_SAME_THEN_ELSE,\n         copies::IFS_SAME_COND,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n+        default_trait_access::DEFAULT_TRAIT_ACCESS,\n         derive::DERIVE_HASH_XOR_EQ,\n         double_comparison::DOUBLE_COMPARISONS,\n         double_parens::DOUBLE_PARENS,\n@@ -547,6 +548,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         identity_conversion::IDENTITY_CONVERSION,\n         identity_op::IDENTITY_OP,\n         if_let_redundant_pattern_matching::IF_LET_REDUNDANT_PATTERN_MATCHING,\n+        indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n         infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH,\n         infinite_iter::INFINITE_ITER,\n         inline_fn_without_body::INLINE_FN_WITHOUT_BODY,\n@@ -715,6 +717,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n         const_static_lifetime::CONST_STATIC_LIFETIME,\n+        default_trait_access::DEFAULT_TRAIT_ACCESS,\n         enum_variants::ENUM_VARIANT_NAMES,\n         enum_variants::MODULE_INCEPTION,\n         eq_op::OP_REF,\n@@ -859,7 +862,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n \n     reg.register_lint_group(\"clippy_correctness\", vec![\n         approx_const::APPROX_CONSTANT,\n-        array_indexing::OUT_OF_BOUNDS_INDEXING,\n         attrs::DEPRECATED_SEMVER,\n         attrs::USELESS_ATTRIBUTE,\n         bit_mask::BAD_BIT_MASK,\n@@ -877,6 +879,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         erasing_op::ERASING_OP,\n         formatting::POSSIBLE_MISSING_COMMA,\n         functions::NOT_UNSAFE_PTR_ARG_DEREF,\n+        indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n         infinite_iter::INFINITE_ITER,\n         inline_fn_without_body::INLINE_FN_WITHOUT_BODY,\n         invalid_ref::INVALID_REF,\n@@ -937,6 +940,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         mutex_atomic::MUTEX_INTEGER,\n         needless_borrow::NEEDLESS_BORROW,\n         ranges::RANGE_PLUS_ONE,\n+        unwrap::PANICKING_UNWRAP,\n         unwrap::UNNECESSARY_UNWRAP,\n     ]);\n }"}, {"sha": "1c063464fcc27a00cc7da016151ca94b583b9cd4", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -59,7 +59,7 @@ impl LintPass for LifetimePass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LifetimePass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, _, _, ref generics, id) = item.node {\n+        if let ItemFn(ref decl, _, ref generics, id) = item.node {\n             check_fn_inner(cx, decl, Some(id), generics, item.span);\n         }\n     }\n@@ -101,18 +101,31 @@ fn check_fn_inner<'a, 'tcx>(\n     }\n \n     let mut bounds_lts = Vec::new();\n-    for typ in generics.ty_params() {\n+    let types = generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamKind::Type { .. } => Some(param),\n+        GenericParamKind::Lifetime { .. } => None,\n+    });\n+    for typ in types {\n         for bound in &typ.bounds {\n-            if let TraitTyParamBound(ref trait_ref, _) = *bound {\n+            let mut visitor = RefVisitor::new(cx);\n+            walk_param_bound(&mut visitor, bound);\n+            if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n+                return;\n+            }\n+            if let GenericBound::Trait(ref trait_ref, _) = *bound {\n                 let params = &trait_ref\n                     .trait_ref\n                     .path\n                     .segments\n                     .last()\n                     .expect(\"a path must have at least one segment\")\n-                    .parameters;\n+                    .args;\n                 if let Some(ref params) = *params {\n-                    for bound in &params.lifetimes {\n+                    let lifetimes = params.args.iter().filter_map(|arg| match arg {\n+                        GenericArg::Lifetime(lt) => Some(lt),\n+                        GenericArg::Type(_) => None,\n+                    });\n+                    for bound in lifetimes {\n                         if bound.name.name() != \"'static\" && !bound.is_elided() {\n                             return;\n                         }\n@@ -225,9 +238,9 @@ fn could_use_elision<'a, 'tcx: 'a>(\n fn allowed_lts_from(named_generics: &[GenericParam]) -> HashSet<RefLt> {\n     let mut allowed_lts = HashSet::new();\n     for par in named_generics.iter() {\n-        if let GenericParam::Lifetime(ref lt) = *par {\n-            if lt.bounds.is_empty() {\n-                allowed_lts.insert(RefLt::Named(lt.lifetime.name.name()));\n+        if let GenericParamKind::Lifetime { .. } = par.kind {\n+            if par.bounds.is_empty() {\n+                allowed_lts.insert(RefLt::Named(par.name.name()));\n             }\n         }\n     }\n@@ -290,8 +303,12 @@ impl<'v, 't> RefVisitor<'v, 't> {\n     }\n \n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n-        if let Some(ref last_path_segment) = last_path_segment(qpath).parameters {\n-            if !last_path_segment.parenthesized && last_path_segment.lifetimes.is_empty() {\n+        if let Some(ref last_path_segment) = last_path_segment(qpath).args {\n+            if !last_path_segment.parenthesized\n+                && !last_path_segment.args.iter().any(|arg| match arg {\n+                    GenericArg::Lifetime(_) => true,\n+                    GenericArg::Type(_) => false,\n+                }) {\n                 let hir_id = self.cx.tcx.hir.node_to_hir_id(ty.id);\n                 match self.cx.tables.qpath_def(qpath, hir_id) {\n                     Def::TyAlias(def_id) | Def::Struct(def_id) => {\n@@ -327,10 +344,12 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             TyPath(ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n             },\n-            TyImplTraitExistential(ref exist_ty, _) => {\n-                for bound in &exist_ty.bounds {\n-                    if let RegionTyParamBound(_) = *bound {\n-                        self.record(&None);\n+            TyImplTraitExistential(exist_ty_id, _, _) => {\n+                if let ItemExistential(ref exist_ty) = self.cx.tcx.hir.expect_item(exist_ty_id.id).node {\n+                    for bound in &exist_ty.bounds {\n+                        if let GenericBound::Outlives(_) = *bound {\n+                            self.record(&None);\n+                        }\n                     }\n                 }\n             }\n@@ -370,7 +389,7 @@ fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &\n                 let allowed_lts = allowed_lts_from(&pred.bound_generic_params);\n                 // now walk the bounds\n                 for bound in pred.bounds.iter() {\n-                    walk_ty_param_bound(&mut visitor, bound);\n+                    walk_param_bound(&mut visitor, bound);\n                 }\n                 // and check that all lifetimes are allowed\n                 match visitor.into_vec() {\n@@ -411,7 +430,7 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n         // don't want to spuriously remove them\n         // `'b` in `'a: 'b` is useless unless used elsewhere in\n         // a non-lifetime bound\n-        if param.is_type_param() {\n+        if let GenericParamKind::Type { .. } = param.kind {\n             walk_generic_param(self, param)\n         }\n     }\n@@ -421,9 +440,11 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n }\n \n fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n-    let hs = generics\n-        .lifetimes()\n-        .map(|lt| (lt.lifetime.name.name(), lt.lifetime.span))\n+    let hs = generics.params.iter()\n+        .filter_map(|par| match par.kind {\n+            GenericParamKind::Lifetime { .. } => Some((par.name.name(), par.span)),\n+            _ => None,\n+        })\n         .collect();\n     let mut checker = LifetimeChecker { map: hs };\n "}, {"sha": "8808de9025d2df9ec437d83be7cfa188f17498b7", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -640,7 +640,7 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n             }\n         },\n         ExprBlock(ref b, _) => never_loop_block(b, main_loop_id),\n-        ExprAgain(d) => {\n+        ExprContinue(d) => {\n             let id = d.target_id\n                 .expect(\"target id can only be missing in the presence of compilation errors\");\n             if id == main_loop_id {"}, {"sha": "97c2522d2ced803c2b91d28e76752fd0facdba52", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -36,7 +36,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     ExprClosure(_, ref decl, closure_eid, _, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n                         let closure_expr = remove_blocks(&body.value);\n-                        let ty = cx.tables.pat_ty(&body.arguments[0].pat);\n                         if_chain! {\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n@@ -45,6 +44,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             // the method is being called on a known type (option or iterator)\n                             if let Some(type_name) = get_type_name(cx, expr, &args[0]);\n                             then {\n+                                // We know that body.arguments is not empty at this point\n+                                let ty = cx.tables.pat_ty(&body.arguments[0].pat);\n                                 // look for derefs, for .map(|x| *x)\n                                 if only_derefs(cx, &*closure_expr, arg_ident) &&\n                                     // .cloned() only removes one level of indirection, don't lint on more\n@@ -103,7 +104,7 @@ fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n             let arg_segment = [\n                 PathSegment {\n                     name: id,\n-                    parameters: None,\n+                    args: None,\n                     infer_types: true,\n                 },\n             ];"}, {"sha": "b5e1780fd0ca062cb917845907859cefdf139920", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -7,7 +7,7 @@ use std::fmt;\n use std::iter;\n use syntax::ast;\n use syntax::codemap::{Span, BytePos};\n-use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self, \n+use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self,\n             is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n             match_type, method_chain_args, match_var, return_ty, remove_blocks, same_tys, single_segment_path, snippet,\n             span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n@@ -336,7 +336,7 @@ declare_clippy_lint! {\n ///\n /// **Known problems:** If the function has side-effects, not calling it will\n /// change the semantic of the program, but you shouldn't rely on that anyway.\n-/// \n+///\n /// **Example:**\n /// ```rust\n /// foo.expect(&format(\"Err {}: {}\", err_code, err_msg))\n@@ -1020,7 +1020,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n                 }\n             }\n         };\n-        \n+\n         snippet(cx, a.span, \"..\").into_owned()\n     }\n \n@@ -1077,7 +1077,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n         }\n \n         let sugg: Cow<_> = snippet(cx, arg.span, \"..\");\n-        \n+\n         span_lint_and_sugg(\n             cx,\n             EXPECT_FUN_CALL,\n@@ -2091,26 +2091,35 @@ impl SelfKind {\n \n fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n     single_segment_ty(ty).map_or(false, |seg| {\n-        generics.ty_params().any(|param| {\n-            param.name == seg.name && param.bounds.iter().any(|bound| {\n-                if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n-                    let path = &ptr.trait_ref.path;\n-                    match_path(path, name) && path.segments.last().map_or(false, |s| {\n-                        if let Some(ref params) = s.parameters {\n-                            if params.parenthesized {\n-                                false\n+        generics.params.iter().any(|param| match param.kind {\n+            hir::GenericParamKind::Type { .. } => {\n+                param.name.name() == seg.name && param.bounds.iter().any(|bound| {\n+                    if let hir::GenericBound::Trait(ref ptr, ..) = *bound {\n+                        let path = &ptr.trait_ref.path;\n+                        match_path(path, name) && path.segments.last().map_or(false, |s| {\n+                            if let Some(ref params) = s.args {\n+                                if params.parenthesized {\n+                                    false\n+                                } else {\n+                                    // FIXME(flip1995): messy, improve if there is a better option\n+                                    // in the compiler\n+                                    let types: Vec<_> = params.args.iter().filter_map(|arg| match arg {\n+                                        hir::GenericArg::Type(ty) => Some(ty),\n+                                        _ => None,\n+                                    }).collect();\n+                                    types.len() == 1\n+                                        && (is_self_ty(&types[0]) || is_ty(&*types[0], self_ty))\n+                                }\n                             } else {\n-                                params.types.len() == 1\n-                                    && (is_self_ty(&params.types[0]) || is_ty(&*params.types[0], self_ty))\n+                                false\n                             }\n-                        } else {\n-                            false\n-                        }\n-                    })\n-                } else {\n-                    false\n-                }\n-            })\n+                        })\n+                    } else {\n+                        false\n+                    }\n+                })\n+            },\n+            _ => false,\n         })\n     })\n }"}, {"sha": "414e507a55b4651892428cc8349b58038e6f24fa", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -558,7 +558,7 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n         .ctxt()\n         .outer()\n         .expn_info()\n-        .map_or(false, |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)))\n+        .map_or(false, |info| matches!(info.format, ExpnFormat::MacroAttribute(_)))\n }\n \n /// Test whether `def` is a variable defined outside a macro."}, {"sha": "94247e64b1051f39e07aab8b3a8143895934f877", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -189,13 +189,13 @@ impl LintPass for MiscEarly {\n impl EarlyLintPass for MiscEarly {\n     fn check_generics(&mut self, cx: &EarlyContext, gen: &Generics) {\n         for param in &gen.params {\n-            if let GenericParam::Type(ref ty) = *param {\n-                let name = ty.ident.name.as_str();\n+            if let GenericParamKind::Type { .. } = param.kind {\n+                let name = param.ident.name.as_str();\n                 if constants::BUILTIN_TYPES.contains(&&*name) {\n                     span_lint(\n                         cx,\n                         BUILTIN_TYPE_SHADOW,\n-                        ty.ident.span,\n+                        param.ident.span,\n                         &format!(\"This generic shadows the built-in type `{}`\", name),\n                     );\n                 }\n@@ -296,7 +296,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n         match expr.node {\n             ExprKind::Call(ref paren, _) => if let ExprKind::Paren(ref closure) = paren.node {\n-                if let ExprKind::Closure(_, _, ref decl, ref block, _) = closure.node {\n+                if let ExprKind::Closure(_, _, _, ref decl, ref block, _) = closure.node {\n                     span_lint_and_then(\n                         cx,\n                         REDUNDANT_CLOSURE_CALL,\n@@ -327,7 +327,7 @@ impl EarlyLintPass for MiscEarly {\n             if_chain! {\n                 if let StmtKind::Local(ref local) = w[0].node;\n                 if let Option::Some(ref t) = local.init;\n-                if let ExprKind::Closure(_, _, _, _, _) = t.node;\n+                if let ExprKind::Closure(..) = t.node;\n                 if let PatKind::Ident(_, ident, _) = local.pat.node;\n                 if let StmtKind::Semi(ref second) = w[1].node;\n                 if let ExprKind::Assign(_, ref call) = second.node;"}, {"sha": "ebb3869f48c5904b9cd12eeb7a241d26cee0f21f", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -143,6 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemGlobalAsm(..) => \"an assembly blob\",\n             hir::ItemTy(..) => \"a type alias\",\n             hir::ItemUnion(..) => \"a union\",\n+            hir::ItemExistential(..) => \"an existential type\",\n             hir::ItemExternCrate(..) |\n             hir::ItemForeignMod(..) |\n             hir::ItemImpl(..) |"}, {"sha": "03a45bc18472f7fd12662b555cb9aa7102aec557", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -72,8 +72,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., abi, _, attrs) => {\n-                if abi != Abi::Rust {\n+            FnKind::ItemFn(.., header, _, attrs) => {\n+                if header.abi != Abi::Rust {\n                     return;\n                 }\n                 for a in attrs {\n@@ -218,8 +218,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                             if let TyPath(QPath::Resolved(_, ref path)) = input.node;\n                             if let Some(elem_ty) = path.segments.iter()\n                                 .find(|seg| seg.name == \"Vec\")\n-                                .and_then(|ps| ps.parameters.as_ref())\n-                                .map(|params| &params.types[0]);\n+                                .and_then(|ps| ps.args.as_ref())\n+                                .map(|params| params.args.iter().find_map(|arg| match arg {\n+                                    GenericArg::Type(ty) => Some(ty),\n+                                    GenericArg::Lifetime(_) => None,\n+                                }).unwrap());\n                             then {\n                                 let slice_ty = format!(\"&[{}]\", snippet(cx, elem_ty.span, \"_\"));\n                                 db.span_suggestion(input.span,"}, {"sha": "013bab69d798ba0657ea347639e7d6a6dc6c2a97", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n \n-use crate::utils::{self, paths};\n+use crate::utils::{self, paths, span_lint, in_external_macro};\n \n /// **What it does:**\n /// Checks for the usage of negated comparision operators on types which only implement\n@@ -53,6 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n \n+            if !in_external_macro(cx, expr.span);\n             if let Expr_::ExprUnary(UnOp::UnNot, ref inner) = expr.node;\n             if let Expr_::ExprBinary(ref op, ref left, _) = inner.node;\n             if let BinOp_::BiLe | BinOp_::BiGe | BinOp_::BiLt | BinOp_::BiGt = op.node;\n@@ -78,7 +79,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n                 };\n \n                 if implements_partial_ord && !implements_ord {\n-                    cx.span_lint(\n+                    span_lint(\n+                        cx,\n                         NEG_CMP_OP_ON_PARTIAL_ORD,\n                         expr.span,\n                         \"The use of negated comparision operators on partially orded \\"}, {"sha": "adc91bacdef7ef2d1623453466012dc2ed9a962e", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -99,11 +99,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                     if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         let name = impl_item.name;\n                         let id = impl_item.id;\n-                        if sig.constness == hir::Constness::Const {\n+                        if sig.header.constness == hir::Constness::Const {\n                             // can't be implemented by default\n                             return;\n                         }\n-                        if impl_item.generics.params.iter().any(|gen| gen.is_type_param()) {\n+                        if impl_item.generics.params.iter().any(|gen| match gen.kind {\n+                            hir::GenericParamKind::Type { .. } => true,\n+                            _ => false\n+                        }) {\n                             // when the result of `new()` depends on a type parameter we should not require\n                             // an\n                             // impl of `Default`"}, {"sha": "b49e3f87ec99342b8d09219b7992bb37ed8dd9b2", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n \n impl EarlyLintPass for NonExpressiveNames {\n     fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n-        if let ItemKind::Fn(ref decl, _, _, _, _, ref blk) = item.node {\n+        if let ItemKind::Fn(ref decl, _, _, ref blk) = item.node {\n             do_check(self, cx, &item.attrs, decl, blk);\n         }\n     }"}, {"sha": "68cecc8de678fb02f5ff42d98cac1c9f0737dd7c", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -103,7 +103,7 @@ impl LintPass for PointerPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, _, _, _, body_id) = item.node {\n+        if let ItemFn(ref decl, _, _, body_id) = item.node {\n             check_fn(cx, decl, item.id, Some(body_id));\n         }\n     }\n@@ -160,10 +160,15 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                 let mut ty_snippet = None;\n                 if_chain! {\n                     if let TyPath(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n-                    if let Some(&PathSegment{parameters: Some(ref parameters), ..}) = path.segments.last();\n-                    if parameters.types.len() == 1;\n+                    if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n                     then {\n-                        ty_snippet = snippet_opt(cx, parameters.types[0].span);\n+                        let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty),\n+                            _ => None,\n+                        }).collect();\n+                        if types.len() == 1 {\n+                            ty_snippet = snippet_opt(cx, types[0].span);\n+                        }\n                     }\n                 };\n                 if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n@@ -218,9 +223,12 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                     if let TyPath(ref path) = ty.node;\n                     if let QPath::Resolved(None, ref pp) = *path;\n                     if let [ref bx] = *pp.segments;\n-                    if let Some(ref params) = bx.parameters;\n+                    if let Some(ref params) = bx.args;\n                     if !params.parenthesized;\n-                    if let [ref inner] = *params.types;\n+                    if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n+                        GenericArg::Type(ty) => Some(ty),\n+                        GenericArg::Lifetime(_) => None,\n+                    });\n                     then {\n                         let replacement = snippet_opt(cx, inner.span);\n                         if let Some(r) = replacement {"}, {"sha": "c2e981979a18d34aa4f6dd9439741d03912fada9", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -455,9 +455,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n fn get_type_snippet(cx: &LateContext, path: &QPath, to_ref_ty: Ty) -> String {\n     let seg = last_path_segment(path);\n     if_chain! {\n-        if let Some(ref params) = seg.parameters;\n+        if let Some(ref params) = seg.args;\n         if !params.parenthesized;\n-        if let Some(to_ty) = params.types.get(1);\n+        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            GenericArg::Lifetime(_) => None,\n+        }).nth(1);\n         if let TyRptr(_, ref to_ty) = to_ty.node;\n         then {\n             return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();"}, {"sha": "8d0ddbec98829537fcbbc6e0a46441ffb33603ad", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -84,8 +84,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., abi, _, attrs) => {\n-                if abi != Abi::Rust {\n+            FnKind::ItemFn(.., header, _, attrs) => {\n+                if header.abi != Abi::Rust {\n                     return;\n                 }\n                 for a in attrs {"}, {"sha": "887e9f12712b423a19404fdb1928e75faebe6372", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -180,9 +180,12 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n     if_chain! {\n-        if let Some(ref params) = last.parameters;\n+        if let Some(ref params) = last.args;\n         if !params.parenthesized;\n-        if let Some(ty) = params.types.get(0);\n+        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            GenericArg::Lifetime(_) => None,\n+        });\n         if let TyPath(ref qpath) = ty.node;\n         if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(ty.id)));\n         if match_def_path(cx.tcx, did, path);\n@@ -244,24 +247,35 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                 QPath::Resolved(Some(ref ty), ref p) => {\n                     check_ty(cx, ty, is_local);\n                     for ty in p.segments.iter().flat_map(|seg| {\n-                        seg.parameters\n+                        seg.args\n                             .as_ref()\n-                            .map_or_else(|| [].iter(), |params| params.types.iter())\n+                            .map_or_else(|| [].iter(), |params| params.args.iter())\n+                            .filter_map(|arg| match arg {\n+                                GenericArg::Type(ty) => Some(ty),\n+                                GenericArg::Lifetime(_) => None,\n+                            })\n                     }) {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n                 QPath::Resolved(None, ref p) => for ty in p.segments.iter().flat_map(|seg| {\n-                    seg.parameters\n+                    seg.args\n                         .as_ref()\n-                        .map_or_else(|| [].iter(), |params| params.types.iter())\n+                        .map_or_else(|| [].iter(), |params| params.args.iter())\n+                        .filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty),\n+                            GenericArg::Lifetime(_) => None,\n+                        })\n                 }) {\n                     check_ty(cx, ty, is_local);\n                 },\n                 QPath::TypeRelative(ref ty, ref seg) => {\n                     check_ty(cx, ty, is_local);\n-                    if let Some(ref params) = seg.parameters {\n-                        for ty in params.types.iter() {\n+                    if let Some(ref params) = seg.args {\n+                        for ty in params.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty),\n+                            GenericArg::Lifetime(_) => None,\n+                        }) {\n                             check_ty(cx, ty, is_local);\n                         }\n                     }\n@@ -288,9 +302,12 @@ fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifeti\n                 if Some(def_id) == cx.tcx.lang_items().owned_box();\n                 if let QPath::Resolved(None, ref path) = *qpath;\n                 if let [ref bx] = *path.segments;\n-                if let Some(ref params) = bx.parameters;\n+                if let Some(ref params) = bx.args;\n                 if !params.parenthesized;\n-                if let [ref inner] = *params.types;\n+                if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    GenericArg::Lifetime(_) => None,\n+                });\n                 then {\n                     if is_any_trait(inner) {\n                         // Ignore `Box<Any>` types, see #1884 for details.\n@@ -1208,7 +1225,10 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n             TyTraitObject(ref param_bounds, _) => {\n                 let has_lifetime_parameters = param_bounds\n                     .iter()\n-                    .any(|bound| bound.bound_generic_params.iter().any(|gen| gen.is_lifetime_param()));\n+                    .any(|bound| bound.bound_generic_params.iter().any(|gen| match gen.kind {\n+                        GenericParamKind::Lifetime { .. } => true,\n+                        _ => false,\n+                    }));\n                 if has_lifetime_parameters {\n                     // complex trait bounds like A<'a, 'b>\n                     (50 * self.nest, 1)\n@@ -1859,7 +1879,11 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a BuildHasher.\n     fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n         if let TyPath(QPath::Resolved(None, ref path)) = hir_ty.node {\n-            let params = &path.segments.last().as_ref()?.parameters.as_ref()?.types;\n+            let params: Vec<_> = path.segments.last().as_ref()?.args.as_ref()?\n+                .args.iter().filter_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    GenericArg::Lifetime(_) => None,\n+                }).collect();\n             let params_len = params.len();\n \n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);"}, {"sha": "ca3000326750cc23a0781ac36f4f6d18b58577b3", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBreak(destination, _) | hir::ExprAgain(destination) => if let Some(label) = destination.label {\n+            hir::ExprBreak(destination, _) | hir::ExprContinue(destination) => if let Some(label) = destination.label {\n                 self.labels.remove(&label.name.as_str());\n             },\n             hir::ExprLoop(_, Some(label), _) | hir::ExprWhile(_, _, Some(label)) => {"}, {"sha": "7355b38fd6bf61cd65e6857b76188ad6fa84e45d", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -32,6 +32,27 @@ declare_clippy_lint! {\n     \"checks for calls of unwrap[_err]() that cannot fail\"\n }\n \n+/// **What it does:** Checks for calls of `unwrap[_err]()` that will always fail.\n+///\n+/// **Why is this bad?** If panicking is desired, an explicit `panic!()` should be used.\n+///\n+/// **Known problems:** This lint only checks `if` conditions not assignments.\n+/// So something like `let x: Option<()> = None; x.unwrap();` will not be recognized.\n+///\n+/// **Example:**\n+/// ```rust\n+/// if option.is_none() {\n+///     do_something_with(option.unwrap())\n+/// }\n+/// ```\n+///\n+/// This code will always panic. The if condition should probably be inverted.\n+declare_clippy_lint! {\n+    pub PANICKING_UNWRAP,\n+    nursery,\n+    \"checks for calls of unwrap[_err]() that will always fail\"\n+}\n+\n pub struct Pass;\n \n /// Visitor that keeps track of which variables are unwrappable.\n@@ -124,17 +145,28 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                 if [\"unwrap\", \"unwrap_err\"].contains(&&*method_name.name.as_str());\n                 let call_to_unwrap = method_name.name == \"unwrap\";\n                 if let Some(unwrappable) = self.unwrappables.iter()\n-                    .find(|u| u.ident.def == path.def && call_to_unwrap == u.safe_to_unwrap);\n+                    .find(|u| u.ident.def == path.def);\n                 then {\n-                    span_lint_and_then(\n-                        self.cx,\n-                        UNNECESSARY_UNWRAP,\n-                        expr.span,\n-                        &format!(\"You checked before that `{}()` cannot fail. \\\n-                        Instead of checking and unwrapping, it's better to use `if let` or `match`.\",\n-                        method_name.name),\n-                        |db| { db.span_label(unwrappable.check.span, \"the check is happening here\"); },\n-                    );\n+                    if call_to_unwrap == unwrappable.safe_to_unwrap {\n+                        span_lint_and_then(\n+                            self.cx,\n+                            UNNECESSARY_UNWRAP,\n+                            expr.span,\n+                            &format!(\"You checked before that `{}()` cannot fail. \\\n+                            Instead of checking and unwrapping, it's better to use `if let` or `match`.\",\n+                            method_name.name),\n+                            |db| { db.span_label(unwrappable.check.span, \"the check is happening here\"); },\n+                        );\n+                    } else {\n+                        span_lint_and_then(\n+                            self.cx,\n+                            PANICKING_UNWRAP,\n+                            expr.span,\n+                            &format!(\"This call to `{}()` will always panic.\",\n+                            method_name.name),\n+                            |db| { db.span_label(unwrappable.check.span, \"because of this check\"); },\n+                        );\n+                    }\n                 }\n             }\n             walk_expr(self, expr);\n@@ -148,7 +180,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n \n impl<'a> LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_UNWRAP)\n+        lint_array!(PANICKING_UNWRAP, UNNECESSARY_UNWRAP)\n     }\n }\n "}, {"sha": "170db6ceabb6b804e072842c84b17a0fded517bb", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -58,9 +58,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n             if let ItemImpl(.., ref item_type, ref refs) = item.node;\n             if let Ty_::TyPath(QPath::Resolved(_, ref item_path)) = item_type.node;\n             then {\n-                let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).parameters;\n+                let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                 let should_check = if let Some(ref params) = *parameters {\n-                    !params.parenthesized && params.lifetimes.len() == 0\n+                    !params.parenthesized && !params.args.iter().any(|arg| match arg {\n+                        GenericArg::Lifetime(_) => true,\n+                        GenericArg::Type(_) => false,\n+                    })\n                 } else {\n                     true\n                 };"}, {"sha": "df6a06bc4784926475b670850dffab178da99bd7", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -432,7 +432,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 }\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprAgain(ref _destination) => {\n+            Expr_::ExprContinue(ref _destination) => {\n                 let destination_pat = self.next(\"destination\");\n                 println!(\"Again(ref {}) = {};\", destination_pat, current);\n                 // FIXME: implement label printing"}, {"sha": "ee6b004dc6cbd4b158cb105e8c8d40e946718708", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n         match (&left.node, &right.node) {\n             (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprAgain(li), &ExprAgain(ri)) => {\n+            (&ExprContinue(li), &ExprContinue(ri)) => {\n                 both(&li.label, &ri.label, |l, r| l.name.as_str() == r.name.as_str())\n             },\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n@@ -152,6 +152,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         left.ident.name == right.ident.name && self.eq_expr(&left.expr, &right.expr)\n     }\n \n+    fn eq_generic_arg(&mut self, left: &GenericArg, right: &GenericArg) -> bool {\n+        match (left, right) {\n+            (GenericArg::Lifetime(l_lt), GenericArg::Lifetime(r_lt)) => self.eq_lifetime(l_lt, r_lt),\n+            (GenericArg::Type(l_ty), GenericArg::Type(r_ty)) => self.eq_ty(l_ty, r_ty),\n+            _ => false,\n+        }\n+    }\n+\n     fn eq_lifetime(&mut self, left: &Lifetime, right: &Lifetime) -> bool {\n         left.name == right.name\n     }\n@@ -201,10 +209,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n-    fn eq_path_parameters(&mut self, left: &PathParameters, right: &PathParameters) -> bool {\n+    fn eq_path_parameters(&mut self, left: &GenericArgs, right: &GenericArgs) -> bool {\n         if !(left.parenthesized || right.parenthesized) {\n-            over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r))\n-                && over(&left.types, &right.types, |l, r| self.eq_ty(l, r))\n+            over(&left.args, &right.args, |l, r| self.eq_generic_arg(l, r)) // FIXME(flip1995): may not work\n                 && over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n         } else if left.parenthesized && right.parenthesized {\n             over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r))\n@@ -224,7 +231,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         if left.name.as_str() != right.name.as_str() {\n             return false;\n         }\n-        match (&left.parameters, &right.parameters) {\n+        match (&left.args, &right.args) {\n             (&None, &None) => true,\n             (&Some(ref l), &Some(ref r)) => self.eq_path_parameters(l, r),\n             _ => false,\n@@ -345,8 +352,8 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprAgain(i) => {\n-                let c: fn(_) -> _ = ExprAgain;\n+            ExprContinue(i) => {\n+                let c: fn(_) -> _ = ExprContinue;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.name);"}, {"sha": "9d92147048c3237509f5a12eadb2dc2dcc310b56", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -300,7 +300,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprAgain(_) => println!(\"{}Again\", ind),\n+        hir::ExprContinue(_) => println!(\"{}Again\", ind),\n         hir::ExprRet(ref e) => {\n             println!(\"{}Ret\", ind);\n             if let Some(ref e) = *e {\n@@ -380,6 +380,9 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n         hir::ItemTy(..) => {\n             println!(\"type alias for {:?}\", cx.tcx.type_of(did));\n         },\n+        hir::ItemExistential(..) => {\n+            println!(\"existential type with real type {:?}\", cx.tcx.type_of(did));\n+        },\n         hir::ItemEnum(..) => {\n             println!(\"enum definition of type {:?}\", cx.tcx.type_of(did));\n         },"}, {"sha": "ae8ffcf2fce61fd3589e82f9e3d8333f46348634", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -57,7 +57,7 @@ pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro(span: Span) -> bool {\n     span.ctxt().outer().expn_info().map_or(false, |info| {\n-        match info.callee.format {\n+        match info.format {\n             // don't treat range expressions desugared to structs as \"in_macro\"\n             ExpnFormat::CompilerDesugaring(kind) => kind != CompilerDesugaringKind::DotFill,\n             _ => true,\n@@ -68,7 +68,7 @@ pub fn in_macro(span: Span) -> bool {\n /// Returns true if `expn_info` was expanded by range expressions.\n pub fn is_range_expression(span: Span) -> bool {\n     span.ctxt().outer().expn_info().map_or(false, |info| {\n-        match info.callee.format {\n+        match info.format {\n             ExpnFormat::CompilerDesugaring(CompilerDesugaringKind::DotFill) => true,\n             _ => false,\n         }\n@@ -84,12 +84,12 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     /// this after other checks have already happened.\n     fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, info: &ExpnInfo) -> bool {\n         // no ExpnInfo = no macro\n-        if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n+        if let ExpnFormat::MacroAttribute(..) = info.format {\n             // these are all plugins\n             return true;\n         }\n         // no span for the callee = external macro\n-        info.callee.span.map_or(true, |span| {\n+        info.def_site.map_or(true, |span| {\n             // no snippet = external macro or compiler-builtin expansion\n             cx.sess()\n                 .codemap()\n@@ -524,7 +524,7 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n         match node {\n             Node::NodeBlock(block) => Some(block),\n             Node::NodeItem(&Item {\n-                node: ItemFn(_, _, _, _, _, eid),\n+                node: ItemFn(_, _, _, eid),\n                 ..\n             }) | Node::NodeImplItem(&ImplItem {\n                 node: ImplItemKind::Method(_, eid),\n@@ -768,7 +768,7 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n         let span_name_span = span.ctxt()\n             .outer()\n             .expn_info()\n-            .map(|ei| (ei.callee.name(), ei.call_site));\n+            .map(|ei| (ei.format.name(), ei.call_site));\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n@@ -791,7 +791,7 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n     let span_name_span = span.ctxt()\n         .outer()\n         .expn_info()\n-        .map(|ei| (ei.callee.name(), ei.call_site));\n+        .map(|ei| (ei.format.name(), ei.call_site));\n \n     match span_name_span {\n         Some((mac_name, new_span)) if mac_name == name => Some(new_span),\n@@ -981,6 +981,7 @@ pub fn opt_def_id(def: Def) -> Option<DefId> {\n         Def::Const(id) |\n         Def::AssociatedConst(id) |\n         Def::Macro(id, ..) |\n+        Def::Existential(id) |\n         Def::GlobalAsm(id) => Some(id),\n \n         Def::Upvar(..) | Def::Local(_) | Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n@@ -1128,3 +1129,17 @@ pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n \n     without\n }\n+\n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt, node: NodeId) -> bool {\n+    let map = &tcx.hir;\n+    let mut prev_enclosing_node = None;\n+    let mut enclosing_node = node;\n+    while Some(enclosing_node) != prev_enclosing_node {\n+        if is_automatically_derived(map.attrs(enclosing_node)) {\n+            return true;\n+        }\n+        prev_enclosing_node = Some(enclosing_node);\n+        enclosing_node = map.get_parent(enclosing_node);\n+    }\n+    false\n+}"}, {"sha": "7606f4f8471e9f8ddfc4762dee38f12791630e37", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -24,6 +24,7 @@ pub const C_VOID: [&str; 4] = [\"std\", \"os\", \"raw\", \"c_void\"];\n pub const C_VOID_LIBC: [&str; 2] = [\"libc\", \"c_void\"];\n pub const DEBUG_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Debug\", \"fmt\"];\n pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n+pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];"}, {"sha": "eb2197a5891e7afcad58c9eb041117d661596c31", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -52,7 +52,7 @@ impl<'a> Sugg<'a> {\n                 hir::ExprIf(..) |\n                 hir::ExprUnary(..) |\n                 hir::ExprMatch(..) => Sugg::MaybeParen(snippet),\n-                hir::ExprAgain(..) |\n+                hir::ExprContinue(..) |\n                 hir::ExprYield(..) |\n                 hir::ExprArray(..) |\n                 hir::ExprBlock(..) |\n@@ -100,6 +100,7 @@ impl<'a> Sugg<'a> {\n             ast::ExprKind::ObsoleteInPlace(..) |\n             ast::ExprKind::Unary(..) |\n             ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            ast::ExprKind::Async(..) |\n             ast::ExprKind::Block(..) |\n             ast::ExprKind::Break(..) |\n             ast::ExprKind::Call(..) |"}, {"sha": "612b03e54db594d8a4b6d6d0b496ea109c0d7116", "filename": "min_version.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/min_version.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/min_version.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/min_version.txt?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -1,7 +1,7 @@\n-rustc 1.28.0-nightly (86a8f1a63 2018-06-17)\n+rustc 1.28.0-nightly (01cc982e9 2018-06-24)\n binary: rustc\n-commit-hash: 86a8f1a6374dd558ebdafe061e61720a73ae732c\n-commit-date: 2018-06-17\n+commit-hash: 01cc982e936120acb0424e41de14e42ba2d88c6f\n+commit-date: 2018-06-24\n host: x86_64-unknown-linux-gnu\n release: 1.28.0-nightly\n LLVM version: 6.0"}, {"sha": "419f61f860b05ecc4cc171ac385258232e2c2841", "filename": "src/driver.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -13,7 +13,7 @@ extern crate rustc_plugin;\n extern crate syntax;\n \n use rustc_driver::{driver::CompileController, Compilation};\n-use std::process::Command;\n+use std::process::{exit, Command};\n \n #[allow(print_stdout)]\n fn show_version() {\n@@ -133,5 +133,10 @@ pub fn main() {\n     }\n     controller.compilation_done.stop = Compilation::Stop;\n \n-    rustc_driver::run_compiler(&args, Box::new(controller), None, None);\n+    if rustc_driver::run_compiler(&args, Box::new(controller), None, None)\n+        .0\n+        .is_err()\n+    {\n+        exit(101);\n+    }\n }"}, {"sha": "b35df667f27ab45540a8054dc2adbdc93ace661f", "filename": "tests/run-pass/issue-2862.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Frun-pass%2Fissue-2862.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Frun-pass%2Fissue-2862.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-2862.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -0,0 +1,14 @@\n+pub trait FooMap {\n+    fn map<B, F: Fn() -> B>(&self, f: F) -> B;\n+}\n+\n+impl FooMap for bool {\n+    fn map<B, F: Fn() -> B>(&self, f: F) -> B {\n+        f()\n+    }\n+}\n+\n+fn main() {\n+    let a = true;\n+    a.map(|| false);\n+}"}, {"sha": "a01600edac77a06d74891d62bf28486d8e71dd9e", "filename": "tests/ui/array_indexing.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7df5601f5c8b84a73a14e5a3d16100d43573740a/tests%2Fui%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7df5601f5c8b84a73a14e5a3d16100d43573740a/tests%2Fui%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farray_indexing.rs?ref=7df5601f5c8b84a73a14e5a3d16100d43573740a", "patch": "@@ -1,45 +0,0 @@\n-#![feature(plugin)]\n-\n-\n-#![warn(indexing_slicing)]\n-#![warn(out_of_bounds_indexing)]\n-#![allow(no_effect, unnecessary_operation)]\n-\n-fn main() {\n-    let x = [1,2,3,4];\n-    x[0];\n-    x[3];\n-    x[4];\n-    x[1 << 3];\n-    &x[1..5];\n-    &x[0..3];\n-    &x[0..=4];\n-    &x[..=4];\n-    &x[..];\n-    &x[1..];\n-    &x[4..];\n-    &x[5..];\n-    &x[..4];\n-    &x[..5];\n-\n-    let y = &x;\n-    y[0];\n-    &y[1..2];\n-    &y[..];\n-    &y[0..=4];\n-    &y[..=4];\n-\n-    let empty: [i8; 0] = [];\n-    empty[0];\n-    &empty[1..5];\n-    &empty[0..=4];\n-    &empty[..=4];\n-    &empty[..];\n-    &empty[0..];\n-    &empty[0..0];\n-    &empty[0..=0];\n-    &empty[..=0];\n-    &empty[..0];\n-    &empty[1..];\n-    &empty[..4];\n-}"}, {"sha": "d730b012932ac5f317f9b05585ef963e44e6c92b", "filename": "tests/ui/array_indexing.stderr", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7df5601f5c8b84a73a14e5a3d16100d43573740a/tests%2Fui%2Farray_indexing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7df5601f5c8b84a73a14e5a3d16100d43573740a/tests%2Fui%2Farray_indexing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farray_indexing.stderr?ref=7df5601f5c8b84a73a14e5a3d16100d43573740a", "patch": "@@ -1,120 +0,0 @@\n-error: const index is out of bounds\n-  --> $DIR/array_indexing.rs:12:5\n-   |\n-12 |     x[4];\n-   |     ^^^^\n-   |\n-   = note: `-D out-of-bounds-indexing` implied by `-D warnings`\n-\n-error: const index is out of bounds\n-  --> $DIR/array_indexing.rs:13:5\n-   |\n-13 |     x[1 << 3];\n-   |     ^^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:14:6\n-   |\n-14 |     &x[1..5];\n-   |      ^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:16:6\n-   |\n-16 |     &x[0..=4];\n-   |      ^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:17:6\n-   |\n-17 |     &x[..=4];\n-   |      ^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:21:6\n-   |\n-21 |     &x[5..];\n-   |      ^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:23:6\n-   |\n-23 |     &x[..5];\n-   |      ^^^^^^\n-\n-error: indexing may panic\n-  --> $DIR/array_indexing.rs:26:5\n-   |\n-26 |     y[0];\n-   |     ^^^^\n-   |\n-   = note: `-D indexing-slicing` implied by `-D warnings`\n-\n-error: slicing may panic\n-  --> $DIR/array_indexing.rs:27:6\n-   |\n-27 |     &y[1..2];\n-   |      ^^^^^^^\n-\n-error: slicing may panic\n-  --> $DIR/array_indexing.rs:29:6\n-   |\n-29 |     &y[0..=4];\n-   |      ^^^^^^^^\n-\n-error: slicing may panic\n-  --> $DIR/array_indexing.rs:30:6\n-   |\n-30 |     &y[..=4];\n-   |      ^^^^^^^\n-\n-error: const index is out of bounds\n-  --> $DIR/array_indexing.rs:33:5\n-   |\n-33 |     empty[0];\n-   |     ^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:34:6\n-   |\n-34 |     &empty[1..5];\n-   |      ^^^^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:35:6\n-   |\n-35 |     &empty[0..=4];\n-   |      ^^^^^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:36:6\n-   |\n-36 |     &empty[..=4];\n-   |      ^^^^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:40:6\n-   |\n-40 |     &empty[0..=0];\n-   |      ^^^^^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:41:6\n-   |\n-41 |     &empty[..=0];\n-   |      ^^^^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:43:6\n-   |\n-43 |     &empty[1..];\n-   |      ^^^^^^^^^^\n-\n-error: range is out of bounds\n-  --> $DIR/array_indexing.rs:44:6\n-   |\n-44 |     &empty[..4];\n-   |      ^^^^^^^^^^\n-\n-error: aborting due to 19 previous errors\n-"}, {"sha": "c3d4b8de08b3f1f0cf2f65510fc4f19a7716657a", "filename": "tests/ui/checked_unwrap.rs", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fchecked_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fchecked_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -1,75 +1,101 @@\n-#![deny(unnecessary_unwrap)]\n+#![deny(panicking_unwrap, unnecessary_unwrap)]\n+#![allow(if_same_then_else)]\n \n fn main() {\n     let x = Some(());\n     if x.is_some() {\n-        x.unwrap();\n+        x.unwrap(); // unnecessary\n+    } else {\n+        x.unwrap(); // will panic\n     }\n     if x.is_none() {\n-        // nothing to do here\n+        x.unwrap(); // will panic\n     } else {\n-        x.unwrap();\n+        x.unwrap(); // unnecessary\n     }\n     let mut x: Result<(), ()> = Ok(());\n     if x.is_ok() {\n-        x.unwrap();\n+        x.unwrap(); // unnecessary\n+        x.unwrap_err(); // will panic\n     } else {\n-        x.unwrap_err();\n+        x.unwrap(); // will panic\n+        x.unwrap_err(); // unnecessary\n     }\n     if x.is_err() {\n-        x.unwrap_err();\n+        x.unwrap(); // will panic\n+        x.unwrap_err(); // unnecessary\n     } else {\n-        x.unwrap();\n+        x.unwrap(); // unnecessary\n+        x.unwrap_err(); // will panic\n     }\n     if x.is_ok() {\n         x = Err(());\n-        x.unwrap();\n+        x.unwrap(); // not unnecessary because of mutation of x\n+        // it will always panic but the lint is not smart enoguh to see this (it only checks if conditions).\n     } else {\n         x = Ok(());\n-        x.unwrap_err();\n+        x.unwrap_err(); // not unnecessary because of mutation of x\n+        // it will always panic but the lint is not smart enoguh to see this (it only checks if conditions).\n     }\n }\n \n fn test_complex_conditions() {\n     let x: Result<(), ()> = Ok(());\n     let y: Result<(), ()> = Ok(());\n     if x.is_ok() && y.is_err() {\n-        x.unwrap();\n-        y.unwrap_err();\n+        x.unwrap(); // unnecessary\n+        x.unwrap_err(); // will panic\n+        y.unwrap(); // will panic\n+        y.unwrap_err(); // unnecessary\n     } else {\n-        // not clear whether unwrappable:\n+        // not statically determinable whether any of the following will always succeed or always fail:\n+        x.unwrap();\n         x.unwrap_err();\n         y.unwrap();\n+        y.unwrap_err();\n     }\n \n     if x.is_ok() || y.is_ok() {\n-        // not clear whether unwrappable:\n+        // not statically determinable whether any of the following will always succeed or always fail:\n         x.unwrap();\n         y.unwrap();\n     } else {\n-        x.unwrap_err();\n-        y.unwrap_err();\n+        x.unwrap(); // will panic\n+        x.unwrap_err(); // unnecessary\n+        y.unwrap(); // will panic\n+        y.unwrap_err(); // unnecessary\n     }\n     let z: Result<(), ()> = Ok(());\n     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n-        x.unwrap();\n-        y.unwrap_err();\n-        z.unwrap();\n+        x.unwrap(); // unnecessary\n+        x.unwrap_err(); // will panic\n+        y.unwrap(); // will panic\n+        y.unwrap_err(); // unnecessary\n+        z.unwrap(); // unnecessary\n+        z.unwrap_err(); // will panic\n     }\n     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n-        // not clear what's unwrappable\n-    } else {\n-        x.unwrap_err();\n+        // not statically determinable whether any of the following will always succeed or always fail:\n+        x.unwrap();\n         y.unwrap();\n-        z.unwrap_err();\n+        z.unwrap();\n+    } else {\n+        x.unwrap(); // will panic\n+        x.unwrap_err(); // unnecessary\n+        y.unwrap(); // unnecessary\n+        y.unwrap_err(); // will panic\n+        z.unwrap(); // will panic\n+        z.unwrap_err(); // unnecessary\n     }\n }\n \n fn test_nested() {\n     fn nested() {\n         let x = Some(());\n         if x.is_some() {\n-            x.unwrap();\n+            x.unwrap(); // unnecessary\n+        } else {\n+            x.unwrap(); // will panic\n         }\n     }\n }"}, {"sha": "1b46ceb5fa8d145ad6533c51a3da1ad104c4518c", "filename": "tests/ui/checked_unwrap.stderr", "status": "modified", "additions": 214, "deletions": 56, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fchecked_unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fchecked_unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap.stderr?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -1,155 +1,313 @@\n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n- --> $DIR/checked_unwrap.rs:6:9\n+ --> $DIR/checked_unwrap.rs:7:9\n   |\n-5 |     if x.is_some() {\n+6 |     if x.is_some() {\n   |        ----------- the check is happening here\n-6 |         x.unwrap();\n+7 |         x.unwrap(); // unnecessary\n+  |         ^^^^^^^^^^\n+  |\n+note: lint level defined here\n+ --> $DIR/checked_unwrap.rs:1:27\n+  |\n+1 | #![deny(panicking_unwrap, unnecessary_unwrap)]\n+  |                           ^^^^^^^^^^^^^^^^^^\n+\n+error: This call to `unwrap()` will always panic.\n+ --> $DIR/checked_unwrap.rs:9:9\n+  |\n+6 |     if x.is_some() {\n+  |        ----------- because of this check\n+...\n+9 |         x.unwrap(); // will panic\n   |         ^^^^^^^^^^\n   |\n note: lint level defined here\n  --> $DIR/checked_unwrap.rs:1:9\n   |\n-1 | #![deny(unnecessary_unwrap)]\n-  |         ^^^^^^^^^^^^^^^^^^\n+1 | #![deny(panicking_unwrap, unnecessary_unwrap)]\n+  |         ^^^^^^^^^^^^^^^^\n+\n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:12:9\n+   |\n+11 |     if x.is_none() {\n+   |        ----------- because of this check\n+12 |         x.unwrap(); // will panic\n+   |         ^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:11:9\n+  --> $DIR/checked_unwrap.rs:14:9\n    |\n-8  |     if x.is_none() {\n+11 |     if x.is_none() {\n    |        ----------- the check is happening here\n ...\n-11 |         x.unwrap();\n+14 |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:15:9\n+  --> $DIR/checked_unwrap.rs:18:9\n    |\n-14 |     if x.is_ok() {\n+17 |     if x.is_ok() {\n    |        --------- the check is happening here\n-15 |         x.unwrap();\n+18 |         x.unwrap(); // unnecessary\n+   |         ^^^^^^^^^^\n+\n+error: This call to `unwrap_err()` will always panic.\n+  --> $DIR/checked_unwrap.rs:19:9\n+   |\n+17 |     if x.is_ok() {\n+   |        --------- because of this check\n+18 |         x.unwrap(); // unnecessary\n+19 |         x.unwrap_err(); // will panic\n+   |         ^^^^^^^^^^^^^^\n+\n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:21:9\n+   |\n+17 |     if x.is_ok() {\n+   |        --------- because of this check\n+...\n+21 |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:17:9\n+  --> $DIR/checked_unwrap.rs:22:9\n    |\n-14 |     if x.is_ok() {\n+17 |     if x.is_ok() {\n    |        --------- the check is happening here\n ...\n-17 |         x.unwrap_err();\n+22 |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:25:9\n+   |\n+24 |     if x.is_err() {\n+   |        ---------- because of this check\n+25 |         x.unwrap(); // will panic\n+   |         ^^^^^^^^^^\n+\n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:20:9\n+  --> $DIR/checked_unwrap.rs:26:9\n    |\n-19 |     if x.is_err() {\n+24 |     if x.is_err() {\n    |        ---------- the check is happening here\n-20 |         x.unwrap_err();\n+25 |         x.unwrap(); // will panic\n+26 |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:22:9\n+  --> $DIR/checked_unwrap.rs:28:9\n    |\n-19 |     if x.is_err() {\n+24 |     if x.is_err() {\n    |        ---------- the check is happening here\n ...\n-22 |         x.unwrap();\n+28 |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n+error: This call to `unwrap_err()` will always panic.\n+  --> $DIR/checked_unwrap.rs:29:9\n+   |\n+24 |     if x.is_err() {\n+   |        ---------- because of this check\n+...\n+29 |         x.unwrap_err(); // will panic\n+   |         ^^^^^^^^^^^^^^\n+\n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:37:9\n+  --> $DIR/checked_unwrap.rs:46:9\n    |\n-36 |     if x.is_ok() && y.is_err() {\n+45 |     if x.is_ok() && y.is_err() {\n    |        --------- the check is happening here\n-37 |         x.unwrap();\n+46 |         x.unwrap(); // unnecessary\n+   |         ^^^^^^^^^^\n+\n+error: This call to `unwrap_err()` will always panic.\n+  --> $DIR/checked_unwrap.rs:47:9\n+   |\n+45 |     if x.is_ok() && y.is_err() {\n+   |        --------- because of this check\n+46 |         x.unwrap(); // unnecessary\n+47 |         x.unwrap_err(); // will panic\n+   |         ^^^^^^^^^^^^^^\n+\n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:48:9\n+   |\n+45 |     if x.is_ok() && y.is_err() {\n+   |                     ---------- because of this check\n+...\n+48 |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:38:9\n+  --> $DIR/checked_unwrap.rs:49:9\n    |\n-36 |     if x.is_ok() && y.is_err() {\n+45 |     if x.is_ok() && y.is_err() {\n    |                     ---------- the check is happening here\n-37 |         x.unwrap();\n-38 |         y.unwrap_err();\n+...\n+49 |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:63:9\n+   |\n+58 |     if x.is_ok() || y.is_ok() {\n+   |        --------- because of this check\n+...\n+63 |         x.unwrap(); // will panic\n+   |         ^^^^^^^^^^\n+\n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:50:9\n+  --> $DIR/checked_unwrap.rs:64:9\n    |\n-45 |     if x.is_ok() || y.is_ok() {\n+58 |     if x.is_ok() || y.is_ok() {\n    |        --------- the check is happening here\n ...\n-50 |         x.unwrap_err();\n+64 |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:65:9\n+   |\n+58 |     if x.is_ok() || y.is_ok() {\n+   |                     --------- because of this check\n+...\n+65 |         y.unwrap(); // will panic\n+   |         ^^^^^^^^^^\n+\n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:51:9\n+  --> $DIR/checked_unwrap.rs:66:9\n    |\n-45 |     if x.is_ok() || y.is_ok() {\n+58 |     if x.is_ok() || y.is_ok() {\n    |                     --------- the check is happening here\n ...\n-51 |         y.unwrap_err();\n+66 |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:55:9\n+  --> $DIR/checked_unwrap.rs:70:9\n    |\n-54 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+69 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |        --------- the check is happening here\n-55 |         x.unwrap();\n+70 |         x.unwrap(); // unnecessary\n+   |         ^^^^^^^^^^\n+\n+error: This call to `unwrap_err()` will always panic.\n+  --> $DIR/checked_unwrap.rs:71:9\n+   |\n+69 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |        --------- because of this check\n+70 |         x.unwrap(); // unnecessary\n+71 |         x.unwrap_err(); // will panic\n+   |         ^^^^^^^^^^^^^^\n+\n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:72:9\n+   |\n+69 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |                       --------- because of this check\n+...\n+72 |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:56:9\n+  --> $DIR/checked_unwrap.rs:73:9\n    |\n-54 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+69 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |                       --------- the check is happening here\n-55 |         x.unwrap();\n-56 |         y.unwrap_err();\n+...\n+73 |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:57:9\n+  --> $DIR/checked_unwrap.rs:74:9\n    |\n-54 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+69 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |                                    ---------- the check is happening here\n ...\n-57 |         z.unwrap();\n+74 |         z.unwrap(); // unnecessary\n+   |         ^^^^^^^^^^\n+\n+error: This call to `unwrap_err()` will always panic.\n+  --> $DIR/checked_unwrap.rs:75:9\n+   |\n+69 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |                                    ---------- because of this check\n+...\n+75 |         z.unwrap_err(); // will panic\n+   |         ^^^^^^^^^^^^^^\n+\n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:83:9\n+   |\n+77 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |        --------- because of this check\n+...\n+83 |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:62:9\n+  --> $DIR/checked_unwrap.rs:84:9\n    |\n-59 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+77 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |        --------- the check is happening here\n ...\n-62 |         x.unwrap_err();\n+84 |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:63:9\n+  --> $DIR/checked_unwrap.rs:85:9\n    |\n-59 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+77 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |                       --------- the check is happening here\n ...\n-63 |         y.unwrap();\n+85 |         y.unwrap(); // unnecessary\n+   |         ^^^^^^^^^^\n+\n+error: This call to `unwrap_err()` will always panic.\n+  --> $DIR/checked_unwrap.rs:86:9\n+   |\n+77 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |                       --------- because of this check\n+...\n+86 |         y.unwrap_err(); // will panic\n+   |         ^^^^^^^^^^^^^^\n+\n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:87:9\n+   |\n+77 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |                                    ---------- because of this check\n+...\n+87 |         z.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:64:9\n+  --> $DIR/checked_unwrap.rs:88:9\n    |\n-59 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+77 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |                                    ---------- the check is happening here\n ...\n-64 |         z.unwrap_err();\n+88 |         z.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/checked_unwrap.rs:72:13\n+  --> $DIR/checked_unwrap.rs:96:13\n    |\n-71 |         if x.is_some() {\n+95 |         if x.is_some() {\n    |            ----------- the check is happening here\n-72 |             x.unwrap();\n+96 |             x.unwrap(); // unnecessary\n+   |             ^^^^^^^^^^\n+\n+error: This call to `unwrap()` will always panic.\n+  --> $DIR/checked_unwrap.rs:98:13\n+   |\n+95 |         if x.is_some() {\n+   |            ----------- because of this check\n+...\n+98 |             x.unwrap(); // will panic\n    |             ^^^^^^^^^^\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 34 previous errors\n "}, {"sha": "675e64246fa909b43339da9424780205812b5400", "filename": "tests/ui/default_trait_access.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -0,0 +1,100 @@\n+#![warn(default_trait_access)]\n+\n+use std::default::Default as D2;\n+use std::string;\n+use std::default;\n+\n+fn main() {\n+    let s1: String = Default::default();\n+\n+    let s2 = String::default();\n+\n+    let s3: String = D2::default();\n+\n+    let s4: String = std::default::Default::default();\n+\n+    let s5 = string::String::default();\n+\n+    let s6: String = default::Default::default();\n+\n+    let s7 = std::string::String::default();\n+\n+    let s8: String = DefaultFactory::make_t_badly();\n+\n+    let s9: String = DefaultFactory::make_t_nicely();\n+\n+    let s10 = DerivedDefault::default();\n+\n+    let s11: GenericDerivedDefault<String> = Default::default();\n+\n+    let s12 = GenericDerivedDefault::<String>::default();\n+\n+    let s13 = TupleDerivedDefault::default();\n+\n+    let s14: TupleDerivedDefault = Default::default();\n+\n+    let s15: ArrayDerivedDefault = Default::default();\n+\n+    let s16 = ArrayDerivedDefault::default();\n+\n+    let s17: TupleStructDerivedDefault = Default::default();\n+\n+    let s18 = TupleStructDerivedDefault::default();\n+\n+    println!(\n+        \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}]\",\n+        s1,\n+        s2,\n+        s3,\n+        s4,\n+        s5,\n+        s6,\n+        s7,\n+        s8,\n+        s9,\n+        s10,\n+        s11,\n+        s12,\n+        s13,\n+        s14,\n+        s15,\n+        s16,\n+        s17,\n+        s18,\n+    );\n+}\n+\n+struct DefaultFactory;\n+\n+impl DefaultFactory {\n+    pub fn make_t_badly<T: Default>() -> T {\n+        Default::default()\n+    }\n+\n+    pub fn make_t_nicely<T: Default>() -> T {\n+        T::default()\n+    }\n+}\n+\n+#[derive(Debug, Default)]\n+struct DerivedDefault {\n+    pub s: String,\n+}\n+\n+#[derive(Debug, Default)]\n+struct GenericDerivedDefault<T: Default + std::fmt::Debug> {\n+    pub s: T,\n+}\n+\n+#[derive(Debug, Default)]\n+struct TupleDerivedDefault {\n+    pub s: (String, String),\n+}\n+\n+#[derive(Debug, Default)]\n+struct ArrayDerivedDefault {\n+    pub s: [String; 10],\n+}\n+\n+#[derive(Debug, Default)]\n+struct TupleStructDerivedDefault(String);"}, {"sha": "8bb4731035aecd5496af36bbd5af1ce0d276c88f", "filename": "tests/ui/default_trait_access.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fdefault_trait_access.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fdefault_trait_access.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.stderr?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -0,0 +1,52 @@\n+error: Calling std::string::String::default() is more clear than this expression\n+ --> $DIR/default_trait_access.rs:8:22\n+  |\n+8 |     let s1: String = Default::default();\n+  |                      ^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n+  |\n+  = note: `-D default-trait-access` implied by `-D warnings`\n+\n+error: Calling std::string::String::default() is more clear than this expression\n+  --> $DIR/default_trait_access.rs:12:22\n+   |\n+12 |     let s3: String = D2::default();\n+   |                      ^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n+\n+error: Calling std::string::String::default() is more clear than this expression\n+  --> $DIR/default_trait_access.rs:14:22\n+   |\n+14 |     let s4: String = std::default::Default::default();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n+\n+error: Calling std::string::String::default() is more clear than this expression\n+  --> $DIR/default_trait_access.rs:18:22\n+   |\n+18 |     let s6: String = default::Default::default();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n+\n+error: Calling GenericDerivedDefault<std::string::String>::default() is more clear than this expression\n+  --> $DIR/default_trait_access.rs:28:46\n+   |\n+28 |     let s11: GenericDerivedDefault<String> = Default::default();\n+   |                                              ^^^^^^^^^^^^^^^^^^ help: try: `GenericDerivedDefault<std::string::String>::default()`\n+\n+error: Calling TupleDerivedDefault::default() is more clear than this expression\n+  --> $DIR/default_trait_access.rs:34:36\n+   |\n+34 |     let s14: TupleDerivedDefault = Default::default();\n+   |                                    ^^^^^^^^^^^^^^^^^^ help: try: `TupleDerivedDefault::default()`\n+\n+error: Calling ArrayDerivedDefault::default() is more clear than this expression\n+  --> $DIR/default_trait_access.rs:36:36\n+   |\n+36 |     let s15: ArrayDerivedDefault = Default::default();\n+   |                                    ^^^^^^^^^^^^^^^^^^ help: try: `ArrayDerivedDefault::default()`\n+\n+error: Calling TupleStructDerivedDefault::default() is more clear than this expression\n+  --> $DIR/default_trait_access.rs:40:42\n+   |\n+40 |     let s17: TupleStructDerivedDefault = Default::default();\n+   |                                          ^^^^^^^^^^^^^^^^^^ help: try: `TupleStructDerivedDefault::default()`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/default_trait_access.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fdefault_trait_access.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fdefault_trait_access.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.stdout?ref=4827bdcc1c234ef612c59d1720f7a6f268390999"}, {"sha": "49df39ca71bcbec5917ebfc39c9b378ee94355c2", "filename": "tests/ui/implicit_hasher.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_hasher.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -30,12 +30,12 @@ impl Foo<i16> for HashMap<String, String> {\n \n impl<K: Hash + Eq, V, S: BuildHasher + Default> Foo<i32> for HashMap<K, V, S> {\n     fn make() -> (Self, Self) {\n-        (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+        (HashMap::default(), HashMap::with_capacity_and_hasher(10, S::default()))\n     }\n }\n impl<S: BuildHasher + Default> Foo<i64> for HashMap<String, String, S> {\n     fn make() -> (Self, Self) {\n-        (HashMap::default(), HashMap::with_capacity_and_hasher(10, Default::default()))\n+        (HashMap::default(), HashMap::with_capacity_and_hasher(10, S::default()))\n     }\n }\n \n@@ -53,12 +53,12 @@ impl Foo<i16> for HashSet<String> {\n \n impl<T: Hash + Eq, S: BuildHasher + Default> Foo<i32> for HashSet<T, S> {\n     fn make() -> (Self, Self) {\n-        (HashSet::default(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+        (HashSet::default(), HashSet::with_capacity_and_hasher(10, S::default()))\n     }\n }\n impl<S: BuildHasher + Default> Foo<i64> for HashSet<String, S> {\n     fn make() -> (Self, Self) {\n-        (HashSet::default(), HashSet::with_capacity_and_hasher(10, Default::default()))\n+        (HashSet::default(), HashSet::with_capacity_and_hasher(10, S::default()))\n     }\n }\n "}, {"sha": "e39dc92367c8ecc5c9ddfa3e9a518da13f237e20", "filename": "tests/ui/indexing_slicing.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -0,0 +1,82 @@\n+#![feature(plugin)]\n+#![warn(indexing_slicing)]\n+#![warn(out_of_bounds_indexing)]\n+#![allow(no_effect, unnecessary_operation)]\n+\n+fn main() {\n+    let x = [1, 2, 3, 4];\n+    let index: usize = 1;\n+    let index_from: usize = 2;\n+    let index_to: usize = 3;\n+    x[index];\n+    &x[index..];\n+    &x[..index];\n+    &x[index_from..index_to];\n+    &x[index_from..][..index_to]; // Two lint reports, one for [index_from..] and another for [..index_to].\n+    x[4]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+    x[1 << 3]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+    &x[..=4];\n+    &x[1..5];\n+    &x[5..][..10]; // Two lint reports, one for [5..] and another for [..10].\n+    &x[5..];\n+    &x[..5];\n+    &x[5..].iter().map(|x| 2 * x).collect::<Vec<i32>>();\n+    &x[0..=4];\n+    &x[0..][..3];\n+    &x[1..][..5];\n+\n+    &x[4..]; // Ok, should not produce stderr.\n+    &x[..4]; // Ok, should not produce stderr.\n+    &x[..]; // Ok, should not produce stderr.\n+    &x[1..]; // Ok, should not produce stderr.\n+    &x[2..].iter().map(|x| 2 * x).collect::<Vec<i32>>(); // Ok, should not produce stderr.\n+    &x[0..].get(..3); // Ok, should not produce stderr.\n+    x[0]; // Ok, should not produce stderr.\n+    x[3]; // Ok, should not produce stderr.\n+    &x[0..3]; // Ok, should not produce stderr.\n+\n+    let y = &x;\n+    y[0];\n+    &y[1..2];\n+    &y[0..=4];\n+    &y[..=4];\n+\n+    &y[..]; // Ok, should not produce stderr.\n+\n+    let empty: [i8; 0] = [];\n+    empty[0]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+    &empty[1..5];\n+    &empty[0..=4];\n+    &empty[..=4];\n+    &empty[1..];\n+    &empty[..4];\n+    &empty[0..=0];\n+    &empty[..=0];\n+\n+    &empty[0..]; // Ok, should not produce stderr.\n+    &empty[0..0]; // Ok, should not produce stderr.\n+    &empty[..0]; // Ok, should not produce stderr.\n+    &empty[..]; // Ok, should not produce stderr.\n+\n+    let v = vec![0; 5];\n+    v[0];\n+    v[10];\n+    v[1 << 3];\n+    &v[10..100];\n+    &x[10..][..100]; // Two lint reports, one for [10..] and another for [..100].\n+    &v[10..];\n+    &v[..100];\n+\n+    &v[..]; // Ok, should not produce stderr.\n+\n+    //\n+    // Continue tests at end function to minimize the changes to this file's corresponding stderr.\n+    //\n+\n+    const N: usize = 15; // Out of bounds\n+    const M: usize = 3; // In bounds\n+    x[N]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+    x[M]; // Ok, should not produce stderr.\n+    v[N];\n+    v[M];\n+}"}, {"sha": "ee11dce6d1c2c164e917e9d10df577be72245d31", "filename": "tests/ui/indexing_slicing.stderr", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Findexing_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Findexing_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing.stderr?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -0,0 +1,271 @@\n+error: indexing may panic.\n+  --> $DIR/indexing_slicing.rs:11:5\n+   |\n+11 |     x[index];\n+   |     ^^^^^^^^\n+   |\n+   = note: `-D indexing-slicing` implied by `-D warnings`\n+   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:12:6\n+   |\n+12 |     &x[index..];\n+   |      ^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(n..)` or .get_mut(n..)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:13:6\n+   |\n+13 |     &x[..index];\n+   |      ^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:14:6\n+   |\n+14 |     &x[index_from..index_to];\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:15:6\n+   |\n+15 |     &x[index_from..][..index_to]; // Two lint reports, one for [index_from..] and another for [..index_to].\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:15:6\n+   |\n+15 |     &x[index_from..][..index_to]; // Two lint reports, one for [index_from..] and another for [..index_to].\n+   |      ^^^^^^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(n..)` or .get_mut(n..)` instead\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:18:6\n+   |\n+18 |     &x[..=4];\n+   |      ^^^^^^^\n+   |\n+   = note: `-D out-of-bounds-indexing` implied by `-D warnings`\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:19:6\n+   |\n+19 |     &x[1..5];\n+   |      ^^^^^^^\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:20:6\n+   |\n+20 |     &x[5..][..10]; // Two lint reports, one for [5..] and another for [..10].\n+   |      ^^^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:20:6\n+   |\n+20 |     &x[5..][..10]; // Two lint reports, one for [5..] and another for [..10].\n+   |      ^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:21:6\n+   |\n+21 |     &x[5..];\n+   |      ^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:22:6\n+   |\n+22 |     &x[..5];\n+   |      ^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:23:6\n+   |\n+23 |     &x[5..].iter().map(|x| 2 * x).collect::<Vec<i32>>();\n+   |      ^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:24:6\n+   |\n+24 |     &x[0..=4];\n+   |      ^^^^^^^^\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:25:6\n+   |\n+25 |     &x[0..][..3];\n+   |      ^^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:26:6\n+   |\n+26 |     &x[1..][..5];\n+   |      ^^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+\n+error: indexing may panic.\n+  --> $DIR/indexing_slicing.rs:39:5\n+   |\n+39 |     y[0];\n+   |     ^^^^\n+   |\n+   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:40:6\n+   |\n+40 |     &y[1..2];\n+   |      ^^^^^^^\n+   |\n+   = help: Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:41:6\n+   |\n+41 |     &y[0..=4];\n+   |      ^^^^^^^^\n+   |\n+   = help: Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:42:6\n+   |\n+42 |     &y[..=4];\n+   |      ^^^^^^^\n+   |\n+   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:48:6\n+   |\n+48 |     &empty[1..5];\n+   |      ^^^^^^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:49:6\n+   |\n+49 |     &empty[0..=4];\n+   |      ^^^^^^^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:50:6\n+   |\n+50 |     &empty[..=4];\n+   |      ^^^^^^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:51:6\n+   |\n+51 |     &empty[1..];\n+   |      ^^^^^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:52:6\n+   |\n+52 |     &empty[..4];\n+   |      ^^^^^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:53:6\n+   |\n+53 |     &empty[0..=0];\n+   |      ^^^^^^^^^^^^\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:54:6\n+   |\n+54 |     &empty[..=0];\n+   |      ^^^^^^^^^^^\n+\n+error: indexing may panic.\n+  --> $DIR/indexing_slicing.rs:62:5\n+   |\n+62 |     v[0];\n+   |     ^^^^\n+   |\n+   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+\n+error: indexing may panic.\n+  --> $DIR/indexing_slicing.rs:63:5\n+   |\n+63 |     v[10];\n+   |     ^^^^^\n+   |\n+   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+\n+error: indexing may panic.\n+  --> $DIR/indexing_slicing.rs:64:5\n+   |\n+64 |     v[1 << 3];\n+   |     ^^^^^^^^^\n+   |\n+   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:65:6\n+   |\n+65 |     &v[10..100];\n+   |      ^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:66:6\n+   |\n+66 |     &x[10..][..100]; // Two lint reports, one for [10..] and another for [..100].\n+   |      ^^^^^^^^^^^^^^\n+   |\n+   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+\n+error: range is out of bounds\n+  --> $DIR/indexing_slicing.rs:66:6\n+   |\n+66 |     &x[10..][..100]; // Two lint reports, one for [10..] and another for [..100].\n+   |      ^^^^^^^\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:67:6\n+   |\n+67 |     &v[10..];\n+   |      ^^^^^^^\n+   |\n+   = help: Consider using `.get(n..)` or .get_mut(n..)` instead\n+\n+error: slicing may panic.\n+  --> $DIR/indexing_slicing.rs:68:6\n+   |\n+68 |     &v[..100];\n+   |      ^^^^^^^^\n+   |\n+   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+\n+error: indexing may panic.\n+  --> $DIR/indexing_slicing.rs:80:5\n+   |\n+80 |     v[N];\n+   |     ^^^^\n+   |\n+   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+\n+error: indexing may panic.\n+  --> $DIR/indexing_slicing.rs:81:5\n+   |\n+81 |     v[M];\n+   |     ^^^^\n+   |\n+   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+\n+error: aborting due to 37 previous errors\n+"}, {"sha": "0322d42e81febffaf34b866720f8ba007591c7b9", "filename": "tests/ui/lifetimes.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -53,6 +53,22 @@ fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n     where for<'x> F: Fn(Lt<'x, I>) -> Lt<'x, I>\n { unreachable!() }\n \n+fn fn_bound_3<'a, F: FnOnce(&'a i32)>(x: &'a i32, f: F) { // no error, see below\n+    f(x);\n+}\n+\n+fn fn_bound_3_cannot_elide() {\n+    let x = 42;\n+    let p = &x;\n+    let mut q = &x;\n+    fn_bound_3(p, |y| q = y); // this will fail if we elides lifetimes of `fn_bound_3`\n+}\n+\n+// no error, multiple input refs\n+fn fn_bound_4<'a, F: FnOnce() -> &'a ()>(cond: bool, x: &'a (), f: F) -> &'a () {\n+    if cond { x } else { f() }\n+}\n+\n struct X {\n     x: u8,\n }"}, {"sha": "b69438af9f8207c9faf151d5eb1c70bafa74b222", "filename": "tests/ui/lifetimes.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Flifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Flifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes.stderr?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -45,45 +45,45 @@ error: explicit lifetimes given in parameter types where they could be elided\n    | |__________________^\n \n error: explicit lifetimes given in parameter types where they could be elided\n-  --> $DIR/lifetimes.rs:61:5\n+  --> $DIR/lifetimes.rs:77:5\n    |\n-61 |     fn self_and_out<'s>(&'s self) -> &'s u8 { &self.x }\n+77 |     fn self_and_out<'s>(&'s self) -> &'s u8 { &self.x }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided\n-  --> $DIR/lifetimes.rs:65:5\n+  --> $DIR/lifetimes.rs:81:5\n    |\n-65 |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) { }\n+81 |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) { }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided\n-  --> $DIR/lifetimes.rs:81:1\n+  --> $DIR/lifetimes.rs:97:1\n    |\n-81 | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str { unimplemented!() }\n+97 | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str { unimplemented!() }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided\n-   --> $DIR/lifetimes.rs:101:1\n+   --> $DIR/lifetimes.rs:117:1\n     |\n-101 | fn trait_obj_elided2<'a>(_arg: &'a Drop) -> &'a str { unimplemented!() }\n+117 | fn trait_obj_elided2<'a>(_arg: &'a Drop) -> &'a str { unimplemented!() }\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided\n-   --> $DIR/lifetimes.rs:105:1\n+   --> $DIR/lifetimes.rs:121:1\n     |\n-105 | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str { unimplemented!() }\n+121 | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str { unimplemented!() }\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided\n-   --> $DIR/lifetimes.rs:116:1\n+   --> $DIR/lifetimes.rs:132:1\n     |\n-116 | fn named_input_elided_output<'a>(_arg: &'a str) -> &str { unimplemented!() }\n+132 | fn named_input_elided_output<'a>(_arg: &'a str) -> &str { unimplemented!() }\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided\n-   --> $DIR/lifetimes.rs:120:1\n+   --> $DIR/lifetimes.rs:136:1\n     |\n-120 | fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) { unimplemented!() }\n+136 | fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) { unimplemented!() }\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 14 previous errors"}, {"sha": "b42cc1f75b7242a0447f768d4991774c23f5dfde", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -3,7 +3,8 @@\n \n #![warn(clippy, clippy_pedantic, option_unwrap_used)]\n #![allow(blacklisted_name, unused, print_stdout, non_ascii_literal, new_without_default,\n-    new_without_default_derive, missing_docs_in_private_items, needless_pass_by_value)]\n+    new_without_default_derive, missing_docs_in_private_items, needless_pass_by_value,\n+    default_trait_access)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;"}, {"sha": "01ec0895fb00e7503edfdabd923b554b76a4efcb", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 187, "deletions": 187, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -1,528 +1,528 @@\n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:20:29\n+  --> $DIR/methods.rs:21:29\n    |\n-20 |     pub fn add(self, other: T) -> T { self }\n+21 |     pub fn add(self, other: T) -> T { self }\n    |                             ^ help: use the applicable keyword: `Self`\n    |\n    = note: `-D use-self` implied by `-D warnings`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:20:35\n+  --> $DIR/methods.rs:21:35\n    |\n-20 |     pub fn add(self, other: T) -> T { self }\n+21 |     pub fn add(self, other: T) -> T { self }\n    |                                   ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:24:25\n+  --> $DIR/methods.rs:25:25\n    |\n-24 |     fn eq(&self, other: T) -> bool { true } // no error, private function\n+25 |     fn eq(&self, other: T) -> bool { true } // no error, private function\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:26:26\n+  --> $DIR/methods.rs:27:26\n    |\n-26 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n+27 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n    |                          ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:26:33\n+  --> $DIR/methods.rs:27:33\n    |\n-26 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n+27 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n    |                                 ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:27:21\n+  --> $DIR/methods.rs:28:21\n    |\n-27 |     fn div(self) -> T { self } // no error, different #arguments\n+28 |     fn div(self) -> T { self } // no error, different #arguments\n    |                     ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:28:25\n+  --> $DIR/methods.rs:29:25\n    |\n-28 |     fn rem(self, other: T) { } // no error, wrong return type\n+29 |     fn rem(self, other: T) { } // no error, wrong return type\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:20:5\n+  --> $DIR/methods.rs:21:5\n    |\n-20 |     pub fn add(self, other: T) -> T { self }\n+21 |     pub fn add(self, other: T) -> T { self }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D should-implement-trait` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:31:17\n+  --> $DIR/methods.rs:32:17\n    |\n-31 |     fn into_u16(&self) -> u16 { 0 }\n+32 |     fn into_u16(&self) -> u16 { 0 }\n    |                 ^^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:33:21\n+  --> $DIR/methods.rs:34:21\n    |\n-33 |     fn to_something(self) -> u32 { 0 }\n+34 |     fn to_something(self) -> u32 { 0 }\n    |                     ^^^^\n \n error: methods called `new` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:35:12\n+  --> $DIR/methods.rs:36:12\n    |\n-35 |     fn new(self) {}\n+36 |     fn new(self) {}\n    |            ^^^^\n \n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:35:5\n+  --> $DIR/methods.rs:36:5\n    |\n-35 |     fn new(self) {}\n+36 |     fn new(self) {}\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `-D new-ret-no-self` implied by `-D warnings`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:79:24\n+  --> $DIR/methods.rs:80:24\n    |\n-79 |     fn new() -> Option<V<T>> { None }\n+80 |     fn new() -> Option<V<T>> { None }\n    |                        ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:83:19\n+  --> $DIR/methods.rs:84:19\n    |\n-83 |     type Output = T;\n+84 |     type Output = T;\n    |                   ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:84:25\n+  --> $DIR/methods.rs:85:25\n    |\n-84 |     fn mul(self, other: T) -> T { self } // no error, obviously\n+85 |     fn mul(self, other: T) -> T { self } // no error, obviously\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:84:31\n+  --> $DIR/methods.rs:85:31\n    |\n-84 |     fn mul(self, other: T) -> T { self } // no error, obviously\n+85 |     fn mul(self, other: T) -> T { self } // no error, obviously\n    |                               ^ help: use the applicable keyword: `Self`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-   --> $DIR/methods.rs:103:13\n+   --> $DIR/methods.rs:104:13\n     |\n-103 |       let _ = opt.map(|x| x + 1)\n+104 |       let _ = opt.map(|x| x + 1)\n     |  _____________^\n-104 | |\n-105 | |                .unwrap_or(0); // should lint even though this call is on a separate line\n+105 | |\n+106 | |                .unwrap_or(0); // should lint even though this call is on a separate line\n     | |____________________________^\n     |\n     = note: `-D option-map-unwrap-or` implied by `-D warnings`\n     = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-   --> $DIR/methods.rs:107:13\n+   --> $DIR/methods.rs:108:13\n     |\n-107 |       let _ = opt.map(|x| {\n+108 |       let _ = opt.map(|x| {\n     |  _____________^\n-108 | |                         x + 1\n-109 | |                     }\n-110 | |               ).unwrap_or(0);\n+109 | |                         x + 1\n+110 | |                     }\n+111 | |               ).unwrap_or(0);\n     | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-   --> $DIR/methods.rs:111:13\n+   --> $DIR/methods.rs:112:13\n     |\n-111 |       let _ = opt.map(|x| x + 1)\n+112 |       let _ = opt.map(|x| x + 1)\n     |  _____________^\n-112 | |                .unwrap_or({\n-113 | |                     0\n-114 | |                 });\n+113 | |                .unwrap_or({\n+114 | |                     0\n+115 | |                 });\n     | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:116:13\n+   --> $DIR/methods.rs:117:13\n     |\n-116 |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n+117 |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:118:13\n+   --> $DIR/methods.rs:119:13\n     |\n-118 |       let _ = opt.map(|x| {\n+119 |       let _ = opt.map(|x| {\n     |  _____________^\n-119 | |         Some(x + 1)\n-120 | |     }\n-121 | |     ).unwrap_or(None);\n+120 | |         Some(x + 1)\n+121 | |     }\n+122 | |     ).unwrap_or(None);\n     | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:122:13\n+   --> $DIR/methods.rs:123:13\n     |\n-122 |       let _ = opt\n+123 |       let _ = opt\n     |  _____________^\n-123 | |         .map(|x| Some(x + 1))\n-124 | |         .unwrap_or(None);\n+124 | |         .map(|x| Some(x + 1))\n+125 | |         .unwrap_or(None);\n     | |________________________^\n     |\n     = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:130:13\n+   --> $DIR/methods.rs:131:13\n     |\n-130 |       let _ = opt.map(|x| x + 1)\n+131 |       let _ = opt.map(|x| x + 1)\n     |  _____________^\n-131 | |\n-132 | |                .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n+132 | |\n+133 | |                .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n     | |____________________________________^\n     |\n     = note: `-D option-map-unwrap-or-else` implied by `-D warnings`\n     = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:134:13\n+   --> $DIR/methods.rs:135:13\n     |\n-134 |       let _ = opt.map(|x| {\n+135 |       let _ = opt.map(|x| {\n     |  _____________^\n-135 | |                         x + 1\n-136 | |                     }\n-137 | |               ).unwrap_or_else(|| 0);\n+136 | |                         x + 1\n+137 | |                     }\n+138 | |               ).unwrap_or_else(|| 0);\n     | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:138:13\n+   --> $DIR/methods.rs:139:13\n     |\n-138 |       let _ = opt.map(|x| x + 1)\n+139 |       let _ = opt.map(|x| x + 1)\n     |  _____________^\n-139 | |                .unwrap_or_else(||\n-140 | |                     0\n-141 | |                 );\n+140 | |                .unwrap_or_else(||\n+141 | |                     0\n+142 | |                 );\n     | |_________________^\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:147:13\n+   --> $DIR/methods.rs:148:13\n     |\n-147 |     let _ = opt.map_or(None, |x| Some(x + 1));\n+148 |     let _ = opt.map_or(None, |x| Some(x + 1));\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using and_then instead: `opt.and_then(|x| Some(x + 1))`\n     |\n     = note: `-D option-map-or-none` implied by `-D warnings`\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:149:13\n+   --> $DIR/methods.rs:150:13\n     |\n-149 |       let _ = opt.map_or(None, |x| {\n+150 |       let _ = opt.map_or(None, |x| {\n     |  _____________^\n-150 | |                         Some(x + 1)\n-151 | |                        }\n-152 | |                 );\n+151 | |                         Some(x + 1)\n+152 | |                        }\n+153 | |                 );\n     | |_________________^\n help: try using and_then instead\n     |\n-149 |     let _ = opt.and_then(|x| {\n-150 |                         Some(x + 1)\n-151 |                        });\n+150 |     let _ = opt.and_then(|x| {\n+151 |                         Some(x + 1)\n+152 |                        });\n     |\n \n error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:162:13\n+   --> $DIR/methods.rs:163:13\n     |\n-162 |       let _ = res.map(|x| x + 1)\n+163 |       let _ = res.map(|x| x + 1)\n     |  _____________^\n-163 | |\n-164 | |                .unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n+164 | |\n+165 | |                .unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n     | |_____________________________________^\n     |\n     = note: `-D result-map-unwrap-or-else` implied by `-D warnings`\n     = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `ok().map_or_else(|e| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:166:13\n+   --> $DIR/methods.rs:167:13\n     |\n-166 |       let _ = res.map(|x| {\n+167 |       let _ = res.map(|x| {\n     |  _____________^\n-167 | |                         x + 1\n-168 | |                     }\n-169 | |               ).unwrap_or_else(|e| 0);\n+168 | |                         x + 1\n+169 | |                     }\n+170 | |               ).unwrap_or_else(|e| 0);\n     | |_____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:170:13\n+   --> $DIR/methods.rs:171:13\n     |\n-170 |       let _ = res.map(|x| x + 1)\n+171 |       let _ = res.map(|x| x + 1)\n     |  _____________^\n-171 | |                .unwrap_or_else(|e|\n-172 | |                     0\n-173 | |                 );\n+172 | |                .unwrap_or_else(|e|\n+173 | |                     0\n+174 | |                 );\n     | |_________________^\n \n error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:199:24\n+   --> $DIR/methods.rs:200:24\n     |\n-199 |     fn filter(self) -> IteratorFalsePositives {\n+200 |     fn filter(self) -> IteratorFalsePositives {\n     |                        ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:203:22\n+   --> $DIR/methods.rs:204:22\n     |\n-203 |     fn next(self) -> IteratorFalsePositives {\n+204 |     fn next(self) -> IteratorFalsePositives {\n     |                      ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:223:32\n+   --> $DIR/methods.rs:224:32\n     |\n-223 |     fn skip(self, _: usize) -> IteratorFalsePositives {\n+224 |     fn skip(self, _: usize) -> IteratorFalsePositives {\n     |                                ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-   --> $DIR/methods.rs:233:13\n+   --> $DIR/methods.rs:234:13\n     |\n-233 |     let _ = v.iter().filter(|&x| *x < 0).next();\n+234 |     let _ = v.iter().filter(|&x| *x < 0).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D filter-next` implied by `-D warnings`\n     = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-   --> $DIR/methods.rs:236:13\n+   --> $DIR/methods.rs:237:13\n     |\n-236 |       let _ = v.iter().filter(|&x| {\n+237 |       let _ = v.iter().filter(|&x| {\n     |  _____________^\n-237 | |                                 *x < 0\n-238 | |                             }\n-239 | |                    ).next();\n+238 | |                                 *x < 0\n+239 | |                             }\n+240 | |                    ).next();\n     | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:251:13\n+   --> $DIR/methods.rs:252:13\n     |\n-251 |     let _ = v.iter().find(|&x| *x < 0).is_some();\n+252 |     let _ = v.iter().find(|&x| *x < 0).is_some();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D search-is-some` implied by `-D warnings`\n     = note: replace `find(|&x| *x < 0).is_some()` with `any(|&x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:254:13\n+   --> $DIR/methods.rs:255:13\n     |\n-254 |       let _ = v.iter().find(|&x| {\n+255 |       let _ = v.iter().find(|&x| {\n     |  _____________^\n-255 | |                               *x < 0\n-256 | |                           }\n-257 | |                    ).is_some();\n+256 | |                               *x < 0\n+257 | |                           }\n+258 | |                    ).is_some();\n     | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:260:13\n+   --> $DIR/methods.rs:261:13\n     |\n-260 |     let _ = v.iter().position(|&x| x < 0).is_some();\n+261 |     let _ = v.iter().position(|&x| x < 0).is_some();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:263:13\n+   --> $DIR/methods.rs:264:13\n     |\n-263 |       let _ = v.iter().position(|&x| {\n+264 |       let _ = v.iter().position(|&x| {\n     |  _____________^\n-264 | |                                   x < 0\n-265 | |                               }\n-266 | |                    ).is_some();\n+265 | |                                   x < 0\n+266 | |                               }\n+267 | |                    ).is_some();\n     | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:269:13\n+   --> $DIR/methods.rs:270:13\n     |\n-269 |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n+270 |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:272:13\n+   --> $DIR/methods.rs:273:13\n     |\n-272 |       let _ = v.iter().rposition(|&x| {\n+273 |       let _ = v.iter().rposition(|&x| {\n     |  _____________^\n-273 | |                                    x < 0\n-274 | |                                }\n-275 | |                    ).is_some();\n+274 | |                                    x < 0\n+275 | |                                }\n+276 | |                    ).is_some();\n     | |______________________________^\n \n error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:289:21\n+   --> $DIR/methods.rs:290:21\n     |\n-289 |         fn new() -> Foo { Foo }\n+290 |         fn new() -> Foo { Foo }\n     |                     ^^^ help: use the applicable keyword: `Self`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:307:22\n+   --> $DIR/methods.rs:308:22\n     |\n-307 |     with_constructor.unwrap_or(make());\n+308 |     with_constructor.unwrap_or(make());\n     |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n     |\n     = note: `-D or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n-   --> $DIR/methods.rs:310:5\n+   --> $DIR/methods.rs:311:5\n     |\n-310 |     with_new.unwrap_or(Vec::new());\n+311 |     with_new.unwrap_or(Vec::new());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:313:21\n+   --> $DIR/methods.rs:314:21\n     |\n-313 |     with_const_args.unwrap_or(Vec::with_capacity(12));\n+314 |     with_const_args.unwrap_or(Vec::with_capacity(12));\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:316:14\n+   --> $DIR/methods.rs:317:14\n     |\n-316 |     with_err.unwrap_or(make());\n+317 |     with_err.unwrap_or(make());\n     |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:319:19\n+   --> $DIR/methods.rs:320:19\n     |\n-319 |     with_err_args.unwrap_or(Vec::with_capacity(12));\n+320 |     with_err_args.unwrap_or(Vec::with_capacity(12));\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-   --> $DIR/methods.rs:322:5\n+   --> $DIR/methods.rs:323:5\n     |\n-322 |     with_default_trait.unwrap_or(Default::default());\n+323 |     with_default_trait.unwrap_or(Default::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-   --> $DIR/methods.rs:325:5\n+   --> $DIR/methods.rs:326:5\n     |\n-325 |     with_default_type.unwrap_or(u64::default());\n+326 |     with_default_type.unwrap_or(u64::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:328:14\n+   --> $DIR/methods.rs:329:14\n     |\n-328 |     with_vec.unwrap_or(vec![]);\n+329 |     with_vec.unwrap_or(vec![]);\n     |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| < [ _ ] > :: into_vec ( box [ $ ( $ x ) , * ] ))`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:333:21\n+   --> $DIR/methods.rs:334:21\n     |\n-333 |     without_default.unwrap_or(Foo::new());\n+334 |     without_default.unwrap_or(Foo::new());\n     |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-   --> $DIR/methods.rs:336:19\n+   --> $DIR/methods.rs:337:19\n     |\n-336 |     map.entry(42).or_insert(String::new());\n+337 |     map.entry(42).or_insert(String::new());\n     |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-   --> $DIR/methods.rs:339:21\n+   --> $DIR/methods.rs:340:21\n     |\n-339 |     btree.entry(42).or_insert(String::new());\n+340 |     btree.entry(42).or_insert(String::new());\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:342:21\n+   --> $DIR/methods.rs:343:21\n     |\n-342 |     let _ = stringy.unwrap_or(\"\".to_owned());\n+343 |     let _ = stringy.unwrap_or(\"\".to_owned());\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: use of `expect` followed by a function call\n-   --> $DIR/methods.rs:365:26\n+   --> $DIR/methods.rs:366:26\n     |\n-365 |     with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+366 |     with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n     |\n     = note: `-D expect-fun-call` implied by `-D warnings`\n \n error: use of `expect` followed by a function call\n-   --> $DIR/methods.rs:368:26\n+   --> $DIR/methods.rs:369:26\n     |\n-368 |     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+369 |     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(format!(\"Error {}: fake error\", error_code).as_str()))`\n \n error: use of `expect` followed by a function call\n-   --> $DIR/methods.rs:378:25\n+   --> $DIR/methods.rs:379:25\n     |\n-378 |     with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+379 |     with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-   --> $DIR/methods.rs:381:25\n+   --> $DIR/methods.rs:382:25\n     |\n-381 |     with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+382 |     with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(format!(\"Error {}: fake error\", error_code).as_str()))`\n \n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:401:23\n+   --> $DIR/methods.rs:402:23\n     |\n-401 |         let bad_vec = some_vec.iter().nth(3);\n+402 |         let bad_vec = some_vec.iter().nth(3);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:402:26\n+   --> $DIR/methods.rs:403:26\n     |\n-402 |         let bad_slice = &some_vec[..].iter().nth(3);\n+403 |         let bad_slice = &some_vec[..].iter().nth(3);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:403:31\n+   --> $DIR/methods.rs:404:31\n     |\n-403 |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n+404 |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n     |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:404:29\n+   --> $DIR/methods.rs:405:29\n     |\n-404 |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n+405 |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:409:23\n+   --> $DIR/methods.rs:410:23\n     |\n-409 |         let bad_vec = some_vec.iter_mut().nth(3);\n+410 |         let bad_vec = some_vec.iter_mut().nth(3);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:412:26\n+   --> $DIR/methods.rs:413:26\n     |\n-412 |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n+413 |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:415:29\n+   --> $DIR/methods.rs:416:29\n     |\n-415 |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n+416 |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:427:13\n+   --> $DIR/methods.rs:428:13\n     |\n-427 |     let _ = some_vec.iter().skip(42).next();\n+428 |     let _ = some_vec.iter().skip(42).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D iter-skip-next` implied by `-D warnings`\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:428:13\n+   --> $DIR/methods.rs:429:13\n     |\n-428 |     let _ = some_vec.iter().cycle().skip(42).next();\n+429 |     let _ = some_vec.iter().cycle().skip(42).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:429:13\n+   --> $DIR/methods.rs:430:13\n     |\n-429 |     let _ = (1..10).skip(10).next();\n+430 |     let _ = (1..10).skip(10).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:430:14\n+   --> $DIR/methods.rs:431:14\n     |\n-430 |     let _ = &some_vec[..].iter().skip(3).next();\n+431 |     let _ = &some_vec[..].iter().skip(3).next();\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-   --> $DIR/methods.rs:439:13\n+   --> $DIR/methods.rs:440:13\n     |\n-439 |     let _ = opt.unwrap();\n+440 |     let _ = opt.unwrap();\n     |             ^^^^^^^^^^^^\n     |\n     = note: `-D option-unwrap-used` implied by `-D warnings`"}, {"sha": "483972bb41b3ba982128898f497b5db55725b3bc", "filename": "tests/ui/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4827bdcc1c234ef612c59d1720f7a6f268390999/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs?ref=4827bdcc1c234ef612c59d1720f7a6f268390999", "patch": "@@ -1,6 +1,6 @@\n-/// This test case utilizes `f64` an easy example for `PartialOrd` only types\n-/// but the lint itself actually validates any expression where the left\n-/// operand implements `PartialOrd` but not `Ord`.\n+//! This test case utilizes `f64` an easy example for `PartialOrd` only types\n+//! but the lint itself actually validates any expression where the left\n+//! operand implements `PartialOrd` but not `Ord`.\n \n use std::cmp::Ordering;\n \n@@ -54,5 +54,14 @@ fn main() {\n     let _ = a_value <= another_value;\n     let _ = a_value > another_value;\n     let _ = a_value >= another_value;\n-}\n \n+    // --- regression tests ---\n+\n+    // Issue 2856: False positive on assert!()\n+    //\n+    // The macro always negates the result of the given comparision in its\n+    // internal check which automatically triggered the lint. As it's an\n+    // external macro there was no chance to do anything about it which lead\n+    // to a whitelisting of all external macros.\n+    assert!(a_value < another_value);\n+}"}]}