{"sha": "f0f9095f1daa3814c9589f38b574e51d394d1bbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZjkwOTVmMWRhYTM4MTRjOTU4OWYzOGI1NzRlNTFkMzk0ZDFiYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-11T17:02:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-11T17:02:04Z"}, "message": "auto merge of #14250 : alexcrichton/rust/gc, r=brson\n\nThis commit removes `@T` from the compiler by moving the AST to using `Gc<T>`. This also starts treating `Gc<T>` as `@T` in the same way that `Box<T>` is the same as `~T` in the compiler.\r\n\r\nAfter this hits a snapshot, the `@T` syntax should be able to be removed completely.", "tree": {"sha": "924e24d821a8d773af3a5e596d1fc603639e5e17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/924e24d821a8d773af3a5e596d1fc603639e5e17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0f9095f1daa3814c9589f38b574e51d394d1bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f9095f1daa3814c9589f38b574e51d394d1bbc", "html_url": "https://github.com/rust-lang/rust/commit/f0f9095f1daa3814c9589f38b574e51d394d1bbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0f9095f1daa3814c9589f38b574e51d394d1bbc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c54ce27b392e9f16a3cc70fed415af8c274af148", "url": "https://api.github.com/repos/rust-lang/rust/commits/c54ce27b392e9f16a3cc70fed415af8c274af148", "html_url": "https://github.com/rust-lang/rust/commit/c54ce27b392e9f16a3cc70fed415af8c274af148"}, {"sha": "54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9", "html_url": "https://github.com/rust-lang/rust/commit/54c2a1e1ce7f32576f0692a1de3fe2763d13bac9"}], "stats": {"total": 5486, "additions": 2818, "deletions": 2668}, "files": [{"sha": "802f7cd40bfd401d2a52c99d41349315b42cd7ce", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -1710,14 +1710,14 @@ having ownership of the box. It allows the creation of cycles, and the individua\n not have a destructor.\n \n ~~~\n-use std::gc::Gc;\n+use std::gc::GC;\n \n // A fixed-size array allocated in a garbage-collected box\n-let x = Gc::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+let x = box(GC) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n let y = x; // does not perform a move, unlike with `Rc`\n let z = x;\n \n-assert!(*z.borrow() == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+assert!(*z == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n ~~~\n \n With shared ownership, mutability cannot be inherited so the boxes are always immutable. However,"}, {"sha": "db6af30bce74080e6bcd6d4c35b69f921c169d03", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -320,8 +320,8 @@ mod tests {\n     #[test]\n     fn gc_inside() {\n         // see issue #11532\n-        use std::gc::Gc;\n-        let a = Rc::new(RefCell::new(Gc::new(1)));\n+        use std::gc::GC;\n+        let a = Rc::new(RefCell::new(box(GC) 1));\n         assert!(a.try_borrow_mut().is_some());\n     }\n "}, {"sha": "b484b2c8128f13f7b903ace57837b8d3a55e3aef", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -248,13 +248,6 @@ impl<S: Writer, T: Hash<S>> Hash<S> for Box<T> {\n     }\n }\n \n-impl<S: Writer, T: Hash<S>> Hash<S> for @T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-\n impl<S: Writer, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "f7680e6f8479cdb11e42d8e199b713d233fecea3", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -39,12 +39,6 @@ pub trait Clone {\n     }\n }\n \n-impl<T> Clone for @T {\n-    /// Return a shallow copy of the managed box.\n-    #[inline]\n-    fn clone(&self) -> @T { *self }\n-}\n-\n impl<'a, T> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n@@ -116,6 +110,7 @@ extern_fn_clone!(A, B, C, D, E, F, G, H)\n mod test {\n     use prelude::*;\n     use realstd::owned::Box;\n+    use realstd::gc::{Gc, GC};\n \n     fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n         use realstd::clone::Clone;\n@@ -136,9 +131,9 @@ mod test {\n \n     #[test]\n     fn test_managed_clone() {\n-        let a = @5i;\n-        let b: @int = a.clone();\n-        assert_eq!(a, b);\n+        let a = box(GC) 5i;\n+        let b: Gc<int> = realclone(&a);\n+        assert!(a == b);\n     }\n \n     #[test]"}, {"sha": "d7a3edccfd822115c5f9ec55f8466061fb5ab285", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -326,29 +326,6 @@ mod impls {\n         fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }\n     }\n     impl<'a, T: Eq> Eq for &'a mut T {}\n-\n-    // @ pointers\n-    impl<T:PartialEq> PartialEq for @T {\n-        #[inline]\n-        fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n-        #[inline]\n-        fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n-    }\n-    impl<T:PartialOrd> PartialOrd for @T {\n-        #[inline]\n-        fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n-        #[inline]\n-        fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n-        #[inline]\n-        fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n-        #[inline]\n-        fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n-    }\n-    impl<T: Ord> Ord for @T {\n-        #[inline]\n-        fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }\n-    }\n-    impl<T: Eq> Eq for @T {}\n }\n \n #[cfg(test)]"}, {"sha": "0fcc02aae0d2b31619294a81749bda2b7e6be261", "filename": "src/libcore/default.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -43,7 +43,3 @@ default_impl!(i64, 0i64)\n \n default_impl!(f32, 0.0f32)\n default_impl!(f64, 0.0f64)\n-\n-impl<T: Default + 'static> Default for @T {\n-    fn default() -> @T { @Default::default() }\n-}"}, {"sha": "0e6a0d1c6f5770c24ea44aab36f716ca236f1198", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -628,9 +628,6 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n \n // Implementations of the core formatting traits\n \n-impl<T: Show> Show for @T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n-}\n impl<'a, T: Show> Show for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n }"}, {"sha": "56db4ee8059fab8596cda3a784f6e1489e8f6dae", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -79,7 +79,6 @@ pub trait Repr<T> {\n \n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n-impl<T> Repr<*Box<T>> for @T {}\n impl<T> Repr<*Vec<T>> for ~[T] {}\n \n #[cfg(test)]"}, {"sha": "d703ece307ffb7e412dfabe4773f2b2acc681cf5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -705,7 +705,7 @@ fn print_flowgraph<W:io::Writer>(analysis: CrateAnalysis,\n                                  block: ast::P<ast::Block>,\n                                  mut out: W) -> io::IoResult<()> {\n     let ty_cx = &analysis.ty_cx;\n-    let cfg = cfg::CFG::new(ty_cx, block);\n+    let cfg = cfg::CFG::new(ty_cx, &*block);\n     let lcfg = LabelledCFG { ast_map: &ty_cx.map,\n                              cfg: &cfg,\n                              name: format!(\"block{}\", block.id).to_string(), };"}, {"sha": "58ac53002ba3c9c3bdd685dbcf3d684a79025167", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -12,6 +12,8 @@ use syntax::fold::Folder;\n use syntax::{ast, fold, attr};\n use syntax::codemap;\n \n+use std::gc::Gc;\n+\n struct Context<'a> {\n     in_cfg: |attrs: &[ast::Attribute]|: 'a -> bool,\n }\n@@ -36,7 +38,7 @@ impl<'a> fold::Folder for Context<'a> {\n     fn fold_item_underscore(&mut self, item: &ast::Item_) -> ast::Item_ {\n         fold_item_underscore(self, item)\n     }\n-    fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n+    fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         fold_expr(self, expr)\n     }\n }\n@@ -60,8 +62,8 @@ fn filter_view_item<'r>(cx: &mut Context, view_item: &'r ast::ViewItem)\n }\n \n fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n-    let filtered_items: Vec<&@ast::Item> = m.items.iter()\n-            .filter(|&a| item_in_cfg(cx, *a))\n+    let filtered_items: Vec<&Gc<ast::Item>> = m.items.iter()\n+            .filter(|a| item_in_cfg(cx, &***a))\n             .collect();\n     let flattened_items = filtered_items.move_iter()\n             .flat_map(|&x| cx.fold_item(x).move_iter())\n@@ -76,9 +78,9 @@ fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n     }\n }\n \n-fn filter_foreign_item(cx: &mut Context, item: @ast::ForeignItem)\n-                       -> Option<@ast::ForeignItem> {\n-    if foreign_item_in_cfg(cx, item) {\n+fn filter_foreign_item(cx: &mut Context, item: Gc<ast::ForeignItem>)\n+                       -> Option<Gc<ast::ForeignItem>> {\n+    if foreign_item_in_cfg(cx, &*item) {\n         Some(item)\n     } else {\n         None\n@@ -103,7 +105,7 @@ fn fold_foreign_mod(cx: &mut Context, nm: &ast::ForeignMod) -> ast::ForeignMod {\n fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n     let item = match *item {\n         ast::ItemImpl(ref a, ref b, c, ref methods) => {\n-            let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n+            let methods = methods.iter().filter(|m| method_in_cfg(cx, &***m))\n                 .map(|x| *x).collect();\n             ast::ItemImpl((*a).clone(), (*b).clone(), c, methods)\n         }\n@@ -114,8 +116,8 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n                                  .collect();\n             ast::ItemTrait((*a).clone(), b, (*c).clone(), methods)\n         }\n-        ast::ItemStruct(def, ref generics) => {\n-            ast::ItemStruct(fold_struct(cx, def), generics.clone())\n+        ast::ItemStruct(ref def, ref generics) => {\n+            ast::ItemStruct(fold_struct(cx, &**def), generics.clone())\n         }\n         ast::ItemEnum(ref def, ref generics) => {\n             let mut variants = def.variants.iter().map(|c| c.clone()).\n@@ -125,11 +127,11 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n                 } else {\n                     Some(match v.node.kind {\n                                 ast::TupleVariantKind(..) => v,\n-                                ast::StructVariantKind(def) => {\n-                                    let def = fold_struct(cx, def);\n-                                    @codemap::Spanned {\n+                                ast::StructVariantKind(ref def) => {\n+                                    let def = fold_struct(cx, &**def);\n+                                    box(GC) codemap::Spanned {\n                                         node: ast::Variant_ {\n-                                            kind: ast::StructVariantKind(def),\n+                                            kind: ast::StructVariantKind(def.clone()),\n                                             ..v.node.clone()\n                                         },\n                                         ..*v\n@@ -148,24 +150,24 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n     fold::noop_fold_item_underscore(&item, cx)\n }\n \n-fn fold_struct(cx: &mut Context, def: &ast::StructDef) -> @ast::StructDef {\n+fn fold_struct(cx: &mut Context, def: &ast::StructDef) -> Gc<ast::StructDef> {\n     let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n         (cx.in_cfg)(m.node.attrs.as_slice())\n     });\n-    @ast::StructDef {\n+    box(GC) ast::StructDef {\n         fields: fields.collect(),\n         ctor_id: def.ctor_id,\n         super_struct: def.super_struct.clone(),\n         is_virtual: def.is_virtual,\n     }\n }\n \n-fn retain_stmt(cx: &mut Context, stmt: @ast::Stmt) -> bool {\n+fn retain_stmt(cx: &mut Context, stmt: Gc<ast::Stmt>) -> bool {\n     match stmt.node {\n       ast::StmtDecl(decl, _) => {\n         match decl.node {\n-          ast::DeclItem(item) => {\n-            item_in_cfg(cx, item)\n+          ast::DeclItem(ref item) => {\n+            item_in_cfg(cx, &**item)\n           }\n           _ => true\n         }\n@@ -175,10 +177,10 @@ fn retain_stmt(cx: &mut Context, stmt: @ast::Stmt) -> bool {\n }\n \n fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-    let resulting_stmts: Vec<&@ast::Stmt> =\n+    let resulting_stmts: Vec<&Gc<ast::Stmt>> =\n         b.stmts.iter().filter(|&a| retain_stmt(cx, *a)).collect();\n     let resulting_stmts = resulting_stmts.move_iter()\n-        .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())\n+        .flat_map(|stmt| cx.fold_stmt(&**stmt).move_iter())\n         .collect();\n     let filtered_view_items = b.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n@@ -193,14 +195,14 @@ fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n     })\n }\n \n-fn fold_expr(cx: &mut Context, expr: @ast::Expr) -> @ast::Expr {\n+fn fold_expr(cx: &mut Context, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n     let expr = match expr.node {\n         ast::ExprMatch(ref m, ref arms) => {\n             let arms = arms.iter()\n                 .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n                 .map(|a| a.clone())\n                 .collect();\n-            @ast::Expr {\n+            box(GC) ast::Expr {\n                 id: expr.id,\n                 span: expr.span.clone(),\n                 node: ast::ExprMatch(m.clone(), arms),\n@@ -236,7 +238,7 @@ fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitMethod) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: &[@ast::MetaItem], attrs: &[ast::Attribute]) -> bool {\n+fn in_cfg(cfg: &[Gc<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n     attr::test_cfg(cfg, attrs.iter().map(|x| *x))\n }\n "}, {"sha": "c5c87ee27027123337e347754f8ab8f16184d0e2", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -23,6 +23,7 @@ use syntax::parse::token;\n use syntax::util::small_vector::SmallVector;\n \n use std::mem;\n+use std::gc::Gc;\n \n pub static VERSION: &'static str = \"0.11.0-pre\";\n \n@@ -165,12 +166,12 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         krate\n     }\n \n-    fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n+    fn fold_item(&mut self, item: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n         if !no_prelude(item.attrs.as_slice()) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree\n-            fold::noop_fold_item(item, self)\n+            fold::noop_fold_item(&*item, self)\n         } else {\n             SmallVector::one(item)\n         }\n@@ -193,7 +194,8 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n                 }),\n         };\n \n-        let vp = @codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID));\n+        let vp = box(GC) codemap::dummy_spanned(ast::ViewPathGlob(prelude_path,\n+                                                                  ast::DUMMY_NODE_ID));\n         let vi2 = ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n             attrs: Vec::new(),"}, {"sha": "3a655a7e22c868122b777034bb4a573adf3cf465", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -18,8 +18,8 @@ use front::config;\n use front::std_inject::with_version;\n \n use std::cell::RefCell;\n+use std::gc::Gc;\n use std::slice;\n-use std::vec::Vec;\n use std::vec;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n@@ -86,7 +86,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         }\n     }\n \n-    fn fold_item(&mut self, i: @ast::Item) -> SmallVector<@ast::Item> {\n+    fn fold_item(&mut self, i: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n         self.cx.path.borrow_mut().push(i.ident);\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.borrow().as_slice()));\n@@ -115,7 +115,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             }\n         }\n \n-        let res = fold::noop_fold_item(i, self);\n+        let res = fold::noop_fold_item(&*i, self);\n         self.cx.path.borrow_mut().pop();\n         res\n     }\n@@ -124,8 +124,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n-        fn nomain(item: @ast::Item) -> @ast::Item {\n-            @ast::Item {\n+        fn nomain(item: Gc<ast::Item>) -> Gc<ast::Item> {\n+            box(GC) ast::Item {\n                 attrs: item.attrs.iter().filter_map(|attr| {\n                     if !attr.name().equiv(&(\"main\")) {\n                         Some(*attr)\n@@ -188,10 +188,10 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     })\n }\n \n-fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n+fn is_test_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs.as_slice(), \"test\");\n \n-    fn has_test_signature(i: @ast::Item) -> bool {\n+    fn has_test_signature(i: Gc<ast::Item>) -> bool {\n         match &i.node {\n           &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n             let no_output = match decl.output.node {\n@@ -217,10 +217,10 @@ fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n     return has_test_attr && has_test_signature(i);\n }\n \n-fn is_bench_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n+fn is_bench_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     let has_bench_attr = attr::contains_name(i.attrs.as_slice(), \"bench\");\n \n-    fn has_test_signature(i: @ast::Item) -> bool {\n+    fn has_test_signature(i: Gc<ast::Item>) -> bool {\n         match i.node {\n             ast::ItemFn(ref decl, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n@@ -247,7 +247,7 @@ fn is_bench_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n     return has_bench_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n+fn is_ignored(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         attr.check_name(\"ignore\") && match attr.meta_item_list() {\n@@ -259,7 +259,7 @@ fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n     })\n }\n \n-fn should_fail(i: @ast::Item) -> bool {\n+fn should_fail(i: Gc<ast::Item>) -> bool {\n     attr::contains_name(i.attrs.as_slice(), \"should_fail\")\n }\n \n@@ -293,7 +293,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let id_test = token::str_to_ident(\"test\");\n     let (vi, vis) = if cx.is_test_crate {\n         (ast::ViewItemUse(\n-            @nospan(ast::ViewPathSimple(id_test,\n+            box(GC) nospan(ast::ViewPathSimple(id_test,\n                                         path_node(vec!(id_test)),\n                                         ast::DUMMY_NODE_ID))),\n          ast::Public)\n@@ -311,7 +311,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     }\n }\n \n-fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n+fn mk_test_module(cx: &TestCtxt) -> Gc<ast::Item> {\n     // Link to test crate\n     let view_items = vec!(mk_std(cx));\n \n@@ -352,7 +352,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n \n     debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_str(&item));\n \n-    return @item;\n+    box(GC) item\n }\n \n fn nospan<T>(t: T) -> codemap::Spanned<T> {\n@@ -383,7 +383,7 @@ fn path_node_global(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn mk_tests(cx: &TestCtxt) -> @ast::Item {\n+fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n \n@@ -401,12 +401,12 @@ fn is_test_crate(krate: &ast::Crate) -> bool {\n     }\n }\n \n-fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n+fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.testfns.borrow().len());\n \n-    @ast::Expr {\n+    box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprVstore(@ast::Expr {\n+        node: ast::ExprVstore(box(GC) ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ExprVec(cx.testfns.borrow().iter().map(|test| {\n                 mk_test_desc_and_fn_rec(cx, test)\n@@ -417,7 +417,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n     }\n }\n \n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n     let span = test.span;\n     let path = test.path.clone();\n \n@@ -428,15 +428,15 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n                     ast_util::path_name_i(path.as_slice()).as_slice()),\n                     ast::CookedStr));\n \n-    let name_expr = @ast::Expr {\n+    let name_expr = box(GC) ast::Expr {\n           id: ast::DUMMY_NODE_ID,\n-          node: ast::ExprLit(@name_lit),\n+          node: ast::ExprLit(box(GC) name_lit),\n           span: span\n     };\n \n     let fn_path = path_node_global(path);\n \n-    let fn_expr = @ast::Expr {\n+    let fn_expr = box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(fn_path),\n         span: span,"}, {"sha": "ee5179e9cef4ac55923cee89d62c7c6fd6fd1250", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -177,7 +177,7 @@ pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: ast::DefId,\n-                      f: |Vec<ast::Attribute> |) {\n+                      f: |Vec<ast::Attribute>|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node, f)\n }"}, {"sha": "d088d0d953d0e577612e273e56935323802bb21e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -28,13 +28,13 @@ use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n-use std::u64;\n-use std::hash;\n+use std::gc::Gc;\n use std::hash::Hash;\n-use std::io;\n+use std::hash;\n use std::io::extensions::u64_from_be_bytes;\n-use std::option;\n+use std::io;\n use std::rc::Rc;\n+use std::u64;\n use serialize::ebml::reader;\n use serialize::ebml;\n use serialize::Decodable;\n@@ -1010,8 +1010,8 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     result\n }\n \n-fn get_meta_items(md: ebml::Doc) -> Vec<@ast::MetaItem> {\n-    let mut items: Vec<@ast::MetaItem> = Vec::new();\n+fn get_meta_items(md: ebml::Doc) -> Vec<Gc<ast::MetaItem>> {\n+    let mut items: Vec<Gc<ast::MetaItem>> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n@@ -1041,7 +1041,7 @@ fn get_meta_items(md: ebml::Doc) -> Vec<@ast::MetaItem> {\n fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n     let mut attrs: Vec<ast::Attribute> = Vec::new();\n     match reader::maybe_get_doc(md, tag_attributes) {\n-      option::Some(attrs_d) => {\n+      Some(attrs_d) => {\n         reader::tagged_docs(attrs_d, tag_attribute, |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n@@ -1061,7 +1061,7 @@ fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n             true\n         });\n       }\n-      option::None => ()\n+      None => ()\n     }\n     return attrs;\n }"}, {"sha": "f5672dce16c6c35c5a16707f67152a5abf511636", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -27,11 +27,12 @@ use middle;\n use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n-use std::mem;\n use std::cell::RefCell;\n-use std::hash;\n+use std::gc::Gc;\n use std::hash::Hash;\n+use std::hash;\n use std::io::MemWriter;\n+use std::mem;\n use std::str;\n use std::collections::HashMap;\n use syntax::abi;\n@@ -475,7 +476,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: @Item, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id(item: Gc<Item>, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n         ItemEnum(ref enum_def, _) => {\n@@ -746,7 +747,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           impl_path: PathElems,\n                           is_default_impl: bool,\n                           parent_id: NodeId,\n-                          ast_method_opt: Option<@Method>) {\n+                          ast_method_opt: Option<Gc<Method>>) {\n \n     debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            token::get_ident(m.ident));\n@@ -774,7 +775,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                 is_default_impl ||\n                 should_inline(ast_method.attrs.as_slice()) {\n             encode_inlined_item(ecx, ebml_w,\n-                                IIMethodRef(local_def(parent_id), false, ast_method));\n+                                IIMethodRef(local_def(parent_id), false,\n+                                            &*ast_method));\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n@@ -1212,7 +1214,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     }\n                     encode_method_sort(ebml_w, 'p');\n                     encode_inlined_item(ecx, ebml_w,\n-                                        IIMethodRef(def_id, true, m));\n+                                        IIMethodRef(def_id, true, &*m));\n                     encode_method_argument_names(ebml_w, &*m.decl);\n                 }\n             }\n@@ -1408,7 +1410,7 @@ fn write_i64(writer: &mut MemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: &mut Encoder, mi: @MetaItem) {\n+fn encode_meta_item(ebml_w: &mut Encoder, mi: Gc<MetaItem>) {\n     match mi.node {\n       MetaWord(ref name) => {\n         ebml_w.start_tag(tag_meta_item_word);"}, {"sha": "cc356a8bf077c7d88a17b8939ddaf12f8f27be0b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -40,7 +40,6 @@ use std::io::Seek;\n use std::io::MemWriter;\n use std::mem;\n use std::rc::Rc;\n-use std::string::String;\n \n use serialize::ebml::reader;\n use serialize::ebml;\n@@ -51,6 +50,7 @@ use writer = serialize::ebml::writer;\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n+#[cfg(test)] use std::gc::Gc;\n \n struct DecodeContext<'a> {\n     cdata: &'a cstore::crate_metadata,\n@@ -146,7 +146,7 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         match ii {\n           ast::IIItem(i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(i));\n+                   syntax::print::pprust::item_to_str(&*i));\n           }\n           _ => { }\n         }\n@@ -438,7 +438,7 @@ impl tr for def::Def {\n           def::DefUse(did) => def::DefUse(did.tr(xcx)),\n           def::DefUpvar(nid1, def, nid2, nid3) => {\n             def::DefUpvar(xcx.tr_id(nid1),\n-                           @(*def).tr(xcx),\n+                           box(GC) (*def).tr(xcx),\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n@@ -1395,17 +1395,17 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: &mut Encoder, item: @ast::Item) {\n+fn encode_item_ast(ebml_w: &mut Encoder, item: Gc<ast::Item>) {\n     ebml_w.start_tag(c::tag_tree as uint);\n     (*item).encode(ebml_w);\n     ebml_w.end_tag();\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: ebml::Doc) -> @ast::Item {\n+fn decode_item_ast(par_doc: ebml::Doc) -> Gc<ast::Item> {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder::new(chi_doc);\n-    @Decodable::decode(&mut d).unwrap()\n+    box(GC) Decodable::decode(&mut d).unwrap()\n }\n \n #[cfg(test)]\n@@ -1440,7 +1440,7 @@ fn mk_ctxt() -> parse::ParseSess {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: Option<@ast::Item>) {\n+fn roundtrip(in_item: Option<Gc<ast::Item>>) {\n     use std::io::MemWriter;\n \n     let in_item = in_item.unwrap();"}, {"sha": "ece8d973236a662754d27c61648091872781cc79", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -894,4 +894,3 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n     }\n }\n-"}, {"sha": "ac94b73564060dc46bf43f05b50335d23412f20d", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -486,8 +486,8 @@ struct StaticInitializerCtxt<'a> {\n impl<'a> visit::Visitor<()> for StaticInitializerCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         match ex.node {\n-            ast::ExprAddrOf(mutbl, base) => {\n-                let base_cmt = self.bccx.cat_expr(base);\n+            ast::ExprAddrOf(mutbl, ref base) => {\n+                let base_cmt = self.bccx.cat_expr(&**base);\n                 let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n                 // Check that we don't allow borrows of unsafe static items.\n                 if check_aliasability(self.bccx, ex.span, euv::AddrOf,"}, {"sha": "5335f9722a98b416ee5b45799c3ef52821dc9935", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -106,7 +106,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n     // flow dependent conditions.\n     match item.node {\n         ast::ItemStatic(_, _, ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, ex);\n+            gather_loans::gather_loans_in_static_initializer(this, &*ex);\n         }\n         _ => {\n             visit::walk_item(this, item, ());\n@@ -480,7 +480,7 @@ impl<'a> BorrowckCtxt<'a> {\n             move_data::MoveExpr => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to \\\n@@ -512,7 +512,7 @@ impl<'a> BorrowckCtxt<'a> {\n             move_data::Captured => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n-                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(format!(\"Captured({:?}) maps to \\"}, {"sha": "f855ca37597a334301fe1df3f33e67a1bb4ef74f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 77, "deletions": 75, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -17,6 +17,8 @@ use syntax::ast;\n use syntax::ast_util;\n use util::nodemap::NodeMap;\n \n+use std::gc::Gc;\n+\n struct CFGBuilder<'a> {\n     tcx: &'a ty::ctxt,\n     exit_map: NodeMap<CFGIndex>,\n@@ -66,23 +68,23 @@ fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n impl<'a> CFGBuilder<'a> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n-        for &stmt in blk.stmts.iter() {\n-            stmts_exit = self.stmt(stmt, stmts_exit);\n+        for stmt in blk.stmts.iter() {\n+            stmts_exit = self.stmt(stmt.clone(), stmts_exit);\n         }\n \n-        let expr_exit = self.opt_expr(blk.expr, stmts_exit);\n+        let expr_exit = self.opt_expr(blk.expr.clone(), stmts_exit);\n \n         self.add_node(blk.id, [expr_exit])\n     }\n \n-    fn stmt(&mut self, stmt: @ast::Stmt, pred: CFGIndex) -> CFGIndex {\n+    fn stmt(&mut self, stmt: Gc<ast::Stmt>, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n-            ast::StmtDecl(decl, _) => {\n-                self.decl(decl, pred)\n+            ast::StmtDecl(ref decl, _) => {\n+                self.decl(&**decl, pred)\n             }\n \n-            ast::StmtExpr(expr, _) | ast::StmtSemi(expr, _) => {\n-                self.expr(expr, pred)\n+            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n+                self.expr(expr.clone(), pred)\n             }\n \n             ast::StmtMac(..) => {\n@@ -91,11 +93,11 @@ impl<'a> CFGBuilder<'a> {\n         }\n     }\n \n-    fn decl(&mut self, decl: @ast::Decl, pred: CFGIndex) -> CFGIndex {\n+    fn decl(&mut self, decl: &ast::Decl, pred: CFGIndex) -> CFGIndex {\n         match decl.node {\n-            ast::DeclLocal(local) => {\n-                let init_exit = self.opt_expr(local.init, pred);\n-                self.pat(local.pat, init_exit)\n+            ast::DeclLocal(ref local) => {\n+                let init_exit = self.opt_expr(local.init.clone(), pred);\n+                self.pat(&*local.pat, init_exit)\n             }\n \n             ast::DeclItem(_) => {\n@@ -104,7 +106,7 @@ impl<'a> CFGBuilder<'a> {\n         }\n     }\n \n-    fn pat(&mut self, pat: @ast::Pat, pred: CFGIndex) -> CFGIndex {\n+    fn pat(&mut self, pat: &ast::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n             ast::PatIdent(_, _, None) |\n             ast::PatEnum(_, None) |\n@@ -114,23 +116,23 @@ impl<'a> CFGBuilder<'a> {\n                 self.add_node(pat.id, [pred])\n             }\n \n-            ast::PatBox(subpat) |\n-            ast::PatRegion(subpat) |\n-            ast::PatIdent(_, _, Some(subpat)) => {\n-                let subpat_exit = self.pat(subpat, pred);\n+            ast::PatBox(ref subpat) |\n+            ast::PatRegion(ref subpat) |\n+            ast::PatIdent(_, _, Some(ref subpat)) => {\n+                let subpat_exit = self.pat(&**subpat, pred);\n                 self.add_node(pat.id, [subpat_exit])\n             }\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n                 let pats_exit =\n-                    self.pats_all(subpats.iter().map(|p| *p), pred);\n+                    self.pats_all(subpats.iter().map(|p| p.clone()), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n             ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n-                    self.pats_all(subpats.iter().map(|f| f.pat), pred);\n+                    self.pats_all(subpats.iter().map(|f| f.pat.clone()), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n@@ -150,39 +152,39 @@ impl<'a> CFGBuilder<'a> {\n         }\n     }\n \n-    fn pats_all<I: Iterator<@ast::Pat>>(&mut self,\n+    fn pats_all<I: Iterator<Gc<ast::Pat>>>(&mut self,\n                                         pats: I,\n                                         pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n         let mut pats = pats;\n-        pats.fold(pred, |pred, pat| self.pat(pat, pred))\n+        pats.fold(pred, |pred, pat| self.pat(&*pat, pred))\n     }\n \n     fn pats_any(&mut self,\n-                pats: &[@ast::Pat],\n+                pats: &[Gc<ast::Pat>],\n                 pred: CFGIndex) -> CFGIndex {\n         //! Handles case where just one of the patterns must match.\n \n         if pats.len() == 1 {\n-            self.pat(pats[0], pred)\n+            self.pat(&*pats[0], pred)\n         } else {\n             let collect = self.add_dummy_node([]);\n             for &pat in pats.iter() {\n-                let pat_exit = self.pat(pat, pred);\n+                let pat_exit = self.pat(&*pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n             }\n             collect\n         }\n     }\n \n-    fn expr(&mut self, expr: @ast::Expr, pred: CFGIndex) -> CFGIndex {\n+    fn expr(&mut self, expr: Gc<ast::Expr>, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n-            ast::ExprBlock(blk) => {\n-                let blk_exit = self.block(blk, pred);\n+            ast::ExprBlock(ref blk) => {\n+                let blk_exit = self.block(&**blk, pred);\n                 self.add_node(expr.id, [blk_exit])\n             }\n \n-            ast::ExprIf(cond, then, None) => {\n+            ast::ExprIf(ref cond, ref then, None) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -197,12 +199,12 @@ impl<'a> CFGBuilder<'a> {\n                 //    v 3   v 4\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(cond, pred);                // 1\n-                let then_exit = self.block(then, cond_exit);          // 2\n-                self.add_node(expr.id, [cond_exit, then_exit])        // 3,4\n+                let cond_exit = self.expr(cond.clone(), pred);           // 1\n+                let then_exit = self.block(&**then, cond_exit);          // 2\n+                self.add_node(expr.id, [cond_exit, then_exit])           // 3,4\n             }\n \n-            ast::ExprIf(cond, then, Some(otherwise)) => {\n+            ast::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -217,13 +219,13 @@ impl<'a> CFGBuilder<'a> {\n                 //    v 4   v 5\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(cond, pred);                // 1\n-                let then_exit = self.block(then, cond_exit);          // 2\n-                let else_exit = self.expr(otherwise, cond_exit);      // 3\n-                self.add_node(expr.id, [then_exit, else_exit])        // 4, 5\n+                let cond_exit = self.expr(cond.clone(), pred);           // 1\n+                let then_exit = self.block(&**then, cond_exit);          // 2\n+                let else_exit = self.expr(otherwise.clone(), cond_exit); // 3\n+                self.add_node(expr.id, [then_exit, else_exit])           // 4, 5\n             }\n \n-            ast::ExprWhile(cond, body) => {\n+            ast::ExprWhile(ref cond, ref body) => {\n                 //\n                 //         [pred]\n                 //           |\n@@ -242,22 +244,22 @@ impl<'a> CFGBuilder<'a> {\n                 // may cause additional edges.\n \n                 // Is the condition considered part of the loop?\n-                let loopback = self.add_dummy_node([pred]);           // 1\n-                let cond_exit = self.expr(cond, loopback);            // 2\n-                let expr_exit = self.add_node(expr.id, [cond_exit]);  // 3\n+                let loopback = self.add_dummy_node([pred]);              // 1\n+                let cond_exit = self.expr(cond.clone(), loopback);       // 2\n+                let expr_exit = self.add_node(expr.id, [cond_exit]);     // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n-                let body_exit = self.block(body, cond_exit);          // 4\n-                self.add_contained_edge(body_exit, loopback);         // 5\n+                let body_exit = self.block(&**body, cond_exit);          // 4\n+                self.add_contained_edge(body_exit, loopback);            // 5\n                 expr_exit\n             }\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::ExprLoop(body, _) => {\n+            ast::ExprLoop(ref body, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -272,20 +274,20 @@ impl<'a> CFGBuilder<'a> {\n                 // Note that `break` and `loop` statements\n                 // may cause additional edges.\n \n-                let loopback = self.add_dummy_node([pred]);           // 1\n-                let expr_exit = self.add_node(expr.id, []);           // 2\n+                let loopback = self.add_dummy_node([pred]);              // 1\n+                let expr_exit = self.add_node(expr.id, []);              // 2\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n-                let body_exit = self.block(body, loopback);           // 3\n-                self.add_contained_edge(body_exit, loopback);         // 4\n+                let body_exit = self.block(&**body, loopback);           // 3\n+                self.add_contained_edge(body_exit, loopback);            // 4\n                 self.loop_scopes.pop();\n                 expr_exit\n             }\n \n-            ast::ExprMatch(discr, ref arms) => {\n+            ast::ExprMatch(ref discr, ref arms) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -309,21 +311,21 @@ impl<'a> CFGBuilder<'a> {\n                 //     v 5  v    v\n                 //   [....expr....]\n                 //\n-                let discr_exit = self.expr(discr, pred);                 // 1\n+                let discr_exit = self.expr(discr.clone(), pred);         // 1\n \n                 let expr_exit = self.add_node(expr.id, []);\n                 let mut guard_exit = discr_exit;\n                 for arm in arms.iter() {\n-                    guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n+                    guard_exit = self.opt_expr(arm.guard, guard_exit);   // 2\n                     let pats_exit = self.pats_any(arm.pats.as_slice(),\n-                                                  guard_exit); // 3\n-                    let body_exit = self.expr(arm.body, pats_exit);      // 4\n+                                                  guard_exit);           // 3\n+                    let body_exit = self.expr(arm.body.clone(), pats_exit); // 4\n                     self.add_contained_edge(body_exit, expr_exit);       // 5\n                 }\n                 expr_exit\n             }\n \n-            ast::ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n+            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -338,13 +340,13 @@ impl<'a> CFGBuilder<'a> {\n                 //    v 3  v 4\n                 //   [..exit..]\n                 //\n-                let l_exit = self.expr(l, pred);                         // 1\n-                let r_exit = self.expr(r, l_exit);                       // 2\n+                let l_exit = self.expr(l.clone(), pred);                  // 1\n+                let r_exit = self.expr(r.clone(), l_exit);               // 2\n                 self.add_node(expr.id, [l_exit, r_exit])                 // 3,4\n             }\n \n-            ast::ExprRet(v) => {\n-                let v_exit = self.opt_expr(v, pred);\n+            ast::ExprRet(ref v) => {\n+                let v_exit = self.opt_expr(v.clone(), pred);\n                 let b = self.add_node(expr.id, [v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_node(ast::DUMMY_NODE_ID, [])\n@@ -370,21 +372,21 @@ impl<'a> CFGBuilder<'a> {\n                 self.straightline(expr, pred, elems.as_slice())\n             }\n \n-            ast::ExprCall(func, ref args) => {\n-                self.call(expr, pred, func, args.as_slice())\n+            ast::ExprCall(ref func, ref args) => {\n+                self.call(expr, pred, func.clone(), args.as_slice())\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n                 self.call(expr, pred, *args.get(0), args.slice_from(1))\n             }\n \n-            ast::ExprIndex(l, r) |\n-            ast::ExprBinary(_, l, r) if self.is_method_call(expr) => {\n-                self.call(expr, pred, l, [r])\n+            ast::ExprIndex(ref l, ref r) |\n+            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(&*expr) => {\n+                self.call(expr, pred, l.clone(), [r.clone()])\n             }\n \n-            ast::ExprUnary(_, e) if self.is_method_call(expr) => {\n-                self.call(expr, pred, e, [])\n+            ast::ExprUnary(_, ref e) if self.is_method_call(&*expr) => {\n+                self.call(expr, pred, e.clone(), [])\n             }\n \n             ast::ExprTup(ref exprs) => {\n@@ -393,7 +395,7 @@ impl<'a> CFGBuilder<'a> {\n \n             ast::ExprStruct(_, ref fields, base) => {\n                 let base_exit = self.opt_expr(base, pred);\n-                let field_exprs: Vec<@ast::Expr> =\n+                let field_exprs: Vec<Gc<ast::Expr>> =\n                     fields.iter().map(|f| f.expr).collect();\n                 self.straightline(expr, base_exit, field_exprs.as_slice())\n             }\n@@ -437,34 +439,34 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn call(&mut self,\n-            call_expr: @ast::Expr,\n+            call_expr: Gc<ast::Expr>,\n             pred: CFGIndex,\n-            func_or_rcvr: @ast::Expr,\n-            args: &[@ast::Expr]) -> CFGIndex {\n+            func_or_rcvr: Gc<ast::Expr>,\n+            args: &[Gc<ast::Expr>]) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         self.straightline(call_expr, func_or_rcvr_exit, args)\n     }\n \n     fn exprs(&mut self,\n-             exprs: &[@ast::Expr],\n+             exprs: &[Gc<ast::Expr>],\n              pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n \n         exprs.iter().fold(pred, |p, &e| self.expr(e, p))\n     }\n \n     fn opt_expr(&mut self,\n-                opt_expr: Option<@ast::Expr>,\n+                opt_expr: Option<Gc<ast::Expr>>,\n                 pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `opt_expr` evaluated, if Some\n \n         opt_expr.iter().fold(pred, |p, &e| self.expr(e, p))\n     }\n \n     fn straightline(&mut self,\n-                    expr: @ast::Expr,\n+                    expr: Gc<ast::Expr>,\n                     pred: CFGIndex,\n-                    subexprs: &[@ast::Expr]) -> CFGIndex {\n+                    subexprs: &[Gc<ast::Expr>]) -> CFGIndex {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n@@ -496,7 +498,7 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn add_exiting_edge(&mut self,\n-                        from_expr: @ast::Expr,\n+                        from_expr: Gc<ast::Expr>,\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n@@ -511,7 +513,7 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn add_returning_edge(&mut self,\n-                          _from_expr: @ast::Expr,\n+                          _from_expr: Gc<ast::Expr>,\n                           from_index: CFGIndex) {\n         let mut data = CFGEdgeData {\n             exiting_scopes: vec!(),\n@@ -523,7 +525,7 @@ impl<'a> CFGBuilder<'a> {\n     }\n \n     fn find_scope(&self,\n-                  expr: @ast::Expr,\n+                  expr: Gc<ast::Expr>,\n                   label: Option<ast::Ident>) -> LoopScope {\n         match label {\n             None => {"}, {"sha": "cf886702d863126f7373e17b7db64e8ac646cf8f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -45,13 +45,13 @@ pub fn check_crate(krate: &Crate, tcx: &ty::ctxt) {\n fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n     match it.node {\n         ItemStatic(_, _, ex) => {\n-            v.visit_expr(ex, true);\n+            v.visit_expr(&*ex, true);\n             check_item_recursion(&v.tcx.sess, &v.tcx.map, &v.tcx.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n                 for ex in var.node.disr_expr.iter() {\n-                    v.visit_expr(*ex, true);\n+                    v.visit_expr(&**ex, true);\n                 }\n             }\n         }\n@@ -73,10 +73,10 @@ fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n     }\n     match p.node {\n       // Let through plain ~-string literals here\n-      PatLit(a) => if !is_str(a) { v.visit_expr(a, true); },\n-      PatRange(a, b) => {\n-        if !is_str(a) { v.visit_expr(a, true); }\n-        if !is_str(b) { v.visit_expr(b, true); }\n+      PatLit(ref a) => if !is_str(&**a) { v.visit_expr(&**a, true); },\n+      PatRange(ref a, ref b) => {\n+        if !is_str(&**a) { v.visit_expr(&**a, true); }\n+        if !is_str(&**b) { v.visit_expr(&**b, true); }\n       }\n       _ => visit::walk_pat(v, p, false)\n     }\n@@ -245,7 +245,7 @@ impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n                 match self.def_map.borrow().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n                             ast_util::is_local(def_id) => {\n-                        self.visit_item(self.ast_map.expect_item(def_id.node), ());\n+                        self.visit_item(&*self.ast_map.expect_item(def_id.node), ());\n                     }\n                     _ => ()\n                 }"}, {"sha": "c855d59d50851f7100edc538e624ad4a24508540", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -35,15 +35,15 @@ impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr, cx:Context) {\n         match e.node {\n-            ast::ExprWhile(e, b) => {\n-                self.visit_expr(e, cx);\n-                self.visit_block(b, Loop);\n+            ast::ExprWhile(ref e, ref b) => {\n+                self.visit_expr(&**e, cx);\n+                self.visit_block(&**b, Loop);\n             }\n-            ast::ExprLoop(b, _) => {\n-                self.visit_block(b, Loop);\n+            ast::ExprLoop(ref b, _) => {\n+                self.visit_block(&**b, Loop);\n             }\n-            ast::ExprFnBlock(_, b) | ast::ExprProc(_, b) => {\n-                self.visit_block(b, Closure);\n+            ast::ExprFnBlock(_, ref b) | ast::ExprProc(_, ref b) => {\n+                self.visit_block(&**b, Closure);\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", cx, e.span),\n             ast::ExprAgain(_) => self.require_loop(\"continue\", cx, e.span),"}, {"sha": "b937d8ef3bbc1bbd758e2e57df82c4ed89ef65d6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -19,6 +19,7 @@ use middle::ty;\n use util::ppaux::ty_to_str;\n \n use std::cmp;\n+use std::gc::Gc;\n use std::iter;\n use syntax::ast::*;\n use syntax::ast_util::{is_unguarded, walk_pat};\n@@ -104,7 +105,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 match opt_def {\n                     Some(DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        match eval_const_expr(cx.tcx, const_expr) {\n+                        match eval_const_expr(cx.tcx, &*const_expr) {\n                             const_float(f) if f.is_nan() => true,\n                             _ => false\n                         }\n@@ -113,7 +114,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 }\n             };\n \n-            walk_pat(*pat, |p| {\n+            walk_pat(&**pat, |p| {\n                 if pat_matches_nan(p) {\n                     cx.tcx.sess.span_warn(p.span, \"unmatchable NaN in pattern, \\\n                                                    use the is_nan method in a guard instead\");\n@@ -133,7 +134,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     }\n }\n \n-fn raw_pat(p: @Pat) -> @Pat {\n+fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n     match p.node {\n       PatIdent(_, _, Some(s)) => { raw_pat(s) }\n       _ => { p }\n@@ -193,7 +194,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &matrix) {\n     cx.tcx.sess.span_err(sp, msg.as_slice());\n }\n \n-type matrix = Vec<Vec<@Pat> > ;\n+type matrix = Vec<Vec<Gc<Pat>>>;\n \n #[deriving(Clone)]\n enum useful {\n@@ -224,7 +225,7 @@ enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n+fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[Gc<Pat>]) -> useful {\n     if m.len() == 0u {\n         return useful_;\n     }\n@@ -327,7 +328,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n \n fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              m: &matrix,\n-                             v: &[@Pat],\n+                             v: &[Gc<Pat>],\n                              ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n@@ -345,7 +346,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n+fn pat_ctor_id(cx: &MatchCheckCtxt, p: Gc<Pat>) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n       PatWild | PatWildMulti => { None }\n@@ -355,14 +356,14 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n           Some(DefVariant(_, id, _)) => Some(variant(id)),\n           Some(DefStatic(did, false)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-            Some(val(eval_const_expr(cx.tcx, const_expr)))\n+            Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n           }\n           _ => None\n         }\n       }\n-      PatLit(expr) => { Some(val(eval_const_expr(cx.tcx, expr))) }\n-      PatRange(lo, hi) => {\n-        Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n+      PatLit(ref expr) => { Some(val(eval_const_expr(cx.tcx, &**expr))) }\n+      PatRange(ref lo, ref hi) => {\n+        Some(range(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi)))\n       }\n       PatStruct(..) => {\n         match cx.tcx.def_map.borrow().find(&pat.id) {\n@@ -383,7 +384,7 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n     }\n }\n \n-fn is_wild(cx: &MatchCheckCtxt, p: @Pat) -> bool {\n+fn is_wild(cx: &MatchCheckCtxt, p: Gc<Pat>) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n       PatWild | PatWildMulti => { true }\n@@ -548,12 +549,12 @@ fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     }\n }\n \n-fn wild() -> @Pat {\n-    @Pat {id: 0, node: PatWild, span: DUMMY_SP}\n+fn wild() -> Gc<Pat> {\n+    box(GC) Pat {id: 0, node: PatWild, span: DUMMY_SP}\n }\n \n-fn wild_multi() -> @Pat {\n-    @Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n+fn wild_multi() -> Gc<Pat> {\n+    box(GC) Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n }\n \n fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val) -> Option<bool> {\n@@ -572,13 +573,13 @@ fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val\n }\n \n fn specialize(cx: &MatchCheckCtxt,\n-                  r: &[@Pat],\n+                  r: &[Gc<Pat>],\n                   ctor_id: &ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n-               -> Option<Vec<@Pat> > {\n+               -> Option<Vec<Gc<Pat>>> {\n     let &Pat{id: ref pat_id, node: ref n, span: ref pat_span} = &(*raw_pat(r[0]));\n-    let head: Option<Vec<@Pat>> = match n {\n+    let head: Option<Vec<Gc<Pat>>> = match n {\n             &PatWild => {\n                 Some(Vec::from_elem(arity, wild()))\n             }\n@@ -597,7 +598,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                     }\n                     Some(DefStatic(did, _)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        let e_v = eval_const_expr(cx.tcx, const_expr);\n+                        let e_v = eval_const_expr(cx.tcx, &*const_expr);\n                         match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n                            Some(true) => Some(vec!()),\n                            Some(false) => None,\n@@ -617,7 +618,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 match def {\n                     DefStatic(did, _) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        let e_v = eval_const_expr(cx.tcx, const_expr);\n+                        let e_v = eval_const_expr(cx.tcx, &*const_expr);\n                         match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n                            Some(true) => Some(vec!()),\n                            Some(false) => None,\n@@ -681,7 +682,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 Some(vec!(inner.clone()))\n             }\n             &PatLit(ref expr) => {\n-              let expr_value = eval_const_expr(cx.tcx, *expr);\n+              let expr_value = eval_const_expr(cx.tcx, &**expr);\n               match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n                  Some(true) => Some(vec!()),\n                  Some(false) => None,\n@@ -692,8 +693,8 @@ fn specialize(cx: &MatchCheckCtxt,\n               }\n             }\n             &PatRange(ref from, ref to) => {\n-              let from_value = eval_const_expr(cx.tcx, *from);\n-              let to_value = eval_const_expr(cx.tcx, *to);\n+              let from_value = eval_const_expr(cx.tcx, &**from);\n+              let to_value = eval_const_expr(cx.tcx, &**to);\n               match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n                  Some(true) => Some(vec!()),\n                  Some(false) => None,\n@@ -733,7 +734,7 @@ fn specialize(cx: &MatchCheckCtxt,\n     head.map(|head| head.append(r.tail()))\n }\n \n-fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {\n+fn default(cx: &MatchCheckCtxt, r: &[Gc<Pat>]) -> Option<Vec<Gc<Pat>>> {\n     if is_wild(cx, r[0]) {\n         Some(Vec::from_slice(r.tail()))\n     } else {\n@@ -750,7 +751,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n     };\n \n     let mut spans = vec![];\n-    find_refutable(cx, loc.pat, &mut spans);\n+    find_refutable(cx, &*loc.pat, &mut spans);\n \n     for span in spans.iter() {\n         cx.tcx.sess.span_err(*span,\n@@ -769,7 +770,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n     visit::walk_fn(cx, kind, decl, body, sp, ());\n     for input in decl.inputs.iter() {\n         let mut spans = vec![];\n-        find_refutable(cx, input.pat, &mut spans);\n+        find_refutable(cx, &*input.pat, &mut spans);\n \n         for span in spans.iter() {\n             cx.tcx.sess.span_err(*span,\n@@ -799,8 +800,8 @@ fn find_refutable(cx: &MatchCheckCtxt, pat: &Pat, spans: &mut Vec<Span>) {\n     }\n \n     match pat.node {\n-      PatBox(sub) | PatRegion(sub) | PatIdent(_, _, Some(sub)) => {\n-        find_refutable(cx, sub, spans)\n+      PatBox(ref sub) | PatRegion(ref sub) | PatIdent(_, _, Some(ref sub)) => {\n+        find_refutable(cx, &**sub, spans)\n       }\n       PatWild | PatWildMulti | PatIdent(_, _, None) => {}\n       PatLit(lit) => {\n@@ -817,12 +818,12 @@ fn find_refutable(cx: &MatchCheckCtxt, pat: &Pat, spans: &mut Vec<Span>) {\n       PatRange(_, _) => { this_pattern!() }\n       PatStruct(_, ref fields, _) => {\n           for f in fields.iter() {\n-              find_refutable(cx, f.pat, spans);\n+              find_refutable(cx, &*f.pat, spans);\n           }\n       }\n       PatTup(ref elts) | PatEnum(_, Some(ref elts))=> {\n           for elt in elts.iter() {\n-              find_refutable(cx, *elt, spans)\n+              find_refutable(cx, &**elt, spans)\n           }\n       }\n       PatEnum(_,_) => {}\n@@ -835,12 +836,12 @@ fn find_refutable(cx: &MatchCheckCtxt, pat: &Pat, spans: &mut Vec<Span>) {\n \n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                    has_guard: bool,\n-                                   pats: &[@Pat]) {\n+                                   pats: &[Gc<Pat>]) {\n     let tcx = cx.tcx;\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n     for pat in pats.iter() {\n-        pat_bindings(def_map, *pat, |bm, _, span, _path| {\n+        pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n             match bm {\n                 BindByRef(_) => {\n                     by_ref_span = Some(span);\n@@ -851,11 +852,11 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         })\n     }\n \n-    let check_move: |&Pat, Option<@Pat>| = |p, sub| {\n+    let check_move: |&Pat, Option<Gc<Pat>>| = |p, sub| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(def_map, p)) {\n+        if sub.map_or(false, |p| pat_contains_bindings(def_map, &*p)) {\n             tcx.sess.span_err(\n                 p.span,\n                 \"cannot bind by-move with sub-bindings\");\n@@ -875,8 +876,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     for pat in pats.iter() {\n-        walk_pat(*pat, |p| {\n-            if pat_is_binding(def_map, p) {\n+        walk_pat(&**pat, |p| {\n+            if pat_is_binding(def_map, &*p) {\n                 match p.node {\n                     PatIdent(BindByValue(_), _, sub) => {\n                         let pat_ty = ty::node_id_to_type(tcx, p.id);"}, {"sha": "36e98763ebbf898099e04656fab160708d07e5f1", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -77,13 +77,14 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n         debug!(\"visit_item(item={})\", pprust::item_to_str(i));\n         match i.node {\n-            ast::ItemStatic(_, mutability, expr) => {\n+            ast::ItemStatic(_, mutability, ref expr) => {\n                 match mutability {\n                     ast::MutImmutable => {\n-                        self.visit_expr(expr, true);\n+                        self.visit_expr(&**expr, true);\n                     }\n                     ast::MutMutable => {\n-                        self.report_error(expr.span, safe_type_for_static_mut(self.tcx, expr));\n+                        let safe = safe_type_for_static_mut(self.tcx, &**expr);\n+                        self.report_error(expr.span, safe);\n                     }\n                 }\n             }"}, {"sha": "13d0443a00f2b62a5f968c2649846704fc964916", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -26,6 +26,7 @@ use syntax::visit;\n use syntax::{ast, ast_map, ast_util};\n \n use std::rc::Rc;\n+use std::gc::Gc;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -81,7 +82,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n+pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<Gc<Expr>> {\n     let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n         Some(def::DefStatic(def_id, false)) => {\n@@ -97,8 +98,9 @@ pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n                             enum_def: ast::DefId,\n                             variant_def: ast::DefId)\n-                       -> Option<@Expr> {\n-    fn variant_expr(variants: &[ast::P<ast::Variant>], id: ast::NodeId) -> Option<@Expr> {\n+                       -> Option<Gc<Expr>> {\n+    fn variant_expr(variants: &[ast::P<ast::Variant>],\n+                    id: ast::NodeId) -> Option<Gc<Expr>> {\n         for variant in variants.iter() {\n             if variant.node.id == id {\n                 return variant.node.disr_expr;\n@@ -141,7 +143,7 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n }\n \n pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n-                          -> Option<@Expr> {\n+                          -> Option<Gc<Expr>> {\n     if ast_util::is_local(def_id) {\n         {\n             match tcx.map.find(def_id.node) {\n@@ -186,39 +188,39 @@ impl<'a> ConstEvalVisitor<'a> {\n             None => {}\n         }\n         let cn = match e.node {\n-            ast::ExprLit(lit) => {\n+            ast::ExprLit(ref lit) => {\n                 match lit.node {\n                     ast::LitStr(..) | ast::LitFloat(..) => general_const,\n                     _ => integral_const\n                 }\n             }\n \n-            ast::ExprUnary(_, inner) | ast::ExprParen(inner) =>\n-                self.classify(inner),\n+            ast::ExprUnary(_, ref inner) | ast::ExprParen(ref inner) =>\n+                self.classify(&**inner),\n \n-            ast::ExprBinary(_, a, b) =>\n-                join(self.classify(a), self.classify(b)),\n+            ast::ExprBinary(_, ref a, ref b) =>\n+                join(self.classify(&**a), self.classify(&**b)),\n \n             ast::ExprTup(ref es) |\n             ast::ExprVec(ref es) =>\n-                join_all(es.iter().map(|e| self.classify(*e))),\n+                join_all(es.iter().map(|e| self.classify(&**e))),\n \n-            ast::ExprVstore(e, vstore) => {\n+            ast::ExprVstore(ref e, vstore) => {\n                 match vstore {\n-                    ast::ExprVstoreSlice => self.classify(e),\n+                    ast::ExprVstoreSlice => self.classify(&**e),\n                     ast::ExprVstoreUniq |\n                     ast::ExprVstoreMutSlice => non_const\n                 }\n             }\n \n             ast::ExprStruct(_, ref fs, None) => {\n-                let cs = fs.iter().map(|f| self.classify(f.expr));\n+                let cs = fs.iter().map(|f| self.classify(&*f.expr));\n                 join_all(cs)\n             }\n \n-            ast::ExprCast(base, _) => {\n+            ast::ExprCast(ref base, _) => {\n                 let ty = ty::expr_ty(self.tcx, e);\n-                let base = self.classify(base);\n+                let base = self.classify(&**base);\n                 if ty::type_is_integral(ty) {\n                     join(integral_const, base)\n                 } else if ty::type_is_fp(ty) {\n@@ -228,12 +230,13 @@ impl<'a> ConstEvalVisitor<'a> {\n                 }\n             }\n \n-            ast::ExprField(base, _, _) => self.classify(base),\n+            ast::ExprField(ref base, _, _) => self.classify(&**base),\n \n-            ast::ExprIndex(base, idx) =>\n-                join(self.classify(base), self.classify(idx)),\n+            ast::ExprIndex(ref base, ref idx) =>\n+                join(self.classify(&**base), self.classify(&**idx)),\n \n-            ast::ExprAddrOf(ast::MutImmutable, base) => self.classify(base),\n+            ast::ExprAddrOf(ast::MutImmutable, ref base) =>\n+                self.classify(&**base),\n \n             // FIXME: (#3728) we can probably do something CCI-ish\n             // surrounding nonlocal constants. But we don't yet.\n@@ -257,7 +260,7 @@ impl<'a> ConstEvalVisitor<'a> {\n     fn lookup_constness(&self, e: &Expr) -> constness {\n         match lookup_const(self.tcx, e) {\n             Some(rhs) => {\n-                let ty = ty::expr_ty(self.tcx, rhs);\n+                let ty = ty::expr_ty(self.tcx, &*rhs);\n                 if ty::type_is_integral(ty) {\n                     integral_const\n                 } else {\n@@ -310,8 +313,8 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n                             -> Result<const_val, String> {\n     fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n     match e.node {\n-      ExprUnary(UnNeg, inner) => {\n-        match eval_const_expr_partial(tcx, inner) {\n+      ExprUnary(UnNeg, ref inner) => {\n+        match eval_const_expr_partial(tcx, &**inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n@@ -320,17 +323,17 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           ref err => ((*err).clone())\n         }\n       }\n-      ExprUnary(UnNot, inner) => {\n-        match eval_const_expr_partial(tcx, inner) {\n+      ExprUnary(UnNot, ref inner) => {\n+        match eval_const_expr_partial(tcx, &**inner) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(\"not on float or string\".to_string())\n         }\n       }\n-      ExprBinary(op, a, b) => {\n-        match (eval_const_expr_partial(tcx, a),\n-               eval_const_expr_partial(tcx, b)) {\n+      ExprBinary(op, ref a, ref b) => {\n+        match (eval_const_expr_partial(tcx, &**a),\n+               eval_const_expr_partial(tcx, &**b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n             match op {\n               BiAdd => Ok(const_float(a + b)),\n@@ -431,19 +434,19 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           _ => Err(\"bad operands for binary\".to_string())\n         }\n       }\n-      ExprCast(base, target_ty) => {\n+      ExprCast(ref base, ref target_ty) => {\n         // This tends to get called w/o the type actually having been\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n         let ety = ty::expr_ty_opt(tcx.ty_ctxt(), e)\n-                .or_else(|| astconv::ast_ty_to_prim_ty(tcx.ty_ctxt(), target_ty))\n+                .or_else(|| astconv::ast_ty_to_prim_ty(tcx.ty_ctxt(), &**target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.ty_ctxt().sess.span_fatal(target_ty.span,\n                                                   \"target type not found for \\\n                                                    const cast\")\n                 });\n \n-        let base = eval_const_expr_partial(tcx, base);\n+        let base = eval_const_expr_partial(tcx, &**base);\n         match base {\n             Err(_) => base,\n             Ok(val) => {\n@@ -479,14 +482,14 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n       }\n       ExprPath(_) => {\n           match lookup_const(tcx.ty_ctxt(), e) {\n-              Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), actual_e),\n+              Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), &*actual_e),\n               None => Err(\"non-constant path in constant expr\".to_string())\n           }\n       }\n-      ExprLit(lit) => Ok(lit_to_const(lit)),\n+      ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n       // If we have a vstore, just keep going; it has to be a string\n-      ExprVstore(e, _) => eval_const_expr_partial(tcx, e),\n-      ExprParen(e)     => eval_const_expr_partial(tcx, e),\n+      ExprVstore(ref e, _) => eval_const_expr_partial(tcx, &**e),\n+      ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n       ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &**expr),"}, {"sha": "b8db8e230b074c589e7ff646fcd7bcf394a6ee2d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -21,7 +21,7 @@ use middle::def;\n use middle::ty;\n use middle::typeck;\n use std::io;\n-use std::string::String;\n+use std::gc::Gc;\n use std::uint;\n use syntax::ast;\n use syntax::ast_util;\n@@ -346,8 +346,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n \n         self.merge_with_entry_set(blk.id, in_out);\n \n-        for &stmt in blk.stmts.iter() {\n-            self.walk_stmt(stmt, in_out, loop_scopes);\n+        for stmt in blk.stmts.iter() {\n+            self.walk_stmt(stmt.clone(), in_out, loop_scopes);\n         }\n \n         self.walk_opt_expr(blk.expr, in_out, loop_scopes);\n@@ -356,16 +356,16 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_stmt(&mut self,\n-                 stmt: @ast::Stmt,\n+                 stmt: Gc<ast::Stmt>,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut Vec<LoopScope> ) {\n         match stmt.node {\n-            ast::StmtDecl(decl, _) => {\n-                self.walk_decl(decl, in_out, loop_scopes);\n+            ast::StmtDecl(ref decl, _) => {\n+                self.walk_decl(decl.clone(), in_out, loop_scopes);\n             }\n \n-            ast::StmtExpr(expr, _) | ast::StmtSemi(expr, _) => {\n-                self.walk_expr(expr, in_out, loop_scopes);\n+            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n+                self.walk_expr(&**expr, in_out, loop_scopes);\n             }\n \n             ast::StmtMac(..) => {\n@@ -375,11 +375,11 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_decl(&mut self,\n-                 decl: @ast::Decl,\n+                 decl: Gc<ast::Decl>,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut Vec<LoopScope> ) {\n         match decl.node {\n-            ast::DeclLocal(local) => {\n+            ast::DeclLocal(ref local) => {\n                 self.walk_opt_expr(local.init, in_out, loop_scopes);\n                 self.walk_pat(local.pat, in_out, loop_scopes);\n             }\n@@ -415,10 +415,10 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 //    v     v\n                 //   (  succ  )\n                 //\n-                self.walk_expr(cond, in_out, loop_scopes);\n+                self.walk_expr(&*cond, in_out, loop_scopes);\n \n                 let mut then_bits = in_out.to_owned();\n-                self.walk_block(then, then_bits, loop_scopes);\n+                self.walk_block(&*then, then_bits, loop_scopes);\n \n                 self.walk_opt_expr(els, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, then_bits, in_out);\n@@ -437,22 +437,22 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 //    <--+ (break)\n                 //\n \n-                self.walk_expr(cond, in_out, loop_scopes);\n+                self.walk_expr(&*cond, in_out, loop_scopes);\n \n                 let mut body_bits = in_out.to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     break_bits: Vec::from_slice(in_out)\n                 });\n-                self.walk_block(blk, body_bits, loop_scopes);\n+                self.walk_block(&*blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n                 let new_loop_scope = loop_scopes.pop().unwrap();\n                 copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::ExprLoop(blk, _) => {\n+            ast::ExprLoop(ref blk, _) => {\n                 //\n                 //     (expr) <--+\n                 //       |       |\n@@ -468,15 +468,15 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                     loop_id: expr.id,\n                     break_bits: Vec::from_slice(in_out)\n                 });\n-                self.walk_block(blk, body_bits, loop_scopes);\n+                self.walk_block(&**blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n \n                 let new_loop_scope = loop_scopes.pop().unwrap();\n                 assert_eq!(new_loop_scope.loop_id, expr.id);\n                 copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n \n-            ast::ExprMatch(discr, ref arms) => {\n+            ast::ExprMatch(ref discr, ref arms) => {\n                 //\n                 //    (discr)\n                 //     / | \\\n@@ -488,7 +488,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 //   (  succ  )\n                 //\n                 //\n-                self.walk_expr(discr, in_out, loop_scopes);\n+                self.walk_expr(&**discr, in_out, loop_scopes);\n \n                 let mut guards = in_out.to_owned();\n \n@@ -507,7 +507,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                     self.walk_pat_alternatives(arm.pats.as_slice(),\n                                                body,\n                                                loop_scopes);\n-                    self.walk_expr(arm.body, body, loop_scopes);\n+                    self.walk_expr(&*arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n                 }\n             }\n@@ -530,30 +530,30 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 self.reset(in_out);\n             }\n \n-            ast::ExprAssign(l, r) |\n-            ast::ExprAssignOp(_, l, r) => {\n-                self.walk_expr(r, in_out, loop_scopes);\n-                self.walk_expr(l, in_out, loop_scopes);\n+            ast::ExprAssign(ref l, ref r) |\n+            ast::ExprAssignOp(_, ref l, ref r) => {\n+                self.walk_expr(&**r, in_out, loop_scopes);\n+                self.walk_expr(&**l, in_out, loop_scopes);\n             }\n \n             ast::ExprVec(ref exprs) => {\n                 self.walk_exprs(exprs.as_slice(), in_out, loop_scopes)\n             }\n \n-            ast::ExprRepeat(l, r) => {\n-                self.walk_expr(l, in_out, loop_scopes);\n-                self.walk_expr(r, in_out, loop_scopes);\n+            ast::ExprRepeat(ref l, ref r) => {\n+                self.walk_expr(&**l, in_out, loop_scopes);\n+                self.walk_expr(&**r, in_out, loop_scopes);\n             }\n \n             ast::ExprStruct(_, ref fields, with_expr) => {\n                 for field in fields.iter() {\n-                    self.walk_expr(field.expr, in_out, loop_scopes);\n+                    self.walk_expr(&*field.expr, in_out, loop_scopes);\n                 }\n                 self.walk_opt_expr(with_expr, in_out, loop_scopes);\n             }\n \n-            ast::ExprCall(f, ref args) => {\n-                self.walk_expr(f, in_out, loop_scopes);\n+            ast::ExprCall(ref f, ref args) => {\n+                self.walk_expr(&**f, in_out, loop_scopes);\n                 self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n             }\n \n@@ -574,10 +574,10 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 self.walk_exprs(exprs.as_slice(), in_out, loop_scopes);\n             }\n \n-            ast::ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n-                self.walk_expr(l, in_out, loop_scopes);\n+            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+                self.walk_expr(&**l, in_out, loop_scopes);\n                 let temp = in_out.to_owned();\n-                self.walk_expr(r, in_out, loop_scopes);\n+                self.walk_expr(&**r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n \n@@ -589,31 +589,31 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n             ast::ExprLit(..) |\n             ast::ExprPath(..) => {}\n \n-            ast::ExprAddrOf(_, e) |\n-            ast::ExprCast(e, _) |\n-            ast::ExprUnary(_, e) |\n-            ast::ExprParen(e) |\n-            ast::ExprVstore(e, _) |\n-            ast::ExprField(e, _, _) => {\n-                self.walk_expr(e, in_out, loop_scopes);\n+            ast::ExprAddrOf(_, ref e) |\n+            ast::ExprCast(ref e, _) |\n+            ast::ExprUnary(_, ref e) |\n+            ast::ExprParen(ref e) |\n+            ast::ExprVstore(ref e, _) |\n+            ast::ExprField(ref e, _, _) => {\n+                self.walk_expr(&**e, in_out, loop_scopes);\n             }\n \n-            ast::ExprBox(s, e) => {\n-                self.walk_expr(s, in_out, loop_scopes);\n-                self.walk_expr(e, in_out, loop_scopes);\n+            ast::ExprBox(ref s, ref e) => {\n+                self.walk_expr(&**s, in_out, loop_scopes);\n+                self.walk_expr(&**e, in_out, loop_scopes);\n             }\n \n             ast::ExprInlineAsm(ref inline_asm) => {\n-                for &(_, expr) in inline_asm.inputs.iter() {\n-                    self.walk_expr(expr, in_out, loop_scopes);\n+                for &(_, ref expr) in inline_asm.inputs.iter() {\n+                    self.walk_expr(&**expr, in_out, loop_scopes);\n                 }\n-                for &(_, expr) in inline_asm.outputs.iter() {\n-                    self.walk_expr(expr, in_out, loop_scopes);\n+                for &(_, ref expr) in inline_asm.outputs.iter() {\n+                    self.walk_expr(&**expr, in_out, loop_scopes);\n                 }\n             }\n \n-            ast::ExprBlock(blk) => {\n-                self.walk_block(blk, in_out, loop_scopes);\n+            ast::ExprBlock(ref blk) => {\n+                self.walk_block(&**blk, in_out, loop_scopes);\n             }\n \n             ast::ExprMac(..) => {\n@@ -674,26 +674,26 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_exprs(&mut self,\n-                  exprs: &[@ast::Expr],\n+                  exprs: &[Gc<ast::Expr>],\n                   in_out: &mut [uint],\n                   loop_scopes: &mut Vec<LoopScope> ) {\n-        for &expr in exprs.iter() {\n-            self.walk_expr(expr, in_out, loop_scopes);\n+        for expr in exprs.iter() {\n+            self.walk_expr(&**expr, in_out, loop_scopes);\n         }\n     }\n \n     fn walk_opt_expr(&mut self,\n-                     opt_expr: Option<@ast::Expr>,\n+                     opt_expr: Option<Gc<ast::Expr>>,\n                      in_out: &mut [uint],\n                      loop_scopes: &mut Vec<LoopScope> ) {\n-        for &expr in opt_expr.iter() {\n-            self.walk_expr(expr, in_out, loop_scopes);\n+        for expr in opt_expr.iter() {\n+            self.walk_expr(&**expr, in_out, loop_scopes);\n         }\n     }\n \n     fn walk_call(&mut self,\n                  call_id: ast::NodeId,\n-                 args: &[@ast::Expr],\n+                 args: &[Gc<ast::Expr>],\n                  in_out: &mut [uint],\n                  loop_scopes: &mut Vec<LoopScope> ) {\n         self.walk_exprs(args, in_out, loop_scopes);\n@@ -710,13 +710,13 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_pat(&mut self,\n-                pat: @ast::Pat,\n+                pat: Gc<ast::Pat>,\n                 in_out: &mut [uint],\n                 _loop_scopes: &mut Vec<LoopScope> ) {\n         debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n-        ast_util::walk_pat(pat, |p| {\n+        ast_util::walk_pat(&*pat, |p| {\n             debug!(\"  p.id={} in_out={}\", p.id, bits_to_str(in_out));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n@@ -725,7 +725,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n     }\n \n     fn walk_pat_alternatives(&mut self,\n-                             pats: &[@ast::Pat],\n+                             pats: &[Gc<ast::Pat>],\n                              in_out: &mut [uint],\n                              loop_scopes: &mut Vec<LoopScope> ) {\n         if pats.len() == 1 {"}, {"sha": "834dc43ee6ed52d4237766798b58dfd7b5da04e1", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -184,25 +184,25 @@ impl<'a> MarkSymbolVisitor<'a> {\n                             }\n                         });\n                         self.live_symbols.extend(live_fields.map(|f| f.node.id));\n-                        visit::walk_item(self, item, ());\n+                        visit::walk_item(self, &*item, ());\n                     }\n                     ast::ItemFn(..)\n                     | ast::ItemTy(..)\n                     | ast::ItemEnum(..)\n                     | ast::ItemStatic(..) => {\n-                        visit::walk_item(self, item, ());\n+                        visit::walk_item(self, &*item, ());\n                     }\n                     _ => ()\n                 }\n             }\n             ast_map::NodeTraitMethod(trait_method) => {\n-                visit::walk_trait_method(self, trait_method, ());\n+                visit::walk_trait_method(self, &*trait_method, ());\n             }\n             ast_map::NodeMethod(method) => {\n-                visit::walk_block(self, method.body, ());\n+                visit::walk_block(self, &*method.body, ());\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n-                visit::walk_foreign_item(self, foreign_item, ());\n+                visit::walk_foreign_item(self, &*foreign_item, ());\n             }\n             _ => ()\n         }\n@@ -217,7 +217,7 @@ impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n                 self.lookup_and_handle_method(expr.id, expr.span);\n             }\n             ast::ExprField(ref lhs, ref ident, _) => {\n-                self.handle_field_access(*lhs, ident);\n+                self.handle_field_access(&**lhs, ident);\n             }\n             _ => ()\n         }\n@@ -479,7 +479,7 @@ impl<'a> Visitor<()> for DeadVisitor<'a> {\n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_method(&mut self, trait_method: &ast::TraitMethod, _: ()) {\n         match *trait_method {\n-            ast::Provided(method) => visit::walk_block(self, method.body, ()),\n+            ast::Provided(ref method) => visit::walk_block(self, &*method.body, ()),\n             ast::Required(_) => ()\n         }\n     }"}, {"sha": "6805c86f1694ceda501074f6feccfad8b803edf3", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -11,6 +11,8 @@\n use syntax::ast;\n use syntax::ast_util::local_def;\n \n+use std::gc::Gc;\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Def {\n     DefFn(ast::DefId, ast::FnStyle),\n@@ -29,7 +31,7 @@ pub enum Def {\n     DefBinding(ast::NodeId, ast::BindingMode),\n     DefUse(ast::DefId),\n     DefUpvar(ast::NodeId,  // id of closed over var\n-             @Def,     // closed over def\n+             Gc<Def>,     // closed over def\n              ast::NodeId,  // expr node that creates the closure\n              ast::NodeId), // id for the block/body of the closure expr\n "}, {"sha": "2333b329996401dc20c4596fbaa68b459a18d525", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -62,7 +62,7 @@ impl<'a> EffectCheckVisitor<'a> {\n         }\n     }\n \n-    fn check_str_index(&mut self, e: @ast::Expr) {\n+    fn check_str_index(&mut self, e: &ast::Expr) {\n         let base_type = match e.node {\n             ast::ExprIndex(base, _) => ty::node_id_to_type(self.tcx, base.id),\n             _ => return\n@@ -173,11 +173,11 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n                     _ => {}\n                 }\n             }\n-            ast::ExprAssign(base, _) | ast::ExprAssignOp(_, base, _) => {\n-                self.check_str_index(base);\n+            ast::ExprAssign(ref base, _) | ast::ExprAssignOp(_, ref base, _) => {\n+                self.check_str_index(&**base);\n             }\n-            ast::ExprAddrOf(ast::MutMutable, base) => {\n-                self.check_str_index(base);\n+            ast::ExprAddrOf(ast::MutMutable, ref base) => {\n+                self.check_str_index(&**base);\n             }\n             ast::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\")"}, {"sha": "86cd3c53804dee2618f572c58a4370fa8598010d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 95, "deletions": 92, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -25,6 +25,8 @@ use syntax::ast;\n use syntax::codemap::{Span};\n use util::ppaux::Repr;\n \n+use std::gc::Gc;\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n \n@@ -157,7 +159,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 ty::ReScope(body.id), // Args live only as long as the fn body.\n                 arg_ty);\n \n-            self.walk_pat(arg_cmt, arg.pat);\n+            self.walk_pat(arg_cmt, arg.pat.clone());\n         }\n     }\n \n@@ -173,9 +175,9 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &Vec<@ast::Expr>) {\n-        for &expr in exprs.iter() {\n-            self.consume_expr(expr);\n+    fn consume_exprs(&mut self, exprs: &Vec<Gc<ast::Expr>>) {\n+        for expr in exprs.iter() {\n+            self.consume_expr(&**expr);\n         }\n     }\n \n@@ -186,15 +188,15 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         self.delegate_consume(expr.id, expr.span, cmt);\n \n         match expr.node {\n-            ast::ExprParen(subexpr) => {\n+            ast::ExprParen(ref subexpr) => {\n                 // Argh but is ExprParen horrible. So, if we consume\n                 // `(x)`, that generally is also consuming `x`, UNLESS\n                 // there are adjustments on the `(x)` expression\n                 // (e.g., autoderefs and autorefs).\n                 if self.typer.adjustments().borrow().contains_key(&expr.id) {\n                     self.walk_expr(expr);\n                 } else {\n-                    self.consume_expr(subexpr);\n+                    self.consume_expr(&**subexpr);\n                 }\n             }\n \n@@ -240,59 +242,59 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            ast::ExprParen(subexpr) => {\n-                self.walk_expr(subexpr)\n+            ast::ExprParen(ref subexpr) => {\n+                self.walk_expr(&**subexpr)\n             }\n \n             ast::ExprPath(..) => { }\n \n-            ast::ExprUnary(ast::UnDeref, base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, base, []) {\n-                    self.select_from_expr(base);\n+            ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n+                if !self.walk_overloaded_operator(expr, &**base, []) {\n+                    self.select_from_expr(&**base);\n                 }\n             }\n \n-            ast::ExprField(base, _, _) => {         // base.f\n-                self.select_from_expr(base);\n+            ast::ExprField(ref base, _, _) => {         // base.f\n+                self.select_from_expr(&**base);\n             }\n \n-            ast::ExprIndex(lhs, rhs) => {           // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, lhs, [rhs]) {\n-                    self.select_from_expr(lhs);\n-                    self.consume_expr(rhs);\n+            ast::ExprIndex(ref lhs, ref rhs) => {           // lhs[rhs]\n+                if !self.walk_overloaded_operator(expr, &**lhs, [rhs.clone()]) {\n+                    self.select_from_expr(&**lhs);\n+                    self.consume_expr(&**rhs);\n                 }\n             }\n \n-            ast::ExprCall(callee, ref args) => {    // callee(args)\n-                self.walk_callee(expr, callee);\n+            ast::ExprCall(ref callee, ref args) => {    // callee(args)\n+                self.walk_callee(expr, &**callee);\n                 self.consume_exprs(args);\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => { // callee.m(args)\n                 self.consume_exprs(args);\n             }\n \n-            ast::ExprStruct(_, ref fields, opt_with) => {\n-                self.walk_struct_expr(expr, fields, opt_with);\n+            ast::ExprStruct(_, ref fields, ref opt_with) => {\n+                self.walk_struct_expr(expr, fields, opt_with.clone());\n             }\n \n             ast::ExprTup(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n-            ast::ExprIf(cond_expr, then_blk, opt_else_expr) => {\n-                self.consume_expr(cond_expr);\n-                self.walk_block(then_blk);\n+            ast::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n+                self.consume_expr(&**cond_expr);\n+                self.walk_block(&**then_blk);\n                 for else_expr in opt_else_expr.iter() {\n-                    self.consume_expr(*else_expr);\n+                    self.consume_expr(&**else_expr);\n                 }\n             }\n \n-            ast::ExprMatch(discr, ref arms) => {\n+            ast::ExprMatch(ref discr, ref arms) => {\n                 // treatment of the discriminant is handled while\n                 // walking the arms:\n-                self.walk_expr(discr);\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(discr));\n+                self.walk_expr(&**discr);\n+                let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n                 for arm in arms.iter() {\n                     self.walk_arm(discr_cmt.clone(), arm);\n                 }\n@@ -302,100 +304,100 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 self.consume_exprs(exprs);\n             }\n \n-            ast::ExprAddrOf(m, base) => {   // &base\n+            ast::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = ty::expr_ty(self.tcx(), expr);\n                 if !ty::type_is_bot(expr_ty) {\n                     let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n                     let bk = ty::BorrowKind::from_mutbl(m);\n-                    self.borrow_expr(base, r, bk, AddrOf);\n+                    self.borrow_expr(&**base, r, bk, AddrOf);\n                 } else {\n-                    self.walk_expr(base);\n+                    self.walk_expr(&**base);\n                 }\n             }\n \n             ast::ExprInlineAsm(ref ia) => {\n-                for &(_, input) in ia.inputs.iter() {\n-                    self.consume_expr(input);\n+                for &(_, ref input) in ia.inputs.iter() {\n+                    self.consume_expr(&**input);\n                 }\n \n-                for &(_, output) in ia.outputs.iter() {\n-                    self.mutate_expr(expr, output, JustWrite);\n+                for &(_, ref output) in ia.outputs.iter() {\n+                    self.mutate_expr(expr, &**output, JustWrite);\n                 }\n             }\n \n             ast::ExprBreak(..) |\n             ast::ExprAgain(..) |\n             ast::ExprLit(..) => {}\n \n-            ast::ExprLoop(blk, _) => {\n-                self.walk_block(blk);\n+            ast::ExprLoop(ref blk, _) => {\n+                self.walk_block(&**blk);\n             }\n \n-            ast::ExprWhile(cond_expr, blk) => {\n-                self.consume_expr(cond_expr);\n-                self.walk_block(blk);\n+            ast::ExprWhile(ref cond_expr, ref blk) => {\n+                self.consume_expr(&**cond_expr);\n+                self.walk_block(&**blk);\n             }\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n-            ast::ExprUnary(_, lhs) => {\n-                if !self.walk_overloaded_operator(expr, lhs, []) {\n-                    self.consume_expr(lhs);\n+            ast::ExprUnary(_, ref lhs) => {\n+                if !self.walk_overloaded_operator(expr, &**lhs, []) {\n+                    self.consume_expr(&**lhs);\n                 }\n             }\n \n-            ast::ExprBinary(_, lhs, rhs) => {\n-                if !self.walk_overloaded_operator(expr, lhs, [rhs]) {\n-                    self.consume_expr(lhs);\n-                    self.consume_expr(rhs);\n+            ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                if !self.walk_overloaded_operator(expr, &**lhs, [rhs.clone()]) {\n+                    self.consume_expr(&**lhs);\n+                    self.consume_expr(&**rhs);\n                 }\n             }\n \n-            ast::ExprBlock(blk) => {\n-                self.walk_block(blk);\n+            ast::ExprBlock(ref blk) => {\n+                self.walk_block(&**blk);\n             }\n \n             ast::ExprRet(ref opt_expr) => {\n                 for expr in opt_expr.iter() {\n-                    self.consume_expr(*expr);\n+                    self.consume_expr(&**expr);\n                 }\n             }\n \n-            ast::ExprAssign(lhs, rhs) => {\n-                self.mutate_expr(expr, lhs, JustWrite);\n-                self.consume_expr(rhs);\n+            ast::ExprAssign(ref lhs, ref rhs) => {\n+                self.mutate_expr(expr, &**lhs, JustWrite);\n+                self.consume_expr(&**rhs);\n             }\n \n-            ast::ExprCast(base, _) => {\n-                self.consume_expr(base);\n+            ast::ExprCast(ref base, _) => {\n+                self.consume_expr(&**base);\n             }\n \n-            ast::ExprAssignOp(_, lhs, rhs) => {\n+            ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n                 // This will have to change if/when we support\n                 // overloaded operators for `+=` and so forth.\n-                self.mutate_expr(expr, lhs, WriteAndRead);\n-                self.consume_expr(rhs);\n+                self.mutate_expr(expr, &**lhs, WriteAndRead);\n+                self.consume_expr(&**rhs);\n             }\n \n-            ast::ExprRepeat(base, count) => {\n-                self.consume_expr(base);\n-                self.consume_expr(count);\n+            ast::ExprRepeat(ref base, ref count) => {\n+                self.consume_expr(&**base);\n+                self.consume_expr(&**count);\n             }\n \n             ast::ExprFnBlock(..) |\n             ast::ExprProc(..) => {\n                 self.walk_captures(expr)\n             }\n \n-            ast::ExprVstore(base, _) => {\n-                self.consume_expr(base);\n+            ast::ExprVstore(ref base, _) => {\n+                self.consume_expr(&**base);\n             }\n \n-            ast::ExprBox(place, base) => {\n-                self.consume_expr(place);\n-                self.consume_expr(base);\n+            ast::ExprBox(ref place, ref base) => {\n+                self.consume_expr(&**place);\n+                self.consume_expr(&**base);\n             }\n \n             ast::ExprMac(..) => {\n@@ -448,10 +450,10 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n \n     fn walk_stmt(&mut self, stmt: &ast::Stmt) {\n         match stmt.node {\n-            ast::StmtDecl(decl, _) => {\n+            ast::StmtDecl(ref decl, _) => {\n                 match decl.node {\n-                    ast::DeclLocal(local) => {\n-                        self.walk_local(local);\n+                    ast::DeclLocal(ref local) => {\n+                        self.walk_local(local.clone());\n                     }\n \n                     ast::DeclItem(_) => {\n@@ -461,9 +463,9 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 }\n             }\n \n-            ast::StmtExpr(expr, _) |\n-            ast::StmtSemi(expr, _) => {\n-                self.consume_expr(expr);\n+            ast::StmtExpr(ref expr, _) |\n+            ast::StmtSemi(ref expr, _) => {\n+                self.consume_expr(&**expr);\n             }\n \n             ast::StmtMac(..) => {\n@@ -472,22 +474,23 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         }\n     }\n \n-    fn walk_local(&mut self, local: @ast::Local) {\n+    fn walk_local(&mut self, local: Gc<ast::Local>) {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.typer.tcx().def_map, local.pat, |_, id, span, _| {\n+                pat_util::pat_bindings(&self.typer.tcx().def_map, &*local.pat,\n+                                       |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n             }\n \n-            Some(expr) => {\n+            Some(ref expr) => {\n                 // Variable declarations with\n                 // initializers are considered\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n-                self.walk_expr(expr);\n-                let init_cmt = return_if_err!(self.mc.cat_expr(expr));\n+                self.walk_expr(&**expr);\n+                let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n                 self.walk_pat(init_cmt, local.pat);\n             }\n         }\n@@ -502,29 +505,29 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         debug!(\"walk_block(blk.id={:?})\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n-            self.walk_stmt(*stmt);\n+            self.walk_stmt(&**stmt);\n         }\n \n         for tail_expr in blk.expr.iter() {\n-            self.consume_expr(*tail_expr);\n+            self.consume_expr(&**tail_expr);\n         }\n     }\n \n     fn walk_struct_expr(&mut self,\n                         _expr: &ast::Expr,\n                         fields: &Vec<ast::Field>,\n-                        opt_with: Option<@ast::Expr>) {\n+                        opt_with: Option<Gc<ast::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields.iter() {\n-            self.consume_expr(field.expr);\n+            self.consume_expr(&*field.expr);\n         }\n \n         let with_expr = match opt_with {\n-            Some(w) => { w }\n+            Some(ref w) => { w.clone() }\n             None => { return; }\n         };\n \n-        let with_cmt = return_if_err!(self.mc.cat_expr(with_expr));\n+        let with_cmt = return_if_err!(self.mc.cat_expr(&*with_expr));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -542,7 +545,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         // Consume those fields of the with expression that are needed.\n         for with_field in with_fields.iter() {\n             if !contains_field_named(with_field, fields) {\n-                let cmt_field = self.mc.cat_field(with_expr,\n+                let cmt_field = self.mc.cat_field(&*with_expr,\n                                                   with_cmt.clone(),\n                                                   with_field.ident,\n                                                   with_field.mt.ty);\n@@ -673,7 +676,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,\n-                                args: &[@ast::Expr])\n+                                args: &[Gc<ast::Expr>])\n                                 -> bool\n     {\n         if !self.typer.is_method_call(expr.id) {\n@@ -689,8 +692,8 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         let r = ty::ReScope(expr.id);\n         let bk = ty::ImmBorrow;\n \n-        for &arg in args.iter() {\n-            self.borrow_expr(arg, r, bk, OverloadedOperator);\n+        for arg in args.iter() {\n+            self.borrow_expr(&**arg, r, bk, OverloadedOperator);\n         }\n         return true;\n     }\n@@ -701,21 +704,21 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         }\n \n         for guard in arm.guard.iter() {\n-            self.consume_expr(*guard);\n+            self.consume_expr(&**guard);\n         }\n \n-        self.consume_expr(arm.body);\n+        self.consume_expr(&*arm.body);\n     }\n \n-    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: @ast::Pat) {\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: Gc<ast::Pat>) {\n         debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         let mc = &self.mc;\n         let typer = self.typer;\n         let tcx = typer.tcx();\n         let def_map = &self.typer.tcx().def_map;\n         let delegate = &mut self.delegate;\n-        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n@@ -765,7 +768,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                         // matched.\n \n                         let (slice_cmt, slice_mutbl, slice_r) = {\n-                            match mc.cat_slice_pattern(cmt_pat, slice_pat) {\n+                            match mc.cat_slice_pattern(cmt_pat, &*slice_pat) {\n                                 Ok(v) => v,\n                                 Err(()) => {\n                                     tcx.sess.span_bug(slice_pat.span,"}, {"sha": "df6b20b62f590edf5b6b984a4e2b8b7cc2cb05ce", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -155,8 +155,8 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n fn check_item(cx: &mut Context, item: &Item) {\n     if !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\") {\n         match item.node {\n-            ItemImpl(_, Some(ref trait_ref), self_type, _) => {\n-                check_impl_of_trait(cx, item, trait_ref, self_type);\n+            ItemImpl(_, Some(ref trait_ref), ref self_type, _) => {\n+                check_impl_of_trait(cx, item, trait_ref, &**self_type);\n             }\n             _ => {}\n         }\n@@ -292,19 +292,19 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     }\n \n     match e.node {\n-        ExprUnary(UnBox, interior) => {\n-            let interior_type = ty::expr_ty(cx.tcx, interior);\n+        ExprUnary(UnBox, ref interior) => {\n+            let interior_type = ty::expr_ty(cx.tcx, &**interior);\n             let _ = check_static(cx.tcx, interior_type, interior.span);\n         }\n-        ExprCast(source, _) => {\n-            let source_ty = ty::expr_ty(cx.tcx, source);\n+        ExprCast(ref source, _) => {\n+            let source_ty = ty::expr_ty(cx.tcx, &**source);\n             let target_ty = ty::expr_ty(cx.tcx, e);\n             check_trait_cast(cx, source_ty, target_ty, source.span);\n         }\n-        ExprRepeat(element, count_expr) => {\n-            let count = ty::eval_repeat_count(cx.tcx, count_expr);\n+        ExprRepeat(ref element, ref count_expr) => {\n+            let count = ty::eval_repeat_count(cx.tcx, &**count_expr);\n             if count > 1 {\n-                let element_ty = ty::expr_ty(cx.tcx, element);\n+                let element_ty = ty::expr_ty(cx.tcx, &**element);\n                 check_copy(cx, element_ty, element.span,\n                            \"repeated element will be copied\");\n             }"}, {"sha": "7527477384a0d77b429aecd011dbfe4a49645834", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -57,6 +57,7 @@ use std::i32;\n use std::i64;\n use std::i8;\n use std::rc::Rc;\n+use std::gc::Gc;\n use std::to_str::ToStr;\n use std::u16;\n use std::u32;\n@@ -652,7 +653,7 @@ impl<'a> Context<'a> {\n /// Return true if that's the case. Otherwise return false.\n pub fn each_lint(sess: &session::Session,\n                  attrs: &[ast::Attribute],\n-                 f: |@ast::MetaItem, Level, InternedString| -> bool)\n+                 f: |Gc<ast::MetaItem>, Level, InternedString| -> bool)\n                  -> bool {\n     let xs = [Allow, Warn, Deny, Forbid];\n     for &level in xs.iter() {\n@@ -745,8 +746,8 @@ impl<'a> AstConv for Context<'a>{\n fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n     return match e.node {\n         ast::ExprCast(expr, ty) => {\n-            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n-            if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n+            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &*ty);\n+            if  ty::get(ty::expr_ty(cx.tcx, &*expr)).sty == ty::get(t_t).sty {\n                 cx.span_lint(UnnecessaryTypecast, ty.span,\n                              \"unnecessary type cast\");\n             }\n@@ -769,7 +770,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                     }\n                 },\n                 _ => {\n-                    let t = ty::expr_ty(cx.tcx, ex);\n+                    let t = ty::expr_ty(cx.tcx, &*ex);\n                     match ty::get(t).sty {\n                         ty::ty_uint(_) => {\n                             cx.span_lint(UnsignedNegate, e.span,\n@@ -781,7 +782,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n             }\n         },\n         ast::ExprBinary(binop, l, r) => {\n-            if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n+            if is_comparison(binop) && !check_limits(cx.tcx, binop, &*l, &*r) {\n                 cx.span_lint(TypeLimits, e.span,\n                              \"comparison is useless due to type limits\");\n             }\n@@ -950,24 +951,24 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n                     _ => ()\n                 }\n             }\n-            ast::TyPtr(ref mt) => { check_ty(cx, mt.ty) }\n+            ast::TyPtr(ref mt) => { check_ty(cx, &*mt.ty) }\n             _ => {}\n         }\n     }\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n         for input in decl.inputs.iter() {\n-            check_ty(cx, input.ty);\n+            check_ty(cx, &*input.ty);\n         }\n-        check_ty(cx, decl.output)\n+        check_ty(cx, &*decl.output)\n     }\n \n     match it.node {\n       ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n         for ni in nmod.items.iter() {\n             match ni.node {\n-                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, decl),\n-                ast::ForeignItemStatic(t, _) => check_ty(cx, t)\n+                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, &*decl),\n+                ast::ForeignItemStatic(t, _) => check_ty(cx, &*t)\n             }\n         }\n       }\n@@ -1082,7 +1083,7 @@ fn check_raw_ptr_deriving(cx: &mut Context, item: &ast::Item) {\n     match item.node {\n         ast::ItemStruct(..) | ast::ItemEnum(..) => {\n             let mut visitor = RawPtrDerivingVisitor { cx: cx };\n-            visit::walk_item(&mut visitor, item, ());\n+            visit::walk_item(&mut visitor, &*item, ());\n         }\n         _ => {}\n     }\n@@ -1184,7 +1185,7 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n         ast::StmtSemi(expr, _) => expr,\n         _ => return\n     };\n-    let t = ty::expr_ty(cx.tcx, expr);\n+    let t = ty::expr_ty(cx.tcx, &*expr);\n     match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n         _ => {}\n@@ -1194,7 +1195,7 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n         _ => {}\n     }\n \n-    let t = ty::expr_ty(cx.tcx, expr);\n+    let t = ty::expr_ty(cx.tcx, &*expr);\n     let mut warned = false;\n     match ty::get(t).sty {\n         ty::ty_struct(did, _) |\n@@ -1431,7 +1432,7 @@ fn check_unnecessary_parens_expr(cx: &Context, e: &ast::Expr) {\n         ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n         _ => return\n     };\n-    check_unnecessary_parens_core(cx, value, msg);\n+    check_unnecessary_parens_core(cx, &*value, msg);\n }\n \n fn check_unnecessary_parens_stmt(cx: &Context, s: &ast::Stmt) {\n@@ -1445,7 +1446,7 @@ fn check_unnecessary_parens_stmt(cx: &Context, s: &ast::Stmt) {\n         },\n         _ => return\n     };\n-    check_unnecessary_parens_core(cx, value, msg);\n+    check_unnecessary_parens_core(cx, &*value, msg);\n }\n \n fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n@@ -1472,12 +1473,12 @@ fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n     }\n }\n \n-fn check_unused_mut_pat(cx: &Context, pats: &[@ast::Pat]) {\n+fn check_unused_mut_pat(cx: &Context, pats: &[Gc<ast::Pat>]) {\n     // collect all mutable pattern and group their NodeIDs by their Identifier to\n     // avoid false warnings in match arms with multiple patterns\n     let mut mutables = HashMap::new();\n     for &p in pats.iter() {\n-        pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path| {\n+        pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path| {\n             match mode {\n                 ast::BindByValue(ast::MutMutable) => {\n                     if path.segments.len() != 1 {"}, {"sha": "69677554421d4ec24ef70df4e0cb8bf11afb6233", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 88, "deletions": 87, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -110,9 +110,10 @@ use middle::pat_util;\n use middle::ty;\n use util::nodemap::NodeMap;\n \n-use std::mem::transmute;\n use std::fmt;\n+use std::gc::Gc;\n use std::io;\n+use std::mem::transmute;\n use std::rc::Rc;\n use std::str;\n use std::uint;\n@@ -364,7 +365,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     for arg in decl.inputs.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n-                               arg.pat,\n+                               &*arg.pat,\n                                |_bm, arg_id, _x, path| {\n             debug!(\"adding argument {}\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n@@ -397,7 +398,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &Local) {\n-    pat_util::pat_bindings(&ir.tcx.def_map, local.pat, |_, p_id, sp, path| {\n+    pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -411,7 +412,7 @@ fn visit_local(ir: &mut IrMaps, local: &Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n-        pat_util::pat_bindings(&ir.tcx.def_map, *pat, |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n@@ -588,22 +589,22 @@ impl<'a> Liveness<'a> {\n     }\n \n     fn arm_pats_bindings(&mut self,\n-                         pats: &[@Pat],\n+                         pats: &[Gc<Pat>],\n                          f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoritative\" set of ids\n         if !pats.is_empty() {\n-            self.pat_bindings(pats[0], f)\n+            self.pat_bindings(&*pats[0], f)\n         }\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: @Pat, succ: LiveNode)\n+    fn define_bindings_in_pat(&mut self, pat: Gc<Pat>, succ: LiveNode)\n                               -> LiveNode {\n         self.define_bindings_in_arm_pats([pat], succ)\n     }\n \n-    fn define_bindings_in_arm_pats(&mut self, pats: &[@Pat], succ: LiveNode)\n+    fn define_bindings_in_arm_pats(&mut self, pats: &[Gc<Pat>], succ: LiveNode)\n                                    -> LiveNode {\n         let mut succ = succ;\n         self.arm_pats_bindings(pats, |this, ln, var, _sp, _id| {\n@@ -858,19 +859,19 @@ impl<'a> Liveness<'a> {\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr, succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n-            self.propagate_through_stmt(*stmt, succ)\n+            self.propagate_through_stmt(&**stmt, succ)\n         })\n     }\n \n     fn propagate_through_stmt(&mut self, stmt: &Stmt, succ: LiveNode)\n                               -> LiveNode {\n         match stmt.node {\n-            StmtDecl(decl, _) => {\n-                self.propagate_through_decl(decl, succ)\n+            StmtDecl(ref decl, _) => {\n+                self.propagate_through_decl(&**decl, succ)\n             }\n \n-            StmtExpr(expr, _) | StmtSemi(expr, _) => {\n-                self.propagate_through_expr(expr, succ)\n+            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n+                self.propagate_through_expr(&**expr, succ)\n             }\n \n             StmtMac(..) => {\n@@ -883,7 +884,7 @@ impl<'a> Liveness<'a> {\n                               -> LiveNode {\n         match decl.node {\n             DeclLocal(ref local) => {\n-                self.propagate_through_local(*local, succ)\n+                self.propagate_through_local(&**local, succ)\n             }\n             DeclItem(_) => succ,\n         }\n@@ -909,19 +910,19 @@ impl<'a> Liveness<'a> {\n         self.define_bindings_in_pat(local.pat, succ)\n     }\n \n-    fn propagate_through_exprs(&mut self, exprs: &[@Expr], succ: LiveNode)\n+    fn propagate_through_exprs(&mut self, exprs: &[Gc<Expr>], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {\n-            self.propagate_through_expr(*expr, succ)\n+            self.propagate_through_expr(&**expr, succ)\n         })\n     }\n \n     fn propagate_through_opt_expr(&mut self,\n-                                  opt_expr: Option<@Expr>,\n+                                  opt_expr: Option<Gc<Expr>>,\n                                   succ: LiveNode)\n                                   -> LiveNode {\n         opt_expr.iter().fold(succ, |succ, expr| {\n-            self.propagate_through_expr(*expr, succ)\n+            self.propagate_through_expr(&**expr, succ)\n         })\n     }\n \n@@ -936,11 +937,11 @@ impl<'a> Liveness<'a> {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          ExprField(e, _, _) => {\n-              self.propagate_through_expr(e, succ)\n+          ExprField(ref e, _, _) => {\n+              self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprFnBlock(_, blk) | ExprProc(_, blk) => {\n+          ExprFnBlock(_, ref blk) | ExprProc(_, ref blk) => {\n               debug!(\"{} is an ExprFnBlock or ExprProc\", expr_to_str(expr));\n \n               /*\n@@ -967,7 +968,7 @@ impl<'a> Liveness<'a> {\n               })\n           }\n \n-          ExprIf(cond, then, els) => {\n+          ExprIf(ref cond, ref then, ref els) => {\n             //\n             //     (cond)\n             //       |\n@@ -981,27 +982,27 @@ impl<'a> Liveness<'a> {\n             //    v     v\n             //   (  succ  )\n             //\n-            let else_ln = self.propagate_through_opt_expr(els, succ);\n-            let then_ln = self.propagate_through_block(then, succ);\n+            let else_ln = self.propagate_through_opt_expr(els.clone(), succ);\n+            let then_ln = self.propagate_through_block(&**then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);\n-            self.propagate_through_expr(cond, ln)\n+            self.propagate_through_expr(&**cond, ln)\n           }\n \n-          ExprWhile(cond, blk) => {\n-            self.propagate_through_loop(expr, Some(cond), blk, succ)\n+          ExprWhile(ref cond, ref blk) => {\n+            self.propagate_through_loop(expr, Some(cond.clone()), &**blk, succ)\n           }\n \n           ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          ExprLoop(blk, _) => {\n-            self.propagate_through_loop(expr, None, blk, succ)\n+          ExprLoop(ref blk, _) => {\n+            self.propagate_through_loop(expr, None, &**blk, succ)\n           }\n \n-          ExprMatch(e, ref arms) => {\n+          ExprMatch(ref e, ref arms) => {\n             //\n             //      (e)\n             //       |\n@@ -1021,7 +1022,7 @@ impl<'a> Liveness<'a> {\n             let mut first_merge = true;\n             for arm in arms.iter() {\n                 let body_succ =\n-                    self.propagate_through_expr(arm.body, succ);\n+                    self.propagate_through_expr(&*arm.body, succ);\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard, body_succ);\n                 let arm_succ =\n@@ -1030,7 +1031,7 @@ impl<'a> Liveness<'a> {\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n-            self.propagate_through_expr(e, ln)\n+            self.propagate_through_expr(&**e, ln)\n           }\n \n           ExprRet(o_e) => {\n@@ -1066,49 +1067,49 @@ impl<'a> Liveness<'a> {\n               }\n           }\n \n-          ExprAssign(l, r) => {\n+          ExprAssign(ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(l, succ, ACC_WRITE);\n-            let succ = self.propagate_through_lvalue_components(l, succ);\n-            self.propagate_through_expr(r, succ)\n+            let succ = self.write_lvalue(&**l, succ, ACC_WRITE);\n+            let succ = self.propagate_through_lvalue_components(&**l, succ);\n+            self.propagate_through_expr(&**r, succ)\n           }\n \n-          ExprAssignOp(_, l, r) => {\n+          ExprAssignOp(_, ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ);\n-            let succ = self.propagate_through_expr(r, succ);\n-            self.propagate_through_lvalue_components(l, succ)\n+            let succ = self.write_lvalue(&**l, succ, ACC_WRITE|ACC_READ);\n+            let succ = self.propagate_through_expr(&**r, succ);\n+            self.propagate_through_lvalue_components(&**l, succ)\n           }\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          ExprVstore(expr, _) => {\n-            self.propagate_through_expr(expr, succ)\n+          ExprVstore(ref expr, _) => {\n+            self.propagate_through_expr(&**expr, succ)\n           }\n \n           ExprVec(ref exprs) => {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n-          ExprRepeat(element, count) => {\n-            let succ = self.propagate_through_expr(count, succ);\n-            self.propagate_through_expr(element, succ)\n+          ExprRepeat(ref element, ref count) => {\n+            let succ = self.propagate_through_expr(&**count, succ);\n+            self.propagate_through_expr(&**element, succ)\n           }\n \n-          ExprStruct(_, ref fields, with_expr) => {\n-            let succ = self.propagate_through_opt_expr(with_expr, succ);\n+          ExprStruct(_, ref fields, ref with_expr) => {\n+            let succ = self.propagate_through_opt_expr(with_expr.clone(), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n-                self.propagate_through_expr(field.expr, succ)\n+                self.propagate_through_expr(&*field.expr, succ)\n             })\n           }\n \n-          ExprCall(f, ref args) => {\n+          ExprCall(ref f, ref args) => {\n             // calling a fn with bot return type means that the fn\n             // will fail, and hence the successors can be ignored\n             let is_bot = !self.ir.tcx.is_method_call(expr.id) && {\n-                let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, f));\n+                let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, &**f));\n                 ty::type_is_bot(t_ret)\n             };\n             let succ = if is_bot {\n@@ -1117,7 +1118,7 @@ impl<'a> Liveness<'a> {\n                 succ\n             };\n             let succ = self.propagate_through_exprs(args.as_slice(), succ);\n-            self.propagate_through_expr(f, succ)\n+            self.propagate_through_expr(&**f, succ)\n           }\n \n           ExprMethodCall(_, _, ref args) => {\n@@ -1133,48 +1134,48 @@ impl<'a> Liveness<'a> {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n-          ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n-            let r_succ = self.propagate_through_expr(r, succ);\n+          ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+            let r_succ = self.propagate_through_expr(&**r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, succ);\n             self.merge_from_succ(ln, r_succ, false);\n \n-            self.propagate_through_expr(l, ln)\n+            self.propagate_through_expr(&**l, ln)\n           }\n \n-          ExprIndex(l, r) |\n-          ExprBinary(_, l, r) |\n-          ExprBox(l, r) => {\n-            self.propagate_through_exprs([l, r], succ)\n+          ExprIndex(ref l, ref r) |\n+          ExprBinary(_, ref l, ref r) |\n+          ExprBox(ref l, ref r) => {\n+            self.propagate_through_exprs([l.clone(), r.clone()], succ)\n           }\n \n-          ExprAddrOf(_, e) |\n-          ExprCast(e, _) |\n-          ExprUnary(_, e) |\n-          ExprParen(e) => {\n-            self.propagate_through_expr(e, succ)\n+          ExprAddrOf(_, ref e) |\n+          ExprCast(ref e, _) |\n+          ExprUnary(_, ref e) |\n+          ExprParen(ref e) => {\n+            self.propagate_through_expr(&**e, succ)\n           }\n \n           ExprInlineAsm(ref ia) => {\n-            let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, expr)| {\n+            let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, ref expr)| {\n                 // see comment on lvalues in\n                 // propagate_through_lvalue_components()\n-                let succ = self.write_lvalue(expr, succ, ACC_WRITE);\n-                self.propagate_through_lvalue_components(expr, succ)\n+                let succ = self.write_lvalue(&**expr, succ, ACC_WRITE);\n+                self.propagate_through_lvalue_components(&**expr, succ)\n             });\n             // Inputs are executed first. Propagate last because of rev order\n-            ia.inputs.iter().rev().fold(succ, |succ, &(_, expr)| {\n-                self.propagate_through_expr(expr, succ)\n+            ia.inputs.iter().rev().fold(succ, |succ, &(_, ref expr)| {\n+                self.propagate_through_expr(&**expr, succ)\n             })\n           }\n \n           ExprLit(..) => {\n             succ\n           }\n \n-          ExprBlock(blk) => {\n-            self.propagate_through_block(blk, succ)\n+          ExprBlock(ref blk) => {\n+            self.propagate_through_block(&**blk, succ)\n           }\n \n           ExprMac(..) => {\n@@ -1238,7 +1239,7 @@ impl<'a> Liveness<'a> {\n \n         match expr.node {\n             ExprPath(_) => succ,\n-            ExprField(e, _, _) => self.propagate_through_expr(e, succ),\n+            ExprField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1276,7 +1277,7 @@ impl<'a> Liveness<'a> {\n \n     fn propagate_through_loop(&mut self,\n                               expr: &Expr,\n-                              cond: Option<@Expr>,\n+                              cond: Option<Gc<Expr>>,\n                               body: &Block,\n                               succ: LiveNode)\n                               -> LiveNode {\n@@ -1353,10 +1354,10 @@ impl<'a> Liveness<'a> {\n fn check_local(this: &mut Liveness, local: &Local) {\n     match local.init {\n         Some(_) => {\n-            this.warn_about_unused_or_dead_vars_in_pat(local.pat);\n+            this.warn_about_unused_or_dead_vars_in_pat(&*local.pat);\n         },\n         None => {\n-            this.pat_bindings(local.pat, |this, ln, var, sp, id| {\n+            this.pat_bindings(&*local.pat, |this, ln, var, sp, id| {\n                 this.warn_about_unused(sp, id, ln, var);\n             })\n         }\n@@ -1374,28 +1375,28 @@ fn check_arm(this: &mut Liveness, arm: &Arm) {\n \n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n-      ExprAssign(l, r) => {\n-        this.check_lvalue(l);\n-        this.visit_expr(r, ());\n+      ExprAssign(ref l, ref r) => {\n+        this.check_lvalue(&**l);\n+        this.visit_expr(&**r, ());\n \n         visit::walk_expr(this, expr, ());\n       }\n \n-      ExprAssignOp(_, l, _) => {\n-        this.check_lvalue(l);\n+      ExprAssignOp(_, ref l, _) => {\n+        this.check_lvalue(&**l);\n \n         visit::walk_expr(this, expr, ());\n       }\n \n       ExprInlineAsm(ref ia) => {\n-        for &(_, input) in ia.inputs.iter() {\n-          this.visit_expr(input, ());\n+        for &(_, ref input) in ia.inputs.iter() {\n+          this.visit_expr(&**input, ());\n         }\n \n         // Output operands must be lvalues\n-        for &(_, out) in ia.outputs.iter() {\n-          this.check_lvalue(out);\n-          this.visit_expr(out, ());\n+        for &(_, ref out) in ia.outputs.iter() {\n+          this.check_lvalue(&**out);\n+          this.visit_expr(&**out, ());\n         }\n \n         visit::walk_expr(this, expr, ());\n@@ -1448,8 +1449,8 @@ impl<'a> Liveness<'a> {\n                 let ends_with_stmt = match body.expr {\n                     None if body.stmts.len() > 0 =>\n                         match body.stmts.last().unwrap().node {\n-                            StmtSemi(e, _) => {\n-                                let t_stmt = ty::expr_ty(self.ir.tcx, e);\n+                            StmtSemi(ref e, _) => {\n+                                let t_stmt = ty::expr_ty(self.ir.tcx, &**e);\n                                 ty::get(t_stmt).sty == ty::get(t_ret).sty\n                             },\n                             _ => false\n@@ -1519,7 +1520,7 @@ impl<'a> Liveness<'a> {\n     fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n-                                   arg.pat,\n+                                   &*arg.pat,\n                                    |_bm, p_id, sp, path| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self."}, {"sha": "dd58f4855db9a755bb787ccc5248e1522aa586e3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -440,22 +440,22 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n         let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n-          ast::ExprUnary(ast::UnDeref, e_base) => {\n-            let base_cmt = if_ok!(self.cat_expr(e_base));\n+          ast::ExprUnary(ast::UnDeref, ref e_base) => {\n+            let base_cmt = if_ok!(self.cat_expr(&**e_base));\n             Ok(self.cat_deref(expr, base_cmt, 0))\n           }\n \n-          ast::ExprField(base, f_name, _) => {\n-            let base_cmt = if_ok!(self.cat_expr(base));\n+          ast::ExprField(ref base, f_name, _) => {\n+            let base_cmt = if_ok!(self.cat_expr(&**base));\n             Ok(self.cat_field(expr, base_cmt, f_name, expr_ty))\n           }\n \n-          ast::ExprIndex(base, _) => {\n+          ast::ExprIndex(ref base, _) => {\n             if self.typer.is_method_call(expr.id) {\n                 return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n             }\n \n-            let base_cmt = if_ok!(self.cat_expr(base));\n+            let base_cmt = if_ok!(self.cat_expr(&**base));\n             Ok(self.cat_index(expr, base_cmt, 0))\n           }\n \n@@ -464,8 +464,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n-          ast::ExprParen(e) => {\n-            self.cat_expr(e)\n+          ast::ExprParen(ref e) => {\n+            self.cat_expr(&**e)\n           }\n \n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n@@ -999,31 +999,32 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                         }\n                     };\n \n-                    for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n+                    for (i, subpat) in subpats.iter().enumerate() {\n+                        let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, downcast_cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n+                        if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&def::DefFn(..)) |\n                 Some(&def::DefStruct(..)) => {\n-                    for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n+                    for (i, subpat) in subpats.iter().enumerate() {\n+                        let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        if_ok!(self.cat_pattern(cmt_field, subpat, |x,y,z| op(x,y,z)));\n+                        if_ok!(self.cat_pattern(cmt_field, &**subpat,\n+                                                |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&def::DefStatic(..)) => {\n-                    for &subpat in subpats.iter() {\n-                        if_ok!(self.cat_pattern(cmt.clone(), subpat, |x,y,z| op(x,y,z)));\n+                    for subpat in subpats.iter() {\n+                        if_ok!(self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 _ => {\n@@ -1034,8 +1035,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             }\n           }\n \n-          ast::PatIdent(_, _, Some(subpat)) => {\n-              if_ok!(self.cat_pattern(cmt, subpat, op));\n+          ast::PatIdent(_, _, Some(ref subpat)) => {\n+              if_ok!(self.cat_pattern(cmt, &**subpat, op));\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -1045,42 +1046,43 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = if_ok!(self.pat_ty(fp.pat)); // see (*2)\n+                let field_ty = if_ok!(self.pat_ty(&*fp.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.ident, field_ty);\n-                if_ok!(self.cat_pattern(cmt_field, fp.pat, |x,y,z| op(x,y,z)));\n+                if_ok!(self.cat_pattern(cmt_field, &*fp.pat, |x,y,z| op(x,y,z)));\n             }\n           }\n \n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n-            for (i, &subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n+            for (i, subpat) in subpats.iter().enumerate() {\n+                let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n+                if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n             }\n           }\n \n-          ast::PatBox(subpat) | ast::PatRegion(subpat) => {\n+          ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n             // @p1, ~p1\n             let subcmt = self.cat_deref(pat, cmt, 0);\n-            if_ok!(self.cat_pattern(subcmt, subpat, op));\n+            if_ok!(self.cat_pattern(subcmt, &**subpat, op));\n           }\n \n           ast::PatVec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n-              for &before_pat in before.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt.clone(), before_pat, |x,y,z| op(x,y,z)));\n+              for before_pat in before.iter() {\n+                  if_ok!(self.cat_pattern(elt_cmt.clone(), &**before_pat,\n+                                          |x,y,z| op(x,y,z)));\n               }\n-              for &slice_pat in slice.iter() {\n-                  let slice_ty = if_ok!(self.pat_ty(slice_pat));\n+              for slice_pat in slice.iter() {\n+                  let slice_ty = if_ok!(self.pat_ty(&**slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  if_ok!(self.cat_pattern(slice_cmt, slice_pat, |x,y,z| op(x,y,z)));\n+                  if_ok!(self.cat_pattern(slice_cmt, &**slice_pat, |x,y,z| op(x,y,z)));\n               }\n-              for &after_pat in after.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt.clone(), after_pat, |x,y,z| op(x,y,z)));\n+              for after_pat in after.iter() {\n+                  if_ok!(self.cat_pattern(elt_cmt.clone(), &**after_pat, |x,y,z| op(x,y,z)));\n               }\n           }\n "}, {"sha": "9ff962158692bcc339475459c3fd0b53fcc436fa", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -12,6 +12,7 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n+use std::gc::Gc;\n use std::mem::replace;\n \n use metadata::csearch;\n@@ -797,8 +798,8 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n-            ast::ExprField(base, ident, _) => {\n-                match ty::get(ty::expr_ty_adjusted(self.tcx, base)).sty {\n+            ast::ExprField(ref base, ident, _) => {\n+                match ty::get(ty::expr_ty_adjusted(self.tcx, &**base)).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, NamedField(ident));\n                     }\n@@ -1134,7 +1135,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n         }\n-        let check_struct = |def: &@ast::StructDef| {\n+        let check_struct = |def: &Gc<ast::StructDef>| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n                     ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n@@ -1281,7 +1282,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(self_, ());\n+                    visitor.visit_ty(&*self_, ());\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n@@ -1318,7 +1319,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                     match *trait_ref {\n                         None => {\n                             for method in methods.iter() {\n-                                visit::walk_method_helper(self, *method, ())\n+                                visit::walk_method_helper(self, &**method, ())\n                             }\n                         }\n                         Some(ref tr) => {\n@@ -1345,7 +1346,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                         if method.explicit_self.node == ast::SelfStatic &&\n                             self.exported_items.contains(&method.id) {\n                             found_pub_static = true;\n-                            visit::walk_method_helper(self, *method, ());\n+                            visit::walk_method_helper(self, &**method, ());\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "d9b5dff3bb0ceb47328f724ec02ee3c03beb5739", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -70,7 +70,7 @@ fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n         {\n             match tcx.map.find(impl_src.node) {\n                 Some(ast_map::NodeItem(item)) => {\n-                    item_might_be_inlined(item)\n+                    item_might_be_inlined(&*item)\n                 }\n                 Some(..) | None => {\n                     tcx.sess.span_bug(method.span, \"impl did is not an item\")\n@@ -184,7 +184,7 @@ impl<'a> ReachableContext<'a> {\n         match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    ast::ItemFn(..) => item_might_be_inlined(item),\n+                    ast::ItemFn(..) => item_might_be_inlined(&*item),\n                     _ => false,\n                 }\n             }\n@@ -273,20 +273,20 @@ impl<'a> ReachableContext<'a> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    ast::ItemFn(_, _, _, _, search_block) => {\n-                        if item_might_be_inlined(item) {\n-                            visit::walk_block(self, search_block, ())\n+                    ast::ItemFn(_, _, _, _, ref search_block) => {\n+                        if item_might_be_inlined(&*item) {\n+                            visit::walk_block(self, &**search_block, ())\n                         }\n                     }\n \n                     // Statics with insignificant addresses are not reachable\n                     // because they're inlined specially into all other crates.\n-                    ast::ItemStatic(_, _, init) => {\n+                    ast::ItemStatic(_, _, ref init) => {\n                         if attr::contains_name(item.attrs.as_slice(),\n                                                \"address_insignificant\") {\n                             self.reachable_symbols.remove(&search_item);\n                         }\n-                        visit::walk_expr(self, init, ());\n+                        visit::walk_expr(self, &**init, ());\n                     }\n \n                     // These are normal, nothing reachable about these\n@@ -310,14 +310,14 @@ impl<'a> ReachableContext<'a> {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::Provided(ref method) => {\n-                        visit::walk_block(self, method.body, ())\n+                        visit::walk_block(self, &*method.body, ())\n                     }\n                 }\n             }\n             ast_map::NodeMethod(method) => {\n                 let did = self.tcx.map.get_parent_did(search_item);\n-                if method_might_be_inlined(self.tcx, method, did) {\n-                    visit::walk_block(self, method.body, ())\n+                if method_might_be_inlined(self.tcx, &*method, did) {\n+                    visit::walk_block(self, &*method.body, ())\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "3b59736e292b51c2b4681367cb1fa660b931906f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -28,6 +28,7 @@ use util::nodemap::NodeMap;\n \n use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n+use std::gc::Gc;\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::visit::{Visitor, FnKind};\n@@ -628,11 +629,11 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n     // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n     match local.init {\n-        Some(expr) => {\n-            record_rvalue_scope_if_borrow_expr(visitor, expr, blk_id);\n+        Some(ref expr) => {\n+            record_rvalue_scope_if_borrow_expr(visitor, &**expr, blk_id);\n \n-            if is_binding_pat(local.pat) || is_borrowed_ty(local.ty) {\n-                record_rvalue_scope(visitor, expr, blk_id);\n+            if is_binding_pat(&*local.pat) || is_borrowed_ty(&*local.ty) {\n+                record_rvalue_scope(visitor, &**expr, blk_id);\n             }\n         }\n \n@@ -657,22 +658,22 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n             ast::PatIdent(ast::BindByRef(_), _, _) => true,\n \n             ast::PatStruct(_, ref field_pats, _) => {\n-                field_pats.iter().any(|fp| is_binding_pat(fp.pat))\n+                field_pats.iter().any(|fp| is_binding_pat(&*fp.pat))\n             }\n \n             ast::PatVec(ref pats1, ref pats2, ref pats3) => {\n-                pats1.iter().any(|&p| is_binding_pat(p)) ||\n-                pats2.iter().any(|&p| is_binding_pat(p)) ||\n-                pats3.iter().any(|&p| is_binding_pat(p))\n+                pats1.iter().any(|p| is_binding_pat(&**p)) ||\n+                pats2.iter().any(|p| is_binding_pat(&**p)) ||\n+                pats3.iter().any(|p| is_binding_pat(&**p))\n             }\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n-                subpats.iter().any(|&p| is_binding_pat(p))\n+                subpats.iter().any(|p| is_binding_pat(&**p))\n             }\n \n-            ast::PatBox(subpat) => {\n-                is_binding_pat(subpat)\n+            ast::PatBox(ref subpat) => {\n+                is_binding_pat(&**subpat)\n             }\n \n             _ => false,\n@@ -709,39 +710,39 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n          */\n \n         match expr.node {\n-            ast::ExprAddrOf(_, subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n-                record_rvalue_scope(visitor, subexpr, blk_id);\n+            ast::ExprAddrOf(_, ref subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n+                record_rvalue_scope(visitor, &**subexpr, blk_id);\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n                 for field in fields.iter() {\n                     record_rvalue_scope_if_borrow_expr(\n-                        visitor, field.expr, blk_id);\n+                        visitor, &*field.expr, blk_id);\n                 }\n             }\n-            ast::ExprVstore(subexpr, _) => {\n+            ast::ExprVstore(ref subexpr, _) => {\n                 visitor.region_maps.record_rvalue_scope(subexpr.id, blk_id);\n-                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n+                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n             }\n             ast::ExprVec(ref subexprs) |\n             ast::ExprTup(ref subexprs) => {\n-                for &subexpr in subexprs.iter() {\n+                for subexpr in subexprs.iter() {\n                     record_rvalue_scope_if_borrow_expr(\n-                        visitor, subexpr, blk_id);\n+                        visitor, &**subexpr, blk_id);\n                 }\n             }\n-            ast::ExprUnary(ast::UnUniq, subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n+            ast::ExprUnary(ast::UnUniq, ref subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n             }\n-            ast::ExprCast(subexpr, _) |\n-            ast::ExprParen(subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id)\n+            ast::ExprCast(ref subexpr, _) |\n+            ast::ExprParen(ref subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id)\n             }\n             ast::ExprBlock(ref block) => {\n                 match block.expr {\n-                    Some(subexpr) => {\n+                    Some(ref subexpr) => {\n                         record_rvalue_scope_if_borrow_expr(\n-                            visitor, subexpr, blk_id);\n+                            visitor, &**subexpr, blk_id);\n                     }\n                     None => { }\n                 }\n@@ -789,7 +790,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n                 ast::ExprField(ref subexpr, _, _) |\n                 ast::ExprIndex(ref subexpr, _) |\n                 ast::ExprParen(ref subexpr) => {\n-                    let subexpr: &'a @Expr = subexpr; // FIXME(#11586)\n+                    let subexpr: &'a Gc<Expr> = subexpr; // FIXME(#11586)\n                     expr = &**subexpr;\n                 }\n                 _ => {"}, {"sha": "759d2ebb624226f0e7e09e10f3dd1e91270e7d6b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -34,9 +34,9 @@ use syntax::visit::Visitor;\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n+use std::gc::Gc;\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n-use std::string::String;\n use std::uint;\n \n // Definition mapping\n@@ -1195,9 +1195,9 @@ impl<'a> Resolver<'a> {\n                 name_bindings.define_type\n                     (DefTy(local_def(item.id)), sp, is_public);\n \n-                for &variant in (*enum_definition).variants.iter() {\n+                for variant in (*enum_definition).variants.iter() {\n                     self.build_reduced_graph_for_variant(\n-                        variant,\n+                        &**variant,\n                         local_def(item.id),\n                         parent.clone(),\n                         is_public);\n@@ -3430,7 +3430,7 @@ impl<'a> Resolver<'a> {\n                 FunctionRibKind(function_id, body_id) => {\n                     if !is_ty_param {\n                         def = DefUpvar(def.def_id().node,\n-                                       @def,\n+                                       box(GC) def,\n                                        function_id,\n                                        body_id);\n                     }\n@@ -3565,7 +3565,7 @@ impl<'a> Resolver<'a> {\n                         // resolve the discriminator expr\n                         // as a constant\n                         self.with_constant_rib(|this| {\n-                            this.resolve_expr(*dis_expr);\n+                            this.resolve_expr(&**dis_expr);\n                         });\n                     }\n                 }\n@@ -3593,13 +3593,13 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemImpl(ref generics,\n-                      ref implemented_traits,\n-                      self_type,\n-                      ref methods) => {\n+                     ref implemented_traits,\n+                     ref self_type,\n+                     ref methods) => {\n                 self.resolve_implementation(item.id,\n                                             generics,\n                                             implemented_traits,\n-                                            self_type,\n+                                            &**self_type,\n                                             methods.as_slice());\n             }\n \n@@ -3647,16 +3647,16 @@ impl<'a> Resolver<'a> {\n                                     &ty_m.generics.ty_params);\n \n                                 for argument in ty_m.decl.inputs.iter() {\n-                                    this.resolve_type(argument.ty);\n+                                    this.resolve_type(&*argument.ty);\n                                 }\n \n-                                this.resolve_type(ty_m.decl.output);\n+                                this.resolve_type(&*ty_m.decl.output);\n                             });\n                           }\n-                          ast::Provided(m) => {\n+                          ast::Provided(ref m) => {\n                               this.resolve_method(MethodRibKind(item.id,\n                                                      Provided(m.id)),\n-                                                  m,\n+                                                  &**m,\n                                                   generics.ty_params.len())\n                           }\n                         }\n@@ -3690,12 +3690,12 @@ impl<'a> Resolver<'a> {\n                                         generics, foreign_item.id, 0,\n                                         ItemRibKind),\n                                     |this| visit::walk_foreign_item(this,\n-                                                                *foreign_item,\n+                                                                &**foreign_item,\n                                                                 ()));\n                             }\n                             ForeignItemStatic(..) => {\n                                 visit::walk_foreign_item(this,\n-                                                         *foreign_item,\n+                                                         &**foreign_item,\n                                                          ());\n                             }\n                         }\n@@ -3812,21 +3812,21 @@ impl<'a> Resolver<'a> {\n                 }\n                 Some(declaration) => {\n                     for argument in declaration.inputs.iter() {\n-                        this.resolve_pattern(argument.pat,\n+                        this.resolve_pattern(&*argument.pat,\n                                              ArgumentIrrefutableMode,\n                                              None);\n \n-                        this.resolve_type(argument.ty);\n+                        this.resolve_type(&*argument.ty);\n \n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    this.resolve_type(declaration.output);\n+                    this.resolve_type(&*declaration.output);\n                 }\n             }\n \n             // Resolve the function body.\n-            this.resolve_block(block);\n+            this.resolve_block(&*block);\n \n             debug!(\"(resolving function) leaving function\");\n         });\n@@ -3842,7 +3842,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_type_parameter_bound(type_parameter.id, bound);\n             }\n             match type_parameter.default {\n-                Some(ty) => self.resolve_type(ty),\n+                Some(ref ty) => self.resolve_type(&**ty),\n                 None => {}\n             }\n         }\n@@ -3857,10 +3857,10 @@ impl<'a> Resolver<'a> {\n             }\n             UnboxedFnTyParamBound(ref unboxed_function) => {\n                 for argument in unboxed_function.decl.inputs.iter() {\n-                    self.resolve_type(argument.ty);\n+                    self.resolve_type(&*argument.ty);\n                 }\n \n-                self.resolve_type(unboxed_function.decl.output);\n+                self.resolve_type(&*unboxed_function.decl.output);\n             }\n             StaticRegionTyParamBound | OtherRegionTyParamBound(_) => {}\n         }\n@@ -3938,7 +3938,7 @@ impl<'a> Resolver<'a> {\n \n             // Resolve fields.\n             for field in fields.iter() {\n-                this.resolve_type(field.node.ty);\n+                this.resolve_type(&*field.node.ty);\n             }\n         });\n     }\n@@ -3995,7 +3995,7 @@ impl<'a> Resolver<'a> {\n                                   generics: &Generics,\n                                   opt_trait_reference: &Option<TraitRef>,\n                                   self_type: &Ty,\n-                                  methods: &[@Method]) {\n+                                  methods: &[Gc<Method>]) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = generics.ty_params.len();\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -4015,7 +4015,7 @@ impl<'a> Resolver<'a> {\n                     for method in methods.iter() {\n                         // We also need a new scope for the method-specific type parameters.\n                         this.resolve_method(MethodRibKind(id, Provided(method.id)),\n-                                            *method,\n+                                            &**method,\n                                             outer_type_parameter_count);\n                     }\n                 });\n@@ -4032,20 +4032,20 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_local(&mut self, local: &Local) {\n         // Resolve the type.\n-        self.resolve_type(local.ty);\n+        self.resolve_type(&*local.ty);\n \n         // Resolve the initializer, if necessary.\n         match local.init {\n             None => {\n                 // Nothing to do.\n             }\n-            Some(initializer) => {\n-                self.resolve_expr(initializer);\n+            Some(ref initializer) => {\n+                self.resolve_expr(&**initializer);\n             }\n         }\n \n         // Resolve the pattern.\n-        self.resolve_pattern(local.pat, LocalIrrefutableMode, None);\n+        self.resolve_pattern(&*local.pat, LocalIrrefutableMode, None);\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -4069,9 +4069,9 @@ impl<'a> Resolver<'a> {\n         if arm.pats.len() == 0 {\n             return\n         }\n-        let map_0 = self.binding_mode_map(*arm.pats.get(0));\n+        let map_0 = self.binding_mode_map(&**arm.pats.get(0));\n         for (i, p) in arm.pats.iter().enumerate() {\n-            let map_i = self.binding_mode_map(*p);\n+            let map_i = self.binding_mode_map(&**p);\n \n             for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n@@ -4114,7 +4114,7 @@ impl<'a> Resolver<'a> {\n \n         let mut bindings_list = HashMap::new();\n         for pattern in arm.pats.iter() {\n-            self.resolve_pattern(*pattern,\n+            self.resolve_pattern(&**pattern,\n                                  RefutableMode,\n                                  Some(&mut bindings_list));\n         }\n@@ -4124,7 +4124,7 @@ impl<'a> Resolver<'a> {\n         self.check_consistent_bindings(arm);\n \n         visit::walk_expr_opt(self, arm.guard, ());\n-        self.resolve_expr(arm.body);\n+        self.resolve_expr(&*arm.body);\n \n         self.value_ribs.borrow_mut().pop();\n     }\n@@ -4392,10 +4392,10 @@ impl<'a> Resolver<'a> {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for &ty in path.segments\n+                    for ty in path.segments\n                                   .iter()\n                                   .flat_map(|seg| seg.types.iter()) {\n-                        self.resolve_type(ty);\n+                        self.resolve_type(&**ty);\n                     }\n                 }\n \n@@ -4430,10 +4430,10 @@ impl<'a> Resolver<'a> {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for &ty in path.segments\n+                    for ty in path.segments\n                                   .iter()\n                                   .flat_map(|s| s.types.iter()) {\n-                        self.resolve_type(ty);\n+                        self.resolve_type(&**ty);\n                     }\n                 }\n \n@@ -4467,20 +4467,20 @@ impl<'a> Resolver<'a> {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for &ty in path.segments\n+                    for ty in path.segments\n                                   .iter()\n                                   .flat_map(|s| s.types.iter()) {\n-                        self.resolve_type(ty);\n+                        self.resolve_type(&**ty);\n                     }\n                 }\n \n-                PatLit(expr) => {\n-                    self.resolve_expr(expr);\n+                PatLit(ref expr) => {\n+                    self.resolve_expr(&**expr);\n                 }\n \n-                PatRange(first_expr, last_expr) => {\n-                    self.resolve_expr(first_expr);\n-                    self.resolve_expr(last_expr);\n+                PatRange(ref first_expr, ref last_expr) => {\n+                    self.resolve_expr(&**first_expr);\n+                    self.resolve_expr(&**last_expr);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n@@ -4571,8 +4571,8 @@ impl<'a> Resolver<'a> {\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n         // First, resolve the types.\n-        for &ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n-            self.resolve_type(ty);\n+        for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n+            self.resolve_type(&**ty);\n         }\n \n         if path.global {\n@@ -4919,8 +4919,8 @@ impl<'a> Resolver<'a> {\n                                                     -> Option<(Path, NodeId, FallbackChecks)> {\n             match t.node {\n                 TyPath(ref path, _, node_id) => Some((path.clone(), node_id, allow)),\n-                TyPtr(mut_ty) => extract_path_and_node_id(mut_ty.ty, OnlyTraitAndStatics),\n-                TyRptr(_, mut_ty) => extract_path_and_node_id(mut_ty.ty, allow),\n+                TyPtr(mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n+                TyRptr(_, mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future."}, {"sha": "4c4b0a1290c4731bf68e6fb79276e5587eb4550e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -226,6 +226,7 @@ use util::ppaux::{Repr, vec_map_to_str};\n use std::collections::HashMap;\n use std::cell::Cell;\n use std::rc::Rc;\n+use std::gc::Gc;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n@@ -237,7 +238,7 @@ use syntax::parse::token::InternedString;\n // expression.\n enum Lit {\n     UnitLikeStructLit(ast::NodeId),    // the node ID of the pattern\n-    ExprLit(@ast::Expr),\n+    ExprLit(Gc<ast::Expr>),\n     ConstLit(ast::DefId),              // the def ID of the constant\n }\n \n@@ -252,11 +253,11 @@ pub enum VecLenOpt {\n enum Opt {\n     lit(Lit),\n     var(ty::Disr, Rc<adt::Repr>),\n-    range(@ast::Expr, @ast::Expr),\n+    range(Gc<ast::Expr>, Gc<ast::Expr>),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n-fn lit_to_expr(tcx: &ty::ctxt, a: &Lit) -> @ast::Expr {\n+fn lit_to_expr(tcx: &ty::ctxt, a: &Lit) -> Gc<ast::Expr> {\n     match *a {\n         ExprLit(existing_a_expr) => existing_a_expr,\n         ConstLit(a_const) => const_eval::lookup_const_by_id(tcx, a_const).unwrap(),\n@@ -270,14 +271,14 @@ fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n         (&lit(a), &lit(b)) => {\n             let a_expr = lit_to_expr(tcx, &a);\n             let b_expr = lit_to_expr(tcx, &b);\n-            match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n+            match const_eval::compare_lit_exprs(tcx, &*a_expr, &*b_expr) {\n                 Some(val1) => val1 == 0,\n                 None => fail!(\"compare_list_exprs: type mismatch\"),\n             }\n         }\n-        (&range(a1, a2), &range(b1, b2)) => {\n-            let m1 = const_eval::compare_lit_exprs(tcx, a1, b1);\n-            let m2 = const_eval::compare_lit_exprs(tcx, a2, b2);\n+        (&range(ref a1, ref a2), &range(ref b1, ref b2)) => {\n+            let m1 = const_eval::compare_lit_exprs(tcx, &**a1, &**b1);\n+            let m2 = const_eval::compare_lit_exprs(tcx, &**a2, &**b2);\n             match (m1, m2) {\n                 (Some(val1), Some(val2)) => (val1 == 0 && val2 == 0),\n                 _ => fail!(\"compare_list_exprs: type mismatch\"),\n@@ -301,8 +302,8 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     match *o {\n-        lit(ExprLit(lit_expr)) => {\n-            let lit_datum = unpack_datum!(bcx, expr::trans(bcx, lit_expr));\n+        lit(ExprLit(ref lit_expr)) => {\n+            let lit_datum = unpack_datum!(bcx, expr::trans(bcx, &**lit_expr));\n             let lit_datum = lit_datum.assert_rvalue(bcx); // literals are rvalues\n             let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n             return single_result(Result::new(bcx, lit_datum.val));\n@@ -322,9 +323,9 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n         var(disr_val, ref repr) => {\n             return adt::trans_case(bcx, &**repr, disr_val);\n         }\n-        range(l1, l2) => {\n-            let (l1, _) = consts::const_expr(ccx, l1, true);\n-            let (l2, _) = consts::const_expr(ccx, l2, true);\n+        range(ref l1, ref l2) => {\n+            let (l1, _) = consts::const_expr(ccx, &**l1, true);\n+            let (l2, _) = consts::const_expr(ccx, &**l2, true);\n             return range_result(Result::new(bcx, l1), Result::new(bcx, l2));\n         }\n         vec_len(n, vec_len_eq, _) => {\n@@ -398,7 +399,7 @@ struct ArmData<'a, 'b> {\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n struct Match<'a, 'b> {\n-    pats: Vec<@ast::Pat>,\n+    pats: Vec<Gc<ast::Pat>>,\n     data: &'a ArmData<'a, 'b>,\n     bound_ptrs: Vec<(Ident, ValueRef)>\n }\n@@ -461,16 +462,16 @@ fn expand_nested_bindings<'a, 'b>(\n     }).collect()\n }\n \n-fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n-    if !pat_is_binding_or_wild(&bcx.tcx().def_map, p) {\n+fn assert_is_binding_or_wild(bcx: &Block, p: Gc<ast::Pat>) {\n+    if !pat_is_binding_or_wild(&bcx.tcx().def_map, &*p) {\n         bcx.sess().span_bug(\n             p.span,\n             format!(\"expected an identifier pattern but found p: {}\",\n                     p.repr(bcx.tcx())).as_slice());\n     }\n }\n \n-type enter_pat<'a> = |@ast::Pat|: 'a -> Option<Vec<@ast::Pat>>;\n+type enter_pat<'a> = |Gc<ast::Pat>|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n \n fn enter_match<'a, 'b>(\n                bcx: &'b Block<'b>,\n@@ -496,7 +497,7 @@ fn enter_match<'a, 'b>(\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n                 ast::PatIdent(_, ref path, None) => {\n-                    if pat_is_binding(dm, this) {\n+                    if pat_is_binding(dm, &*this) {\n                         bound_ptrs.push((path_to_ident(path), val));\n                     }\n                 }\n@@ -531,7 +532,7 @@ fn enter_default<'a, 'b>(\n     let matches = enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n           ast::PatWild | ast::PatWildMulti => Some(Vec::new()),\n-          ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(Vec::new()),\n+          ast::PatIdent(_, _, None) if pat_is_binding(dm, &*p) => Some(Vec::new()),\n           _ => None\n         }\n     });\n@@ -600,12 +601,12 @@ fn enter_opt<'a, 'b>(\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     let mut i = 0;\n     enter_match(bcx, &tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(..) |\n-            ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, p) => {\n+            ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, &*p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n                 let const_def_id = const_def.def_id();\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n@@ -628,7 +629,7 @@ fn enter_opt<'a, 'b>(\n                 }\n             }\n             ast::PatIdent(_, _, None)\n-                    if pat_is_variant_or_struct(&tcx.def_map, p) => {\n+                    if pat_is_variant_or_struct(&tcx.def_map, &*p) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(Vec::new())\n                 } else {\n@@ -739,7 +740,7 @@ fn enter_rec_or_struct<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatStruct(_, ref fpats, _) => {\n@@ -775,7 +776,7 @@ fn enter_tup<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatTup(ref elts) => {\n@@ -808,7 +809,7 @@ fn enter_tuple_struct<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatEnum(_, Some(ref elts)) => {\n@@ -839,7 +840,7 @@ fn enter_uniq<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n+    let dummy = box(GC) ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatBox(sub) => {\n@@ -867,7 +868,7 @@ fn enter_region<'a, 'b>(\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat { id: 0, node: ast::PatWild, span: DUMMY_SP };\n+    let dummy = box(GC) ast::Pat { id: 0, node: ast::PatWild, span: DUMMY_SP };\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatRegion(sub) => {\n@@ -1194,14 +1195,14 @@ fn pick_col(m: &[Match]) -> uint {\n     fn score(p: &ast::Pat) -> uint {\n         match p.node {\n           ast::PatLit(_) | ast::PatEnum(_, _) | ast::PatRange(_, _) => 1u,\n-          ast::PatIdent(_, _, Some(p)) => score(p),\n+          ast::PatIdent(_, _, Some(ref p)) => score(&**p),\n           _ => 0u\n         }\n     }\n     let mut scores = Vec::from_elem(m[0].pats.len(), 0u);\n     for br in m.iter() {\n-        for (i, p) in br.pats.iter().enumerate() {\n-            *scores.get_mut(i) += score(*p);\n+        for (i, ref p) in br.pats.iter().enumerate() {\n+            *scores.get_mut(i) += score(&***p);\n         }\n     }\n     let mut max_score = 0u;\n@@ -1454,9 +1455,9 @@ fn compile_submatch<'a, 'b>(\n             Store(bcx, *value_ptr, llmatch);\n         }\n         match data.arm.guard {\n-            Some(guard_expr) => {\n+            Some(ref guard_expr) => {\n                 bcx = compile_guard(bcx,\n-                                    guard_expr,\n+                                    &**guard_expr,\n                                     m[0].data,\n                                     m.slice(1, m.len()),\n                                     vals,\n@@ -1841,15 +1842,15 @@ pub fn trans_match<'a>(\n     trans_match_inner(bcx, match_expr.id, discr_expr, arms, dest)\n }\n \n-fn create_bindings_map(bcx: &Block, pat: @ast::Pat) -> BindingsMap {\n+fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n     // from the various alternatives.\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    pat_bindings(&tcx.def_map, pat, |bm, p_id, span, path| {\n+    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path| {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1966,7 +1967,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         let cleanup_scope = fcx.push_custom_cleanup_scope();\n         bcx = insert_lllocals(bcx, &arm_data.bindings_map,\n                               cleanup::CustomScope(cleanup_scope));\n-        bcx = expr::trans_into(bcx, arm_data.arm.body, dest);\n+        bcx = expr::trans_into(bcx, &*arm_data.arm.body, dest);\n         bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         arm_cxs.push(bcx);\n     }\n@@ -2007,12 +2008,12 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n             //\n             // In such cases, the more general path is unsafe, because\n             // it assumes it is matching against a valid value.\n-            match simple_identifier(pat) {\n+            match simple_identifier(&*pat) {\n                 Some(path) => {\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n                         bcx, pat.id, path, BindLocal, var_scope, (),\n-                        |(), bcx, v, _| expr::trans_into(bcx, init_expr,\n+                        |(), bcx, v, _| expr::trans_into(bcx, &*init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n \n@@ -2021,8 +2022,8 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n \n             // General path.\n             let init_datum =\n-                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, init_expr, \"let\"));\n-            if ty::type_is_bot(expr_ty(bcx, init_expr)) {\n+                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &*init_expr, \"let\"));\n+            if ty::type_is_bot(expr_ty(bcx, &*init_expr)) {\n                 create_dummy_locals(bcx, pat)\n             } else {\n                 if bcx.sess().asm_comments() {\n@@ -2038,12 +2039,12 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n     };\n \n     fn create_dummy_locals<'a>(mut bcx: &'a Block<'a>,\n-                               pat: @ast::Pat)\n+                               pat: Gc<ast::Pat>)\n                                -> &'a Block<'a> {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        pat_bindings(&tcx.def_map, pat, |_, p_id, _, path| {\n+        pat_bindings(&tcx.def_map, &*pat, |_, p_id, _, path| {\n                 let scope = cleanup::var_scope(tcx, p_id);\n                 bcx = mk_binding_alloca(\n                     bcx, p_id, path, BindLocal, scope, (),\n@@ -2054,7 +2055,7 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n }\n \n pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n-                     pat: @ast::Pat,\n+                     pat: Gc<ast::Pat>,\n                      arg: Datum<Rvalue>,\n                      arg_scope: cleanup::ScopeId)\n                      -> &'a Block<'a> {\n@@ -2073,7 +2074,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n \n     let _icx = push_ctxt(\"match::store_arg\");\n \n-    match simple_identifier(pat) {\n+    match simple_identifier(&*pat) {\n         Some(path) => {\n             // Generate nicer LLVM for the common case of fn a pattern\n             // like `x: T`\n@@ -2137,7 +2138,7 @@ fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n \n fn bind_irrefutable_pat<'a>(\n                         bcx: &'a Block<'a>,\n-                        pat: @ast::Pat,\n+                        pat: Gc<ast::Pat>,\n                         val: ValueRef,\n                         binding_mode: IrrefutablePatternBindingMode,\n                         cleanup_scope: cleanup::ScopeId)\n@@ -2176,7 +2177,7 @@ fn bind_irrefutable_pat<'a>(\n     let ccx = bcx.ccx();\n     match pat.node {\n         ast::PatIdent(pat_binding_mode, ref path, inner) => {\n-            if pat_is_binding(&tcx.def_map, pat) {\n+            if pat_is_binding(&tcx.def_map, &*pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map."}, {"sha": "871b75760f1d020377321bacc460e235aa5698f9", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -37,23 +37,23 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     let temp_scope = fcx.push_custom_cleanup_scope();\n \n     // Prepare the output operands\n-    let outputs = ia.outputs.iter().map(|&(ref c, out)| {\n+    let outputs = ia.outputs.iter().map(|&(ref c, ref out)| {\n         constraints.push((*c).clone());\n \n-        let out_datum = unpack_datum!(bcx, expr::trans(bcx, out));\n+        let out_datum = unpack_datum!(bcx, expr::trans(bcx, &**out));\n         output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n         out_datum.val\n \n     }).collect::<Vec<_>>();\n \n     // Now the input operands\n-    let inputs = ia.inputs.iter().map(|&(ref c, input)| {\n+    let inputs = ia.inputs.iter().map(|&(ref c, ref input)| {\n         constraints.push((*c).clone());\n \n-        let in_datum = unpack_datum!(bcx, expr::trans(bcx, input));\n+        let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n         unpack_result!(bcx, {\n             callee::trans_arg_datum(bcx,\n-                                   expr_ty(bcx, input),\n+                                   expr_ty(bcx, &**input),\n                                    in_datum,\n                                    cleanup::CustomScope(temp_scope),\n                                    callee::DontAutorefArg)"}, {"sha": "3d5f0168743821d6a33ad5990488b1b450308a69", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -81,6 +81,7 @@ use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n+use std::gc::Gc;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n@@ -977,8 +978,8 @@ pub fn init_local<'a>(bcx: &'a Block<'a>, local: &ast::Local)\n     if ignore_lhs(bcx, local) {\n         // Handle let _ = e; just like e;\n         match local.init {\n-            Some(init) => {\n-                return controlflow::trans_stmt_semi(bcx, init)\n+            Some(ref init) => {\n+                return controlflow::trans_stmt_semi(bcx, &**init)\n             }\n             None => { return bcx; }\n         }\n@@ -1537,14 +1538,14 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n                   sp: Span, id: ast::NodeId, vi: &[Rc<ty::VariantInfo>],\n                   i: &mut uint) {\n-    for &variant in enum_definition.variants.iter() {\n+    for variant in enum_definition.variants.iter() {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n         match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, variant, args.as_slice(),\n+                trans_enum_variant(ccx, id, &**variant, args.as_slice(),\n                                    disr_val, &param_substs::empty(), llfn);\n             }\n             ast::TupleVariantKind(_) => {\n@@ -1621,16 +1622,16 @@ impl<'a> Visitor<()> for TransItemVisitor<'a> {\n pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     match item.node {\n-      ast::ItemFn(decl, _fn_style, abi, ref generics, body) => {\n+      ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if abi != Rust  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n-                ccx, decl, body, item.attrs.as_slice(), llfndecl, item.id);\n+                ccx, &**decl, &**body, item.attrs.as_slice(), llfndecl, item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfn = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n-                     decl,\n-                     body,\n+                     &**decl,\n+                     &**body,\n                      llfn,\n                      &param_substs::empty(),\n                      item.id,\n@@ -1639,7 +1640,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n             // Be sure to travel more than just one layer deep to catch nested\n             // items in blocks and such.\n             let mut v = TransItemVisitor{ ccx: ccx };\n-            v.visit_block(body, ());\n+            v.visit_block(&**body, ());\n         }\n       }\n       ast::ItemImpl(ref generics, _, _, ref ms) => {\n@@ -1655,10 +1656,10 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n             trans_enum_def(ccx, enum_definition, item.span, item.id, vi.as_slice(), &mut i);\n         }\n       }\n-      ast::ItemStatic(_, m, expr) => {\n+      ast::ItemStatic(_, m, ref expr) => {\n           // Recurse on the expression to catch items in blocks\n           let mut v = TransItemVisitor{ ccx: ccx };\n-          v.visit_expr(expr, ());\n+          v.visit_expr(&**expr, ());\n           consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n@@ -1697,7 +1698,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: &CrateContext, struct_def: @ast::StructDef) {\n+pub fn trans_struct_def(ccx: &CrateContext, struct_def: Gc<ast::StructDef>) {\n     // If this is a tuple-like struct, translate the constructor.\n     match struct_def.ctor_id {\n         // We only need to translate a constructor if there are fields;\n@@ -1719,7 +1720,7 @@ pub fn trans_struct_def(ccx: &CrateContext, struct_def: @ast::StructDef) {\n pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n     for item in m.items.iter() {\n-        trans_item(ccx, *item);\n+        trans_item(ccx, &**item);\n     }\n }\n \n@@ -2003,7 +2004,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n \n             let v = match i.node {\n-                ast::ItemStatic(_, _, expr) => {\n+                ast::ItemStatic(_, _, ref expr) => {\n                     // If this static came from an external crate, then\n                     // we need to get the symbol from csearch instead of\n                     // using the current crate's name/version\n@@ -2022,7 +2023,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n-                    let (v, inlineable) = consts::const_expr(ccx, expr, is_local);\n+                    let (v, inlineable) = consts::const_expr(ccx, &**expr, is_local);\n                     ccx.const_values.borrow_mut().insert(id, v);\n                     let mut inlineable = inlineable;\n \n@@ -2118,13 +2119,13 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                    get_item_val()\");\n                 }\n                 ast::Provided(m) => {\n-                    register_method(ccx, id, m)\n+                    register_method(ccx, id, &*m)\n                 }\n             }\n         }\n \n         ast_map::NodeMethod(m) => {\n-            register_method(ccx, id, m)\n+            register_method(ccx, id, &*m)\n         }\n \n         ast_map::NodeForeignItem(ni) => {\n@@ -2134,13 +2135,13 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 ast::ForeignItemFn(..) => {\n                     let abi = ccx.tcx.map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n-                    let name = foreign::link_name(ni);\n+                    let name = foreign::link_name(&*ni);\n                     foreign::register_foreign_item_fn(ccx, abi, ty,\n                                                       name.get().as_slice(),\n                                                       Some(ni.span))\n                 }\n                 ast::ForeignItemStatic(..) => {\n-                    foreign::register_static(ccx, ni)\n+                    foreign::register_static(ccx, &*ni)\n                 }\n             }\n         }"}, {"sha": "2f4b086b5b0e1ffb26a9ee525ee507fd69e42984", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -53,6 +53,8 @@ use syntax::ast;\n use synabi = syntax::abi;\n use syntax::ast_map;\n \n+use std::gc::Gc;\n+\n pub struct MethodData {\n     pub llfn: ValueRef,\n     pub llself: ValueRef,\n@@ -649,7 +651,7 @@ pub fn trans_call_inner<'a>(\n \n         let mut llargs = Vec::new();\n         let arg_tys = match args {\n-            ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n+            ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, &**x)).collect(),\n             _ => fail!(\"expected arg exprs.\")\n         };\n         bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n@@ -683,7 +685,7 @@ pub fn trans_call_inner<'a>(\n pub enum CallArgs<'a> {\n     // Supply value of arguments as a list of expressions that must be\n     // translated. This is used in the common case of `foo(bar, qux)`.\n-    ArgExprs(&'a [@ast::Expr]),\n+    ArgExprs(&'a [Gc<ast::Expr>]),\n \n     // Supply value of arguments as a list of LLVM value refs; frequently\n     // used with lang items and so forth, when the argument is an internal\n@@ -715,18 +717,18 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n     match args {\n         ArgExprs(arg_exprs) => {\n             let num_formal_args = arg_tys.len();\n-            for (i, &arg_expr) in arg_exprs.iter().enumerate() {\n+            for (i, arg_expr) in arg_exprs.iter().enumerate() {\n                 if i == 0 && ignore_self {\n                     continue;\n                 }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n-                    expr_ty_adjusted(cx, arg_expr)\n+                    expr_ty_adjusted(cx, &**arg_expr)\n                 } else {\n                     *arg_tys.get(i)\n                 };\n \n-                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_expr));\n+                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &**arg_expr));\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_datum(bcx, arg_ty, arg_datum,\n                                     arg_cleanup_scope,"}, {"sha": "ae476fb9741cb461af8864298292e91a3bc6e858", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -34,8 +34,8 @@ use middle::ty;\n use util::ppaux::{Repr, ty_to_str};\n \n use std::c_str::ToCStr;\n+use std::gc::Gc;\n use std::vec;\n-use std::vec::Vec;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n \n@@ -92,11 +92,11 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n }\n \n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n-             es: &[@ast::Expr], is_local: bool) -> (ValueRef, Type, bool) {\n+             es: &[Gc<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, &**e, is_local)));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(cx, vs.as_slice(), false)\n@@ -292,8 +292,8 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n-    let map_list = |exprs: &[@ast::Expr]| {\n-        exprs.iter().map(|&e| const_expr(cx, e, is_local))\n+    let map_list = |exprs: &[Gc<ast::Expr>]| {\n+        exprs.iter().map(|e| const_expr(cx, &**e, is_local))\n              .fold((Vec::new(), true),\n                    |(l, all_inlineable), (val, inlineable)| {\n                 (l.append_one(val), all_inlineable && inlineable)\n@@ -302,18 +302,18 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n-          ast::ExprLit(lit) => {\n-              (consts::const_lit(cx, e, (*lit).clone()), true)\n+          ast::ExprLit(ref lit) => {\n+              (consts::const_lit(cx, e, (**lit).clone()), true)\n           }\n-          ast::ExprBinary(b, e1, e2) => {\n-            let (te1, _) = const_expr(cx, e1, is_local);\n-            let (te2, _) = const_expr(cx, e2, is_local);\n+          ast::ExprBinary(b, ref e1, ref e2) => {\n+            let (te1, _) = const_expr(cx, &**e1, is_local);\n+            let (te2, _) = const_expr(cx, &**e2, is_local);\n \n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let ty = ty::expr_ty(cx.tcx(), e1);\n+            let ty = ty::expr_ty(cx.tcx(), &**e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n             return (match b {\n@@ -387,9 +387,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               },\n             }, true)\n           },\n-          ast::ExprUnary(u, e) => {\n-            let (te, _) = const_expr(cx, e, is_local);\n-            let ty = ty::expr_ty(cx.tcx(), e);\n+          ast::ExprUnary(u, ref e) => {\n+            let (te, _) = const_expr(cx, &**e, is_local);\n+            let ty = ty::expr_ty(cx.tcx(), &**e);\n             let is_float = ty::type_is_fp(ty);\n             return (match u {\n               ast::UnBox | ast::UnUniq | ast::UnDeref => {\n@@ -414,20 +414,20 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n             }, true)\n           }\n-          ast::ExprField(base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), base);\n+          ast::ExprField(ref base, field, _) => {\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), &**base);\n               let brepr = adt::represent_type(cx, bt);\n-              let (bv, inlineable) = const_expr(cx, base, is_local);\n+              let (bv, inlineable) = const_expr(cx, &**base, is_local);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.name, field_tys);\n                   (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n               })\n           }\n \n-          ast::ExprIndex(base, index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx(), base);\n-              let (bv, inlineable) = const_expr(cx, base, is_local);\n-              let iv = match const_eval::eval_const_expr(cx.tcx(), index) {\n+          ast::ExprIndex(ref base, ref index) => {\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), &**base);\n+              let (bv, inlineable) = const_expr(cx, &**base, is_local);\n+              let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n                   _ => cx.sess().span_bug(index.span,\n@@ -466,11 +466,11 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n               (const_get_elt(cx, arr, [iv as c_uint]), inlineable)\n           }\n-          ast::ExprCast(base, _) => {\n+          ast::ExprCast(ref base, _) => {\n             let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let basety = ty::expr_ty(cx.tcx(), base);\n-            let (v, inlineable) = const_expr(cx, base, is_local);\n+            let basety = ty::expr_ty(cx.tcx(), &**base);\n+            let (v, inlineable) = const_expr(cx, &**base, is_local);\n             return (match (expr::cast_type_kind(basety),\n                            expr::cast_type_kind(ety)) {\n \n@@ -520,8 +520,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               }\n             }, inlineable)\n           }\n-          ast::ExprAddrOf(ast::MutImmutable, sub) => {\n-              let (e, _) = const_expr(cx, sub, is_local);\n+          ast::ExprAddrOf(ast::MutImmutable, ref sub) => {\n+              let (e, _) = const_expr(cx, &**sub, is_local);\n               (const_addr_of(cx, e), false)\n           }\n           ast::ExprTup(ref es) => {\n@@ -536,15 +536,15 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               let tcx = cx.tcx();\n \n               let base_val = match *base_opt {\n-                Some(base) => Some(const_expr(cx, base, is_local)),\n+                Some(ref base) => Some(const_expr(cx, &**base, is_local)),\n                 None => None\n               };\n \n               expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n                   let (cs, inlineable) = vec::unzip(field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n-                          Some(f) => const_expr(cx, (*f).expr, is_local),\n+                          Some(ref f) => const_expr(cx, &*f.expr, is_local),\n                           None => {\n                               match base_val {\n                                 Some((bv, inlineable)) => {\n@@ -567,12 +567,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                                is_local);\n             (v, inlineable)\n           }\n-          ast::ExprVstore(sub, store @ ast::ExprVstoreSlice) |\n-          ast::ExprVstore(sub, store @ ast::ExprVstoreMutSlice) => {\n+          ast::ExprVstore(ref sub, store @ ast::ExprVstoreSlice) |\n+          ast::ExprVstore(ref sub, store @ ast::ExprVstoreMutSlice) => {\n             match sub.node {\n               ast::ExprLit(ref lit) => {\n                 match lit.node {\n-                    ast::LitStr(..) => { const_expr(cx, sub, is_local) }\n+                    ast::LitStr(..) => { const_expr(cx, &**sub, is_local) }\n                     _ => { cx.sess().span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n@@ -595,16 +595,16 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               _ => cx.sess().span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n-          ast::ExprRepeat(elem, count) => {\n+          ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);\n             let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = match const_eval::eval_const_expr(cx.tcx(), count) {\n+            let n = match const_eval::eval_const_expr(cx.tcx(), &**count) {\n                 const_eval::const_int(i)  => i as uint,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n+            let vs = Vec::from_elem(n, const_expr(cx, &**elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs.as_slice(), false)\n             } else {\n@@ -673,7 +673,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(e) => { const_expr(cx, e, is_local) }\n+          ast::ExprParen(ref e) => { const_expr(cx, &**e, is_local) }\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n                 Some(ref expr) => const_expr(cx, &**expr, is_local),"}, {"sha": "e9b1c56eb00320485f34ccc5767d3e328436ec6b", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -31,6 +31,8 @@ use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n \n+use std::gc::Gc;\n+\n pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n                       s: &ast::Stmt)\n                       -> &'a Block<'a> {\n@@ -48,18 +50,18 @@ pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n     fcx.push_ast_cleanup_scope(id);\n \n     match s.node {\n-        ast::StmtExpr(e, _) | ast::StmtSemi(e, _) => {\n-            bcx = trans_stmt_semi(bcx, e);\n+        ast::StmtExpr(ref e, _) | ast::StmtSemi(ref e, _) => {\n+            bcx = trans_stmt_semi(bcx, &**e);\n         }\n         ast::StmtDecl(d, _) => {\n             match d.node {\n                 ast::DeclLocal(ref local) => {\n-                    bcx = init_local(bcx, *local);\n+                    bcx = init_local(bcx, &**local);\n                     if cx.sess().opts.debuginfo == FullDebugInfo {\n-                        debuginfo::create_local_var_metadata(bcx, *local);\n+                        debuginfo::create_local_var_metadata(bcx, &**local);\n                     }\n                 }\n-                ast::DeclItem(i) => trans_item(cx.fcx.ccx, i)\n+                ast::DeclItem(ref i) => trans_item(cx.fcx.ccx, &**i)\n             }\n         }\n         ast::StmtMac(..) => cx.tcx().sess.bug(\"unexpanded macro\")\n@@ -92,7 +94,7 @@ pub fn trans_block<'a>(bcx: &'a Block<'a>,\n     fcx.push_ast_cleanup_scope(b.id);\n \n     for s in b.stmts.iter() {\n-        bcx = trans_stmt(bcx, *s);\n+        bcx = trans_stmt(bcx, &**s);\n     }\n \n     if dest != expr::Ignore {\n@@ -103,8 +105,8 @@ pub fn trans_block<'a>(bcx: &'a Block<'a>,\n     }\n \n     match b.expr {\n-        Some(e) => {\n-            bcx = expr::trans_into(bcx, e, dest);\n+        Some(ref e) => {\n+            bcx = expr::trans_into(bcx, &**e, dest);\n         }\n         None => {\n             assert!(dest == expr::Ignore || bcx.unreachable.get());\n@@ -120,7 +122,7 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n                     if_id: ast::NodeId,\n                     cond: &ast::Expr,\n                     thn: ast::P<ast::Block>,\n-                    els: Option<@ast::Expr>,\n+                    els: Option<Gc<ast::Expr>>,\n                     dest: expr::Dest)\n                     -> &'a Block<'a> {\n     debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n@@ -137,21 +139,21 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n             match els {\n                 Some(elexpr) => {\n                     let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx };\n-                    trans.visit_expr(elexpr, ());\n+                    trans.visit_expr(&*elexpr, ());\n                 }\n                 None => {}\n             }\n             // if true { .. } [else { .. }]\n-            bcx = trans_block(bcx, thn, dest);\n+            bcx = trans_block(bcx, &*thn, dest);\n             debuginfo::clear_source_location(bcx.fcx);\n         } else {\n             let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx } ;\n-            trans.visit_block(thn, ());\n+            trans.visit_block(&*thn, ());\n \n             match els {\n                 // if false { .. } else { .. }\n                 Some(elexpr) => {\n-                    bcx = expr::trans_into(bcx, elexpr, dest);\n+                    bcx = expr::trans_into(bcx, &*elexpr, dest);\n                     debuginfo::clear_source_location(bcx.fcx);\n                 }\n \n@@ -165,14 +167,14 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n \n     let name = format!(\"then-block-{}-\", thn.id);\n     let then_bcx_in = bcx.fcx.new_id_block(name.as_slice(), thn.id);\n-    let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n+    let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     debuginfo::clear_source_location(bcx.fcx);\n \n     let next_bcx;\n     match els {\n         Some(elexpr) => {\n             let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n-            let else_bcx_out = expr::trans_into(else_bcx_in, elexpr, dest);\n+            let else_bcx_out = expr::trans_into(else_bcx_in, &*elexpr, dest);\n             next_bcx = bcx.fcx.join_blocks(if_id,\n                                            [then_bcx_out, else_bcx_out]);\n             CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n@@ -319,7 +321,7 @@ pub fn trans_cont<'a>(bcx: &'a Block<'a>,\n }\n \n pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n-                     e: Option<@ast::Expr>)\n+                     e: Option<Gc<ast::Expr>>)\n                      -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n@@ -330,7 +332,7 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n     };\n     match e {\n         Some(x) => {\n-            bcx = expr::trans_into(bcx, x, dest);\n+            bcx = expr::trans_into(bcx, &*x, dest);\n         }\n         _ => {}\n     }"}, {"sha": "db17000abb32b188c26477794b18e29de05e22d4", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 82, "deletions": 78, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -143,14 +143,14 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux;\n \n+use libc::{c_uint, c_ulonglong, c_longlong};\n use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n-use std::rc::{Rc, Weak};\n use std::collections::HashMap;\n use std::collections::HashSet;\n-use libc::{c_uint, c_ulonglong, c_longlong};\n+use std::gc::Gc;\n use std::ptr;\n-use std::string::String;\n+use std::rc::{Rc, Weak};\n use std::sync::atomics;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map};\n@@ -379,7 +379,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     let cx = bcx.ccx();\n     let def_map = &cx.tcx.def_map;\n \n-    pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n \n         let datum = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n@@ -524,7 +524,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let def_map = &cx.tcx.def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n-    pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path_ref| {\n         let llarg = match bcx.fcx.llargs.borrow().find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n@@ -715,7 +715,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx, fn_ast_id, fn_decl, param_substs, span);\n+        let fn_signature = get_function_signature(cx, fn_ast_id, &*fn_decl, param_substs, span);\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n@@ -779,7 +779,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     let arg_pats = fn_decl.inputs.iter().map(|arg_ref| arg_ref.pat).collect::<Vec<_>>();\n     populate_scope_map(cx,\n                        arg_pats.as_slice(),\n-                       top_level_block,\n+                       &*top_level_block,\n                        fn_metadata,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n \n@@ -2519,7 +2519,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // descriptors where necessary. These artificial scopes allow GDB to correctly handle name\n // shadowing.\n fn populate_scope_map(cx: &CrateContext,\n-                      arg_pats: &[@ast::Pat],\n+                      arg_pats: &[Gc<ast::Pat>],\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2535,7 +2535,7 @@ fn populate_scope_map(cx: &CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely with variable\n     // shadowing.\n     for &arg_pat in arg_pats.iter() {\n-        pat_util::pat_bindings(def_map, arg_pat, |_, _, _, path_ref| {\n+        pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path_ref| {\n             let ident = ast_util::path_to_ident(path_ref);\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata, ident: Some(ident) });\n         })\n@@ -2597,19 +2597,21 @@ fn populate_scope_map(cx: &CrateContext,\n \n         // The interesting things here are statements and the concluding expression.\n         for statement in block.stmts.iter() {\n-            scope_map.insert(ast_util::stmt_id(*statement),\n+            scope_map.insert(ast_util::stmt_id(&**statement),\n                              scope_stack.last().unwrap().scope_metadata);\n \n             match statement.node {\n-                ast::StmtDecl(decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n-                ast::StmtExpr(exp, _) |\n-                ast::StmtSemi(exp, _) => walk_expr(cx, exp, scope_stack, scope_map),\n+                ast::StmtDecl(ref decl, _) =>\n+                    walk_decl(cx, &**decl, scope_stack, scope_map),\n+                ast::StmtExpr(ref exp, _) |\n+                ast::StmtSemi(ref exp, _) =>\n+                    walk_expr(cx, &**exp, scope_stack, scope_map),\n                 ast::StmtMac(..) => () // ignore macros (which should be expanded anyway)\n             }\n         }\n \n         for exp in block.expr.iter() {\n-            walk_expr(cx, *exp, scope_stack, scope_map);\n+            walk_expr(cx, &**exp, scope_stack, scope_map);\n         }\n     }\n \n@@ -2624,15 +2626,15 @@ fn populate_scope_map(cx: &CrateContext,\n                 walk_pattern(cx, local.pat, scope_stack, scope_map);\n \n                 for exp in local.init.iter() {\n-                    walk_expr(cx, *exp, scope_stack, scope_map);\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }\n             _ => ()\n         }\n     }\n \n     fn walk_pattern(cx: &CrateContext,\n-                    pat: @ast::Pat,\n+                    pat: Gc<ast::Pat>,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n@@ -2646,7 +2648,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n                 // Check if this is a binding. If so we need to put it on the scope stack and maybe\n                 // introduce an artificial scope\n-                if pat_util::pat_is_binding(def_map, pat) {\n+                if pat_util::pat_is_binding(def_map, &*pat) {\n \n                     let ident = ast_util::path_to_ident(path_ref);\n \n@@ -2741,25 +2743,25 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::PatTup(ref sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for &sub_pat in sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in sub_pats.iter() {\n+                    walk_pattern(cx, sub_pat.clone(), scope_stack, scope_map);\n                 }\n             }\n \n-            ast::PatBox(sub_pat) | ast::PatRegion(sub_pat) => {\n+            ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, sub_pat.clone(), scope_stack, scope_map);\n             }\n \n-            ast::PatLit(exp) => {\n+            ast::PatLit(ref exp) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, exp, scope_stack, scope_map);\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n             }\n \n-            ast::PatRange(exp1, exp2) => {\n+            ast::PatRange(ref exp1, ref exp2) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, exp1, scope_stack, scope_map);\n-                walk_expr(cx, exp2, scope_stack, scope_map);\n+                walk_expr(cx, &**exp1, scope_stack, scope_map);\n+                walk_expr(cx, &**exp2, scope_stack, scope_map);\n             }\n \n             ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n@@ -2798,72 +2800,74 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprAgain(_) |\n             ast::ExprPath(_)  => {}\n \n-            ast::ExprVstore(sub_exp, _)   |\n-            ast::ExprCast(sub_exp, _)     |\n-            ast::ExprAddrOf(_, sub_exp)  |\n-            ast::ExprField(sub_exp, _, _) |\n-            ast::ExprParen(sub_exp)       => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+            ast::ExprVstore(ref sub_exp, _)   |\n+            ast::ExprCast(ref sub_exp, _)     |\n+            ast::ExprAddrOf(_, ref sub_exp)  |\n+            ast::ExprField(ref sub_exp, _, _) |\n+            ast::ExprParen(ref sub_exp) =>\n+                walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n \n-            ast::ExprBox(place, sub_expr) => {\n-                walk_expr(cx, place, scope_stack, scope_map);\n-                walk_expr(cx, sub_expr, scope_stack, scope_map);\n+            ast::ExprBox(ref place, ref sub_expr) => {\n+                walk_expr(cx, &**place, scope_stack, scope_map);\n+                walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n             }\n \n             ast::ExprRet(exp_opt) => match exp_opt {\n-                Some(sub_exp) => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+                Some(sub_exp) => walk_expr(cx, &*sub_exp, scope_stack, scope_map),\n                 None => ()\n             },\n \n-            ast::ExprUnary(_, sub_exp) => {\n-                walk_expr(cx, sub_exp, scope_stack, scope_map);\n+            ast::ExprUnary(_, ref sub_exp) => {\n+                walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n             }\n \n-            ast::ExprAssignOp(_, lhs, rhs) |\n-            ast::ExprIndex(lhs, rhs)        |\n-            ast::ExprBinary(_, lhs, rhs)    => {\n-                walk_expr(cx, lhs, scope_stack, scope_map);\n-                walk_expr(cx, rhs, scope_stack, scope_map);\n+            ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+            ast::ExprIndex(ref lhs, ref rhs)        |\n+            ast::ExprBinary(_, ref lhs, ref rhs)    => {\n+                walk_expr(cx, &**lhs, scope_stack, scope_map);\n+                walk_expr(cx, &**rhs, scope_stack, scope_map);\n             }\n \n             ast::ExprVec(ref init_expressions) |\n             ast::ExprTup(ref init_expressions) => {\n                 for ie in init_expressions.iter() {\n-                    walk_expr(cx, *ie, scope_stack, scope_map);\n+                    walk_expr(cx, &**ie, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::ExprAssign(sub_exp1, sub_exp2) |\n-            ast::ExprRepeat(sub_exp1, sub_exp2) => {\n-                walk_expr(cx, sub_exp1, scope_stack, scope_map);\n-                walk_expr(cx, sub_exp2, scope_stack, scope_map);\n+            ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n+            ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n+                walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n+                walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n             }\n \n-            ast::ExprIf(cond_exp, then_block, ref opt_else_exp) => {\n-                walk_expr(cx, cond_exp, scope_stack, scope_map);\n+            ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n+                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n \n                 with_new_scope(cx,\n                                then_block.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    walk_block(cx, then_block, scope_stack, scope_map);\n+                    walk_block(cx, &**then_block, scope_stack, scope_map);\n                 });\n \n                 match *opt_else_exp {\n-                    Some(else_exp) => walk_expr(cx, else_exp, scope_stack, scope_map),\n+                    Some(ref else_exp) =>\n+                        walk_expr(cx, &**else_exp, scope_stack, scope_map),\n                     _ => ()\n                 }\n             }\n \n-            ast::ExprWhile(cond_exp, loop_body) => {\n-                walk_expr(cx, cond_exp, scope_stack, scope_map);\n+            ast::ExprWhile(ref cond_exp, ref loop_body) => {\n+                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n \n                 with_new_scope(cx,\n                                loop_body.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    walk_block(cx, loop_body, scope_stack, scope_map);\n+                    walk_block(cx, &**loop_body, scope_stack, scope_map);\n                 })\n             }\n \n@@ -2877,48 +2881,48 @@ fn populate_scope_map(cx: &CrateContext,\n                                               Found unexpanded macro.\");\n             }\n \n-            ast::ExprLoop(block, _) |\n-            ast::ExprBlock(block)   => {\n+            ast::ExprLoop(ref block, _) |\n+            ast::ExprBlock(ref block)   => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    walk_block(cx, block, scope_stack, scope_map);\n+                    walk_block(cx, &**block, scope_stack, scope_map);\n                 })\n             }\n \n-            ast::ExprFnBlock(decl, block) |\n-            ast::ExprProc(decl, block) => {\n+            ast::ExprFnBlock(ref decl, ref block) |\n+            ast::ExprProc(ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    for &ast::Arg { pat: pattern, .. } in decl.inputs.iter() {\n-                        walk_pattern(cx, pattern, scope_stack, scope_map);\n+                    for &ast::Arg { pat: ref pattern, .. } in decl.inputs.iter() {\n+                        walk_pattern(cx, pattern.clone(), scope_stack, scope_map);\n                     }\n \n-                    walk_block(cx, block, scope_stack, scope_map);\n+                    walk_block(cx, &**block, scope_stack, scope_map);\n                 })\n             }\n \n-            ast::ExprCall(fn_exp, ref args) => {\n-                walk_expr(cx, fn_exp, scope_stack, scope_map);\n+            ast::ExprCall(ref fn_exp, ref args) => {\n+                walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n \n                 for arg_exp in args.iter() {\n-                    walk_expr(cx, *arg_exp, scope_stack, scope_map);\n+                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n                 for arg_exp in args.iter() {\n-                    walk_expr(cx, *arg_exp, scope_stack, scope_map);\n+                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::ExprMatch(discriminant_exp, ref arms) => {\n-                walk_expr(cx, discriminant_exp, scope_stack, scope_map);\n+            ast::ExprMatch(ref discriminant_exp, ref arms) => {\n+                walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n \n                 // for each arm we have to first walk the pattern as these might introduce new\n                 // artificial scopes. It should be sufficient to walk only one pattern per arm, as\n@@ -2937,35 +2941,35 @@ fn populate_scope_map(cx: &CrateContext,\n                         }\n \n                         for guard_exp in arm_ref.guard.iter() {\n-                            walk_expr(cx, *guard_exp, scope_stack, scope_map)\n+                            walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n                         }\n \n-                        walk_expr(cx, arm_ref.body, scope_stack, scope_map);\n+                        walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n                     })\n                 }\n             }\n \n             ast::ExprStruct(_, ref fields, ref base_exp) => {\n-                for &ast::Field { expr: exp, .. } in fields.iter() {\n-                    walk_expr(cx, exp, scope_stack, scope_map);\n+                for &ast::Field { expr: ref exp, .. } in fields.iter() {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n                 match *base_exp {\n-                    Some(exp) => walk_expr(cx, exp, scope_stack, scope_map),\n+                    Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n                     None => ()\n                 }\n             }\n \n             ast::ExprInlineAsm(ast::InlineAsm { inputs: ref inputs,\n                                                 outputs: ref outputs,\n                                                 .. }) => {\n-                // inputs, outputs: ~[(String, @expr)]\n-                for &(_, exp) in inputs.iter() {\n-                    walk_expr(cx, exp, scope_stack, scope_map);\n+                // inputs, outputs: ~[(String, Gc<expr>)]\n+                for &(_, ref exp) in inputs.iter() {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n \n-                for &(_, exp) in outputs.iter() {\n-                    walk_expr(cx, exp, scope_stack, scope_map);\n+                for &(_, ref exp) in outputs.iter() {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n                 }\n             }\n         }"}, {"sha": "fa6566022468595c9dd41d05d89d5568e355724d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 89, "deletions": 109, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -77,6 +77,8 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_str};\n \n+use std::gc::Gc;\n+\n // Destinations\n \n // These are passed around by the code generating functions to track the\n@@ -380,45 +382,53 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_datum_unadjusted\");\n \n     match expr.node {\n-        ast::ExprParen(e) => {\n-            trans(bcx, e)\n+        ast::ExprParen(ref e) => {\n+            trans(bcx, &**e)\n         }\n         ast::ExprPath(_) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n-        ast::ExprField(base, ident, _) => {\n-            trans_rec_field(bcx, base, ident)\n+        ast::ExprField(ref base, ident, _) => {\n+            trans_rec_field(bcx, &**base, ident)\n         }\n-        ast::ExprIndex(base, idx) => {\n-            trans_index(bcx, expr, base, idx)\n+        ast::ExprIndex(ref base, ref idx) => {\n+            trans_index(bcx, expr, &**base, &**idx)\n         }\n-        ast::ExprVstore(contents, ast::ExprVstoreUniq) => {\n+        ast::ExprVstore(ref contents, ast::ExprVstoreUniq) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n             let datum = unpack_datum!(\n-                bcx, tvec::trans_uniq_vstore(bcx, expr, contents));\n+                bcx, tvec::trans_uniq_vstore(bcx, expr, &**contents));\n             bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n             DatumBlock::new(bcx, datum)\n         }\n-        ast::ExprBox(_, contents) => {\n-            // Special case for `box T`. (The other case, for GC, is handled\n-            // in `trans_rvalue_dps_unadjusted`.)\n+        ast::ExprBox(_, ref contents) => {\n+            // Special case for `Box<T>` and `Gc<T>`\n             let box_ty = expr_ty(bcx, expr);\n-            let contents_ty = expr_ty(bcx, contents);\n-            trans_uniq_expr(bcx, box_ty, contents, contents_ty)\n+            let contents_ty = expr_ty(bcx, &**contents);\n+            match ty::get(box_ty).sty {\n+                ty::ty_uniq(..) => {\n+                    trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n+                }\n+                ty::ty_box(..) => {\n+                    trans_managed_expr(bcx, box_ty, &**contents, contents_ty)\n+                }\n+                _ => bcx.sess().span_bug(expr.span,\n+                                         \"expected unique or managed box\")\n+            }\n         }\n-        ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n-        ast::ExprBinary(op, lhs, rhs) => {\n-            trans_binary(bcx, expr, op, lhs, rhs)\n+        ast::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, (**lit).clone()),\n+        ast::ExprBinary(op, ref lhs, ref rhs) => {\n+            trans_binary(bcx, expr, op, &**lhs, &**rhs)\n         }\n-        ast::ExprUnary(op, x) => {\n-            trans_unary(bcx, expr, op, x)\n+        ast::ExprUnary(op, ref x) => {\n+            trans_unary(bcx, expr, op, &**x)\n         }\n-        ast::ExprAddrOf(_, x) => {\n-            trans_addr_of(bcx, expr, x)\n+        ast::ExprAddrOf(_, ref x) => {\n+            trans_addr_of(bcx, expr, &**x)\n         }\n-        ast::ExprCast(val, _) => {\n+        ast::ExprCast(ref val, _) => {\n             // Datum output mode means this is a scalar cast:\n-            trans_imm_cast(bcx, val, expr.id)\n+            trans_imm_cast(bcx, &**val, expr.id)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -581,8 +591,8 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n     }\n \n     match expr.node {\n-        ast::ExprParen(e) => {\n-            trans_into(bcx, e, Ignore)\n+        ast::ExprParen(ref e) => {\n+            trans_into(bcx, &**e, Ignore)\n         }\n         ast::ExprBreak(label_opt) => {\n             controlflow::trans_break(bcx, expr.id, label_opt)\n@@ -593,15 +603,15 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprRet(ex) => {\n             controlflow::trans_ret(bcx, ex)\n         }\n-        ast::ExprWhile(cond, body) => {\n-            controlflow::trans_while(bcx, expr.id, cond, body)\n+        ast::ExprWhile(ref cond, ref body) => {\n+            controlflow::trans_while(bcx, expr.id, &**cond, &**body)\n         }\n-        ast::ExprLoop(body, _) => {\n-            controlflow::trans_loop(bcx, expr.id, body)\n+        ast::ExprLoop(ref body, _) => {\n+            controlflow::trans_loop(bcx, expr.id, &**body)\n         }\n-        ast::ExprAssign(dst, src) => {\n-            let src_datum = unpack_datum!(bcx, trans(bcx, src));\n-            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign\"));\n+        ast::ExprAssign(ref dst, ref src) => {\n+            let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n+            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &**dst, \"assign\"));\n \n             if ty::type_needs_drop(bcx.tcx(), dst_datum.ty) {\n                 // If there are destructors involved, make sure we\n@@ -628,8 +638,8 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n                 src_datum.store_to(bcx, dst_datum.val)\n             }\n         }\n-        ast::ExprAssignOp(op, dst, src) => {\n-            trans_assign_op(bcx, expr, op, dst, src)\n+        ast::ExprAssignOp(op, ref dst, ref src) => {\n+            trans_assign_op(bcx, expr, op, &**dst, src.clone())\n         }\n         ast::ExprInlineAsm(ref a) => {\n             asm::trans_inline_asm(bcx, a)\n@@ -654,20 +664,20 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n     let fcx = bcx.fcx;\n \n     match expr.node {\n-        ast::ExprParen(e) => {\n-            trans_into(bcx, e, dest)\n+        ast::ExprParen(ref e) => {\n+            trans_into(bcx, &**e, dest)\n         }\n         ast::ExprPath(_) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n-        ast::ExprIf(cond, thn, els) => {\n-            controlflow::trans_if(bcx, expr.id, cond, thn, els, dest)\n+        ast::ExprIf(ref cond, ref thn, els) => {\n+            controlflow::trans_if(bcx, expr.id, &**cond, thn.clone(), els, dest)\n         }\n-        ast::ExprMatch(discr, ref arms) => {\n-            _match::trans_match(bcx, expr, discr, arms.as_slice(), dest)\n+        ast::ExprMatch(ref discr, ref arms) => {\n+            _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)\n         }\n-        ast::ExprBlock(blk) => {\n-            controlflow::trans_block(bcx, blk, dest)\n+        ast::ExprBlock(ref blk) => {\n+            controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n             trans_rec_or_struct(bcx,\n@@ -679,7 +689,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            let numbered_fields: Vec<(uint, @ast::Expr)> =\n+            let numbered_fields: Vec<(uint, Gc<ast::Expr>)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             trans_adt(bcx, &*repr, 0, numbered_fields.as_slice(), None, dest)\n         }\n@@ -697,26 +707,26 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::ExprVstore(contents, ast::ExprVstoreSlice) |\n-        ast::ExprVstore(contents, ast::ExprVstoreMutSlice) => {\n+        ast::ExprVstore(ref contents, ast::ExprVstoreSlice) |\n+        ast::ExprVstore(ref contents, ast::ExprVstoreMutSlice) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n-            bcx = tvec::trans_slice_vstore(bcx, expr, contents, dest);\n+            bcx = tvec::trans_slice_vstore(bcx, expr, &**contents, dest);\n             fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id)\n         }\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             tvec::trans_fixed_vstore(bcx, expr, expr, dest)\n         }\n-        ast::ExprFnBlock(decl, body) |\n-        ast::ExprProc(decl, body) => {\n+        ast::ExprFnBlock(ref decl, ref body) |\n+        ast::ExprProc(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let store = ty::ty_closure_store(expr_ty);\n             debug!(\"translating block function {} with type {}\",\n                    expr_to_str(expr), expr_ty.repr(tcx));\n-            closure::trans_expr_fn(bcx, store, decl, body, expr.id, dest)\n+            closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n         }\n-        ast::ExprCall(f, ref args) => {\n+        ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n-                let callee_datum = unpack_datum!(bcx, trans(bcx, f));\n+                let callee_datum = unpack_datum!(bcx, trans(bcx, &**f));\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       callee_datum,\n@@ -725,43 +735,43 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n-                                   f,\n+                                   &**f,\n                                    callee::ArgExprs(args.as_slice()),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n-                                      *args.get(0),\n+                                      &**args.get(0),\n                                       callee::ArgExprs(args.as_slice()),\n                                       dest)\n         }\n-        ast::ExprBinary(_, lhs, rhs) => {\n+        ast::ExprBinary(_, ref lhs, ref rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let lhs = unpack_datum!(bcx, trans(bcx, lhs));\n-            let rhs_datum = unpack_datum!(bcx, trans(bcx, rhs));\n+            let lhs = unpack_datum!(bcx, trans(bcx, &**lhs));\n+            let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n                                 Some((rhs_datum, rhs.id)), Some(dest)).bcx\n         }\n-        ast::ExprUnary(_, subexpr) => {\n+        ast::ExprUnary(_, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let arg = unpack_datum!(bcx, trans(bcx, subexpr));\n+            let arg = unpack_datum!(bcx, trans(bcx, &**subexpr));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n                                 arg, None, Some(dest)).bcx\n         }\n-        ast::ExprIndex(base, idx) => {\n+        ast::ExprIndex(ref base, ref idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let base = unpack_datum!(bcx, trans(bcx, base));\n-            let idx_datum = unpack_datum!(bcx, trans(bcx, idx));\n+            let base = unpack_datum!(bcx, trans(bcx, &**base));\n+            let idx_datum = unpack_datum!(bcx, trans(bcx, &**idx));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n                                 Some((idx_datum, idx.id)), Some(dest)).bcx\n         }\n-        ast::ExprCast(val, _) => {\n+        ast::ExprCast(ref val, _) => {\n             // DPS output mode means this is a trait cast:\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n                 ty::ty_trait(..) => {\n-                    let datum = unpack_datum!(bcx, trans(bcx, val));\n+                    let datum = unpack_datum!(bcx, trans(bcx, &**val));\n                     meth::trans_trait_cast(bcx, datum, expr.id, dest)\n                 }\n                 _ => {\n@@ -770,13 +780,8 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::ExprAssignOp(op, dst, src) => {\n-            trans_assign_op(bcx, expr, op, dst, src)\n-        }\n-        ast::ExprBox(_, contents) => {\n-            // Special case for `Gc<T>` for now. The other case, for unique\n-            // pointers, is handled in `trans_rvalue_datum_unadjusted`.\n-            trans_gc(bcx, expr, contents, dest)\n+        ast::ExprAssignOp(op, ref dst, ref src) => {\n+            trans_assign_op(bcx, expr, op, &**dst, src.clone())\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -975,7 +980,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n fn trans_rec_or_struct<'a>(\n                        bcx: &'a Block<'a>,\n                        fields: &[ast::Field],\n-                       base: Option<@ast::Expr>,\n+                       base: Option<Gc<ast::Expr>>,\n                        expr_span: codemap::Span,\n                        id: ast::NodeId,\n                        dest: Dest)\n@@ -1037,7 +1042,7 @@ fn trans_rec_or_struct<'a>(\n  */\n struct StructBaseInfo {\n     /// The base expression; will be evaluated after all explicit fields.\n-    expr: @ast::Expr,\n+    expr: Gc<ast::Expr>,\n     /// The indices of fields to copy paired with their types.\n     fields: Vec<(uint, ty::t)> }\n \n@@ -1055,7 +1060,7 @@ fn trans_adt<'a>(\n              bcx: &'a Block<'a>,\n              repr: &adt::Repr,\n              discr: ty::Disr,\n-             fields: &[(uint, @ast::Expr)],\n+             fields: &[(uint, Gc<ast::Expr>)],\n              optbase: Option<StructBaseInfo>,\n              dest: Dest)\n              -> &'a Block<'a> {\n@@ -1064,12 +1069,12 @@ fn trans_adt<'a>(\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            for &(_i, e) in fields.iter() {\n-                bcx = trans_into(bcx, e, Ignore);\n+            for &(_i, ref e) in fields.iter() {\n+                bcx = trans_into(bcx, &**e, Ignore);\n             }\n             for sbi in optbase.iter() {\n                 // FIXME #7261: this moves entire base, not just certain fields\n-                bcx = trans_into(bcx, sbi.expr, Ignore);\n+                bcx = trans_into(bcx, &*sbi.expr, Ignore);\n             }\n             return bcx;\n         }\n@@ -1082,18 +1087,18 @@ fn trans_adt<'a>(\n \n     adt::trans_start_init(bcx, repr, addr, discr);\n \n-    for &(i, e) in fields.iter() {\n+    for &(i, ref e) in fields.iter() {\n         let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n-        let e_ty = expr_ty_adjusted(bcx, e);\n-        bcx = trans_into(bcx, e, SaveIn(dest));\n+        let e_ty = expr_ty_adjusted(bcx, &**e);\n+        bcx = trans_into(bcx, &**e, SaveIn(dest));\n         fcx.schedule_drop_mem(cleanup::CustomScope(custom_cleanup_scope),\n                               dest, e_ty);\n     }\n \n     for base in optbase.iter() {\n         // FIXME #6573: is it sound to use the destination's repr on the base?\n         // And, would it ever be reasonable to be here with discr != 0?\n-        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base.expr, \"base\"));\n+        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n         for &(i, t) in base.fields.iter() {\n             let datum = base_datum.get_element(\n                 t,\n@@ -1242,31 +1247,6 @@ fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n     return immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock();\n }\n \n-fn trans_gc<'a>(mut bcx: &'a Block<'a>,\n-                expr: &ast::Expr,\n-                contents: &ast::Expr,\n-                dest: Dest)\n-                -> &'a Block<'a> {\n-    let contents_ty = expr_ty(bcx, contents);\n-    let box_ty = ty::mk_box(bcx.tcx(), contents_ty);\n-\n-    let contents_datum = unpack_datum!(bcx, trans_managed_expr(bcx,\n-                                                               box_ty,\n-                                                               contents,\n-                                                               contents_ty));\n-\n-    match dest {\n-        Ignore => bcx,\n-        SaveIn(addr) => {\n-            let expr_ty = expr_ty(bcx, expr);\n-            let repr = adt::represent_type(bcx.ccx(), expr_ty);\n-            adt::trans_start_init(bcx, &*repr, addr, 0);\n-            let field_dest = adt::trans_field_ptr(bcx, &*repr, addr, 0, 0);\n-            contents_datum.store_to(bcx, field_dest)\n-        }\n-    }\n-}\n-\n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n fn trans_eager_binop<'a>(\n@@ -1480,16 +1460,16 @@ fn trans_overloaded_call<'a>(\n                          mut bcx: &'a Block<'a>,\n                          expr: &ast::Expr,\n                          callee: Datum<Expr>,\n-                         args: &[@ast::Expr],\n+                         args: &[Gc<ast::Expr>],\n                          dest: Option<Dest>)\n                          -> &'a Block<'a> {\n     // Evaluate and tuple the arguments.\n     let tuple_type = ty::mk_tup(bcx.tcx(),\n                                 args.iter()\n-                                    .map(|e| expr_ty(bcx, *e))\n+                                    .map(|e| expr_ty(bcx, &**e))\n                                     .collect());\n     let repr = adt::represent_type(bcx.ccx(), tuple_type);\n-    let numbered_fields: Vec<(uint, @ast::Expr)> =\n+    let numbered_fields: Vec<(uint, Gc<ast::Expr>)> =\n         args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n     let argument_scope = bcx.fcx.push_custom_cleanup_scope();\n     let tuple_datum =\n@@ -1701,7 +1681,7 @@ fn trans_assign_op<'a>(\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n                    dst: &ast::Expr,\n-                   src: @ast::Expr)\n+                   src: Gc<ast::Expr>)\n                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n@@ -1718,7 +1698,7 @@ fn trans_assign_op<'a>(\n     let dst = Load(bcx, dst_datum.val);\n \n     // Evaluate RHS\n-    let rhs_datum = unpack_datum!(bcx, trans(bcx, src));\n+    let rhs_datum = unpack_datum!(bcx, trans(bcx, &*src));\n     let rhs_ty = rhs_datum.ty;\n     let rhs = rhs_datum.to_llscalarish(bcx);\n "}, {"sha": "ed1c1d3092035ab4a2b539f636a53041e7715539", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -443,8 +443,8 @@ pub fn trans_native_call<'a>(\n \n pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n-    for &foreign_item in foreign_mod.items.iter() {\n-        let lname = link_name(foreign_item);\n+    for foreign_item in foreign_mod.items.iter() {\n+        let lname = link_name(&**foreign_item);\n \n         match foreign_item.node {\n             ast::ForeignItemFn(..) => {"}, {"sha": "55ea4a3a0bb1e6dcd84d93fd7056f9d5e965610f", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -51,7 +51,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external_srcs.borrow_mut().insert(item.id, fn_id);\n \n             ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n-            trans_item(ccx, item);\n+            trans_item(ccx, &*item);\n \n             // We're bringing an external global into this crate, but we don't\n             // want to create two copies of the global. If we do this, then if\n@@ -107,7 +107,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             _ => ccx.sess().bug(\"maybe_instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n           }\n-          trans_item(ccx, item);\n+          trans_item(ccx, &*item);\n           local_def(my_id)\n         }\n         csearch::found_parent(_, _) => {\n@@ -131,7 +131,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n           if num_type_params == 0 {\n               let llfn = get_item_val(ccx, mth.id);\n-              trans_fn(ccx, mth.decl, mth.body, llfn,\n+              trans_fn(ccx, &*mth.decl, &*mth.body, llfn,\n                        &param_substs::empty(), mth.id, []);\n           }\n           local_def(mth.id)"}, {"sha": "59387c549db61a40cfb338995e35200fe1c9cf63", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -35,6 +35,7 @@ use util::common::indenter;\n use util::ppaux::Repr;\n \n use std::c_str::ToCStr;\n+use std::gc::Gc;\n use syntax::abi::Rust;\n use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n@@ -47,7 +48,7 @@ see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n pub fn trans_impl(ccx: &CrateContext,\n                   name: ast::Ident,\n-                  methods: &[@ast::Method],\n+                  methods: &[Gc<ast::Method>],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"meth::trans_impl\");\n@@ -60,18 +61,18 @@ pub fn trans_impl(ccx: &CrateContext,\n     if !generics.ty_params.is_empty() {\n         let mut v = TransItemVisitor{ ccx: ccx };\n         for method in methods.iter() {\n-            visit::walk_method_helper(&mut v, *method, ());\n+            visit::walk_method_helper(&mut v, &**method, ());\n         }\n         return;\n     }\n     for method in methods.iter() {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n-            trans_fn(ccx, method.decl, method.body,\n+            trans_fn(ccx, &*method.decl, &*method.body,\n                      llfn, &param_substs::empty(), method.id, []);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n-            visit::walk_method_helper(&mut v, *method, ());\n+            visit::walk_method_helper(&mut v, &**method, ());\n         }\n     }\n }"}, {"sha": "0315815266ee5d6268f44aa1bf6b57aab6fb1d6d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -201,12 +201,12 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeItem(i) => {\n             match *i {\n               ast::Item {\n-                  node: ast::ItemFn(decl, _, _, _, body),\n+                  node: ast::ItemFn(ref decl, _, _, _, ref body),\n                   ..\n               } => {\n                   let d = mk_lldecl();\n                   set_llvm_fn_attrs(i.attrs.as_slice(), d);\n-                  trans_fn(ccx, decl, body, d, &psubsts, fn_id.node, []);\n+                  trans_fn(ccx, &**decl, &**body, d, &psubsts, fn_id.node, []);\n                   d\n               }\n               _ => {\n@@ -215,12 +215,12 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             }\n         }\n         ast_map::NodeForeignItem(i) => {\n-            let simple = intrinsic::get_simple_intrinsic(ccx, i);\n+            let simple = intrinsic::get_simple_intrinsic(ccx, &*i);\n             match simple {\n                 Some(decl) => decl,\n                 None => {\n                     let d = mk_lldecl();\n-                    intrinsic::trans_intrinsic(ccx, d, i, &psubsts, ref_id);\n+                    intrinsic::trans_intrinsic(ccx, d, &*i, &psubsts, ref_id);\n                     d\n                 }\n             }\n@@ -235,7 +235,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                 ast::TupleVariantKind(ref args) => {\n                     trans_enum_variant(ccx,\n                                        parent,\n-                                       v,\n+                                       &*v,\n                                        args.as_slice(),\n                                        this_tv.disr_val,\n                                        &psubsts,\n@@ -249,15 +249,15 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n             set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-            trans_fn(ccx, mth.decl, mth.body, d, &psubsts, mth.id, []);\n+            trans_fn(ccx, &*mth.decl, &*mth.body, d, &psubsts, mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n                     set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx, mth.decl, mth.body, d, &psubsts, mth.id, []);\n+                    trans_fn(ccx, &*mth.decl, &*mth.body, d, &psubsts, mth.id, []);\n                     d\n                 }\n                 _ => {"}, {"sha": "c116df92be24665b8684263b8c0ed1bb8b69515d", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -351,7 +351,7 @@ pub fn write_content<'a>(\n             match dest {\n                 Ignore => {\n                     for element in elements.iter() {\n-                        bcx = expr::trans_into(bcx, *element, Ignore);\n+                        bcx = expr::trans_into(bcx, &**element, Ignore);\n                     }\n                 }\n \n@@ -361,7 +361,7 @@ pub fn write_content<'a>(\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index {:?} with lleltptr={:?}\",\n                                i, bcx.val_to_str(lleltptr));\n-                        bcx = expr::trans_into(bcx, *element,\n+                        bcx = expr::trans_into(bcx, &**element,\n                                                SaveIn(lleltptr));\n                         fcx.schedule_drop_mem(\n                             cleanup::CustomScope(temp_scope),\n@@ -373,13 +373,13 @@ pub fn write_content<'a>(\n             }\n             return bcx;\n         }\n-        ast::ExprRepeat(element, count_expr) => {\n+        ast::ExprRepeat(ref element, ref count_expr) => {\n             match dest {\n                 Ignore => {\n-                    return expr::trans_into(bcx, element, Ignore);\n+                    return expr::trans_into(bcx, &**element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    let count = ty::eval_repeat_count(bcx.tcx(), count_expr);\n+                    let count = ty::eval_repeat_count(bcx.tcx(), &**count_expr);\n                     if count == 0 {\n                         return bcx;\n                     }\n@@ -389,7 +389,7 @@ pub fn write_content<'a>(\n                     // this can only happen as a result of OOM. So we just skip out on the\n                     // cleanup since things would *probably* be broken at that point anyways.\n \n-                    let elem = unpack_datum!(bcx, expr::trans(bcx, element));\n+                    let elem = unpack_datum!(bcx, expr::trans(bcx, &**element));\n                     assert!(!ty::type_moves_by_default(bcx.tcx(), elem.ty));\n \n                     let bcx = iter_vec_loop(bcx, lldest, vt,\n@@ -442,8 +442,8 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n             }\n         },\n         ast::ExprVec(ref es) => es.len(),\n-        ast::ExprRepeat(_, count_expr) => {\n-            ty::eval_repeat_count(bcx.tcx(), count_expr)\n+        ast::ExprRepeat(_, ref count_expr) => {\n+            ty::eval_repeat_count(bcx.tcx(), &**count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "99c337946ae3b93467003da348f00f08814c0675", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -18,7 +18,7 @@ use middle::lint;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n-use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n+use middle::lang_items::OpaqueStructLangItem;\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::freevars;\n use middle::resolve;\n@@ -42,6 +42,7 @@ use std::cmp;\n use std::fmt::Show;\n use std::fmt;\n use std::hash::{Hash, sip, Writer};\n+use std::gc::Gc;\n use std::iter::AdditiveIterator;\n use std::mem;\n use std::ops;\n@@ -348,8 +349,8 @@ pub struct ctxt {\n \n     /// These two caches are used by const_eval when decoding external statics\n     /// and variants that are found.\n-    pub extern_const_statics: RefCell<DefIdMap<Option<@ast::Expr>>>,\n-    pub extern_const_variants: RefCell<DefIdMap<Option<@ast::Expr>>>,\n+    pub extern_const_statics: RefCell<DefIdMap<Option<Gc<ast::Expr>>>>,\n+    pub extern_const_variants: RefCell<DefIdMap<Option<Gc<ast::Expr>>>>,\n \n     pub method_map: typeck::MethodMap,\n     pub vtable_map: typeck::vtable_map,\n@@ -3108,21 +3109,21 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         }\n \n         ast::ExprBox(place, _) => {\n-            // Special case `Box<T>` for now:\n+            // Special case `Box<T>`/`Gc<T>` for now:\n             let definition = match tcx.def_map.borrow().find(&place.id) {\n                 Some(&def) => def,\n                 None => fail!(\"no def for place\"),\n             };\n             let def_id = definition.def_id();\n-            match tcx.lang_items.items.get(ExchangeHeapLangItem as uint) {\n-                &Some(item_def_id) if def_id == item_def_id => {\n-                    RvalueDatumExpr\n-                }\n-                &Some(_) | &None => RvalueDpsExpr,\n+            if tcx.lang_items.exchange_heap() == Some(def_id) ||\n+               tcx.lang_items.managed_heap() == Some(def_id) {\n+                RvalueDatumExpr\n+            } else {\n+                RvalueDpsExpr\n             }\n         }\n \n-        ast::ExprParen(e) => expr_kind(tcx, e),\n+        ast::ExprParen(ref e) => expr_kind(tcx, &**e),\n \n         ast::ExprMac(..) => {\n             tcx.sess.span_bug(\n@@ -3181,7 +3182,7 @@ pub fn ty_sort_str(cx: &ctxt, t: t) -> String {\n         }\n \n         ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n-        ty_box(_) => \"@-ptr\".to_string(),\n+        ty_box(_) => \"Gc-ptr\".to_string(),\n         ty_uniq(_) => \"box\".to_string(),\n         ty_vec(_, _) => \"vector\".to_string(),\n         ty_ptr(_) => \"*-ptr\".to_string(),\n@@ -3740,7 +3741,7 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n                             };\n \n                             match variant.node.disr_expr {\n-                                Some(e) => match const_eval::eval_const_expr_partial(cx, e) {\n+                                Some(ref e) => match const_eval::eval_const_expr_partial(cx, &**e) {\n                                     Ok(const_eval::const_int(val)) => {\n                                         discriminant = val as Disr\n                                     }\n@@ -3763,7 +3764,7 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n                             };\n \n                             last_discriminant = Some(discriminant);\n-                            Rc::new(VariantInfo::from_ast_variant(cx, variant,\n+                            Rc::new(VariantInfo::from_ast_variant(cx, &*variant,\n                                                                   discriminant))\n                         }).collect())\n                     }"}, {"sha": "7db23ee264def3b5a41991324d576bd8b3ff3db6", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -230,7 +230,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     }\n \n     let tps = path.segments.iter().flat_map(|s| s.types.iter())\n-                            .map(|&a_t| ast_ty_to_ty(this, rscope, a_t))\n+                            .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n                             .collect();\n \n     let mut substs = subst::Substs {\n@@ -451,6 +451,53 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                                               supplied to `Box<T>`\");\n                     Some(ty::mk_err())\n                 }\n+                def::DefTy(did) | def::DefStruct(did)\n+                        if Some(did) == this.tcx().lang_items.gc() => {\n+                    if path.segments\n+                           .iter()\n+                           .flat_map(|s| s.types.iter())\n+                           .count() > 1 {\n+                        this.tcx()\n+                            .sess\n+                            .span_err(path.span,\n+                                      \"`Gc` has only one type parameter\")\n+                    }\n+\n+                    for inner_ast_type in path.segments\n+                                              .iter()\n+                                              .flat_map(|s| s.types.iter()) {\n+                        let mt = ast::MutTy {\n+                            ty: *inner_ast_type,\n+                            mutbl: ast::MutImmutable,\n+                        };\n+                        return Some(mk_pointer(this,\n+                                               rscope,\n+                                               &mt,\n+                                               Box,\n+                                               |typ| {\n+                            match ty::get(typ).sty {\n+                                ty::ty_str => {\n+                                    this.tcx()\n+                                        .sess\n+                                        .span_err(path.span,\n+                                                  \"`Gc<str>` is not a type\");\n+                                    ty::mk_err()\n+                                }\n+                                ty::ty_vec(_, None) => {\n+                                    this.tcx()\n+                                        .sess\n+                                        .span_err(path.span,\n+                                                  \"`Gc<[T]>` is not a type\");\n+                                    ty::mk_err()\n+                                }\n+                                _ => ty::mk_box(this.tcx(), typ),\n+                            }\n+                        }))\n+                    }\n+                    this.tcx().sess.span_bug(path.span,\n+                                             \"not enough type parameters \\\n+                                              supplied to `Gc<T>`\")\n+                }\n                 _ => None\n             }\n         }\n@@ -485,12 +532,12 @@ pub fn trait_ref_for_unboxed_function<AC:AstConv,\n                         .inputs\n                         .iter()\n                         .map(|input| {\n-                            ast_ty_to_ty(this, rscope, input.ty)\n+                            ast_ty_to_ty(this, rscope, &*input.ty)\n                         }).collect::<Vec<_>>();\n     let input_tuple = ty::mk_tup(this.tcx(), input_types);\n     let output_type = ast_ty_to_ty(this,\n                                    rscope,\n-                                   unboxed_function.decl.output);\n+                                   &*unboxed_function.decl.output);\n     let substs = subst::Substs {\n         self_ty: None,\n         tps: vec!(input_tuple, output_type),\n@@ -517,8 +564,8 @@ fn mk_pointer<AC:AstConv,\n     debug!(\"mk_pointer(ptr_ty={:?})\", ptr_ty);\n \n     match a_seq_ty.ty.node {\n-        ast::TyVec(ty) => {\n-            let mut mt = ast_ty_to_mt(this, rscope, ty);\n+        ast::TyVec(ref ty) => {\n+            let mut mt = ast_ty_to_mt(this, rscope, &**ty);\n             if a_seq_ty.mutbl == ast::MutMutable {\n                 mt.mutbl = ast::MutMutable;\n             }\n@@ -543,7 +590,7 @@ fn mk_pointer<AC:AstConv,\n                 substs\n             } = trait_ref_for_unboxed_function(this,\n                                                rscope,\n-                                               *unboxed_function);\n+                                               &**unboxed_function);\n             return ty::mk_trait(this.tcx(),\n                                 def_id,\n                                 substs,\n@@ -603,7 +650,7 @@ fn mk_pointer<AC:AstConv,\n         _ => {}\n     }\n \n-    constr(ast_ty_to_ty(this, rscope, a_seq_ty.ty))\n+    constr(ast_ty_to_ty(this, rscope, &*a_seq_ty.ty))\n }\n \n // Parses the programmer's textual representation of a type into our\n@@ -643,12 +690,12 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyVec(ty) => {\n                 tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n                 // return /something/ so they can at least get more errors\n-                let vec_ty = ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty), None);\n+                let vec_ty = ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty), None);\n                 ty::mk_uniq(tcx, vec_ty)\n             }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n-                    ty: ast_ty_to_ty(this, rscope, mt.ty),\n+                    ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n                     mutbl: mt.mutbl\n                 })\n             }\n@@ -660,7 +707,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             }\n             ast::TyTup(ref fields) => {\n                 let flds = fields.iter()\n-                                 .map(|&t| ast_ty_to_ty(this, rscope, t))\n+                                 .map(|t| ast_ty_to_ty(this, rscope, &**t))\n                                  .collect();\n                 ty::mk_tup(tcx, flds)\n             }\n@@ -670,7 +717,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                       \"variadic function must have C calling convention\");\n                 }\n                 ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.fn_style,\n-                                                  bf.abi, bf.decl))\n+                                                  bf.abi, &*bf.decl))\n             }\n             ast::TyClosure(ref f, ref region) => {\n \n@@ -694,7 +741,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             f.onceness,\n                                             bounds,\n                                             store,\n-                                            f.decl,\n+                                            &*f.decl,\n                                             None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n@@ -712,7 +759,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                             f.onceness,\n                                             bounds,\n                                             ty::UniqTraitStore,\n-                                            f.decl,\n+                                            &*f.decl,\n                                             None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n@@ -783,14 +830,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 }\n             }\n             ast::TyFixedLengthVec(ty, e) => {\n-                match const_eval::eval_const_expr_partial(tcx, e) {\n+                match const_eval::eval_const_expr_partial(tcx, &*e) {\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty),\n                                            Some(i as uint)),\n                             const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, &*ty),\n                                            Some(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n@@ -829,7 +876,7 @@ pub fn ty_of_arg<AC: AstConv, RS: RegionScope>(this: &AC, rscope: &RS, a: &ast::\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, a.ty),\n+        _ => ast_ty_to_ty(this, rscope, &*a.ty),\n     }\n }\n \n@@ -900,7 +947,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n \n     let output_ty = match decl.output.node {\n         ast::TyInfer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &*decl.output)\n     };\n \n     return ty::BareFnTy {\n@@ -949,7 +996,7 @@ pub fn ty_of_closure<AC:AstConv>(\n     let output_ty = match decl.output.node {\n         ast::TyInfer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &*decl.output)\n     };\n \n     ty::ClosureTy {"}, {"sha": "d5f7ca56f741e4636dcebab01e85ee6f7026e7f7", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -23,6 +23,7 @@ use middle::typeck::infer;\n use middle::typeck::require_same_types;\n \n use std::collections::{HashMap, HashSet};\n+use std::gc::Gc;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n@@ -43,10 +44,10 @@ pub fn check_match(fcx: &FnCtxt,\n     for arm in arms.iter() {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, *arm.pats.get(0)),\n+            map: pat_id_map(&tcx.def_map, &**arm.pats.get(0)),\n         };\n \n-        for p in arm.pats.iter() { check_pat(&mut pcx, *p, discrim_ty);}\n+        for p in arm.pats.iter() { check_pat(&mut pcx, &**p, discrim_ty);}\n     }\n \n     // The result of the match is the common supertype of all the\n@@ -64,9 +65,9 @@ pub fn check_match(fcx: &FnCtxt,\n         let mut guard_err = false;\n         let mut guard_bot = false;\n         match arm.guard {\n-          Some(e) => {\n-              check_expr_has_type(fcx, e, ty::mk_bool());\n-              let e_ty = fcx.expr_ty(e);\n+          Some(ref e) => {\n+              check_expr_has_type(fcx, &**e, ty::mk_bool());\n+              let e_ty = fcx.expr_ty(&**e);\n               if ty::type_is_error(e_ty) {\n                   guard_err = true;\n               }\n@@ -76,7 +77,7 @@ pub fn check_match(fcx: &FnCtxt,\n           },\n           None => ()\n         }\n-        check_expr(fcx, arm.body);\n+        check_expr(fcx, &*arm.body);\n         let bty = fcx.node_ty(arm.body.id);\n         saw_err = saw_err || ty::type_is_error(bty);\n         if guard_err {\n@@ -111,7 +112,7 @@ pub struct pat_ctxt<'a> {\n }\n \n pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n-                         subpats: &Option<Vec<@ast::Pat>>, expected: ty::t) {\n+                         subpats: &Option<Vec<Gc<ast::Pat>>>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -269,7 +270,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n         if !error_happened {\n             for pats in subpats.iter() {\n                 for (subpat, arg_ty) in pats.iter().zip(arg_types.iter()) {\n-                    check_pat(pcx, *subpat, *arg_ty);\n+                    check_pat(pcx, &**subpat, *arg_ty);\n                 }\n             }\n         }\n@@ -286,7 +287,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n     if error_happened {\n         for pats in subpats.iter() {\n             for pat in pats.iter() {\n-                check_pat(pcx, *pat, ty::mk_err());\n+                check_pat(pcx, &**pat, ty::mk_err());\n             }\n         }\n     }\n@@ -331,13 +332,13 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                                        class_id,\n                                                        class_field.id,\n                                                        substitutions);\n-                check_pat(pcx, field.pat, field_type);\n+                check_pat(pcx, &*field.pat, field_type);\n                 found_fields.insert(index);\n             }\n             None => {\n                 // Check the pattern anyway, so that attempts to look\n                 // up its type won't fail\n-                check_pat(pcx, field.pat, ty::mk_err());\n+                check_pat(pcx, &*field.pat, ty::mk_err());\n                 tcx.sess.span_err(span,\n                     format!(\"struct `{}` does not have a field named `{}`\",\n                             ty::item_path_str(tcx, class_id),\n@@ -441,17 +442,17 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n       ast::PatWild | ast::PatWildMulti => {\n         fcx.write_ty(pat.id, expected);\n       }\n-      ast::PatLit(lt) => {\n-        check_expr_has_type(fcx, lt, expected);\n-        fcx.write_ty(pat.id, fcx.expr_ty(lt));\n+      ast::PatLit(ref lt) => {\n+        check_expr_has_type(fcx, &**lt, expected);\n+        fcx.write_ty(pat.id, fcx.expr_ty(&**lt));\n       }\n-      ast::PatRange(begin, end) => {\n-        check_expr_has_type(fcx, begin, expected);\n-        check_expr_has_type(fcx, end, expected);\n+      ast::PatRange(ref begin, ref end) => {\n+        check_expr_has_type(fcx, &**begin, expected);\n+        check_expr_has_type(fcx, &**end, expected);\n         let b_ty =\n-            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(begin));\n+            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**begin));\n         let e_ty =\n-            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(end));\n+            fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**end));\n         debug!(\"pat_range beginning type: {:?}\", b_ty);\n         debug!(\"pat_range ending type: {:?}\", e_ty);\n         if !require_same_types(\n@@ -463,7 +464,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             tcx.sess.span_err(pat.span,\n                 \"only char and numeric types are allowed in range\");\n         } else {\n-            match valid_range_bounds(fcx.ccx, begin, end) {\n+            match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n                 Some(false) => {\n                     tcx.sess.span_err(begin.span,\n                         \"lower range bound must be less than upper\");\n@@ -516,7 +517,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         debug!(\"(checking match) writing type for pat id {}\", pat.id);\n \n         match sub {\n-          Some(p) => check_pat(pcx, p, expected),\n+          Some(ref p) => check_pat(pcx, &**p, expected),\n           _ => ()\n         }\n       }\n@@ -593,13 +594,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n                 for (i, elt) in elts.iter().enumerate() {\n-                    check_pat(pcx, *elt, *ex_elts.get(i));\n+                    check_pat(pcx, &**elt, *ex_elts.get(i));\n                 }\n                 fcx.write_ty(pat.id, expected);\n             }\n             _ => {\n                 for elt in elts.iter() {\n-                    check_pat(pcx, *elt, ty::mk_err());\n+                    check_pat(pcx, &**elt, ty::mk_err());\n                 }\n                 // use terr_tuple_size if both types are tuples\n                 let type_error = match *s {\n@@ -627,26 +628,26 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             }\n         }\n       }\n-      ast::PatBox(inner) => {\n-          check_pointer_pat(pcx, Send, inner, pat.id, pat.span, expected);\n+      ast::PatBox(ref inner) => {\n+          check_pointer_pat(pcx, Send, &**inner, pat.id, pat.span, expected);\n       }\n-      ast::PatRegion(inner) => {\n-          check_pointer_pat(pcx, Borrowed, inner, pat.id, pat.span, expected);\n+      ast::PatRegion(ref inner) => {\n+          check_pointer_pat(pcx, Borrowed, &**inner, pat.id, pat.span, expected);\n       }\n       ast::PatVec(ref before, slice, ref after) => {\n         let default_region_var =\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n \n         let check_err = || {\n-            for &elt in before.iter() {\n-                check_pat(pcx, elt, ty::mk_err());\n+            for elt in before.iter() {\n+                check_pat(pcx, &**elt, ty::mk_err());\n             }\n-            for &elt in slice.iter() {\n-                check_pat(pcx, elt, ty::mk_err());\n+            for elt in slice.iter() {\n+                check_pat(pcx, &**elt, ty::mk_err());\n             }\n-            for &elt in after.iter() {\n-                check_pat(pcx, elt, ty::mk_err());\n+            for elt in after.iter() {\n+                check_pat(pcx, &**elt, ty::mk_err());\n             }\n             // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n             fcx.infcx().type_error_message_str_with_expected(\n@@ -697,19 +698,19 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           }\n         };\n         for elt in before.iter() {\n-            check_pat(pcx, *elt, elt_type);\n+            check_pat(pcx, &**elt, elt_type);\n         }\n         match slice {\n-            Some(slice_pat) => {\n+            Some(ref slice_pat) => {\n                 let slice_ty = ty::mk_slice(tcx,\n                                             region_var,\n                                             ty::mt {ty: elt_type, mutbl: mutbl});\n-                check_pat(pcx, slice_pat, slice_ty);\n+                check_pat(pcx, &**slice_pat, slice_ty);\n             }\n             None => ()\n         }\n         for elt in after.iter() {\n-            check_pat(pcx, *elt, elt_type);\n+            check_pat(pcx, &**elt, elt_type);\n         }\n         fcx.write_ty(pat.id, expected);\n       }\n@@ -718,7 +719,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n     }\n }\n \n-// Helper function to check @, box and & patterns\n+// Helper function to check gc, box and & patterns\n pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          pointer_kind: PointerKind,\n                          inner: &ast::Pat,"}, {"sha": "9eba67ea076f4e9d663b52aa69acf90fd9b17304", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 182, "deletions": 221, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -79,8 +79,6 @@ type parameter).\n \n use middle::const_eval;\n use middle::def;\n-use middle::lang_items::{ExchangeHeapLangItem, GcLangItem};\n-use middle::lang_items::{ManagedHeapLangItem};\n use middle::lint::UnreachableCode;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n@@ -121,7 +119,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::vec::Vec;\n+use std::gc::Gc;\n use syntax::abi;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n@@ -382,11 +380,11 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n     fn visit_local(&mut self, local: &ast::Local, _: ()) {\n         let o_ty = match local.ty.node {\n             ast::TyInfer => None,\n-            _ => Some(self.fcx.to_ty(local.ty))\n+            _ => Some(self.fcx.to_ty(&*local.ty))\n         };\n         self.assign(local.id, o_ty);\n         debug!(\"Local variable {} is assigned type {}\",\n-               self.fcx.pat_to_str(local.pat),\n+               self.fcx.pat_to_str(&*local.pat),\n                self.fcx.infcx().ty_to_str(\n                    self.fcx.inh.locals.borrow().get_copy(&local.id)));\n         visit::walk_local(self, local, ());\n@@ -478,17 +476,17 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n             pat_util::pat_bindings(&tcx.def_map,\n-                                   input.pat,\n+                                   &*input.pat,\n                                    |_bm, pat_id, _sp, _path| {\n                                        visit.assign(pat_id, None);\n                                    });\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n                 fcx: &fcx,\n-                map: pat_id_map(&tcx.def_map, input.pat),\n+                map: pat_id_map(&tcx.def_map, &*input.pat),\n             };\n-            _match::check_pat(&pcx, input.pat, *arg_ty);\n+            _match::check_pat(&pcx, &*input.pat, *arg_ty);\n         }\n \n         visit.visit_block(body, ());\n@@ -499,11 +497,11 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     // We unify the tail expr's type with the\n     // function result type, if there is a tail expr.\n     match body.expr {\n-        Some(tail_expr) => {\n+        Some(ref tail_expr) => {\n             // Special case: we print a special error if there appears\n             // to be do-block/for-loop confusion\n             demand::suptype_with_fn(&fcx, tail_expr.span, false,\n-                fcx.ret_ty, fcx.expr_ty(tail_expr),\n+                fcx.ret_ty, fcx.expr_ty(&**tail_expr),\n                 |sp, e, a, s| {\n                     fcx.report_mismatched_return_types(sp, e, a, s);\n                 });\n@@ -626,7 +624,7 @@ pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n                                       enum_definition.variants.as_slice());\n         }\n         ast::ItemStruct(..) => {\n-            check_fields_sized(ccx.tcx, ccx.tcx.map.expect_struct(it.id));\n+            check_fields_sized(ccx.tcx, &*ccx.tcx.map.expect_struct(it.id));\n         }\n         _ => {}\n     }\n@@ -639,14 +637,14 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     let _indenter = indenter();\n \n     match it.node {\n-      ast::ItemStatic(_, _, e) => check_const(ccx, it.span, e, it.id),\n+      ast::ItemStatic(_, _, ref e) => check_const(ccx, it.span, &**e, it.id),\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n                             enum_definition.variants.as_slice(),\n                             it.id);\n       }\n-      ast::ItemFn(decl, _, _, _, body) => {\n+      ast::ItemFn(ref decl, _, _, _, ref body) => {\n         let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n         let param_env = ty::construct_parameter_environment(\n@@ -658,14 +656,14 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 fn_tpt.generics.region_param_defs.as_slice(),\n                 body.id);\n \n-        check_bare_fn(ccx, decl, body, it.id, fn_tpt.ty, param_env);\n+        check_bare_fn(ccx, &**decl, &**body, it.id, fn_tpt.ty, param_env);\n       }\n       ast::ItemImpl(_, ref opt_trait_ref, _, ref ms) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n         let impl_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for m in ms.iter() {\n-            check_method_body(ccx, &impl_tpt.generics, None, *m);\n+            check_method_body(ccx, &impl_tpt.generics, None, &**m);\n         }\n \n         match *opt_trait_ref {\n@@ -694,7 +692,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n                 Provided(m) => {\n                     check_method_body(ccx, &trait_def.generics,\n-                                      Some(trait_def.trait_ref.clone()), m);\n+                                      Some(trait_def.trait_ref.clone()), &*m);\n                 }\n             }\n         }\n@@ -709,7 +707,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       ast::ItemForeignMod(ref m) => {\n         if m.abi == abi::RustIntrinsic {\n             for item in m.items.iter() {\n-                check_intrinsic_type(ccx, *item);\n+                check_intrinsic_type(ccx, &**item);\n             }\n         } else {\n             for item in m.items.iter() {\n@@ -770,15 +768,15 @@ fn check_method_body(ccx: &CrateCtxt,\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n \n-    check_bare_fn(ccx, method.decl, method.body, method.id, fty, param_env);\n+    check_bare_fn(ccx, &*method.decl, &*method.body, method.id, fty, param_env);\n }\n \n fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                                     impl_span: Span,\n                                     impl_generics: &ty::Generics,\n                                     ast_trait_ref: &ast::TraitRef,\n                                     impl_trait_ref: &ty::TraitRef,\n-                                    impl_methods: &[@ast::Method]) {\n+                                    impl_methods: &[Gc<ast::Method>]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n     let trait_methods = ty::trait_methods(tcx, impl_trait_ref.def_id);\n@@ -1356,9 +1354,9 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n /// Attempts to resolve a call expression as an overloaded call.\n fn try_overloaded_call(fcx: &FnCtxt,\n                        call_expression: &ast::Expr,\n-                       callee: @ast::Expr,\n+                       callee: Gc<ast::Expr>,\n                        callee_type: ty::t,\n-                       args: &[@ast::Expr])\n+                       args: &[Gc<ast::Expr>])\n                        -> bool {\n     // Try `FnOnce`, then `FnMut`, then `Fn`.\n     for &(maybe_function_trait, method_name) in [\n@@ -1454,7 +1452,7 @@ fn check_method_argument_types(fcx: &FnCtxt,\n                                sp: Span,\n                                method_fn_ty: ty::t,\n                                callee_expr: &ast::Expr,\n-                               args: &[@ast::Expr],\n+                               args: &[Gc<ast::Expr>],\n                                deref_args: DerefArgs,\n                                tuple_arguments: TupleArgumentsFlag)\n                                -> ty::t {\n@@ -1501,7 +1499,7 @@ fn check_argument_types(fcx: &FnCtxt,\n                         sp: Span,\n                         fn_inputs: &[ty::t],\n                         callee_expr: &ast::Expr,\n-                        args: &[@ast::Expr],\n+                        args: &[Gc<ast::Expr>],\n                         deref_args: DerefArgs,\n                         variadic: bool,\n                         tuple_arguments: TupleArgumentsFlag) {\n@@ -1654,7 +1652,7 @@ fn check_argument_types(fcx: &FnCtxt,\n                     DontDerefArgs => {}\n                 }\n \n-                check_expr_coercable_to_type(fcx, *arg, formal_ty);\n+                check_expr_coercable_to_type(fcx, &**arg, formal_ty);\n \n             }\n         }\n@@ -1664,11 +1662,12 @@ fn check_argument_types(fcx: &FnCtxt,\n     // arguments which we skipped above.\n     if variadic {\n         for arg in args.iter().skip(expected_arg_count) {\n-            check_expr(fcx, *arg);\n+            check_expr(fcx, &**arg);\n \n             // There are a few types which get autopromoted when passed via varargs\n             // in C but we just error out instead and require explicit casts.\n-            let arg_ty = structurally_resolved_type(fcx, arg.span, fcx.expr_ty(*arg));\n+            let arg_ty = structurally_resolved_type(fcx, arg.span,\n+                                                    fcx.expr_ty(&**arg));\n             match ty::get(arg_ty).sty {\n                 ty::ty_float(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n@@ -2040,7 +2039,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_call(fcx: &FnCtxt,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n-                  args: &[@ast::Expr]) {\n+                  args: &[Gc<ast::Expr>]) {\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -2091,21 +2090,21 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_method_call(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::SpannedIdent,\n-                         args: &[@ast::Expr],\n+                         args: &[Gc<ast::Expr>],\n                          tps: &[ast::P<ast::Ty>]) {\n-        let rcvr = args[0];\n+        let rcvr = args[0].clone();\n         // We can't know if we need &mut self before we look up the method,\n         // so treat the receiver as mutable just in case - only explicit\n         // overloaded dereferences care about the distinction.\n-        check_expr_with_lvalue_pref(fcx, rcvr, PreferMutLvalue);\n+        check_expr_with_lvalue_pref(fcx, &*rcvr, PreferMutLvalue);\n \n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n                                                 expr.span,\n-                                                fcx.expr_ty(rcvr));\n+                                                fcx.expr_ty(&*rcvr));\n \n-        let tps = tps.iter().map(|&ast_ty| fcx.to_ty(ast_ty)).collect::<Vec<_>>();\n-        let fn_ty = match method::lookup(fcx, expr, rcvr,\n+        let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n+        let fn_ty = match method::lookup(fcx, expr, &*rcvr,\n                                          method_name.node.name,\n                                          expr_t, tps.as_slice(),\n                                          DontDerefArgs,\n@@ -2136,7 +2135,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 // Check for potential static matches (missing self parameters)\n                 method::lookup(fcx,\n                                expr,\n-                               rcvr,\n+                               &*rcvr,\n                                method_name.node.name,\n                                expr_t,\n                                tps.as_slice(),\n@@ -2166,18 +2165,18 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_then_else(fcx: &FnCtxt,\n                        cond_expr: &ast::Expr,\n                        then_blk: &ast::Block,\n-                       opt_else_expr: Option<@ast::Expr>,\n+                       opt_else_expr: Option<Gc<ast::Expr>>,\n                        id: ast::NodeId,\n                        sp: Span,\n                        expected: Option<ty::t>) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n \n         let branches_ty = match opt_else_expr {\n-            Some(else_expr) => {\n+            Some(ref else_expr) => {\n                 check_block_with_expected(fcx, then_blk, expected);\n                 let then_ty = fcx.node_ty(then_blk.id);\n-                check_expr_with_opt_hint(fcx, else_expr, expected);\n-                let else_ty = fcx.expr_ty(else_expr);\n+                check_expr_with_opt_hint(fcx, &**else_expr, expected);\n+                let else_ty = fcx.expr_ty(&**else_expr);\n                 infer::common_supertype(fcx.infcx(),\n                                         infer::IfExpression(sp),\n                                         true,\n@@ -2207,7 +2206,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         self_t: ty::t,\n                         opname: ast::Name,\n                         trait_did: Option<ast::DefId>,\n-                        args: &[@ast::Expr],\n+                        args: &[Gc<ast::Expr>],\n                         autoderef_receiver: AutoderefReceiverFlag,\n                         unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n@@ -2253,25 +2252,25 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_binop(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n-                   lhs: @ast::Expr,\n-                   rhs: @ast::Expr,\n+                   lhs: Gc<ast::Expr>,\n+                   rhs: Gc<ast::Expr>,\n                    is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n         let lvalue_pref = match is_binop_assignment {\n             BinopAssignment => PreferMutLvalue,\n             SimpleBinop => NoPreference\n         };\n-        check_expr_with_lvalue_pref(fcx, lhs, lvalue_pref);\n+        check_expr_with_lvalue_pref(fcx, &*lhs, lvalue_pref);\n \n         // Callee does bot / err checking\n         let lhs_t = structurally_resolved_type(fcx, lhs.span,\n-                                               fcx.expr_ty(lhs));\n+                                               fcx.expr_ty(&*lhs));\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type\n-            check_expr(fcx, rhs);\n-            let rhs_t = fcx.expr_ty(rhs);\n+            check_expr(fcx, &*rhs);\n+            let rhs_t = fcx.expr_ty(&*rhs);\n             require_integral(fcx, rhs.span, rhs_t);\n             fcx.write_ty(expr.id, lhs_t);\n             return;\n@@ -2280,7 +2279,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         if ty::is_binopable(tcx, lhs_t, op) {\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n-            check_expr_has_type(fcx, rhs, tvar);\n+            check_expr_has_type(fcx, &*rhs, tvar);\n \n             let result_t = match op {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n@@ -2345,7 +2344,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                    },\n                                    lhs_t,\n                                    None);\n-            check_expr(fcx, rhs);\n+            check_expr(fcx, &*rhs);\n             ty::mk_err()\n         };\n \n@@ -2357,10 +2356,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn check_user_binop(fcx: &FnCtxt,\n                         ex: &ast::Expr,\n-                        lhs_expr: @ast::Expr,\n+                        lhs_expr: Gc<ast::Expr>,\n                         lhs_resolved_t: ty::t,\n                         op: ast::BinOp,\n-                        rhs: @ast::Expr) -> ty::t {\n+                        rhs: Gc<ast::Expr>) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op {\n@@ -2381,7 +2380,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::BiEq => (\"eq\", lang.eq_trait()),\n             ast::BiNe => (\"ne\", lang.eq_trait()),\n             ast::BiAnd | ast::BiOr => {\n-                check_expr(fcx, rhs);\n+                check_expr(fcx, &*rhs);\n                 return ty::mk_err();\n             }\n         };\n@@ -2400,7 +2399,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        mname: &str,\n                        trait_did: Option<ast::DefId>,\n                        ex: &ast::Expr,\n-                       rhs_expr: @ast::Expr,\n+                       rhs_expr: Gc<ast::Expr>,\n                        rhs_t: ty::t) -> ty::t {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n                         trait_did, [rhs_expr], DontAutoderefReceiver, || {\n@@ -2513,7 +2512,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         check_fn(fcx.ccx, inherited_style, &fty_sig,\n-                 decl, id, body, fcx.inh);\n+                 &*decl, id, &*body, fcx.inh);\n     }\n \n \n@@ -2549,7 +2548,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             None => {}\n         }\n \n-        let tps: Vec<ty::t> = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n+        let tps: Vec<ty::t> = tys.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2647,7 +2646,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             // an error, so we can continue typechecking\n             check_expr_coercable_to_type(\n                     fcx,\n-                    field.expr,\n+                    &*field.expr,\n                     expected_field_type);\n         }\n \n@@ -2688,7 +2687,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 span: codemap::Span,\n                                 class_id: ast::DefId,\n                                 fields: &[ast::Field],\n-                                base_expr: Option<@ast::Expr>) {\n+                                base_expr: Option<Gc<ast::Expr>>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -2728,7 +2727,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match base_expr {\n             None => {}\n             Some(base_expr) => {\n-                check_expr_has_type(fcx, base_expr, struct_type);\n+                check_expr_has_type(fcx, &*base_expr, struct_type);\n                 if ty::type_is_bot(fcx.node_ty(base_expr.id)) {\n                     struct_type = ty::mk_bot();\n                 }\n@@ -2793,8 +2792,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     let mut any_bot = false;\n                     let t: ty::t = fcx.infcx().next_ty_var();\n                     for e in args.iter() {\n-                        check_expr_has_type(fcx, *e, t);\n-                        let arg_t = fcx.expr_ty(*e);\n+                        check_expr_has_type(fcx, &**e, t);\n+                        let arg_t = fcx.expr_ty(&**e);\n                         if ty::type_is_error(arg_t) {\n                             any_error = true;\n                         }\n@@ -2807,29 +2806,29 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     } else if any_bot {\n                         ty::mk_bot()\n                     } else {\n-                        ast_expr_vstore_to_ty(fcx, ev, vst, ||\n+                        ast_expr_vstore_to_ty(fcx, &*ev, vst, ||\n                             ty::mt{ ty: ty::mk_vec(tcx,\n                                                    ty::mt {ty: t, mutbl: mutability},\n                                                    None),\n                                                    mutbl: mutability })\n                     }\n                 }\n-                ast::ExprRepeat(element, count_expr) => {\n-                    check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n-                    let _ = ty::eval_repeat_count(fcx, count_expr);\n+                ast::ExprRepeat(ref element, ref count_expr) => {\n+                    check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n+                    let _ = ty::eval_repeat_count(fcx, &**count_expr);\n                     let mutability = match vst {\n                         ast::ExprVstoreMutSlice => ast::MutMutable,\n                         _ => ast::MutImmutable,\n                     };\n                     let t = fcx.infcx().next_ty_var();\n-                    check_expr_has_type(fcx, element, t);\n-                    let arg_t = fcx.expr_ty(element);\n+                    check_expr_has_type(fcx, &**element, t);\n+                    let arg_t = fcx.expr_ty(&**element);\n                     if ty::type_is_error(arg_t) {\n                         ty::mk_err()\n                     } else if ty::type_is_bot(arg_t) {\n                         ty::mk_bot()\n                     } else {\n-                        ast_expr_vstore_to_ty(fcx, ev, vst, ||\n+                        ast_expr_vstore_to_ty(fcx, &*ev, vst, ||\n                             ty::mt{ ty: ty::mk_vec(tcx,\n                                                    ty::mt {ty: t, mutbl: mutability},\n                                                    None),\n@@ -2851,9 +2850,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_ty(id, typ);\n         }\n \n-      ast::ExprBox(place, subexpr) => {\n-          check_expr(fcx, place);\n-          check_expr(fcx, subexpr);\n+      ast::ExprBox(ref place, ref subexpr) => {\n+          check_expr(fcx, &**place);\n+          check_expr(fcx, &**subexpr);\n \n           let mut checked = false;\n           match place.node {\n@@ -2862,52 +2861,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                   // places: the exchange heap and the managed heap.\n                   let definition = lookup_def(fcx, path.span, place.id);\n                   let def_id = definition.def_id();\n-                  match tcx.lang_items\n-                           .items\n-                           .get(ExchangeHeapLangItem as uint) {\n-                      &Some(item_def_id) if def_id == item_def_id => {\n-                          fcx.write_ty(id, ty::mk_uniq(tcx,\n-                                                       fcx.expr_ty(subexpr)));\n-                          checked = true\n-                      }\n-                      &Some(_) | &None => {}\n-                  }\n-                  if !checked {\n-                      match tcx.lang_items\n-                               .items\n-                               .get(ManagedHeapLangItem as uint) {\n-                          &Some(item_def_id) if def_id == item_def_id => {\n-                              // Assign the magic `Gc<T>` struct.\n-                              let gc_struct_id =\n-                                  match tcx.lang_items\n-                                           .require(GcLangItem) {\n-                                      Ok(id) => id,\n-                                      Err(msg) => {\n-                                          tcx.sess.span_err(expr.span,\n-                                                            msg.as_slice());\n-                                          ast::DefId {\n-                                              krate: ast::CRATE_NODE_ID,\n-                                              node: ast::DUMMY_NODE_ID,\n-                                          }\n-                                      }\n-                                  };\n-                              let regions =\n-                                  subst::NonerasedRegions(Vec::new());\n-                              let sty = ty::mk_struct(tcx,\n-                                                      gc_struct_id,\n-                                                      subst::Substs {\n-                                                        self_ty: None,\n-                                                        tps: vec!(\n-                                                            fcx.expr_ty(\n-                                                                subexpr)\n-                                                        ),\n-                                                        regions: regions,\n-                                                      });\n-                              fcx.write_ty(id, sty);\n-                              checked = true\n-                          }\n-                          &Some(_) | &None => {}\n-                      }\n+                  if tcx.lang_items.exchange_heap() == Some(def_id) {\n+                      fcx.write_ty(id, ty::mk_uniq(tcx,\n+                                                   fcx.expr_ty(&**subexpr)));\n+                      checked = true\n+                  } else if tcx.lang_items.managed_heap() == Some(def_id) {\n+                      fcx.write_ty(id, ty::mk_box(tcx,\n+                                                  fcx.expr_ty(&**subexpr)));\n+                      checked = true\n                   }\n               }\n               _ => {}\n@@ -2921,15 +2882,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           }\n       }\n \n-      ast::ExprLit(lit) => {\n-        let typ = check_lit(fcx, lit);\n+      ast::ExprLit(ref lit) => {\n+        let typ = check_lit(fcx, &**lit);\n         fcx.write_ty(id, typ);\n       }\n-      ast::ExprBinary(op, lhs, rhs) => {\n-        check_binop(fcx, expr, op, lhs, rhs, SimpleBinop);\n+      ast::ExprBinary(op, ref lhs, ref rhs) => {\n+        check_binop(fcx, expr, op, lhs.clone(), rhs.clone(), SimpleBinop);\n \n-        let lhs_ty = fcx.expr_ty(lhs);\n-        let rhs_ty = fcx.expr_ty(rhs);\n+        let lhs_ty = fcx.expr_ty(&**lhs);\n+        let rhs_ty = fcx.expr_ty(&**rhs);\n         if ty::type_is_error(lhs_ty) ||\n             ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n@@ -2939,15 +2900,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::ExprAssignOp(op, lhs, rhs) => {\n-        check_binop(fcx, expr, op, lhs, rhs, BinopAssignment);\n+      ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n+        check_binop(fcx, expr, op, lhs.clone(), rhs.clone(), BinopAssignment);\n \n-        let lhs_t = fcx.expr_ty(lhs);\n+        let lhs_t = fcx.expr_ty(&**lhs);\n         let result_t = fcx.expr_ty(expr);\n         demand::suptype(fcx, expr.span, result_t, lhs_t);\n \n         let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, lhs) {\n+        if !ty::expr_is_lval(tcx, &**lhs) {\n             tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n         }\n \n@@ -2959,7 +2920,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_nil(expr.id);\n         }\n       }\n-      ast::ExprUnary(unop, oprnd) => {\n+      ast::ExprUnary(unop, ref oprnd) => {\n         let exp_inner = unpack_expected(fcx, expected, |sty| {\n             match unop {\n                 ast::UnBox | ast::UnUniq => match *sty {\n@@ -2974,8 +2935,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::UnDeref => lvalue_pref,\n             _ => NoPreference\n         };\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, oprnd, exp_inner, lvalue_pref);\n-        let mut oprnd_t = fcx.expr_ty(oprnd);\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**oprnd, exp_inner, lvalue_pref);\n+        let mut oprnd_t = fcx.expr_ty(&**oprnd);\n         if !ty::type_is_error(oprnd_t) && !ty::type_is_bot(oprnd_t) {\n             match unop {\n                 ast::UnBox => {\n@@ -2990,7 +2951,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         Some(mt) => mt.ty,\n                         None => match try_overloaded_deref(fcx, expr.span,\n                                                            Some(MethodCall::expr(expr.id)),\n-                                                           Some(&*oprnd), oprnd_t, lvalue_pref) {\n+                                                           Some(&**oprnd), oprnd_t, lvalue_pref) {\n                             Some(mt) => mt.ty,\n                             None => {\n                                 let is_newtype = match ty::get(oprnd_t).sty {\n@@ -3025,7 +2986,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n                         oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n                                                   tcx.lang_items.not_trait(),\n-                                                  expr, oprnd, oprnd_t);\n+                                                  expr, oprnd.clone(), oprnd_t);\n                     }\n                 }\n                 ast::UnNeg => {\n@@ -3035,14 +2996,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          ty::type_is_fp(oprnd_t)) {\n                         oprnd_t = check_user_unop(fcx, \"-\", \"neg\",\n                                                   tcx.lang_items.neg_trait(),\n-                                                  expr, oprnd, oprnd_t);\n+                                                  expr, oprnd.clone(), oprnd_t);\n                     }\n                 }\n             }\n         }\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::ExprAddrOf(mutbl, oprnd) => {\n+      ast::ExprAddrOf(mutbl, ref oprnd) => {\n           let hint = unpack_expected(\n               fcx, expected,\n               |sty| match *sty { ty::ty_rptr(_, ref mt) => Some(mt.ty),\n@@ -3051,7 +3012,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::MutMutable => PreferMutLvalue,\n             ast::MutImmutable => NoPreference\n         };\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, oprnd, hint, lvalue_pref);\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**oprnd, hint, lvalue_pref);\n \n         // Note: at this point, we cannot say what the best lifetime\n         // is to use for resulting pointer.  We want to use the\n@@ -3069,7 +3030,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let region = fcx.infcx().next_region_var(\n             infer::AddrOfRegion(expr.span));\n \n-        let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n+        let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n             ty::mk_err()\n         } else if ty::type_is_bot(tm.ty) {\n@@ -3088,20 +3049,20 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         instantiate_path(fcx, pth, tpt, defn, expr.span, expr.id);\n       }\n       ast::ExprInlineAsm(ref ia) => {\n-          for &(_, input) in ia.inputs.iter() {\n-              check_expr(fcx, input);\n+          for &(_, ref input) in ia.inputs.iter() {\n+              check_expr(fcx, &**input);\n           }\n-          for &(_, out) in ia.outputs.iter() {\n-              check_expr(fcx, out);\n+          for &(_, ref out) in ia.outputs.iter() {\n+              check_expr(fcx, &**out);\n           }\n           fcx.write_nil(id);\n       }\n       ast::ExprMac(_) => tcx.sess.bug(\"unexpanded macro\"),\n       ast::ExprBreak(_) => { fcx.write_bot(id); }\n       ast::ExprAgain(_) => { fcx.write_bot(id); }\n-      ast::ExprRet(expr_opt) => {\n+      ast::ExprRet(ref expr_opt) => {\n         let ret_ty = fcx.ret_ty;\n-        match expr_opt {\n+        match *expr_opt {\n           None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n                                     ret_ty, ty::mk_nil()) {\n             Ok(_) => { /* fall through */ }\n@@ -3111,27 +3072,27 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     \"`return;` in function returning non-nil\");\n             }\n           },\n-          Some(e) => {\n-              check_expr_has_type(fcx, e, ret_ty);\n+          Some(ref e) => {\n+              check_expr_has_type(fcx, &**e, ret_ty);\n           }\n         }\n         fcx.write_bot(id);\n       }\n-      ast::ExprParen(a) => {\n-        check_expr_with_opt_hint_and_lvalue_pref(fcx, a, expected, lvalue_pref);\n-        fcx.write_ty(id, fcx.expr_ty(a));\n+      ast::ExprParen(ref a) => {\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, &**a, expected, lvalue_pref);\n+        fcx.write_ty(id, fcx.expr_ty(&**a));\n       }\n-      ast::ExprAssign(lhs, rhs) => {\n-        check_expr_with_lvalue_pref(fcx, lhs, PreferMutLvalue);\n+      ast::ExprAssign(ref lhs, ref rhs) => {\n+        check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n \n         let tcx = fcx.tcx();\n-        if !ty::expr_is_lval(tcx, lhs) {\n+        if !ty::expr_is_lval(tcx, &**lhs) {\n             tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n         }\n \n-        let lhs_ty = fcx.expr_ty(lhs);\n-        check_expr_has_type(fcx, rhs, lhs_ty);\n-        let rhs_ty = fcx.expr_ty(rhs);\n+        let lhs_ty = fcx.expr_ty(&**lhs);\n+        check_expr_has_type(fcx, &**rhs, lhs_ty);\n+        let rhs_ty = fcx.expr_ty(&**rhs);\n \n         if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n@@ -3141,14 +3102,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprIf(cond, then_blk, opt_else_expr) => {\n-        check_then_else(fcx, cond, then_blk, opt_else_expr,\n+      ast::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n+        check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.clone(),\n                         id, expr.span, expected);\n       }\n-      ast::ExprWhile(cond, body) => {\n-        check_expr_has_type(fcx, cond, ty::mk_bool());\n-        check_block_no_value(fcx, body);\n-        let cond_ty = fcx.expr_ty(cond);\n+      ast::ExprWhile(ref cond, ref body) => {\n+        check_expr_has_type(fcx, &**cond, ty::mk_bool());\n+        check_block_no_value(fcx, &**body);\n+        let cond_ty = fcx.expr_ty(&**cond);\n         let body_ty = fcx.node_ty(body.id);\n         if ty::type_is_error(cond_ty) || ty::type_is_error(body_ty) {\n             fcx.write_error(id);\n@@ -3162,54 +3123,54 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprForLoop(..) =>\n           fail!(\"non-desugared expr_for_loop\"),\n-      ast::ExprLoop(body, _) => {\n-        check_block_no_value(fcx, (body));\n-        if !may_break(tcx, expr.id, body) {\n+      ast::ExprLoop(ref body, _) => {\n+        check_block_no_value(fcx, &**body);\n+        if !may_break(tcx, expr.id, body.clone()) {\n             fcx.write_bot(id);\n         }\n         else {\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprMatch(discrim, ref arms) => {\n-        _match::check_match(fcx, expr, discrim, arms.as_slice());\n+      ast::ExprMatch(ref discrim, ref arms) => {\n+        _match::check_match(fcx, expr, &**discrim, arms.as_slice());\n       }\n-      ast::ExprFnBlock(decl, body) => {\n+      ast::ExprFnBlock(ref decl, ref body) => {\n         let region = astconv::opt_ast_region_to_region(fcx,\n                                                        fcx.infcx(),\n                                                        expr.span,\n                                                        &None);\n         check_expr_fn(fcx,\n                       expr,\n                       ty::RegionTraitStore(region, ast::MutMutable),\n-                      decl,\n-                      body,\n+                      &**decl,\n+                      body.clone(),\n                       expected);\n       }\n-      ast::ExprProc(decl, body) => {\n+      ast::ExprProc(ref decl, ref body) => {\n         check_expr_fn(fcx,\n                       expr,\n                       ty::UniqTraitStore,\n-                      decl,\n-                      body,\n+                      &**decl,\n+                      body.clone(),\n                       expected);\n       }\n-      ast::ExprBlock(b) => {\n-        check_block_with_expected(fcx, b, expected);\n+      ast::ExprBlock(ref b) => {\n+        check_block_with_expected(fcx, &**b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n-      ast::ExprCall(f, ref args) => {\n+      ast::ExprCall(ref f, ref args) => {\n           // Index expressions need to be handled separately, to inform them\n           // that they appear in call position.\n-          check_expr(fcx, f);\n-          let f_ty = fcx.expr_ty(f);\n+          check_expr(fcx, &**f);\n+          let f_ty = fcx.expr_ty(&**f);\n \n-          if !try_overloaded_call(fcx, expr, f, f_ty, args.as_slice()) {\n-              check_call(fcx, expr, f, args.as_slice());\n+          if !try_overloaded_call(fcx, expr, f.clone(), f_ty, args.as_slice()) {\n+              check_call(fcx, expr, &**f, args.as_slice());\n               let (args_bot, args_err) = args.iter().fold((false, false),\n                  |(rest_bot, rest_err), a| {\n                      // is this not working?\n-                     let a_ty = fcx.expr_ty(*a);\n+                     let a_ty = fcx.expr_ty(&**a);\n                      (rest_bot || ty::type_is_bot(a_ty),\n                       rest_err || ty::type_is_error(a_ty))});\n               if ty::type_is_error(f_ty) || args_err {\n@@ -3222,7 +3183,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n         check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice());\n-        let mut arg_tys = args.iter().map(|a| fcx.expr_ty(*a));\n+        let mut arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let (args_bot, args_err) = arg_tys.fold((false, false),\n              |(rest_bot, rest_err), a| {\n               (rest_bot || ty::type_is_bot(a),\n@@ -3233,10 +3194,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::ExprCast(e, t) => {\n-        check_expr(fcx, e);\n-        let t_1 = fcx.to_ty(t);\n-        let t_e = fcx.expr_ty(e);\n+      ast::ExprCast(ref e, ref t) => {\n+        check_expr(fcx, &**e);\n+        let t_1 = fcx.to_ty(&**t);\n+        let t_e = fcx.expr_ty(&**e);\n \n         debug!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n         debug!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n@@ -3335,7 +3296,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 /* this case is allowed */\n                             }\n                             _ => {\n-                                demand::coerce(fcx, e.span, t_1, e);\n+                                demand::coerce(fcx, e.span, t_1, &**e);\n                             }\n                         }\n                     } else if !(type_is_scalar(fcx,expr.span,t_e)\n@@ -3359,18 +3320,18 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprVec(ref args) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n         for e in args.iter() {\n-            check_expr_has_type(fcx, *e, t);\n+            check_expr_has_type(fcx, &**e, t);\n         }\n         let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n                              Some(args.len()));\n         fcx.write_ty(id, typ);\n       }\n-      ast::ExprRepeat(element, count_expr) => {\n-        check_expr_with_hint(fcx, count_expr, ty::mk_uint());\n-        let count = ty::eval_repeat_count(fcx, count_expr);\n+      ast::ExprRepeat(ref element, ref count_expr) => {\n+        check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n+        let count = ty::eval_repeat_count(fcx, &**count_expr);\n         let t: ty::t = fcx.infcx().next_ty_var();\n-        check_expr_has_type(fcx, element, t);\n-        let element_ty = fcx.expr_ty(element);\n+        check_expr_has_type(fcx, &**element, t);\n+        let element_ty = fcx.expr_ty(&**element);\n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);\n         }\n@@ -3398,8 +3359,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 Some(ref fs) if i < fs.len() => Some(*fs.get(i)),\n                 _ => None\n             };\n-            check_expr_with_opt_hint(fcx, *e, opt_hint);\n-            let t = fcx.expr_ty(*e);\n+            check_expr_with_opt_hint(fcx, &**e, opt_hint);\n+            let t = fcx.expr_ty(&**e);\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n@@ -3431,14 +3392,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n         }\n       }\n-      ast::ExprField(base, field, ref tys) => {\n-        check_field(fcx, expr, lvalue_pref, base, field.name, tys.as_slice());\n+      ast::ExprField(ref base, ref field, ref tys) => {\n+        check_field(fcx, expr, lvalue_pref, &**base, field.name, tys.as_slice());\n       }\n-      ast::ExprIndex(base, idx) => {\n-          check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n-          check_expr(fcx, idx);\n-          let raw_base_t = fcx.expr_ty(base);\n-          let idx_t = fcx.expr_ty(idx);\n+      ast::ExprIndex(ref base, ref idx) => {\n+          check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n+          check_expr(fcx, &**idx);\n+          let raw_base_t = fcx.expr_ty(&**base);\n+          let idx_t = fcx.expr_ty(&**idx);\n           if ty::type_is_error(raw_base_t) || ty::type_is_bot(raw_base_t) {\n               fcx.write_ty(id, raw_base_t);\n           } else if ty::type_is_error(idx_t) || ty::type_is_bot(idx_t) {\n@@ -3449,7 +3410,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n                   Some(mt) => {\n-                      check_expr_has_type(fcx, idx, ty::mk_uint());\n+                      check_expr_has_type(fcx, &**idx, ty::mk_uint());\n                       fcx.write_ty(id, mt.ty);\n                       fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n@@ -3462,7 +3423,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                     resolved,\n                                                     token::intern(\"index\"),\n                                                     tcx.lang_items.index_trait(),\n-                                                    [base, idx],\n+                                                    [base.clone(), idx.clone()],\n                                                     AutoderefReceiver,\n                                                     || {\n                         fcx.type_error_message(expr.span,\n@@ -3526,9 +3487,9 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n     fcx.write_ty(local.id, t);\n \n     match local.init {\n-        Some(init) => {\n-            check_decl_initializer(fcx, local.id, init);\n-            let init_ty = fcx.expr_ty(init);\n+        Some(ref init) => {\n+            check_decl_initializer(fcx, local.id, &**init);\n+            let init_ty = fcx.expr_ty(&**init);\n             if ty::type_is_error(init_ty) || ty::type_is_bot(init_ty) {\n                 fcx.write_ty(local.id, init_ty);\n             }\n@@ -3538,9 +3499,9 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n \n     let pcx = pat_ctxt {\n         fcx: fcx,\n-        map: pat_id_map(&tcx.def_map, local.pat),\n+        map: pat_id_map(&tcx.def_map, &*local.pat),\n     };\n-    _match::check_pat(&pcx, local.pat, t);\n+    _match::check_pat(&pcx, &*local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);\n     if ty::type_is_error(pat_ty) || ty::type_is_bot(pat_ty) {\n         fcx.write_ty(local.id, pat_ty);\n@@ -3556,26 +3517,26 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n         node_id = id;\n         match decl.node {\n           ast::DeclLocal(ref l) => {\n-              check_decl_local(fcx, *l);\n+              check_decl_local(fcx, &**l);\n               let l_t = fcx.node_ty(l.id);\n               saw_bot = saw_bot || ty::type_is_bot(l_t);\n               saw_err = saw_err || ty::type_is_error(l_t);\n           }\n           ast::DeclItem(_) => {/* ignore for now */ }\n         }\n       }\n-      ast::StmtExpr(expr, id) => {\n+      ast::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, expr, ty::mk_nil());\n-        let expr_ty = fcx.expr_ty(expr);\n+        check_expr_has_type(fcx, &**expr, ty::mk_nil());\n+        let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot = saw_bot || ty::type_is_bot(expr_ty);\n         saw_err = saw_err || ty::type_is_error(expr_ty);\n       }\n-      ast::StmtSemi(expr, id) => {\n+      ast::StmtSemi(ref expr, id) => {\n         node_id = id;\n-        check_expr(fcx, expr);\n-        let expr_ty = fcx.expr_ty(expr);\n+        check_expr(fcx, &**expr);\n+        let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot |= ty::type_is_bot(expr_ty);\n         saw_err |= ty::type_is_error(expr_ty);\n       }\n@@ -3622,8 +3583,8 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n         let mut any_bot = false;\n         let mut any_err = false;\n         for s in blk.stmts.iter() {\n-            check_stmt(fcx, *s);\n-            let s_id = ast_util::stmt_id(*s);\n+            check_stmt(fcx, &**s);\n+            let s_id = ast_util::stmt_id(&**s);\n             let s_ty = fcx.node_ty(s_id);\n             if last_was_bot && !warned && match s.node {\n                   ast::StmtDecl(decl, _) => {\n@@ -3670,8 +3631,8 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                              e.span,\n                              \"unreachable expression\".to_string());\n             }\n-            check_expr_with_opt_hint(fcx, e, expected);\n-              let ety = fcx.expr_ty(e);\n+            check_expr_with_opt_hint(fcx, &*e, expected);\n+              let ety = fcx.expr_ty(&*e);\n               fcx.write_ty(blk.id, ety);\n               if any_err {\n                   fcx.write_error(blk.id);\n@@ -3831,7 +3792,7 @@ pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                     }\n                 }\n             },\n-            ast::StructVariantKind(struct_def) => check_fields_sized(ccx.tcx, struct_def),\n+            ast::StructVariantKind(struct_def) => check_fields_sized(ccx.tcx, &*struct_def),\n             _ => {}\n         }\n     }\n@@ -3891,17 +3852,17 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n \n             match v.node.disr_expr {\n                 Some(e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_str(e));\n+                    debug!(\"disr expr, checking {}\", pprust::expr_to_str(&*e));\n \n                     let inh = blank_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n                     let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n-                    check_const_with_ty(&fcx, e.span, e, declty);\n+                    check_const_with_ty(&fcx, e.span, &*e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n                     // that the expression is in a form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n-                    match const_eval::eval_const_expr_partial(ccx.tcx, e) {\n+                    match const_eval::eval_const_expr_partial(ccx.tcx, &*e) {\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n@@ -3936,7 +3897,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n             }\n             disr_vals.push(current_disr_val);\n \n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, v,\n+            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &*v,\n                                                                      current_disr_val));\n             prev_disr_val = Some(current_disr_val);\n \n@@ -4134,7 +4095,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         let mut pushed = false;\n         for (i, ty) in pth.segments.iter()\n                                    .flat_map(|segment| segment.types.iter())\n-                                   .map(|&ast_type| fcx.to_ty(ast_type))\n+                                   .map(|ast_type| fcx.to_ty(&**ast_type))\n                                    .enumerate() {\n             match self_parameter_index {\n                 Some(index) if index == i => {\n@@ -4302,7 +4263,7 @@ pub fn ast_expr_vstore_to_ty(fcx: &FnCtxt,\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n-    (loop_query(b, |e| {\n+    (loop_query(&*b, |e| {\n         match *e {\n             ast::ExprBreak(_) => true,\n             _ => false"}, {"sha": "93ab492eb3af58d432d0c59a93bf25947ca4c8c3", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -141,6 +141,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::cell::RefCell;\n+use std::gc::Gc;\n \n // If mem categorization results in an error, it's because the type\n // check failed (or will fail, when the error is uncovered and\n@@ -343,16 +344,16 @@ fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n \n fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n     // see above\n-    for &p in arm.pats.iter() {\n-        constrain_bindings_in_pat(p, rcx);\n+    for p in arm.pats.iter() {\n+        constrain_bindings_in_pat(&**p, rcx);\n     }\n \n     visit::walk_arm(rcx, arm, ());\n }\n \n fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n     // see above\n-    constrain_bindings_in_pat(l.pat, rcx);\n+    constrain_bindings_in_pat(&*l.pat, rcx);\n     link_local(rcx, l);\n     visit::walk_local(rcx, l, ());\n }\n@@ -441,9 +442,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     }\n \n     match expr.node {\n-        ast::ExprCall(callee, ref args) => {\n+        ast::ExprCall(ref callee, ref args) => {\n             if !has_method_map {\n-                constrain_callee(rcx, callee.id, expr, callee);\n+                constrain_callee(rcx, callee.id, expr, &**callee);\n                 constrain_call(rcx,\n                                Some(callee.id),\n                                expr,\n@@ -462,45 +463,47 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAssign(lhs, _) => {\n-            adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n+        ast::ExprAssign(ref lhs, _) => {\n+            adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAssignOp(_, lhs, rhs) => {\n+        ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, None, expr, Some(lhs), [rhs], true);\n+                constrain_call(rcx, None, expr, Some(lhs.clone()),\n+                               [rhs.clone()], true);\n             }\n \n-            adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n+            adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprIndex(lhs, rhs) |\n-        ast::ExprBinary(_, lhs, rhs) if has_method_map => {\n+        ast::ExprIndex(ref lhs, ref rhs) |\n+        ast::ExprBinary(_, ref lhs, ref rhs) if has_method_map => {\n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, None, expr, Some(lhs), [rhs], true);\n+            constrain_call(rcx, None, expr, Some(lhs.clone()),\n+                           [rhs.clone()], true);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprUnary(_, lhs) if has_method_map => {\n+        ast::ExprUnary(_, ref lhs) if has_method_map => {\n             // As above.\n-            constrain_call(rcx, None, expr, Some(lhs), [], true);\n+            constrain_call(rcx, None, expr, Some(lhs.clone()), [], true);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprUnary(ast::UnDeref, base) => {\n+        ast::ExprUnary(ast::UnDeref, ref base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n             let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n-                    constrain_call(rcx, None, expr, Some(base), [], true);\n+                    constrain_call(rcx, None, expr, Some(base.clone()), [], true);\n                     ty::ty_fn_ret(method.ty)\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -516,15 +519,15 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprIndex(vec_expr, _) => {\n+        ast::ExprIndex(ref vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n-            let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n+            let vec_type = rcx.resolve_expr_type_adjusted(&**vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprCast(source, _) => {\n+        ast::ExprCast(ref source, _) => {\n             // Determine if we are casting `source` to a trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n@@ -543,7 +546,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 ty::ty_trait(box ty::TyTrait {\n                     store: ty::RegionTraitStore(trait_region, _), ..\n                 }) => {\n-                    let source_ty = rcx.resolve_expr_type_adjusted(source);\n+                    let source_ty = rcx.resolve_expr_type_adjusted(&**source);\n                     constrain_regions_in_type(\n                         rcx,\n                         trait_region,\n@@ -556,8 +559,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAddrOf(m, base) => {\n-            link_addr_of(rcx, expr, m, base);\n+        ast::ExprAddrOf(m, ref base) => {\n+            link_addr_of(rcx, expr, m, &**base);\n \n             // Require that when you write a `&expr` expression, the\n             // resulting pointer has a lifetime that encompasses the\n@@ -572,8 +575,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprMatch(discr, ref arms) => {\n-            link_match(rcx, discr, arms.as_slice());\n+        ast::ExprMatch(ref discr, ref arms) => {\n+            link_match(rcx, &**discr, arms.as_slice());\n \n             visit::walk_expr(rcx, expr, ());\n         }\n@@ -582,18 +585,18 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n \n-        ast::ExprLoop(body, _) => {\n+        ast::ExprLoop(ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(body.id);\n             visit::walk_expr(rcx, expr, ());\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n-        ast::ExprWhile(cond, body) => {\n+        ast::ExprWhile(ref cond, ref body) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n-            rcx.visit_expr(cond, ());\n+            rcx.visit_expr(&**cond, ());\n \n             rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(body, ());\n+            rcx.visit_block(&**body, ());\n \n             rcx.set_repeating_scope(repeating_scope);\n         }\n@@ -785,8 +788,8 @@ fn constrain_call(rcx: &mut Rcx,\n                   // operator\n                   fn_expr_id: Option<ast::NodeId>,\n                   call_expr: &ast::Expr,\n-                  receiver: Option<@ast::Expr>,\n-                  arg_exprs: &[@ast::Expr],\n+                  receiver: Option<Gc<ast::Expr>>,\n+                  arg_exprs: &[Gc<ast::Expr>],\n                   implicitly_ref_args: bool) {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n     //! and overloaded operators). Constrains the regions which appear\n@@ -820,7 +823,7 @@ fn constrain_call(rcx: &mut Rcx,\n     let callee_scope = call_expr.id;\n     let callee_region = ty::ReScope(callee_scope);\n \n-    for &arg_expr in arg_exprs.iter() {\n+    for arg_expr in arg_exprs.iter() {\n         debug!(\"Argument\");\n \n         // ensure that any regions appearing in the argument type are\n@@ -834,17 +837,17 @@ fn constrain_call(rcx: &mut Rcx,\n         // result. modes are going away and the \"DerefArgs\" code\n         // should be ported to use adjustments\n         if implicitly_ref_args {\n-            link_by_ref(rcx, arg_expr, callee_scope);\n+            link_by_ref(rcx, &**arg_expr, callee_scope);\n         }\n     }\n \n     // as loop above, but for receiver\n-    for &r in receiver.iter() {\n+    for r in receiver.iter() {\n         debug!(\"Receiver\");\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n-            link_by_ref(rcx, r, callee_scope);\n+            link_by_ref(rcx, &**r, callee_scope);\n         }\n     }\n \n@@ -1054,11 +1057,11 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n     debug!(\"regionck::for_local()\");\n     let init_expr = match local.init {\n         None => { return; }\n-        Some(expr) => expr,\n+        Some(ref expr) => expr,\n     };\n     let mc = mc::MemCategorizationContext::new(rcx);\n-    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-    link_pattern(rcx, mc, discr_cmt, local.pat);\n+    let discr_cmt = ignore_err!(mc.cat_expr(&**init_expr));\n+    link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n \n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n@@ -1073,8 +1076,8 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n     for arm in arms.iter() {\n-        for &root_pat in arm.pats.iter() {\n-            link_pattern(rcx, mc, discr_cmt.clone(), root_pat);\n+        for root_pat in arm.pats.iter() {\n+            link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n         }\n     }\n }\n@@ -1098,8 +1101,8 @@ fn link_pattern(rcx: &Rcx,\n                 }\n \n                 // `[_, ..slice, _]` pattern\n-                ast::PatVec(_, Some(slice_pat), _) => {\n-                    match mc.cat_slice_pattern(sub_cmt, slice_pat) {\n+                ast::PatVec(_, Some(ref slice_pat), _) => {\n+                    match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n                             link_region(rcx, sub_pat.span, slice_r,\n                                         ty::BorrowKind::from_mutbl(slice_mutbl),"}, {"sha": "b4dbccd9bb21dd9b635e564748fa614022018537", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -666,10 +666,10 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n           None => {}\n         }\n       }\n-      ast::ExprCast(src, _) => {\n+      ast::ExprCast(ref src, _) => {\n           debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n-          resolve_object_cast(src, target_ty);\n+          resolve_object_cast(&**src, target_ty);\n       }\n       _ => ()\n     }"}, {"sha": "d503f8bedb6d8ca72b33a6e5df57c64d3bd27b8d", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -53,10 +53,10 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     let mut wbcx = WritebackCx::new(fcx);\n     wbcx.visit_block(blk, ());\n     for arg in decl.inputs.iter() {\n-        wbcx.visit_pat(arg.pat, ());\n+        wbcx.visit_pat(&*arg.pat, ());\n \n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&fcx.tcx().def_map, arg.pat) {\n+        if !pat_util::pat_is_binding(&fcx.tcx().def_map, &*arg.pat) {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n                                arg.pat.id);\n         }"}, {"sha": "d2053760467023a9886059beb74f2b3f904cc3ce", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -129,6 +129,14 @@ fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n                     _ => {}\n                 }\n             }\n+            ty_box(..) => {\n+                match tcx.lang_items.gc() {\n+                    Some(did) if did.krate == ast::LOCAL_CRATE => {\n+                        found_nominal = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n \n             _ => { }\n         }\n@@ -203,8 +211,8 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n                 // Then visit the module items.\n                 visit::walk_mod(self, module_, ());\n             }\n-            ItemImpl(_, None, ast_ty, _) => {\n-                if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n+            ItemImpl(_, None, ref ast_ty, _) => {\n+                if !self.cc.ast_type_is_defined_in_local_crate(&**ast_ty) {\n                     // This is an error.\n                     let session = &self.cc.crate_context.tcx.sess;\n                     session.span_err(item.span,"}, {"sha": "f1de8ff6daba994454c609f936c581b0dc8bca0d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -50,6 +50,8 @@ use util::ppaux::Repr;\n \n use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n+use std::gc::Gc;\n+\n use syntax::abi;\n use syntax::ast::{StaticRegionTyParamBound, OtherRegionTyParamBound};\n use syntax::ast::{TraitTyParamBound, UnboxedFnTyParamBound};\n@@ -117,10 +119,10 @@ impl<'a> AstConv for CrateCtxt<'a> {\n         }\n \n         match self.tcx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => ty_of_item(self, item),\n+            Some(ast_map::NodeItem(item)) => ty_of_item(self, &*item),\n             Some(ast_map::NodeForeignItem(foreign_item)) => {\n                 let abi = self.tcx.map.get_foreign_abi(id.node);\n-                ty_of_foreign_item(self, foreign_item, abi)\n+                ty_of_foreign_item(self, &*foreign_item, abi)\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n@@ -156,7 +158,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         let result_ty = match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n-                let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, va.ty)).collect();\n+                let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n                 ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n \n@@ -170,7 +172,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx, struct_def, tpt, variant.node.id);\n+                convert_struct(ccx, &*struct_def, tpt, variant.node.id);\n \n                 let input_tys: Vec<_> = struct_def.fields.iter().map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id)).collect();\n@@ -205,14 +207,14 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_ty_generics,\n                                     &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.fn_style, m.decl)\n+                                    &m.generics, &m.fn_style, &*m.decl)\n                             }\n \n                             &ast::Provided(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_ty_generics,\n                                     &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.fn_style, m.decl)\n+                                    &m.generics, &m.fn_style, &*m.decl)\n                             }\n                         });\n \n@@ -454,7 +456,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n                      struct_generics: &ty::Generics,\n                      v: &ast::StructField,\n                      origin: ast::DefId) -> ty::field_ty {\n-    let tt = ccx.to_ty(&ExplicitRscope, v.node.ty);\n+    let tt = ccx.to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n@@ -485,7 +487,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n \n fn convert_methods(ccx: &CrateCtxt,\n                    container: MethodContainer,\n-                   ms: &[@ast::Method],\n+                   ms: &[Gc<ast::Method>],\n                    untransformed_rcvr_ty: ty::t,\n                    rcvr_ty_generics: &ty::Generics,\n                    rcvr_ast_generics: &ast::Generics,\n@@ -503,7 +505,7 @@ fn convert_methods(ccx: &CrateCtxt,\n                                                          num_rcvr_ty_params);\n         let mty = Rc::new(ty_of_method(ccx,\n                                        container,\n-                                       *m,\n+                                       &**m,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ast_generics,\n                                        rcvr_visibility));\n@@ -542,7 +544,7 @@ fn convert_methods(ccx: &CrateCtxt,\n     {\n         let fty = astconv::ty_of_method(ccx, m.id, m.fn_style,\n                                         untransformed_rcvr_ty,\n-                                        m.explicit_self, m.decl);\n+                                        m.explicit_self, &*m.decl);\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -608,7 +610,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         },\n         ast::ItemImpl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n+            let selfty = ccx.to_ty(&ExplicitRscope, &*selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id),\n@@ -671,13 +673,13 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // Write the super-struct type, if it exists.\n             match struct_def.super_struct {\n                 Some(ty) => {\n-                    let supserty = ccx.to_ty(&ExplicitRscope, ty);\n+                    let supserty = ccx.to_ty(&ExplicitRscope, &*ty);\n                     write_ty_to_tcx(tcx, it.id, supserty);\n                 },\n                 _ => {},\n             }\n \n-            convert_struct(ccx, struct_def, tpt, it.id);\n+            convert_struct(ccx, &*struct_def, tpt, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -855,7 +857,7 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     }\n \n     match ccx.tcx.map.get(trait_id.node) {\n-        ast_map::NodeItem(item) => trait_def_of_item(ccx, item),\n+        ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n             ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n                                      trait_id.node).as_slice())\n@@ -910,7 +912,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n     }\n     match it.node {\n         ast::ItemStatic(t, _, _) => {\n-            let typ = ccx.to_ty(&ExplicitRscope, t);\n+            let typ = ccx.to_ty(&ExplicitRscope, &*t);\n             let tpt = no_params(typ);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n@@ -922,7 +924,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                                               it.id,\n                                               fn_style,\n                                               abi,\n-                                              decl);\n+                                              &*decl);\n             let tpt = ty_param_bounds_and_ty {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n@@ -942,7 +944,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             }\n \n             let tpt = {\n-                let ty = ccx.to_ty(&ExplicitRscope, t);\n+                let ty = ccx.to_ty(&ExplicitRscope, &*t);\n                 ty_param_bounds_and_ty {\n                     generics: ty_generics_for_type(ccx, generics),\n                     ty: ty\n@@ -992,7 +994,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n     match it.node {\n         ast::ForeignItemFn(fn_decl, ref generics) => {\n             ty_of_foreign_fn_decl(ccx,\n-                                  fn_decl,\n+                                  &*fn_decl,\n                                   local_def(it.id),\n                                   generics,\n                                   abi)\n@@ -1003,7 +1005,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                     type_param_defs: Rc::new(Vec::new()),\n                     region_param_defs: Rc::new(Vec::new()),\n                 },\n-                ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n+                ty: ast_ty_to_ty(ccx, &ExplicitRscope, &*t)\n             }\n         }\n     }\n@@ -1047,7 +1049,7 @@ fn ty_generics(ccx: &CrateCtxt,\n                                                     param.ident,\n                                                     param.span));\n                 let default = param.default.map(|path| {\n-                    let ty = ast_ty_to_ty(ccx, &ExplicitRscope, path);\n+                    let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*path);\n                     let cur_idx = param_ty.idx;\n \n                     ty::walk_ty(ty, |t| {\n@@ -1201,7 +1203,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                         .map(|a| ty_of_arg(ccx, &rb, a, None))\n                         .collect();\n \n-    let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n+    let output_ty = ast_ty_to_ty(ccx, &rb, &*decl.output);\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,"}, {"sha": "7c313d53b2c3e414bdd12e68c5bfc1f2b2ff54fb", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -1140,7 +1140,7 @@ impl<'a> Rebuilder<'a> {\n                 }\n                 ref other => other.clone()\n             };\n-            @ast::Ty { id: from.id, node: new_node, span: from.span }\n+            box(GC) ast::Ty { id: from.id, node: new_node, span: from.span }\n         }\n \n         let new_ty_node = match to.node {\n@@ -1155,7 +1155,7 @@ impl<'a> Rebuilder<'a> {\n             }\n             _ => fail!(\"expect ast::TyRptr or ast::TyPath\")\n         };\n-        let new_ty = @ast::Ty {\n+        let new_ty = box(GC) ast::Ty {\n             id: to.id,\n             node: new_ty_node,\n             span: to.span"}, {"sha": "80bc09904ec18817cc91c017afacab26289213f8", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -479,13 +479,13 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n                 // `ty::VariantInfo::from_ast_variant()` ourselves\n                 // here, mainly so as to mask the differences between\n                 // struct-like enums and so forth.\n-                for &ast_variant in enum_definition.variants.iter() {\n+                for ast_variant in enum_definition.variants.iter() {\n                     let variant =\n                         ty::VariantInfo::from_ast_variant(tcx,\n-                                                          ast_variant,\n+                                                          &**ast_variant,\n                                                           /*discriminant*/ 0);\n-                    for &arg_ty in variant.args.iter() {\n-                        self.add_constraints_from_ty(arg_ty, self.covariant);\n+                    for arg_ty in variant.args.iter() {\n+                        self.add_constraints_from_ty(*arg_ty, self.covariant);\n                     }\n                 }\n             }"}, {"sha": "3dd056969d665e8983c4e67dec61c78bae702430", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -102,6 +102,6 @@ pub fn block_query(b: ast::P<ast::Block>, p: |&ast::Expr| -> bool) -> bool {\n         p: p,\n         flag: false,\n     };\n-    visit::walk_block(&mut v, b, ());\n+    visit::walk_block(&mut v, &*b, ());\n     return v.flag;\n }"}, {"sha": "251b7ed3c15065ed2877beebc5aee0296b487ba8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -25,7 +25,7 @@ use middle::ty;\n use middle::typeck;\n \n use std::rc::Rc;\n-use std::string::String;\n+use std::gc::Gc;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n@@ -510,7 +510,7 @@ impl<T:Repr> Repr for Rc<T> {\n     }\n }\n \n-impl<T:Repr> Repr for @T {\n+impl<T:Repr + 'static> Repr for Gc<T> {\n     fn repr(&self, tcx: &ctxt) -> String {\n         (&**self).repr(tcx)\n     }"}, {"sha": "db65939bdfcc7fb182f57c3624d1eb4a0a0364f8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -31,6 +31,7 @@ use rustc::middle::ty;\n \n use std::rc::Rc;\n use std::u32;\n+use std::gc::Gc;\n \n use core;\n use doctree;\n@@ -52,7 +53,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<U> for @T {\n+impl<T: Clean<U>, U> Clean<U> for Gc<T> {\n     fn clean(&self) -> U {\n         (**self).clean()\n     }\n@@ -428,12 +429,12 @@ impl attr::AttrMetaMethods for Attribute {\n             _ => None,\n         }\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n }\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -864,7 +865,7 @@ pub struct Argument {\n impl Clean<Argument> for ast::Arg {\n     fn clean(&self) -> Argument {\n         Argument {\n-            name: name_from_pat(self.pat),\n+            name: name_from_pat(&*self.pat),\n             type_: (self.ty.clean()),\n             id: self.id\n         }\n@@ -1745,7 +1746,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                                                          remaining,\n                                                          b.clone());\n                             let path = syntax::codemap::dummy_spanned(path);\n-                            ret.push(convert(&ast::ViewItemUse(@path)));\n+                            ret.push(convert(&ast::ViewItemUse(box(GC) path)));\n                         }\n                     }\n                     ast::ViewPathSimple(_, _, id) => {\n@@ -1913,8 +1914,8 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n         PatTup(..) => \"(tuple arg NYI)\".to_string(),\n-        PatBox(p) => name_from_pat(p),\n-        PatRegion(p) => name_from_pat(p),\n+        PatBox(p) => name_from_pat(&*p),\n+        PatRegion(p) => name_from_pat(&*p),\n         PatLit(..) => {\n             warn!(\"tried to get argument name from PatLit, \\\n                   which is silly in function arguments\");"}, {"sha": "c206d203ee8ac35c4d60f91db58feb901d2ebd9a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -95,7 +95,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     let mut cfg = build_configuration(&sess);\n     for cfg_ in cfgs.move_iter() {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n-        cfg.push(@dummy_spanned(ast::MetaWord(cfg_)));\n+        cfg.push(box(GC) dummy_spanned(ast::MetaWord(cfg_)));\n     }\n \n     let krate = phase_1_parse_input(&sess, cfg, &input);\n@@ -128,11 +128,11 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, path: &Path)\n                 -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n-    let ctxt = @ctxt;\n+    let ctxt = box(GC) ctxt;\n     super::ctxtkey.replace(Some(ctxt));\n \n     let krate = {\n-        let mut v = RustdocVisitor::new(ctxt, Some(&analysis));\n+        let mut v = RustdocVisitor::new(&*ctxt, Some(&analysis));\n         v.visit(&ctxt.krate);\n         v.clean()\n     };"}, {"sha": "b8a2a6195b7a539ab09507485823bc492960c544", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,6 +16,8 @@ use syntax::codemap::Span;\n use syntax::ast;\n use syntax::ast::{Ident, NodeId};\n \n+use std::gc::Gc;\n+\n pub struct Module {\n     pub name: Option<Ident>,\n     pub attrs: Vec<ast::Attribute>,\n@@ -133,7 +135,7 @@ pub struct Typedef {\n pub struct Static {\n     pub type_: ast::P<ast::Ty>,\n     pub mutability: ast::Mutability,\n-    pub expr: @ast::Expr,\n+    pub expr: Gc<ast::Expr>,\n     pub name: Ident,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: ast::Visibility,\n@@ -156,7 +158,7 @@ pub struct Impl {\n     pub generics: ast::Generics,\n     pub trait_: Option<ast::TraitRef>,\n     pub for_: ast::P<ast::Ty>,\n-    pub methods: Vec<@ast::Method>,\n+    pub methods: Vec<Gc<ast::Method>>,\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n     pub vis: ast::Visibility,"}, {"sha": "e2222799e928242ba10ff0a06b3b93d0da867848", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -37,6 +37,7 @@ extern crate log;\n use std::io;\n use std::io::{File, MemWriter};\n use std::str;\n+use std::gc::Gc;\n use serialize::{json, Decodable, Encodable};\n \n // reexported from `clean` so it can be easily updated with the mod itself\n@@ -85,7 +86,7 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n     \"unindent-comments\",\n ];\n \n-local_data_key!(pub ctxtkey: @core::DocContext)\n+local_data_key!(pub ctxtkey: Gc<core::DocContext>)\n local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n type Output = (clean::Crate, Vec<plugins::PluginJson> );"}, {"sha": "3b19dc3d0196b4571f643084e11bf9c92318e7c3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -64,13 +64,13 @@ pub fn run(input: &str,\n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(cfgs.move_iter().map(|cfg_| {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n-        @dummy_spanned(ast::MetaWord(cfg_))\n+        box(GC) dummy_spanned(ast::MetaWord(cfg_))\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n                                                           &from_str(\"rustdoc-test\").unwrap());\n \n-    let ctx = @core::DocContext {\n+    let ctx = box(GC) core::DocContext {\n         krate: krate,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n@@ -82,7 +82,7 @@ pub fn run(input: &str,\n     };\n     super::ctxtkey.replace(Some(ctx));\n \n-    let mut v = RustdocVisitor::new(ctx, None);\n+    let mut v = RustdocVisitor::new(&*ctx, None);\n     v.visit(&ctx.krate);\n     let krate = v.clean();\n     let (krate, _) = passes::unindent_comments(krate);"}, {"sha": "555b396b44945e600703f4fd1d5383c66a40bfc4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -18,6 +18,8 @@ use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n+use std::gc::Gc;\n+\n use core;\n use doctree::*;\n \n@@ -54,10 +56,10 @@ impl<'a> RustdocVisitor<'a> {\n         self.module.is_crate = true;\n     }\n \n-    pub fn visit_struct_def(&mut self, item: &ast::Item, sd: @ast::StructDef,\n+    pub fn visit_struct_def(&mut self, item: &ast::Item, sd: Gc<ast::StructDef>,\n                             generics: &ast::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n-        let struct_type = struct_type_from_def(sd);\n+        let struct_type = struct_type_from_def(&*sd);\n         Struct {\n             id: item.id,\n             struct_type: struct_type,\n@@ -125,7 +127,7 @@ impl<'a> RustdocVisitor<'a> {\n         om.vis = vis;\n         om.id = id;\n         for i in m.items.iter() {\n-            self.visit_item(*i, &mut om);\n+            self.visit_item(&**i, &mut om);\n         }\n         om\n     }\n@@ -159,9 +161,9 @@ impl<'a> RustdocVisitor<'a> {\n         om.view_items.push(item);\n     }\n \n-    fn visit_view_path(&mut self, path: @ast::ViewPath,\n+    fn visit_view_path(&mut self, path: Gc<ast::ViewPath>,\n                        om: &mut Module,\n-                       please_inline: bool) -> Option<@ast::ViewPath> {\n+                       please_inline: bool) -> Option<Gc<ast::ViewPath>> {\n         match path.node {\n             ast::ViewPathSimple(_, _, id) => {\n                 if self.resolve_id(id, false, om, please_inline) { return None }\n@@ -175,7 +177,7 @@ impl<'a> RustdocVisitor<'a> {\n                 }\n \n                 if mine.len() == 0 { return None }\n-                return Some(@::syntax::codemap::Spanned {\n+                return Some(box(GC) ::syntax::codemap::Spanned {\n                     node: ast::ViewPathList(p.clone(), mine, b.clone()),\n                     span: path.span,\n                 })\n@@ -213,13 +215,13 @@ impl<'a> RustdocVisitor<'a> {\n                                 self.visit_view_item(vi, om);\n                             }\n                             for i in m.items.iter() {\n-                                self.visit_item(*i, om);\n+                                self.visit_item(&**i, om);\n                             }\n                         }\n                         _ => { fail!(\"glob not mapped to a module\"); }\n                     }\n                 } else {\n-                    self.visit_item(it, om);\n+                    self.visit_item(&*it, om);\n                 }\n                 true\n             }\n@@ -245,8 +247,8 @@ impl<'a> RustdocVisitor<'a> {\n                 om.enums.push(self.visit_enum_def(item, ed, gen)),\n             ast::ItemStruct(sd, ref gen) =>\n                 om.structs.push(self.visit_struct_def(item, sd, gen)),\n-            ast::ItemFn(fd, ref pur, ref abi, ref gen, _) =>\n-                om.fns.push(self.visit_fn(item, fd, pur, abi, gen)),\n+            ast::ItemFn(ref fd, ref pur, ref abi, ref gen, _) =>\n+                om.fns.push(self.visit_fn(item, &**fd, pur, abi, gen)),\n             ast::ItemTy(ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty,"}, {"sha": "d4987bd0afe0bb362911c9b31ee8c6efe8a8fb8c", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,6 +16,7 @@ Core encoding and decoding interfaces.\n \n use std::path;\n use std::rc::Rc;\n+use std::gc::Gc;\n \n pub trait Encoder<E> {\n     // Primitive types:\n@@ -387,7 +388,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Box<T> {\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for @T {\n+impl<E, S:Encoder<E>,T:'static + Encodable<S, E>> Encodable<S, E> for Gc<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n@@ -407,9 +408,9 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Rc<T> {\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E> + 'static> Decodable<D, E> for @T {\n-    fn decode(d: &mut D) -> Result<@T, E> {\n-        Ok(@try!(Decodable::decode(d)))\n+impl<E, D:Decoder<E>,T:Decodable<D, E> + 'static> Decodable<D, E> for Gc<T> {\n+    fn decode(d: &mut D) -> Result<Gc<T>, E> {\n+        Ok(box(GC) try!(Decodable::decode(d)))\n     }\n }\n "}, {"sha": "b57920e002c88a2bde79eeebb600d382ff946194", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -18,52 +18,32 @@ collector is task-local so `Gc<T>` is not sendable.\n \n #![allow(experimental)]\n \n-use kinds::marker;\n use clone::Clone;\n+use cmp::{Ord, PartialOrd, Ordering, Eq, PartialEq};\n+use default::Default;\n+use fmt;\n+use hash;\n+use kinds::marker;\n+use ops::Deref;\n+use raw;\n \n /// Immutable garbage-collected pointer type\n #[lang=\"gc\"]\n-#[cfg(not(test))]\n #[experimental = \"Gc is currently based on reference-counting and will not collect cycles until \\\n                   task annihilation. For now, cycles need to be broken manually by using `Rc<T>` \\\n                   with a non-owning `Weak<T>` pointer. A tracing garbage collector is planned.\"]\n pub struct Gc<T> {\n+    #[cfg(stage0)]\n     ptr: @T,\n+    #[cfg(not(stage0))]\n+    _ptr: *T,\n     marker: marker::NoSend,\n }\n \n-#[cfg(test)]\n-pub struct Gc<T> {\n-    ptr: @T,\n-    marker: marker::NoSend,\n-}\n-\n-impl<T: 'static> Gc<T> {\n-    /// Construct a new garbage-collected box\n-    #[inline]\n-    pub fn new(value: T) -> Gc<T> {\n-        Gc { ptr: @value, marker: marker::NoSend }\n-    }\n-\n-    /// Borrow the value contained in the garbage-collected box\n-    #[inline]\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n-        &*self.ptr\n-    }\n-\n-    /// Determine if two garbage-collected boxes point to the same object\n-    #[inline]\n-    pub fn ptr_eq(&self, other: &Gc<T>) -> bool {\n-        self.borrow() as *T == other.borrow() as *T\n-    }\n-}\n-\n impl<T> Clone for Gc<T> {\n     /// Clone the pointer only\n     #[inline]\n-    fn clone(&self) -> Gc<T> {\n-        Gc{ ptr: self.ptr, marker: marker::NoSend }\n-    }\n+    fn clone(&self) -> Gc<T> { *self }\n }\n \n /// An value that represents the task-local managed heap.\n@@ -73,8 +53,54 @@ impl<T> Clone for Gc<T> {\n #[cfg(not(test))]\n pub static GC: () = ();\n \n-#[cfg(test)]\n-pub static GC: () = ();\n+impl<T: PartialEq + 'static> PartialEq for Gc<T> {\n+    #[inline]\n+    fn eq(&self, other: &Gc<T>) -> bool { *(*self) == *(*other) }\n+    #[inline]\n+    fn ne(&self, other: &Gc<T>) -> bool { *(*self) != *(*other) }\n+}\n+impl<T: PartialOrd + 'static> PartialOrd for Gc<T> {\n+    #[inline]\n+    fn lt(&self, other: &Gc<T>) -> bool { *(*self) < *(*other) }\n+    #[inline]\n+    fn le(&self, other: &Gc<T>) -> bool { *(*self) <= *(*other) }\n+    #[inline]\n+    fn ge(&self, other: &Gc<T>) -> bool { *(*self) >= *(*other) }\n+    #[inline]\n+    fn gt(&self, other: &Gc<T>) -> bool { *(*self) > *(*other) }\n+}\n+impl<T: Ord + 'static> Ord for Gc<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Gc<T>) -> Ordering { (**self).cmp(&**other) }\n+}\n+impl<T: Eq + 'static> Eq for Gc<T> {}\n+\n+impl<T: 'static> Deref<T> for Gc<T> {\n+    #[cfg(stage0)]\n+    fn deref<'a>(&'a self) -> &'a T { &*self.ptr }\n+    #[cfg(not(stage0))]\n+    fn deref<'a>(&'a self) -> &'a T { &**self }\n+}\n+\n+impl<T: Default + 'static> Default for Gc<T> {\n+    fn default() -> Gc<T> {\n+        box(GC) Default::default()\n+    }\n+}\n+\n+impl<T: 'static> raw::Repr<*raw::Box<T>> for Gc<T> {}\n+\n+impl<S: hash::Writer, T: hash::Hash<S> + 'static> hash::Hash<S> for Gc<T> {\n+    fn hash(&self, s: &mut S) {\n+        (**self).hash(s)\n+    }\n+}\n+\n+impl<T: 'static + fmt::Show> fmt::Show for Gc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "318410c45c1fe9902db72da2cbb29b65e5b3c3ee", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -135,6 +135,8 @@ extern crate rustrt;\n #[cfg(test)] pub use realstd::ops;\n #[cfg(test)] pub use realstd::cmp;\n #[cfg(test)] pub use realstd::ty;\n+#[cfg(test)] pub use realstd::owned;\n+#[cfg(test)] pub use realstd::gc;\n \n \n // NB: These reexports are in the order they should be listed in rustdoc\n@@ -219,6 +221,7 @@ pub mod rand;\n \n pub mod ascii;\n \n+#[cfg(not(test))]\n pub mod gc;\n \n /* Common traits */"}, {"sha": "7c1e82a2a6f7272ddcf68bec50661e84ddee7ad3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 74, "deletions": 73, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -21,15 +21,16 @@ use std::fmt;\n use std::fmt::Show;\n use std::option::Option;\n use std::rc::Rc;\n+use std::gc::Gc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A pointer abstraction. FIXME(eddyb) #10676 use Rc<T> in the future.\n-pub type P<T> = @T;\n+pub type P<T> = Gc<T>;\n \n #[allow(non_snake_case_functions)]\n /// Construct a P<T> from a T value.\n pub fn P<T: 'static>(value: T) -> P<T> {\n-    @value\n+    box(GC) value\n }\n \n // FIXME #6993: in librustc, uses of \"ident\" should be replaced\n@@ -217,7 +218,7 @@ pub enum DefRegion {\n \n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n-pub type CrateConfig = Vec<@MetaItem> ;\n+pub type CrateConfig = Vec<Gc<MetaItem>>;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Crate {\n@@ -232,7 +233,7 @@ pub type MetaItem = Spanned<MetaItem_>;\n #[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n-    MetaList(InternedString, Vec<@MetaItem> ),\n+    MetaList(InternedString, Vec<Gc<MetaItem>>),\n     MetaNameValue(InternedString, Lit),\n }\n \n@@ -264,8 +265,8 @@ impl PartialEq for MetaItem_ {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Block {\n     pub view_items: Vec<ViewItem>,\n-    pub stmts: Vec<@Stmt>,\n-    pub expr: Option<@Expr>,\n+    pub stmts: Vec<Gc<Stmt>>,\n+    pub expr: Option<Gc<Expr>>,\n     pub id: NodeId,\n     pub rules: BlockCheckMode,\n     pub span: Span,\n@@ -281,7 +282,7 @@ pub struct Pat {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct FieldPat {\n     pub ident: Ident,\n-    pub pat: @Pat,\n+    pub pat: Gc<Pat>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -301,18 +302,18 @@ pub enum Pat_ {\n     // which it is. The resolver determines this, and\n     // records this pattern's NodeId in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    PatIdent(BindingMode, Path, Option<@Pat>),\n-    PatEnum(Path, Option<Vec<@Pat> >), /* \"none\" means a * pattern where\n+    PatIdent(BindingMode, Path, Option<Gc<Pat>>),\n+    PatEnum(Path, Option<Vec<Gc<Pat>>>), /* \"none\" means a * pattern where\n                                      * we don't bind the fields to names */\n-    PatStruct(Path, Vec<FieldPat> , bool),\n-    PatTup(Vec<@Pat> ),\n-    PatBox(@Pat),\n-    PatRegion(@Pat), // reference pattern\n-    PatLit(@Expr),\n-    PatRange(@Expr, @Expr),\n+    PatStruct(Path, Vec<FieldPat>, bool),\n+    PatTup(Vec<Gc<Pat>>),\n+    PatBox(Gc<Pat>),\n+    PatRegion(Gc<Pat>), // reference pattern\n+    PatLit(Gc<Expr>),\n+    PatRange(Gc<Expr>, Gc<Expr>),\n     // [a, b, ..i, y, z] is represented as\n     // PatVec(~[a, b], Some(i), ~[y, z])\n-    PatVec(Vec<@Pat> , Option<@Pat>, Vec<@Pat> ),\n+    PatVec(Vec<Gc<Pat>>, Option<Gc<Pat>>, Vec<Gc<Pat>>),\n     PatMac(Mac),\n }\n \n@@ -365,13 +366,13 @@ pub type Stmt = Spanned<Stmt_>;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Stmt_ {\n     // could be an item or a local (let) binding:\n-    StmtDecl(@Decl, NodeId),\n+    StmtDecl(Gc<Decl>, NodeId),\n \n     // expr without trailing semi-colon (must have unit type):\n-    StmtExpr(@Expr, NodeId),\n+    StmtExpr(Gc<Expr>, NodeId),\n \n     // expr with trailing semi-colon (may have any type):\n-    StmtSemi(@Expr, NodeId),\n+    StmtSemi(Gc<Expr>, NodeId),\n \n     // bool: is there a trailing sem-colon?\n     StmtMac(Mac, bool),\n@@ -391,8 +392,8 @@ pub enum LocalSource {\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Local {\n     pub ty: P<Ty>,\n-    pub pat: @Pat,\n-    pub init: Option<@Expr>,\n+    pub pat: Gc<Pat>,\n+    pub init: Option<Gc<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n     pub source: LocalSource,\n@@ -403,23 +404,23 @@ pub type Decl = Spanned<Decl_>;\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Decl_ {\n     // a local (let) binding:\n-    DeclLocal(@Local),\n+    DeclLocal(Gc<Local>),\n     // an item binding:\n-    DeclItem(@Item),\n+    DeclItem(Gc<Item>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n-    pub pats: Vec<@Pat>,\n-    pub guard: Option<@Expr>,\n-    pub body: @Expr,\n+    pub pats: Vec<Gc<Pat>>,\n+    pub guard: Option<Gc<Expr>>,\n+    pub body: Gc<Expr>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Field {\n     pub ident: SpannedIdent,\n-    pub expr: @Expr,\n+    pub expr: Gc<Expr>,\n     pub span: Span,\n }\n \n@@ -446,56 +447,56 @@ pub struct Expr {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Expr_ {\n-    ExprVstore(@Expr, ExprVstore),\n+    ExprVstore(Gc<Expr>, ExprVstore),\n     // First expr is the place; second expr is the value.\n-    ExprBox(@Expr, @Expr),\n-    ExprVec(Vec<@Expr>),\n-    ExprCall(@Expr, Vec<@Expr>),\n-    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<@Expr>),\n-    ExprTup(Vec<@Expr>),\n-    ExprBinary(BinOp, @Expr, @Expr),\n-    ExprUnary(UnOp, @Expr),\n-    ExprLit(@Lit),\n-    ExprCast(@Expr, P<Ty>),\n-    ExprIf(@Expr, P<Block>, Option<@Expr>),\n-    ExprWhile(@Expr, P<Block>),\n+    ExprBox(Gc<Expr>, Gc<Expr>),\n+    ExprVec(Vec<Gc<Expr>>),\n+    ExprCall(Gc<Expr>, Vec<Gc<Expr>>),\n+    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<Gc<Expr>>),\n+    ExprTup(Vec<Gc<Expr>>),\n+    ExprBinary(BinOp, Gc<Expr>, Gc<Expr>),\n+    ExprUnary(UnOp, Gc<Expr>),\n+    ExprLit(Gc<Lit>),\n+    ExprCast(Gc<Expr>, P<Ty>),\n+    ExprIf(Gc<Expr>, P<Block>, Option<Gc<Expr>>),\n+    ExprWhile(Gc<Expr>, P<Block>),\n     // FIXME #6993: change to Option<Name>\n-    ExprForLoop(@Pat, @Expr, P<Block>, Option<Ident>),\n+    ExprForLoop(Gc<Pat>, Gc<Expr>, P<Block>, Option<Ident>),\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name>\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(@Expr, Vec<Arm>),\n+    ExprMatch(Gc<Expr>, Vec<Arm>),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n-    ExprAssign(@Expr, @Expr),\n-    ExprAssignOp(BinOp, @Expr, @Expr),\n-    ExprField(@Expr, Ident, Vec<P<Ty>>),\n-    ExprIndex(@Expr, @Expr),\n+    ExprAssign(Gc<Expr>, Gc<Expr>),\n+    ExprAssignOp(BinOp, Gc<Expr>, Gc<Expr>),\n+    ExprField(Gc<Expr>, Ident, Vec<P<Ty>>),\n+    ExprIndex(Gc<Expr>, Gc<Expr>),\n \n     /// Expression that looks like a \"name\". For example,\n     /// `std::slice::from_elem::<uint>` is an ExprPath that's the \"name\" part\n     /// of a function call.\n     ExprPath(Path),\n \n-    ExprAddrOf(Mutability, @Expr),\n+    ExprAddrOf(Mutability, Gc<Expr>),\n     ExprBreak(Option<Ident>),\n     ExprAgain(Option<Ident>),\n-    ExprRet(Option<@Expr>),\n+    ExprRet(Option<Gc<Expr>>),\n \n     ExprInlineAsm(InlineAsm),\n \n     ExprMac(Mac),\n \n     // A struct literal expression.\n-    ExprStruct(Path, Vec<Field> , Option<@Expr> /* base */),\n+    ExprStruct(Path, Vec<Field> , Option<Gc<Expr>> /* base */),\n \n     // A vector literal constructed from one repeated element.\n-    ExprRepeat(@Expr /* element */, @Expr /* count */),\n+    ExprRepeat(Gc<Expr> /* element */, Gc<Expr> /* count */),\n \n     // No-op: used solely so we can pretty-print faithfully\n-    ExprParen(@Expr)\n+    ExprParen(Gc<Expr>)\n }\n \n // When the main rust parser encounters a syntax-extension invocation, it\n@@ -667,7 +668,7 @@ pub struct TypeMethod {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum TraitMethod {\n     Required(TypeMethod),\n-    Provided(@Method),\n+    Provided(Gc<Method>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -782,16 +783,16 @@ pub enum Ty_ {\n     TyBox(P<Ty>),\n     TyUniq(P<Ty>),\n     TyVec(P<Ty>),\n-    TyFixedLengthVec(P<Ty>, @Expr),\n+    TyFixedLengthVec(P<Ty>, Gc<Expr>),\n     TyPtr(MutTy),\n     TyRptr(Option<Lifetime>, MutTy),\n-    TyClosure(@ClosureTy, Option<Lifetime>),\n-    TyProc(@ClosureTy),\n-    TyBareFn(@BareFnTy),\n-    TyUnboxedFn(@UnboxedFnTy),\n+    TyClosure(Gc<ClosureTy>, Option<Lifetime>),\n+    TyProc(Gc<ClosureTy>),\n+    TyBareFn(Gc<BareFnTy>),\n+    TyUnboxedFn(Gc<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<OwnedSlice<TyParamBound>>, NodeId), // for #7264; see above\n-    TyTypeof(@Expr),\n+    TyTypeof(Gc<Expr>),\n     // TyInfer means the type should be inferred instead of it having been\n     // specified. This can appear anywhere in a type.\n     TyInfer,\n@@ -808,8 +809,8 @@ pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n     pub clobbers: InternedString,\n-    pub inputs: Vec<(InternedString, @Expr)>,\n-    pub outputs: Vec<(InternedString, @Expr)>,\n+    pub inputs: Vec<(InternedString, Gc<Expr>)>,\n+    pub outputs: Vec<(InternedString, Gc<Expr>)>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect\n@@ -818,7 +819,7 @@ pub struct InlineAsm {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arg {\n     pub ty: P<Ty>,\n-    pub pat: @Pat,\n+    pub pat: Gc<Pat>,\n     pub id: NodeId,\n }\n \n@@ -832,7 +833,7 @@ impl Arg {\n                 node: TyInfer,\n                 span: DUMMY_SP,\n             }),\n-            pat: @Pat {\n+            pat: box(GC) Pat {\n                 id: DUMMY_NODE_ID,\n                 node: PatIdent(BindByValue(mutability), path, None),\n                 span: span\n@@ -903,14 +904,14 @@ pub struct Mod {\n     /// to the last token in the external file.\n     pub inner: Span,\n     pub view_items: Vec<ViewItem>,\n-    pub items: Vec<@Item>,\n+    pub items: Vec<Gc<Item>>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n-    pub items: Vec<@ForeignItem>,\n+    pub items: Vec<Gc<ForeignItem>>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -922,7 +923,7 @@ pub struct VariantArg {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n-    StructVariantKind(@StructDef),\n+    StructVariantKind(Gc<StructDef>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -936,7 +937,7 @@ pub struct Variant_ {\n     pub attrs: Vec<Attribute>,\n     pub kind: VariantKind,\n     pub id: NodeId,\n-    pub disr_expr: Option<@Expr>,\n+    pub disr_expr: Option<Gc<Expr>>,\n     pub vis: Visibility,\n }\n \n@@ -984,7 +985,7 @@ pub enum ViewItem_ {\n     // (containing arbitrary characters) from which to fetch the crate sources\n     // For example, extern crate whatever = \"github.com/mozilla/rust\"\n     ViewItemExternCrate(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(@ViewPath),\n+    ViewItemUse(Gc<ViewPath>),\n }\n \n // Meta-data associated with an item\n@@ -1007,7 +1008,7 @@ pub struct AttrId(pub uint);\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub value: @MetaItem,\n+    pub value: Gc<MetaItem>,\n     pub is_sugared_doc: bool,\n }\n \n@@ -1105,18 +1106,18 @@ pub struct Item {\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n-    ItemStatic(P<Ty>, Mutability, @Expr),\n+    ItemStatic(P<Ty>, Mutability, Gc<Expr>),\n     ItemFn(P<FnDecl>, FnStyle, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),\n     ItemTy(P<Ty>, Generics),\n     ItemEnum(EnumDef, Generics),\n-    ItemStruct(@StructDef, Generics),\n+    ItemStruct(Gc<StructDef>, Generics),\n     ItemTrait(Generics, Sized, Vec<TraitRef> , Vec<TraitMethod> ),\n     ItemImpl(Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<@Method> ),\n+             Vec<Gc<Method>>),\n     // a macro invocation (which includes macro definition)\n     ItemMac(Mac),\n }\n@@ -1142,9 +1143,9 @@ pub enum ForeignItem_ {\n // that we trans.\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum InlinedItem {\n-    IIItem(@Item),\n-    IIMethod(DefId /* impl id */, bool /* is provided */, @Method),\n-    IIForeign(@ForeignItem),\n+    IIItem(Gc<Item>),\n+    IIMethod(DefId /* impl id */, bool /* is provided */, Gc<Method>),\n+    IIForeign(Gc<ForeignItem>),\n }\n \n #[cfg(test)]"}, {"sha": "d78c9c2edc34a671d0d859d4840173c02452f717", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -20,9 +20,9 @@ use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::fmt;\n+use std::gc::Gc;\n use std::iter;\n use std::slice;\n-use std::string::String;\n \n #[deriving(Clone, PartialEq)]\n pub enum PathElem {\n@@ -94,22 +94,22 @@ pub fn path_to_str<PI: Iterator<PathElem>>(mut path: PI) -> String {\n \n #[deriving(Clone)]\n pub enum Node {\n-    NodeItem(@Item),\n-    NodeForeignItem(@ForeignItem),\n-    NodeTraitMethod(@TraitMethod),\n-    NodeMethod(@Method),\n+    NodeItem(Gc<Item>),\n+    NodeForeignItem(Gc<ForeignItem>),\n+    NodeTraitMethod(Gc<TraitMethod>),\n+    NodeMethod(Gc<Method>),\n     NodeVariant(P<Variant>),\n-    NodeExpr(@Expr),\n-    NodeStmt(@Stmt),\n-    NodeArg(@Pat),\n-    NodeLocal(@Pat),\n-    NodePat(@Pat),\n+    NodeExpr(Gc<Expr>),\n+    NodeStmt(Gc<Stmt>),\n+    NodeArg(Gc<Pat>),\n+    NodeLocal(Gc<Pat>),\n+    NodePat(Gc<Pat>),\n     NodeBlock(P<Block>),\n \n     /// NodeStructCtor represents a tuple struct.\n-    NodeStructCtor(@StructDef),\n+    NodeStructCtor(Gc<StructDef>),\n \n-    NodeLifetime(@Lifetime),\n+    NodeLifetime(Gc<Lifetime>),\n }\n \n // The odd layout is to bring down the total size.\n@@ -119,19 +119,19 @@ enum MapEntry {\n     NotPresent,\n \n     // All the node types, with a parent ID.\n-    EntryItem(NodeId, @Item),\n-    EntryForeignItem(NodeId, @ForeignItem),\n-    EntryTraitMethod(NodeId, @TraitMethod),\n-    EntryMethod(NodeId, @Method),\n+    EntryItem(NodeId, Gc<Item>),\n+    EntryForeignItem(NodeId, Gc<ForeignItem>),\n+    EntryTraitMethod(NodeId, Gc<TraitMethod>),\n+    EntryMethod(NodeId, Gc<Method>),\n     EntryVariant(NodeId, P<Variant>),\n-    EntryExpr(NodeId, @Expr),\n-    EntryStmt(NodeId, @Stmt),\n-    EntryArg(NodeId, @Pat),\n-    EntryLocal(NodeId, @Pat),\n-    EntryPat(NodeId, @Pat),\n+    EntryExpr(NodeId, Gc<Expr>),\n+    EntryStmt(NodeId, Gc<Stmt>),\n+    EntryArg(NodeId, Gc<Pat>),\n+    EntryLocal(NodeId, Gc<Pat>),\n+    EntryPat(NodeId, Gc<Pat>),\n     EntryBlock(NodeId, P<Block>),\n-    EntryStructCtor(NodeId, @StructDef),\n-    EntryLifetime(NodeId, @Lifetime),\n+    EntryStructCtor(NodeId, Gc<StructDef>),\n+    EntryLifetime(NodeId, Gc<Lifetime>),\n \n     // Roots for node trees.\n     RootCrate,\n@@ -262,14 +262,14 @@ impl Map {\n         }\n     }\n \n-    pub fn expect_item(&self, id: NodeId) -> @Item {\n+    pub fn expect_item(&self, id: NodeId) -> Gc<Item> {\n         match self.find(id) {\n             Some(NodeItem(item)) => item,\n             _ => fail!(\"expected item, found {}\", self.node_to_str(id))\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> @StructDef {\n+    pub fn expect_struct(&self, id: NodeId) -> Gc<StructDef> {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n@@ -294,7 +294,7 @@ impl Map {\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: NodeId) -> @ForeignItem {\n+    pub fn expect_foreign_item(&self, id: NodeId) -> Gc<ForeignItem> {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n             _ => fail!(\"expected foreign item, found {}\", self.node_to_str(id))\n@@ -457,11 +457,11 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         self.fold_ops.new_span(span)\n     }\n \n-    fn fold_item(&mut self, i: @Item) -> SmallVector<@Item> {\n+    fn fold_item(&mut self, i: Gc<Item>) -> SmallVector<Gc<Item>> {\n         let parent = self.parent;\n         self.parent = DUMMY_NODE_ID;\n \n-        let i = fold::noop_fold_item(i, self).expect_one(\"expected one item\");\n+        let i = fold::noop_fold_item(&*i, self).expect_one(\"expected one item\");\n         assert_eq!(self.parent, i.id);\n \n         match i.node {\n@@ -476,16 +476,17 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n                 }\n             }\n             ItemForeignMod(ref nm) => {\n-                for &nitem in nm.items.iter() {\n-                    self.insert(nitem.id, EntryForeignItem(self.parent, nitem));\n+                for nitem in nm.items.iter() {\n+                    self.insert(nitem.id, EntryForeignItem(self.parent,\n+                                                           nitem.clone()));\n                 }\n             }\n-            ItemStruct(struct_def, _) => {\n+            ItemStruct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n                 match struct_def.ctor_id {\n                     Some(ctor_id) => {\n                         self.insert(ctor_id, EntryStructCtor(self.parent,\n-                                                             struct_def));\n+                                                             struct_def.clone()));\n                     }\n                     None => {}\n                 }\n@@ -499,11 +500,11 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n                     match *tm {\n                         Required(ref m) => {\n                             self.insert(m.id, EntryTraitMethod(self.parent,\n-                                                               @(*tm).clone()));\n+                                                               box(GC) (*tm).clone()));\n                         }\n                         Provided(m) => {\n                             self.insert(m.id, EntryTraitMethod(self.parent,\n-                                                               @Provided(m)));\n+                                                               box(GC) Provided(m)));\n                         }\n                     }\n                 }\n@@ -517,7 +518,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         SmallVector::one(i)\n     }\n \n-    fn fold_pat(&mut self, pat: @Pat) -> @Pat {\n+    fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n         let pat = fold::noop_fold_pat(pat, self);\n         match pat.node {\n             PatIdent(..) => {\n@@ -532,17 +533,17 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         pat\n     }\n \n-    fn fold_expr(&mut self, expr: @Expr) -> @Expr {\n+    fn fold_expr(&mut self, expr: Gc<Expr>) -> Gc<Expr> {\n         let expr = fold::noop_fold_expr(expr, self);\n \n         self.insert(expr.id, EntryExpr(self.parent, expr));\n \n         expr\n     }\n \n-    fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<@Stmt> {\n+    fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<Gc<Stmt>> {\n         let stmt = fold::noop_fold_stmt(stmt, self).expect_one(\"expected one statement\");\n-        self.insert(ast_util::stmt_id(stmt), EntryStmt(self.parent, stmt));\n+        self.insert(ast_util::stmt_id(&*stmt), EntryStmt(self.parent, stmt));\n         SmallVector::one(stmt)\n     }\n \n@@ -555,10 +556,10 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         m\n     }\n \n-    fn fold_method(&mut self, m: @Method) -> @Method {\n+    fn fold_method(&mut self, m: Gc<Method>) -> Gc<Method> {\n         let parent = self.parent;\n         self.parent = DUMMY_NODE_ID;\n-        let m = fold::noop_fold_method(m, self);\n+        let m = fold::noop_fold_method(&*m, self);\n         assert_eq!(self.parent, m.id);\n         self.parent = parent;\n         m\n@@ -580,7 +581,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n \n     fn fold_lifetime(&mut self, lifetime: &Lifetime) -> Lifetime {\n         let lifetime = fold::noop_fold_lifetime(lifetime, self);\n-        self.insert(lifetime.id, EntryLifetime(self.parent, @lifetime));\n+        self.insert(lifetime.id, EntryLifetime(self.parent, box(GC) lifetime));\n         lifetime\n     }\n }\n@@ -643,7 +644,7 @@ pub fn map_decoded_item<F: FoldOps>(map: &Map,\n         IIItem(_) => {}\n         IIMethod(impl_did, is_provided, m) => {\n             let entry = if is_provided {\n-                EntryTraitMethod(cx.parent, @Provided(m))\n+                EntryTraitMethod(cx.parent, box(GC) Provided(m))\n             } else {\n                 EntryMethod(cx.parent, m)\n             };\n@@ -701,36 +702,36 @@ fn node_id_to_str(map: &Map, id: NodeId) -> String {\n                     token::get_ident(variant.node.name),\n                     map.path_to_str(id), id)).to_string()\n         }\n-        Some(NodeExpr(expr)) => {\n+        Some(NodeExpr(ref expr)) => {\n             (format!(\"expr {} (id={})\",\n-                    pprust::expr_to_str(expr), id)).to_string()\n+                    pprust::expr_to_str(&**expr), id)).to_string()\n         }\n-        Some(NodeStmt(stmt)) => {\n+        Some(NodeStmt(ref stmt)) => {\n             (format!(\"stmt {} (id={})\",\n-                    pprust::stmt_to_str(stmt), id)).to_string()\n+                    pprust::stmt_to_str(&**stmt), id)).to_string()\n         }\n-        Some(NodeArg(pat)) => {\n+        Some(NodeArg(ref pat)) => {\n             (format!(\"arg {} (id={})\",\n-                    pprust::pat_to_str(pat), id)).to_string()\n+                    pprust::pat_to_str(&**pat), id)).to_string()\n         }\n-        Some(NodeLocal(pat)) => {\n+        Some(NodeLocal(ref pat)) => {\n             (format!(\"local {} (id={})\",\n-                    pprust::pat_to_str(pat), id)).to_string()\n+                    pprust::pat_to_str(&**pat), id)).to_string()\n         }\n-        Some(NodePat(pat)) => {\n-            (format!(\"pat {} (id={})\", pprust::pat_to_str(pat), id)).to_string()\n+        Some(NodePat(ref pat)) => {\n+            (format!(\"pat {} (id={})\", pprust::pat_to_str(&**pat), id)).to_string()\n         }\n-        Some(NodeBlock(block)) => {\n+        Some(NodeBlock(ref block)) => {\n             (format!(\"block {} (id={})\",\n-                    pprust::block_to_str(block), id)).to_string()\n+                    pprust::block_to_str(&**block), id)).to_string()\n         }\n         Some(NodeStructCtor(_)) => {\n             (format!(\"struct_ctor {} (id={})\",\n                     map.path_to_str(id), id)).to_string()\n         }\n         Some(NodeLifetime(ref l)) => {\n             (format!(\"lifetime {} (id={})\",\n-                    pprust::lifetime_to_str(*l), id)).to_string()\n+                    pprust::lifetime_to_str(&**l), id)).to_string()\n         }\n         None => {\n             (format!(\"unknown node (id={})\", id)).to_string()"}, {"sha": "fcddbfa9a89b957b499f3830cb7e7cd77b3fcb23", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -21,7 +21,7 @@ use visit;\n \n use std::cell::Cell;\n use std::cmp;\n-use std::string::String;\n+use std::gc::Gc;\n use std::u32;\n \n pub fn path_name_i(idents: &[Ident]) -> String {\n@@ -93,15 +93,15 @@ pub fn is_shift_binop(b: BinOp) -> bool {\n \n pub fn unop_to_str(op: UnOp) -> &'static str {\n     match op {\n-      UnBox => \"@\",\n+      UnBox => \"box(GC) \",\n       UnUniq => \"box() \",\n       UnDeref => \"*\",\n       UnNot => \"!\",\n       UnNeg => \"-\",\n     }\n }\n \n-pub fn is_path(e: @Expr) -> bool {\n+pub fn is_path(e: Gc<Expr>) -> bool {\n     return match e.node { ExprPath(_) => true, _ => false };\n }\n \n@@ -181,11 +181,11 @@ pub fn float_ty_to_str(t: FloatTy) -> String {\n     }\n }\n \n-pub fn is_call_expr(e: @Expr) -> bool {\n+pub fn is_call_expr(e: Gc<Expr>) -> bool {\n     match e.node { ExprCall(..) => true, _ => false }\n }\n \n-pub fn block_from_expr(e: @Expr) -> P<Block> {\n+pub fn block_from_expr(e: Gc<Expr>) -> P<Block> {\n     P(Block {\n         view_items: Vec::new(),\n         stmts: Vec::new(),\n@@ -210,8 +210,8 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     }\n }\n \n-pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> @Pat {\n-    @ast::Pat { id: id,\n+pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> Gc<Pat> {\n+    box(GC) ast::Pat { id: id,\n                 node: PatIdent(BindByValue(MutImmutable), ident_to_path(s, i), None),\n                 span: s }\n }\n@@ -229,7 +229,7 @@ pub fn is_unguarded(a: &Arm) -> bool {\n     }\n }\n \n-pub fn unguarded_pat(a: &Arm) -> Option<Vec<@Pat> > {\n+pub fn unguarded_pat(a: &Arm) -> Option<Vec<Gc<Pat>>> {\n     if is_unguarded(a) {\n         Some(/* FIXME (#2543) */ a.pats.clone())\n     } else {\n@@ -254,7 +254,7 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty.as_slice())\n }\n \n-pub fn public_methods(ms: Vec<@Method> ) -> Vec<@Method> {\n+pub fn public_methods(ms: Vec<Gc<Method>> ) -> Vec<Gc<Method>> {\n     ms.move_iter().filter(|m| {\n         match m.vis {\n             Public => true,\n@@ -285,7 +285,7 @@ pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n }\n \n pub fn split_trait_methods(trait_methods: &[TraitMethod])\n-    -> (Vec<TypeMethod> , Vec<@Method> ) {\n+    -> (Vec<TypeMethod> , Vec<Gc<Method>> ) {\n     let mut reqd = Vec::new();\n     let mut provd = Vec::new();\n     for trt_method in trait_methods.iter() {\n@@ -610,7 +610,7 @@ pub fn compute_id_range_for_fn_body(fk: &visit::FnKind,\n     visitor.result.get()\n }\n \n-pub fn is_item_impl(item: @ast::Item) -> bool {\n+pub fn is_item_impl(item: Gc<ast::Item>) -> bool {\n     match item.node {\n         ItemImpl(..) => true,\n         _            => false\n@@ -623,20 +623,20 @@ pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n     }\n \n     match pat.node {\n-        PatIdent(_, _, Some(p)) => walk_pat(p, it),\n+        PatIdent(_, _, Some(ref p)) => walk_pat(&**p, it),\n         PatStruct(_, ref fields, _) => {\n-            fields.iter().advance(|f| walk_pat(f.pat, |p| it(p)))\n+            fields.iter().advance(|f| walk_pat(&*f.pat, |p| it(p)))\n         }\n         PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n-            s.iter().advance(|&p| walk_pat(p, |p| it(p)))\n+            s.iter().advance(|p| walk_pat(&**p, |p| it(p)))\n         }\n-        PatBox(s) | PatRegion(s) => {\n-            walk_pat(s, it)\n+        PatBox(ref s) | PatRegion(ref s) => {\n+            walk_pat(&**s, it)\n         }\n         PatVec(ref before, ref slice, ref after) => {\n-            before.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n-                slice.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n-                after.iter().advance(|&p| walk_pat(p, |p| it(p)))\n+            before.iter().advance(|p| walk_pat(&**p, |p| it(p))) &&\n+                slice.iter().advance(|p| walk_pat(&**p, |p| it(p))) &&\n+                after.iter().advance(|p| walk_pat(&**p, |p| it(p)))\n         }\n         PatMac(_) => fail!(\"attempted to analyze unexpanded pattern\"),\n         PatWild | PatWildMulti | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n@@ -685,7 +685,7 @@ pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {\n \n /// Returns true if the given pattern consists solely of an identifier\n /// and false otherwise.\n-pub fn pat_is_ident(pat: @ast::Pat) -> bool {\n+pub fn pat_is_ident(pat: Gc<ast::Pat>) -> bool {\n     match pat.node {\n         ast::PatIdent(..) => true,\n         _ => false,\n@@ -720,7 +720,7 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n }\n \n // Returns true if this literal is a string and false otherwise.\n-pub fn lit_is_str(lit: @Lit) -> bool {\n+pub fn lit_is_str(lit: Gc<Lit>) -> bool {\n     match lit.node {\n         LitStr(..) => true,\n         _ => false,"}, {"sha": "83f1326c656213b47fe95bbf6348016b68a34947", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -22,6 +22,7 @@ use crateid::CrateId;\n \n use std::collections::HashSet;\n use std::collections::BitvSet;\n+use std::gc::Gc;\n \n local_data_key!(used_attrs: BitvSet)\n \n@@ -52,7 +53,7 @@ pub trait AttrMetaMethods {\n      */\n     fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]>;\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]>;\n }\n \n impl AttrMetaMethods for Attribute {\n@@ -67,7 +68,7 @@ impl AttrMetaMethods for Attribute {\n     fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n         self.node.value.meta_item_list()\n     }\n }\n@@ -93,7 +94,7 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n         match self.node {\n             MetaList(_, ref l) => Some(l.as_slice()),\n             _ => None\n@@ -102,23 +103,23 @@ impl AttrMetaMethods for MetaItem {\n }\n \n // Annoying, but required to get test_cfg to work\n-impl AttrMetaMethods for @MetaItem {\n+impl AttrMetaMethods for Gc<MetaItem> {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<MetaItem>]> {\n         (**self).meta_item_list()\n     }\n }\n \n \n pub trait AttributeMethods {\n-    fn meta(&self) -> @MetaItem;\n+    fn meta(&self) -> Gc<MetaItem>;\n     fn desugar_doc(&self) -> Attribute;\n }\n \n impl AttributeMethods for Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n-    fn meta(&self) -> @MetaItem {\n+    fn meta(&self) -> Gc<MetaItem> {\n         self.node.value\n     }\n \n@@ -146,22 +147,23 @@ impl AttributeMethods for Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n-                              -> @MetaItem {\n+                              -> Gc<MetaItem> {\n     let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n     mk_name_value_item(name, value_lit)\n }\n \n pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n-                          -> @MetaItem {\n-    @dummy_spanned(MetaNameValue(name, value))\n+                          -> Gc<MetaItem> {\n+    box(GC) dummy_spanned(MetaNameValue(name, value))\n }\n \n-pub fn mk_list_item(name: InternedString, items: Vec<@MetaItem> ) -> @MetaItem {\n-    @dummy_spanned(MetaList(name, items))\n+pub fn mk_list_item(name: InternedString,\n+                    items: Vec<Gc<MetaItem>>) -> Gc<MetaItem> {\n+    box(GC) dummy_spanned(MetaList(name, items))\n }\n \n-pub fn mk_word_item(name: InternedString) -> @MetaItem {\n-    @dummy_spanned(MetaWord(name))\n+pub fn mk_word_item(name: InternedString) -> Gc<MetaItem> {\n+    box(GC) dummy_spanned(MetaWord(name))\n }\n \n local_data_key!(next_attr_id: uint)\n@@ -173,7 +175,7 @@ pub fn mk_attr_id() -> AttrId {\n }\n \n /// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(id: AttrId, item: @MetaItem) -> Attribute {\n+pub fn mk_attr_inner(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrInner,\n@@ -183,7 +185,7 @@ pub fn mk_attr_inner(id: AttrId, item: @MetaItem) -> Attribute {\n }\n \n /// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(id: AttrId, item: @MetaItem) -> Attribute {\n+pub fn mk_attr_outer(id: AttrId, item: Gc<MetaItem>) -> Attribute {\n     dummy_spanned(Attribute_ {\n         id: id,\n         style: ast::AttrOuter,\n@@ -200,7 +202,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n     let attr = Attribute_ {\n         id: id,\n         style: style,\n-        value: @spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n+        value: box(GC) spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n                                               lit)),\n         is_sugared_doc: true\n     };\n@@ -211,8 +213,8 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n /// Check if `needle` occurs in `haystack` by a structural\n /// comparison. This is slightly subtle, and relies on ignoring the\n /// span included in the `==` comparison a plain MetaItem.\n-pub fn contains(haystack: &[@ast::MetaItem],\n-                needle: @ast::MetaItem) -> bool {\n+pub fn contains(haystack: &[Gc<ast::MetaItem>],\n+                needle: Gc<ast::MetaItem>) -> bool {\n     debug!(\"attr::contains (name={})\", needle.name());\n     haystack.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n@@ -235,7 +237,7 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n+pub fn last_meta_item_value_str_by_name(items: &[Gc<MetaItem>], name: &str)\n                                      -> Option<InternedString> {\n     items.iter()\n          .rev()\n@@ -245,20 +247,20 @@ pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: &[@MetaItem]) -> Vec<@MetaItem> {\n+pub fn sort_meta_items(items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n     // This is sort of stupid here, but we need to sort by\n     // human-readable strings.\n     let mut v = items.iter()\n         .map(|&mi| (mi.name(), mi))\n-        .collect::<Vec<(InternedString, @MetaItem)> >();\n+        .collect::<Vec<(InternedString, Gc<MetaItem>)> >();\n \n     v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n     // There doesn't seem to be a more optimal way to do this\n     v.move_iter().map(|(_, m)| {\n         match m.node {\n             MetaList(ref n, ref mis) => {\n-                @Spanned {\n+                box(GC) Spanned {\n                     node: MetaList((*n).clone(),\n                                    sort_meta_items(mis.as_slice())),\n                     .. /*bad*/ (*m).clone()\n@@ -273,7 +275,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> Vec<@MetaItem> {\n  * From a list of crate attributes get only the meta_items that affect crate\n  * linkage\n  */\n-pub fn find_linkage_metas(attrs: &[Attribute]) -> Vec<@MetaItem> {\n+pub fn find_linkage_metas(attrs: &[Attribute]) -> Vec<Gc<MetaItem>> {\n     let mut result = Vec::new();\n     for attr in attrs.iter().filter(|at| at.check_name(\"link\")) {\n         match attr.meta().node {\n@@ -330,7 +332,7 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"a\")]`) == true\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(bar, foo=\"b\")]`) == false\n pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n-    (cfg: &[@MetaItem], mut metas: It) -> bool {\n+    (cfg: &[Gc<MetaItem>], mut metas: It) -> bool {\n     // having no #[cfg(...)] attributes counts as matching.\n     let mut no_cfgs = true;\n \n@@ -422,7 +424,7 @@ pub fn find_stability(attrs: &[Attribute]) -> Option<Stability> {\n     })\n }\n \n-pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n+pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[Gc<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n         let name = meta.name();"}, {"sha": "d9e3e4e941d2b208ed64f207c3bb40a827c59257", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -23,8 +23,8 @@ source code snippets, etc.\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n+use std::gc::Gc;\n use std::rc::Rc;\n-use std::string::String;\n \n pub trait Pos {\n     fn from_uint(n: uint) -> Self;\n@@ -91,7 +91,7 @@ pub struct Span {\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    pub expn_info: Option<@ExpnInfo>\n+    pub expn_info: Option<Gc<ExpnInfo>>\n }\n \n pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };"}, {"sha": "665d9da664d6409cdfa0f35984f1fc82162ce5e1", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -20,7 +20,6 @@ use parse;\n use parse::token::InternedString;\n use parse::token;\n \n-\n enum State {\n     Asm,\n     Outputs,\n@@ -214,7 +213,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                  out));\n     }\n \n-    MacExpr::new(@ast::Expr {\n+    MacExpr::new(box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(asm.get()),"}, {"sha": "7ba517a3aedbdfcc779c53e31ad85b801ccc2fdb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -20,6 +20,7 @@ use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n+use std::gc::Gc;\n \n // new-style macro! tt code:\n //\n@@ -35,10 +36,10 @@ pub struct MacroDef {\n }\n \n pub type ItemDecorator =\n-    fn(&mut ExtCtxt, Span, @ast::MetaItem, @ast::Item, |@ast::Item|);\n+    fn(&mut ExtCtxt, Span, Gc<ast::MetaItem>, Gc<ast::Item>, |Gc<ast::Item>|);\n \n pub type ItemModifier =\n-    fn(&mut ExtCtxt, Span, @ast::MetaItem, @ast::Item) -> @ast::Item;\n+    fn(&mut ExtCtxt, Span, Gc<ast::MetaItem>, Gc<ast::Item>) -> Gc<ast::Item>;\n \n pub struct BasicMacroExpander {\n     pub expander: MacroExpanderFn,\n@@ -104,74 +105,74 @@ pub trait MacResult {\n         None\n     }\n     /// Create an expression.\n-    fn make_expr(&self) -> Option<@ast::Expr> {\n+    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n         None\n     }\n     /// Create zero or more items.\n-    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         None\n     }\n     /// Create a pattern.\n-    fn make_pat(&self) -> Option<@ast::Pat> {\n+    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         None\n     }\n \n     /// Create a statement.\n     ///\n     /// By default this attempts to create an expression statement,\n     /// returning None if that fails.\n-    fn make_stmt(&self) -> Option<@ast::Stmt> {\n+    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n         self.make_expr()\n-            .map(|e| @codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))\n+            .map(|e| box(GC) codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))\n     }\n }\n \n /// A convenience type for macros that return a single expression.\n pub struct MacExpr {\n-    e: @ast::Expr\n+    e: Gc<ast::Expr>,\n }\n impl MacExpr {\n-    pub fn new(e: @ast::Expr) -> Box<MacResult> {\n+    pub fn new(e: Gc<ast::Expr>) -> Box<MacResult> {\n         box MacExpr { e: e } as Box<MacResult>\n     }\n }\n impl MacResult for MacExpr {\n-    fn make_expr(&self) -> Option<@ast::Expr> {\n+    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n         Some(self.e)\n     }\n }\n /// A convenience type for macros that return a single pattern.\n pub struct MacPat {\n-    p: @ast::Pat\n+    p: Gc<ast::Pat>,\n }\n impl MacPat {\n-    pub fn new(p: @ast::Pat) -> Box<MacResult> {\n+    pub fn new(p: Gc<ast::Pat>) -> Box<MacResult> {\n         box MacPat { p: p } as Box<MacResult>\n     }\n }\n impl MacResult for MacPat {\n-    fn make_pat(&self) -> Option<@ast::Pat> {\n+    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         Some(self.p)\n     }\n }\n /// A convenience type for macros that return a single item.\n pub struct MacItem {\n-    i: @ast::Item\n+    i: Gc<ast::Item>\n }\n impl MacItem {\n-    pub fn new(i: @ast::Item) -> Box<MacResult> {\n+    pub fn new(i: Gc<ast::Item>) -> Box<MacResult> {\n         box MacItem { i: i } as Box<MacResult>\n     }\n }\n impl MacResult for MacItem {\n-    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         Some(SmallVector::one(self.i))\n     }\n-    fn make_stmt(&self) -> Option<@ast::Stmt> {\n-        Some(@codemap::respan(\n+    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n+        Some(box(GC) codemap::respan(\n             self.i.span,\n             ast::StmtDecl(\n-                @codemap::respan(self.i.span, ast::DeclItem(self.i)),\n+                box(GC) codemap::respan(self.i.span, ast::DeclItem(self.i)),\n                 ast::DUMMY_NODE_ID)))\n     }\n }\n@@ -202,17 +203,17 @@ impl DummyResult {\n     }\n \n     /// A plain dummy expression.\n-    pub fn raw_expr(sp: Span) -> @ast::Expr {\n-        @ast::Expr {\n+    pub fn raw_expr(sp: Span) -> Gc<ast::Expr> {\n+        box(GC) ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprLit(@codemap::respan(sp, ast::LitNil)),\n+            node: ast::ExprLit(box(GC) codemap::respan(sp, ast::LitNil)),\n             span: sp,\n         }\n     }\n \n     /// A plain dummy pattern.\n-    pub fn raw_pat(sp: Span) -> @ast::Pat {\n-        @ast::Pat {\n+    pub fn raw_pat(sp: Span) -> Gc<ast::Pat> {\n+        box(GC) ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::PatWild,\n             span: sp,\n@@ -221,21 +222,21 @@ impl DummyResult {\n }\n \n impl MacResult for DummyResult {\n-    fn make_expr(&self) -> Option<@ast::Expr> {\n+    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n         Some(DummyResult::raw_expr(self.span))\n     }\n-    fn make_pat(&self) -> Option<@ast::Pat> {\n+    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         Some(DummyResult::raw_pat(self.span))\n     }\n-    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         if self.expr_only {\n             None\n         } else {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_stmt(&self) -> Option<@ast::Stmt> {\n-        Some(@codemap::respan(self.span,\n+    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n+        Some(box(GC) codemap::respan(self.span,\n                               ast::StmtExpr(DummyResult::raw_expr(self.span),\n                                             ast::DUMMY_NODE_ID)))\n     }\n@@ -397,7 +398,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n-    pub backtrace: Option<@ExpnInfo>,\n+    pub backtrace: Option<Gc<ExpnInfo>>,\n     pub ecfg: expand::ExpansionConfig,\n \n     pub mod_path: Vec<ast::Ident> ,\n@@ -417,7 +418,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn expand_expr(&mut self, mut e: @ast::Expr) -> @ast::Expr {\n+    pub fn expand_expr(&mut self, mut e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         loop {\n             match e.node {\n                 ast::ExprMac(..) => {\n@@ -442,7 +443,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n     pub fn print_backtrace(&self) { }\n-    pub fn backtrace(&self) -> Option<@ExpnInfo> { self.backtrace }\n+    pub fn backtrace(&self) -> Option<Gc<ExpnInfo>> { self.backtrace }\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n@@ -455,9 +456,9 @@ impl<'a> ExtCtxt<'a> {\n         match ei {\n             ExpnInfo {call_site: cs, callee: ref callee} => {\n                 self.backtrace =\n-                    Some(@ExpnInfo {\n+                    Some(box(GC) ExpnInfo {\n                         call_site: Span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: self.backtrace},\n+                                         expn_info: self.backtrace.clone()},\n                         callee: (*callee).clone()\n                     });\n             }\n@@ -528,7 +529,7 @@ impl<'a> ExtCtxt<'a> {\n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n-pub fn expr_to_str(cx: &mut ExtCtxt, expr: @ast::Expr, err_msg: &str)\n+pub fn expr_to_str(cx: &mut ExtCtxt, expr: Gc<ast::Expr>, err_msg: &str)\n                    -> Option<(InternedString, ast::StrStyle)> {\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expand_expr(expr);\n@@ -584,7 +585,7 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n /// parsing error, emit a non-fatal error and return None.\n pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::TokenTree]) -> Option<Vec<@ast::Expr> > {\n+                          tts: &[ast::TokenTree]) -> Option<Vec<Gc<ast::Expr>>> {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.iter()"}, {"sha": "148b653b61cb95019600262a8db90ba4637d2bfc", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 223, "deletions": 195, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -21,6 +21,8 @@ use parse::token::special_idents;\n use parse::token::InternedString;\n use parse::token;\n \n+use std::gc::Gc;\n+\n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n     pub use ext;\n@@ -73,115 +75,129 @@ pub trait AstBuilder {\n     fn lifetime(&self, span: Span, ident: ast::Name) -> ast::Lifetime;\n \n     // statements\n-    fn stmt_expr(&self, expr: @ast::Expr) -> @ast::Stmt;\n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::Expr) -> @ast::Stmt;\n+    fn stmt_expr(&self, expr: Gc<ast::Expr>) -> Gc<ast::Stmt>;\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n+                ex: Gc<ast::Expr>) -> Gc<ast::Stmt>;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n-                      ex: @ast::Expr)\n-                      -> @ast::Stmt;\n+                      ex: Gc<ast::Expr>)\n+                      -> Gc<ast::Stmt>;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: Vec<@ast::Stmt> , expr: Option<@ast::Expr>) -> P<ast::Block>;\n-    fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n+             expr: Option<Gc<ast::Expr>>) -> P<ast::Block>;\n+    fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n                  view_items: Vec<ast::ViewItem> ,\n-                 stmts: Vec<@ast::Stmt> ,\n-                 expr: Option<@ast::Expr>) -> P<ast::Block>;\n+                 stmts: Vec<Gc<ast::Stmt>> ,\n+                 expr: Option<Gc<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n-    fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr;\n-    fn expr_path(&self, path: ast::Path) -> @ast::Expr;\n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::Expr;\n+    fn expr(&self, span: Span, node: ast::Expr_) -> Gc<ast::Expr>;\n+    fn expr_path(&self, path: ast::Path) -> Gc<ast::Expr>;\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> Gc<ast::Expr>;\n \n-    fn expr_self(&self, span: Span) -> @ast::Expr;\n+    fn expr_self(&self, span: Span) -> Gc<ast::Expr>;\n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n-                   lhs: @ast::Expr, rhs: @ast::Expr) -> @ast::Expr;\n-    fn expr_deref(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr) -> @ast::Expr;\n-\n-    fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n-    fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n-    fn expr_mut_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n-    fn expr_field_access(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n-    fn expr_call(&self, span: Span, expr: @ast::Expr, args: Vec<@ast::Expr> ) -> @ast::Expr;\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<@ast::Expr> ) -> @ast::Expr;\n+                   lhs: Gc<ast::Expr>, rhs: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_deref(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+\n+    fn expr_managed(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_mut_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_field_access(&self, span: Span, expr: Gc<ast::Expr>,\n+                         ident: ast::Ident) -> Gc<ast::Expr>;\n+    fn expr_call(&self, span: Span, expr: Gc<ast::Expr>,\n+                 args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident,\n+                       args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n-                        args: Vec<@ast::Expr> ) -> @ast::Expr;\n+                        args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n     fn expr_method_call(&self, span: Span,\n-                        expr: @ast::Expr, ident: ast::Ident,\n-                        args: Vec<@ast::Expr> ) -> @ast::Expr;\n-    fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr;\n-    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: P<ast::Ty>) -> @ast::Expr;\n-\n-    fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field;\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> @ast::Expr;\n-    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: Vec<ast::Field> ) -> @ast::Expr;\n-\n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> @ast::Expr;\n-\n-    fn expr_uint(&self, span: Span, i: uint) -> @ast::Expr;\n-    fn expr_int(&self, sp: Span, i: int) -> @ast::Expr;\n-    fn expr_u8(&self, sp: Span, u: u8) -> @ast::Expr;\n-    fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr;\n-\n-    fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr;\n-    fn expr_vec(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n-    fn expr_vec_ng(&self, sp: Span) -> @ast::Expr;\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n-    fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr;\n-    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr;\n-\n-    fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr;\n-    fn expr_none(&self, sp: Span) -> @ast::Expr;\n-\n-    fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr;\n-    fn expr_unreachable(&self, span: Span) -> @ast::Expr;\n-\n-    fn expr_ok(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n-    fn expr_err(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n-    fn expr_try(&self, span: Span, head: @ast::Expr) -> @ast::Expr;\n-\n-    fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat;\n-    fn pat_wild(&self, span: Span) -> @ast::Pat;\n-    fn pat_lit(&self, span: Span, expr: @ast::Expr) -> @ast::Pat;\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::Pat;\n+                        expr: Gc<ast::Expr>, ident: ast::Ident,\n+                        args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n+    fn expr_block(&self, b: P<ast::Block>) -> Gc<ast::Expr>;\n+    fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>,\n+                 ty: P<ast::Ty>) -> Gc<ast::Expr>;\n+\n+    fn field_imm(&self, span: Span, name: Ident, e: Gc<ast::Expr>) -> ast::Field;\n+    fn expr_struct(&self, span: Span, path: ast::Path,\n+                   fields: Vec<ast::Field> ) -> Gc<ast::Expr>;\n+    fn expr_struct_ident(&self, span: Span, id: ast::Ident,\n+                         fields: Vec<ast::Field> ) -> Gc<ast::Expr>;\n+\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> Gc<ast::Expr>;\n+\n+    fn expr_uint(&self, span: Span, i: uint) -> Gc<ast::Expr>;\n+    fn expr_int(&self, sp: Span, i: int) -> Gc<ast::Expr>;\n+    fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr>;\n+    fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr>;\n+\n+    fn expr_vstore(&self, sp: Span, expr: Gc<ast::Expr>, vst: ast::ExprVstore) -> Gc<ast::Expr>;\n+    fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n+    fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr>;\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr>;\n+    fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n+    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> Gc<ast::Expr>;\n+\n+    fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_none(&self, sp: Span) -> Gc<ast::Expr>;\n+\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr>;\n+    fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr>;\n+\n+    fn expr_ok(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_err(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn expr_try(&self, span: Span, head: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> Gc<ast::Pat>;\n+    fn pat_wild(&self, span: Span) -> Gc<ast::Pat>;\n+    fn pat_lit(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Pat>;\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> Gc<ast::Pat>;\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::BindingMode) -> @ast::Pat;\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<@ast::Pat> ) -> @ast::Pat;\n+                              bm: ast::BindingMode) -> Gc<ast::Pat>;\n+    fn pat_enum(&self, span: Span, path: ast::Path,\n+                subpats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat>;\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> @ast::Pat;\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat>;\n \n-    fn arm(&self, span: Span, pats: Vec<@ast::Pat> , expr: @ast::Expr) -> ast::Arm;\n+    fn arm(&self, span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm;\n     fn arm_unreachable(&self, span: Span) -> ast::Arm;\n \n-    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: Vec<ast::Arm> ) -> @ast::Expr;\n+    fn expr_match(&self, span: Span, arg: Gc<ast::Expr>, arms: Vec<ast::Arm> ) -> Gc<ast::Expr>;\n     fn expr_if(&self, span: Span,\n-               cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr;\n+               cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n+               els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr;\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr>;\n \n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr;\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr;\n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr;\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr>;\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr>;\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> Gc<ast::Expr>;\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: @ast::Expr) -> @ast::Expr;\n-    fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n-    fn lambda_expr_1(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn lambda_expr_0(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n+    fn lambda_expr_1(&self, span: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr>;\n \n-    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident> , blk: Vec<@ast::Stmt> ) -> @ast::Expr;\n-    fn lambda_stmts_0(&self, span: Span, stmts: Vec<@ast::Stmt> ) -> @ast::Expr;\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<@ast::Stmt> , ident: ast::Ident) -> @ast::Expr;\n+    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,\n+                    blk: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr>;\n+    fn lambda_stmts_0(&self, span: Span,\n+                      stmts: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr>;\n+    fn lambda_stmts_1(&self, span: Span,\n+                      stmts: Vec<Gc<ast::Stmt>>, ident: ast::Ident) -> Gc<ast::Expr>;\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> @ast::Item;\n+            name: Ident, attrs: Vec<ast::Attribute>,\n+            node: ast::Item_) -> Gc<ast::Item>;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // FIXME unused self\n@@ -193,56 +209,59 @@ pub trait AstBuilder {\n                     inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> @ast::Item;\n+                    body: P<ast::Block>) -> Gc<ast::Item>;\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n                inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n-               body: P<ast::Block>) -> @ast::Item;\n+               body: P<ast::Block>) -> Gc<ast::Item>;\n \n     fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n                       name: Ident,\n                       enum_definition: ast::EnumDef,\n-                      generics: Generics) -> @ast::Item;\n-    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::EnumDef) -> @ast::Item;\n+                      generics: Generics) -> Gc<ast::Item>;\n+    fn item_enum(&self, span: Span, name: Ident,\n+                 enum_def: ast::EnumDef) -> Gc<ast::Item>;\n \n     fn item_struct_poly(&self,\n                         span: Span,\n                         name: Ident,\n                         struct_def: ast::StructDef,\n-                        generics: Generics) -> @ast::Item;\n-    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> @ast::Item;\n+                        generics: Generics) -> Gc<ast::Item>;\n+    fn item_struct(&self, span: Span, name: Ident,\n+                   struct_def: ast::StructDef) -> Gc<ast::Item>;\n \n     fn item_mod(&self, span: Span, inner_span: Span,\n-                name: Ident, attrs: Vec<ast::Attribute> ,\n-                vi: Vec<ast::ViewItem> , items: Vec<@ast::Item> ) -> @ast::Item;\n+                name: Ident, attrs: Vec<ast::Attribute>,\n+                vi: Vec<ast::ViewItem>,\n+                items: Vec<Gc<ast::Item>>) -> Gc<ast::Item>;\n \n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n                     ty: P<ast::Ty>,\n-                    generics: Generics) -> @ast::Item;\n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::Item;\n+                    generics: Generics) -> Gc<ast::Item>;\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> Gc<ast::Item>;\n \n-    fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute;\n+    fn attribute(&self, sp: Span, mi: Gc<ast::MetaItem>) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> @ast::MetaItem;\n+    fn meta_word(&self, sp: Span, w: InternedString) -> Gc<ast::MetaItem>;\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<@ast::MetaItem> )\n-                 -> @ast::MetaItem;\n+                 mis: Vec<Gc<ast::MetaItem>>)\n+                 -> Gc<ast::MetaItem>;\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n                        value: ast::Lit_)\n-                       -> @ast::MetaItem;\n+                       -> Gc<ast::MetaItem>;\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: @ast::ViewPath) -> ast::ViewItem;\n+                vis: ast::Visibility, vp: Gc<ast::ViewPath>) -> ast::ViewItem;\n     fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n@@ -418,17 +437,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, name: name }\n     }\n \n-    fn stmt_expr(&self, expr: @ast::Expr) -> @ast::Stmt {\n-        @respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID))\n+    fn stmt_expr(&self, expr: Gc<ast::Expr>) -> Gc<ast::Stmt> {\n+        box(GC) respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID))\n     }\n \n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::Expr) -> @ast::Stmt {\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n+                ex: Gc<ast::Expr>) -> Gc<ast::Stmt> {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let local = @ast::Local {\n+        let local = box(GC) ast::Local {\n             ty: self.ty_infer(sp),\n             pat: pat,\n             init: Some(ex),\n@@ -437,22 +457,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             source: ast::LocalLet,\n         };\n         let decl = respan(sp, ast::DeclLocal(local));\n-        @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n+        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n     }\n \n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n                       ident: ast::Ident,\n                       typ: P<ast::Ty>,\n-                      ex: @ast::Expr)\n-                      -> @ast::Stmt {\n+                      ex: Gc<ast::Expr>)\n+                      -> Gc<ast::Stmt> {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let local = @ast::Local {\n+        let local = box(GC) ast::Local {\n             ty: typ,\n             pat: pat,\n             init: Some(ex),\n@@ -461,21 +481,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             source: ast::LocalLet,\n         };\n         let decl = respan(sp, ast::DeclLocal(local));\n-        @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n+        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n     }\n \n-    fn block(&self, span: Span, stmts: Vec<@ast::Stmt> , expr: Option<@Expr>) -> P<ast::Block> {\n+    fn block(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n+             expr: Option<Gc<Expr>>) -> P<ast::Block> {\n         self.block_all(span, Vec::new(), stmts, expr)\n     }\n \n-    fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block> {\n+    fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block> {\n         self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n                  view_items: Vec<ast::ViewItem> ,\n-                 stmts: Vec<@ast::Stmt> ,\n-                 expr: Option<@ast::Expr>) -> P<ast::Block> {\n+                 stmts: Vec<Gc<ast::Stmt>>,\n+                 expr: Option<Gc<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                view_items: view_items,\n                stmts: stmts,\n@@ -486,147 +507,149 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             })\n     }\n \n-    fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr {\n-        @ast::Expr {\n+    fn expr(&self, span: Span, node: ast::Expr_) -> Gc<ast::Expr> {\n+        box(GC) ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n         }\n     }\n \n-    fn expr_path(&self, path: ast::Path) -> @ast::Expr {\n+    fn expr_path(&self, path: ast::Path) -> Gc<ast::Expr> {\n         self.expr(path.span, ast::ExprPath(path))\n     }\n \n-    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::Expr {\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> Gc<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n-    fn expr_self(&self, span: Span) -> @ast::Expr {\n+    fn expr_self(&self, span: Span) -> Gc<ast::Expr> {\n         self.expr_ident(span, special_idents::self_)\n     }\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n-                   lhs: @ast::Expr, rhs: @ast::Expr) -> @ast::Expr {\n+                   lhs: Gc<ast::Expr>, rhs: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprBinary(op, lhs, rhs))\n     }\n \n-    fn expr_deref(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_deref(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr_unary(sp, ast::UnDeref, e)\n     }\n-    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprUnary(op, e))\n     }\n \n-    fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_managed(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr_unary(sp, ast::UnBox, e)\n     }\n \n-    fn expr_field_access(&self, sp: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {\n+    fn expr_field_access(&self, sp: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprField(expr, ident, Vec::new()))\n     }\n-    fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n     }\n-    fn expr_mut_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n+    fn expr_mut_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n     }\n \n-    fn expr_call(&self, span: Span, expr: @ast::Expr, args: Vec<@ast::Expr> ) -> @ast::Expr {\n+    fn expr_call(&self, span: Span, expr: Gc<ast::Expr>,\n+                 args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprCall(expr, args))\n     }\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<@ast::Expr> ) -> @ast::Expr {\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident,\n+                       args: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n     }\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n-                      args: Vec<@ast::Expr> ) -> @ast::Expr {\n+                      args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n     fn expr_method_call(&self, span: Span,\n-                        expr: @ast::Expr,\n+                        expr: Gc<ast::Expr>,\n                         ident: ast::Ident,\n-                        mut args: Vec<@ast::Expr> ) -> @ast::Expr {\n+                        mut args: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         let id = Spanned { node: ident, span: span };\n         args.unshift(expr);\n         self.expr(span, ast::ExprMethodCall(id, Vec::new(), args))\n     }\n-    fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr {\n+    fn expr_block(&self, b: P<ast::Block>) -> Gc<ast::Expr> {\n         self.expr(b.span, ast::ExprBlock(b))\n     }\n-    fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field {\n+    fn field_imm(&self, span: Span, name: Ident, e: Gc<ast::Expr>) -> ast::Field {\n         ast::Field { ident: respan(span, name), expr: e, span: span }\n     }\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> @ast::Expr {\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprStruct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n-                         id: ast::Ident, fields: Vec<ast::Field> ) -> @ast::Expr {\n+                         id: ast::Ident, fields: Vec<ast::Field> ) -> Gc<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> @ast::Expr {\n-        self.expr(sp, ast::ExprLit(@respan(sp, lit)))\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> Gc<ast::Expr> {\n+        self.expr(sp, ast::ExprLit(box(GC) respan(sp, lit)))\n     }\n-    fn expr_uint(&self, span: Span, i: uint) -> @ast::Expr {\n+    fn expr_uint(&self, span: Span, i: uint) -> Gc<ast::Expr> {\n         self.expr_lit(span, ast::LitUint(i as u64, ast::TyU))\n     }\n-    fn expr_int(&self, sp: Span, i: int) -> @ast::Expr {\n+    fn expr_int(&self, sp: Span, i: int) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(i as i64, ast::TyI))\n     }\n-    fn expr_u8(&self, sp: Span, u: u8) -> @ast::Expr {\n+    fn expr_u8(&self, sp: Span, u: u8) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitUint(u as u64, ast::TyU8))\n     }\n-    fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr {\n+    fn expr_bool(&self, sp: Span, value: bool) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitBool(value))\n     }\n \n-    fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr {\n+    fn expr_vstore(&self, sp: Span, expr: Gc<ast::Expr>, vst: ast::ExprVstore) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprVstore(expr, vst))\n     }\n-    fn expr_vec(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n+    fn expr_vec(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprVec(exprs))\n     }\n-    fn expr_vec_ng(&self, sp: Span) -> @ast::Expr {\n+    fn expr_vec_ng(&self, sp: Span) -> Gc<ast::Expr> {\n         self.expr_call_global(sp,\n                               vec!(self.ident_of(\"std\"),\n                                    self.ident_of(\"vec\"),\n                                    self.ident_of(\"Vec\"),\n                                    self.ident_of(\"new\")),\n                               Vec::new())\n     }\n-    fn expr_vec_slice(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<Gc<ast::Expr>> ) -> Gc<ast::Expr> {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n     }\n-    fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr {\n+    fn expr_str(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n         self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n-    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr {\n+    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> Gc<ast::Expr> {\n         self.expr_vstore(sp, self.expr_str(sp, s), ast::ExprVstoreUniq)\n     }\n \n \n-    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: P<ast::Ty>) -> @ast::Expr {\n+    fn expr_cast(&self, sp: Span, expr: Gc<ast::Expr>, ty: P<ast::Ty>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprCast(expr, ty))\n     }\n \n \n-    fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+    fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n             self.ident_of(\"Some\"));\n         self.expr_call_global(sp, some, vec!(expr))\n     }\n \n-    fn expr_none(&self, sp: Span) -> @ast::Expr {\n+    fn expr_none(&self, sp: Span) -> Gc<ast::Expr> {\n         let none = self.path_global(sp, vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n             self.ident_of(\"None\")));\n         self.expr_path(none)\n     }\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr {\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n@@ -643,29 +666,29 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 self.expr_uint(span, loc.line)))\n     }\n \n-    fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n+    fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr> {\n         self.expr_fail(span,\n                        InternedString::new(\n                            \"internal error: entered unreachable code\"))\n     }\n \n-    fn expr_ok(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+    fn expr_ok(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let ok = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n             self.ident_of(\"Ok\"));\n         self.expr_call_global(sp, ok, vec!(expr))\n     }\n \n-    fn expr_err(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+    fn expr_err(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let err = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"result\"),\n             self.ident_of(\"Err\"));\n         self.expr_call_global(sp, err, vec!(expr))\n     }\n \n-    fn expr_try(&self, sp: Span, head: @ast::Expr) -> @ast::Expr {\n+    fn expr_try(&self, sp: Span, head: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let ok = self.ident_of(\"Ok\");\n         let ok_path = self.path_ident(sp, ok);\n         let err = self.ident_of(\"Err\");\n@@ -694,38 +717,38 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n \n-    fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat {\n-        @ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }\n+    fn pat(&self, span: Span, pat: ast::Pat_) -> Gc<ast::Pat> {\n+        box(GC) ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }\n     }\n-    fn pat_wild(&self, span: Span) -> @ast::Pat {\n+    fn pat_wild(&self, span: Span) -> Gc<ast::Pat> {\n         self.pat(span, ast::PatWild)\n     }\n-    fn pat_lit(&self, span: Span, expr: @ast::Expr) -> @ast::Pat {\n+    fn pat_lit(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Pat> {\n         self.pat(span, ast::PatLit(expr))\n     }\n-    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::Pat {\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> Gc<ast::Pat> {\n         self.pat_ident_binding_mode(span, ident, ast::BindByValue(ast::MutImmutable))\n     }\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n                               ident: ast::Ident,\n-                              bm: ast::BindingMode) -> @ast::Pat {\n+                              bm: ast::BindingMode) -> Gc<ast::Pat> {\n         let path = self.path_ident(span, ident);\n         let pat = ast::PatIdent(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<@ast::Pat> ) -> @ast::Pat {\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<Gc<ast::Pat>> ) -> Gc<ast::Pat> {\n         let pat = ast::PatEnum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> @ast::Pat {\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat> {\n         let pat = ast::PatStruct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n \n-    fn arm(&self, _span: Span, pats: Vec<@ast::Pat> , expr: @ast::Expr) -> ast::Arm {\n+    fn arm(&self, _span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec!(),\n             pats: pats,\n@@ -738,56 +761,60 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.arm(span, vec!(self.pat_wild(span)), self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: Vec<ast::Arm> ) -> @Expr {\n+    fn expr_match(&self, span: Span, arg: Gc<ast::Expr>,\n+                  arms: Vec<ast::Arm>) -> Gc<Expr> {\n         self.expr(span, ast::ExprMatch(arg, arms))\n     }\n \n     fn expr_if(&self, span: Span,\n-               cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr {\n+               cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n+               els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n         let els = els.map(|x| self.expr_block(self.block_expr(x)));\n         self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n     }\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr {\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr {\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> Gc<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr {\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> Gc<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)\n     }\n \n-    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr {\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> Gc<ast::Expr> {\n         self.lambda(span, vec!(ident), blk)\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , expr: @ast::Expr) -> @ast::Expr {\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n-    fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr {\n+    fn lambda_expr_0(&self, span: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.lambda0(span, self.block_expr(expr))\n     }\n-    fn lambda_expr_1(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {\n+    fn lambda_expr_1(&self, span: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n     fn lambda_stmts(&self,\n                     span: Span,\n                     ids: Vec<ast::Ident>,\n-                    stmts: Vec<@ast::Stmt>)\n-                    -> @ast::Expr {\n+                    stmts: Vec<Gc<ast::Stmt>>)\n+                    -> Gc<ast::Expr> {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: Span, stmts: Vec<@ast::Stmt> ) -> @ast::Expr {\n+    fn lambda_stmts_0(&self, span: Span,\n+                      stmts: Vec<Gc<ast::Stmt>>) -> Gc<ast::Expr> {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: Vec<@ast::Stmt> , ident: ast::Ident) -> @ast::Expr {\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n+                      ident: ast::Ident) -> Gc<ast::Expr> {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n@@ -811,10 +838,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> @ast::Item {\n+            name: Ident, attrs: Vec<ast::Attribute>,\n+            node: ast::Item_) -> Gc<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n-        @ast::Item { ident: name,\n+        box(GC) ast::Item { ident: name,\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     node: node,\n@@ -828,7 +856,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> @ast::Item {\n+                    body: P<ast::Block>) -> Gc<ast::Item> {\n         self.item(span,\n                   name,\n                   Vec::new(),\n@@ -845,7 +873,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n-              ) -> @ast::Item {\n+              ) -> Gc<ast::Item> {\n         self.item_fn_poly(\n             span,\n             name,\n@@ -873,18 +901,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n-                      generics: Generics) -> @ast::Item {\n+                      generics: Generics) -> Gc<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemEnum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n-                 enum_definition: ast::EnumDef) -> @ast::Item {\n+                 enum_definition: ast::EnumDef) -> Gc<ast::Item> {\n         self.item_enum_poly(span, name, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n     fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::StructDef) -> @ast::Item {\n+                   struct_def: ast::StructDef) -> Gc<ast::Item> {\n         self.item_struct_poly(\n             span,\n             name,\n@@ -894,14 +922,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n-        struct_def: ast::StructDef, generics: Generics) -> @ast::Item {\n-        self.item(span, name, Vec::new(), ast::ItemStruct(@struct_def, generics))\n+        struct_def: ast::StructDef, generics: Generics) -> Gc<ast::Item> {\n+        self.item(span, name, Vec::new(), ast::ItemStruct(box(GC) struct_def, generics))\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n                 attrs: Vec<ast::Attribute> ,\n                 vi: Vec<ast::ViewItem> ,\n-                items: Vec<@ast::Item> ) -> @ast::Item {\n+                items: Vec<Gc<ast::Item>>) -> Gc<ast::Item> {\n         self.item(\n             span,\n             name,\n@@ -915,15 +943,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n-                    generics: Generics) -> @ast::Item {\n+                    generics: Generics) -> Gc<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))\n     }\n \n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::Item {\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> Gc<ast::Item> {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n-    fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute {\n+    fn attribute(&self, sp: Span, mi: Gc<ast::MetaItem>) -> ast::Attribute {\n         respan(sp, ast::Attribute_ {\n             id: attr::mk_attr_id(),\n             style: ast::AttrOuter,\n@@ -932,26 +960,26 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> @ast::MetaItem {\n-        @respan(sp, ast::MetaWord(w))\n+    fn meta_word(&self, sp: Span, w: InternedString) -> Gc<ast::MetaItem> {\n+        box(GC) respan(sp, ast::MetaWord(w))\n     }\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: Vec<@ast::MetaItem> )\n-                 -> @ast::MetaItem {\n-        @respan(sp, ast::MetaList(name, mis))\n+                 mis: Vec<Gc<ast::MetaItem>> )\n+                 -> Gc<ast::MetaItem> {\n+        box(GC) respan(sp, ast::MetaList(name, mis))\n     }\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n                        value: ast::Lit_)\n-                       -> @ast::MetaItem {\n-        @respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n+                       -> Gc<ast::MetaItem> {\n+        box(GC) respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n     }\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: @ast::ViewPath) -> ast::ViewItem {\n+                vis: ast::Visibility, vp: Gc<ast::ViewPath>) -> ast::ViewItem {\n         ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n             attrs: Vec::new(),\n@@ -968,7 +996,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      @respan(sp,\n+                      box(GC) respan(sp,\n                            ast::ViewPathSimple(ident,\n                                                path,\n                                                ast::DUMMY_NODE_ID)))\n@@ -981,7 +1009,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }).collect();\n \n         self.view_use(sp, vis,\n-                      @respan(sp,\n+                      box(GC) respan(sp,\n                            ast::ViewPathList(self.path(sp, path),\n                                              imports,\n                                              ast::DUMMY_NODE_ID)))\n@@ -990,7 +1018,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn view_use_glob(&self, sp: Span,\n                      vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      @respan(sp,\n+                      box(GC) respan(sp,\n                            ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID)))\n     }\n }\n@@ -1013,8 +1041,8 @@ pub trait Duplicate {\n     fn duplicate(&self, cx: &ExtCtxt) -> Self;\n }\n \n-impl Duplicate for @ast::Expr {\n-    fn duplicate(&self, _: &ExtCtxt) -> @ast::Expr {\n+impl Duplicate for Gc<ast::Expr> {\n+    fn duplicate(&self, _: &ExtCtxt) -> Gc<ast::Expr> {\n         let mut folder = Duplicator;\n         folder.fold_expr(*self)\n     }"}, {"sha": "3522095ed70049e691f9424a51d8e795a0caeb30", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -44,7 +44,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     }\n     let res = str_to_ident(res_str.as_slice());\n \n-    let e = @ast::Expr {\n+    let e = box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(\n             ast::Path {"}, {"sha": "fac9f37c462cca8328c69458eb6ed93210a2b735", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -14,11 +14,13 @@ use ext::base::ExtCtxt;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_bound(cx: &mut ExtCtxt,\n                              span: Span,\n-                             mitem: @MetaItem,\n-                             item: @Item,\n-                             push: |@Item|) {\n+                             mitem: Gc<MetaItem>,\n+                             item: Gc<Item>,\n+                             push: |Gc<Item>|) {\n \n     let name = match mitem.node {\n         MetaWord(ref tname) => {"}, {"sha": "93e4920bc1de43f5df09cda2be599d4018d10e3c", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,11 +16,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n-                             mitem: @MetaItem,\n-                             item: @Item,\n-                             push: |@Item|) {\n+                             mitem: Gc<MetaItem>,\n+                             item: Gc<Item>,\n+                             push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -51,7 +53,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n fn cs_clone(\n     name: &str,\n     cx: &mut ExtCtxt, trait_span: Span,\n-    substr: &Substructure) -> @Expr {\n+    substr: &Substructure) -> Gc<Expr> {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;"}, {"sha": "ef8d477a98e678f83e9ecd3108c5ca5cf3c44857", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,18 +16,20 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n-                          mitem: @MetaItem,\n-                          item: @Item,\n-                          push: |@Item|) {\n+                          mitem: Gc<MetaItem>,\n+                          item: Gc<Item>,\n+                          push: |Gc<Item>|) {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }"}, {"sha": "88ebe8a60faff5370bfacb7a1b5e025099d8add5", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n-                           mitem: @MetaItem,\n-                           item: @Item,\n-                           push: |@Item|) {\n+                           mitem: Gc<MetaItem>,\n+                           item: Gc<Item>,\n+                           push: |Gc<Item>|) {\n     macro_rules! md (\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -58,7 +60,8 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n+         substr: &Substructure) -> Gc<Expr> {\n     let op = if less {ast::BiLt} else {ast::BiGt};\n     cs_fold(\n         false, // need foldr,"}, {"sha": "8b1e0498d253c43907b43ce5dc0ae37c2b0ae89d", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,12 +16,15 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                                span: Span,\n-                               mitem: @MetaItem,\n-                               item: @Item,\n-                               push: |@Item|) {\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+                               mitem: Gc<MetaItem>,\n+                               item: Gc<Item>,\n+                               push: |Gc<Item>|) {\n+    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span,\n+                          substr: &Substructure) -> Gc<Expr> {\n         cs_same_method(|cx, span, exprs| {\n             // create `a.<method>(); b.<method>(); c.<method>(); ...`\n             // (where method is `assert_receiver_is_total_eq`)"}, {"sha": "271aa90cd24a4f5ea1114745a08fdedd16cbc3c7", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -18,12 +18,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n use std::cmp::{Ordering, Equal, Less, Greater};\n+use std::gc::Gc;\n \n pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 span: Span,\n-                                mitem: @MetaItem,\n-                                item: @Item,\n-                                push: |@Item|) {\n+                                mitem: Gc<MetaItem>,\n+                                item: Gc<Item>,\n+                                push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -65,7 +66,7 @@ pub fn ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> ast::Path\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> @Expr {\n+              substr: &Substructure) -> Gc<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n     let equals_path = ordering_const(cx, span, Equal);\n "}, {"sha": "0c23d65fde046e788da842b10c50008c0160d1b1", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -23,11 +23,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use parse::token;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n-                                 mitem: @MetaItem,\n-                                 item: @Item,\n-                                 push: |@Item|) {\n+                                 mitem: Gc<MetaItem>,\n+                                 item: Gc<Item>,\n+                                 push: |Gc<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -64,7 +66,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n }\n \n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure) -> @Expr {\n+                          substr: &Substructure) -> Gc<Expr> {\n     let decoder = substr.nonself_args[0];\n     let recurse = vec!(cx.ident_of(\"serialize\"),\n                     cx.ident_of(\"Decodable\"),\n@@ -159,8 +161,8 @@ fn decode_static_fields(cx: &mut ExtCtxt,\n                         trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> @Expr)\n-                        -> @Expr {\n+                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> Gc<Expr>)\n+                        -> Gc<Expr> {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {"}, {"sha": "dfebc0f5e642111a25a1015b857e67cbd66faf43", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,11 +16,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -46,7 +48,8 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn default_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                        substr: &Substructure) -> Gc<Expr> {\n     let default_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),"}, {"sha": "f57670af1999b3c90be860f84f67907ba012f91a", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -91,11 +91,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n-                                 mitem: @MetaItem,\n-                                 item: @Item,\n-                                 push: |@Item|) {\n+                                 mitem: Gc<MetaItem>,\n+                                 item: Gc<Item>,\n+                                 push: |Gc<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -134,7 +136,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n }\n \n fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure) -> @Expr {\n+                          substr: &Substructure) -> Gc<Expr> {\n     let encoder = substr.nonself_args[0];\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_e\");"}, {"sha": "251eae75ee551eeba93094c26fbb2e98e07487dc", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 72, "deletions": 69, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -178,6 +178,7 @@ StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span\n */\n \n use std::cell::RefCell;\n+use std::gc::Gc;\n \n use ast;\n use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n@@ -248,9 +249,9 @@ pub struct Substructure<'a> {\n     /// ident of the method\n     pub method_ident: Ident,\n     /// dereferenced access to any Self or Ptr(Self, _) arguments\n-    pub self_args: &'a [@Expr],\n+    pub self_args: &'a [Gc<Expr>],\n     /// verbatim access to any other arguments\n-    pub nonself_args: &'a [@Expr],\n+    pub nonself_args: &'a [Gc<Expr>],\n     pub fields: &'a SubstructureFields<'a>\n }\n \n@@ -262,42 +263,43 @@ pub struct FieldInfo {\n     pub name: Option<Ident>,\n     /// The expression corresponding to this field of `self`\n     /// (specifically, a reference to it).\n-    pub self_: @Expr,\n+    pub self_: Gc<Expr>,\n     /// The expressions corresponding to references to this field in\n     /// the other Self arguments.\n-    pub other: Vec<@Expr>,\n+    pub other: Vec<Gc<Expr>>,\n }\n \n /// Fields for a static method\n pub enum StaticFields {\n     /// Tuple structs/enum variants like this\n-    Unnamed(Vec<Span> ),\n+    Unnamed(Vec<Span>),\n     /// Normal structs/struct variants.\n-    Named(Vec<(Ident, Span)> )\n+    Named(Vec<(Ident, Span)>),\n }\n \n /// A summary of the possible sets of fields. See above for details\n /// and examples\n pub enum SubstructureFields<'a> {\n-    Struct(Vec<FieldInfo> ),\n+    Struct(Vec<FieldInfo>),\n     /**\n     Matching variants of the enum: variant index, ast::Variant,\n     fields: the field name is only non-`None` in the case of a struct\n     variant.\n     */\n-    EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo> ),\n+    EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo>),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::Variant,\n     [field span, field ident, fields])] \\(i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'a [(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )]),\n+    EnumNonMatching(&'a [(uint, P<ast::Variant>,\n+                          Vec<(Span, Option<Ident>, Gc<Expr>)>)]),\n \n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n     /// A static method where Self is an enum.\n-    StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)> )\n+    StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)>),\n }\n \n \n@@ -307,7 +309,7 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'a> =\n-    |&mut ExtCtxt, Span, &Substructure|: 'a -> @Expr;\n+    |&mut ExtCtxt, Span, &Substructure|: 'a -> Gc<Expr>;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n@@ -317,9 +319,9 @@ representing each variant: (variant index, ast::Variant instance,\n pub type EnumNonMatchFunc<'a> =\n     |&mut ExtCtxt,\n            Span,\n-           &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )],\n-           &[@Expr]|: 'a\n-           -> @Expr;\n+           &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, Gc<Expr>)>)],\n+           &[Gc<Expr>]|: 'a\n+           -> Gc<Expr>;\n \n pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n     -> RefCell<CombineSubstructureFunc<'a>> {\n@@ -330,13 +332,13 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   cx: &mut ExtCtxt,\n-                  _mitem: @ast::MetaItem,\n-                  item: @ast::Item,\n-                  push: |@ast::Item|) {\n+                  _mitem: Gc<ast::MetaItem>,\n+                  item: Gc<ast::Item>,\n+                  push: |Gc<ast::Item>|) {\n         let newitem = match item.node {\n-            ast::ItemStruct(struct_def, ref generics) => {\n+            ast::ItemStruct(ref struct_def, ref generics) => {\n                 self.expand_struct_def(cx,\n-                                       struct_def,\n+                                       &**struct_def,\n                                        item.ident,\n                                        generics)\n             }\n@@ -357,7 +359,7 @@ impl<'a> TraitDef<'a> {\n                 _ => false,\n             }\n         }).map(|a| a.clone()));\n-        push(@ast::Item {\n+        push(box(GC) ast::Item {\n             attrs: attrs,\n             ..(*newitem).clone()\n         })\n@@ -379,7 +381,7 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: Vec<@ast::Method> ) -> @ast::Item {\n+                           methods: Vec<Gc<ast::Method>> ) -> Gc<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let Generics { mut lifetimes, ty_params } =\n@@ -435,7 +437,7 @@ impl<'a> TraitDef<'a> {\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let ident = ast_util::impl_pretty_name(&opt_trait_ref, self_type);\n+        let ident = ast_util::impl_pretty_name(&opt_trait_ref, &*self_type);\n         cx.item(\n             self.span,\n             ident,\n@@ -448,7 +450,7 @@ impl<'a> TraitDef<'a> {\n                          cx: &mut ExtCtxt,\n                          struct_def: &StructDef,\n                          type_ident: Ident,\n-                         generics: &Generics) -> @ast::Item {\n+                         generics: &Generics) -> Gc<ast::Item> {\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(\n@@ -484,7 +486,7 @@ impl<'a> TraitDef<'a> {\n                        cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n                        type_ident: Ident,\n-                       generics: &Generics) -> @ast::Item {\n+                       generics: &Generics) -> Gc<ast::Item> {\n         let methods = self.methods.iter().map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, self,\n@@ -522,10 +524,10 @@ impl<'a> MethodDef<'a> {\n                                 cx: &mut ExtCtxt,\n                                 trait_: &TraitDef,\n                                 type_ident: Ident,\n-                                self_args: &[@Expr],\n-                                nonself_args: &[@Expr],\n+                                self_args: &[Gc<Expr>],\n+                                nonself_args: &[Gc<Expr>],\n                                 fields: &SubstructureFields)\n-        -> @Expr {\n+        -> Gc<Expr> {\n         let substructure = Substructure {\n             type_ident: type_ident,\n             method_ident: cx.ident_of(self.name),\n@@ -556,7 +558,8 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                type_ident: Ident,\n                                generics: &Generics)\n-        -> (ast::ExplicitSelf, Vec<@Expr> , Vec<@Expr> , Vec<(Ident, P<ast::Ty>)> ) {\n+        -> (ast::ExplicitSelf, Vec<Gc<Expr>>, Vec<Gc<Expr>>,\n+            Vec<(Ident, P<ast::Ty>)>) {\n \n         let mut self_args = Vec::new();\n         let mut nonself_args = Vec::new();\n@@ -608,7 +611,7 @@ impl<'a> MethodDef<'a> {\n                      generics: &Generics,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: @Expr) -> @ast::Method {\n+                     body: Gc<Expr>) -> Gc<ast::Method> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -630,7 +633,7 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         // Create the method.\n-        @ast::Method {\n+        box(GC) ast::Method {\n             ident: method_ident,\n             attrs: self.attributes.clone(),\n             generics: fn_generics,\n@@ -670,9 +673,9 @@ impl<'a> MethodDef<'a> {\n                                  trait_: &TraitDef,\n                                  struct_def: &StructDef,\n                                  type_ident: Ident,\n-                                 self_args: &[@Expr],\n-                                 nonself_args: &[@Expr])\n-        -> @Expr {\n+                                 self_args: &[Gc<Expr>],\n+                                 nonself_args: &[Gc<Expr>])\n+        -> Gc<Expr> {\n \n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n@@ -737,9 +740,9 @@ impl<'a> MethodDef<'a> {\n                                         trait_: &TraitDef,\n                                         struct_def: &StructDef,\n                                         type_ident: Ident,\n-                                        self_args: &[@Expr],\n-                                        nonself_args: &[@Expr])\n-        -> @Expr {\n+                                        self_args: &[Gc<Expr>],\n+                                        nonself_args: &[Gc<Expr>])\n+        -> Gc<Expr> {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(cx,\n@@ -780,9 +783,9 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                enum_def: &EnumDef,\n                                type_ident: Ident,\n-                               self_args: &[@Expr],\n-                               nonself_args: &[@Expr])\n-                               -> @Expr {\n+                               self_args: &[Gc<Expr>],\n+                               nonself_args: &[Gc<Expr>])\n+                               -> Gc<Expr> {\n         let mut matches = Vec::new();\n         self.build_enum_match(cx, trait_, enum_def, type_ident,\n                               self_args, nonself_args,\n@@ -816,12 +819,12 @@ impl<'a> MethodDef<'a> {\n                         trait_: &TraitDef,\n                         enum_def: &EnumDef,\n                         type_ident: Ident,\n-                        self_args: &[@Expr],\n-                        nonself_args: &[@Expr],\n+                        self_args: &[Gc<Expr>],\n+                        nonself_args: &[Gc<Expr>],\n                         matching: Option<uint>,\n                         matches_so_far: &mut Vec<(uint, P<ast::Variant>,\n-                                              Vec<(Span, Option<Ident>, @Expr)> )> ,\n-                        match_count: uint) -> @Expr {\n+                                              Vec<(Span, Option<Ident>, Gc<Expr>)>)> ,\n+                        match_count: uint) -> Gc<Expr> {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n@@ -871,7 +874,7 @@ impl<'a> MethodDef<'a> {\n                             other: (*other).clone()\n                         }\n                     }).collect();\n-                    EnumMatching(variant_index, variant, field_tuples)\n+                    EnumMatching(variant_index, &*variant, field_tuples)\n                 }\n                 None => {\n                     EnumNonMatching(matches_so_far.as_slice())\n@@ -905,7 +908,7 @@ impl<'a> MethodDef<'a> {\n                 let variant = *enum_def.variants.get(index);\n                 let (pattern, idents) = trait_.create_enum_variant_pattern(\n                     cx,\n-                    variant,\n+                    &*variant,\n                     current_match_str.as_slice(),\n                     ast::MutImmutable);\n \n@@ -938,7 +941,7 @@ impl<'a> MethodDef<'a> {\n                     let (pattern, idents) =\n                         trait_.create_enum_variant_pattern(\n                             cx,\n-                            variant,\n+                            &*variant,\n                             current_match_str.as_slice(),\n                             ast::MutImmutable);\n \n@@ -974,17 +977,17 @@ impl<'a> MethodDef<'a> {\n                                       trait_: &TraitDef,\n                                       enum_def: &EnumDef,\n                                       type_ident: Ident,\n-                                      self_args: &[@Expr],\n-                                      nonself_args: &[@Expr])\n-        -> @Expr {\n+                                      self_args: &[Gc<Expr>],\n+                                      nonself_args: &[Gc<Expr>])\n+        -> Gc<Expr> {\n         let summary = enum_def.variants.iter().map(|v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n                     Unnamed(args.iter().map(|va| trait_.set_expn_info(cx, va.ty.span)).collect())\n                 }\n-                ast::StructVariantKind(struct_def) => {\n-                    trait_.summarise_struct(cx, struct_def)\n+                ast::StructVariantKind(ref struct_def) => {\n+                    trait_.summarise_struct(cx, &**struct_def)\n                 }\n             };\n             (ident, v.span, summary)\n@@ -1009,7 +1012,7 @@ impl<'a> TraitDef<'a> {\n             None => cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };\n-        to_set.expn_info = Some(@codemap::ExpnInfo {\n+        to_set.expn_info = Some(box(GC) codemap::ExpnInfo {\n             call_site: to_set,\n             callee: codemap::NameAndSpan {\n                 name: format!(\"deriving({})\", trait_name).to_string(),\n@@ -1048,7 +1051,7 @@ impl<'a> TraitDef<'a> {\n                           cx: &mut ExtCtxt,\n                           field_paths: Vec<ast::Path> ,\n                           mutbl: ast::Mutability)\n-                          -> Vec<@ast::Pat> {\n+                          -> Vec<Gc<ast::Pat>> {\n         field_paths.iter().map(|path| {\n             cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n@@ -1061,7 +1064,7 @@ impl<'a> TraitDef<'a> {\n                              struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-                             -> (@ast::Pat, Vec<(Span, Option<Ident>, @Expr)> ) {\n+                             -> (Gc<ast::Pat>, Vec<(Span, Option<Ident>, Gc<Expr>)>) {\n         if struct_def.fields.is_empty() {\n             return (\n                 cx.pat_ident_binding_mode(\n@@ -1126,7 +1129,7 @@ impl<'a> TraitDef<'a> {\n                                    variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n-        -> (@ast::Pat, Vec<(Span, Option<Ident>, @Expr)> ) {\n+        -> (Gc<ast::Pat>, Vec<(Span, Option<Ident>, Gc<Expr>)> ) {\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n@@ -1159,8 +1162,8 @@ impl<'a> TraitDef<'a> {\n                 (cx.pat_enum(variant.span, matching_path, subpats),\n                  ident_expr)\n             }\n-            ast::StructVariantKind(struct_def) => {\n-                self.create_struct_pattern(cx, variant_ident, struct_def,\n+            ast::StructVariantKind(ref struct_def) => {\n+                self.create_struct_pattern(cx, variant_ident, &**struct_def,\n                                            prefix, mutbl)\n             }\n         }\n@@ -1174,13 +1177,13 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: |&mut ExtCtxt, Span, @Expr, @Expr, &[@Expr]| -> @Expr,\n-               base: @Expr,\n+               f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>, &[Gc<Expr>]| -> Gc<Expr>,\n+               base: Gc<Expr>,\n                enum_nonmatch_f: EnumNonMatchFunc,\n                cx: &mut ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n-               -> @Expr {\n+               -> Gc<Expr> {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n@@ -1221,12 +1224,12 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<@Expr> | -> @Expr,\n+pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n-                      -> @Expr {\n+                      -> Gc<Expr> {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n@@ -1257,13 +1260,13 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: |&mut ExtCtxt, Span, @Expr, @Expr| -> @Expr,\n-                           base: @Expr,\n+                           f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>| -> Gc<Expr>,\n+                           base: Gc<Expr>,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n                            cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n-                           -> @Expr {\n+                           -> Gc<Expr> {\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n@@ -1285,10 +1288,10 @@ Use a given binop to combine the result of calling the derived method\n on all the fields.\n */\n #[inline]\n-pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n+pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n-                substructure: &Substructure) -> @Expr {\n+                substructure: &Substructure) -> Gc<Expr> {\n     cs_same_method_fold(\n         true, // foldl is good enough\n         |cx, span, old, new| {\n@@ -1306,7 +1309,7 @@ pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              cx: &mut ExtCtxt, span: Span,\n-             substructure: &Substructure) -> @Expr {\n+             substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n              cx, span, substructure)\n@@ -1316,7 +1319,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n               cx: &mut ExtCtxt, span: Span,\n-              substructure: &Substructure) -> @Expr {\n+              substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n              cx, span, substructure)"}, {"sha": "7501b950770c2e0c96f603d7d536a612792265c3", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -20,6 +20,7 @@ use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use owned_slice::OwnedSlice;\n \n+use std::gc::Gc;\n \n /// The types of pointers\n pub enum PtrTy<'a> {\n@@ -81,7 +82,7 @@ impl<'a> Path<'a> {\n /// A type. Supports pointers (except for *), Self, and literals\n pub enum Ty<'a> {\n     Self,\n-    // &/Box/@ Ty\n+    // &/Box/ Ty\n     Ptr(Box<Ty<'a>>, PtrTy<'a>),\n     // mod::mod::Type<[lifetime], [Params...]>, including a plain type\n     // parameter, and things like `int`\n@@ -244,7 +245,7 @@ impl<'a> LifetimeBounds<'a> {\n \n \n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n-    -> (@Expr, ast::ExplicitSelf) {\n+    -> (Gc<Expr>, ast::ExplicitSelf) {\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {"}, {"sha": "77fb013b269a222331a368e933bdedbb83e2946b", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n \n     let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n         (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,\n@@ -64,7 +66,8 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n     hash_trait_def.expand(cx, mitem, item, push);\n }\n \n-fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                     substr: &Substructure) -> Gc<Expr> {\n     let state_expr = match substr.nonself_args {\n         [state_expr] => state_expr,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(Hash)`\")"}, {"sha": "1833e56dbfb0895f0c6bebf547b70c44bbe8e19f", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -22,6 +22,8 @@ use ast::{Item, MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use codemap::Span;\n \n+use std::gc::Gc;\n+\n pub mod bounds;\n pub mod clone;\n pub mod encodable;\n@@ -47,9 +49,9 @@ pub mod generic;\n \n pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             _span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     match mitem.node {\n         MetaNameValue(_, ref l) => {\n             cx.span_err(l.span, \"unexpected value in `deriving`\");"}, {"sha": "735497d9a2cf6ccfd6d50e9473d4545851cda2d5", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n-                                      mitem: @MetaItem,\n-                                      item: @Item,\n-                                      push: |@Item|) {\n+                                      mitem: Gc<MetaItem>,\n+                                      item: Gc<Item>,\n+                                      push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -70,7 +72,8 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,\n+           substr: &Substructure) -> Gc<Expr> {\n     let n = match substr.nonself_args {\n         [n] => n,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(FromPrimitive)`\")"}, {"sha": "f6a15ea917e187c74910ce9563da32f02e07e655", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,11 +16,13 @@ use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -53,7 +55,8 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                     substr: &Substructure) -> Gc<Expr> {\n     let rng = match substr.nonself_args {\n         [rng] => vec!( rng ),\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -134,8 +137,8 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                   trait_span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n-                  rand_call: |&mut ExtCtxt, Span| -> @Expr)\n-                  -> @Expr {\n+                  rand_call: |&mut ExtCtxt, Span| -> Gc<Expr>)\n+                  -> Gc<Expr> {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {"}, {"sha": "9c5e41c8f60fa35ebab18a511c7a9cbe3f08f80d", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -20,12 +20,13 @@ use parse::token;\n \n use std::collections::HashMap;\n use std::string::String;\n+use std::gc::Gc;\n \n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(box Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));\n@@ -57,7 +58,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n // we construct a format string and then defer to std::fmt, since that\n // knows what's up with formatting at so on.\n fn show_substructure(cx: &mut ExtCtxt, span: Span,\n-                     substr: &Substructure) -> @Expr {\n+                     substr: &Substructure) -> Gc<Expr> {\n     // build `<name>`, `<name>({}, {}, ...)` or `<name> { <field>: {},\n     // <field>: {}, ... }` based on the \"shape\".\n     //"}, {"sha": "93947251223fd18eacc5a2e6f6d3eab521f48f88", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,11 +16,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n+use std::gc::Gc;\n+\n pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             span: Span,\n-                            mitem: @MetaItem,\n-                            item: @Item,\n-                            push: |@Item|) {\n+                            mitem: Gc<MetaItem>,\n+                            item: Gc<Item>,\n+                            push: |Gc<Item>|) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -63,7 +65,8 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n+fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                     substr: &Substructure) -> Gc<Expr> {\n     let zero_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),"}, {"sha": "fffaa12fa1f8542442c7a2f4f27a36e77db232ff", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -29,7 +29,9 @@ use visit;\n use visit::Visitor;\n use util::small_vector::SmallVector;\n \n-pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n+use std::gc::Gc;\n+\n+pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -115,7 +117,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                         fld.fold_expr(marked_after).node.clone();\n                     fld.cx.bt_pop();\n \n-                    @ast::Expr {\n+                    box(GC) ast::Expr {\n                         id: ast::DUMMY_NODE_ID,\n                         node: fully_expanded,\n                         span: e.span,\n@@ -172,7 +174,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n             let value_ident = token::gensym_ident(\"__value\");\n             // this is careful to use src_pat.span so that error\n             // messages point exact at that.\n-            let local = @ast::Local {\n+            let local = box(GC) ast::Local {\n                 ty: fld.cx.ty_infer(src_pat.span),\n                 pat: src_pat,\n                 init: Some(fld.cx.expr_ident(src_pat.span, value_ident)),\n@@ -181,7 +183,8 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                 source: ast::LocalFor\n             };\n             let local = codemap::respan(src_pat.span, ast::DeclLocal(local));\n-            let local = @codemap::respan(span, ast::StmtDecl(@local, ast::DUMMY_NODE_ID));\n+            let local = box(GC) codemap::respan(span, ast::StmtDecl(box(GC) local,\n+                                                            ast::DUMMY_NODE_ID));\n \n             // { let ...; <src_loop_block> }\n             let block = fld.cx.block(span, vec![local],\n@@ -256,7 +259,7 @@ fn expand_loop_block(loop_block: P<Block>,\n             // in a block enclosed by loop head.\n             fld.extsbox.push_frame();\n             fld.extsbox.info().pending_renames.push(rename);\n-            let expanded_block = expand_block_elts(loop_block, fld);\n+            let expanded_block = expand_block_elts(&*loop_block, fld);\n             fld.extsbox.pop_frame();\n \n             (expanded_block, Some(renamed_ident))\n@@ -277,8 +280,8 @@ macro_rules! with_exts_frame (\n )\n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n-                   -> SmallVector<@ast::Item> {\n+pub fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n+                   -> SmallVector<Gc<ast::Item>> {\n     let it = expand_item_modifiers(it, fld);\n \n     let mut decorator_items = SmallVector::zero();\n@@ -301,7 +304,7 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n \n                 // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n                 // but that double-mut-borrows fld\n-                let mut items: SmallVector<@ast::Item> = SmallVector::zero();\n+                let mut items: SmallVector<Gc<ast::Item>> = SmallVector::zero();\n                 dec_fn(fld.cx, attr.span, attr.node.value, it,\n                        |item| items.push(item));\n                 decorator_items.extend(items.move_iter()\n@@ -320,34 +323,34 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n             let macro_escape = contains_macro_escape(new_attrs.as_slice());\n             let result = with_exts_frame!(fld.extsbox,\n                                           macro_escape,\n-                                          noop_fold_item(it, fld));\n+                                          noop_fold_item(&*it, fld));\n             fld.cx.mod_pop();\n             result\n         },\n         _ => {\n-            let it = @ast::Item {\n+            let it = box(GC) ast::Item {\n                 attrs: new_attrs,\n                 ..(*it).clone()\n \n             };\n-            noop_fold_item(it, fld)\n+            noop_fold_item(&*it, fld)\n         }\n     };\n \n     new_items.push_all(decorator_items);\n     new_items\n }\n \n-fn expand_item_modifiers(mut it: @ast::Item, fld: &mut MacroExpander)\n-                         -> @ast::Item {\n+fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n+                         -> Gc<ast::Item> {\n     let (modifiers, attrs) = it.attrs.partitioned(|attr| {\n         match fld.extsbox.find(&intern(attr.name().get())) {\n             Some(&ItemModifier(_)) => true,\n             _ => false\n         }\n     });\n \n-    it = @ast::Item {\n+    it = box(GC) ast::Item {\n         attrs: attrs,\n         ..(*it).clone()\n     };\n@@ -388,8 +391,8 @@ pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n-                       -> SmallVector<@ast::Item> {\n+pub fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n+                       -> SmallVector<Gc<ast::Item>> {\n     let (pth, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n             node: MacInvocTT(ref pth, ref tts, _),\n@@ -494,7 +497,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n }\n \n // expand a stmt\n-pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n+pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi) = match s.node {\n@@ -550,7 +553,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n                 }\n             };\n \n-            mark_stmt(expanded,fm)\n+            mark_stmt(&*expanded,fm)\n         }\n \n         _ => {\n@@ -561,20 +564,20 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     };\n \n     // Keep going, outside-in.\n-    let fully_expanded = fld.fold_stmt(marked_after);\n+    let fully_expanded = fld.fold_stmt(&*marked_after);\n     if fully_expanded.is_empty() {\n         fld.cx.span_err(pth.span, \"macro didn't expand to a statement\");\n         return SmallVector::zero();\n     }\n     fld.cx.bt_pop();\n-    let fully_expanded: SmallVector<@Stmt> = fully_expanded.move_iter()\n-            .map(|s| @Spanned { span: s.span, node: s.node.clone() })\n+    let fully_expanded: SmallVector<Gc<Stmt>> = fully_expanded.move_iter()\n+            .map(|s| box(GC) Spanned { span: s.span, node: s.node.clone() })\n             .collect();\n \n     fully_expanded.move_iter().map(|s| {\n         match s.node {\n             StmtExpr(e, stmt_id) if semi => {\n-                @Spanned {\n+                box(GC) Spanned {\n                     span: s.span,\n                     node: StmtSemi(e, stmt_id)\n                 }\n@@ -587,7 +590,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n-                         -> SmallVector<@Stmt> {\n+                         -> SmallVector<Gc<Stmt>> {\n     // is it a let?\n     match s.node {\n         StmtDecl(decl, node_id) => {\n@@ -612,7 +615,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n                     let mut name_finder = new_name_finder(Vec::new());\n-                    name_finder.visit_pat(expanded_pat,());\n+                    name_finder.visit_pat(&*expanded_pat,());\n                     // generate fresh names, push them to a new pending list\n                     let mut new_pending_renames = Vec::new();\n                     for ident in name_finder.ident_accumulator.iter() {\n@@ -631,16 +634,16 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     // also, don't forget to expand the init:\n                     let new_init_opt = init.map(|e| fld.fold_expr(e));\n                     let rewritten_local =\n-                        @Local {\n+                        box(GC) Local {\n                             ty: local.ty,\n                             pat: rewritten_pat,\n                             init: new_init_opt,\n                             id: id,\n                             span: span,\n                             source: source\n                         };\n-                    SmallVector::one(@Spanned {\n-                        node: StmtDecl(@Spanned {\n+                    SmallVector::one(box(GC) Spanned {\n+                        node: StmtDecl(box(GC) Spanned {\n                                 node: DeclLocal(rewritten_local),\n                                 span: stmt_span\n                             },\n@@ -687,7 +690,7 @@ impl Visitor<()> for NewNameFinderContext {\n                 }\n                 // visit optional subpattern of pat_ident:\n                 for subpat in inner.iter() {\n-                    self.visit_pat(*subpat, ())\n+                    self.visit_pat(&**subpat, ())\n                 }\n             }\n             // use the default traversal for non-pat_idents\n@@ -725,9 +728,9 @@ pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n             let renamed_stmt = {\n                 let pending_renames = &mut fld.extsbox.info().pending_renames;\n                 let mut rename_fld = renames_to_fold(pending_renames);\n-                rename_fld.fold_stmt(*x).expect_one(\"rename_fold didn't return one value\")\n+                rename_fld.fold_stmt(&**x).expect_one(\"rename_fold didn't return one value\")\n             };\n-            fld.fold_stmt(renamed_stmt).move_iter()\n+            fld.fold_stmt(&*renamed_stmt).move_iter()\n         }).collect();\n     let new_expr = b.expr.map(|x| {\n         let expr = {\n@@ -747,7 +750,7 @@ pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     })\n }\n \n-pub fn expand_pat(p: @ast::Pat, fld: &mut MacroExpander) -> @ast::Pat {\n+pub fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n     let (pth, tts) = match p.node {\n         PatMac(ref mac) => {\n             match mac.node {\n@@ -817,7 +820,7 @@ pub fn expand_pat(p: @ast::Pat, fld: &mut MacroExpander) -> @ast::Pat {\n         fld.fold_pat(marked_after).node.clone();\n     fld.cx.bt_pop();\n \n-    @ast::Pat {\n+    box(GC) ast::Pat {\n         id: ast::DUMMY_NODE_ID,\n         node: fully_expanded,\n         span: p.span,\n@@ -863,24 +866,24 @@ pub struct MacroExpander<'a, 'b> {\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n-    fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n+    fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         expand_expr(expr, self)\n     }\n \n-    fn fold_pat(&mut self, pat: @ast::Pat) -> @ast::Pat {\n+    fn fold_pat(&mut self, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n         expand_pat(pat, self)\n     }\n \n-    fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n+    fn fold_item(&mut self, item: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n         expand_item(item, self)\n     }\n \n-    fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n+    fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<Gc<ast::Stmt>> {\n         expand_stmt(stmt, self)\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        expand_block(block, self)\n+        expand_block(&*block, self)\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n@@ -976,27 +979,27 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n-fn mark_expr(expr: @ast::Expr, m: Mrk) -> @ast::Expr {\n+fn mark_expr(expr: Gc<ast::Expr>, m: Mrk) -> Gc<ast::Expr> {\n     new_mark_folder(m).fold_expr(expr)\n }\n \n // apply a given mark to the given pattern. Used following the expansion of a macro.\n-fn mark_pat(pat: @ast::Pat, m: Mrk) -> @ast::Pat {\n+fn mark_pat(pat: Gc<ast::Pat>, m: Mrk) -> Gc<ast::Pat> {\n     new_mark_folder(m).fold_pat(pat)\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> @ast::Stmt {\n+fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> Gc<ast::Stmt> {\n     new_mark_folder(m).fold_stmt(expr)\n             .expect_one(\"marking a stmt didn't return a stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr: @ast::Item, m: Mrk) -> SmallVector<@ast::Item> {\n+fn mark_item(expr: Gc<ast::Item>, m: Mrk) -> SmallVector<Gc<ast::Item>> {\n     new_mark_folder(m).fold_item(expr)\n }\n \n-fn original_span(cx: &ExtCtxt) -> @codemap::ExpnInfo {\n+fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n     let mut relevant_info = cx.backtrace();\n     let mut einfo = relevant_info.unwrap();\n     loop {\n@@ -1134,7 +1137,7 @@ mod test {\n             node: Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: AttrOuter,\n-                value: @Spanned {\n+                value: box(GC) Spanned {\n                     node: MetaWord(token::intern_and_get_ident(s)),\n                     span: codemap::DUMMY_SP,\n                 },"}, {"sha": "8cf290b826b9ab740b4afb0c1731b25fde6ee499", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -20,6 +20,7 @@ use rsparse = parse;\n \n use parse = fmt_macros;\n use std::collections::{HashMap, HashSet};\n+use std::gc::Gc;\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n@@ -39,29 +40,29 @@ struct Context<'a, 'b> {\n \n     // Parsed argument expressions and the types that we've found so far for\n     // them.\n-    args: Vec<@ast::Expr>,\n+    args: Vec<Gc<ast::Expr>>,\n     arg_types: Vec<Option<ArgumentType>>,\n     // Parsed named expressions and the types that we've found for them so far.\n     // Note that we keep a side-array of the ordering of the named arguments\n     // found to be sure that we can translate them in the same order that they\n     // were declared in.\n-    names: HashMap<String, @ast::Expr>,\n+    names: HashMap<String, Gc<ast::Expr>>,\n     name_types: HashMap<String, ArgumentType>,\n     name_ordering: Vec<String>,\n \n     // Collection of the compiled `rt::Piece` structures\n-    pieces: Vec<@ast::Expr> ,\n+    pieces: Vec<Gc<ast::Expr>>,\n     name_positions: HashMap<String, uint>,\n-    method_statics: Vec<@ast::Item> ,\n+    method_statics: Vec<Gc<ast::Item>>,\n \n     // Updated as arguments are consumed or methods are entered\n     nest_level: uint,\n     next_arg: uint,\n }\n \n pub enum Invocation {\n-    Call(@ast::Expr),\n-    MethodCall(@ast::Expr, ast::Ident),\n+    Call(Gc<ast::Expr>),\n+    MethodCall(Gc<ast::Expr>, ast::Ident),\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -74,10 +75,10 @@ pub enum Invocation {\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n               tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<String>,\n-                            HashMap<String, @ast::Expr>)>) {\n+    -> (Invocation, Option<(Gc<ast::Expr>, Vec<Gc<ast::Expr>>, Vec<String>,\n+                            HashMap<String, Gc<ast::Expr>>)>) {\n     let mut args = Vec::new();\n-    let mut names = HashMap::<String, @ast::Expr>::new();\n+    let mut names = HashMap::<String, Gc<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n     let mut p = rsparse::new_parser_from_tts(ecx.parse_sess(),\n@@ -399,15 +400,15 @@ impl<'a, 'b> Context<'a, 'b> {\n           self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s))\n     }\n \n-    fn none(&self) -> @ast::Expr {\n+    fn none(&self) -> Gc<ast::Expr> {\n         let none = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n                 self.ecx.ident_of(\"None\")));\n         self.ecx.expr_path(none)\n     }\n \n-    fn some(&self, e: @ast::Expr) -> @ast::Expr {\n+    fn some(&self, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         let p = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n@@ -416,7 +417,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_call(self.fmtsp, p, vec!(e))\n     }\n \n-    fn trans_count(&self, c: parse::Count) -> @ast::Expr {\n+    fn trans_count(&self, c: parse::Count) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n         match c {\n             parse::CountIs(i) => {\n@@ -447,7 +448,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn trans_method(&mut self, method: &parse::Method) -> @ast::Expr {\n+    fn trans_method(&mut self, method: &parse::Method) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n         let method = match *method {\n             parse::Select(ref arms, ref default) => {\n@@ -528,7 +529,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n \n     /// Translate a `parse::Piece` to a static `rt::Piece`\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::Expr {\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> Gc<ast::Expr> {\n         let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n@@ -615,7 +616,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n-    fn to_expr(&self, invocation: Invocation) -> @ast::Expr {\n+    fn to_expr(&self, invocation: Invocation) -> Gc<ast::Expr> {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n         let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n@@ -625,8 +626,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         // First, declare all of our methods that are statics\n         for &method in self.method_statics.iter() {\n             let decl = respan(self.fmtsp, ast::DeclItem(method));\n-            lets.push(@respan(self.fmtsp,\n-                              ast::StmtDecl(@decl, ast::DUMMY_NODE_ID)));\n+            lets.push(box(GC) respan(self.fmtsp,\n+                              ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n         }\n \n         // Next, build up the static array which will become our precompiled\n@@ -653,7 +654,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         let item = self.ecx.item(self.fmtsp, static_name,\n                                  self.static_attrs(), st);\n         let decl = respan(self.fmtsp, ast::DeclItem(item));\n-        lets.push(@respan(self.fmtsp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID)));\n+        lets.push(box(GC) respan(self.fmtsp,\n+                                 ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID)));\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -766,8 +768,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_match(self.fmtsp, head, vec!(arm))\n     }\n \n-    fn format_arg(&self, sp: Span, argno: Position, arg: @ast::Expr)\n-                  -> @ast::Expr {\n+    fn format_arg(&self, sp: Span, argno: Position, arg: Gc<ast::Expr>)\n+                  -> Gc<ast::Expr> {\n         let ty = match argno {\n             Exact(ref i) => self.arg_types.get(*i).get_ref(),\n             Named(ref s) => self.name_types.get(s)\n@@ -854,9 +856,12 @@ pub fn expand_format_args_method(ecx: &mut ExtCtxt, sp: Span,\n /// expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     invocation: Invocation,\n-                                    efmt: @ast::Expr, args: Vec<@ast::Expr>,\n+                                    efmt: Gc<ast::Expr>,\n+                                    args: Vec<Gc<ast::Expr>>,\n                                     name_ordering: Vec<String>,\n-                                    names: HashMap<String, @ast::Expr>) -> @ast::Expr {\n+                                    names: HashMap<String, Gc<ast::Expr>>)\n+    -> Gc<ast::Expr>\n+{\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n         ecx: ecx,"}, {"sha": "185924f704cdde120bff5f723fcd79120def3821", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -17,6 +17,7 @@ use parse::token::*;\n use parse::token;\n use parse;\n \n+use std::gc::Gc;\n \n /**\n *\n@@ -50,6 +51,8 @@ pub mod rt {\n     pub use parse::new_parser_from_tts;\n     pub use codemap::{BytePos, Span, dummy_spanned};\n \n+    use std::gc::Gc;\n+\n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> ;\n     }\n@@ -85,13 +88,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::Item {\n+    impl ToSource for Gc<ast::Item> {\n         fn to_source(&self) -> String {\n-            pprust::item_to_str(*self)\n+            pprust::item_to_str(&**self)\n         }\n     }\n \n-    impl<'a> ToSource for &'a [@ast::Item] {\n+    impl<'a> ToSource for &'a [Gc<ast::Item>] {\n         fn to_source(&self) -> String {\n             self.iter()\n                 .map(|i| i.to_source())\n@@ -123,9 +126,9 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::Expr {\n+    impl ToSource for Gc<ast::Expr> {\n         fn to_source(&self) -> String {\n-            pprust::expr_to_str(*self)\n+            pprust::expr_to_str(&**self)\n         }\n     }\n \n@@ -263,12 +266,12 @@ pub mod rt {\n     )\n \n     impl_to_tokens!(ast::Ident)\n-    impl_to_tokens!(@ast::Item)\n-    impl_to_tokens_self!(&'a [@ast::Item])\n+    impl_to_tokens!(Gc<ast::Item>)\n+    impl_to_tokens_self!(&'a [Gc<ast::Item>])\n     impl_to_tokens!(ast::Ty)\n     impl_to_tokens_self!(&'a [ast::Ty])\n     impl_to_tokens!(Generics)\n-    impl_to_tokens!(@ast::Expr)\n+    impl_to_tokens!(Gc<ast::Expr>)\n     impl_to_tokens!(ast::Block)\n     impl_to_tokens!(ast::Arg)\n     impl_to_tokens_self!(&'a str)\n@@ -287,15 +290,15 @@ pub mod rt {\n     impl_to_tokens!(u64)\n \n     pub trait ExtParseUtils {\n-        fn parse_item(&self, s: String) -> @ast::Item;\n-        fn parse_expr(&self, s: String) -> @ast::Expr;\n-        fn parse_stmt(&self, s: String) -> @ast::Stmt;\n+        fn parse_item(&self, s: String) -> Gc<ast::Item>;\n+        fn parse_expr(&self, s: String) -> Gc<ast::Expr>;\n+        fn parse_stmt(&self, s: String) -> Gc<ast::Stmt>;\n         fn parse_tts(&self, s: String) -> Vec<ast::TokenTree> ;\n     }\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n-        fn parse_item(&self, s: String) -> @ast::Item {\n+        fn parse_item(&self, s: String) -> Gc<ast::Item> {\n             let res = parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n@@ -310,15 +313,15 @@ pub mod rt {\n             }\n         }\n \n-        fn parse_stmt(&self, s: String) -> @ast::Stmt {\n+        fn parse_stmt(&self, s: String) -> Gc<ast::Stmt> {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n                                               Vec::new(),\n                                               self.parse_sess())\n         }\n \n-        fn parse_expr(&self, s: String) -> @ast::Expr {\n+        fn parse_expr(&self, s: String) -> Gc<ast::Expr> {\n             parse::parse_expr_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n@@ -400,25 +403,25 @@ fn id_ext(str: &str) -> ast::Ident {\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n+fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> Gc<ast::Expr> {\n     let e_str = cx.expr_str(sp, token::get_ident(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n                         vec!(e_str))\n }\n \n-fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> @ast::Expr {\n+fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> @ast::Expr {\n+fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> Gc<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"token\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> @ast::Expr {\n+fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> Gc<ast::Expr> {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -434,7 +437,7 @@ fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> @ast::Expr {\n     mk_token_path(cx, sp, name)\n }\n \n-fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n+fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n \n     match *tok {\n         BINOP(binop) => {\n@@ -565,7 +568,8 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n     mk_token_path(cx, sp, name)\n }\n \n-fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<@ast::Stmt> {\n+\n+fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<Gc<ast::Stmt>> {\n     match *tt {\n         ast::TTTok(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n@@ -605,7 +609,7 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<@ast::Stmt> {\n }\n \n fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> Vec<@ast::Stmt> {\n+    -> Vec<Gc<ast::Stmt>> {\n     let mut ss = Vec::new();\n     for tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n@@ -614,7 +618,7 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-              -> (@ast::Expr, @ast::Expr) {\n+              -> (Gc<ast::Expr>, Gc<ast::Expr>) {\n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a TTNonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n@@ -686,8 +690,8 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n-                  cx_expr: @ast::Expr,\n-                  expr: @ast::Expr) -> @ast::Expr {\n+                  cx_expr: Gc<ast::Expr>,\n+                  expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n     let uses = [\n         &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n     ].iter().map(|path| {\n@@ -703,8 +707,8 @@ fn expand_wrapper(cx: &ExtCtxt,\n fn expand_parse_call(cx: &ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n-                     arg_exprs: Vec<@ast::Expr> ,\n-                     tts: &[ast::TokenTree]) -> @ast::Expr {\n+                     arg_exprs: Vec<Gc<ast::Expr>>,\n+                     tts: &[ast::TokenTree]) -> Gc<ast::Expr> {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call("}, {"sha": "915fc16c15660a05368690c7e770dc05a0bcb81c", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -19,6 +19,7 @@ use parse;\n use parse::token;\n use print::pprust;\n \n+use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -163,7 +164,7 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n }\n \n // recur along an ExpnInfo chain to find the original expression\n-fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n+fn topmost_expn_info(expn_info: Gc<codemap::ExpnInfo>) -> Gc<codemap::ExpnInfo> {\n     match *expn_info {\n         ExpnInfo { call_site: ref call_site, .. } => {\n             match call_site.expn_info {"}, {"sha": "85035a8d38e43a58b31c5c9ae2a838f10c2e464a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -452,7 +452,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       \"tt\" => {\n         p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n-        let res = token::NtTT(@p.parse_token_tree());\n+        let res = token::NtTT(box(GC) p.parse_token_tree());\n         p.quote_depth -= 1u;\n         res\n       }"}, {"sha": "6607b6451c02a45fa8302e8acd99d2521a582f92", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -29,6 +29,7 @@ use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::gc::Gc;\n \n struct ParserAnyMacro<'a> {\n     parser: RefCell<Parser<'a>>,\n@@ -58,17 +59,17 @@ impl<'a> ParserAnyMacro<'a> {\n }\n \n impl<'a> MacResult for ParserAnyMacro<'a> {\n-    fn make_expr(&self) -> Option<@ast::Expr> {\n+    fn make_expr(&self) -> Option<Gc<ast::Expr>> {\n         let ret = self.parser.borrow_mut().parse_expr();\n         self.ensure_complete_parse(true);\n         Some(ret)\n     }\n-    fn make_pat(&self) -> Option<@ast::Pat> {\n+    fn make_pat(&self) -> Option<Gc<ast::Pat>> {\n         let ret = self.parser.borrow_mut().parse_pat();\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n-    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+    fn make_items(&self) -> Option<SmallVector<Gc<ast::Item>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -81,7 +82,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n-    fn make_stmt(&self) -> Option<@ast::Stmt> {\n+    fn make_stmt(&self) -> Option<Gc<ast::Stmt>> {\n         let attrs = self.parser.borrow_mut().parse_outer_attributes();\n         let ret = self.parser.borrow_mut().parse_stmt(attrs);\n         self.ensure_complete_parse(true);"}, {"sha": "d8c7ffe4db7ac185f22d0973e5758c5785224178", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 62, "deletions": 54, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -17,18 +17,19 @@ use owned_slice::OwnedSlice;\n use util::small_vector::SmallVector;\n \n use std::rc::Rc;\n+use std::gc::Gc;\n \n // We may eventually want to be able to fold over type parameters, too.\n pub trait Folder {\n     fn fold_crate(&mut self, c: Crate) -> Crate {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: &[@MetaItem]) -> Vec<@MetaItem> {\n+    fn fold_meta_items(&mut self, meta_items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n         meta_items.iter().map(|x| fold_meta_item_(*x, self)).collect()\n     }\n \n-    fn fold_view_path(&mut self, view_path: @ViewPath) -> @ViewPath {\n+    fn fold_view_path(&mut self, view_path: Gc<ViewPath>) -> Gc<ViewPath> {\n         let inner_view_path = match view_path.node {\n             ViewPathSimple(ref ident, ref path, node_id) => {\n                 let id = self.new_id(node_id);\n@@ -60,7 +61,7 @@ pub trait Folder {\n                              id)\n             }\n         };\n-        @Spanned {\n+        box(GC) Spanned {\n             node: inner_view_path,\n             span: self.new_span(view_path.span),\n         }\n@@ -70,12 +71,12 @@ pub trait Folder {\n         noop_fold_view_item(vi, self)\n     }\n \n-    fn fold_foreign_item(&mut self, ni: @ForeignItem) -> @ForeignItem {\n-        noop_fold_foreign_item(ni, self)\n+    fn fold_foreign_item(&mut self, ni: Gc<ForeignItem>) -> Gc<ForeignItem> {\n+        noop_fold_foreign_item(&*ni, self)\n     }\n \n-    fn fold_item(&mut self, i: @Item) -> SmallVector<@Item> {\n-        noop_fold_item(i, self)\n+    fn fold_item(&mut self, i: Gc<Item>) -> SmallVector<Gc<Item>> {\n+        noop_fold_item(&*i, self)\n     }\n \n     fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n@@ -103,15 +104,15 @@ pub trait Folder {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&mut self, m: @Method) -> @Method {\n-        noop_fold_method(m, self)\n+    fn fold_method(&mut self, m: Gc<Method>) -> Gc<Method>  {\n+        noop_fold_method(&*m, self)\n     }\n \n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&mut self, s: &Stmt) -> SmallVector<@Stmt> {\n+    fn fold_stmt(&mut self, s: &Stmt) -> SmallVector<Gc<Stmt>> {\n         noop_fold_stmt(s, self)\n     }\n \n@@ -124,11 +125,11 @@ pub trait Folder {\n         }\n     }\n \n-    fn fold_pat(&mut self, p: @Pat) -> @Pat {\n+    fn fold_pat(&mut self, p: Gc<Pat>) -> Gc<Pat> {\n         noop_fold_pat(p, self)\n     }\n \n-    fn fold_decl(&mut self, d: @Decl) -> SmallVector<@Decl> {\n+    fn fold_decl(&mut self, d: Gc<Decl>) -> SmallVector<Gc<Decl>> {\n         let node = match d.node {\n             DeclLocal(ref l) => SmallVector::one(DeclLocal(self.fold_local(*l))),\n             DeclItem(it) => {\n@@ -137,14 +138,14 @@ pub trait Folder {\n         };\n \n         node.move_iter().map(|node| {\n-            @Spanned {\n+            box(GC) Spanned {\n                 node: node,\n                 span: self.new_span(d.span),\n             }\n         }).collect()\n     }\n \n-    fn fold_expr(&mut self, e: @Expr) -> @Expr {\n+    fn fold_expr(&mut self, e: Gc<Expr>) -> Gc<Expr> {\n         noop_fold_expr(e, self)\n     }\n \n@@ -160,34 +161,34 @@ pub trait Folder {\n                 TyRptr(fold_opt_lifetime(region, self), fold_mt(mt, self))\n             }\n             TyClosure(ref f, ref region) => {\n-                TyClosure(@ClosureTy {\n+                TyClosure(box(GC) ClosureTy {\n                     fn_style: f.fn_style,\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n-                    decl: self.fold_fn_decl(f.decl),\n+                    decl: self.fold_fn_decl(&*f.decl),\n                     lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 }, fold_opt_lifetime(region, self))\n             }\n             TyProc(ref f) => {\n-                TyProc(@ClosureTy {\n+                TyProc(box(GC) ClosureTy {\n                     fn_style: f.fn_style,\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n-                    decl: self.fold_fn_decl(f.decl),\n+                    decl: self.fold_fn_decl(&*f.decl),\n                     lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 })\n             }\n             TyBareFn(ref f) => {\n-                TyBareFn(@BareFnTy {\n+                TyBareFn(box(GC) BareFnTy {\n                     lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                     fn_style: f.fn_style,\n                     abi: f.abi,\n-                    decl: self.fold_fn_decl(f.decl)\n+                    decl: self.fold_fn_decl(&*f.decl)\n                 })\n             }\n             TyUnboxedFn(ref f) => {\n-                TyUnboxedFn(@UnboxedFnTy {\n-                    decl: self.fold_fn_decl(f.decl),\n+                TyUnboxedFn(box(GC) UnboxedFnTy {\n+                    decl: self.fold_fn_decl(&*f.decl),\n                 })\n             }\n             TyTup(ref tys) => TyTup(tys.iter().map(|&ty| self.fold_ty(ty)).collect()),\n@@ -236,7 +237,7 @@ pub trait Folder {\n                     fold_variant_arg_(x, self)).collect())\n             }\n             StructVariantKind(ref struct_def) => {\n-                kind = StructVariantKind(@ast::StructDef {\n+                kind = StructVariantKind(box(GC) ast::StructDef {\n                     fields: struct_def.fields.iter()\n                         .map(|f| self.fold_struct_field(f)).collect(),\n                     ctor_id: struct_def.ctor_id.map(|c| self.new_id(c)),\n@@ -285,9 +286,9 @@ pub trait Folder {\n         }\n     }\n \n-    fn fold_local(&mut self, l: @Local) -> @Local {\n+    fn fold_local(&mut self, l: Gc<Local>) -> Gc<Local> {\n         let id = self.new_id(l.id); // Needs to be first, for ast_map.\n-        @Local {\n+        box(GC) Local {\n             id: id,\n             ty: self.fold_ty(l.ty),\n             pat: self.fold_pat(l.pat),\n@@ -310,7 +311,8 @@ pub trait Folder {\n         }\n     }\n \n-    fn map_exprs(&self, f: |@Expr| -> @Expr, es: &[@Expr]) -> Vec<@Expr> {\n+    fn map_exprs(&self, f: |Gc<Expr>| -> Gc<Expr>,\n+                 es: &[Gc<Expr>]) -> Vec<Gc<Expr>> {\n         es.iter().map(|x| f(*x)).collect()\n     }\n \n@@ -346,8 +348,8 @@ pub trait Folder {\n /* some little folds that probably aren't useful to have in Folder itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_<T: Folder>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n-    @Spanned {\n+fn fold_meta_item_<T: Folder>(mi: Gc<MetaItem>, fld: &mut T) -> Gc<MetaItem> {\n+    box(GC) Spanned {\n         node:\n             match mi.node {\n                 MetaWord(ref id) => MetaWord((*id).clone()),\n@@ -447,7 +449,7 @@ fn fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n         StaticRegionTyParamBound => StaticRegionTyParamBound,\n         UnboxedFnTyParamBound(ref unboxed_function_type) => {\n             UnboxedFnTyParamBound(UnboxedFnTy {\n-                decl: fld.fold_fn_decl(unboxed_function_type.decl),\n+                decl: fld.fold_fn_decl(&*unboxed_function_type.decl),\n             })\n         }\n         OtherRegionTyParamBound(s) => OtherRegionTyParamBound(s)\n@@ -495,8 +497,9 @@ pub fn fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n-fn fold_struct_def<T: Folder>(struct_def: @StructDef, fld: &mut T) -> @StructDef {\n-    @ast::StructDef {\n+fn fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,\n+                              fld: &mut T) -> Gc<StructDef> {\n+    box(GC) ast::StructDef {\n         fields: struct_def.fields.iter().map(|f| fold_struct_field(f, fld)).collect(),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n         super_struct: match struct_def.super_struct {\n@@ -583,7 +586,7 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     let id = folder.new_id(b.id); // Needs to be first, for ast_map.\n     let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();\n-    let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n+    let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(&**s).move_iter()).collect();\n     P(Block {\n         id: id,\n         view_items: view_items,\n@@ -601,7 +604,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n         }\n         ItemFn(decl, fn_style, abi, ref generics, body) => {\n             ItemFn(\n-                folder.fold_fn_decl(decl),\n+                folder.fold_fn_decl(&*decl),\n                 fn_style,\n                 abi,\n                 fold_generics(generics, folder),\n@@ -617,7 +620,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n             ItemEnum(\n                 ast::EnumDef {\n                     variants: enum_definition.variants.iter().map(|&x| {\n-                        folder.fold_variant(x)\n+                        folder.fold_variant(&*x)\n                     }).collect(),\n                 },\n                 fold_generics(generics, folder))\n@@ -656,7 +659,7 @@ pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMeth\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n         fn_style: m.fn_style,\n-        decl: fld.fold_fn_decl(m.decl),\n+        decl: fld.fold_fn_decl(&*m.decl),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: fld.fold_explicit_self(&m.explicit_self),\n         span: fld.new_span(m.span),\n@@ -683,18 +686,19 @@ pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n     }\n }\n \n-pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item> {\n+pub fn noop_fold_item<T: Folder>(i: &Item,\n+                                 folder: &mut T) -> SmallVector<Gc<Item>> {\n     let id = folder.new_id(i.id); // Needs to be first, for ast_map.\n     let node = folder.fold_item_underscore(&i.node);\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n         ItemImpl(_, ref maybe_trait, ty, _) => {\n-            ast_util::impl_pretty_name(maybe_trait, ty)\n+            ast_util::impl_pretty_name(maybe_trait, &*ty)\n         }\n         _ => i.ident\n     };\n \n-    SmallVector::one(@Item {\n+    SmallVector::one(box(GC) Item {\n         id: id,\n         ident: folder.fold_ident(ident),\n         attrs: i.attrs.iter().map(|e| fold_attribute_(*e, folder)).collect(),\n@@ -704,9 +708,10 @@ pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item>\n     })\n }\n \n-pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @ForeignItem {\n+pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n+                                         folder: &mut T) -> Gc<ForeignItem> {\n     let id = folder.new_id(ni.id); // Needs to be first, for ast_map.\n-    @ForeignItem {\n+    box(GC) ForeignItem {\n         id: id,\n         ident: folder.fold_ident(ni.ident),\n         attrs: ni.attrs.iter().map(|x| fold_attribute_(*x, folder)).collect(),\n@@ -728,23 +733,23 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @F\n     }\n }\n \n-pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n+pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> Gc<Method> {\n     let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n-    @Method {\n+    box(GC) Method {\n         id: id,\n         ident: folder.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n         generics: fold_generics(&m.generics, folder),\n         explicit_self: folder.fold_explicit_self(&m.explicit_self),\n         fn_style: m.fn_style,\n-        decl: folder.fold_fn_decl(m.decl),\n+        decl: folder.fold_fn_decl(&*m.decl),\n         body: folder.fold_block(m.body),\n         span: folder.new_span(m.span),\n         vis: m.vis\n     }\n }\n \n-pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n+pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n     let id = folder.new_id(p.id);\n     let node = match p.node {\n         PatWild => PatWild,\n@@ -783,14 +788,14 @@ pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n         PatMac(ref mac) => PatMac(folder.fold_mac(mac)),\n     };\n \n-    @Pat {\n+    box(GC) Pat {\n         id: id,\n         span: folder.new_span(p.span),\n         node: node,\n     }\n }\n \n-pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n+pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n     let id = folder.new_id(e.id);\n     let node = match e.node {\n         ExprVstore(e, v) => {\n@@ -851,13 +856,15 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n             ExprMatch(folder.fold_expr(expr),\n                       arms.iter().map(|x| folder.fold_arm(x)).collect())\n         }\n-        ExprFnBlock(decl, body) => {\n-            ExprFnBlock(folder.fold_fn_decl(decl), folder.fold_block(body))\n+        ExprFnBlock(ref decl, ref body) => {\n+            ExprFnBlock(folder.fold_fn_decl(&**decl),\n+                        folder.fold_block(body.clone()))\n         }\n-        ExprProc(decl, body) => {\n-            ExprProc(folder.fold_fn_decl(decl), folder.fold_block(body))\n+        ExprProc(ref decl, ref body) => {\n+            ExprProc(folder.fold_fn_decl(&**decl),\n+                     folder.fold_block(body.clone()))\n         }\n-        ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n+        ExprBlock(ref blk) => ExprBlock(folder.fold_block(blk.clone())),\n         ExprAssign(el, er) => {\n             ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n         }\n@@ -900,14 +907,15 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n     };\n \n-    @Expr {\n+    box(GC) Expr {\n         id: id,\n         node: node,\n         span: folder.new_span(e.span),\n     }\n }\n \n-pub fn noop_fold_stmt<T: Folder>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n+pub fn noop_fold_stmt<T: Folder>(s: &Stmt,\n+                                 folder: &mut T) -> SmallVector<Gc<Stmt>> {\n     let nodes = match s.node {\n         StmtDecl(d, id) => {\n             let id = folder.new_id(id);\n@@ -926,7 +934,7 @@ pub fn noop_fold_stmt<T: Folder>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt>\n         StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))\n     };\n \n-    nodes.move_iter().map(|node| @Spanned {\n+    nodes.move_iter().map(|node| box(GC) Spanned {\n         node: node,\n         span: folder.new_span(s.span),\n     }).collect()"}, {"sha": "64766b5013cbb74c0fc386a9c59b6cab5a65341e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -16,15 +16,17 @@ use parse::token;\n use parse::parser::Parser;\n use parse::token::INTERPOLATED;\n \n+use std::gc::Gc;\n+\n // a parser that can parse attributes.\n pub trait ParserAttr {\n-    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> ;\n+    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute>;\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&mut self)\n-                                  -> (Vec<ast::Attribute> , Vec<ast::Attribute> );\n-    fn parse_meta_item(&mut self) -> @ast::MetaItem;\n-    fn parse_meta_seq(&mut self) -> Vec<@ast::MetaItem> ;\n-    fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> ;\n+                                  -> (Vec<ast::Attribute>, Vec<ast::Attribute>);\n+    fn parse_meta_item(&mut self) -> Gc<ast::MetaItem>;\n+    fn parse_meta_seq(&mut self) -> Vec<Gc<ast::MetaItem>>;\n+    fn parse_optional_meta(&mut self) -> Vec<Gc<ast::MetaItem>>;\n }\n \n impl<'a> ParserAttr for Parser<'a> {\n@@ -157,7 +159,7 @@ impl<'a> ParserAttr for Parser<'a> {\n     // matches meta_item = IDENT\n     // | IDENT = lit\n     // | IDENT meta_seq\n-    fn parse_meta_item(&mut self) -> @ast::MetaItem {\n+    fn parse_meta_item(&mut self) -> Gc<ast::MetaItem> {\n         match self.token {\n             token::INTERPOLATED(token::NtMeta(e)) => {\n                 self.bump();\n@@ -184,29 +186,29 @@ impl<'a> ParserAttr for Parser<'a> {\n                     }\n                 }\n                 let hi = self.span.hi;\n-                @spanned(lo, hi, ast::MetaNameValue(name, lit))\n+                box(GC) spanned(lo, hi, ast::MetaNameValue(name, lit))\n             }\n             token::LPAREN => {\n                 let inner_items = self.parse_meta_seq();\n                 let hi = self.span.hi;\n-                @spanned(lo, hi, ast::MetaList(name, inner_items))\n+                box(GC) spanned(lo, hi, ast::MetaList(name, inner_items))\n             }\n             _ => {\n                 let hi = self.last_span.hi;\n-                @spanned(lo, hi, ast::MetaWord(name))\n+                box(GC) spanned(lo, hi, ast::MetaWord(name))\n             }\n         }\n     }\n \n     // matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> Vec<@ast::MetaItem> {\n+    fn parse_meta_seq(&mut self) -> Vec<Gc<ast::MetaItem>> {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> {\n+    fn parse_optional_meta(&mut self) -> Vec<Gc<ast::MetaItem>> {\n         match self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => Vec::new()"}, {"sha": "8d9cc305c26e815d8c65393e5af4fa96623707f8", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -13,6 +13,7 @@\n // Predicates on exprs and stmts that the pretty-printer and parser use\n \n use ast;\n+use std::gc::Gc;\n \n // does this expression require a semicolon to be treated\n // as a statement? The negation of this: 'can this expression\n@@ -21,7 +22,7 @@ use ast;\n // 'if true {...} else {...}\n //  |x| 5 '\n // isn't parsed as (if true {...} else {...} | x) | 5\n-pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n+pub fn expr_requires_semi_to_be_stmt(e: Gc<ast::Expr>) -> bool {\n     match e.node {\n         ast::ExprIf(..)\n         | ast::ExprMatch(..)\n@@ -33,7 +34,7 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n     }\n }\n \n-pub fn expr_is_simple_block(e: @ast::Expr) -> bool {\n+pub fn expr_is_simple_block(e: Gc<ast::Expr>) -> bool {\n     match e.node {\n         ast::ExprBlock(block) => block.rules == ast::DefaultBlock,\n       _ => false"}, {"sha": "88746d145b6fcffceb919b189024c099138aa535", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -18,6 +18,7 @@ use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n use std::cell::RefCell;\n+use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -105,7 +106,7 @@ pub fn parse_expr_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> @ast::Expr {\n+                                  -> Gc<ast::Expr> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n }\n@@ -114,7 +115,7 @@ pub fn parse_item_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> Option<@ast::Item> {\n+                                  -> Option<Gc<ast::Item>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     let attrs = p.parse_outer_attributes();\n     maybe_aborted(p.parse_item(attrs),p)\n@@ -124,7 +125,7 @@ pub fn parse_meta_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n                                   sess: &ParseSess)\n-                                  -> @ast::MetaItem {\n+                                  -> Gc<ast::MetaItem> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n }\n@@ -134,7 +135,7 @@ pub fn parse_stmt_from_source_str(name: String,\n                                   cfg: ast::CrateConfig,\n                                   attrs: Vec<ast::Attribute> ,\n                                   sess: &ParseSess)\n-                                  -> @ast::Stmt {\n+                                  -> Gc<ast::Stmt> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -306,7 +307,7 @@ mod test {\n \n     #[test] fn path_exprs_1() {\n         assert!(string_to_expr(\"a\".to_string()) ==\n-                   @ast::Expr{\n+                   box(GC) ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                         span: sp(0, 1),\n@@ -325,7 +326,7 @@ mod test {\n \n     #[test] fn path_exprs_2 () {\n         assert!(string_to_expr(\"::a::b\".to_string()) ==\n-                   @ast::Expr {\n+                   box(GC) ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                             span: sp(0, 6),\n@@ -537,9 +538,9 @@ mod test {\n \n     #[test] fn ret_expr() {\n         assert!(string_to_expr(\"return d\".to_string()) ==\n-                   @ast::Expr{\n+                   box(GC) ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node:ast::ExprRet(Some(@ast::Expr{\n+                    node:ast::ExprRet(Some(box(GC) ast::Expr{\n                         id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprPath(ast::Path{\n                             span: sp(7, 8),\n@@ -560,8 +561,8 @@ mod test {\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   @Spanned{\n-                       node: ast::StmtExpr(@ast::Expr {\n+                   box(GC) Spanned{\n+                       node: ast::StmtExpr(box(GC) ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprPath(ast::Path {\n                                span:sp(0,1),\n@@ -588,7 +589,7 @@ mod test {\n         let sess = new_parse_sess();\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n         assert!(parser.parse_pat() ==\n-                   @ast::Pat{id: ast::DUMMY_NODE_ID,\n+                   box(GC) ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n                                 ast::BindByValue(ast::MutImmutable),\n                                 ast::Path {\n@@ -612,7 +613,7 @@ mod test {\n         // this test depends on the intern order of \"fn\" and \"int\"\n         assert!(string_to_item(\"fn a (b : int) { b; }\".to_string()) ==\n                   Some(\n-                      @ast::Item{ident:str_to_ident(\"a\"),\n+                      box(GC) ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemFn(ast::P(ast::FnDecl {\n@@ -632,7 +633,7 @@ mod test {\n                                         }, None, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     }),\n-                                    pat: @ast::Pat {\n+                                    pat: box(GC) ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n                                             ast::BindByValue(ast::MutImmutable),\n@@ -668,8 +669,8 @@ mod test {\n                                     },\n                                     ast::P(ast::Block {\n                                         view_items: Vec::new(),\n-                                        stmts: vec!(@Spanned{\n-                                            node: ast::StmtSemi(@ast::Expr{\n+                                        stmts: vec!(box(GC) Spanned{\n+                                            node: ast::StmtSemi(box(GC) ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprPath(\n                                                       ast::Path{\n@@ -703,12 +704,12 @@ mod test {\n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n         string_to_expr(\"3 + 4\".to_string());\n-        string_to_expr(\"a::z.froob(b,@(987+3))\".to_string());\n+        string_to_expr(\"a::z.froob(b,box(GC)(987+3))\".to_string());\n     }\n \n     #[test] fn attrs_fix_bug () {\n         string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-                   -> Result<@Writer, String> {\n+                   -> Result<Gc<Writer>, String> {\n     #[cfg(windows)]\n     fn wb() -> c_int {\n       (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int"}, {"sha": "9706176ca8babbe9e26a4d7b567a187a5c5737a7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -22,6 +22,8 @@ use codemap::{Span, respan};\n use parse::parser;\n use parse::token;\n \n+use std::gc::Gc;\n+\n /// The specific types of unsupported syntax\n #[deriving(PartialEq, Eq, Hash)]\n pub enum ObsoleteSyntax {\n@@ -35,7 +37,7 @@ pub trait ParserObsoleteMethods {\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax);\n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr;\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> Gc<Expr>;\n     fn report(&mut self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n@@ -68,9 +70,9 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n \n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr {\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> Gc<Expr> {\n         self.obsolete(sp, kind);\n-        self.mk_expr(sp.lo, sp.hi, ExprLit(@respan(sp, LitNil)))\n+        self.mk_expr(sp.lo, sp.hi, ExprLit(box(GC) respan(sp, LitNil)))\n     }\n \n     fn report(&mut self,"}, {"sha": "8083bf41706d65acea1c25272057b941b2dbdcd5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 125, "deletions": 118, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -79,7 +79,7 @@ use owned_slice::OwnedSlice;\n use std::collections::HashSet;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::string::String;\n+use std::gc::Gc;\n \n #[allow(non_camel_case_types)]\n #[deriving(PartialEq)]\n@@ -119,9 +119,9 @@ pub struct PathAndBounds {\n enum ItemOrViewItem {\n     // Indicates a failure to parse any kind of item. The attributes are\n     // returned.\n-    IoviNone(Vec<Attribute> ),\n-    IoviItem(@Item),\n-    IoviForeignItem(@ForeignItem),\n+    IoviNone(Vec<Attribute>),\n+    IoviItem(Gc<Item>),\n+    IoviForeignItem(Gc<ForeignItem>),\n     IoviViewItem(ViewItem)\n }\n \n@@ -275,10 +275,10 @@ fn maybe_append(lhs: Vec<Attribute> , rhs: Option<Vec<Attribute> >)\n \n \n struct ParsedItemsAndViewItems {\n-    attrs_remaining: Vec<Attribute> ,\n-    view_items: Vec<ViewItem> ,\n-    items: Vec<@Item> ,\n-    foreign_items: Vec<@ForeignItem>\n+    attrs_remaining: Vec<Attribute>,\n+    view_items: Vec<ViewItem>,\n+    items: Vec<Gc<Item>>,\n+    foreign_items: Vec<Gc<ForeignItem>>\n }\n \n /* ident is handled by common.rs */\n@@ -454,7 +454,8 @@ impl<'a> Parser<'a> {\n     // Commit to parsing a complete expression `e` expected to be\n     // followed by some token from the set edible + inedible.  Recover\n     // from anticipated input errors, discarding erroneous characters.\n-    pub fn commit_expr(&mut self, e: @Expr, edible: &[token::Token], inedible: &[token::Token]) {\n+    pub fn commit_expr(&mut self, e: Gc<Expr>, edible: &[token::Token],\n+                       inedible: &[token::Token]) {\n         debug!(\"commit_expr {:?}\", e);\n         match e.node {\n             ExprPath(..) => {\n@@ -469,14 +470,15 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_expr_expecting(&mut self, e: @Expr, edible: token::Token) {\n+    pub fn commit_expr_expecting(&mut self, e: Gc<Expr>, edible: token::Token) {\n         self.commit_expr(e, &[edible], &[])\n     }\n \n     // Commit to parsing a complete statement `s`, which expects to be\n     // followed by some token from the set edible + inedible.  Check\n     // for recoverable input errors, discarding erroneous characters.\n-    pub fn commit_stmt(&mut self, s: @Stmt, edible: &[token::Token], inedible: &[token::Token]) {\n+    pub fn commit_stmt(&mut self, s: Gc<Stmt>, edible: &[token::Token],\n+                       inedible: &[token::Token]) {\n         debug!(\"commit_stmt {:?}\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n         if self.last_token.as_ref().map_or(false, |t| is_ident_or_path(*t)) {\n@@ -488,7 +490,7 @@ impl<'a> Parser<'a> {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_stmt_expecting(&mut self, s: @Stmt, edible: token::Token) {\n+    pub fn commit_stmt_expecting(&mut self, s: Gc<Stmt>, edible: token::Token) {\n         self.commit_stmt(s, &[edible], &[])\n     }\n \n@@ -980,7 +982,7 @@ impl<'a> Parser<'a> {\n \n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n-        return TyBareFn(@BareFnTy {\n+        return TyBareFn(box(GC) BareFnTy {\n             abi: abi,\n             fn_style: fn_style,\n             lifetimes: lifetimes,\n@@ -1021,7 +1023,7 @@ impl<'a> Parser<'a> {\n             cf: ret_style,\n             variadic: variadic\n         });\n-        TyProc(@ClosureTy {\n+        TyProc(box(GC) ClosureTy {\n             fn_style: NormalFn,\n             onceness: Once,\n             bounds: bounds,\n@@ -1092,11 +1094,11 @@ impl<'a> Parser<'a> {\n         });\n \n         if is_unboxed {\n-            TyUnboxedFn(@UnboxedFnTy {\n+            TyUnboxedFn(box(GC) UnboxedFnTy {\n                 decl: decl,\n             })\n         } else {\n-            TyClosure(@ClosureTy {\n+            TyClosure(box(GC) ClosureTy {\n                 fn_style: fn_style,\n                 onceness: onceness,\n                 bounds: bounds,\n@@ -1192,7 +1194,7 @@ impl<'a> Parser<'a> {\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n                 let attrs = attrs.append(inner_attrs.as_slice());\n-                Provided(@ast::Method {\n+                Provided(box(GC) ast::Method {\n                     ident: ident,\n                     attrs: attrs,\n                     generics: generics,\n@@ -1465,7 +1467,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn maybe_parse_fixed_vstore(&mut self) -> Option<@ast::Expr> {\n+    pub fn maybe_parse_fixed_vstore(&mut self) -> Option<Gc<ast::Expr>> {\n         if self.token == token::COMMA &&\n                 self.look_ahead(1, |t| *t == token::DOTDOT) {\n             self.bump();\n@@ -1516,12 +1518,12 @@ impl<'a> Parser<'a> {\n     }\n \n     // matches '-' lit | lit\n-    pub fn parse_literal_maybe_minus(&mut self) -> @Expr {\n+    pub fn parse_literal_maybe_minus(&mut self) -> Gc<Expr> {\n         let minus_lo = self.span.lo;\n         let minus_present = self.eat(&token::BINOP(token::MINUS));\n \n         let lo = self.span.lo;\n-        let literal = @self.parse_lit();\n+        let literal = box(GC) self.parse_lit();\n         let hi = self.span.hi;\n         let expr = self.mk_expr(lo, hi, ExprLit(literal));\n \n@@ -1723,62 +1725,65 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> @Expr {\n-        @Expr {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> Gc<Expr> {\n+        box(GC) Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n         }\n     }\n \n-    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: @Expr) -> ast::Expr_ {\n+    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: Gc<Expr>) -> ast::Expr_ {\n         ExprUnary(unop, expr)\n     }\n \n-    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n+    pub fn mk_binary(&mut self, binop: ast::BinOp,\n+                     lhs: Gc<Expr>, rhs: Gc<Expr>) -> ast::Expr_ {\n         ExprBinary(binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&mut self, f: @Expr, args: Vec<@Expr> ) -> ast::Expr_ {\n+    pub fn mk_call(&mut self, f: Gc<Expr>, args: Vec<Gc<Expr>>) -> ast::Expr_ {\n         ExprCall(f, args)\n     }\n \n     fn mk_method_call(&mut self,\n                       ident: ast::SpannedIdent,\n                       tps: Vec<P<Ty>>,\n-                      args: Vec<@Expr>)\n+                      args: Vec<Gc<Expr>>)\n                       -> ast::Expr_ {\n         ExprMethodCall(ident, tps, args)\n     }\n \n-    pub fn mk_index(&mut self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n+    pub fn mk_index(&mut self, expr: Gc<Expr>, idx: Gc<Expr>) -> ast::Expr_ {\n         ExprIndex(expr, idx)\n     }\n \n-    pub fn mk_field(&mut self, expr: @Expr, ident: Ident, tys: Vec<P<Ty>> ) -> ast::Expr_ {\n+    pub fn mk_field(&mut self, expr: Gc<Expr>, ident: Ident,\n+                    tys: Vec<P<Ty>>) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n-    pub fn mk_assign_op(&mut self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n+    pub fn mk_assign_op(&mut self, binop: ast::BinOp,\n+                        lhs: Gc<Expr>, rhs: Gc<Expr>) -> ast::Expr_ {\n         ExprAssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> @Expr {\n-        @Expr {\n+    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> Gc<Expr> {\n+        box(GC) Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n     }\n \n-    pub fn mk_lit_u32(&mut self, i: u32) -> @Expr {\n+    pub fn mk_lit_u32(&mut self, i: u32) -> Gc<Expr> {\n         let span = &self.span;\n-        let lv_lit = @codemap::Spanned {\n+        let lv_lit = box(GC) codemap::Spanned {\n             node: LitUint(i as u64, TyU32),\n             span: *span\n         };\n \n-        @Expr {\n+        box(GC) Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprLit(lv_lit),\n             span: *span,\n@@ -1788,7 +1793,7 @@ impl<'a> Parser<'a> {\n     // at the bottom (top?) of the precedence hierarchy,\n     // parse things like parenthesized exprs,\n     // macros, return, etc.\n-    pub fn parse_bottom_expr(&mut self) -> @Expr {\n+    pub fn parse_bottom_expr(&mut self) -> Gc<Expr> {\n         maybe_whole_expr!(self);\n \n         let lo = self.span.lo;\n@@ -1804,7 +1809,7 @@ impl<'a> Parser<'a> {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @spanned(lo, hi, LitNil);\n+                let lit = box(GC) spanned(lo, hi, LitNil);\n                 return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n             let mut es = vec!(self.parse_expr());\n@@ -1991,27 +1996,27 @@ impl<'a> Parser<'a> {\n             // other literal expression\n             let lit = self.parse_lit();\n             hi = lit.span.hi;\n-            ex = ExprLit(@lit);\n+            ex = ExprLit(box(GC) lit);\n         }\n \n         return self.mk_expr(lo, hi, ex);\n     }\n \n     // parse a block or unsafe block\n     pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode)\n-                            -> @Expr {\n+                            -> Gc<Expr> {\n         self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n     }\n \n     // parse a.b or a(13) or a[4] or just a\n-    pub fn parse_dot_or_call_expr(&mut self) -> @Expr {\n+    pub fn parse_dot_or_call_expr(&mut self) -> Gc<Expr> {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n \n-    pub fn parse_dot_or_call_expr_with(&mut self, e0: @Expr) -> @Expr {\n+    pub fn parse_dot_or_call_expr_with(&mut self, e0: Gc<Expr>) -> Gc<Expr> {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -2282,7 +2287,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a prefix-operator expr\n-    pub fn parse_prefix_expr(&mut self) -> @Expr {\n+    pub fn parse_prefix_expr(&mut self) -> Gc<Expr> {\n         let lo = self.span.lo;\n         let hi;\n \n@@ -2384,13 +2389,14 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an expression of binops\n-    pub fn parse_binops(&mut self) -> @Expr {\n+    pub fn parse_binops(&mut self) -> Gc<Expr> {\n         let prefix_expr = self.parse_prefix_expr();\n         self.parse_more_binops(prefix_expr, 0)\n     }\n \n     // parse an expression of binops of at least min_prec precedence\n-    pub fn parse_more_binops(&mut self, lhs: @Expr, min_prec: uint) -> @Expr {\n+    pub fn parse_more_binops(&mut self, lhs: Gc<Expr>,\n+                             min_prec: uint) -> Gc<Expr> {\n         if self.expr_is_complete(lhs) { return lhs; }\n \n         // Prevent dynamic borrow errors later on by limiting the\n@@ -2439,7 +2445,7 @@ impl<'a> Parser<'a> {\n     // parse an assignment expression....\n     // actually, this seems to be the main entry point for\n     // parsing an arbitrary expression.\n-    pub fn parse_assign_expr(&mut self) -> @Expr {\n+    pub fn parse_assign_expr(&mut self) -> Gc<Expr> {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match self.token {\n@@ -2473,11 +2479,11 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an 'if' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self) -> @Expr {\n+    pub fn parse_if_expr(&mut self) -> Gc<Expr> {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let thn = self.parse_block();\n-        let mut els: Option<@Expr> = None;\n+        let mut els: Option<Gc<Expr>> = None;\n         let mut hi = thn.span.hi;\n         if self.eat_keyword(keywords::Else) {\n             let elexpr = self.parse_else_expr();\n@@ -2488,7 +2494,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // `|args| { ... }` or `{ ...}` like in `do` expressions\n-    pub fn parse_lambda_block_expr(&mut self) -> @Expr {\n+    pub fn parse_lambda_block_expr(&mut self) -> Gc<Expr> {\n         self.parse_lambda_expr_(\n             |p| {\n                 match p.token {\n@@ -2517,7 +2523,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // `|args| expr`\n-    pub fn parse_lambda_expr(&mut self) -> @Expr {\n+    pub fn parse_lambda_expr(&mut self) -> Gc<Expr> {\n         self.parse_lambda_expr_(|p| p.parse_fn_block_decl(),\n                                 |p| p.parse_expr())\n     }\n@@ -2527,8 +2533,8 @@ impl<'a> Parser<'a> {\n     // and in parsing a block expr as e.g. in for...\n     pub fn parse_lambda_expr_(&mut self,\n                               parse_decl: |&mut Parser| -> P<FnDecl>,\n-                              parse_body: |&mut Parser| -> @Expr)\n-                              -> @Expr {\n+                              parse_body: |&mut Parser| -> Gc<Expr>)\n+                              -> Gc<Expr> {\n         let lo = self.span.lo;\n         let decl = parse_decl(self);\n         let body = parse_body(self);\n@@ -2544,7 +2550,7 @@ impl<'a> Parser<'a> {\n         return self.mk_expr(lo, body.span.hi, ExprFnBlock(decl, fakeblock));\n     }\n \n-    pub fn parse_else_expr(&mut self) -> @Expr {\n+    pub fn parse_else_expr(&mut self) -> Gc<Expr> {\n         if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else {\n@@ -2554,7 +2560,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>) -> @Expr {\n+    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>) -> Gc<Expr> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let lo = self.last_span.lo;\n@@ -2567,15 +2573,15 @@ impl<'a> Parser<'a> {\n         self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident))\n     }\n \n-    pub fn parse_while_expr(&mut self) -> @Expr {\n+    pub fn parse_while_expr(&mut self) -> Gc<Expr> {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body));\n     }\n \n-    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> @Expr {\n+    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> Gc<Expr> {\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         let hi = body.span.hi;\n@@ -2590,7 +2596,7 @@ impl<'a> Parser<'a> {\n          || self.look_ahead(1, |t| *t == token::DOTDOT))\n     }\n \n-    fn parse_match_expr(&mut self) -> @Expr {\n+    fn parse_match_expr(&mut self) -> Gc<Expr> {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n         self.commit_expr_expecting(discriminant, token::LBRACE);\n@@ -2628,12 +2634,12 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an expression\n-    pub fn parse_expr(&mut self) -> @Expr {\n+    pub fn parse_expr(&mut self) -> Gc<Expr> {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     // parse an expression, subject to the given restriction\n-    fn parse_expr_res(&mut self, r: restriction) -> @Expr {\n+    fn parse_expr_res(&mut self, r: restriction) -> Gc<Expr> {\n         let old = self.restriction;\n         self.restriction = r;\n         let e = self.parse_assign_expr();\n@@ -2642,7 +2648,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse the RHS of a local variable declaration (e.g. '= 14;')\n-    fn parse_initializer(&mut self) -> Option<@Expr> {\n+    fn parse_initializer(&mut self) -> Option<Gc<Expr>> {\n         if self.token == token::EQ {\n             self.bump();\n             Some(self.parse_expr())\n@@ -2652,7 +2658,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse patterns, separated by '|' s\n-    fn parse_pats(&mut self) -> Vec<@Pat> {\n+    fn parse_pats(&mut self) -> Vec<Gc<Pat>> {\n         let mut pats = Vec::new();\n         loop {\n             pats.push(self.parse_pat());\n@@ -2663,7 +2669,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_pat_vec_elements(\n         &mut self,\n-    ) -> (Vec<@Pat> , Option<@Pat>, Vec<@Pat> ) {\n+    ) -> (Vec<Gc<Pat>> , Option<Gc<Pat>>, Vec<Gc<Pat>> ) {\n         let mut before = Vec::new();\n         let mut slice = None;\n         let mut after = Vec::new();\n@@ -2685,7 +2691,7 @@ impl<'a> Parser<'a> {\n \n             if is_slice {\n                 if self.token == token::COMMA || self.token == token::RBRACKET {\n-                    slice = Some(@ast::Pat {\n+                    slice = Some(box(GC) ast::Pat {\n                         id: ast::DUMMY_NODE_ID,\n                         node: PatWildMulti,\n                         span: self.span,\n@@ -2764,7 +2770,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 let fieldpath = ast_util::ident_to_path(self.last_span,\n                                                         fieldname);\n-                @ast::Pat {\n+                box(GC) ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatIdent(bind_type, fieldpath, None),\n                     span: self.last_span\n@@ -2776,7 +2782,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a pattern.\n-    pub fn parse_pat(&mut self) -> @Pat {\n+    pub fn parse_pat(&mut self) -> Gc<Pat> {\n         maybe_whole!(self, NtPat);\n \n         let lo = self.span.lo;\n@@ -2788,7 +2794,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             pat = PatWild;\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2801,7 +2807,7 @@ impl<'a> Parser<'a> {\n             pat = PatBox(sub);\n             hi = self.last_span.hi;\n             self.obsolete(self.last_span, ObsoleteOwnedPattern);\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2814,7 +2820,7 @@ impl<'a> Parser<'a> {\n             let sub = self.parse_pat();\n             pat = PatRegion(sub);\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2826,7 +2832,7 @@ impl<'a> Parser<'a> {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @codemap::Spanned {\n+                let lit = box(GC) codemap::Spanned {\n                     node: LitNil,\n                     span: mk_sp(lo, hi)};\n                 let expr = self.mk_expr(lo, hi, ExprLit(lit));\n@@ -2845,7 +2851,7 @@ impl<'a> Parser<'a> {\n                 pat = PatTup(fields);\n             }\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2860,7 +2866,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::RBRACKET);\n             pat = ast::PatVec(before, slice, after);\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2904,7 +2910,7 @@ impl<'a> Parser<'a> {\n             let sub = self.parse_pat();\n             pat = PatBox(sub);\n             hi = self.last_span.hi;\n-            return @ast::Pat {\n+            return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n@@ -2960,7 +2966,7 @@ impl<'a> Parser<'a> {\n                         pat = PatStruct(enum_path, fields, etc);\n                     }\n                     _ => {\n-                        let mut args: Vec<@Pat> = Vec::new();\n+                        let mut args: Vec<Gc<Pat>> = Vec::new();\n                         match self.token {\n                           token::LPAREN => {\n                             let is_dotdot = self.look_ahead(1, |t| {\n@@ -3003,7 +3009,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n         hi = self.last_span.hi;\n-        @ast::Pat {\n+        box(GC) ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: pat,\n             span: mk_sp(lo, hi),\n@@ -3044,7 +3050,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a local variable declaration\n-    fn parse_local(&mut self) -> @Local {\n+    fn parse_local(&mut self) -> Gc<Local> {\n         let lo = self.span.lo;\n         let pat = self.parse_pat();\n \n@@ -3055,7 +3061,7 @@ impl<'a> Parser<'a> {\n         });\n         if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n         let init = self.parse_initializer();\n-        @ast::Local {\n+        box(GC) ast::Local {\n             ty: ty,\n             pat: pat,\n             init: init,\n@@ -3066,10 +3072,10 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a \"let\" stmt\n-    fn parse_let(&mut self) -> @Decl {\n+    fn parse_let(&mut self) -> Gc<Decl> {\n         let lo = self.span.lo;\n         let local = self.parse_local();\n-        return @spanned(lo, self.last_span.hi, DeclLocal(local));\n+        box(GC) spanned(lo, self.last_span.hi, DeclLocal(local))\n     }\n \n     // parse a structure field\n@@ -3092,7 +3098,7 @@ impl<'a> Parser<'a> {\n \n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n-    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute> ) -> @Stmt {\n+    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute>) -> Gc<Stmt> {\n         maybe_whole!(self, NtStmt);\n \n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n@@ -3107,7 +3113,7 @@ impl<'a> Parser<'a> {\n             check_expected_item(self, !item_attrs.is_empty());\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n-            return @spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n+            return box(GC) spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n         } else if is_ident(&self.token)\n             && !token::is_any_keyword(&self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n@@ -3166,12 +3172,12 @@ impl<'a> Parser<'a> {\n             let hi = self.span.hi;\n \n             if id == token::special_idents::invalid {\n-                return @spanned(lo, hi, StmtMac(\n+                return box(GC) spanned(lo, hi, StmtMac(\n                     spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT)), false));\n             } else {\n                 // if it has a special ident, it's definitely an item\n-                return @spanned(lo, hi, StmtDecl(\n-                    @spanned(lo, hi, DeclItem(\n+                return box(GC) spanned(lo, hi, StmtDecl(\n+                    box(GC) spanned(lo, hi, DeclItem(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             ItemMac(spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT))),\n@@ -3184,8 +3190,8 @@ impl<'a> Parser<'a> {\n             match self.parse_item_or_view_item(item_attrs, false) {\n                 IoviItem(i) => {\n                     let hi = i.span.hi;\n-                    let decl = @spanned(lo, hi, DeclItem(i));\n-                    return @spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n+                    let decl = box(GC) spanned(lo, hi, DeclItem(i));\n+                    return box(GC) spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n                 }\n                 IoviViewItem(vi) => {\n                     self.span_fatal(vi.span,\n@@ -3201,12 +3207,12 @@ impl<'a> Parser<'a> {\n \n             // Remainder are line-expr stmts.\n             let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n-            return @spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID));\n+            return box(GC) spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID));\n         }\n     }\n \n     // is this expression a successfully-parsed statement?\n-    fn expr_is_complete(&mut self, e: @Expr) -> bool {\n+    fn expr_is_complete(&mut self, e: Gc<Expr>) -> bool {\n         return self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(e);\n     }\n@@ -3258,8 +3264,8 @@ impl<'a> Parser<'a> {\n                                             false, false);\n \n         for item in items.iter() {\n-            let decl = @spanned(item.span.lo, item.span.hi, DeclItem(*item));\n-            stmts.push(@spanned(item.span.lo, item.span.hi,\n+            let decl = box(GC) spanned(item.span.lo, item.span.hi, DeclItem(*item));\n+            stmts.push(box(GC) spanned(item.span.lo, item.span.hi,\n                                 StmtDecl(decl, ast::DUMMY_NODE_ID)));\n         }\n \n@@ -3286,7 +3292,7 @@ impl<'a> Parser<'a> {\n                     match stmt.node {\n                         StmtExpr(e, stmt_id) => {\n                             // expression without semicolon\n-                            if classify::stmt_ends_with_semi(stmt) {\n+                            if classify::stmt_ends_with_semi(&*stmt) {\n                                 // Just check for errors and recover; do not eat semicolon yet.\n                                 self.commit_stmt(stmt, &[], &[token::SEMI, token::RBRACE]);\n                             }\n@@ -3299,7 +3305,7 @@ impl<'a> Parser<'a> {\n                                         hi: self.last_span.hi,\n                                         expn_info: stmt.span.expn_info,\n                                     };\n-                                    stmts.push(@codemap::Spanned {\n+                                    stmts.push(box(GC) codemap::Spanned {\n                                         node: StmtSemi(e, stmt_id),\n                                         span: span_with_semi,\n                                     });\n@@ -3317,7 +3323,7 @@ impl<'a> Parser<'a> {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@codemap::Spanned {\n+                                    stmts.push(box(GC) codemap::Spanned {\n                                         node: StmtMac((*m).clone(), true),\n                                         span: stmt.span,\n                                     });\n@@ -3336,9 +3342,9 @@ impl<'a> Parser<'a> {\n                             }\n                         }\n                         _ => { // all other kinds of statements:\n-                            stmts.push(stmt);\n+                            stmts.push(stmt.clone());\n \n-                            if classify::stmt_ends_with_semi(stmt) {\n+                            if classify::stmt_ends_with_semi(&*stmt) {\n                                 self.commit_stmt_expecting(stmt, token::SEMI);\n                             }\n                         }\n@@ -3827,8 +3833,8 @@ impl<'a> Parser<'a> {\n \n     fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n                node: Item_, vis: Visibility,\n-               attrs: Vec<Attribute> ) -> @Item {\n-        @Item {\n+               attrs: Vec<Attribute>) -> Gc<Item> {\n+        box(GC) Item {\n             ident: ident,\n             attrs: attrs,\n             id: ast::DUMMY_NODE_ID,\n@@ -3847,7 +3853,8 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n-    fn parse_method(&mut self, already_parsed_attrs: Option<Vec<Attribute> >) -> @Method {\n+    fn parse_method(&mut self,\n+                    already_parsed_attrs: Option<Vec<Attribute>>) -> Gc<Method> {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n             Some(mut a) => { a.push_all_move(next_attrs); a }\n@@ -3867,7 +3874,7 @@ impl<'a> Parser<'a> {\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         let hi = body.span.hi;\n         let attrs = attrs.append(inner_attrs.as_slice());\n-        @ast::Method {\n+        box(GC) ast::Method {\n             ident: ident,\n             attrs: attrs,\n             generics: generics,\n@@ -3950,7 +3957,7 @@ impl<'a> Parser<'a> {\n             method_attrs = None;\n         }\n \n-        let ident = ast_util::impl_pretty_name(&opt_trait, ty);\n+        let ident = ast_util::impl_pretty_name(&opt_trait, &*ty);\n \n         (ident, ItemImpl(generics, opt_trait, ty, meths), Some(inner_attrs))\n     }\n@@ -4041,7 +4048,7 @@ impl<'a> Parser<'a> {\n         let _ = ast::DUMMY_NODE_ID;  // FIXME: Workaround for crazy bug.\n         let new_id = ast::DUMMY_NODE_ID;\n         (class_name,\n-         ItemStruct(@ast::StructDef {\n+         ItemStruct(box(GC) ast::StructDef {\n              fields: fields,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None },\n              super_struct: super_struct,\n@@ -4121,7 +4128,7 @@ impl<'a> Parser<'a> {\n             items: starting_items,\n             ..\n         } = self.parse_items_and_view_items(first_item_attrs, true, true);\n-        let mut items: Vec<@Item> = starting_items;\n+        let mut items: Vec<Gc<Item>> = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n         // don't think this other loop is even necessary....\n@@ -4322,25 +4329,25 @@ impl<'a> Parser<'a> {\n \n     // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&mut self, vis: ast::Visibility,\n-                             attrs: Vec<Attribute> ) -> @ForeignItem {\n+                             attrs: Vec<Attribute>) -> Gc<ForeignItem> {\n         let lo = self.span.lo;\n         self.expect_keyword(keywords::Fn);\n \n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(true);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        @ast::ForeignItem { ident: ident,\n-                            attrs: attrs,\n-                            node: ForeignItemFn(decl, generics),\n-                            id: ast::DUMMY_NODE_ID,\n-                            span: mk_sp(lo, hi),\n-                            vis: vis }\n+        box(GC) ast::ForeignItem { ident: ident,\n+                                   attrs: attrs,\n+                                   node: ForeignItemFn(decl, generics),\n+                                   id: ast::DUMMY_NODE_ID,\n+                                   span: mk_sp(lo, hi),\n+                                   vis: vis }\n     }\n \n     // parse a static item from a foreign module\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility,\n-                                 attrs: Vec<Attribute> ) -> @ForeignItem {\n+                                 attrs: Vec<Attribute> ) -> Gc<ForeignItem> {\n         let lo = self.span.lo;\n \n         self.expect_keyword(keywords::Static);\n@@ -4351,7 +4358,7 @@ impl<'a> Parser<'a> {\n         let ty = self.parse_ty(false);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        @ast::ForeignItem {\n+        box(GC) ast::ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemStatic(ty, mutbl),\n@@ -4483,14 +4490,14 @@ impl<'a> Parser<'a> {\n \n     // parse a structure-like enum variant definition\n     // this should probably be renamed or refactored...\n-    fn parse_struct_def(&mut self) -> @StructDef {\n+    fn parse_struct_def(&mut self) -> Gc<StructDef> {\n         let mut fields: Vec<StructField> = Vec::new();\n         while self.token != token::RBRACE {\n             fields.push(self.parse_struct_decl_field());\n         }\n         self.bump();\n \n-        return @ast::StructDef {\n+        return box(GC) ast::StructDef {\n             fields: fields,\n             ctor_id: None,\n             super_struct: None,\n@@ -4617,7 +4624,7 @@ impl<'a> Parser<'a> {\n             INTERPOLATED(token::NtItem(item)) => {\n                 self.bump();\n                 let new_attrs = attrs.append(item.attrs.as_slice());\n-                return IoviItem(@Item {\n+                return IoviItem(box(GC) Item {\n                     attrs: new_attrs,\n                     ..(*item).clone()\n                 });\n@@ -4892,7 +4899,7 @@ impl<'a> Parser<'a> {\n         return IoviNone(attrs);\n     }\n \n-    pub fn parse_item(&mut self, attrs: Vec<Attribute> ) -> Option<@Item> {\n+    pub fn parse_item(&mut self, attrs: Vec<Attribute> ) -> Option<Gc<Item>> {\n         match self.parse_item_or_view_item(attrs, true) {\n             IoviNone(_) => None,\n             IoviViewItem(_) =>\n@@ -4914,7 +4921,7 @@ impl<'a> Parser<'a> {\n     // | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n     // | MOD? non_global_path MOD_SEP STAR\n     // | MOD? non_global_path\n-    fn parse_view_path(&mut self) -> @ViewPath {\n+    fn parse_view_path(&mut self) -> Gc<ViewPath> {\n         let lo = self.span.lo;\n \n         if self.token == token::LBRACE {\n@@ -4928,7 +4935,7 @@ impl<'a> Parser<'a> {\n                 global: false,\n                 segments: Vec::new()\n             };\n-            return @spanned(lo, self.span.hi,\n+            return box(GC) spanned(lo, self.span.hi,\n                             ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n         }\n \n@@ -4956,7 +4963,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }).collect()\n             };\n-            return @spanned(lo, self.span.hi,\n+            return box(GC) spanned(lo, self.span.hi,\n                             ViewPathSimple(first_ident, path,\n                                            ast::DUMMY_NODE_ID));\n           }\n@@ -4991,7 +4998,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return @spanned(lo, self.span.hi,\n+                    return box(GC) spanned(lo, self.span.hi,\n                                     ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n                   }\n \n@@ -5009,7 +5016,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return @spanned(lo, self.span.hi,\n+                    return box(GC) spanned(lo, self.span.hi,\n                                     ViewPathGlob(path, ast::DUMMY_NODE_ID));\n                   }\n \n@@ -5031,7 +5038,7 @@ impl<'a> Parser<'a> {\n                 }\n             }).collect()\n         };\n-        return @spanned(lo,\n+        return box(GC) spanned(lo,\n                         self.last_span.hi,\n                         ViewPathSimple(last, path, ast::DUMMY_NODE_ID));\n     }"}, {"sha": "fa70261a7d7119c44c551f2d3ba8cfa4609e33d4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -18,10 +18,10 @@ use util::interner;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n-use std::path::BytesContainer;\n+use std::gc::Gc;\n use std::mem;\n+use std::path::BytesContainer;\n use std::rc::Rc;\n-use std::string::String;\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash, Show)]\n@@ -105,16 +105,16 @@ pub enum Token {\n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n-    NtItem(@ast::Item),\n+    NtItem(Gc<ast::Item>),\n     NtBlock(P<ast::Block>),\n-    NtStmt(@ast::Stmt),\n-    NtPat( @ast::Pat),\n-    NtExpr(@ast::Expr),\n+    NtStmt(Gc<ast::Stmt>),\n+    NtPat( Gc<ast::Pat>),\n+    NtExpr(Gc<ast::Expr>),\n     NtTy(  P<ast::Ty>),\n     NtIdent(Box<ast::Ident>, bool),\n-    NtMeta(@ast::MetaItem), // stuff inside brackets for attributes\n+    NtMeta(Gc<ast::MetaItem>), // stuff inside brackets for attributes\n     NtPath(Box<ast::Path>),\n-    NtTT(  @ast::TokenTree), // needs @ed to break a circularity\n+    NtTT(  Gc<ast::TokenTree>), // needs @ed to break a circularity\n     NtMatchers(Vec<ast::Matcher> )\n }\n \n@@ -241,8 +241,8 @@ pub fn to_str(t: &Token) -> String {\n       EOF => \"<eof>\".to_string(),\n       INTERPOLATED(ref nt) => {\n         match nt {\n-            &NtExpr(e) => ::print::pprust::expr_to_str(e),\n-            &NtMeta(e) => ::print::pprust::meta_item_to_str(e),\n+            &NtExpr(ref e) => ::print::pprust::expr_to_str(&**e),\n+            &NtMeta(ref e) => ::print::pprust::meta_item_to_str(&**e),\n             _ => {\n                 let mut s = \"an interpolated \".to_string();\n                 match *nt {"}, {"sha": "33b7086d7ae63282e660d7aeb2ed258f654efb26", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 194, "deletions": 190, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -26,11 +26,11 @@ use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n use print::pp::{Breaks, Consistent, Inconsistent, eof};\n use print::pp;\n \n+use std::gc::Gc;\n use std::io::{IoResult, MemWriter};\n use std::io;\n use std::mem;\n use std::str;\n-use std::string::String;\n \n pub enum AnnNode<'a> {\n     NodeBlock(&'a ast::Block),\n@@ -421,8 +421,8 @@ impl<'a> State<'a> {\n     }\n \n     pub fn commasep_exprs(&mut self, b: Breaks,\n-                          exprs: &[@ast::Expr]) -> IoResult<()> {\n-        self.commasep_cmnt(b, exprs, |s, &e| s.print_expr(e), |e| e.span)\n+                          exprs: &[Gc<ast::Expr>]) -> IoResult<()> {\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n     }\n \n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n@@ -432,7 +432,7 @@ impl<'a> State<'a> {\n             try!(self.print_view_item(vitem));\n         }\n         for item in _mod.items.iter() {\n-            try!(self.print_item(*item));\n+            try!(self.print_item(&**item));\n         }\n         Ok(())\n     }\n@@ -444,7 +444,7 @@ impl<'a> State<'a> {\n             try!(self.print_view_item(vitem));\n         }\n         for item in nmod.items.iter() {\n-            try!(self.print_foreign_item(*item));\n+            try!(self.print_foreign_item(&**item));\n         }\n         Ok(())\n     }\n@@ -464,17 +464,17 @@ impl<'a> State<'a> {\n         match ty.node {\n             ast::TyNil => try!(word(&mut self.s, \"()\")),\n             ast::TyBot => try!(word(&mut self.s, \"!\")),\n-            ast::TyBox(ty) => {\n+            ast::TyBox(ref ty) => {\n                 try!(word(&mut self.s, \"@\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n             }\n-            ast::TyUniq(ty) => {\n+            ast::TyUniq(ref ty) => {\n                 try!(word(&mut self.s, \"~\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n             }\n-            ast::TyVec(ty) => {\n+            ast::TyVec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::TyPtr(ref mt) => {\n@@ -505,7 +505,7 @@ impl<'a> State<'a> {\n                                       &None,\n                                       f.fn_style,\n                                       ast::Many,\n-                                      f.decl,\n+                                      &*f.decl,\n                                       None,\n                                       &None,\n                                       Some(&generics),\n@@ -522,14 +522,14 @@ impl<'a> State<'a> {\n                                       region,\n                                       f.fn_style,\n                                       f.onceness,\n-                                      f.decl,\n+                                      &*f.decl,\n                                       None,\n                                       &f.bounds,\n                                       Some(&generics),\n                                       None,\n                                       false));\n             }\n-            ast::TyProc(f) => {\n+            ast::TyProc(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: OwnedSlice::empty()\n@@ -539,7 +539,7 @@ impl<'a> State<'a> {\n                                       &None,\n                                       f.fn_style,\n                                       f.onceness,\n-                                      f.decl,\n+                                      &*f.decl,\n                                       None,\n                                       &f.bounds,\n                                       Some(&generics),\n@@ -552,7 +552,7 @@ impl<'a> State<'a> {\n                                       &None,\n                                       ast::NormalFn,\n                                       ast::Many,\n-                                      f.decl,\n+                                      &*f.decl,\n                                       None,\n                                       &None,\n                                       None,\n@@ -562,16 +562,16 @@ impl<'a> State<'a> {\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n             }\n-            ast::TyFixedLengthVec(ty, v) => {\n+            ast::TyFixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n                 try!(word(&mut self.s, \", ..\"));\n-                try!(self.print_expr(v));\n+                try!(self.print_expr(&**v));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::TyTypeof(e) => {\n+            ast::TyTypeof(ref e) => {\n                 try!(word(&mut self.s, \"typeof(\"));\n-                try!(self.print_expr(e));\n+                try!(self.print_expr(&**e));\n                 try!(word(&mut self.s, \")\"));\n             }\n             ast::TyInfer => {\n@@ -582,7 +582,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_type_ref(&mut self, ty: &P<ast::Ty>) -> IoResult<()> {\n-        self.print_type(*ty)\n+        self.print_type(&**ty)\n     }\n \n     pub fn print_foreign_item(&mut self,\n@@ -591,22 +591,22 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(item.span.lo));\n         try!(self.print_outer_attributes(item.attrs.as_slice()));\n         match item.node {\n-            ast::ForeignItemFn(decl, ref generics) => {\n-                try!(self.print_fn(decl, None, abi::Rust, item.ident, generics,\n-                None, item.vis));\n+            ast::ForeignItemFn(ref decl, ref generics) => {\n+                try!(self.print_fn(&**decl, None, abi::Rust, item.ident, generics,\n+                                   None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n                 self.end() // end the outer fn box\n             }\n-            ast::ForeignItemStatic(t, m) => {\n+            ast::ForeignItemStatic(ref t, m) => {\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"static\").as_slice()));\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(t));\n+                try!(self.print_type(&**t));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -620,26 +620,26 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(item.attrs.as_slice()));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n-            ast::ItemStatic(ty, m, expr) => {\n+            ast::ItemStatic(ref ty, m, ref expr) => {\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"static\").as_slice()));\n                 if m == ast::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n-            ast::ItemFn(decl, fn_style, abi, ref typarams, body) => {\n+            ast::ItemFn(ref decl, fn_style, abi, ref typarams, ref body) => {\n                 try!(self.print_fn(\n-                    decl,\n+                    &**decl,\n                     Some(fn_style),\n                     abi,\n                     item.ident,\n@@ -648,7 +648,7 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(body, item.attrs.as_slice()));\n+                try!(self.print_block_with_attrs(&**body, item.attrs.as_slice()));\n             }\n             ast::ItemMod(ref _mod) => {\n                 try!(self.head(visibility_qualified(item.vis,\n@@ -666,7 +666,7 @@ impl<'a> State<'a> {\n                 try!(self.print_foreign_mod(nmod, item.attrs.as_slice()));\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTy(ty, ref params) => {\n+            ast::ItemTy(ref ty, ref params) => {\n                 try!(self.ibox(indent_unit));\n                 try!(self.ibox(0u));\n                 try!(self.word_nbsp(visibility_qualified(item.vis,\n@@ -677,7 +677,7 @@ impl<'a> State<'a> {\n \n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n@@ -690,16 +690,17 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n             }\n-            ast::ItemStruct(struct_def, ref generics) => {\n+            ast::ItemStruct(ref struct_def, ref generics) => {\n                 if struct_def.is_virtual {\n                     try!(self.word_space(\"virtual\"));\n                 }\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"struct\").as_slice()));\n-                try!(self.print_struct(struct_def, generics, item.ident, item.span));\n+                try!(self.print_struct(&**struct_def, generics, item.ident,\n+                                       item.span));\n             }\n \n-            ast::ItemImpl(ref generics, ref opt_trait, ty, ref methods) => {\n+            ast::ItemImpl(ref generics, ref opt_trait, ref ty, ref methods) => {\n                 try!(self.head(visibility_qualified(item.vis,\n                                                     \"impl\").as_slice()));\n                 if generics.is_parameterized() {\n@@ -716,13 +717,13 @@ impl<'a> State<'a> {\n                     &None => {}\n                 }\n \n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n \n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes(item.attrs.as_slice()));\n                 for meth in methods.iter() {\n-                    try!(self.print_method(*meth));\n+                    try!(self.print_method(&**meth));\n                 }\n                 try!(self.bclose(item.span));\n             }\n@@ -788,12 +789,12 @@ impl<'a> State<'a> {\n                           variants: &[P<ast::Variant>],\n                           span: codemap::Span) -> IoResult<()> {\n         try!(self.bopen());\n-        for &v in variants.iter() {\n+        for v in variants.iter() {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n             try!(self.print_outer_attributes(v.node.attrs.as_slice()));\n             try!(self.ibox(indent_unit));\n-            try!(self.print_variant(v));\n+            try!(self.print_variant(&**v));\n             try!(word(&mut self.s, \",\"));\n             try!(self.end());\n             try!(self.maybe_print_trailing_comment(v.span, None));\n@@ -816,9 +817,9 @@ impl<'a> State<'a> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n         match struct_def.super_struct {\n-            Some(t) => {\n+            Some(ref t) => {\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(t));\n+                try!(self.print_type(&**t));\n             },\n             None => {},\n         }\n@@ -833,7 +834,7 @@ impl<'a> State<'a> {\n                             ast::UnnamedField(vis) => {\n                                 try!(s.print_visibility(vis));\n                                 try!(s.maybe_print_comment(field.span.lo));\n-                                s.print_type(field.node.ty)\n+                                s.print_type(&*field.node.ty)\n                             }\n                         }\n                     }\n@@ -858,7 +859,7 @@ impl<'a> State<'a> {\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_ident(ident));\n                         try!(self.word_nbsp(\":\"));\n-                        try!(self.print_type(field.node.ty));\n+                        try!(self.print_type(&*field.node.ty));\n                         try!(word(&mut self.s, \",\"));\n                     }\n                 }\n@@ -929,21 +930,21 @@ impl<'a> State<'a> {\n                     try!(self.popen());\n                     try!(self.commasep(Consistent,\n                                        args.as_slice(),\n-                                       |s, arg| s.print_type(arg.ty)));\n+                                       |s, arg| s.print_type(&*arg.ty)));\n                     try!(self.pclose());\n                 }\n             }\n-            ast::StructVariantKind(struct_def) => {\n+            ast::StructVariantKind(ref struct_def) => {\n                 try!(self.head(\"\"));\n                 let generics = ast_util::empty_generics();\n-                try!(self.print_struct(struct_def, &generics, v.node.name, v.span));\n+                try!(self.print_struct(&**struct_def, &generics, v.node.name, v.span));\n             }\n         }\n         match v.node.disr_expr {\n-            Some(d) => {\n+            Some(ref d) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_expr(d)\n+                self.print_expr(&**d)\n             }\n             _ => Ok(())\n         }\n@@ -958,7 +959,7 @@ impl<'a> State<'a> {\n                               &None,\n                               m.fn_style,\n                               ast::Many,\n-                              m.decl,\n+                              &*m.decl,\n                               Some(m.ident),\n                               &None,\n                               Some(&m.generics),\n@@ -971,19 +972,19 @@ impl<'a> State<'a> {\n                               m: &ast::TraitMethod) -> IoResult<()> {\n         match *m {\n             Required(ref ty_m) => self.print_ty_method(ty_m),\n-            Provided(m) => self.print_method(m)\n+            Provided(ref m) => self.print_method(&**m)\n         }\n     }\n \n     pub fn print_method(&mut self, meth: &ast::Method) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(meth.attrs.as_slice()));\n-        try!(self.print_fn(meth.decl, Some(meth.fn_style), abi::Rust,\n+        try!(self.print_fn(&*meth.decl, Some(meth.fn_style), abi::Rust,\n                         meth.ident, &meth.generics, Some(meth.explicit_self.node),\n                         meth.vis));\n         try!(word(&mut self.s, \" \"));\n-        self.print_block_with_attrs(meth.body, meth.attrs.as_slice())\n+        self.print_block_with_attrs(&*meth.body, meth.attrs.as_slice())\n     }\n \n     pub fn print_outer_attributes(&mut self,\n@@ -1032,7 +1033,7 @@ impl<'a> State<'a> {\n                 ast::AttrInner => try!(word(&mut self.s, \"#![\")),\n                 ast::AttrOuter => try!(word(&mut self.s, \"#[\")),\n             }\n-            try!(self.print_meta_item(attr.meta()));\n+            try!(self.print_meta_item(&*attr.meta()));\n             word(&mut self.s, \"]\")\n         }\n     }\n@@ -1041,16 +1042,16 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> IoResult<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n-            ast::StmtDecl(decl, _) => {\n-                try!(self.print_decl(decl));\n+            ast::StmtDecl(ref decl, _) => {\n+                try!(self.print_decl(&**decl));\n             }\n-            ast::StmtExpr(expr, _) => {\n+            ast::StmtExpr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n             }\n-            ast::StmtSemi(expr, _) => {\n+            ast::StmtSemi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \";\"));\n             }\n             ast::StmtMac(ref mac, semi) => {\n@@ -1105,12 +1106,12 @@ impl<'a> State<'a> {\n             try!(self.print_view_item(vi));\n         }\n         for st in blk.stmts.iter() {\n-            try!(self.print_stmt(*st));\n+            try!(self.print_stmt(&**st));\n         }\n         match blk.expr {\n-            Some(expr) => {\n+            Some(ref expr) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n             _ => ()\n@@ -1119,26 +1120,26 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeBlock(blk))\n     }\n \n-    fn print_else(&mut self, els: Option<@ast::Expr>) -> IoResult<()> {\n+    fn print_else(&mut self, els: Option<Gc<ast::Expr>>) -> IoResult<()> {\n         match els {\n             Some(_else) => {\n                 match _else.node {\n                     // \"another else-if\"\n-                    ast::ExprIf(i, t, e) => {\n+                    ast::ExprIf(ref i, ref t, e) => {\n                         try!(self.cbox(indent_unit - 1u));\n                         try!(self.ibox(0u));\n                         try!(word(&mut self.s, \" else if \"));\n-                        try!(self.print_expr(i));\n+                        try!(self.print_expr(&**i));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(t));\n+                        try!(self.print_block(&**t));\n                         self.print_else(e)\n                     }\n                     // \"final else\"\n-                    ast::ExprBlock(b) => {\n+                    ast::ExprBlock(ref b) => {\n                         try!(self.cbox(indent_unit - 1u));\n                         try!(self.ibox(0u));\n                         try!(word(&mut self.s, \" else \"));\n-                        self.print_block(b)\n+                        self.print_block(&**b)\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n@@ -1151,7 +1152,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n-                    elseopt: Option<@ast::Expr>, chk: bool) -> IoResult<()> {\n+                    elseopt: Option<Gc<ast::Expr>>, chk: bool) -> IoResult<()> {\n         try!(self.head(\"if\"));\n         if chk { try!(self.word_nbsp(\"check\")); }\n         try!(self.print_expr(test));\n@@ -1184,7 +1185,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_call_post(&mut self, args: &[@ast::Expr]) -> IoResult<()> {\n+    fn print_call_post(&mut self, args: &[Gc<ast::Expr>]) -> IoResult<()> {\n         try!(self.popen());\n         try!(self.commasep_exprs(Inconsistent, args));\n         self.pclose()\n@@ -1207,16 +1208,16 @@ impl<'a> State<'a> {\n         try!(self.ibox(indent_unit));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprVstore(e, v) => {\n+            ast::ExprVstore(ref e, v) => {\n                 try!(self.print_expr_vstore(v));\n-                try!(self.print_expr(e));\n+                try!(self.print_expr(&**e));\n             },\n-            ast::ExprBox(p, e) => {\n+            ast::ExprBox(ref p, ref e) => {\n                 try!(word(&mut self.s, \"box\"));\n                 try!(word(&mut self.s, \"(\"));\n-                try!(self.print_expr(p));\n+                try!(self.print_expr(&**p));\n                 try!(self.word_space(\")\"));\n-                try!(self.print_expr(e));\n+                try!(self.print_expr(&**e));\n             }\n             ast::ExprVec(ref exprs) => {\n                 try!(self.ibox(indent_unit));\n@@ -1226,13 +1227,13 @@ impl<'a> State<'a> {\n                 try!(self.end());\n             }\n \n-            ast::ExprRepeat(element, count) => {\n+            ast::ExprRepeat(ref element, ref count) => {\n                 try!(self.ibox(indent_unit));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(element));\n+                try!(self.print_expr(&**element));\n                 try!(word(&mut self.s, \",\"));\n                 try!(word(&mut self.s, \"..\"));\n-                try!(self.print_expr(count));\n+                try!(self.print_expr(&**count));\n                 try!(word(&mut self.s, \"]\"));\n                 try!(self.end());\n             }\n@@ -1247,19 +1248,19 @@ impl<'a> State<'a> {\n                         try!(s.ibox(indent_unit));\n                         try!(s.print_ident(field.ident.node));\n                         try!(s.word_space(\":\"));\n-                        try!(s.print_expr(field.expr));\n+                        try!(s.print_expr(&*field.expr));\n                         s.end()\n                     },\n                     |f| f.span));\n                 match wth {\n-                    Some(expr) => {\n+                    Some(ref expr) => {\n                         try!(self.ibox(indent_unit));\n                         if !fields.is_empty() {\n                             try!(word(&mut self.s, \",\"));\n                             try!(space(&mut self.s));\n                         }\n                         try!(word(&mut self.s, \"..\"));\n-                        try!(self.print_expr(expr));\n+                        try!(self.print_expr(&**expr));\n                         try!(self.end());\n                     }\n                     _ => try!(word(&mut self.s, \",\"))\n@@ -1274,13 +1275,13 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n-            ast::ExprCall(func, ref args) => {\n-                try!(self.print_expr_maybe_paren(func));\n+            ast::ExprCall(ref func, ref args) => {\n+                try!(self.print_expr_maybe_paren(&**func));\n                 try!(self.print_call_post(args.as_slice()));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n                 let base_args = args.slice_from(1);\n-                try!(self.print_expr(*args.get(0)));\n+                try!(self.print_expr(&**args.get(0)));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(ident.node));\n                 if tys.len() > 0u {\n@@ -1291,66 +1292,66 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_call_post(base_args));\n             }\n-            ast::ExprBinary(op, lhs, rhs) => {\n-                try!(self.print_expr(lhs));\n+            ast::ExprBinary(op, ref lhs, ref rhs) => {\n+                try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(ast_util::binop_to_str(op)));\n-                try!(self.print_expr(rhs));\n+                try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprUnary(op, expr) => {\n+            ast::ExprUnary(op, ref expr) => {\n                 try!(word(&mut self.s, ast_util::unop_to_str(op)));\n-                try!(self.print_expr_maybe_paren(expr));\n+                try!(self.print_expr_maybe_paren(&**expr));\n             }\n-            ast::ExprAddrOf(m, expr) => {\n+            ast::ExprAddrOf(m, ref expr) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_mutability(m));\n-                try!(self.print_expr_maybe_paren(expr));\n+                try!(self.print_expr_maybe_paren(&**expr));\n             }\n-            ast::ExprLit(lit) => try!(self.print_literal(lit)),\n-            ast::ExprCast(expr, ty) => {\n-                try!(self.print_expr(expr));\n+            ast::ExprLit(ref lit) => try!(self.print_literal(&**lit)),\n+            ast::ExprCast(ref expr, ref ty) => {\n+                try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"as\"));\n-                try!(self.print_type(ty));\n+                try!(self.print_type(&**ty));\n             }\n-            ast::ExprIf(test, blk, elseopt) => {\n-                try!(self.print_if(test, blk, elseopt, false));\n+            ast::ExprIf(ref test, ref blk, elseopt) => {\n+                try!(self.print_if(&**test, &**blk, elseopt, false));\n             }\n-            ast::ExprWhile(test, blk) => {\n+            ast::ExprWhile(ref test, ref blk) => {\n                 try!(self.head(\"while\"));\n-                try!(self.print_expr(test));\n+                try!(self.print_expr(&**test));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(blk));\n+                try!(self.print_block(&**blk));\n             }\n-            ast::ExprForLoop(pat, iter, blk, opt_ident) => {\n+            ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n                     try!(word(&mut self.s, \"'\"));\n                     try!(self.print_ident(*ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"for\"));\n-                try!(self.print_pat(pat));\n+                try!(self.print_pat(&**pat));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"in\"));\n-                try!(self.print_expr(iter));\n+                try!(self.print_expr(&**iter));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(blk));\n+                try!(self.print_block(&**blk));\n             }\n-            ast::ExprLoop(blk, opt_ident) => {\n+            ast::ExprLoop(ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n                     try!(word(&mut self.s, \"'\"));\n                     try!(self.print_ident(*ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"loop\"));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(blk));\n+                try!(self.print_block(&**blk));\n             }\n-            ast::ExprMatch(expr, ref arms) => {\n+            ast::ExprMatch(ref expr, ref arms) => {\n                 try!(self.cbox(indent_unit));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n-                try!(self.print_expr(expr));\n+                try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 let len = arms.len();\n@@ -1371,58 +1372,59 @@ impl<'a> State<'a> {\n                             try!(space(&mut self.s));\n                             try!(self.word_space(\"|\"));\n                         }\n-                        try!(self.print_pat(*p));\n+                        try!(self.print_pat(&**p));\n                     }\n                     try!(space(&mut self.s));\n                     match arm.guard {\n-                        Some(e) => {\n+                        Some(ref e) => {\n                             try!(self.word_space(\"if\"));\n-                            try!(self.print_expr(e));\n+                            try!(self.print_expr(&**e));\n                             try!(space(&mut self.s));\n                         }\n                         None => ()\n                     }\n                     try!(self.word_space(\"=>\"));\n \n                     match arm.body.node {\n-                        ast::ExprBlock(blk) => {\n+                        ast::ExprBlock(ref blk) => {\n                             // the block will close the pattern's ibox\n-                            try!(self.print_block_unclosed_indent(blk, indent_unit));\n+                            try!(self.print_block_unclosed_indent(&**blk,\n+                                                                  indent_unit));\n                         }\n                         _ => {\n                             try!(self.end()); // close the ibox for the pattern\n-                            try!(self.print_expr(arm.body));\n+                            try!(self.print_expr(&*arm.body));\n                         }\n                     }\n-                    if !expr_is_simple_block(expr)\n+                    if !expr_is_simple_block(expr.clone())\n                         && i < len - 1 {\n                         try!(word(&mut self.s, \",\"));\n                     }\n                     try!(self.end()); // close enclosing cbox\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n             }\n-            ast::ExprFnBlock(decl, body) => {\n+            ast::ExprFnBlock(ref decl, ref body) => {\n                 // in do/for blocks we don't want to show an empty\n                 // argument list, but at this point we don't know which\n                 // we are inside.\n                 //\n                 // if !decl.inputs.is_empty() {\n-                try!(self.print_fn_block_args(decl));\n+                try!(self.print_fn_block_args(&**decl));\n                 try!(space(&mut self.s));\n                 // }\n \n                 if !body.stmts.is_empty() || !body.expr.is_some() {\n-                    try!(self.print_block_unclosed(body));\n+                    try!(self.print_block_unclosed(&**body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n                     match body.expr.unwrap().node {\n-                        ast::ExprBlock(blk) => {\n-                            try!(self.print_block_unclosed(blk));\n+                        ast::ExprBlock(ref blk) => {\n+                            try!(self.print_block_unclosed(&**blk));\n                         }\n                         _ => {\n                             // this is a bare expression\n-                            try!(self.print_expr(body.expr.unwrap()));\n+                            try!(self.print_expr(&*body.expr.unwrap()));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n@@ -1432,25 +1434,25 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprProc(decl, body) => {\n+            ast::ExprProc(ref decl, ref body) => {\n                 // in do/for blocks we don't want to show an empty\n                 // argument list, but at this point we don't know which\n                 // we are inside.\n                 //\n                 // if !decl.inputs.is_empty() {\n-                try!(self.print_proc_args(decl));\n+                try!(self.print_proc_args(&**decl));\n                 try!(space(&mut self.s));\n                 // }\n                 assert!(body.stmts.is_empty());\n                 assert!(body.expr.is_some());\n                 // we extract the block, so as not to create another set of boxes\n                 match body.expr.unwrap().node {\n-                    ast::ExprBlock(blk) => {\n-                        try!(self.print_block_unclosed(blk));\n+                    ast::ExprBlock(ref blk) => {\n+                        try!(self.print_block_unclosed(&**blk));\n                     }\n                     _ => {\n                         // this is a bare expression\n-                        try!(self.print_expr(body.expr.unwrap()));\n+                        try!(self.print_expr(&*body.expr.unwrap()));\n                         try!(self.end()); // need to close a box\n                     }\n                 }\n@@ -1459,28 +1461,28 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprBlock(blk) => {\n+            ast::ExprBlock(ref blk) => {\n                 // containing cbox, will be closed by print-block at }\n                 try!(self.cbox(indent_unit));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0u));\n-                try!(self.print_block(blk));\n+                try!(self.print_block(&**blk));\n             }\n-            ast::ExprAssign(lhs, rhs) => {\n-                try!(self.print_expr(lhs));\n+            ast::ExprAssign(ref lhs, ref rhs) => {\n+                try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(rhs));\n+                try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprAssignOp(op, lhs, rhs) => {\n-                try!(self.print_expr(lhs));\n+            ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n+                try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, ast_util::binop_to_str(op)));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(rhs));\n+                try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprField(expr, id, ref tys) => {\n-                try!(self.print_expr(expr));\n+            ast::ExprField(ref expr, id, ref tys) => {\n+                try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(id));\n                 if tys.len() > 0u {\n@@ -1491,10 +1493,10 @@ impl<'a> State<'a> {\n                     try!(word(&mut self.s, \">\"));\n                 }\n             }\n-            ast::ExprIndex(expr, index) => {\n-                try!(self.print_expr(expr));\n+            ast::ExprIndex(ref expr, ref index) => {\n+                try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(index));\n+                try!(self.print_expr(&**index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n@@ -1516,12 +1518,12 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s))\n                 }\n             }\n-            ast::ExprRet(result) => {\n+            ast::ExprRet(ref result) => {\n                 try!(word(&mut self.s, \"return\"));\n-                match result {\n-                    Some(expr) => {\n+                match *result {\n+                    Some(ref expr) => {\n                         try!(word(&mut self.s, \" \"));\n-                        try!(self.print_expr(expr));\n+                        try!(self.print_expr(&**expr));\n                     }\n                     _ => ()\n                 }\n@@ -1536,20 +1538,22 @@ impl<'a> State<'a> {\n                 try!(self.print_string(a.asm.get(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.outputs.as_slice(), |s, &(ref co, o)| {\n+                try!(self.commasep(Inconsistent, a.outputs.as_slice(),\n+                                   |s, &(ref co, ref o)| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     try!(s.popen());\n-                    try!(s.print_expr(o));\n+                    try!(s.print_expr(&**o));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.inputs.as_slice(), |s, &(ref co, o)| {\n+                try!(self.commasep(Inconsistent, a.inputs.as_slice(),\n+                                   |s, &(ref co, ref o)| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     try!(s.popen());\n-                    try!(s.print_expr(o));\n+                    try!(s.print_expr(&**o));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -1560,9 +1564,9 @@ impl<'a> State<'a> {\n                 try!(self.pclose());\n             }\n             ast::ExprMac(ref m) => try!(self.print_mac(m)),\n-            ast::ExprParen(e) => {\n+            ast::ExprParen(ref e) => {\n                 try!(self.popen());\n-                try!(self.print_expr(e));\n+                try!(self.print_expr(&**e));\n                 try!(self.pclose());\n             }\n         }\n@@ -1571,38 +1575,38 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_local_decl(&mut self, loc: &ast::Local) -> IoResult<()> {\n-        try!(self.print_pat(loc.pat));\n+        try!(self.print_pat(&*loc.pat));\n         match loc.ty.node {\n             ast::TyInfer => Ok(()),\n             _ => {\n                 try!(self.word_space(\":\"));\n-                self.print_type(loc.ty)\n+                self.print_type(&*loc.ty)\n             }\n         }\n     }\n \n     pub fn print_decl(&mut self, decl: &ast::Decl) -> IoResult<()> {\n         try!(self.maybe_print_comment(decl.span.lo));\n         match decl.node {\n-            ast::DeclLocal(loc) => {\n+            ast::DeclLocal(ref loc) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.ibox(indent_unit));\n                 try!(self.word_nbsp(\"let\"));\n \n                 try!(self.ibox(indent_unit));\n-                try!(self.print_local_decl(loc));\n+                try!(self.print_local_decl(&**loc));\n                 try!(self.end());\n                 match loc.init {\n-                    Some(init) => {\n+                    Some(ref init) => {\n                         try!(self.nbsp());\n                         try!(self.word_space(\"=\"));\n-                        try!(self.print_expr(init));\n+                        try!(self.print_expr(&**init));\n                     }\n                     _ => {}\n                 }\n                 self.end()\n             }\n-            ast::DeclItem(item) => self.print_item(item)\n+            ast::DeclItem(ref item) => self.print_item(&**item)\n         }\n     }\n \n@@ -1709,9 +1713,9 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_path(path, true));\n                 match sub {\n-                    Some(p) => {\n+                    Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n-                        try!(self.print_pat(p));\n+                        try!(self.print_pat(&**p));\n                     }\n                     None => ()\n                 }\n@@ -1724,7 +1728,7 @@ impl<'a> State<'a> {\n                         if !args.is_empty() {\n                             try!(self.popen());\n                             try!(self.commasep(Inconsistent, args.as_slice(),\n-                                              |s, &p| s.print_pat(p)));\n+                                              |s, p| s.print_pat(&**p)));\n                             try!(self.pclose());\n                         }\n                     }\n@@ -1739,7 +1743,7 @@ impl<'a> State<'a> {\n                         try!(s.cbox(indent_unit));\n                         try!(s.print_ident(f.ident));\n                         try!(s.word_space(\":\"));\n-                        try!(s.print_pat(f.pat));\n+                        try!(s.print_pat(&*f.pat));\n                         s.end()\n                     },\n                     |f| f.pat.span));\n@@ -1753,46 +1757,46 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n                                    elts.as_slice(),\n-                                   |s, &p| s.print_pat(p)));\n+                                   |s, p| s.print_pat(&**p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n-            ast::PatBox(inner) => {\n+            ast::PatBox(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n-                try!(self.print_pat(inner));\n+                try!(self.print_pat(&**inner));\n             }\n-            ast::PatRegion(inner) => {\n+            ast::PatRegion(ref inner) => {\n                 try!(word(&mut self.s, \"&\"));\n-                try!(self.print_pat(inner));\n+                try!(self.print_pat(&**inner));\n             }\n-            ast::PatLit(e) => try!(self.print_expr(e)),\n-            ast::PatRange(begin, end) => {\n-                try!(self.print_expr(begin));\n+            ast::PatLit(ref e) => try!(self.print_expr(&**e)),\n+            ast::PatRange(ref begin, ref end) => {\n+                try!(self.print_expr(&**begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"..\"));\n-                try!(self.print_expr(end));\n+                try!(self.print_expr(&**end));\n             }\n             ast::PatVec(ref before, slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n                                    before.as_slice(),\n-                                   |s, &p| s.print_pat(p)));\n-                for &p in slice.iter() {\n+                                   |s, p| s.print_pat(&**p)));\n+                for p in slice.iter() {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n-                    match *p {\n+                    match **p {\n                         ast::Pat { node: ast::PatWildMulti, .. } => {\n                             // this case is handled by print_pat\n                         }\n                         _ => try!(word(&mut self.s, \"..\")),\n                     }\n-                    try!(self.print_pat(p));\n+                    try!(self.print_pat(&**p));\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,\n                                    after.as_slice(),\n-                                   |s, &p| s.print_pat(p)));\n+                                   |s, p| s.print_pat(&**p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::PatMac(ref m) => try!(self.print_mac(m)),\n@@ -1888,7 +1892,7 @@ impl<'a> State<'a> {\n             _ => {\n                 try!(self.space_if_not_bol());\n                 try!(self.word_space(\"->\"));\n-                self.print_type(decl.output)\n+                self.print_type(&*decl.output)\n             }\n         }\n     }\n@@ -1904,7 +1908,7 @@ impl<'a> State<'a> {\n             _ => {\n                 try!(self.space_if_not_bol());\n                 try!(self.word_space(\"->\"));\n-                try!(self.print_type(decl.output));\n+                try!(self.print_type(&*decl.output));\n             }\n         }\n \n@@ -1922,7 +1926,7 @@ impl<'a> State<'a> {\n             _ => {\n                 try!(self.space_if_not_bol());\n                 try!(self.word_space(\"->\"));\n-                try!(self.print_type(decl.output));\n+                try!(self.print_type(&*decl.output));\n             }\n         }\n \n@@ -1964,7 +1968,7 @@ impl<'a> State<'a> {\n                                          &None,\n                                          ast::NormalFn,\n                                          ast::Many,\n-                                         unboxed_function_type.decl,\n+                                         &*unboxed_function_type.decl,\n                                          None,\n                                          &None,\n                                          None,\n@@ -2014,10 +2018,10 @@ impl<'a> State<'a> {\n                         try!(s.print_ident(param.ident));\n                         try!(s.print_bounds(&None, &param.bounds, false));\n                         match param.default {\n-                            Some(default) => {\n+                            Some(ref default) => {\n                                 try!(space(&mut s.s));\n                                 try!(s.word_space(\"=\"));\n-                                s.print_type(default)\n+                                s.print_type(&**default)\n                             }\n                             _ => Ok(())\n                         }\n@@ -2045,7 +2049,7 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                                    items.as_slice(),\n-                                   |s, &i| s.print_meta_item(i)));\n+                                   |s, i| s.print_meta_item(&**i)));\n                 try!(self.pclose());\n             }\n         }\n@@ -2103,7 +2107,7 @@ impl<'a> State<'a> {\n \n             ast::ViewItemUse(ref vp) => {\n                 try!(self.head(\"use\"));\n-                try!(self.print_view_path(*vp));\n+                try!(self.print_view_path(&**vp));\n             }\n         }\n         try!(word(&mut self.s, \";\"));\n@@ -2121,13 +2125,13 @@ impl<'a> State<'a> {\n \n     pub fn print_mt(&mut self, mt: &ast::MutTy) -> IoResult<()> {\n         try!(self.print_mutability(mt.mutbl));\n-        self.print_type(mt.ty)\n+        self.print_type(&*mt.ty)\n     }\n \n     pub fn print_arg(&mut self, input: &ast::Arg) -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n         match input.ty.node {\n-            ast::TyInfer => try!(self.print_pat(input.pat)),\n+            ast::TyInfer => try!(self.print_pat(&*input.pat)),\n             _ => {\n                 match input.pat.node {\n                     ast::PatIdent(_, ref path, _) if\n@@ -2137,12 +2141,12 @@ impl<'a> State<'a> {\n                         // Do nothing.\n                     }\n                     _ => {\n-                        try!(self.print_pat(input.pat));\n+                        try!(self.print_pat(&*input.pat));\n                         try!(word(&mut self.s, \":\"));\n                         try!(space(&mut self.s));\n                     }\n                 }\n-                try!(self.print_type(input.ty));\n+                try!(self.print_type(&*input.ty));\n             }\n         }\n         self.end()\n@@ -2229,7 +2233,7 @@ impl<'a> State<'a> {\n                 if decl.cf == ast::NoReturn {\n                     try!(self.word_nbsp(\"!\"));\n                 } else {\n-                    try!(self.print_type(decl.output));\n+                    try!(self.print_type(&*decl.output));\n                 }\n                 try!(self.end());\n             }"}, {"sha": "59771a57dfa50bdfda64b19d89aaccc93aa530d7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 149, "deletions": 147, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -15,6 +15,8 @@ use codemap::Span;\n use parse;\n use owned_slice::OwnedSlice;\n \n+use std::gc::Gc;\n+\n // Context-passing AST walker. Each overridden visit method has full control\n // over what happens with its node, it can do its own traversal of the node's\n // children (potentially passing in different contexts to each), call\n@@ -135,9 +137,9 @@ pub fn walk_inlined_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                   item: &ast::InlinedItem,\n                                                   env: E) {\n     match *item {\n-        IIItem(i) => visitor.visit_item(i, env),\n-        IIForeign(i) => visitor.visit_foreign_item(i, env),\n-        IIMethod(_, _, m) => walk_method_helper(visitor, m, env),\n+        IIItem(i) => visitor.visit_item(&*i, env),\n+        IIForeign(i) => visitor.visit_foreign_item(&*i, env),\n+        IIMethod(_, _, m) => walk_method_helper(visitor, &*m, env),\n     }\n }\n \n@@ -155,7 +157,7 @@ pub fn walk_mod<E: Clone, V: Visitor<E>>(visitor: &mut V, module: &Mod, env: E)\n     }\n \n     for item in module.items.iter() {\n-        visitor.visit_item(*item, env.clone())\n+        visitor.visit_item(&**item, env.clone())\n     }\n }\n \n@@ -188,11 +190,11 @@ pub fn walk_view_item<E: Clone, V: Visitor<E>>(visitor: &mut V, vi: &ViewItem, e\n }\n \n pub fn walk_local<E: Clone, V: Visitor<E>>(visitor: &mut V, local: &Local, env: E) {\n-    visitor.visit_pat(local.pat, env.clone());\n-    visitor.visit_ty(local.ty, env.clone());\n+    visitor.visit_pat(&*local.pat, env.clone());\n+    visitor.visit_ty(&*local.ty, env.clone());\n     match local.init {\n         None => {}\n-        Some(initializer) => visitor.visit_expr(initializer, env),\n+        Some(initializer) => visitor.visit_expr(&*initializer, env),\n     }\n }\n \n@@ -218,14 +220,14 @@ pub fn walk_trait_ref_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E) {\n     visitor.visit_ident(item.span, item.ident, env.clone());\n     match item.node {\n-        ItemStatic(typ, _, expr) => {\n-            visitor.visit_ty(typ, env.clone());\n-            visitor.visit_expr(expr, env.clone());\n+        ItemStatic(ref typ, _, ref expr) => {\n+            visitor.visit_ty(&**typ, env.clone());\n+            visitor.visit_expr(&**expr, env.clone());\n         }\n         ItemFn(declaration, fn_style, abi, ref generics, body) => {\n             visitor.visit_fn(&FkItemFn(item.ident, generics, fn_style, abi),\n-                             declaration,\n-                             body,\n+                             &*declaration,\n+                             &*body,\n                              item.span,\n                              item.id,\n                              env.clone())\n@@ -238,11 +240,11 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                 visitor.visit_view_item(view_item, env.clone())\n             }\n             for foreign_item in foreign_module.items.iter() {\n-                visitor.visit_foreign_item(*foreign_item, env.clone())\n+                visitor.visit_foreign_item(&**foreign_item, env.clone())\n             }\n         }\n-        ItemTy(typ, ref type_parameters) => {\n-            visitor.visit_ty(typ, env.clone());\n+        ItemTy(ref typ, ref type_parameters) => {\n+            visitor.visit_ty(&**typ, env.clone());\n             visitor.visit_generics(type_parameters, env.clone())\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n@@ -259,14 +261,14 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                                                                    trait_reference, env.clone()),\n                 None => ()\n             }\n-            visitor.visit_ty(typ, env.clone());\n+            visitor.visit_ty(&*typ, env.clone());\n             for method in methods.iter() {\n-                walk_method_helper(visitor, *method, env.clone())\n+                walk_method_helper(visitor, &**method, env.clone())\n             }\n         }\n-        ItemStruct(struct_definition, ref generics) => {\n+        ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics, env.clone());\n-            visitor.visit_struct_def(struct_definition,\n+            visitor.visit_struct_def(&**struct_definition,\n                                      item.ident,\n                                      generics,\n                                      item.id,\n@@ -295,7 +297,7 @@ pub fn walk_enum_def<E: Clone, V:Visitor<E>>(visitor: &mut V,\n                                              generics: &Generics,\n                                              env: E) {\n     for &variant in enum_definition.variants.iter() {\n-        visitor.visit_variant(variant, generics, env.clone());\n+        visitor.visit_variant(&*variant, generics, env.clone());\n     }\n }\n \n@@ -308,19 +310,19 @@ pub fn walk_variant<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     match variant.node.kind {\n         TupleVariantKind(ref variant_arguments) => {\n             for variant_argument in variant_arguments.iter() {\n-                visitor.visit_ty(variant_argument.ty, env.clone())\n+                visitor.visit_ty(&*variant_argument.ty, env.clone())\n             }\n         }\n-        StructVariantKind(struct_definition) => {\n-            visitor.visit_struct_def(struct_definition,\n+        StructVariantKind(ref struct_definition) => {\n+            visitor.visit_struct_def(&**struct_definition,\n                                      variant.node.name,\n                                      generics,\n                                      variant.node.id,\n                                      env.clone())\n         }\n     }\n     match variant.node.disr_expr {\n-        Some(expr) => visitor.visit_expr(expr, env.clone()),\n+        Some(ref expr) => visitor.visit_expr(&**expr, env.clone()),\n         None => ()\n     }\n     for attr in variant.node.attrs.iter() {\n@@ -335,25 +337,25 @@ pub fn skip_ty<E, V: Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     match typ.node {\n         TyUniq(ty) | TyVec(ty) | TyBox(ty) => {\n-            visitor.visit_ty(ty, env)\n+            visitor.visit_ty(&*ty, env)\n         }\n         TyPtr(ref mutable_type) => {\n-            visitor.visit_ty(mutable_type.ty, env)\n+            visitor.visit_ty(&*mutable_type.ty, env)\n         }\n         TyRptr(ref lifetime, ref mutable_type) => {\n             visitor.visit_opt_lifetime_ref(typ.span, lifetime, env.clone());\n-            visitor.visit_ty(mutable_type.ty, env)\n+            visitor.visit_ty(&*mutable_type.ty, env)\n         }\n         TyTup(ref tuple_element_types) => {\n             for &tuple_element_type in tuple_element_types.iter() {\n-                visitor.visit_ty(tuple_element_type, env.clone())\n+                visitor.visit_ty(&*tuple_element_type, env.clone())\n             }\n         }\n         TyClosure(ref function_declaration, ref region) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty, env.clone())\n             }\n-            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n             for bounds in function_declaration.bounds.iter() {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n             }\n@@ -366,9 +368,9 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n         }\n         TyProc(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty, env.clone())\n             }\n-            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n             for bounds in function_declaration.bounds.iter() {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n             }\n@@ -377,30 +379,30 @@ pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n         }\n         TyBareFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty, env.clone())\n             }\n-            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n                                 env.clone());\n         }\n         TyUnboxedFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty, env.clone())\n             }\n-            visitor.visit_ty(function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n         }\n         TyPath(ref path, ref bounds, id) => {\n             visitor.visit_path(path, id, env.clone());\n             for bounds in bounds.iter() {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n             }\n         }\n-        TyFixedLengthVec(ty, expression) => {\n-            visitor.visit_ty(ty, env.clone());\n-            visitor.visit_expr(expression, env)\n+        TyFixedLengthVec(ref ty, ref expression) => {\n+            visitor.visit_ty(&**ty, env.clone());\n+            visitor.visit_expr(&**expression, env)\n         }\n-        TyTypeof(expression) => {\n-            visitor.visit_expr(expression, env)\n+        TyTypeof(ref expression) => {\n+            visitor.visit_expr(&**expression, env)\n         }\n         TyNil | TyBot | TyInfer => {}\n     }\n@@ -418,8 +420,8 @@ pub fn walk_path<E: Clone, V: Visitor<E>>(visitor: &mut V, path: &Path, env: E)\n     for segment in path.segments.iter() {\n         visitor.visit_ident(path.span, segment.identifier, env.clone());\n \n-        for &typ in segment.types.iter() {\n-            visitor.visit_ty(typ, env.clone());\n+        for typ in segment.types.iter() {\n+            visitor.visit_ty(&**typ, env.clone());\n         }\n         for lifetime in segment.lifetimes.iter() {\n             visitor.visit_lifetime_ref(lifetime, env.clone());\n@@ -433,47 +435,47 @@ pub fn walk_pat<E: Clone, V: Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E)\n             visitor.visit_path(path, pattern.id, env.clone());\n             for children in children.iter() {\n                 for child in children.iter() {\n-                    visitor.visit_pat(*child, env.clone())\n+                    visitor.visit_pat(&**child, env.clone())\n                 }\n             }\n         }\n         PatStruct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id, env.clone());\n             for field in fields.iter() {\n-                visitor.visit_pat(field.pat, env.clone())\n+                visitor.visit_pat(&*field.pat, env.clone())\n             }\n         }\n         PatTup(ref tuple_elements) => {\n             for tuple_element in tuple_elements.iter() {\n-                visitor.visit_pat(*tuple_element, env.clone())\n+                visitor.visit_pat(&**tuple_element, env.clone())\n             }\n         }\n-        PatBox(subpattern) |\n-        PatRegion(subpattern) => {\n-            visitor.visit_pat(subpattern, env)\n+        PatBox(ref subpattern) |\n+        PatRegion(ref subpattern) => {\n+            visitor.visit_pat(&**subpattern, env)\n         }\n         PatIdent(_, ref path, ref optional_subpattern) => {\n             visitor.visit_path(path, pattern.id, env.clone());\n             match *optional_subpattern {\n                 None => {}\n-                Some(subpattern) => visitor.visit_pat(subpattern, env),\n+                Some(ref subpattern) => visitor.visit_pat(&**subpattern, env),\n             }\n         }\n-        PatLit(expression) => visitor.visit_expr(expression, env),\n-        PatRange(lower_bound, upper_bound) => {\n-            visitor.visit_expr(lower_bound, env.clone());\n-            visitor.visit_expr(upper_bound, env)\n+        PatLit(ref expression) => visitor.visit_expr(&**expression, env),\n+        PatRange(ref lower_bound, ref upper_bound) => {\n+            visitor.visit_expr(&**lower_bound, env.clone());\n+            visitor.visit_expr(&**upper_bound, env)\n         }\n         PatWild | PatWildMulti => (),\n         PatVec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n             for prepattern in prepattern.iter() {\n-                visitor.visit_pat(*prepattern, env.clone())\n+                visitor.visit_pat(&**prepattern, env.clone())\n             }\n             for slice_pattern in slice_pattern.iter() {\n-                visitor.visit_pat(*slice_pattern, env.clone())\n+                visitor.visit_pat(&**slice_pattern, env.clone())\n             }\n             for postpattern in postpatterns.iter() {\n-                visitor.visit_pat(*postpattern, env.clone())\n+                visitor.visit_pat(&**postpattern, env.clone())\n             }\n         }\n         PatMac(ref macro) => visitor.visit_mac(macro, env),\n@@ -486,11 +488,11 @@ pub fn walk_foreign_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     visitor.visit_ident(foreign_item.span, foreign_item.ident, env.clone());\n \n     match foreign_item.node {\n-        ForeignItemFn(function_declaration, ref generics) => {\n-            walk_fn_decl(visitor, function_declaration, env.clone());\n+        ForeignItemFn(ref function_declaration, ref generics) => {\n+            walk_fn_decl(visitor, &**function_declaration, env.clone());\n             visitor.visit_generics(generics, env.clone())\n         }\n-        ForeignItemStatic(typ, _) => visitor.visit_ty(typ, env.clone()),\n+        ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ, env.clone()),\n     }\n \n     for attr in foreign_item.attrs.iter() {\n@@ -509,9 +511,9 @@ pub fn walk_ty_param_bounds<E: Clone, V: Visitor<E>>(visitor: &mut V,\n             StaticRegionTyParamBound => {}\n             UnboxedFnTyParamBound(ref function_declaration) => {\n                 for argument in function_declaration.decl.inputs.iter() {\n-                    visitor.visit_ty(argument.ty, env.clone())\n+                    visitor.visit_ty(&*argument.ty, env.clone())\n                 }\n-                visitor.visit_ty(function_declaration.decl.output,\n+                visitor.visit_ty(&*function_declaration.decl.output,\n                                  env.clone());\n             }\n             OtherRegionTyParamBound(..) => {}\n@@ -525,7 +527,7 @@ pub fn walk_generics<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     for type_parameter in generics.ty_params.iter() {\n         walk_ty_param_bounds(visitor, &type_parameter.bounds, env.clone());\n         match type_parameter.default {\n-            Some(ty) => visitor.visit_ty(ty, env.clone()),\n+            Some(ref ty) => visitor.visit_ty(&**ty, env.clone()),\n             None => {}\n         }\n     }\n@@ -536,10 +538,10 @@ pub fn walk_fn_decl<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                              function_declaration: &FnDecl,\n                                              env: E) {\n     for argument in function_declaration.inputs.iter() {\n-        visitor.visit_pat(argument.pat, env.clone());\n-        visitor.visit_ty(argument.ty, env.clone())\n+        visitor.visit_pat(&*argument.pat, env.clone());\n+        visitor.visit_ty(&*argument.ty, env.clone())\n     }\n-    visitor.visit_ty(function_declaration.output, env)\n+    visitor.visit_ty(&*function_declaration.output, env)\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n@@ -551,8 +553,8 @@ pub fn walk_method_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    env: E) {\n     visitor.visit_ident(method.span, method.ident, env.clone());\n     visitor.visit_fn(&FkMethod(method.ident, &method.generics, method),\n-                     method.decl,\n-                     method.body,\n+                     &*method.decl,\n+                     &*method.body,\n                      method.span,\n                      method.id,\n                      env.clone());\n@@ -590,10 +592,10 @@ pub fn walk_ty_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     visitor.visit_ident(method_type.span, method_type.ident, env.clone());\n     visitor.visit_explicit_self(&method_type.explicit_self, env.clone());\n     for argument_type in method_type.decl.inputs.iter() {\n-        visitor.visit_ty(argument_type.ty, env.clone())\n+        visitor.visit_ty(&*argument_type.ty, env.clone())\n     }\n     visitor.visit_generics(&method_type.generics, env.clone());\n-    visitor.visit_ty(method_type.decl.output, env.clone());\n+    visitor.visit_ty(&*method_type.decl.output, env.clone());\n     for attr in method_type.attrs.iter() {\n         visitor.visit_attribute(attr, env.clone());\n     }\n@@ -606,15 +608,15 @@ pub fn walk_trait_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         Required(ref method_type) => {\n             visitor.visit_ty_method(method_type, env)\n         }\n-        Provided(method) => walk_method_helper(visitor, method, env),\n+        Provided(ref method) => walk_method_helper(visitor, &**method, env),\n     }\n }\n \n pub fn walk_struct_def<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                 struct_definition: &StructDef,\n                                                 env: E) {\n     match struct_definition.super_struct {\n-        Some(t) => visitor.visit_ty(t, env.clone()),\n+        Some(ref t) => visitor.visit_ty(&**t, env.clone()),\n         None => {},\n     }\n     for field in struct_definition.fields.iter() {\n@@ -632,7 +634,7 @@ pub fn walk_struct_field<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         _ => {}\n     }\n \n-    visitor.visit_ty(struct_field.node.ty, env.clone());\n+    visitor.visit_ty(&*struct_field.node.ty, env.clone());\n \n     for attr in struct_field.node.attrs.iter() {\n         visitor.visit_attribute(attr, env.clone());\n@@ -644,42 +646,42 @@ pub fn walk_block<E: Clone, V: Visitor<E>>(visitor: &mut V, block: &Block, env:\n         visitor.visit_view_item(view_item, env.clone())\n     }\n     for statement in block.stmts.iter() {\n-        visitor.visit_stmt(*statement, env.clone())\n+        visitor.visit_stmt(&**statement, env.clone())\n     }\n     walk_expr_opt(visitor, block.expr, env)\n }\n \n pub fn walk_stmt<E: Clone, V: Visitor<E>>(visitor: &mut V, statement: &Stmt, env: E) {\n     match statement.node {\n-        StmtDecl(declaration, _) => visitor.visit_decl(declaration, env),\n-        StmtExpr(expression, _) | StmtSemi(expression, _) => {\n-            visitor.visit_expr(expression, env)\n+        StmtDecl(ref declaration, _) => visitor.visit_decl(&**declaration, env),\n+        StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n+            visitor.visit_expr(&**expression, env)\n         }\n         StmtMac(ref macro, _) => visitor.visit_mac(macro, env),\n     }\n }\n \n pub fn walk_decl<E: Clone, V: Visitor<E>>(visitor: &mut V, declaration: &Decl, env: E) {\n     match declaration.node {\n-        DeclLocal(ref local) => visitor.visit_local(*local, env),\n-        DeclItem(item) => visitor.visit_item(item, env),\n+        DeclLocal(ref local) => visitor.visit_local(&**local, env),\n+        DeclItem(ref item) => visitor.visit_item(&**item, env),\n     }\n }\n \n pub fn walk_expr_opt<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                              optional_expression: Option<@Expr>,\n+                                              optional_expression: Option<Gc<Expr>>,\n                                               env: E) {\n     match optional_expression {\n         None => {}\n-        Some(expression) => visitor.visit_expr(expression, env),\n+        Some(ref expression) => visitor.visit_expr(&**expression, env),\n     }\n }\n \n pub fn walk_exprs<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                           expressions: &[@Expr],\n+                                           expressions: &[Gc<Expr>],\n                                            env: E) {\n     for expression in expressions.iter() {\n-        visitor.visit_expr(*expression, env.clone())\n+        visitor.visit_expr(&**expression, env.clone())\n     }\n }\n \n@@ -689,111 +691,111 @@ pub fn walk_mac<E, V: Visitor<E>>(_: &mut V, _: &Mac, _: E) {\n \n pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, env: E) {\n     match expression.node {\n-        ExprVstore(subexpression, _) => {\n-            visitor.visit_expr(subexpression, env.clone())\n+        ExprVstore(ref subexpression, _) => {\n+            visitor.visit_expr(&**subexpression, env.clone())\n         }\n-        ExprBox(place, subexpression) => {\n-            visitor.visit_expr(place, env.clone());\n-            visitor.visit_expr(subexpression, env.clone())\n+        ExprBox(ref place, ref subexpression) => {\n+            visitor.visit_expr(&**place, env.clone());\n+            visitor.visit_expr(&**subexpression, env.clone())\n         }\n         ExprVec(ref subexpressions) => {\n             walk_exprs(visitor, subexpressions.as_slice(), env.clone())\n         }\n-        ExprRepeat(element, count) => {\n-            visitor.visit_expr(element, env.clone());\n-            visitor.visit_expr(count, env.clone())\n+        ExprRepeat(ref element, ref count) => {\n+            visitor.visit_expr(&**element, env.clone());\n+            visitor.visit_expr(&**count, env.clone())\n         }\n         ExprStruct(ref path, ref fields, optional_base) => {\n             visitor.visit_path(path, expression.id, env.clone());\n             for field in fields.iter() {\n-                visitor.visit_expr(field.expr, env.clone())\n+                visitor.visit_expr(&*field.expr, env.clone())\n             }\n             walk_expr_opt(visitor, optional_base, env.clone())\n         }\n         ExprTup(ref subexpressions) => {\n             for subexpression in subexpressions.iter() {\n-                visitor.visit_expr(*subexpression, env.clone())\n+                visitor.visit_expr(&**subexpression, env.clone())\n             }\n         }\n-        ExprCall(callee_expression, ref arguments) => {\n+        ExprCall(ref callee_expression, ref arguments) => {\n             for argument in arguments.iter() {\n-                visitor.visit_expr(*argument, env.clone())\n+                visitor.visit_expr(&**argument, env.clone())\n             }\n-            visitor.visit_expr(callee_expression, env.clone())\n+            visitor.visit_expr(&**callee_expression, env.clone())\n         }\n         ExprMethodCall(_, ref types, ref arguments) => {\n             walk_exprs(visitor, arguments.as_slice(), env.clone());\n-            for &typ in types.iter() {\n-                visitor.visit_ty(typ, env.clone())\n+            for typ in types.iter() {\n+                visitor.visit_ty(&**typ, env.clone())\n             }\n         }\n-        ExprBinary(_, left_expression, right_expression) => {\n-            visitor.visit_expr(left_expression, env.clone());\n-            visitor.visit_expr(right_expression, env.clone())\n+        ExprBinary(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(&**left_expression, env.clone());\n+            visitor.visit_expr(&**right_expression, env.clone())\n         }\n-        ExprAddrOf(_, subexpression) | ExprUnary(_, subexpression) => {\n-            visitor.visit_expr(subexpression, env.clone())\n+        ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n+            visitor.visit_expr(&**subexpression, env.clone())\n         }\n         ExprLit(_) => {}\n-        ExprCast(subexpression, typ) => {\n-            visitor.visit_expr(subexpression, env.clone());\n-            visitor.visit_ty(typ, env.clone())\n+        ExprCast(ref subexpression, ref typ) => {\n+            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_ty(&**typ, env.clone())\n         }\n-        ExprIf(head_expression, if_block, optional_else) => {\n-            visitor.visit_expr(head_expression, env.clone());\n-            visitor.visit_block(if_block, env.clone());\n+        ExprIf(ref head_expression, ref if_block, optional_else) => {\n+            visitor.visit_expr(&**head_expression, env.clone());\n+            visitor.visit_block(&**if_block, env.clone());\n             walk_expr_opt(visitor, optional_else, env.clone())\n         }\n-        ExprWhile(subexpression, block) => {\n-            visitor.visit_expr(subexpression, env.clone());\n-            visitor.visit_block(block, env.clone())\n+        ExprWhile(ref subexpression, ref block) => {\n+            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_block(&**block, env.clone())\n         }\n-        ExprForLoop(pattern, subexpression, block, _) => {\n-            visitor.visit_pat(pattern, env.clone());\n-            visitor.visit_expr(subexpression, env.clone());\n-            visitor.visit_block(block, env.clone())\n+        ExprForLoop(ref pattern, ref subexpression, ref block, _) => {\n+            visitor.visit_pat(&**pattern, env.clone());\n+            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_block(&**block, env.clone())\n         }\n-        ExprLoop(block, _) => visitor.visit_block(block, env.clone()),\n-        ExprMatch(subexpression, ref arms) => {\n-            visitor.visit_expr(subexpression, env.clone());\n+        ExprLoop(ref block, _) => visitor.visit_block(&**block, env.clone()),\n+        ExprMatch(ref subexpression, ref arms) => {\n+            visitor.visit_expr(&**subexpression, env.clone());\n             for arm in arms.iter() {\n                 visitor.visit_arm(arm, env.clone())\n             }\n         }\n-        ExprFnBlock(function_declaration, body) => {\n+        ExprFnBlock(ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n-                             function_declaration,\n-                             body,\n+                             &**function_declaration,\n+                             &**body,\n                              expression.span,\n                              expression.id,\n                              env.clone())\n         }\n-        ExprProc(function_declaration, body) => {\n+        ExprProc(ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n-                             function_declaration,\n-                             body,\n+                             &**function_declaration,\n+                             &**body,\n                              expression.span,\n                              expression.id,\n                              env.clone())\n         }\n-        ExprBlock(block) => visitor.visit_block(block, env.clone()),\n-        ExprAssign(left_hand_expression, right_hand_expression) => {\n-            visitor.visit_expr(right_hand_expression, env.clone());\n-            visitor.visit_expr(left_hand_expression, env.clone())\n+        ExprBlock(ref block) => visitor.visit_block(&**block, env.clone()),\n+        ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n+            visitor.visit_expr(&**right_hand_expression, env.clone());\n+            visitor.visit_expr(&**left_hand_expression, env.clone())\n         }\n-        ExprAssignOp(_, left_expression, right_expression) => {\n-            visitor.visit_expr(right_expression, env.clone());\n-            visitor.visit_expr(left_expression, env.clone())\n+        ExprAssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(&**right_expression, env.clone());\n+            visitor.visit_expr(&**left_expression, env.clone())\n         }\n-        ExprField(subexpression, _, ref types) => {\n-            visitor.visit_expr(subexpression, env.clone());\n-            for &typ in types.iter() {\n-                visitor.visit_ty(typ, env.clone())\n+        ExprField(ref subexpression, _, ref types) => {\n+            visitor.visit_expr(&**subexpression, env.clone());\n+            for typ in types.iter() {\n+                visitor.visit_ty(&**typ, env.clone())\n             }\n         }\n-        ExprIndex(main_expression, index_expression) => {\n-            visitor.visit_expr(main_expression, env.clone());\n-            visitor.visit_expr(index_expression, env.clone())\n+        ExprIndex(ref main_expression, ref index_expression) => {\n+            visitor.visit_expr(&**main_expression, env.clone());\n+            visitor.visit_expr(&**index_expression, env.clone())\n         }\n         ExprPath(ref path) => {\n             visitor.visit_path(path, expression.id, env.clone())\n@@ -803,15 +805,15 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n             walk_expr_opt(visitor, optional_expression, env.clone())\n         }\n         ExprMac(ref macro) => visitor.visit_mac(macro, env.clone()),\n-        ExprParen(subexpression) => {\n-            visitor.visit_expr(subexpression, env.clone())\n+        ExprParen(ref subexpression) => {\n+            visitor.visit_expr(&**subexpression, env.clone())\n         }\n         ExprInlineAsm(ref assembler) => {\n-            for &(_, input) in assembler.inputs.iter() {\n-                visitor.visit_expr(input, env.clone())\n+            for &(_, ref input) in assembler.inputs.iter() {\n+                visitor.visit_expr(&**input, env.clone())\n             }\n-            for &(_, output) in assembler.outputs.iter() {\n-                visitor.visit_expr(output, env.clone())\n+            for &(_, ref output) in assembler.outputs.iter() {\n+                visitor.visit_expr(&**output, env.clone())\n             }\n         }\n     }\n@@ -821,10 +823,10 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n \n pub fn walk_arm<E: Clone, V: Visitor<E>>(visitor: &mut V, arm: &Arm, env: E) {\n     for pattern in arm.pats.iter() {\n-        visitor.visit_pat(*pattern, env.clone())\n+        visitor.visit_pat(&**pattern, env.clone())\n     }\n     walk_expr_opt(visitor, arm.guard, env.clone());\n-    visitor.visit_expr(arm.body, env.clone());\n+    visitor.visit_expr(&*arm.body, env.clone());\n     for attr in arm.attrs.iter() {\n         visitor.visit_attribute(attr, env.clone());\n     }"}, {"sha": "7baa500ee0d3829b8b0275f71c0d2516dc299f7d", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -17,10 +17,11 @@ use time::precise_time_s;\n use std::os;\n use std::task;\n use std::vec;\n+use std::gc::Gc;\n \n #[deriving(Clone)]\n enum List<T> {\n-    Nil, Cons(T, @List<T>)\n+    Nil, Cons(T, Gc<List<T>>)\n }\n \n enum UniqueList {\n@@ -60,15 +61,15 @@ struct State {\n }\n \n struct r {\n-  _l: @nillist,\n+  _l: Gc<nillist>,\n }\n \n #[unsafe_destructor]\n impl Drop for r {\n     fn drop(&mut self) {}\n }\n \n-fn r(l: @nillist) -> r {\n+fn r(l: Gc<nillist>) -> r {\n     r {\n         _l: l\n     }\n@@ -84,21 +85,22 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n         let st = match st {\n           None => {\n             State {\n-                managed: @Nil,\n+                managed: box(GC) Nil,\n                 unique: box Nil,\n-                tuple: (@Nil, box Nil),\n-                vec: vec!(@Nil),\n-                res: r(@Nil)\n+                tuple: (box(GC) Nil, box Nil),\n+                vec: vec!(box(GC) Nil),\n+                res: r(box(GC) Nil)\n             }\n           }\n           Some(st) => {\n             State {\n-                managed: @Cons((), st.managed),\n-                unique: box Cons((), @*st.unique),\n-                tuple: (@Cons((), st.tuple.ref0().clone()),\n-                        box Cons((), @*st.tuple.ref1().clone())),\n-                vec: st.vec.clone().append(&[@Cons((), *st.vec.last().unwrap())]),\n-                res: r(@Cons((), st.res._l))\n+                managed: box(GC) Cons((), st.managed),\n+                unique: box Cons((), box(GC) *st.unique),\n+                tuple: (box(GC) Cons((), st.tuple.ref0().clone()),\n+                        box Cons((), box(GC) *st.tuple.ref1().clone())),\n+                vec: st.vec.clone().append(\n+                        &[box(GC) Cons((), *st.vec.last().unwrap())]),\n+                res: r(box(GC) Cons((), st.res._l))\n             }\n           }\n         };"}, {"sha": "2fb1d2ffc9d19db1cdd7d11eda1b3b3cf358a8ed", "filename": "src/test/compile-fail/terr-sorts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -19,7 +19,7 @@ type bar = @foo;\n \n fn want_foo(f: foo) {}\n fn have_bar(b: bar) {\n-    want_foo(b); //~ ERROR (expected struct foo but found @-ptr)\n+    want_foo(b); //~ ERROR (expected struct foo but found Gc-ptr)\n }\n \n fn main() {}"}, {"sha": "d07cee79fad0882fabcb52502178bbc4b6e8caa8", "filename": "src/test/run-pass/generic-recursive-tag.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME(#14193)\n+\n #![feature(managed_boxes)]\n \n enum list<T> { cons(@T, @list<T>), nil, }"}, {"sha": "a9067ef87ba31ce5587fa1be8710347ccee181d8", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME(#14193)\n+\n #![feature(managed_boxes)]\n \n // Test cyclic detector when using trait instances."}, {"sha": "f25dfcb94c591fbdc6f16b3eb7febab4beb7c918", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f9095f1daa3814c9589f38b574e51d394d1bbc/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=f0f9095f1daa3814c9589f38b574e51d394d1bbc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME(#14193)\n+\n #![feature(managed_boxes)]\n \n use std::cell::RefCell;"}]}