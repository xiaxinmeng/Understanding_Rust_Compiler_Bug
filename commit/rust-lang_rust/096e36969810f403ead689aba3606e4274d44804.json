{"sha": "096e36969810f403ead689aba3606e4274d44804", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NmUzNjk2OTgxMGY0MDNlYWQ2ODlhYmEzNjA2ZTQyNzRkNDQ4MDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-22T18:04:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-22T18:04:09Z"}, "message": "Merge #9675\n\n9675: internal: Move and clean up record completion tests r=Veykril a=Veykril\n\nNow all that's left are the expression related tests which will take some time to go through\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "8d584cde436b0d18191cdfd606a44976853abc28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d584cde436b0d18191cdfd606a44976853abc28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/096e36969810f403ead689aba3606e4274d44804", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg+bMZCRBK7hj4Ov3rIwAA4LkIAC0Fq3jFvvbt4NjAK8r85/Iz\nfuIs69L1jToK8NGyayeVDz/r6DGDR4NDEHFIsxJovzOtG6EiNSd7TPdqaPJUOVDI\nGTyKEciIJ55TUQ3QbN4SCsC2pf1jg2dzFN7mylAiG3hc0n3DWGMT9hMzNrOsZgOM\nPIAh1IemiYFp3W18OD3Dtnku/LMDvKlFgzZZvvAVgxz/nsFfxbPigmJRI7iYawcg\n3VWYTPnxwzBjoG87XRXwhaAO10bNFuul26gHH6NtBH9EWBJ5aXtk90eoB8HTbKmA\nAcTEKNMi/KpDlHQSQsXmS3H62A52qHdUn2oau4pw838lvPeeZwQ6DBn32pLh2d8=\n=KpQW\n-----END PGP SIGNATURE-----\n", "payload": "tree 8d584cde436b0d18191cdfd606a44976853abc28\nparent 444679f202742c8fd00e9d1c7fddfaa9a067e640\nparent d5947d9d487d15eea928ee687286651f6a98a4bf\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1626977049 +0000\ncommitter GitHub <noreply@github.com> 1626977049 +0000\n\nMerge #9675\n\n9675: internal: Move and clean up record completion tests r=Veykril a=Veykril\n\nNow all that's left are the expression related tests which will take some time to go through\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/096e36969810f403ead689aba3606e4274d44804", "html_url": "https://github.com/rust-lang/rust/commit/096e36969810f403ead689aba3606e4274d44804", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/096e36969810f403ead689aba3606e4274d44804/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "444679f202742c8fd00e9d1c7fddfaa9a067e640", "url": "https://api.github.com/repos/rust-lang/rust/commits/444679f202742c8fd00e9d1c7fddfaa9a067e640", "html_url": "https://github.com/rust-lang/rust/commit/444679f202742c8fd00e9d1c7fddfaa9a067e640"}, {"sha": "d5947d9d487d15eea928ee687286651f6a98a4bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5947d9d487d15eea928ee687286651f6a98a4bf", "html_url": "https://github.com/rust-lang/rust/commit/d5947d9d487d15eea928ee687286651f6a98a4bf"}], "stats": {"total": 561, "additions": 234, "deletions": 327}, "files": [{"sha": "c7cf5e3e4b14ca82c4d3af9da86774d504cd3bbf", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 29, "deletions": 277, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=096e36969810f403ead689aba3606e4274d44804", "patch": "@@ -47,322 +47,74 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n \n #[cfg(test)]\n mod tests {\n-    use expect_test::{expect, Expect};\n \n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Reference);\n-        expect.assert_eq(&actual);\n-    }\n-\n-    fn check_snippet(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Snippet);\n-        expect.assert_eq(&actual);\n-    }\n+    use crate::tests::check_edit;\n \n     #[test]\n-    fn test_record_literal_field_default() {\n-        let test_code = r#\"\n-//- minicore: default\n-struct S { foo: u32, bar: usize }\n-\n-impl Default for S {\n-    fn default() -> Self {\n-        S {\n-            foo: 0,\n-            bar: 0,\n-        }\n-    }\n-}\n-\n-fn process(f: S) {\n-    let other = S {\n-        foo: 5,\n-        .$0\n-    };\n-}\n-\"#;\n-        check(\n-            test_code,\n-            expect![[r#\"\n-                fd bar usize\n-            \"#]],\n-        );\n-\n-        check_snippet(\n-            test_code,\n-            expect![[r#\"\n-                fd ..Default::default()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_default_completion() {\n+    fn default_completion_edit() {\n         check_edit(\n             \"..Default::default()\",\n             r#\"\n //- minicore: default\n-struct S { foo: u32, bar: usize }\n+struct Struct { foo: u32, bar: usize }\n \n-impl Default for S {\n-    fn default() -> Self {\n-        S {\n-            foo: 0,\n-            bar: 0,\n-        }\n-    }\n+impl Default for Struct {\n+    fn default() -> Self {}\n }\n \n-fn process(f: S) {\n-    let other = S {\n+fn foo() {\n+    let other = Struct {\n         foo: 5,\n         .$0\n     };\n }\n \"#,\n             r#\"\n-struct S { foo: u32, bar: usize }\n+struct Struct { foo: u32, bar: usize }\n \n-impl Default for S {\n-    fn default() -> Self {\n-        S {\n-            foo: 0,\n-            bar: 0,\n-        }\n-    }\n+impl Default for Struct {\n+    fn default() -> Self {}\n }\n \n-fn process(f: S) {\n-    let other = S {\n+fn foo() {\n+    let other = Struct {\n         foo: 5,\n         ..Default::default()\n     };\n }\n \"#,\n         );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_without_default() {\n-        let test_code = r#\"\n-struct S { foo: u32, bar: usize }\n-\n-fn process(f: S) {\n-    let other = S {\n-        foo: 5,\n-        .$0\n-    };\n-}\n-\"#;\n-        check(\n-            test_code,\n-            expect![[r#\"\n-                fd bar usize\n-            \"#]],\n-        );\n-\n-        check_snippet(test_code, expect![[r#\"\"#]]);\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_field() {\n-        check(\n-            r#\"\n-struct S { foo: u32 }\n-\n-fn process(f: S) {\n-    match f {\n-        S { f$0: 92 } => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd foo u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_enum_variant() {\n-        check(\n-            r#\"\n-enum E { S { foo: u32, bar: () } }\n-\n-fn process(e: E) {\n-    match e {\n-        E::S { $0 } => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd foo u32\n-                fd bar ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_pattern_field_in_simple_macro() {\n-        check(\n-            r\"\n-macro_rules! m { ($e:expr) => { $e } }\n-struct S { foo: u32 }\n-\n-fn process(f: S) {\n-    m!(match f {\n-        S { f$0: 92 } => (),\n-    })\n-}\n-\",\n-            expect![[r#\"\n-                fd foo u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn only_missing_fields_are_completed_in_destruct_pats() {\n-        check(\n+        check_edit(\n+            \"..Default::default()\",\n             r#\"\n-struct S {\n-    foo1: u32, foo2: u32,\n-    bar: u32, baz: u32,\n-}\n+//- minicore: default\n+struct Struct { foo: u32, bar: usize }\n \n-fn main() {\n-    let s = S {\n-        foo1: 1, foo2: 2,\n-        bar: 3, baz: 4,\n-    };\n-    if let S { foo1, foo2: a, $0 } = s {}\n+impl Default for Struct {\n+    fn default() -> Self {}\n }\n-\"#,\n-            expect![[r#\"\n-                fd bar u32\n-                fd baz u32\n-            \"#]],\n-        );\n-    }\n \n-    #[test]\n-    fn test_record_literal_field() {\n-        check(\n-            r#\"\n-struct A { the_field: u32 }\n fn foo() {\n-   A { the$0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd the_field u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_enum_variant() {\n-        check(\n-            r#\"\n-enum E { A { a: u32 } }\n-fn foo() {\n-    let _ = E::A { $0 }\n+    let other = Struct {\n+        foo: 5,\n+        $0\n+    };\n }\n \"#,\n-            expect![[r#\"\n-                fd a u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_two_structs() {\n-        check(\n             r#\"\n-struct A { a: u32 }\n-struct B { b: u32 }\n+struct Struct { foo: u32, bar: usize }\n \n-fn foo() {\n-   let _: A = B { $0 }\n+impl Default for Struct {\n+    fn default() -> Self {}\n }\n-\"#,\n-            expect![[r#\"\n-                fd b u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_generic_struct() {\n-        check(\n-            r#\"\n-struct A<T> { a: T }\n \n fn foo() {\n-   let _: A<u32> = A { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd a u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_record_literal_field_in_simple_macro() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-struct A { the_field: u32 }\n-fn foo() {\n-   m!(A { the$0 })\n-}\n-\"#,\n-            expect![[r#\"\n-                fd the_field u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn only_missing_fields_are_completed() {\n-        check(\n-            r#\"\n-struct S {\n-    foo1: u32, foo2: u32,\n-    bar: u32, baz: u32,\n-}\n-\n-fn main() {\n-    let foo1 = 1;\n-    let s = S { foo1, foo2: 5, $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fd bar u32\n-                fd baz u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_functional_update() {\n-        check(\n-            r#\"\n-struct S { foo1: u32, foo2: u32 }\n-\n-fn main() {\n-    let foo1 = 1;\n-    let s = S { foo1, $0 .. loop {} }\n+    let other = Struct {\n+        foo: 5,\n+        ..Default::default()\n+    };\n }\n \"#,\n-            expect![[r#\"\n-                fd foo2 u32\n-            \"#]],\n         );\n     }\n }"}, {"sha": "6237a6ef1ef9ab8528a74fe9f2198212f973253e", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=096e36969810f403ead689aba3606e4274d44804", "patch": "@@ -108,10 +108,4 @@ mod tests {\n             \"#]],\n         );\n     }\n-\n-    #[test]\n-    fn should_not_complete_snippets_in_path() {\n-        check(r#\"fn foo(x: i32) { ::foo$0 }\"#, expect![[\"\"]]);\n-        check(r#\"fn foo(x: i32) { ::$0 }\"#, expect![[\"\"]]);\n-    }\n }"}, {"sha": "3713be0a17690dafaca00c785fe81b7a7256966e", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=096e36969810f403ead689aba3606e4274d44804", "patch": "@@ -299,29 +299,6 @@ mod tests {\n         expect.assert_eq(&actual)\n     }\n \n-    #[test]\n-    fn name_ref_function_type_const() {\n-        check(\n-            r#\"\n-trait Test {\n-    type TestType;\n-    const TEST_CONST: u16;\n-    fn test();\n-}\n-struct T;\n-\n-impl Test for T {\n-    t$0\n-}\n-\"#,\n-            expect![[\"\n-ta type TestType = \\n\\\n-ct const TEST_CONST: u16 = \\n\\\n-fn fn test()\n-\"]],\n-        );\n-    }\n-\n     #[test]\n     fn no_completion_inside_fn() {\n         check(\n@@ -572,27 +549,6 @@ impl Test for T {\n         );\n     }\n \n-    #[test]\n-    fn hide_implemented_fn() {\n-        check(\n-            r#\"\n-trait Test {\n-    fn foo();\n-    fn foo_bar();\n-}\n-struct T;\n-\n-impl Test for T {\n-    fn foo() {}\n-    fn f$0\n-}\n-\"#,\n-            expect![[r#\"\n-                fn fn foo_bar()\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn generic_fn() {\n         check_edit("}, {"sha": "cd812b617ea77eab3dc2ac1e3c0e5578b3c8ae75", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=096e36969810f403ead689aba3606e4274d44804", "patch": "@@ -3,13 +3,17 @@\n //! Most tests live in this module or its submodules unless for very specific completions like\n //! `attributes` or `lifetimes` where the completed concept is a distinct thing.\n //! Notable examples for completions that are being tested in this module's submodule are paths.\n+//! Another exception are `check_edit` tests which usually live in the completion modules themselves,\n+//! as the main purpose of this test module here is to give the developer an overview of whats being\n+//! completed where, not how.\n \n mod attribute;\n mod fn_param;\n mod item_list;\n mod item;\n mod pattern;\n mod predicate;\n+mod record;\n mod sourcegen;\n mod type_pos;\n mod use_tree;"}, {"sha": "1c1915ffbdf7f18741bf60218b44895842e8d0c3", "filename": "crates/ide_completion/src/tests/item_list.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=096e36969810f403ead689aba3606e4274d44804", "patch": "@@ -210,3 +210,40 @@ fn in_trait_assoc_item_list() {\n         \"##]],\n     );\n }\n+\n+#[test]\n+fn in_trait_impl_assoc_item_list() {\n+    check(\n+        r#\"\n+trait Test {\n+    type Type0;\n+    type Type1;\n+    const CONST0: ();\n+    const CONST1: ();\n+    fn function0();\n+    fn function1();\n+}\n+\n+impl Test for () {\n+    type Type0 = ();\n+    const CONST0: () = ();\n+    fn function0() {}\n+    $0\n+}\n+\"#,\n+        expect![[r##\"\n+            kw pub(crate)\n+            kw pub\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw self\n+            kw super\n+            kw crate\n+            md module\n+            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+        \"##]],\n+    );\n+}"}, {"sha": "db3e3153078d534bdb323959be0681d5ee47c52f", "filename": "crates/ide_completion/src/tests/record.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096e36969810f403ead689aba3606e4274d44804/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs?ref=096e36969810f403ead689aba3606e4274d44804", "patch": "@@ -0,0 +1,164 @@\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::completion_list;\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual);\n+}\n+\n+#[test]\n+fn with_default_impl() {\n+    check(\n+        r#\"\n+//- minicore: default\n+struct Struct { foo: u32, bar: usize }\n+\n+impl Default for Struct {\n+    fn default() -> Self {\n+        Struct {\n+            foo: 0,\n+            bar: 0,\n+        }\n+    }\n+}\n+\n+fn foo() {\n+    let other = Struct {\n+        foo: 5,\n+        $0\n+    };\n+}\n+\"#,\n+        expect![[r#\"\n+            fd ..Default::default()\n+            fd bar                  usize\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn without_default_impl() {\n+    check(\n+        r#\"\n+struct Struct { foo: u32, bar: usize }\n+\n+fn foo() {\n+    let other = Struct {\n+        foo: 5,\n+        $0\n+    };\n+}\n+\"#,\n+        expect![[r#\"\n+            fd bar usize\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn record_pattern_field() {\n+    check(\n+        r#\"\n+struct Struct { foo: u32, bar: u32 }\n+\n+fn foo(s: Struct) {\n+    match s {\n+        Struct { foo, $0: 92 } => (),\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            fd bar u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn pattern_enum_variant() {\n+    check(\n+        r#\"\n+enum Enum { Variant { foo: u32, bar: u32 } }\n+fn foo(e: Enum) {\n+    match e {\n+        Enum::Variant { foo, $0 } => (),\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            fd bar u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn record_literal_field_in_macro() {\n+    check(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct Struct { field: u32 }\n+fn foo() {\n+    m!(Struct { fie$0 })\n+}\n+\"#,\n+        expect![[r#\"\n+            fd field u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn record_pattern_field_in_macro() {\n+    check(\n+        r\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct Struct { field: u32 }\n+\n+fn foo(f: Struct) {\n+    m!(match f {\n+        Struct { f$0: 92 } => (),\n+    })\n+}\n+\",\n+        expect![[r#\"\n+            fd field u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn functional_update() {\n+    // FIXME: This should filter out all completions that do not have the type `Foo`\n+    check(\n+        r#\"\n+struct Foo { foo1: u32, foo2: u32 }\n+\n+fn main() {\n+    let thing = 1;\n+    let foo = Foo { foo1: 0, foo2: 0 };\n+    let foo2 = Foo { thing, ..$0 }\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            lc foo       Foo\n+            lc thing     i32\n+            st Foo\n+            fn main()    fn()\n+            bt u32\n+        \"#]],\n+    );\n+}"}]}