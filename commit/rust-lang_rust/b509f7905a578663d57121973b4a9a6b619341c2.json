{"sha": "b509f7905a578663d57121973b4a9a6b619341c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MDlmNzkwNWE1Nzg2NjNkNTcxMjE5NzNiNGE5YTZiNjE5MzQxYzI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-06T20:21:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-09T18:21:47Z"}, "message": "Implement io::native::file", "tree": {"sha": "3e151c04cdd30ccff2bb3698d5f60f1cf184ca7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e151c04cdd30ccff2bb3698d5f60f1cf184ca7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b509f7905a578663d57121973b4a9a6b619341c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b509f7905a578663d57121973b4a9a6b619341c2", "html_url": "https://github.com/rust-lang/rust/commit/b509f7905a578663d57121973b4a9a6b619341c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b509f7905a578663d57121973b4a9a6b619341c2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fd7f852e131ad8c9935fd9577c071be5b4635ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd7f852e131ad8c9935fd9577c071be5b4635ec", "html_url": "https://github.com/rust-lang/rust/commit/4fd7f852e131ad8c9935fd9577c071be5b4635ec"}], "stats": {"total": 255, "additions": 230, "deletions": 25}, "files": [{"sha": "f0dd63a32244cdd1d7620f6dad54e147510e9964", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 230, "deletions": 25, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/b509f7905a578663d57121973b4a9a6b619341c2/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b509f7905a578663d57121973b4a9a6b619341c2/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=b509f7905a578663d57121973b4a9a6b619341c2", "patch": "@@ -10,68 +10,273 @@\n \n //! Blocking posix-based file I/O\n \n+#[allow(non_camel_case_types)];\n+\n+use libc;\n+use os;\n use prelude::*;\n use super::super::*;\n-use libc::{c_int, FILE};\n \n-#[allow(non_camel_case_types)]\n-pub type fd_t = c_int;\n+fn raise_error() {\n+    // XXX: this should probably be a bit more descriptive...\n+    let (kind, desc) = match os::errno() as i32 {\n+        libc::EOF => (EndOfFile, \"end of file\"),\n+        _ => (OtherIoError, \"unknown error\"),\n+    };\n+\n+    io_error::cond.raise(IoError {\n+        kind: kind,\n+        desc: desc,\n+        detail: Some(os::last_os_error())\n+    });\n+}\n+\n+fn keep_going(data: &[u8], f: &fn(*u8, uint) -> i64) -> i64 {\n+    #[cfg(windows)] static eintr: int = 0; // doesn't matter\n+    #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n+\n+    let (data, origamt) = do data.as_imm_buf |data, amt| { (data, amt) };\n+    let mut data = data;\n+    let mut amt = origamt;\n+    while amt > 0 {\n+        let mut ret;\n+        loop {\n+            ret = f(data, amt);\n+            if cfg!(not(windows)) { break } // windows has no eintr\n+            // if we get an eintr, then try again\n+            if ret != -1 || os::errno() as int != eintr { break }\n+        }\n+        if ret == 0 {\n+            break\n+        } else if ret != -1 {\n+            amt -= ret as uint;\n+            data = unsafe { data.offset(ret as int) };\n+        } else {\n+            return ret;\n+        }\n+    }\n+    return (origamt - amt) as i64;\n+}\n+\n+pub type fd_t = libc::c_int;\n \n pub struct FileDesc {\n-    priv fd: fd_t\n+    priv fd: fd_t,\n }\n \n impl FileDesc {\n     /// Create a `FileDesc` from an open C file descriptor.\n     ///\n-    /// The `FileDesc` takes ownership of the file descriptor\n-    /// and will close it upon destruction.\n-    pub fn new(_fd: fd_t) -> FileDesc { fail2!() }\n+    /// The `FileDesc` will take ownership of the specified file descriptor and\n+    /// close it upon destruction.\n+    ///\n+    /// Note that all I/O operations done on this object will be *blocking*, but\n+    /// they do not require the runtime to be active.\n+    pub fn new(fd: fd_t) -> FileDesc {\n+        FileDesc { fd: fd }\n+    }\n }\n \n impl Reader for FileDesc {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        #[cfg(windows)] type rlen = libc::c_uint;\n+        #[cfg(not(windows))] type rlen = libc::size_t;\n+        let ret = do keep_going(buf) |buf, len| {\n+            unsafe {\n+                libc::read(self.fd, buf as *mut libc::c_void, len as rlen) as i64\n+            }\n+        };\n+        if ret == 0 {\n+            None\n+        } else if ret < 0 {\n+            raise_error();\n+            None\n+        } else {\n+            Some(ret as uint)\n+        }\n+    }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { false }\n }\n \n impl Writer for FileDesc {\n-    fn write(&mut self, _buf: &[u8]) { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn write(&mut self, buf: &[u8]) {\n+        #[cfg(windows)] type wlen = libc::c_uint;\n+        #[cfg(not(windows))] type wlen = libc::size_t;\n+        let ret = do keep_going(buf) |buf, len| {\n+            unsafe {\n+                libc::write(self.fd, buf as *libc::c_void, len as wlen) as i64\n+            }\n+        };\n+        if ret < 0 {\n+            raise_error();\n+        }\n+    }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) {}\n }\n \n-impl Seek for FileDesc {\n-    fn tell(&self) -> u64 { fail2!() }\n-\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n+impl Drop for FileDesc {\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn drop(&mut self) {\n+        unsafe { libc::close(self.fd); }\n+    }\n }\n \n pub struct CFile {\n-    priv file: *FILE\n+    priv file: *libc::FILE\n }\n \n impl CFile {\n     /// Create a `CFile` from an open `FILE` pointer.\n     ///\n-    /// The `CFile` takes ownership of the file descriptor\n-    /// and will close it upon destruction.\n-    pub fn new(_file: *FILE) -> CFile { fail2!() }\n+    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n+    /// destruction.\n+    pub fn new(file: *libc::FILE) -> CFile { CFile { file: file } }\n }\n \n impl Reader for CFile {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let ret = do keep_going(buf) |buf, len| {\n+            unsafe {\n+                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n+                            self.file) as i64\n+            }\n+        };\n+        if ret == 0 {\n+            None\n+        } else if ret < 0 {\n+            raise_error();\n+            None\n+        } else {\n+            Some(ret as uint)\n+        }\n+    }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn eof(&mut self) -> bool {\n+        unsafe { libc::feof(self.file) != 0 }\n+    }\n }\n \n impl Writer for CFile {\n-    fn write(&mut self, _buf: &[u8]) { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn write(&mut self, buf: &[u8]) {\n+        let ret = do keep_going(buf) |buf, len| {\n+            unsafe {\n+                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n+                            self.file) as i64\n+            }\n+        };\n+        if ret < 0 {\n+            raise_error();\n+        }\n+    }\n \n-    fn flush(&mut self) { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn flush(&mut self) {\n+        if unsafe { libc::fflush(self.file) } < 0 {\n+            raise_error();\n+        }\n+    }\n }\n \n impl Seek for CFile {\n-    fn tell(&self) -> u64 { fail2!() }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn tell(&self) -> u64 {\n+        let ret = unsafe { libc::ftell(self.file) };\n+        if ret < 0 {\n+            raise_error();\n+        }\n+        return ret as u64;\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        let whence = match style {\n+            SeekSet => libc::SEEK_SET,\n+            SeekEnd => libc::SEEK_END,\n+            SeekCur => libc::SEEK_CUR,\n+        };\n+        if unsafe { libc::fseek(self.file, pos as libc::c_long, whence) } < 0 {\n+            raise_error();\n+        }\n+    }\n+}\n+\n+impl Drop for CFile {\n+    #[fixed_stack_segment] #[inline(never)]\n+    fn drop(&mut self) {\n+        unsafe { libc::fclose(self.file); }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use libc;\n+    use os;\n+    use prelude::*;\n+    use rt::io::{io_error, SeekSet};\n+    use super::*;\n+\n+    #[test] #[fixed_stack_segment]\n+    fn test_file_desc() {\n+        // Run this test with some pipes so we don't have to mess around with\n+        // opening or closing files.\n+        unsafe {\n+            let os::Pipe { input, out } = os::pipe();\n+            let mut reader = FileDesc::new(input);\n+            let mut writer = FileDesc::new(out);\n+\n+            writer.write(bytes!(\"test\"));\n+            let mut buf = [0u8, ..4];\n+            match reader.read(buf) {\n+                Some(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail2!(\"invalid read: {:?}\", r)\n+            }\n+\n+            let mut raised = false;\n+            do io_error::cond.trap(|_| { raised = true; }).inside {\n+                writer.read(buf);\n+            }\n+            assert!(raised);\n+\n+            raised = false;\n+            do io_error::cond.trap(|_| { raised = true; }).inside {\n+                reader.write(buf);\n+            }\n+            assert!(raised);\n+        }\n+    }\n+\n+    #[test] #[fixed_stack_segment]\n+    #[ignore(windows)] // apparently windows doesn't like tmpfile\n+    fn test_cfile() {\n+        unsafe {\n+            let f = libc::tmpfile();\n+            assert!(!f.is_null());\n+            let mut file = CFile::new(f);\n+\n+            file.write(bytes!(\"test\"));\n+            let mut buf = [0u8, ..4];\n+            file.seek(0, SeekSet);\n+            match file.read(buf) {\n+                Some(4) => {\n+                    assert_eq!(buf[0], 't' as u8);\n+                    assert_eq!(buf[1], 'e' as u8);\n+                    assert_eq!(buf[2], 's' as u8);\n+                    assert_eq!(buf[3], 't' as u8);\n+                }\n+                r => fail2!(\"invalid read: {:?}\", r)\n+            }\n+        }\n+    }\n }"}]}