{"sha": "164f7a290ef98377e4c8c158eca2fbed098a2842", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NGY3YTI5MGVmOTgzNzdlNGM4YzE1OGVjYTJmYmVkMDk4YTI4NDI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-15T12:35:12Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-15T12:37:41Z"}, "message": "std::vec: convert to(_mut)_ptr to as_... methods on &[] and &mut [].", "tree": {"sha": "d9b2239b59f5d18bb680429595192fc64fdad6eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9b2239b59f5d18bb680429595192fc64fdad6eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/164f7a290ef98377e4c8c158eca2fbed098a2842", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/164f7a290ef98377e4c8c158eca2fbed098a2842", "html_url": "https://github.com/rust-lang/rust/commit/164f7a290ef98377e4c8c158eca2fbed098a2842", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/164f7a290ef98377e4c8c158eca2fbed098a2842/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f53292f7ee7365fe50ac216efac438ff5569fd06", "url": "https://api.github.com/repos/rust-lang/rust/commits/f53292f7ee7365fe50ac216efac438ff5569fd06", "html_url": "https://github.com/rust-lang/rust/commit/f53292f7ee7365fe50ac216efac438ff5569fd06"}], "stats": {"total": 228, "additions": 115, "deletions": 113}, "files": [{"sha": "088970bf00d2829c5fb6c44f173d1aeca7ac87f7", "filename": "doc/po/ja/tutorial-ffi.md.po", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -168,7 +168,7 @@ msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n \"pub fn validate_compressed_buffer(src: &[u8]) -> bool {\\n\"\n \"    unsafe {\\n\"\n-\"        snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\\n\"\n+\"        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\\n\"\n \"    }\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n@@ -207,7 +207,7 @@ msgid \"\"\n \"pub fn compress(src: &[u8]) -> ~[u8] {\\n\"\n \"    unsafe {\\n\"\n \"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = vec::raw::to_ptr(src);\\n\"\n+\"        let psrc = src.as_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -216,7 +216,7 @@ msgstr \"\"\n msgid \"\"\n \"        let mut dstlen = snappy_max_compressed_length(srclen);\\n\"\n \"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = vec::raw::to_mut_ptr(dst);\\n\"\n+\"        let pdst = dst.as_mut_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -247,7 +247,7 @@ msgid \"\"\n \"pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\\n\"\n \"    unsafe {\\n\"\n \"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = vec::raw::to_ptr(src);\\n\"\n+\"        let psrc = src.as_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -263,7 +263,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = vec::raw::to_mut_ptr(dst);\\n\"\n+\"        let pdst = dst.as_mut_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text"}, {"sha": "670e9f32fe65fc988f3f2c750cd0234c91349ad0", "filename": "doc/po/tutorial-ffi.md.pot", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/doc%2Fpo%2Ftutorial-ffi.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/doc%2Fpo%2Ftutorial-ffi.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-ffi.md.pot?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -168,7 +168,7 @@ msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n \"pub fn validate_compressed_buffer(src: &[u8]) -> bool {\\n\"\n \"    unsafe {\\n\"\n-\"        snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\\n\"\n+\"        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\\n\"\n \"    }\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n@@ -207,7 +207,7 @@ msgid \"\"\n \"pub fn compress(src: &[u8]) -> ~[u8] {\\n\"\n \"    unsafe {\\n\"\n \"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = vec::raw::to_ptr(src);\\n\"\n+\"        let psrc = src.as_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -216,7 +216,7 @@ msgstr \"\"\n msgid \"\"\n \"        let mut dstlen = snappy_max_compressed_length(srclen);\\n\"\n \"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = vec::raw::to_mut_ptr(dst);\\n\"\n+\"        let pdst = dst.as_mut_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -247,7 +247,7 @@ msgid \"\"\n \"pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\\n\"\n \"    unsafe {\\n\"\n \"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = vec::raw::to_ptr(src);\\n\"\n+\"        let psrc = src.as_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -263,7 +263,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = vec::raw::to_mut_ptr(dst);\\n\"\n+\"        let pdst = dst.as_mut_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text"}, {"sha": "39eff68afd1f6ee76f7a1c7383510a3e38c597be", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -79,7 +79,7 @@ the allocated memory. The length is less than or equal to the capacity.\n ~~~~ {.xfail-test}\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n-        snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\n+        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n     }\n }\n ~~~~\n@@ -100,11 +100,11 @@ the true length after compression for setting the length.\n pub fn compress(src: &[u8]) -> ~[u8] {\n     unsafe {\n         let srclen = src.len() as size_t;\n-        let psrc = vec::raw::to_ptr(src);\n+        let psrc = src.as_ptr();\n \n         let mut dstlen = snappy_max_compressed_length(srclen);\n         let mut dst = vec::with_capacity(dstlen as uint);\n-        let pdst = vec::raw::to_mut_ptr(dst);\n+        let pdst = dst.as_mut_ptr();\n \n         snappy_compress(psrc, srclen, pdst, &mut dstlen);\n         dst.set_len(dstlen as uint);\n@@ -120,13 +120,13 @@ format and `snappy_uncompressed_length` will retrieve the exact buffer size requ\n pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n     unsafe {\n         let srclen = src.len() as size_t;\n-        let psrc = vec::raw::to_ptr(src);\n+        let psrc = src.as_ptr();\n \n         let mut dstlen: size_t = 0;\n         snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n \n         let mut dst = vec::with_capacity(dstlen as uint);\n-        let pdst = vec::raw::to_mut_ptr(dst);\n+        let pdst = dst.as_mut_ptr();\n \n         if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n             dst.set_len(dstlen as uint);"}, {"sha": "dc5f3b5d3cfd4b884950f9e24f87c57a13a2833c", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -44,7 +44,6 @@ use std::num;\n use std::ptr;\n use std::mem;\n use std::uint;\n-use std::vec;\n use std::unstable::intrinsics;\n use std::unstable::intrinsics::{TyDesc, get_tydesc};\n \n@@ -115,7 +114,7 @@ fn round_up_to(base: uint, align: uint) -> uint {\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n     let mut idx = 0;\n-    let buf = vec::raw::to_ptr(chunk.data);\n+    let buf = chunk.data.as_ptr();\n     let fill = chunk.fill;\n \n     while idx < fill {\n@@ -179,7 +178,7 @@ impl Arena {\n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n-            ptr::offset(vec::raw::to_ptr(this.pod_head.data), start as int)\n+            ptr::offset(this.pod_head.data.as_ptr(), start as int)\n         }\n     }\n \n@@ -235,7 +234,7 @@ impl Arena {\n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n-            let buf = vec::raw::to_ptr(self.head.data);\n+            let buf = self.head.data.as_ptr();\n             return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n         }\n     }"}, {"sha": "65ff67975a2f533d5141051e7864670d90b4df0e", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -16,7 +16,6 @@ use metadata::cstore;\n use util::common::time;\n \n use std::libc;\n-use std::vec;\n \n pub fn run(sess: session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[~str]) {\n@@ -48,7 +47,7 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n         debug!(\"reading {}\", name);\n         let bc = time(sess.time_passes(), format!(\"read {}.bc\", name), (), |_|\n                       archive.read(format!(\"{}.bc\", name)));\n-        let ptr = vec::raw::to_ptr(bc);\n+        let ptr = bc.as_ptr();\n         debug!(\"linking {}\", name);\n         time(sess.time_passes(), format!(\"ll link {}\", name), (), |()| unsafe {\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n@@ -62,7 +61,7 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n     // Internalize everything but the reachable symbols of the current module\n     let cstrs = reachable.map(|s| s.to_c_str());\n     let arr = cstrs.map(|c| c.with_ref(|p| p));\n-    let ptr = vec::raw::to_ptr(arr);\n+    let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod, ptr as **libc::c_char,\n                                          arr.len() as libc::size_t);"}, {"sha": "863c567a21651e4ed5b36f0b32e1249dac08cbf6", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -20,7 +20,6 @@ use middle::trans::type_::Type;\n use std::cast;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_char};\n-use std::vec;\n use syntax::codemap::Span;\n use std::ptr::is_not_null;\n \n@@ -118,7 +117,7 @@ impl Builder {\n     pub fn aggregate_ret(&self, ret_vals: &[ValueRef]) {\n         unsafe {\n             llvm::LLVMBuildAggregateRet(self.llbuilder,\n-                                        vec::raw::to_ptr(ret_vals),\n+                                        ret_vals.as_ptr(),\n                                         ret_vals.len() as c_uint);\n         }\n     }\n@@ -161,7 +160,7 @@ impl Builder {\n         unsafe {\n             let v = llvm::LLVMBuildInvoke(self.llbuilder,\n                                           llfn,\n-                                          vec::raw::to_ptr(args),\n+                                          args.as_ptr(),\n                                           args.len() as c_uint,\n                                           then,\n                                           catch,\n@@ -500,7 +499,7 @@ impl Builder {\n     pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"gep\");\n         unsafe {\n-            llvm::LLVMBuildGEP(self.llbuilder, ptr, vec::raw::to_ptr(indices),\n+            llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n@@ -528,7 +527,7 @@ impl Builder {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n-                self.llbuilder, ptr, vec::raw::to_ptr(indices), indices.len() as c_uint, noname())\n+                self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n@@ -716,8 +715,8 @@ impl Builder {\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n         unsafe {\n-            llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n-                                  vec::raw::to_ptr(bbs),\n+            llvm::LLVMAddIncoming(phi, vals.as_ptr(),\n+                                  bbs.as_ptr(),\n                                   vals.len() as c_uint);\n             phi\n         }\n@@ -775,7 +774,7 @@ impl Builder {\n                 attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n         self.count_insn(\"call\");\n         unsafe {\n-            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, vec::raw::to_ptr(args),\n+            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, args.as_ptr(),\n                                         args.len() as c_uint, noname());\n             for &(idx, attr) in attributes.iter() {\n                 llvm::LLVMAddInstrAttribute(v, idx as c_uint, attr as c_uint);\n@@ -885,7 +884,7 @@ impl Builder {\n             let args: &[ValueRef] = [];\n             self.count_insn(\"trap\");\n             llvm::LLVMBuildCall(\n-                self.llbuilder, T, vec::raw::to_ptr(args), args.len() as c_uint, noname());\n+                self.llbuilder, T, args.as_ptr(), args.len() as c_uint, noname());\n         }\n     }\n "}, {"sha": "55617067db43733f0cc34c5d1904b64f1e822cf3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -946,7 +946,7 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n         let mut elts: ~[ValueRef] = ~[];\n         while i < size { elts.push(C_u8(0u)); i += 1u; }\n         return llvm::LLVMConstArray(Type::i8().to_ref(),\n-                                    vec::raw::to_ptr(elts), elts.len() as c_uint);\n+                                    elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n@@ -968,13 +968,13 @@ pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n \n pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstArray(ty.to_ref(), vec::raw::to_ptr(elts), elts.len() as c_uint);\n+        return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        let ptr = cast::transmute(vec::raw::to_ptr(bytes));\n+        let ptr = cast::transmute(bytes.as_ptr());\n         return llvm::LLVMConstStringInContext(base::task_llcx(), ptr, bytes.len() as c_uint, True);\n     }\n }"}, {"sha": "167b17ba95c6c26291136bd001a0a2a30026f28f", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -31,7 +31,6 @@ use util::sha2::Sha256;\n use std::c_str::ToCStr;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n-use std::vec;\n use std::libc::c_uint;\n use syntax::ast;\n \n@@ -261,7 +260,7 @@ impl CrateContext {\n             indices.iter().map(|i| C_i32(*i as i32)).collect();\n         unsafe {\n             llvm::LLVMConstInBoundsGEP(pointer,\n-                                       vec::raw::to_ptr(v),\n+                                       v.as_ptr(),\n                                        indices.len() as c_uint)\n         }\n     }"}, {"sha": "0f83e51cac8bc525758d5efa0a3b8da959aad1b7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -860,7 +860,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     return unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32)\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n     };\n }\n \n@@ -949,7 +949,7 @@ fn declare_local(bcx: @mut Block,\n                         file_metadata,\n                         loc.line as c_uint,\n                         type_metadata,\n-                        vec::raw::to_ptr(address_operations),\n+                        address_operations.as_ptr(),\n                         address_operations.len() as c_uint,\n                         argument_index)\n                 }\n@@ -2133,7 +2133,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n             let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n-                                                          vec::raw::to_ptr(elements),\n+                                                          elements.as_ptr(),\n                                                           elements.len() as c_uint);\n             }\n         }"}, {"sha": "8c5b55b73cda520b8f4574311fa308711b57d316", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -150,13 +150,13 @@ impl Type {\n \n     pub fn func(args: &[Type], ret: &Type) -> Type {\n         let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n-        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec::raw::to_ptr(vec),\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n                                    args.len() as c_uint, False))\n     }\n \n     pub fn variadic_func(args: &[Type], ret: &Type) -> Type {\n         let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n-        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec::raw::to_ptr(vec),\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n                                    args.len() as c_uint, True))\n     }\n \n@@ -170,7 +170,7 @@ impl Type {\n \n     pub fn struct_(els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { cast::transmute(els) };\n-        ty!(llvm::LLVMStructTypeInContext(base::task_llcx(), vec::raw::to_ptr(els),\n+        ty!(llvm::LLVMStructTypeInContext(base::task_llcx(), els.as_ptr(),\n                                           els.len() as c_uint, packed as Bool))\n     }\n \n@@ -297,7 +297,7 @@ impl Type {\n     pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n         unsafe {\n             let vec : &[TypeRef] = cast::transmute(els);\n-            llvm::LLVMStructSetBody(self.to_ref(), vec::raw::to_ptr(vec),\n+            llvm::LLVMStructSetBody(self.to_ref(), vec.as_ptr(),\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n@@ -311,7 +311,7 @@ impl Type {\n             let num_fields = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n             let mut elems = vec::from_elem(num_fields, 0 as TypeRef);\n \n-            llvm::LLVMGetStructElementTypes(self.to_ref(), vec::raw::to_mut_ptr(elems));\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), elems.as_mut_ptr());\n \n             Type::from_ref(elems[idx])\n         }\n@@ -355,7 +355,7 @@ impl Type {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n             let args = vec::from_elem(n_args, 0 as TypeRef);\n-            llvm::LLVMGetParamTypes(self.to_ref(), vec::raw::to_ptr(args));\n+            llvm::LLVMGetParamTypes(self.to_ref(), args.as_ptr());\n             cast::transmute(args)\n         }\n     }"}, {"sha": "3a8af71e019ef7b8d70b1a640d00be6f73b1ba28", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -20,7 +20,6 @@ use std::io;\n use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::sched::{Scheduler, SchedHandle};\n-use std::vec;\n \n use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after};\n use uvio::HomingIO;\n@@ -78,7 +77,7 @@ impl FsRequest {\n     {\n         execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_write(loop_.handle, req,\n-                              fd, vec::raw::to_ptr(buf) as *c_void,\n+                              fd, buf.as_ptr() as *c_void,\n                               buf.len() as size_t, offset, cb)\n         })\n     }\n@@ -88,7 +87,7 @@ impl FsRequest {\n     {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_read(loop_.handle, req,\n-                             fd, vec::raw::to_ptr(buf) as *c_void,\n+                             fd, buf.as_ptr() as *c_void,\n                              buf.len() as size_t, offset, cb)\n         }).map(|req| {\n             req.get_result() as int"}, {"sha": "d8bf356a099b4470019b121fb81194aa6f12725d", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -60,7 +60,6 @@ use std::str::raw::from_c_str;\n use std::str;\n use std::task;\n use std::unstable::finally::Finally;\n-use std::vec;\n \n use std::io::IoError;\n \n@@ -388,7 +387,7 @@ pub fn empty_buf() -> Buf {\n \n /// Borrow a slice to a Buf\n pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n-    let data = vec::raw::to_ptr(v);\n+    let data = v.as_ptr();\n     uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n }\n "}, {"sha": "6f1930bc7fe3143650a009d621da078f4d11c718", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -62,7 +62,7 @@ pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n             // apparently there's an off-by-one in libuv?\n             let ip_size = ip_size + 1;\n             let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n-            let buf_ptr = vec::raw::to_ptr(buf);\n+            let buf_ptr = buf.as_ptr();\n             let ret = if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n                 uvll::uv_ip4_name(addr, buf_ptr as *c_char, ip_size as size_t)\n             } else {"}, {"sha": "91be656334392effa4fe7ca370a3c9b609c3aa54", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -33,7 +33,6 @@ use std::libc::{size_t, c_int, c_uint, c_void, c_char, c_double};\n use std::libc::ssize_t;\n use std::libc::{malloc, free};\n use std::libc;\n-use std::vec;\n \n #[cfg(test)]\n use std::libc::uintptr_t;\n@@ -419,7 +418,7 @@ pub unsafe fn uv_write(req: *uv_write_t,\n                     cb: uv_write_cb) -> c_int;\n     }\n \n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_ptr = buf_in.as_ptr();\n     let buf_cnt = buf_in.len() as i32;\n     return uv_write(req, stream, buf_ptr, buf_cnt, cb);\n }\n@@ -435,7 +434,7 @@ pub unsafe fn uv_udp_send(req: *uv_udp_send_t,\n                        cb: uv_udp_send_cb) -> c_int;\n     }\n \n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_ptr = buf_in.as_ptr();\n     let buf_cnt = buf_in.len() as i32;\n     return uv_udp_send(req, handle, buf_ptr, buf_cnt, addr, cb);\n }"}, {"sha": "1ba6b7b50cabfcc71efe3f1a1c22181762c17afb", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -385,7 +385,7 @@ mod tests {\n     fn test_str_multistring_parsing() {\n         unsafe {\n             let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n-            let ptr = vec::raw::to_ptr(input);\n+            let ptr = input.as_ptr();\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n             let result = from_c_multistring(ptr as *libc::c_char, None, |c| {"}, {"sha": "bd618dd6f0f4af897a04bbec21a13684d740f1c1", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -133,7 +133,7 @@ impl rtio::RtioFileStream for FileDesc {\n         self.inner_write(buf)\n     }\n     fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        return os_pread(self.fd, vec::raw::to_ptr(buf), buf.len(), offset);\n+        return os_pread(self.fd, buf.as_ptr(), buf.len(), offset);\n \n         #[cfg(windows)]\n         fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n@@ -165,7 +165,7 @@ impl rtio::RtioFileStream for FileDesc {\n         }\n     }\n     fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        return os_pwrite(self.fd, vec::raw::to_ptr(buf), buf.len(), offset);\n+        return os_pwrite(self.fd, buf.as_ptr(), buf.len(), offset);\n \n         #[cfg(windows)]\n         fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n@@ -700,7 +700,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n         }\n         let mut buf = vec::with_capacity::<u8>(len as uint);\n         match unsafe {\n-            libc::readlink(p, vec::raw::to_ptr(buf) as *mut libc::c_char,\n+            libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n                            len as libc::size_t)\n         } {\n             -1 => Err(super::last_error()),"}, {"sha": "7abeb34a010a1c695f81d68aed46a77959b8daf8", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -358,13 +358,13 @@ pub fn self_exe_path() -> Option<Path> {\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n             let mut sz: size_t = 0;\n-            let err = sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n+            let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n                              ptr::mut_null(), &mut sz, ptr::null(), 0u as size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n             let err = v.as_mut_buf(|buf,_| {\n-                sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n+                sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n                        buf as *mut c_void, &mut sz, ptr::null(), 0u as size_t)\n             });\n             if err != 0 { return None; }"}, {"sha": "e2dda8267658914d0855471b9a23fc3fb74fe382", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -449,7 +449,7 @@ pub mod ptr_tests {\n     use cast;\n     use libc;\n     use str;\n-    use vec;\n+    use vec::{ImmutableVector, MutableVector};\n \n     #[test]\n     fn test() {\n@@ -474,15 +474,15 @@ pub mod ptr_tests {\n             let v0 = ~[32000u16, 32001u16, 32002u16];\n             let mut v1 = ~[0u16, 0u16, 0u16];\n \n-            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1),\n-                        offset(vec::raw::to_ptr(v0), 1), 1);\n+            copy_memory(mut_offset(v1.as_mut_ptr(), 1),\n+                        offset(v0.as_ptr(), 1), 1);\n             assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n-            copy_memory(vec::raw::to_mut_ptr(v1),\n-                        offset(vec::raw::to_ptr(v0), 2), 1);\n+            copy_memory(v1.as_mut_ptr(),\n+                        offset(v0.as_ptr(), 2), 1);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 0u16));\n-            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2),\n-                        vec::raw::to_ptr(v0), 1u);\n+            copy_memory(mut_offset(v1.as_mut_ptr(), 2),\n+                        v0.as_ptr(), 1u);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 32000u16));\n         }\n@@ -558,7 +558,7 @@ pub mod ptr_tests {\n \n         unsafe {\n             let xs = ~[5, ..16];\n-            let mut ptr = to_ptr(xs);\n+            let mut ptr = xs.as_ptr();\n             let end = ptr.offset(16);\n \n             while ptr < end {\n@@ -567,7 +567,7 @@ pub mod ptr_tests {\n             }\n \n             let mut xs_mut = xs.clone();\n-            let mut m_ptr = to_mut_ptr(xs_mut);\n+            let mut m_ptr = xs_mut.as_mut_ptr();\n             let m_end = m_ptr.offset(16);\n \n             while m_ptr < m_end {\n@@ -581,20 +581,18 @@ pub mod ptr_tests {\n \n     #[test]\n     fn test_ptr_subtraction() {\n-        use vec::raw::*;\n-\n         unsafe {\n             let xs = ~[0,1,2,3,4,5,6,7,8,9];\n             let mut idx = 9i8;\n-            let ptr = to_ptr(xs);\n+            let ptr = xs.as_ptr();\n \n             while idx >= 0i8 {\n                 assert_eq!(*(ptr.offset(idx as int)), idx as int);\n                 idx = idx - 1i8;\n             }\n \n             let mut xs_mut = xs.clone();\n-            let m_start = to_mut_ptr(xs_mut);\n+            let m_start = xs_mut.as_mut_ptr();\n             let mut m_ptr = m_start.offset(9);\n \n             while m_ptr >= m_start {\n@@ -700,7 +698,7 @@ pub mod ptr_tests {\n     #[test]\n     fn test_set_memory() {\n         let mut xs = [0u8, ..20];\n-        let ptr = vec::raw::to_mut_ptr(xs);\n+        let ptr = xs.as_mut_ptr();\n         unsafe { set_memory(ptr, 5u8, xs.len()); }\n         assert_eq!(xs, [5u8, ..20]);\n     }"}, {"sha": "38d7a683a702fc1537a10af814878eaf78ac8fcd", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -49,7 +49,7 @@ impl IsaacRng {\n         let mut rng = EMPTY;\n \n         unsafe {\n-            let ptr = raw::to_mut_ptr(rng.rsl);\n+            let ptr = rng.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n                 OSRng::new().fill_bytes(slice);\n@@ -254,7 +254,7 @@ impl Isaac64Rng {\n         let mut rng = EMPTY_64;\n \n         unsafe {\n-            let ptr = raw::to_mut_ptr(rng.rsl);\n+            let ptr = rng.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n                 OSRng::new().fill_bytes(slice);"}, {"sha": "44b60e955d2178043925d9a0c16a6348231be1e8", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -39,13 +39,13 @@ impl StackSegment {\n \n     /// Point to the low end of the allocated stack\n     pub fn start(&self) -> *uint {\n-        vec::raw::to_ptr(self.buf) as *uint\n+        self.buf.as_ptr() as *uint\n     }\n \n     /// Point one word beyond the high end of the allocated stack\n     pub fn end(&self) -> *uint {\n         unsafe {\n-            vec::raw::to_ptr(self.buf).offset(self.buf.len() as int) as *uint\n+            self.buf.as_ptr().offset(self.buf.len() as int) as *uint\n         }\n     }\n }"}, {"sha": "0c95f527acee3495522e854442836d630c6ac782", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -1139,7 +1139,7 @@ pub mod raw {\n     fn test_from_buf_len() {\n         unsafe {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-            let b = vec::raw::to_ptr(a);\n+            let b = a.as_ptr();\n             let c = from_buf_len(b, 3u);\n             assert_eq!(c, ~\"AAA\");\n         }\n@@ -3360,7 +3360,7 @@ mod tests {\n     fn test_raw_from_c_str() {\n         unsafe {\n             let a = ~[65, 65, 65, 65, 65, 65, 65, 0];\n-            let b = vec::raw::to_ptr(a);\n+            let b = a.as_ptr();\n             let c = raw::from_c_str(b);\n             assert_eq!(c, ~\"AAAAAAA\");\n         }"}, {"sha": "137a176ff41fa2a36fb8acddf2dfd3f79e3bf903", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164f7a290ef98377e4c8c158eca2fbed098a2842/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=164f7a290ef98377e4c8c158eca2fbed098a2842", "patch": "@@ -123,7 +123,6 @@ use unstable::finally::Finally;\n use unstable::intrinsics;\n use unstable::intrinsics::{get_tydesc, owns_managed};\n use unstable::raw::{Box, Repr, Slice, Vec};\n-use vec;\n use util;\n \n /**\n@@ -135,7 +134,7 @@ use util;\n pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        let p = raw::to_mut_ptr(v);\n+        let p = v.as_mut_ptr();\n         let mut i: uint = 0u;\n         (|| {\n             while i < n_elts {\n@@ -162,7 +161,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n     // vec::with_capacity/ptr::set_memory for primitive types.\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        let p = raw::to_mut_ptr(v);\n+        let p = v.as_mut_ptr();\n         let mut i = 0u;\n         (|| {\n             while i < n_elts {\n@@ -955,6 +954,17 @@ pub trait ImmutableVector<'a, T> {\n     /// bounds checking.\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n \n+    /**\n+     * Returns an unsafe pointer to the vector's buffer\n+     *\n+     * The caller must ensure that the vector outlives the pointer this\n+     * function returns, or else it will end up pointing to garbage.\n+     *\n+     * Modifying the vector may cause its buffer to be reallocated, which\n+     * would also make any pointers to it invalid.\n+     */\n+    fn as_ptr(&self) -> *T;\n+\n     /**\n      * Binary search a sorted vector with a comparator function.\n      *\n@@ -1043,7 +1053,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     #[inline]\n     fn iter(self) -> VecIterator<'a, T> {\n         unsafe {\n-            let p = vec::raw::to_ptr(self);\n+            let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n                 VecIterator{ptr: p,\n                             end: (p as uint + self.len()) as *T,\n@@ -1156,6 +1166,12 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n         self.repr().data.offset(index as int)\n     }\n \n+    #[inline]\n+    fn as_ptr(&self) -> *T {\n+        self.repr().data\n+    }\n+\n+\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n@@ -1571,8 +1587,8 @@ impl<T> OwnedVector<T> for ~[T] {\n         let new_len = self_len + rhs_len;\n         self.reserve_additional(rhs.len());\n         unsafe { // Note: infallible.\n-            let self_p = vec::raw::to_mut_ptr(*self);\n-            let rhs_p = vec::raw::to_ptr(rhs);\n+            let self_p = self.as_mut_ptr();\n+            let rhs_p = rhs.as_ptr();\n             ptr::copy_memory(ptr::mut_offset(self_p, self_len as int), rhs_p, rhs_len);\n             self.set_len(new_len);\n             rhs.set_len(0);\n@@ -1648,7 +1664,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             self.set_len(next_ln);\n \n             // Swap out the element we want from the end\n-            let vp = raw::to_mut_ptr(*self);\n+            let vp = self.as_mut_ptr();\n             let vp = ptr::mut_offset(vp, (next_ln - 1) as int);\n \n             Some(ptr::replace_ptr(vp, work_elt))\n@@ -1900,7 +1916,7 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n             if ln < 1 { return; }\n \n             // Avoid bounds checks by using unsafe pointers.\n-            let p = vec::raw::to_mut_ptr(*self);\n+            let p = self.as_mut_ptr();\n             let mut r = 1;\n             let mut w = 1;\n \n@@ -2038,6 +2054,17 @@ pub trait MutableVector<'a, T> {\n \n     /// Returns an unsafe mutable pointer to the element in index\n     unsafe fn unsafe_mut_ref(self, index: uint) -> *mut T;\n+\n+    /// Return an unsafe mutable pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T;\n+\n     /// Unsafely sets the element in index to the value\n     unsafe fn unsafe_set(self, index: uint, val: T);\n \n@@ -2083,7 +2110,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     #[inline]\n     fn mut_iter(self) -> VecMutIterator<'a, T> {\n         unsafe {\n-            let p = vec::raw::to_mut_ptr(self);\n+            let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n                 VecMutIterator{ptr: p,\n                                end: (p as uint + self.len()) as *mut T,\n@@ -2159,6 +2186,11 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         ptr::mut_offset(self.repr().data as *mut T, index as int)\n     }\n \n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T {\n+        self.repr().data as *mut T\n+    }\n+\n     #[inline]\n     unsafe fn unsafe_set(self, index: uint, val: T) {\n         *self.unsafe_mut_ref(index) = val;\n@@ -2206,31 +2238,10 @@ pub mod raw {\n     use cast;\n     use option::Some;\n     use ptr;\n-    use mem;\n     use unstable::intrinsics;\n     use vec::{with_capacity, ImmutableVector, MutableVector};\n     use unstable::raw::Slice;\n \n-    /**\n-     * Returns an unsafe pointer to the vector's buffer\n-     *\n-     * The caller must ensure that the vector outlives the pointer this\n-     * function returns, or else it will end up pointing to garbage.\n-     *\n-     * Modifying the vector may cause its buffer to be reallocated, which\n-     * would also make any pointers to it invalid.\n-     */\n-    #[inline]\n-    pub fn to_ptr<T>(v: &[T]) -> *T {\n-        v.repr().data\n-    }\n-\n-    /** see `to_ptr()` */\n-    #[inline]\n-    pub fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n-        v.repr().data as *mut T\n-    }\n-\n     /**\n      * Form a slice from a pointer and length (as a number of units,\n      * not bytes).\n@@ -2755,7 +2766,7 @@ mod tests {\n         unsafe {\n             // Test on-stack copy-from-buf.\n             let a = ~[1, 2, 3];\n-            let mut ptr = raw::to_ptr(a);\n+            let mut ptr = a.as_ptr();\n             let b = from_buf(ptr, 3u);\n             assert_eq!(b.len(), 3u);\n             assert_eq!(b[0], 1);\n@@ -2764,7 +2775,7 @@ mod tests {\n \n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n-            ptr = raw::to_ptr(c);\n+            ptr = c.as_ptr();\n             let d = from_buf(ptr, 5u);\n             assert_eq!(d.len(), 5u);\n             assert_eq!(d[0], 1);\n@@ -4291,7 +4302,7 @@ mod bench {\n         bh.iter(|| {\n             let mut v: ~[u8] = vec::with_capacity(1024);\n             unsafe {\n-                let vp = vec::raw::to_mut_ptr(v);\n+                let vp = v.as_mut_ptr();\n                 ptr::set_memory(vp, 0, 1024);\n                 v.set_len(1024);\n             }"}]}