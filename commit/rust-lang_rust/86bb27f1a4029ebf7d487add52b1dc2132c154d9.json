{"sha": "86bb27f1a4029ebf7d487add52b1dc2132c154d9", "node_id": "C_kwDOAAsO6NoAKDg2YmIyN2YxYTQwMjllYmY3ZDQ4N2FkZDUyYjFkYzIxMzJjMTU0ZDk", "commit": {"author": {"name": "Roland Ruckerbauer", "email": "roland.rucky@gmail.com", "date": "2022-05-22T23:03:08Z"}, "committer": {"name": "Roland Ruckerbauer", "email": "roland.rucky@gmail.com", "date": "2022-05-23T10:24:54Z"}, "message": "Fix inference when pattern matching a tuple field with a wildcard.", "tree": {"sha": "4b0b50f38d731f9995d79b9621b350be7d9dfa8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b0b50f38d731f9995d79b9621b350be7d9dfa8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86bb27f1a4029ebf7d487add52b1dc2132c154d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86bb27f1a4029ebf7d487add52b1dc2132c154d9", "html_url": "https://github.com/rust-lang/rust/commit/86bb27f1a4029ebf7d487add52b1dc2132c154d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86bb27f1a4029ebf7d487add52b1dc2132c154d9/comments", "author": null, "committer": null, "parents": [{"sha": "84be2eaf99c1c057b401f755f92d22d5896900f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/84be2eaf99c1c057b401f755f92d22d5896900f2", "html_url": "https://github.com/rust-lang/rust/commit/84be2eaf99c1c057b401f755f92d22d5896900f2"}], "stats": {"total": 49, "additions": 41, "deletions": 8}, "files": [{"sha": "dbce0f7cd4fb89e3ef0e0e7635ed690b7963a520", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/86bb27f1a4029ebf7d487add52b1dc2132c154d9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bb27f1a4029ebf7d487add52b1dc2132c154d9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=86bb27f1a4029ebf7d487add52b1dc2132c154d9", "patch": "@@ -1,6 +1,6 @@\n //! Type inference for patterns.\n \n-use std::iter::repeat;\n+use std::iter::repeat_with;\n \n use chalk_ir::Mutability;\n use hir_def::{\n@@ -140,15 +140,28 @@ impl<'a> InferenceContext<'a> {\n                     }\n                     None => ((&args[..], &[][..]), 0),\n                 };\n-                let err_ty = self.err_ty();\n-                let mut expectations_iter =\n-                    expectations.iter().map(|a| a.assert_ty_ref(Interner)).chain(repeat(&err_ty));\n-                let mut infer_pat = |(&pat, ty)| self.infer_pat(pat, ty, default_bm);\n+                let mut expectations_iter = expectations\n+                    .iter()\n+                    .cloned()\n+                    .map(|a| a.assert_ty_ref(Interner).clone())\n+                    .chain(repeat_with(|| self.table.new_type_var()));\n \n                 let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + args.len());\n-                inner_tys.extend(pre.iter().zip(expectations_iter.by_ref()).map(&mut infer_pat));\n-                inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns).cloned());\n-                inner_tys.extend(post.iter().zip(expectations_iter).map(infer_pat));\n+\n+                inner_tys\n+                    .extend(expectations_iter.by_ref().take(n_uncovered_patterns + args.len()));\n+\n+                // Process pre\n+                for (ty, pat) in inner_tys.iter_mut().zip(pre) {\n+                    *ty = self.infer_pat(*pat, ty, default_bm);\n+                }\n+\n+                // Process post\n+                for (ty, pat) in\n+                    inner_tys.iter_mut().skip(pre.len() + n_uncovered_patterns).zip(post)\n+                {\n+                    *ty = self.infer_pat(*pat, ty, default_bm);\n+                }\n \n                 TyKind::Tuple(inner_tys.len(), Substitution::from_iter(Interner, inner_tys))\n                     .intern(Interner)"}, {"sha": "399553356b04112997c951e2de528175f9f441f7", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/86bb27f1a4029ebf7d487add52b1dc2132c154d9/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bb27f1a4029ebf7d487add52b1dc2132c154d9/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=86bb27f1a4029ebf7d487add52b1dc2132c154d9", "patch": "@@ -969,3 +969,23 @@ fn main() {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn tuple_wildcard() {\n+    check_types(\n+        r#\"\n+fn main() {\n+    enum Option<T> {Some(T), None}\n+    use Option::*;\n+\n+    let mut x = None;\n+    x;\n+  //^ Option<(i32, i32)>\n+\n+    if let Some((_, _a)) = x {}\n+\n+    x = Some((1, 2));\n+}\n+        \"#,\n+    );\n+}"}]}