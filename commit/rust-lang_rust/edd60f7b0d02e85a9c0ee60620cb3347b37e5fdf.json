{"sha": "edd60f7b0d02e85a9c0ee60620cb3347b37e5fdf", "node_id": "C_kwDOAAsO6NoAKGVkZDYwZjdiMGQwMmU4NWE5YzBlZTYwNjIwY2IzMzQ3YjM3ZTVmZGY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-05-13T09:02:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-05-13T09:02:57Z"}, "message": "Simplify bind pat filtering", "tree": {"sha": "4b39740ac2523b74e1b4fd9ed8c116ce6057b50b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b39740ac2523b74e1b4fd9ed8c116ce6057b50b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edd60f7b0d02e85a9c0ee60620cb3347b37e5fdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edd60f7b0d02e85a9c0ee60620cb3347b37e5fdf", "html_url": "https://github.com/rust-lang/rust/commit/edd60f7b0d02e85a9c0ee60620cb3347b37e5fdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edd60f7b0d02e85a9c0ee60620cb3347b37e5fdf/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "730286b523c23170630142b6ebba0677a9aedae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/730286b523c23170630142b6ebba0677a9aedae9", "html_url": "https://github.com/rust-lang/rust/commit/730286b523c23170630142b6ebba0677a9aedae9"}], "stats": {"total": 103, "additions": 32, "deletions": 71}, "files": [{"sha": "3d5122a7cf3e713dac02f8f8f469f10db96ad18e", "filename": "crates/ide/src/inlay_hints/bind_pat.rs", "status": "modified", "additions": 32, "deletions": 71, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/edd60f7b0d02e85a9c0ee60620cb3347b37e5fdf/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd60f7b0d02e85a9c0ee60620cb3347b37e5fdf/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=edd60f7b0d02e85a9c0ee60620cb3347b37e5fdf", "patch": "@@ -3,7 +3,7 @@\n //! fn f(a: i32, b: i32) -> i32 { a + b }\n //! let _x /* i32 */= f(4, 4);\n //! ```\n-use hir::{Semantics, TypeInfo};\n+use hir::Semantics;\n use ide_db::{base_db::FileId, famous_defs::FamousDefs, RootDatabase};\n \n use itertools::Itertools;\n@@ -28,11 +28,41 @@ pub(super) fn hints(\n         return None;\n     }\n \n+    let parent = pat.syntax().parent()?;\n+    let type_ascriptable = match_ast! {\n+        match parent {\n+            ast::Param(it) => {\n+                if it.ty().is_some() {\n+                    return None;\n+                }\n+                Some(it.colon_token())\n+            },\n+            ast::LetStmt(it) => {\n+                if config.hide_closure_initialization_hints {\n+                    if let Some(ast::Expr::ClosureExpr(closure)) = it.initializer() {\n+                        if closure_has_block_body(&closure) {\n+                            return None;\n+                        }\n+                    }\n+                }\n+                if it.ty().is_some() {\n+                    return None;\n+                }\n+                Some(it.colon_token())\n+            },\n+            _ => None\n+        }\n+    };\n+\n     let descended = sema.descend_node_into_attributes(pat.clone()).pop();\n     let desc_pat = descended.as_ref().unwrap_or(pat);\n     let ty = sema.type_of_binding_in_pat(desc_pat)?;\n \n-    if should_not_display_type_hint(sema, config, pat, &ty) {\n+    if ty.is_unknown() {\n+        return None;\n+    }\n+\n+    if sema.resolve_bind_pat_to_const(pat).is_some() {\n         return None;\n     }\n \n@@ -44,11 +74,6 @@ pub(super) fn hints(\n         return None;\n     }\n \n-    let type_ascriptable = desc_pat.syntax().parent().and_then(|it| {\n-        ast::LetStmt::cast(it.clone())\n-            .map(|it| it.colon_token())\n-            .or_else(|| ast::Param::cast(it).map(|it| it.colon_token()))\n-    });\n     let text_edit = if let Some(colon_token) = &type_ascriptable {\n         ty_to_text_edit(\n             sema,\n@@ -89,57 +114,6 @@ pub(super) fn hints(\n     Some(())\n }\n \n-fn should_not_display_type_hint(\n-    sema: &Semantics<'_, RootDatabase>,\n-    config: &InlayHintsConfig,\n-    bind_pat: &ast::IdentPat,\n-    pat_ty: &hir::Type,\n-) -> bool {\n-    let db = sema.db;\n-\n-    if pat_ty.is_unknown() {\n-        return true;\n-    }\n-\n-    if sema.resolve_bind_pat_to_const(bind_pat).is_some() {\n-        return true;\n-    }\n-\n-    for node in bind_pat.syntax().ancestors() {\n-        match_ast! {\n-            match node {\n-                ast::LetStmt(it) => {\n-                    if config.hide_closure_initialization_hints {\n-                        if let Some(ast::Expr::ClosureExpr(closure)) = it.initializer() {\n-                            if closure_has_block_body(&closure) {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                    return it.ty().is_some()\n-                },\n-                // FIXME: We might wanna show type hints in parameters for non-top level patterns as well\n-                ast::Param(it) => return it.ty().is_some(),\n-                ast::MatchArm(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n-                ast::LetExpr(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n-                ast::IfExpr(_) => return false,\n-                ast::WhileExpr(_) => return false,\n-                ast::ForExpr(it) => {\n-                    // We *should* display hint only if user provided \"in {expr}\" and we know the type of expr (and it's not unit).\n-                    // Type of expr should be iterable.\n-                    return it.in_token().is_none() ||\n-                        it.iterable()\n-                            .and_then(|iterable_expr| sema.type_of_expr(&iterable_expr))\n-                            .map(TypeInfo::original)\n-                            .map_or(true, |iterable_ty| iterable_ty.is_unknown() || iterable_ty.is_unit())\n-                },\n-                _ => (),\n-            }\n-        }\n-    }\n-    false\n-}\n-\n fn is_named_constructor(\n     sema: &Semantics<'_, RootDatabase>,\n     pat: &ast::IdentPat,\n@@ -193,19 +167,6 @@ fn is_named_constructor(\n     (ctor_name == ty_name).then_some(())\n }\n \n-fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir::Type) -> bool {\n-    if let Some(hir::Adt::Enum(enum_data)) = pat_ty.as_adt() {\n-        let pat_text = bind_pat.to_string();\n-        enum_data\n-            .variants(db)\n-            .into_iter()\n-            .map(|variant| variant.name(db).to_smol_str())\n-            .any(|enum_name| enum_name == pat_text)\n-    } else {\n-        false\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     // This module also contains tests for super::closure_ret"}]}