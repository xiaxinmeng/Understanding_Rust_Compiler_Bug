{"sha": "8e44688889b4532919ba5280b9c3fd15d2b49402", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNDQ2ODg4ODliNDUzMjkxOWJhNTI4MGI5YzNmZDE1ZDJiNDk0MDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-18T21:13:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-19T10:52:59Z"}, "message": "Deduce the argument types based on the expected type, trawling through the fulfillment contect if necessary.", "tree": {"sha": "141f3ab417bdd22e33bd54f52bf7f9137f8794c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/141f3ab417bdd22e33bd54f52bf7f9137f8794c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e44688889b4532919ba5280b9c3fd15d2b49402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e44688889b4532919ba5280b9c3fd15d2b49402", "html_url": "https://github.com/rust-lang/rust/commit/8e44688889b4532919ba5280b9c3fd15d2b49402", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e44688889b4532919ba5280b9c3fd15d2b49402/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe2fcb39f43737089739c0190670231f18bc7a6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe2fcb39f43737089739c0190670231f18bc7a6a", "html_url": "https://github.com/rust-lang/rust/commit/fe2fcb39f43737089739c0190670231f18bc7a6a"}], "stats": {"total": 260, "additions": 249, "deletions": 11}, "files": [{"sha": "62382ac386fcd8719411f6199cb9bd40698e981a", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=8e44688889b4532919ba5280b9c3fd15d2b49402", "patch": "@@ -109,6 +109,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.select(&mut selcx, false)\n     }\n \n+    pub fn pending_trait_obligations(&self) -> &[Obligation<'tcx>] {\n+        self.trait_obligations[]\n+    }\n+\n     fn select<'a>(&mut self,\n                   selcx: &mut SelectionContext<'a, 'tcx>,\n                   only_new_obligations: bool)"}, {"sha": "6e6e2f1eee531d955cb4d2ec8585ae5a96102465", "filename": "src/librustc/middle/typeck/check/closure.rs", "status": "modified", "additions": 125, "deletions": 8, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fclosure.rs?ref=8e44688889b4532919ba5280b9c3fd15d2b49402", "patch": "@@ -13,10 +13,11 @@\n  */\n \n use super::check_fn;\n-use super::Expectation;\n+use super::{Expectation, ExpectCastableToType, ExpectHasType, NoExpectation};\n use super::FnCtxt;\n \n-use middle::ty;\n+use middle::subst;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv;\n use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n@@ -25,13 +26,40 @@ use syntax::ast;\n use syntax::ast_util;\n use util::ppaux::Repr;\n \n-pub fn check_unboxed_closure(fcx: &FnCtxt,\n-                             expr: &ast::Expr,\n-                             kind: ast::UnboxedClosureKind,\n-                             decl: &ast::FnDecl,\n-                             body: &ast::Block) {\n+pub fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                      expr: &ast::Expr,\n+                                      kind: ast::UnboxedClosureKind,\n+                                      decl: &ast::FnDecl,\n+                                      body: &ast::Block,\n+                                      expected: Expectation<'tcx>) {\n     let expr_def_id = ast_util::local_def(expr.id);\n \n+    let expected_sig_and_kind = match expected.resolve(fcx) {\n+        NoExpectation => None,\n+        ExpectCastableToType(t) | ExpectHasType(t) => {\n+            deduce_unboxed_closure_expectations_from_expected_type(fcx, t)\n+        }\n+    };\n+\n+    let (expected_sig, expected_kind) = match expected_sig_and_kind {\n+        None => (None, None),\n+        Some((sig, kind)) => {\n+            // Avoid accidental capture of bound regions by renaming\n+            // them to fresh names, basically.\n+            let sig =\n+                ty::replace_late_bound_regions(\n+                    fcx.tcx(),\n+                    &sig,\n+                    |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn)).0;\n+            (Some(sig), Some(kind))\n+        }\n+    };\n+\n+    debug!(\"check_unboxed_closure expected={} expected_sig={} expected_kind={}\",\n+           expected.repr(fcx.tcx()),\n+           expected_sig.repr(fcx.tcx()),\n+           expected_kind);\n+\n     let mut fn_ty = astconv::ty_of_closure(\n         fcx,\n         ast::NormalFn,\n@@ -46,7 +74,7 @@ pub fn check_unboxed_closure(fcx: &FnCtxt,\n \n         decl,\n         abi::RustCall,\n-        None);\n+        expected_sig);\n \n     let region = match fcx.infcx().anon_regions(expr.span, 1) {\n         Err(_) => {\n@@ -98,6 +126,95 @@ pub fn check_unboxed_closure(fcx: &FnCtxt,\n         .insert(expr_def_id, unboxed_closure);\n }\n \n+fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                                                   expected_ty: Ty<'tcx>)\n+                                                                   -> Option<(ty::FnSig<'tcx>,\n+                                                                              ty::UnboxedClosureKind)>\n+{\n+    match expected_ty.sty {\n+        ty::ty_trait(ref object_type) => {\n+            deduce_unboxed_closure_expectations_from_trait_ref(fcx, &object_type.principal)\n+        }\n+        ty::ty_infer(ty::TyVar(vid)) => {\n+            deduce_unboxed_closure_expectations_from_obligations(fcx, vid)\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}\n+\n+fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    trait_ref: &ty::TraitRef<'tcx>)\n+    -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n+{\n+    let tcx = fcx.tcx();\n+\n+    debug!(\"deduce_unboxed_closure_expectations_from_object_type({})\",\n+           trait_ref.repr(tcx));\n+\n+    let def_id_kinds = [\n+        (tcx.lang_items.fn_trait(), ty::FnUnboxedClosureKind),\n+        (tcx.lang_items.fn_mut_trait(), ty::FnMutUnboxedClosureKind),\n+        (tcx.lang_items.fn_once_trait(), ty::FnOnceUnboxedClosureKind),\n+    ];\n+\n+    for &(def_id, kind) in def_id_kinds.iter() {\n+        if Some(trait_ref.def_id) == def_id {\n+            debug!(\"found object type {}\", kind);\n+\n+            let arg_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n+            let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(arg_param_ty);\n+            debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n+\n+            let input_tys = match arg_param_ty.sty {\n+                ty::ty_tup(ref tys) => { (*tys).clone() }\n+                _ => { continue; }\n+            };\n+            debug!(\"input_tys {}\", input_tys.repr(tcx));\n+\n+            let ret_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n+            let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(ret_param_ty);\n+            debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n+\n+            let fn_sig = ty::FnSig {\n+                inputs: input_tys,\n+                output: ty::FnConverging(ret_param_ty),\n+                variadic: false\n+            };\n+            debug!(\"fn_sig {}\", fn_sig.repr(tcx));\n+\n+            return Some((fn_sig, kind));\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    expected_vid: ty::TyVid)\n+    -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n+{\n+    // Here `expected_ty` is known to be a type inference variable.\n+    for obligation in fcx.inh.fulfillment_cx.borrow().pending_trait_obligations().iter() {\n+        let obligation_self_ty = fcx.infcx().shallow_resolve(obligation.self_ty());\n+        match obligation_self_ty.sty {\n+            ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n+            _ => { continue; }\n+        }\n+\n+        match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &*obligation.trait_ref) {\n+            Some(e) => { return Some(e); }\n+            None => { }\n+        }\n+    }\n+\n+    None\n+}\n+\n+\n pub fn check_expr_fn<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                               expr: &ast::Expr,\n                               store: ty::TraitStore,"}, {"sha": "28648d6d4e22cdf5b2cdffd3485083e3bebe5e59", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8e44688889b4532919ba5280b9c3fd15d2b49402", "patch": "@@ -78,7 +78,7 @@ type parameter).\n \n pub use self::LvaluePreference::*;\n pub use self::DerefArgs::*;\n-use self::Expectation::*;\n+pub use self::Expectation::*;\n use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n \n@@ -97,7 +97,7 @@ use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{mod, Ty};\n-use middle::ty::{replace_late_bound_regions, liberate_late_bound_regions};\n+use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n@@ -4165,7 +4165,8 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          expr,\n                                          kind,\n                                          &**decl,\n-                                         &**body);\n+                                         &**body,\n+                                         expected);\n       }\n       ast::ExprProc(ref decl, ref body) => {\n           closure::check_expr_fn(fcx,"}, {"sha": "70f0d61b5ee1fdfd896b4acdcf816f90be942dce", "filename": "src/test/compile-fail/regions-escape-unboxed-closure.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Fcompile-fail%2Fregions-escape-unboxed-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Fcompile-fail%2Fregions-escape-unboxed-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-unboxed-closure.rs?ref=8e44688889b4532919ba5280b9c3fd15d2b49402", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+fn with_int(f: &mut FnMut(&int)) {\n+}\n+\n+fn main() {\n+    let mut x: Option<&int> = None;\n+    with_int(&mut |&mut: y| x = Some(y));   //~ ERROR cannot infer\n+}"}, {"sha": "72109b22957e02ceb57891670ba37f8c6f175f8e", "filename": "src/test/compile-fail/unboxed-closures-infer-argument-types-two-region-pointers.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-argument-types-two-region-pointers.rs?ref=8e44688889b4532919ba5280b9c3fd15d2b49402", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// That a closure whose expected argument types include two distinct\n+// bound regions.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::cell::Cell;\n+\n+fn doit<T,F>(val: T, f: &F)\n+    where F : Fn(&Cell<&T>, &T)\n+{\n+    let x = Cell::new(&val);\n+    f.call((&x,&val))\n+}\n+\n+pub fn main() {\n+    doit(0i, &|&: x, y| {\n+        x.set(y); //~ ERROR cannot infer\n+    });\n+}"}, {"sha": "465c324122a44d5171213b317de7f0c06215dade", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-from-expected-bound.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs?ref=8e44688889b4532919ba5280b9c3fd15d2b49402", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer that the type of `x` is `int` based\n+// on the expected type from the object.\n+\n+#![feature(unboxed_closures)]\n+\n+fn doit<T,F>(val: T, f: &F)\n+    where F : Fn(T)\n+{\n+    f.call((val,))\n+}\n+\n+pub fn main() {\n+    doit(0i, &|&: x /*: int*/ | { x.to_int(); });\n+}"}, {"sha": "440292d202e486a2c011132288ed91e402db47d9", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-from-expected-object-type.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs?ref=8e44688889b4532919ba5280b9c3fd15d2b49402", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer that the type of `x` is `int` based\n+// on the expected type from the object.\n+\n+#![feature(unboxed_closures)]\n+\n+fn doit<T>(val: T, f: &Fn(T)) { f.call((val,)) }\n+\n+pub fn main() {\n+    doit(0i, &|&: x /*: int*/ | { x.to_int(); });\n+}"}, {"sha": "b279eb5fbba90284514ce96ae448a8d144586919", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e44688889b4532919ba5280b9c3fd15d2b49402/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs?ref=8e44688889b4532919ba5280b9c3fd15d2b49402", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer that the type of `x` is `int` based\n+// on the expected type from the object.\n+\n+#![feature(unboxed_closures)]\n+\n+fn doit<T,F>(val: T, f: &F)\n+    where F : Fn(&T)\n+{\n+    f.call((&val,))\n+}\n+\n+pub fn main() {\n+    doit(0i, &|&: x /*: int*/ | { x.to_int(); });\n+}"}]}