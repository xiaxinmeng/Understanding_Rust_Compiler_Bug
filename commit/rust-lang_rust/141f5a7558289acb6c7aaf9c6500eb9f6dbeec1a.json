{"sha": "141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MWY1YTc1NTgyODlhY2I2YzdhYWY5YzY1MDBlYjlmNmRiZWVjMWE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-01T18:20:33Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-01T18:20:33Z"}, "message": "review comments", "tree": {"sha": "c5cfde98781741f20399819fb89a75015235e74c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5cfde98781741f20399819fb89a75015235e74c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a", "html_url": "https://github.com/rust-lang/rust/commit/141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "html_url": "https://github.com/rust-lang/rust/commit/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4"}], "stats": {"total": 110, "additions": 57, "deletions": 53}, "files": [{"sha": "17c9e520bcea284c2d385eb71649003555f70f60", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a", "patch": "@@ -2403,20 +2403,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_pin(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::PinTypeLangItem, None);\n-        self.mk_generic_adt(def_id, ty)\n-    }\n-\n-    #[inline]\n-    pub fn mk_rc(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::Rc, None);\n-        self.mk_generic_adt(def_id, ty)\n-    }\n-\n-    #[inline]\n-    pub fn mk_arc(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::Arc, None);\n+    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(item, None);\n         self.mk_generic_adt(def_id, ty)\n     }\n "}, {"sha": "fbaa9904d8303c0386954e2de62a0e31ab5bebc6", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 55, "deletions": 39, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=141f5a7558289acb6c7aaf9c6500eb9f6dbeec1a", "patch": "@@ -12,7 +12,7 @@ use crate::check::fatally_break_rust;\n use crate::check::report_unexpected_variant_res;\n use crate::check::Needs;\n use crate::check::TupleArgumentsFlag::DontTupleArguments;\n-use crate::check::method::{probe, SelfSource};\n+use crate::check::method::{probe, SelfSource, MethodError};\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n@@ -29,6 +29,7 @@ use rustc::hir::def::{CtorKind, Res, DefKind};\n use rustc::hir::ptr::P;\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::middle::lang_items;\n use rustc::mir::interpret::GlobalId;\n use rustc::ty;\n use rustc::ty::adjustment::{\n@@ -775,51 +776,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n-        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n-            if let Ok(pick) = self.lookup_probe(\n-                span,\n-                segment.ident,\n-                new_rcvr_t,\n-                rcvr,\n-                probe::ProbeScope::AllTraits,\n-            ) {\n-                err.span_label(\n-                    pick.item.ident.span,\n-                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n-                );\n-            }\n-        };\n-\n         let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr) {\n             Ok(method) => {\n                 self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n                 if segment.ident.name != kw::Invalid {\n-                    if let Some(mut err) = self.report_method_error(\n-                        span,\n-                        rcvr_t,\n-                        segment.ident,\n-                        SelfSource::MethodCall(rcvr),\n-                        error,\n-                        Some(args),\n-                    ) {\n-                        if let ty::Adt(..) = rcvr_t.sty {\n-                            // Try alternative arbitrary self types that could fulfill this call.\n-                            // FIXME: probe for all types that *could* be arbitrary self-types, not\n-                            // just this whitelist.\n-                            let box_rcvr_t = self.tcx.mk_box(rcvr_t);\n-                            try_alt_rcvr(&mut err, box_rcvr_t);\n-                            let pin_rcvr_t = self.tcx.mk_pin(rcvr_t);\n-                            try_alt_rcvr(&mut err, pin_rcvr_t);\n-                            let arc_rcvr_t = self.tcx.mk_arc(rcvr_t);\n-                            try_alt_rcvr(&mut err, arc_rcvr_t);\n-                            let rc_rcvr_t = self.tcx.mk_rc(rcvr_t);\n-                            try_alt_rcvr(&mut err, rc_rcvr_t);\n-                        }\n-                        err.emit();\n-                    }\n+                    self.report_extended_method_error(segment, span, args, rcvr_t, error);\n                 }\n                 Err(())\n             }\n@@ -836,6 +800,58 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n+    fn report_extended_method_error(\n+        &self,\n+        segment: &hir::PathSegment,\n+        span: Span,\n+        args: &'tcx [hir::Expr],\n+        rcvr_t: Ty<'tcx>,\n+        error: MethodError<'tcx>\n+    ) {\n+        let rcvr = &args[0];\n+        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n+            if let Ok(pick) = self.lookup_probe(\n+                span,\n+                segment.ident,\n+                new_rcvr_t,\n+                rcvr,\n+                probe::ProbeScope::AllTraits,\n+            ) {\n+                err.span_label(\n+                    pick.item.ident.span,\n+                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                );\n+            }\n+        };\n+\n+        if let Some(mut err) = self.report_method_error(\n+            span,\n+            rcvr_t,\n+            segment.ident,\n+            SelfSource::MethodCall(rcvr),\n+            error,\n+            Some(args),\n+        ) {\n+            if let ty::Adt(..) = rcvr_t.sty {\n+                // Try alternative arbitrary self types that could fulfill this call.\n+                // FIXME: probe for all types that *could* be arbitrary self-types, not\n+                // just this whitelist.\n+                let box_rcvr_t = self.tcx.mk_box(rcvr_t);\n+                try_alt_rcvr(&mut err, box_rcvr_t);\n+                let pin_rcvr_t = self.tcx.mk_lang_item(\n+                    rcvr_t,\n+                    lang_items::PinTypeLangItem,\n+                );\n+                try_alt_rcvr(&mut err, pin_rcvr_t);\n+                let arc_rcvr_t = self.tcx.mk_lang_item(rcvr_t, lang_items::Arc);\n+                try_alt_rcvr(&mut err, arc_rcvr_t);\n+                let rc_rcvr_t = self.tcx.mk_lang_item(rcvr_t, lang_items::Rc);\n+                try_alt_rcvr(&mut err, rc_rcvr_t);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n     fn check_expr_cast(\n         &self,\n         e: &'tcx hir::Expr,"}]}