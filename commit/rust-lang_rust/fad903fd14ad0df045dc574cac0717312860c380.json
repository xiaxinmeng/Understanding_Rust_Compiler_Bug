{"sha": "fad903fd14ad0df045dc574cac0717312860c380", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZDkwM2ZkMTRhZDBkZjA0NWRjNTc0Y2FjMDcxNzMxMjg2MGMzODA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-08T13:16:47Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-12-15T01:26:19Z"}, "message": "Move from String to PathBuf where applicable", "tree": {"sha": "066feeae5995979a4c6d6788d08b3924a827408d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/066feeae5995979a4c6d6788d08b3924a827408d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad903fd14ad0df045dc574cac0717312860c380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad903fd14ad0df045dc574cac0717312860c380", "html_url": "https://github.com/rust-lang/rust/commit/fad903fd14ad0df045dc574cac0717312860c380", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad903fd14ad0df045dc574cac0717312860c380/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ee7911f4bfb08cfa569454bbaaf81b9c454375a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ee7911f4bfb08cfa569454bbaaf81b9c454375a", "html_url": "https://github.com/rust-lang/rust/commit/4ee7911f4bfb08cfa569454bbaaf81b9c454375a"}], "stats": {"total": 266, "additions": 152, "deletions": 114}, "files": [{"sha": "0e48ab7c23abaeaabb4eeb7a78b2826d218768d9", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_private)]\n #![cfg(not(test))]\n \n extern crate env_logger;\n@@ -22,7 +23,7 @@ use std::str::FromStr;\n \n use getopts::{Matches, Options};\n \n-use rustfmt::{run, Input, Summary};\n+use rustfmt::{run, FileName, Input, Summary};\n use rustfmt::file_lines::FileLines;\n use rustfmt::config::{get_toml_path, Color, Config, WriteMode};\n \n@@ -243,8 +244,9 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n             if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n                 config.set().file_lines(file_lines.parse()?);\n                 for f in config.file_lines().files() {\n-                    if f != \"stdin\" {\n-                        eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f);\n+                    match *f {\n+                        FileName::Custom(ref f) if f == \"stdin\" => {}\n+                        _ => eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f),\n                     }\n                 }\n             }\n@@ -264,8 +266,12 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n             let options = CliOptions::from_matches(&matches)?;\n \n             for f in options.file_lines.files() {\n-                if !files.contains(&PathBuf::from(f)) {\n-                    eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f);\n+                match *f {\n+                    FileName::Real(ref f) if files.contains(f) => {}\n+                    FileName::Real(_) => {\n+                        eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n+                    }\n+                    _ => eprintln!(\"Warning: Not a file '{}'\", f),\n                 }\n             }\n "}, {"sha": "7f6e650ad220295e9539484d5b4c28f88b42de54", "filename": "src/checkstyle.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/src%2Fcheckstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/src%2Fcheckstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcheckstyle.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::io::{self, Write};\n+use std::path::Path;\n \n use config::WriteMode;\n use rustfmt_diff::{DiffLine, Mismatch};\n@@ -41,13 +42,13 @@ where\n \n pub fn output_checkstyle_file<T>(\n     mut writer: T,\n-    filename: &str,\n+    filename: &Path,\n     diff: Vec<Mismatch>,\n ) -> Result<(), io::Error>\n where\n     T: Write,\n {\n-    write!(writer, \"<file name=\\\"{}\\\">\", filename)?;\n+    write!(writer, \"<file name=\\\"{}\\\">\", filename.display())?;\n     for mismatch in diff {\n         for line in mismatch.lines {\n             // Do nothing with `DiffLine::Context` and `DiffLine::Resulting`."}, {"sha": "e0401b0b197e7438c90bc322d1db4d2520699375", "filename": "src/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -13,7 +13,7 @@\n \n use std::rc::Rc;\n \n-use syntax::codemap::{BytePos, CodeMap, FileMap, Span};\n+use syntax::codemap::{BytePos, CodeMap, FileMap, FileName, Span};\n \n use comment::FindUncommented;\n \n@@ -25,8 +25,8 @@ pub struct LineRange {\n }\n \n impl LineRange {\n-    pub fn file_name(&self) -> &str {\n-        self.file.as_ref().name.as_str()\n+    pub fn file_name(&self) -> &FileName {\n+        &self.file.name\n     }\n }\n "}, {"sha": "82844a4b22221d5ccd699f5fd35482d3081cb583", "filename": "src/file_lines.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -10,12 +10,14 @@\n \n //! This module contains types and functions to support formatting specific line ranges.\n \n-use std::{cmp, iter, path, str};\n+use std::{cmp, iter, str};\n use std::collections::HashMap;\n \n+use serde::de::{Deserialize, Deserializer};\n use serde_json as json;\n \n use codemap::LineRange;\n+use syntax::codemap::FileName;\n \n /// A range that is inclusive of both ends.\n #[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, Deserialize)]\n@@ -84,11 +86,11 @@ impl Range {\n /// non-overlapping ranges sorted by their start point. An inner `None` is interpreted to mean all\n /// lines in all files.\n #[derive(Clone, Debug, Default)]\n-pub struct FileLines(Option<HashMap<String, Vec<Range>>>);\n+pub struct FileLines(Option<HashMap<FileName, Vec<Range>>>);\n \n /// Normalizes the ranges so that the invariants for `FileLines` hold: ranges are non-overlapping,\n /// and ordered by their start point.\n-fn normalize_ranges(ranges: &mut HashMap<String, Vec<Range>>) {\n+fn normalize_ranges(ranges: &mut HashMap<FileName, Vec<Range>>) {\n     for ranges in ranges.values_mut() {\n         ranges.sort();\n         let mut result = vec![];\n@@ -117,7 +119,7 @@ impl FileLines {\n         FileLines(None)\n     }\n \n-    pub fn from_ranges(mut ranges: HashMap<String, Vec<Range>>) -> FileLines {\n+    pub fn from_ranges(mut ranges: HashMap<FileName, Vec<Range>>) -> FileLines {\n         normalize_ranges(&mut ranges);\n         FileLines(Some(ranges))\n     }\n@@ -129,7 +131,7 @@ impl FileLines {\n \n     /// Returns true if `self` includes all lines in all files. Otherwise runs `f` on all ranges in\n     /// the designated file (if any) and returns true if `f` ever does.\n-    fn file_range_matches<F>(&self, file_name: &str, f: F) -> bool\n+    fn file_range_matches<F>(&self, file_name: &FileName, f: F) -> bool\n     where\n         F: FnMut(&Range) -> bool,\n     {\n@@ -156,35 +158,31 @@ impl FileLines {\n     }\n \n     /// Returns true if `line` from `file_name` is in `self`.\n-    pub fn contains_line(&self, file_name: &str, line: usize) -> bool {\n+    pub fn contains_line(&self, file_name: &FileName, line: usize) -> bool {\n         self.file_range_matches(file_name, |r| r.lo <= line && r.hi >= line)\n     }\n \n     /// Returns true if any of the lines between `lo` and `hi` from `file_name` are in `self`.\n-    pub fn intersects_range(&self, file_name: &str, lo: usize, hi: usize) -> bool {\n+    pub fn intersects_range(&self, file_name: &FileName, lo: usize, hi: usize) -> bool {\n         self.file_range_matches(file_name, |r| r.intersects(Range::new(lo, hi)))\n     }\n }\n \n /// `FileLines` files iterator.\n-pub struct Files<'a>(Option<::std::collections::hash_map::Keys<'a, String, Vec<Range>>>);\n+pub struct Files<'a>(Option<::std::collections::hash_map::Keys<'a, FileName, Vec<Range>>>);\n \n impl<'a> iter::Iterator for Files<'a> {\n-    type Item = &'a String;\n+    type Item = &'a FileName;\n \n-    fn next(&mut self) -> Option<&'a String> {\n+    fn next(&mut self) -> Option<&'a FileName> {\n         self.0.as_mut().and_then(Iterator::next)\n     }\n }\n \n-fn canonicalize_path_string(s: &str) -> Option<String> {\n-    if s == \"stdin\" {\n-        return Some(s.to_string());\n-    }\n-\n-    match path::PathBuf::from(s).canonicalize() {\n-        Ok(canonicalized) => canonicalized.to_str().map(|s| s.to_string()),\n-        _ => None,\n+fn canonicalize_path_string(file: &FileName) -> Option<FileName> {\n+    match *file {\n+        FileName::Real(ref path) => path.canonicalize().ok().map(FileName::Real),\n+        _ => Some(file.clone()),\n     }\n }\n \n@@ -206,12 +204,21 @@ impl str::FromStr for FileLines {\n // For JSON decoding.\n #[derive(Clone, Debug, Deserialize)]\n struct JsonSpan {\n-    file: String,\n+    #[serde(deserialize_with = \"deserialize_filename\")] file: FileName,\n     range: (usize, usize),\n }\n \n+fn deserialize_filename<'de, D: Deserializer<'de>>(d: D) -> Result<FileName, D::Error> {\n+    let s = String::deserialize(d)?;\n+    if s == \"stdin\" {\n+        Ok(FileName::Custom(s))\n+    } else {\n+        Ok(FileName::Real(s.into()))\n+    }\n+}\n+\n impl JsonSpan {\n-    fn into_tuple(self) -> Result<(String, Range), String> {\n+    fn into_tuple(self) -> Result<(FileName, Range), String> {\n         let (lo, hi) = self.range;\n         let canonical = canonicalize_path_string(&self.file)\n             .ok_or_else(|| format!(\"Can't canonicalize {}\", &self.file))?;"}, {"sha": "5678dd59c55b7cb47fad61bf8d6566fab1f8c73c", "filename": "src/filemap.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -12,15 +12,17 @@\n \n use std::fs::{self, File};\n use std::io::{self, BufWriter, Read, Write};\n+use std::path::Path;\n \n use checkstyle::{output_checkstyle_file, output_footer, output_header};\n use config::{Config, NewlineStyle, WriteMode};\n use rustfmt_diff::{make_diff, print_diff, Mismatch};\n+use syntax::codemap::FileName;\n \n // A map of the files of a crate, with their new content\n pub type FileMap = Vec<FileRecord>;\n \n-pub type FileRecord = (String, String);\n+pub type FileRecord = (FileName, String);\n \n // Append a newline to the end of each file.\n pub fn append_newline(s: &mut String) {\n@@ -80,7 +82,7 @@ where\n \n pub fn write_file<T>(\n     text: &str,\n-    filename: &str,\n+    filename: &FileName,\n     out: &mut T,\n     config: &Config,\n ) -> Result<bool, io::Error>\n@@ -89,7 +91,7 @@ where\n {\n     fn source_and_formatted_text(\n         text: &str,\n-        filename: &str,\n+        filename: &Path,\n         config: &Config,\n     ) -> Result<(String, String), io::Error> {\n         let mut f = File::open(filename)?;\n@@ -102,23 +104,29 @@ where\n     }\n \n     fn create_diff(\n-        filename: &str,\n+        filename: &Path,\n         text: &str,\n         config: &Config,\n     ) -> Result<Vec<Mismatch>, io::Error> {\n         let (ori, fmt) = source_and_formatted_text(text, filename, config)?;\n         Ok(make_diff(&ori, &fmt, 3))\n     }\n \n+    let filename_to_path = || match *filename {\n+        FileName::Real(ref path) => path,\n+        _ => panic!(\"cannot format `{}` with WriteMode::Replace\", filename),\n+    };\n+\n     match config.write_mode() {\n         WriteMode::Replace => {\n-            if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n+            let filename = filename_to_path();\n+            if let Ok((ori, fmt)) = source_and_formatted_text(text, &filename, config) {\n                 if fmt != ori {\n                     // Do a little dance to make writing safer - write to a temp file\n                     // rename the original to a .bk, then rename the temp file to the\n                     // original.\n-                    let tmp_name = filename.to_owned() + \".tmp\";\n-                    let bk_name = filename.to_owned() + \".bk\";\n+                    let tmp_name = filename.with_extension(\"tmp\");\n+                    let bk_name = filename.with_extension(\"bk\");\n                     {\n                         // Write text to temp file\n                         let tmp_file = File::create(&tmp_name)?;\n@@ -132,7 +140,8 @@ where\n         }\n         WriteMode::Overwrite => {\n             // Write text directly over original file if there is a diff.\n-            let (source, formatted) = source_and_formatted_text(text, filename, config)?;\n+            let filename = filename_to_path();\n+            let (source, formatted) = source_and_formatted_text(text, &filename, config)?;\n             if source != formatted {\n                 let file = File::create(filename)?;\n                 write_system_newlines(file, text, config)?;\n@@ -146,19 +155,21 @@ where\n             write_system_newlines(out, text, config)?;\n         }\n         WriteMode::Diff => {\n-            if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n+            let filename = filename_to_path();\n+            if let Ok((ori, fmt)) = source_and_formatted_text(text, &filename, config) {\n                 let mismatch = make_diff(&ori, &fmt, 3);\n                 let has_diff = !mismatch.is_empty();\n                 print_diff(\n                     mismatch,\n-                    |line_num| format!(\"Diff in {} at line {}:\", filename, line_num),\n+                    |line_num| format!(\"Diff in {} at line {}:\", filename.display(), line_num),\n                     config.color(),\n                 );\n                 return Ok(has_diff);\n             }\n         }\n         WriteMode::Checkstyle => {\n-            let diff = create_diff(filename, text, config)?;\n+            let filename = filename_to_path();\n+            let diff = create_diff(&filename, text, config)?;\n             output_checkstyle_file(out, filename, diff)?;\n         }\n     }"}, {"sha": "14914359bdc089ce90310e680bd41f240268f4a7", "filename": "src/lib.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -29,13 +29,14 @@ use std::collections::HashMap;\n use std::fmt;\n use std::io::{self, stdout, Write};\n use std::iter::repeat;\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::rc::Rc;\n \n use errors::{DiagnosticBuilder, Handler};\n use errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::ast;\n use syntax::codemap::{CodeMap, FilePathMapping};\n+pub use syntax::codemap::FileName;\n use syntax::parse::{self, ParseSess};\n \n use checkstyle::{output_footer, output_header};\n@@ -146,7 +147,7 @@ impl FormattingError {\n \n pub struct FormatReport {\n     // Maps stringified file paths to their associated formatting errors.\n-    file_error_map: HashMap<String, Vec<FormattingError>>,\n+    file_error_map: HashMap<FileName, Vec<FormattingError>>,\n }\n \n impl FormatReport {\n@@ -295,12 +296,12 @@ impl fmt::Display for FormatReport {\n fn format_ast<F>(\n     krate: &ast::Crate,\n     parse_session: &mut ParseSess,\n-    main_file: &Path,\n+    main_file: &FileName,\n     config: &Config,\n     mut after_file: F,\n ) -> Result<(FileMap, bool), io::Error>\n where\n-    F: FnMut(&str, &mut String, &[(usize, usize)]) -> Result<bool, io::Error>,\n+    F: FnMut(&FileName, &mut String, &[(usize, usize)]) -> Result<bool, io::Error>,\n {\n     let mut result = FileMap::new();\n     // diff mode: check if any files are differing\n@@ -310,12 +311,11 @@ where\n     // nothing to distinguish the nested module contents.\n     let skip_children = config.skip_children() || config.write_mode() == config::WriteMode::Plain;\n     for (path, module) in modules::list_files(krate, parse_session.codemap())? {\n-        if skip_children && path.as_path() != main_file {\n+        if skip_children && path != *main_file {\n             continue;\n         }\n-        let path_str = path.to_str().unwrap();\n         if config.verbose() {\n-            println!(\"Formatting {}\", path_str);\n+            println!(\"Formatting {}\", path);\n         }\n         let filemap = parse_session\n             .codemap()\n@@ -325,7 +325,7 @@ where\n         let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n         let mut visitor = FmtVisitor::from_codemap(parse_session, config, &snippet_provider);\n         // Format inner attributes if available.\n-        if !krate.attrs.is_empty() && path == main_file {\n+        if !krate.attrs.is_empty() && path == *main_file {\n             visitor.skip_empty_lines(filemap.end_pos);\n             if visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner) {\n                 visitor.push_rewrite(module.inner, None);\n@@ -343,16 +343,17 @@ where\n             ::utils::count_newlines(&format!(\"{}\", visitor.buffer))\n         );\n \n-        has_diff |= match after_file(path_str, &mut visitor.buffer, &visitor.skipped_range) {\n+        let filename = path.clone();\n+        has_diff |= match after_file(&filename, &mut visitor.buffer, &visitor.skipped_range) {\n             Ok(result) => result,\n             Err(e) => {\n                 // Create a new error with path_str to help users see which files failed\n-                let err_msg = path_str.to_string() + &\": \".to_string() + &e.to_string();\n+                let err_msg = format!(\"{}: {}\", path, e);\n                 return Err(io::Error::new(e.kind(), err_msg));\n             }\n         };\n \n-        result.push((path_str.to_owned(), visitor.buffer));\n+        result.push((filename, visitor.buffer));\n     }\n \n     Ok((result, has_diff))\n@@ -389,7 +390,7 @@ fn should_report_error(\n // FIXME(#20) other stuff for parity with make tidy\n fn format_lines(\n     text: &mut String,\n-    name: &str,\n+    name: &FileName,\n     skipped_range: &[(usize, usize)],\n     config: &Config,\n     report: &mut FormatReport,\n@@ -491,7 +492,7 @@ fn format_lines(\n         }\n     }\n \n-    report.file_error_map.insert(name.to_owned(), errors);\n+    report.file_error_map.insert(name.clone(), errors);\n }\n \n fn parse_input(\n@@ -505,8 +506,11 @@ fn parse_input(\n             parser.parse_crate_mod()\n         }\n         Input::Text(text) => {\n-            let mut parser =\n-                parse::new_parser_from_source_str(parse_session, \"stdin\".to_owned(), text);\n+            let mut parser = parse::new_parser_from_source_str(\n+                parse_session,\n+                FileName::Custom(\"stdin\".to_owned()),\n+                text,\n+            );\n             parser.cfg_mods = false;\n             parser.parse_crate_mod()\n         }\n@@ -547,8 +551,8 @@ pub fn format_input<T: Write>(\n     let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n \n     let main_file = match input {\n-        Input::File(ref file) => file.clone(),\n-        Input::Text(..) => PathBuf::from(\"stdin\"),\n+        Input::File(ref file) => FileName::Real(file.clone()),\n+        Input::Text(..) => FileName::Custom(\"stdin\".to_owned()),\n     };\n \n     let krate = match parse_input(input, &parse_session) {"}, {"sha": "718ac6bfaab1c2313d3aedfbff9ca49205dc4693", "filename": "src/missed_spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -11,7 +11,7 @@\n use std::borrow::Cow;\n use std::iter::repeat;\n \n-use syntax::codemap::{BytePos, Pos, Span};\n+use syntax::codemap::{BytePos, FileName, Pos, Span};\n \n use codemap::LineRangeUtils;\n use comment::{rewrite_comment, CodeCharKind, CommentCodeSlices};\n@@ -260,7 +260,7 @@ impl<'a> FmtVisitor<'a> {\n         snippet: &str,\n         subslice: &str,\n         offset: usize,\n-        file_name: &str,\n+        file_name: &FileName,\n     ) {\n         for (mut i, c) in subslice.char_indices() {\n             i += offset;"}, {"sha": "ce63597b394072b71aa20a093a0b811afb88fb21", "filename": "src/modules.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -13,7 +13,7 @@ use std::path::{Path, PathBuf};\n use std::io;\n \n use syntax::ast;\n-use syntax::codemap;\n+use syntax::codemap::{self, FileName};\n use syntax::parse::parser;\n \n use utils::contains_skip;\n@@ -23,15 +23,16 @@ use utils::contains_skip;\n pub fn list_files<'a>(\n     krate: &'a ast::Crate,\n     codemap: &codemap::CodeMap,\n-) -> Result<BTreeMap<PathBuf, &'a ast::Mod>, io::Error> {\n+) -> Result<BTreeMap<FileName, &'a ast::Mod>, io::Error> {\n     let mut result = BTreeMap::new(); // Enforce file order determinism\n-    let root_filename: PathBuf = codemap.span_to_filename(krate.span).into();\n-    list_submodules(\n-        &krate.module,\n-        root_filename.parent().unwrap(),\n-        codemap,\n-        &mut result,\n-    )?;\n+    let root_filename = codemap.span_to_filename(krate.span);\n+    {\n+        let parent = match root_filename {\n+            FileName::Real(ref path) => path.parent().unwrap(),\n+            _ => Path::new(\"\"),\n+        };\n+        list_submodules(&krate.module, parent, codemap, &mut result)?;\n+    }\n     result.insert(root_filename, &krate.module);\n     Ok(result)\n }\n@@ -41,7 +42,7 @@ fn list_submodules<'a>(\n     module: &'a ast::Mod,\n     search_dir: &Path,\n     codemap: &codemap::CodeMap,\n-    result: &mut BTreeMap<PathBuf, &'a ast::Mod>,\n+    result: &mut BTreeMap<FileName, &'a ast::Mod>,\n ) -> Result<(), io::Error> {\n     debug!(\"list_submodules: search_dir: {:?}\", search_dir);\n     for item in &module.items {\n@@ -54,7 +55,7 @@ fn list_submodules<'a>(\n                 } else {\n                     let mod_path = module_file(item.ident, &item.attrs, search_dir, codemap)?;\n                     let dir_path = mod_path.parent().unwrap().to_owned();\n-                    result.insert(mod_path, sub_mod);\n+                    result.insert(FileName::Real(mod_path), sub_mod);\n                     dir_path\n                 };\n                 list_submodules(sub_mod, &dir_path, codemap, result)?;"}, {"sha": "212e23f4f10a9044ccff97ceb87b28c95c0cde9c", "filename": "tests/system.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fad903fd14ad0df045dc574cac0717312860c380/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad903fd14ad0df045dc574cac0717312860c380/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=fad903fd14ad0df045dc574cac0717312860c380", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_private)]\n+\n #[macro_use]\n extern crate log;\n extern crate regex;\n@@ -28,10 +30,8 @@ use rustfmt::rustfmt_diff::*;\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n \n-fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> String {\n-    let path = dir_entry.expect(\"Couldn't get DirEntry\").path();\n-\n-    path.to_str().expect(\"Couldn't stringify path\").to_owned()\n+fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> PathBuf {\n+    dir_entry.expect(\"Couldn't get DirEntry\").path().to_owned()\n }\n \n // Integration tests. The files in the tests/source are formatted and compared\n@@ -68,12 +68,12 @@ fn coverage_tests() {\n fn checkstyle_test() {\n     let filename = \"tests/writemode/source/fn-single-line.rs\";\n     let expected_filename = \"tests/writemode/target/checkstyle.xml\";\n-    assert_output(filename, expected_filename);\n+    assert_output(Path::new(filename), Path::new(expected_filename));\n }\n \n // Helper function for comparing the results of rustfmt\n // to a known output file generated by one of the write modes.\n-fn assert_output(source: &str, expected_filename: &str) {\n+fn assert_output(source: &Path, expected_filename: &Path) {\n     let config = read_config(source);\n     let (file_map, _report) = format_file(source, &config);\n \n@@ -91,7 +91,7 @@ fn assert_output(source: &str, expected_filename: &str) {\n     let compare = make_diff(&expected_text, &output, DIFF_CONTEXT_SIZE);\n     if !compare.is_empty() {\n         let mut failures = HashMap::new();\n-        failures.insert(source.to_string(), compare);\n+        failures.insert(source.to_owned(), compare);\n         print_mismatches(failures);\n         assert!(false, \"Text does not match expected output\");\n     }\n@@ -121,8 +121,8 @@ fn self_tests() {\n         .chain(fs::read_dir(\"tests\").expect(\"Couldn't read tests dir\"))\n         .map(get_path_string);\n     // Hack because there's no `IntoIterator` impl for `[T; N]`.\n-    let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n-    let files = files.chain(Some(\"build.rs\".to_owned()).into_iter());\n+    let files = files.chain(Some(PathBuf::from(\"src/lib.rs\")).into_iter());\n+    let files = files.chain(Some(PathBuf::from(\"build.rs\")).into_iter());\n \n     let (reports, count, fails) = check_files(files);\n     let mut warnings = 0;\n@@ -152,9 +152,11 @@ fn stdin_formatting_smoke_test() {\n         format_input::<io::Stdout>(input, &config, None).unwrap();\n     assert!(error_summary.has_no_errors());\n     for &(ref file_name, ref text) in &file_map {\n-        if file_name == \"stdin\" {\n-            assert_eq!(text.to_string(), \"fn main() {}\\n\");\n-            return;\n+        if let FileName::Custom(ref file_name) = *file_name {\n+            if file_name == \"stdin\" {\n+                assert_eq!(text.to_string(), \"fn main() {}\\n\");\n+                return;\n+            }\n         }\n     }\n     panic!(\"no stdin\");\n@@ -197,14 +199,14 @@ fn format_lines_errors_are_reported() {\n // Returns the number of files checked and the number of failures.\n fn check_files<I>(files: I) -> (Vec<FormatReport>, u32, u32)\n where\n-    I: Iterator<Item = String>,\n+    I: Iterator<Item = PathBuf>,\n {\n     let mut count = 0;\n     let mut fails = 0;\n     let mut reports = vec![];\n \n-    for file_name in files.filter(|f| f.ends_with(\".rs\")) {\n-        debug!(\"Testing '{}'...\", file_name);\n+    for file_name in files.filter(|f| f.extension().map_or(false, |f| f == \"rs\")) {\n+        debug!(\"Testing '{}'...\", file_name.display());\n \n         match idempotent_check(file_name) {\n             Ok(ref report) if report.has_warnings() => {\n@@ -224,34 +226,29 @@ where\n     (reports, count, fails)\n }\n \n-fn print_mismatches(result: HashMap<String, Vec<Mismatch>>) {\n+fn print_mismatches(result: HashMap<PathBuf, Vec<Mismatch>>) {\n     let mut t = term::stdout().unwrap();\n \n     for (file_name, diff) in result {\n         print_diff(\n             diff,\n-            |line_num| format!(\"\\nMismatch at {}:{}:\", file_name, line_num),\n+            |line_num| format!(\"\\nMismatch at {}:{}:\", file_name.display(), line_num),\n             Color::Auto,\n         );\n     }\n \n     t.reset().unwrap();\n }\n \n-fn read_config(filename: &str) -> Config {\n+fn read_config(filename: &Path) -> Config {\n     let sig_comments = read_significant_comments(filename);\n     // Look for a config file... If there is a 'config' property in the significant comments, use\n     // that. Otherwise, if there are no significant comments at all, look for a config file with\n     // the same name as the test file.\n     let mut config = if !sig_comments.is_empty() {\n-        get_config(sig_comments.get(\"config\").map(|x| &(*x)[..]))\n+        get_config(sig_comments.get(\"config\").map(Path::new))\n     } else {\n-        get_config(\n-            Path::new(filename)\n-                .with_extension(\"toml\")\n-                .file_name()\n-                .and_then(std::ffi::OsStr::to_str),\n-        )\n+        get_config(filename.with_extension(\"toml\").file_name().map(Path::new))\n     };\n \n     for (key, val) in &sig_comments {\n@@ -274,7 +271,9 @@ fn format_file<P: Into<PathBuf>>(filepath: P, config: &Config) -> (FileMap, Form\n     (file_map, report)\n }\n \n-pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n+pub fn idempotent_check(\n+    filename: PathBuf,\n+) -> Result<FormatReport, HashMap<PathBuf, Vec<Mismatch>>> {\n     let sig_comments = read_significant_comments(&filename);\n     let config = read_config(&filename);\n     let (file_map, format_report) = format_file(filename, &config);\n@@ -286,7 +285,9 @@ pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String\n         write_system_newlines(&mut v, text, &config).unwrap();\n         // Won't panic, we are writing correct utf8.\n         let one_result = String::from_utf8(v).unwrap();\n-        write_result.insert(filename.clone(), one_result);\n+        if let FileName::Real(ref filename) = *filename {\n+            write_result.insert(filename.to_owned(), one_result);\n+        }\n     }\n \n     let target = sig_comments.get(\"target\").map(|x| &(*x)[..]);\n@@ -297,13 +298,13 @@ pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String\n // Reads test config file using the supplied (optional) file name. If there's no file name or the\n // file doesn't exist, just return the default config. Otherwise, the file must be read\n // successfully.\n-fn get_config(config_file: Option<&str>) -> Config {\n+fn get_config(config_file: Option<&Path>) -> Config {\n     let config_file_name = match config_file {\n         None => return Default::default(),\n         Some(file_name) => {\n-            let mut full_path = \"tests/config/\".to_owned();\n-            full_path.push_str(file_name);\n-            if !Path::new(&full_path).exists() {\n+            let mut full_path = PathBuf::from(\"tests/config/\");\n+            full_path.push(file_name);\n+            if !full_path.exists() {\n                 return Default::default();\n             };\n             full_path\n@@ -321,8 +322,9 @@ fn get_config(config_file: Option<&str>) -> Config {\n \n // Reads significant comments of the form: // rustfmt-key: value\n // into a hash map.\n-fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n-    let file = fs::File::open(file_name).expect(&format!(\"Couldn't read file {}\", file_name));\n+fn read_significant_comments(file_name: &Path) -> HashMap<String, String> {\n+    let file =\n+        fs::File::open(file_name).expect(&format!(\"Couldn't read file {}\", file_name.display()));\n     let reader = BufReader::new(file);\n     let pattern = r\"^\\s*//\\s*rustfmt-([^:]+):\\s*(\\S+)\";\n     let regex = regex::Regex::new(pattern).expect(\"Failed creating pattern 1\");\n@@ -357,9 +359,9 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n // Compare output to input.\n // TODO: needs a better name, more explanation.\n fn handle_result(\n-    result: HashMap<String, String>,\n+    result: HashMap<PathBuf, String>,\n     target: Option<&str>,\n-) -> Result<(), HashMap<String, Vec<Mismatch>>> {\n+) -> Result<(), HashMap<PathBuf, Vec<Mismatch>>> {\n     let mut failures = HashMap::new();\n \n     for (file_name, fmt_text) in result {\n@@ -391,15 +393,21 @@ fn handle_result(\n }\n \n // Map source file paths to their target paths.\n-fn get_target(file_name: &str, target: Option<&str>) -> String {\n-    if file_name.contains(\"source\") {\n-        let target_file_name = file_name.replace(\"source\", \"target\");\n+fn get_target(file_name: &Path, target: Option<&str>) -> PathBuf {\n+    if let Some(n) = file_name\n+        .components()\n+        .position(|c| c.as_os_str() == \"source\")\n+    {\n+        let mut target_file_name = PathBuf::new();\n+        for (i, c) in file_name.components().enumerate() {\n+            if i == n {\n+                target_file_name.push(\"target\");\n+            } else {\n+                target_file_name.push(c.as_os_str());\n+            }\n+        }\n         if let Some(replace_name) = target {\n-            Path::new(&target_file_name)\n-                .with_file_name(replace_name)\n-                .into_os_string()\n-                .into_string()\n-                .unwrap()\n+            target_file_name.with_file_name(replace_name)\n         } else {\n             target_file_name\n         }"}]}