{"sha": "1864970430d967699142b3e610f818d2f03b496e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NjQ5NzA0MzBkOTY3Njk5MTQyYjNlNjEwZjgxOGQyZjAzYjQ5NmU=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-04-11T11:44:45Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-04-17T18:58:18Z"}, "message": "Add the try_trait_v2 library basics\n\nNo compiler changes as part of this -- just new unstable traits and impls thereof.\n\nThe goal here is to add the things that aren't going to break anything, to keep the feature implementation simpler in the next PR.", "tree": {"sha": "0b5db0c12498cf70b8e18d77b1aab8ae20fe4373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b5db0c12498cf70b8e18d77b1aab8ae20fe4373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1864970430d967699142b3e610f818d2f03b496e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1864970430d967699142b3e610f818d2f03b496e", "html_url": "https://github.com/rust-lang/rust/commit/1864970430d967699142b3e610f818d2f03b496e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1864970430d967699142b3e610f818d2f03b496e/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "361bfce305b8829eda7f3d133fe82a118685de1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/361bfce305b8829eda7f3d133fe82a118685de1f", "html_url": "https://github.com/rust-lang/rust/commit/361bfce305b8829eda7f3d133fe82a118685de1f"}], "stats": {"total": 394, "additions": 389, "deletions": 5}, "files": [{"sha": "ecaff053bd5c0ebe49471c176c3ade6b909fdc09", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=1864970430d967699142b3e610f818d2f03b496e", "patch": "@@ -1,4 +1,5 @@\n-use crate::ops::Try;\n+use crate::convert;\n+use crate::ops::{self, Try};\n \n /// Used to tell an operation whether it should exit early or go on as usual.\n ///\n@@ -81,6 +82,35 @@ impl<B, C> Try for ControlFlow<B, C> {\n     }\n }\n \n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<B, C> ops::TryV2 for ControlFlow<B, C> {\n+    type Output = C;\n+    type Residual = ControlFlow<B, convert::Infallible>;\n+\n+    #[inline]\n+    fn from_output(output: Self::Output) -> Self {\n+        ControlFlow::Continue(output)\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            ControlFlow::Continue(c) => ControlFlow::Continue(c),\n+            ControlFlow::Break(b) => ControlFlow::Break(ControlFlow::Break(b)),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<B, C> ops::FromResidual for ControlFlow<B, C> {\n+    #[inline]\n+    fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {\n+        match residual {\n+            ControlFlow::Break(b) => ControlFlow::Break(b),\n+        }\n+    }\n+}\n+\n impl<B, C> ControlFlow<B, C> {\n     /// Returns `true` if this is a `Break` variant.\n     ///"}, {"sha": "1b07936ccde1dceb2bcbd551a6c2d2952cd080bc", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=1864970430d967699142b3e610f818d2f03b496e", "patch": "@@ -148,6 +148,7 @@ mod generator;\n mod index;\n mod range;\n mod r#try;\n+mod try_trait;\n mod unsize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -184,6 +185,12 @@ pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::r#try::Try;\n \n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+pub use self::try_trait::FromResidual;\n+\n+#[unstable(feature = \"try_trait_transition\", reason = \"for bootstrap\", issue = \"none\")]\n+pub use self::try_trait::Try as TryV2;\n+\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub use self::generator::{Generator, GeneratorState};\n "}, {"sha": "2f03ab9eac257ee311b219db5d862fb91f8e0e00", "filename": "library/core/src/ops/try_trait.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=1864970430d967699142b3e610f818d2f03b496e", "patch": "@@ -0,0 +1,225 @@\n+use crate::ops::ControlFlow;\n+\n+/// The trait used for a variety of operations related to short-circuits,\n+/// such as the `?` operator, `try {}` blocks, and `try_*` methods.\n+///\n+/// # Using `Try` in Generic Code\n+///\n+/// `Iterator::try_fold` was stabilized to call back in Rust 1.27, but\n+/// this trait is much newer.  To illustrate the various associated types and\n+/// methods, let's implement our own version.\n+///\n+/// As a reminder, an infallible version of a fold looks something like this:\n+/// ```\n+/// fn simple_fold<A, T>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> A,\n+/// ) -> A {\n+///     for x in iter {\n+///         accum = f(accum, x);\n+///     }\n+///     accum\n+/// }\n+/// ```\n+///\n+/// So instead of `f` returning just an `A`, we'll need it to return some other\n+/// type that produces an `A` in the \"don't short circuit\" path.  Conveniently,\n+/// that's also the type we need to return from the function.\n+///\n+/// Let's add a new generic parameter `R` for that type, and bound it to the\n+/// output type that we want:\n+/// ```\n+/// # #![feature(try_trait_v2)]\n+/// # #![feature(try_trait_transition)]\n+/// # use std::ops::TryV2 as Try;\n+/// fn simple_try_fold_1<A, T, R: Try<Output = A>>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> R,\n+/// ) -> R {\n+///     todo!()\n+/// }\n+/// ```\n+///\n+/// `Try` is also the trait we need to get the updated accumulator from `f`'s return\n+/// value and return the result if we manage to get through the entire iterator:\n+/// ```\n+/// # #![feature(try_trait_v2)]\n+/// # #![feature(try_trait_transition)]\n+/// # #![feature(control_flow_enum)]\n+/// # use std::ops::{ControlFlow, TryV2 as Try};\n+/// fn simple_try_fold_2<A, T, R: Try<Output = A>>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> R,\n+/// ) -> R {\n+///     for x in iter {\n+///         let cf = f(accum, x).branch();\n+///         match cf {\n+///             ControlFlow::Continue(a) => accum = a,\n+///             ControlFlow::Break(_) => todo!(),\n+///         }\n+///     }\n+///     R::from_output(accum)\n+/// }\n+/// ```\n+///\n+/// We'll also need `FromResidual::from_residual` to turn the residual back into\n+/// the original type.  But because it's a supertrait of `Try`, we don't need to\n+/// mention it in the bounds.  All types which implement `Try` can always be\n+/// recreated from their corresponding residual, so we'll just call it:\n+/// ```\n+/// # #![feature(try_trait_v2)]\n+/// # #![feature(try_trait_transition)]\n+/// # #![feature(control_flow_enum)]\n+/// # use std::ops::{ControlFlow, TryV2 as Try};\n+/// pub fn simple_try_fold_3<A, T, R: Try<Output = A>>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> R,\n+/// ) -> R {\n+///     for x in iter {\n+///         let cf = f(accum, x).branch();\n+///         match cf {\n+///             ControlFlow::Continue(a) => accum = a,\n+///             ControlFlow::Break(r) => return R::from_residual(r),\n+///         }\n+///     }\n+///     R::from_output(accum)\n+/// }\n+/// ```\n+///\n+/// But this \"call `branch`, then `match` on it, and `return` if it was a\n+/// `Break`\" is exactly what happens inside the `?` operator.  So rather than\n+/// do all this manually, we can just use `?` instead:\n+/// ```compile_fail (enable again once ? converts to the new trait)\n+/// # #![feature(try_trait_v2)]\n+/// # #![feature(try_trait_transition)]\n+/// # use std::ops::TryV2 as Try;\n+/// fn simple_try_fold<A, T, R: Try<Output = A>>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> R,\n+/// ) -> R {\n+///     for x in iter {\n+///         accum = f(accum, x)?;\n+///     }\n+///     R::from_output(accum)\n+/// }\n+/// ```\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+pub trait Try: FromResidual {\n+    /// The type of the value produced by `?` when *not* short-circuiting.\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    type Output;\n+\n+    /// The type of the value passed to [`FromResidual::from_residual`]\n+    /// as part of `?` when short-circuiting.\n+    ///\n+    /// This represents the possible values of the `Self` type which are *not*\n+    /// represented by the `Output` type.\n+    ///\n+    /// # Note to Implementors\n+    ///\n+    /// The choice of this type is critical to interconversion.\n+    /// Unlike the `Output` type, which will often be a raw generic type,\n+    /// this type is typically a newtype of some sort to \"color\" the type\n+    /// so that it's distinguishable from the residuals of other types.\n+    ///\n+    /// This is why `Result<T, E>::Residual` is not `E`, but `Result<Infallible, E>`.\n+    /// That way it's distinct from `ControlFlow<E>::Residual`, for example,\n+    /// and thus `?` on `ControlFlow` cannot be used in a method returning `Result`.\n+    ///\n+    /// In a type that's generic on a parameter that's used as the `Output` type,\n+    /// call it `Foo<T> : Try` where `Foo<T>::Output == T`, it's typically easiest\n+    /// to make the corresponding `Residual` type by filling in that generic\n+    /// with an uninhabited type: `type Residual = Foo<Infallible>;`.\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    type Residual;\n+\n+    /// Wraps up a value such that `?` on the value will produce the original value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_trait_v2)]\n+    /// #![feature(control_flow_enum)]\n+    /// #![feature(try_trait_transition)]\n+    /// use std::ops::TryV2 as Try;\n+    ///\n+    /// assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n+    /// assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n+    /// assert_eq!(\n+    ///     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n+    ///     std::ops::ControlFlow::Continue(5),\n+    /// );\n+    ///\n+    /// # fn make_question_mark_work() -> Option<()> {\n+    /// assert_eq!(Option::from_output(4)?, 4);\n+    /// # None }\n+    /// # make_question_mark_work();\n+    ///\n+    /// // This is used, for example, on the accumulator in `try_fold`:\n+    /// let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n+    /// assert_eq!(r, Some(4));\n+    /// ```\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    fn from_output(output: Self::Output) -> Self;\n+\n+    /// Used in `?` to decide whether the operator should produce a value\n+    /// (because this returned [`ControlFlow::Continue`])\n+    /// or propagate a value back to the caller\n+    /// (because this returned [`ControlFlow::Break`]).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_trait_v2)]\n+    /// #![feature(control_flow_enum)]\n+    /// #![feature(try_trait_transition)]\n+    /// use std::ops::{ControlFlow, TryV2 as Try};\n+    ///\n+    /// assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n+    /// assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n+    ///\n+    /// assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n+    /// assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n+    ///\n+    /// assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n+    /// assert_eq!(\n+    ///     ControlFlow::<_, String>::Break(3).branch(),\n+    ///     ControlFlow::Break(ControlFlow::Break(3)),\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;\n+}\n+\n+/// Used to specify which residuals can be converted into which [`Try`] types.\n+///\n+/// Every `Try` type needs to be recreatable from its own associated\n+/// `Residual` type, but can also have additional `FromResidual` implementations\n+/// to support interconversion with other `Try` types.\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+pub trait FromResidual<R = <Self as Try>::Residual> {\n+    /// Produces the return value of the function from the residual\n+    /// when the `?` operator results in an early exit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_trait_v2)]\n+    /// #![feature(control_flow_enum)]\n+    /// use std::ops::{ControlFlow, FromResidual};\n+    ///\n+    /// assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n+    /// assert_eq!(Option::<String>::from_residual(None), None);\n+    /// assert_eq!(\n+    ///     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n+    ///     ControlFlow::Break(5),\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    fn from_residual(residual: R) -> Self;\n+}"}, {"sha": "dd44bb4c6ee82c74bcebf82dcf3bfffe8acf1d68", "filename": "library/core/src/option.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=1864970430d967699142b3e610f818d2f03b496e", "patch": "@@ -150,8 +150,8 @@\n use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n use crate::pin::Pin;\n use crate::{\n-    hint, mem,\n-    ops::{self, Deref, DerefMut},\n+    convert, hint, mem,\n+    ops::{self, ControlFlow, Deref, DerefMut},\n };\n \n /// The `Option` type. See [the module level documentation](self) for more.\n@@ -1660,6 +1660,35 @@ impl<T> ops::Try for Option<T> {\n     }\n }\n \n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T> ops::TryV2 for Option<T> {\n+    type Output = T;\n+    type Residual = Option<convert::Infallible>;\n+\n+    #[inline]\n+    fn from_output(output: Self::Output) -> Self {\n+        Some(output)\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            Some(v) => ControlFlow::Continue(v),\n+            None => ControlFlow::Break(None),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T> ops::FromResidual for Option<T> {\n+    #[inline]\n+    fn from_residual(residual: Option<convert::Infallible>) -> Self {\n+        match residual {\n+            None => None,\n+        }\n+    }\n+}\n+\n impl<T> Option<Option<T>> {\n     /// Converts from `Option<Option<T>>` to `Option<T>`\n     ///"}, {"sha": "bac02104c3488ac4baecefb1d6ac7f21053cce50", "filename": "library/core/src/result.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=1864970430d967699142b3e610f818d2f03b496e", "patch": "@@ -228,7 +228,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{self, FromIterator, FusedIterator, TrustedLen};\n-use crate::ops::{self, Deref, DerefMut};\n+use crate::ops::{self, ControlFlow, Deref, DerefMut};\n use crate::{convert, fmt, hint};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n@@ -1646,3 +1646,32 @@ impl<T, E> ops::Try for Result<T, E> {\n         Err(v)\n     }\n }\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E> ops::TryV2 for Result<T, E> {\n+    type Output = T;\n+    type Residual = Result<convert::Infallible, E>;\n+\n+    #[inline]\n+    fn from_output(output: Self::Output) -> Self {\n+        Ok(output)\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            Ok(v) => ControlFlow::Continue(v),\n+            Err(e) => ControlFlow::Break(Err(e)),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Result<T, F> {\n+    #[inline]\n+    fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n+        match residual {\n+            Err(e) => Err(From::from(e)),\n+        }\n+    }\n+}"}, {"sha": "2765c21a46db11b1e2ad5d142255319d126c8e7c", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1864970430d967699142b3e610f818d2f03b496e/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=1864970430d967699142b3e610f818d2f03b496e", "patch": "@@ -1,6 +1,7 @@\n #![stable(feature = \"futures_api\", since = \"1.36.0\")]\n \n-use crate::ops::Try;\n+use crate::convert;\n+use crate::ops::{self, ControlFlow, Try};\n use crate::result::Result;\n \n /// Indicates whether a value is available or if the current task has been\n@@ -152,6 +153,36 @@ impl<T, E> Try for Poll<Result<T, E>> {\n     }\n }\n \n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E> ops::TryV2 for Poll<Result<T, E>> {\n+    type Output = Poll<T>;\n+    type Residual = Result<convert::Infallible, E>;\n+\n+    #[inline]\n+    fn from_output(c: Self::Output) -> Self {\n+        c.map(Ok)\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            Poll::Ready(Ok(x)) => ControlFlow::Continue(Poll::Ready(x)),\n+            Poll::Ready(Err(e)) => ControlFlow::Break(Err(e)),\n+            Poll::Pending => ControlFlow::Continue(Poll::Pending),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Poll<Result<T, F>> {\n+    #[inline]\n+    fn from_residual(x: Result<convert::Infallible, E>) -> Self {\n+        match x {\n+            Err(e) => Poll::Ready(Err(From::from(e))),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<T, E> Try for Poll<Option<Result<T, E>>> {\n     type Ok = Poll<Option<T>>;\n@@ -177,3 +208,36 @@ impl<T, E> Try for Poll<Option<Result<T, E>>> {\n         x.map(|x| x.map(Ok))\n     }\n }\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E> ops::TryV2 for Poll<Option<Result<T, E>>> {\n+    type Output = Poll<Option<T>>;\n+    type Residual = Result<convert::Infallible, E>;\n+\n+    #[inline]\n+    fn from_output(c: Self::Output) -> Self {\n+        c.map(|x| x.map(Ok))\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            Poll::Ready(Some(Ok(x))) => ControlFlow::Continue(Poll::Ready(Some(x))),\n+            Poll::Ready(Some(Err(e))) => ControlFlow::Break(Err(e)),\n+            Poll::Ready(None) => ControlFlow::Continue(Poll::Ready(None)),\n+            Poll::Pending => ControlFlow::Continue(Poll::Pending),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>>\n+    for Poll<Option<Result<T, F>>>\n+{\n+    #[inline]\n+    fn from_residual(x: Result<convert::Infallible, E>) -> Self {\n+        match x {\n+            Err(e) => Poll::Ready(Some(Err(From::from(e)))),\n+        }\n+    }\n+}"}]}