{"sha": "e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "node_id": "C_kwDOAAsO6NoAKGUxYjAyMGRmOWY3MmVhYjdlOGIzZTM4YTUyNjNkZGRhNTRjZTE4ZTE", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-05-26T10:32:22Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-06-04T07:51:49Z"}, "message": "Use `load`-`store` instead of `memcpy` for short integer arrays", "tree": {"sha": "8cfd4367532aceb4f6e85596c1f2cc08fec799d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cfd4367532aceb4f6e85596c1f2cc08fec799d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "html_url": "https://github.com/rust-lang/rust/commit/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cce0b52e7bc7ca2b95fe9f95c8528cd87e787e33", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce0b52e7bc7ca2b95fe9f95c8528cd87e787e33", "html_url": "https://github.com/rust-lang/rust/commit/cce0b52e7bc7ca2b95fe9f95c8528cd87e787e33"}], "stats": {"total": 152, "additions": 136, "deletions": 16}, "files": [{"sha": "4ffa2b9c6a39d809423ffa8304538bb40d91d228", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "patch": "@@ -288,6 +288,9 @@ impl<'ll, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn reg_backend_type(&self, ty: &Reg) -> &'ll Type {\n         ty.llvm_type(self)\n     }\n+    fn scalar_copy_backend_type(&self, layout: TyAndLayout<'tcx>) -> Option<Self::Type> {\n+        layout.scalar_copy_llvm_type(self)\n+    }\n }\n \n impl<'ll, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'ll, 'tcx> {"}, {"sha": "3339e4e07edd38c705309ac7d481c84b9688f4aa", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n+use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::{Abi, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{PointeeInfo, Scalar, Size, TyAbiInterface, Variants};\n@@ -192,6 +193,7 @@ pub trait LayoutLlvmExt<'tcx> {\n     ) -> &'a Type;\n     fn llvm_field_index<'a>(&self, cx: &CodegenCx<'a, 'tcx>, index: usize) -> u64;\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo>;\n+    fn scalar_copy_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<&'a Type>;\n }\n \n impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n@@ -414,4 +416,35 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result\n     }\n+\n+    fn scalar_copy_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<&'a Type> {\n+        debug_assert!(self.is_sized());\n+\n+        // FIXME: this is a fairly arbitrary choice, but 128 bits on WASM\n+        // (matching the 128-bit SIMD types proposal) and 256 bits on x64\n+        // (like AVX2 registers) seems at least like a tolerable starting point.\n+        let threshold = cx.data_layout().pointer_size * 4;\n+        if self.layout.size() > threshold {\n+            return None;\n+        }\n+\n+        // Vectors, even for non-power-of-two sizes, have the same layout as\n+        // arrays but don't count as aggregate types\n+        if let FieldsShape::Array { count, .. } = self.layout.fields()\n+            && let element = self.field(cx, 0)\n+            && element.ty.is_integral()\n+        {\n+            // `cx.type_ix(bits)` is tempting here, but while that works great\n+            // for things that *stay* as memory-to-memory copies, it also ends\n+            // up suppressing vectorization as it introduces shifts when it\n+            // extracts all the individual values.\n+\n+            let ety = element.llvm_type(cx);\n+            return Some(cx.type_vector(ety, *count));\n+        }\n+\n+        // FIXME: The above only handled integer arrays; surely more things\n+        // would also be possible. Be careful about provenance, though!\n+        None\n+    }\n }"}, {"sha": "dc4a28c866ff3ffe24d85c6134d556a4520d0c1f", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "patch": "@@ -380,7 +380,19 @@ pub fn memcpy_ty<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         return;\n     }\n \n-    bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n+    if flags == MemFlags::empty()\n+        && let Some(bty) = bx.cx().scalar_copy_backend_type(layout)\n+    {\n+        // I look forward to only supporting opaque pointers\n+        let pty = bx.type_ptr_to(bty);\n+        let src = bx.pointercast(src, pty);\n+        let dst = bx.pointercast(dst, pty);\n+\n+        let temp = bx.load(bty, src, src_align);\n+        bx.store(temp, dst, dst_align);\n+    } else {\n+        bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n+    }\n }\n \n pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>("}, {"sha": "e64417e1a4a69873b4d61d3873b035ca5c535167", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "patch": "@@ -126,6 +126,28 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n         index: usize,\n         immediate: bool,\n     ) -> Self::Type;\n+\n+    /// A type that can be used in a [`super::BuilderMethods::load`] +\n+    /// [`super::BuilderMethods::store`] pair to implement a *typed* copy,\n+    /// such as a MIR `*_0 = *_1`.\n+    ///\n+    /// It's always legal to return `None` here, as the provided impl does,\n+    /// in which case callers should use [`super::BuilderMethods::memcpy`]\n+    /// instead of the `load`+`store` pair.\n+    ///\n+    /// This can be helpful for things like arrays, where the LLVM backend type\n+    /// `[3 x i16]` optimizes to three separate loads and stores, but it can\n+    /// instead be copied via an `i48` that stays as the single `load`+`store`.\n+    /// (As of 2023-05 LLVM cannot necessarily optimize away a `memcpy` in these\n+    /// cases, due to `poison` handling, but in codegen we have more information\n+    /// about the type invariants, so can emit something better instead.)\n+    ///\n+    /// This *should* return `None` for particularly-large types, where leaving\n+    /// the `memcpy` may well be important to avoid code size explosion.\n+    fn scalar_copy_backend_type(&self, layout: TyAndLayout<'tcx>) -> Option<Self::Type> {\n+        let _ = layout;\n+        None\n+    }\n }\n \n // For backends that support CFI using type membership (i.e., testing whether a given pointer is"}, {"sha": "98488eb92ee0256132a7f8cc5e3a750fd8595a8d", "filename": "tests/codegen/array-codegen.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/tests%2Fcodegen%2Farray-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/tests%2Fcodegen%2Farray-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-codegen.rs?ref=e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+// min-llvm-version: 15.0 (for opaque pointers)\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @array_load\n+#[no_mangle]\n+pub fn array_load(a: &[u8; 4]) -> [u8; 4] {\n+    // CHECK: %0 = alloca [4 x i8], align 1\n+    // CHECK: %[[TEMP1:.+]] = load <4 x i8>, ptr %a, align 1\n+    // CHECK: store <4 x i8> %[[TEMP1]], ptr %0, align 1\n+    // CHECK: %[[TEMP2:.+]] = load i32, ptr %0, align 1\n+    // CHECK: ret i32 %[[TEMP2]]\n+    *a\n+}\n+\n+// CHECK-LABEL: @array_store\n+#[no_mangle]\n+pub fn array_store(a: [u8; 4], p: &mut [u8; 4]) {\n+    // CHECK: %a = alloca [4 x i8]\n+    // CHECK: %[[TEMP:.+]] = load <4 x i8>, ptr %a, align 1\n+    // CHECK-NEXT: store <4 x i8> %[[TEMP]], ptr %p, align 1\n+    *p = a;\n+}\n+\n+// CHECK-LABEL: @array_copy\n+#[no_mangle]\n+pub fn array_copy(a: &[u8; 4], p: &mut [u8; 4]) {\n+    // CHECK: %[[LOCAL:.+]] = alloca [4 x i8], align 1\n+    // CHECK: %[[TEMP1:.+]] = load <4 x i8>, ptr %a, align 1\n+    // CHECK: store <4 x i8> %[[TEMP1]], ptr %[[LOCAL]], align 1\n+    // CHECK: %[[TEMP2:.+]] = load <4 x i8>, ptr %[[LOCAL]], align 1\n+    // CHECK: store <4 x i8> %[[TEMP2]], ptr %p, align 1\n+    *p = *a;\n+}"}, {"sha": "6151177de15b27247ff7de809567c5848d31f6a4", "filename": "tests/codegen/mem-replace-simple-type.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/tests%2Fcodegen%2Fmem-replace-simple-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/tests%2Fcodegen%2Fmem-replace-simple-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-simple-type.rs?ref=e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "patch": "@@ -32,3 +32,14 @@ pub fn replace_ref_str<'a>(r: &mut &'a str, v: &'a str) -> &'a str {\n     // CHECK: ret { ptr, i64 } %[[P2]]\n     std::mem::replace(r, v)\n }\n+\n+#[no_mangle]\n+// CHECK-LABEL: @replace_short_array(\n+pub fn replace_short_array(r: &mut [u32; 3], v: [u32; 3]) -> [u32; 3] {\n+    // CHECK-NOT: alloca\n+    // CHECK: %[[R:.+]] = load <3 x i32>, ptr %r, align 4\n+    // CHECK: store <3 x i32> %[[R]], ptr %0\n+    // CHECK: %[[V:.+]] = load <3 x i32>, ptr %v, align 4\n+    // CHECK: store <3 x i32> %[[V]], ptr %r\n+    std::mem::replace(r, v)\n+}"}, {"sha": "3472a42b0e65e2a4f3e61a0c354229d7bb4e0c21", "filename": "tests/codegen/swap-simd-types.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/tests%2Fcodegen%2Fswap-simd-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/tests%2Fcodegen%2Fswap-simd-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fswap-simd-types.rs?ref=e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "patch": "@@ -30,3 +30,12 @@ pub fn swap_m256_slice(x: &mut [__m256], y: &mut [__m256]) {\n         x.swap_with_slice(y);\n     }\n }\n+\n+// CHECK-LABEL: @swap_bytes32\n+#[no_mangle]\n+pub fn swap_bytes32(x: &mut [u8; 32], y: &mut [u8; 32]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <32 x i8>{{.+}}align 1\n+// CHECK: store <32 x i8>{{.+}}align 1\n+    swap(x, y)\n+}"}, {"sha": "419645a3fc6bc87822edc46603e1320c2c8ad703", "filename": "tests/codegen/swap-small-types.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/tests%2Fcodegen%2Fswap-small-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b020df9f72eab7e8b3e38a5263ddda54ce18e1/tests%2Fcodegen%2Fswap-small-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fswap-small-types.rs?ref=e1b020df9f72eab7e8b3e38a5263ddda54ce18e1", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O\n+// compile-flags: -O -Z merge-functions=disabled\n // only-x86_64\n // ignore-debug: the debug assertions get in the way\n \n@@ -12,13 +12,10 @@ type RGB48 = [u16; 3];\n #[no_mangle]\n pub fn swap_rgb48_manually(x: &mut RGB48, y: &mut RGB48) {\n     // CHECK-NOT: alloca\n-    // CHECK: %temp = alloca [3 x i16]\n-    // CHECK-NOT: alloca\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{.+}} %temp, {{.+}} %x, {{.+}} 6, {{.+}})\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{.+}} %x, {{.+}} %y, {{.+}} 6, {{.+}})\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{.+}} %y, {{.+}} %temp, {{.+}} 6, {{.+}})\n-    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: %[[TEMP0:.+]] = load <3 x i16>, ptr %x, align 2\n+    // CHECK: %[[TEMP1:.+]] = load <3 x i16>, ptr %y, align 2\n+    // CHECK: store <3 x i16> %[[TEMP1]], ptr %x, align 2\n+    // CHECK: store <3 x i16> %[[TEMP0]], ptr %y, align 2\n \n     let temp = *x;\n     *x = *y;\n@@ -28,13 +25,11 @@ pub fn swap_rgb48_manually(x: &mut RGB48, y: &mut RGB48) {\n // CHECK-LABEL: @swap_rgb48\n #[no_mangle]\n pub fn swap_rgb48(x: &mut RGB48, y: &mut RGB48) {\n-    // FIXME MIR inlining messes up LLVM optimizations.\n-    // If these checks start failing, please update this test.\n-    // CHECK: alloca [3 x i16]\n-    // CHECK: call void @llvm.memcpy\n-// WOULD-CHECK-NOT: alloca\n-// WOULD-CHECK: load i48\n-// WOULD-CHECK: store i48\n+    // CHECK-NOT: alloca\n+    // CHECK: load <3 x i16>\n+    // CHECK: load <3 x i16>\n+    // CHECK: store <3 x i16>\n+    // CHECK: store <3 x i16>\n     swap(x, y)\n }\n "}]}