{"sha": "8a27c19c92b293051bd5fa8c3bd18082d8d7dd51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMjdjMTljOTJiMjkzMDUxYmQ1ZmE4YzNiZDE4MDgyZDhkN2RkNTE=", "commit": {"author": {"name": "Linus F\u00e4rnstrand", "email": "faern@faern.net", "date": "2018-06-02T09:24:32Z"}, "committer": {"name": "Linus F\u00e4rnstrand", "email": "faern@faern.net", "date": "2018-06-02T11:57:31Z"}, "message": "Make integer methods non-const in stage0", "tree": {"sha": "6b017f6614fe906bd19e2fdcf5d1e7d9bbec5d70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b017f6614fe906bd19e2fdcf5d1e7d9bbec5d70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a27c19c92b293051bd5fa8c3bd18082d8d7dd51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a27c19c92b293051bd5fa8c3bd18082d8d7dd51", "html_url": "https://github.com/rust-lang/rust/commit/8a27c19c92b293051bd5fa8c3bd18082d8d7dd51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a27c19c92b293051bd5fa8c3bd18082d8d7dd51/comments", "author": {"login": "faern", "id": 332294, "node_id": "MDQ6VXNlcjMzMjI5NA==", "avatar_url": "https://avatars.githubusercontent.com/u/332294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/faern", "html_url": "https://github.com/faern", "followers_url": "https://api.github.com/users/faern/followers", "following_url": "https://api.github.com/users/faern/following{/other_user}", "gists_url": "https://api.github.com/users/faern/gists{/gist_id}", "starred_url": "https://api.github.com/users/faern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/faern/subscriptions", "organizations_url": "https://api.github.com/users/faern/orgs", "repos_url": "https://api.github.com/users/faern/repos", "events_url": "https://api.github.com/users/faern/events{/privacy}", "received_events_url": "https://api.github.com/users/faern/received_events", "type": "User", "site_admin": false}, "committer": {"login": "faern", "id": 332294, "node_id": "MDQ6VXNlcjMzMjI5NA==", "avatar_url": "https://avatars.githubusercontent.com/u/332294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/faern", "html_url": "https://github.com/faern", "followers_url": "https://api.github.com/users/faern/followers", "following_url": "https://api.github.com/users/faern/following{/other_user}", "gists_url": "https://api.github.com/users/faern/gists{/gist_id}", "starred_url": "https://api.github.com/users/faern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/faern/subscriptions", "organizations_url": "https://api.github.com/users/faern/orgs", "repos_url": "https://api.github.com/users/faern/repos", "events_url": "https://api.github.com/users/faern/events{/privacy}", "received_events_url": "https://api.github.com/users/faern/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b9ab8939efc1a38a7a5398a069517466fd88d38", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b9ab8939efc1a38a7a5398a069517466fd88d38", "html_url": "https://github.com/rust-lang/rust/commit/1b9ab8939efc1a38a7a5398a069517466fd88d38"}], "stats": {"total": 192, "additions": 192, "deletions": 0}, "files": [{"sha": "26dd08b10b9b8778cb64b810a33022589eef60d9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/8a27c19c92b293051bd5fa8c3bd18082d8d7dd51/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a27c19c92b293051bd5fa8c3bd18082d8d7dd51/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8a27c19c92b293051bd5fa8c3bd18082d8d7dd51", "patch": "@@ -267,11 +267,20 @@ $EndFeature, \"\n ```\n \"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n+        }\n+\n         doc_comment! {\n             concat!(\"Returns the number of zeros in the binary representation of `self`.\n \n@@ -283,13 +292,24 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentatio\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n \n@@ -304,13 +324,24 @@ assert_eq!(n.leading_zeros(), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn leading_zeros(self) -> u32 {\n                 (self as $UnsignedT).leading_zeros()\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn leading_zeros(self) -> u32 {\n+                (self as $UnsignedT).leading_zeros()\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Returns the number of trailing zeros in the binary representation of `self`.\n \n@@ -325,13 +356,24 @@ assert_eq!(n.trailing_zeros(), 2);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn trailing_zeros(self) -> u32 {\n                 (self as $UnsignedT).trailing_zeros()\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn trailing_zeros(self) -> u32 {\n+                (self as $UnsignedT).trailing_zeros()\n+            }\n+        }\n+\n         /// Shifts the bits to the left by a specified amount, `n`,\n         /// wrapping the truncated bits to the end of the resulting integer.\n         ///\n@@ -400,12 +442,21 @@ $EndFeature, \"\n         /// assert_eq!(m, 21760);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(not(stage0))]\n         #[rustc_const_unstable(feature = \"const_int_ops\")]\n         #[inline]\n         pub const fn swap_bytes(self) -> Self {\n             (self as $UnsignedT).swap_bytes() as Self\n         }\n \n+        /// Dummy docs. See !stage0 documentation.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n+        #[inline]\n+        pub fn swap_bytes(self) -> Self {\n+            (self as $UnsignedT).swap_bytes() as Self\n+        }\n+\n         /// Reverses the bit pattern of the integer.\n         ///\n         /// # Examples\n@@ -452,6 +503,7 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn from_be(x: Self) -> Self {\n@@ -466,6 +518,16 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn from_be(x: Self) -> Self {\n+                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts an integer from little endian to the target's endianness.\n \n@@ -486,6 +548,7 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn from_le(x: Self) -> Self {\n@@ -500,6 +563,16 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn from_le(x: Self) -> Self {\n+                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts `self` to big endian from the target's endianness.\n \n@@ -520,6 +593,7 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn to_be(self) -> Self { // or not to be?\n@@ -534,6 +608,16 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn to_be(self) -> Self { // or not to be?\n+                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts `self` to little endian from the target's endianness.\n \n@@ -554,6 +638,7 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn to_le(self) -> Self {\n@@ -568,6 +653,16 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn to_le(self) -> Self {\n+                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n@@ -2070,13 +2165,24 @@ Basic usage:\n assert_eq!(n.count_ones(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn count_ones(self) -> u32 {\n                 unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn count_ones(self) -> u32 {\n+                unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Returns the number of zeros in the binary representation of `self`.\n \n@@ -2088,13 +2194,24 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n \n@@ -2108,13 +2225,24 @@ Basic usage:\n assert_eq!(n.leading_zeros(), 2);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn leading_zeros(self) -> u32 {\n                 unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn leading_zeros(self) -> u32 {\n+                unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Returns the number of trailing zeros in the binary representation\n of `self`.\n@@ -2129,13 +2257,24 @@ Basic usage:\n assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn trailing_zeros(self) -> u32 {\n                 unsafe { uint_cttz_call!(self, $BITS) as u32 }\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn trailing_zeros(self) -> u32 {\n+                unsafe { uint_cttz_call!(self, $BITS) as u32 }\n+            }\n+        }\n+\n         /// Shifts the bits to the left by a specified amount, `n`,\n         /// wrapping the truncated bits to the end of the resulting integer.\n         ///\n@@ -2208,12 +2347,21 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n         /// assert_eq!(m, 21760);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(not(stage0))]\n         #[rustc_const_unstable(feature = \"const_int_ops\")]\n         #[inline]\n         pub const fn swap_bytes(self) -> Self {\n             unsafe { intrinsics::bswap(self as $ActualT) as Self }\n         }\n \n+        /// Dummy docs. See !stage0 documentation.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n+        #[inline]\n+        pub fn swap_bytes(self) -> Self {\n+            unsafe { intrinsics::bswap(self as $ActualT) as Self }\n+        }\n+\n         /// Reverses the bit pattern of the integer.\n         ///\n         /// # Examples\n@@ -2260,6 +2408,7 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn from_be(x: Self) -> Self {\n@@ -2274,6 +2423,16 @@ if cfg!(target_endian = \\\"big\\\") {\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn from_be(x: Self) -> Self {\n+                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts an integer from little endian to the target's endianness.\n \n@@ -2294,6 +2453,7 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn from_le(x: Self) -> Self {\n@@ -2308,6 +2468,16 @@ if cfg!(target_endian = \\\"little\\\") {\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn from_le(x: Self) -> Self {\n+                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts `self` to big endian from the target's endianness.\n \n@@ -2328,6 +2498,7 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn to_be(self) -> Self { // or not to be?\n@@ -2342,6 +2513,16 @@ if cfg!(target_endian = \\\"big\\\") {\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn to_be(self) -> Self { // or not to be?\n+                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts `self` to little endian from the target's endianness.\n \n@@ -2362,6 +2543,7 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(not(stage0))]\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn to_le(self) -> Self {\n@@ -2376,6 +2558,16 @@ if cfg!(target_endian = \\\"little\\\") {\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Dummy docs. See !stage0 documentation\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n+            #[inline]\n+            pub fn to_le(self) -> Self {\n+                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred."}]}