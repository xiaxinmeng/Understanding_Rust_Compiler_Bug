{"sha": "40598895394004a82bef1a7d9f99efdabd552d43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNTk4ODk1Mzk0MDA0YTgyYmVmMWE3ZDlmOTllZmRhYmQ1NTJkNDM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T12:08:46Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T12:24:17Z"}, "message": "improve Pin documentation", "tree": {"sha": "81055874f1176b215c9df83b1a7c8bd85f7b5573", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81055874f1176b215c9df83b1a7c8bd85f7b5573"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40598895394004a82bef1a7d9f99efdabd552d43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40598895394004a82bef1a7d9f99efdabd552d43", "html_url": "https://github.com/rust-lang/rust/commit/40598895394004a82bef1a7d9f99efdabd552d43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40598895394004a82bef1a7d9f99efdabd552d43/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32471f7ea4ca5a9218d86cf8b1d8f85919dc096b", "url": "https://api.github.com/repos/rust-lang/rust/commits/32471f7ea4ca5a9218d86cf8b1d8f85919dc096b", "html_url": "https://github.com/rust-lang/rust/commit/32471f7ea4ca5a9218d86cf8b1d8f85919dc096b"}], "stats": {"total": 210, "additions": 190, "deletions": 20}, "files": [{"sha": "f9a4f75c92ae2dd072d349d9f141e92c5833b5cb", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40598895394004a82bef1a7d9f99efdabd552d43/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40598895394004a82bef1a7d9f99efdabd552d43/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=40598895394004a82bef1a7d9f99efdabd552d43", "patch": "@@ -597,7 +597,8 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n \n /// Types which can be safely moved after being pinned.\n ///\n-/// Since Rust itself has no notion of immovable types, and will consider moves to always be safe,\n+/// Since Rust itself has no notion of immovable types, and will consider moves\n+/// (e.g. through assignment or [`mem::replace`]) to always be safe,\n /// this trait cannot prevent types from moving by itself.\n ///\n /// Instead it can be used to prevent moves through the type system,\n@@ -606,7 +607,12 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// See the [`pin module`] documentation for more information on pinning.\n ///\n /// Implementing this trait lifts the restrictions of pinning off a type,\n-/// which then allows it to move out with functions such as [`replace`].\n+/// which then allows it to move out with functions such as [`mem::replace`].\n+///\n+/// `Unpin` has no consequence at all for non-pinned data. In particular,\n+/// [`mem::replace`] will happily move `!Unpin` data. However, you cannot use\n+/// [`mem::replace`] on data wrapped inside a [`Pin`], and *that* is what makes\n+/// this system work.\n ///\n /// So this, for example, can only be done on types implementing `Unpin`:\n ///\n@@ -623,7 +629,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n ///\n /// This trait is automatically implemented for almost every type.\n ///\n-/// [`replace`]: ../../std/mem/fn.replace.html\n+/// [`mem::replace`]: ../../std/mem/fn.replace.html\n /// [`Pin`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[stable(feature = \"pin\", since = \"1.33.0\")]"}, {"sha": "b8a0a93eddb77bdaf3562c7c7cd4d0505aa71133", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 181, "deletions": 17, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/40598895394004a82bef1a7d9f99efdabd552d43/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40598895394004a82bef1a7d9f99efdabd552d43/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=40598895394004a82bef1a7d9f99efdabd552d43", "patch": "@@ -16,29 +16,30 @@\n //! but doesn't allow moving `T`. The pointer value itself (the `Box`) can still be moved,\n //! but the value behind it cannot.\n //!\n-//! Since data can be moved out of `&mut` and `Box` with functions such as [`swap`],\n+//! Since data can be moved out of `&mut` and `Box` with functions such as [`mem::swap`],\n //! changing the location of the underlying data, [`Pin`] prohibits accessing the\n //! underlying pointer type (the `&mut` or `Box`) directly, and provides its own set of\n //! APIs for accessing and using the value. [`Pin`] also guarantees that no other\n //! functions will move the pointed-to value. This allows for the creation of\n //! self-references and other special behaviors that are only possible for unmovable\n //! values.\n //!\n-//! However, these restrictions are usually not necessary. Many types are always freely\n-//! movable. These types implement the [`Unpin`] auto-trait, which nullifies the effect\n-//! of [`Pin`]. For `T: Unpin`, `Pin<Box<T>>` and `Box<T>` function identically, as do\n-//! `Pin<&mut T>` and `&mut T`.\n+//! It is worth reiterating that [`Pin`] does *not* change the fact that the Rust compiler\n+//! considers all types movable.  [`mem::swap`] remains callable for any `T`.  Instead, `Pin`\n+//! prevents certain *values* (pointed to by pointers wrapped in `Pin`) from being\n+//! moved by making it impossible to call methods like [`mem::swap`] on them.\n //!\n-//! Note that pinning and `Unpin` only affect the pointed-to type. For example, whether\n-//! or not `Box<T>` is `Unpin` has no affect on the behavior of `Pin<Box<T>>`. Similarly,\n-//! `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves, even though the\n-//! `T` underneath them isn't, because the pointers in `Pin<Box<_>>` and `Pin<&mut _>`\n-//! are always freely movable, even if the data they point to isn't.\n+//! # `Unpin`\n //!\n-//! [`Pin`]: struct.Pin.html\n-//! [`Unpin`]: ../../std/marker/trait.Unpin.html\n-//! [`swap`]: ../../std/mem/fn.swap.html\n-//! [`Box`]: ../../std/boxed/struct.Box.html\n+//! However, these restrictions are usually not necessary. Many types are always freely\n+//! movable, even when pinned. These types implement the [`Unpin`] auto-trait, which\n+//! nullifies the effect of [`Pin`]. For `T: Unpin`, `Pin<Box<T>>` and `Box<T>` function\n+//! identically, as do `Pin<&mut T>` and `&mut T`.\n+//!\n+//! Note that pinning and `Unpin` only affect the pointed-to type, not the pointer\n+//! type itself that got wrapped in `Pin`. For example, whether or not `Box<T>` is\n+//! `Unpin` has no affect on the behavior of `Pin<Box<T>>` (here, `T` is the\n+//! pointed-to type).\n //!\n //! # Examples\n //!\n@@ -94,6 +95,106 @@\n //! // let new_unmoved = Unmovable::new(\"world\".to_string());\n //! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n //! ```\n+//!\n+//! # `Drop` guarantee\n+//!\n+//! The purpose of pinning is to be able to rely on the placement of some data in memory.\n+//! To make this work, not just moving the data is restricted; deallocating or overwriting\n+//! it is restricted, too. Concretely, for pinned data you have to maintain the invariant\n+//! that *it will not get overwritten or deallocated until `drop` was called*.\n+//! (\"Overwriting\" here refers to other ways of invalidating storage, such as switching\n+//! from one enum variant to another.)\n+//!\n+//! The purpose of this guarantee is to allow data structures that store pointers\n+//! to pinned data. For example, in an intrusive doubly-linked list, every element\n+//! will have pointers to its predecessor and successor in the list. Every element\n+//! will be pinned, because moving the elements around would invalidate the pointers.\n+//! Moreover, the `Drop` implemenetation of a linked list element will patch the pointers\n+//! of its predecessor and successor to remove itself from the list. Clearly, if an element\n+//! could be deallocated or overwritten without calling `drop`, the pointers into it\n+//! from its neighbouring elements would become invalid, breaking the data structure.\n+//!\n+//! Notice that this guarantee does *not* mean that memory does not leak! It is still\n+//! completely okay not to ever call `drop` on a pinned element (e.g., you can still\n+//! call [`mem::forget`] on a `Pin<Box<T>>`). What you may not do is free or reuse the storage\n+//! without calling `drop`.\n+//!\n+//! # `Drop` implementation\n+//!\n+//! If your type relies on pinning (for example, because it contains internal\n+//! references, or because you are implementing something like the intrusive\n+//! doubly-linked list mentioned in the previous section), you have to be careful\n+//! when implementing `Drop`: notice that `drop` takes `&mut self`, but this\n+//! will be called even if your type was previously pinned! It is as if the\n+//! compiler automatically called `get_unchecked_mut`. This can never cause\n+//! a problem in safe code because implementing a type that relies on pinning\n+//! requires unsafe code, but be aware that deciding to make use of pinning\n+//! in your type (for example by implementing some operation on `Pin<&[mut] Self>`)\n+//! has consequences for your `Drop` implemenetation as well.\n+//!\n+//! # Projections and Structural Pinning\n+//!\n+//! One interesting question arises when considering pinning and \"container types\" --\n+//! types such as `Vec` or `Box` but also `RefCell`; types that serve as wrappers\n+//! around other types.  When can such a type have a \"projection\" operation, an\n+//! operation with type `fn(Pin<&[mut] Container<T>>) -> Pin<&[mut] T>`?\n+//! This does not just apply to generic container types, even for normal structs\n+//! the question arises whether `fn(Pin<&[mut] Struct>) -> Pin<&[mut] Field>`\n+//! is an operation that can be soundly added to the API.\n+//!\n+//! This question is closely related to the question of whether pinning is \"structural\":\n+//! when you have pinned a container, have you pinned its contents? Adding a\n+//! projection to the API answers that question with a \"yes\" by offering pinned access\n+//! to the contents.\n+//!\n+//! In general, as the author of a type you get to decide whether pinning is structural, and\n+//! whether projections are provided. However, there are a couple requirements to be\n+//! upheld when adding projection operations:\n+//!\n+//! 1. The container must only be [`Unpin`] if all its fields are `Unpin`. This is the default,\n+//!    but `Unpin` is a safe trait, so as the author of the container it is your responsibility\n+//!    *not* to add something like `impl<T> Unpin for Container<T>`. (Notice that adding a\n+//!    projection operation requires unsafe code, so the fact that `Unpin` is a safe trait\n+//!    does not break the principle that you only have to worry about any of this if\n+//!    you use `unsafe`.)\n+//! 2. The destructor of the container must not move out of its argument. This is the exact\n+//!    point that was raised in the [previous section][drop-impl]: `drop` takes `&mut self`,\n+//!    but the container (and hence its fields) might have been pinned before.\n+//!    You have to guarantee that you do not move a field inside your `Drop` implementation.\n+//! 3. Your container type must *not* be `#[repr(packed)]`. Packed structs have their fields\n+//!    moved around when they are dropped to properly align them, which is in conflict with\n+//!    claiming that the fields are pinned when your struct is.\n+//! 4. You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n+//!    you must make sure that, once your container is pinned, the memory containing the\n+//!    content is not overwritten or deallocated without calling the content's destructors.\n+//!    This can be tricky, as witnessed by `VecDeque`: the destructor of `VecDeque` can fail\n+//!    to call `drop` on all elements if one of the destructors panics. This violates the\n+//!    `Drop` guarantee, because it can lead to elements being deallocated without\n+//!    their destructor being called.\n+//! 5. You must not offer any other operations that could lead to data being moved out of\n+//!    the fields when your type is pinned. This is usually not a concern, but can become\n+//!    tricky when interior mutability is involved. For example, imagine `RefCell`\n+//!    would have a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n+//!    This would be catastrophic, because it is possible to move out of a pinned\n+//!    `RefCell`: from `x: Pin<&mut RefCell<T>>`, use `let y = x.into_ref().get_ref()` to obtain\n+//!    `y: &RefCell<T>`, and from there use `y.borrow_mut().deref_mut()` to obtain `&mut T`\n+//!    which can be used with [`mem::swap`].\n+//!\n+//! On the other hand, if you decide *not* to offer any pinning projections, you\n+//! are free to do `impl<T> Unpin for Container<T>`.  In the standard library,\n+//! we do this for all pointer types: `Box<T>: Unpin` holds for all `T`.\n+//! It makes a lot of sense to do this for pointer types, because moving the `Box<T>`\n+//! does not actually move the `T`: the `Box<T>` can be freely movable even if the `T`\n+//! is not. In fact, even `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves,\n+//! for the same reason.\n+//!\n+//! [`Pin`]: struct.Pin.html\n+//! [`Unpin`]: ../../std/marker/trait.Unpin.html\n+//! [`mem::swap`]: ../../std/mem/fn.swap.html\n+//! [`mem::forget`]: ../../std/mem/fn.forget.html\n+//! [`Box`]: ../../std/boxed/struct.Box.html\n+//! [drop-impl]: #drop-implementation\n+//! [drop-guarantee]: #drop-guarantee\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n \n@@ -170,7 +271,12 @@ where\n     P::Target: Unpin,\n {\n     /// Construct a new `Pin` around a pointer to some data of a type that\n-    /// implements `Unpin`.\n+    /// implements [`Unpin`].\n+    ///\n+    /// Unlike `Pin::new_unchecked`, this method is safe because the pointer\n+    /// `P` dereferences to an [`Unpin`] type, which nullifies the pinning guarantees.\n+    ///\n+    /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn new(pointer: P) -> Pin<P> {\n@@ -191,15 +297,46 @@ impl<P: Deref> Pin<P> {\n     /// not guarantee that the data `P` points to is pinned, constructing a\n     /// `Pin<P>` is undefined behavior.\n     ///\n+    /// By using this method, you are making a promise about the `P::Deref` and\n+    /// `P::DerefMut` implementations, if they exist. Most importantly, they\n+    /// must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`\n+    /// will call `DerefMut::deref_mut` and `Deref::deref` *on the pinned pointer*\n+    /// and expect these methods to uphold the pinning invariants.\n+    /// Moreover, by calling this method you promise that the reference `P`\n+    /// dereferences to will not be moved out of again; in particular, it\n+    /// must not be possible to obtain a `&mut P::Target` and then\n+    /// move out of that reference (using, for example [`replace`]).\n+    ///\n+    /// For example, the following is a *violation* of `Pin`'s safety:\n+    /// ```\n+    /// use std::mem;\n+    /// use std::pin::Pin;\n+    ///\n+    /// fn foo<T>(mut a: T, b: T) {\n+    ///     unsafe { let p = Pin::new_unchecked(&mut a); } // should mean `a` can never move again\n+    ///     let a2 = mem::replace(&mut a, b);\n+    ///     // the address of `a` changed to `a2`'s stack slot, so `a` got moved even\n+    ///     // though we have previously pinned it!\n+    /// }\n+    /// ```\n+    ///\n     /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n     /// instead.\n+    ///\n+    /// [`replace`]: ../../std/mem/fn.replace.html\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n         Pin { pointer }\n     }\n \n     /// Gets a pinned shared reference from this pinned pointer.\n+    ///\n+    /// This is a generic method to go from `&Pin<SmartPointer<T>>` to `Pin<&T>`.\n+    /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n+    /// the pointee cannot move after `Pin<SmartPointer<T>>` got created.\n+    /// \"Malicious\" implementations of `SmartPointer::Deref` are likewise\n+    /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n@@ -209,13 +346,22 @@ impl<P: Deref> Pin<P> {\n \n impl<P: DerefMut> Pin<P> {\n     /// Gets a pinned mutable reference from this pinned pointer.\n+    ///\n+    /// This is a generic method to go from `&mut Pin<SmartPointer<T>>` to `Pin<&mut T>`.\n+    /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n+    /// the pointee cannot move after `Pin<SmartPointer<T>>` got created.\n+    /// \"Malicious\" implementations of `SmartPointer::DerefMut` are likewise\n+    /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n         unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n \n-    /// Assign a new value to the memory behind the pinned reference.\n+    /// Assigns a new value to the memory behind the pinned reference.\n+    ///\n+    /// This overwrites pinned data, but that is okay: its destructor gets\n+    /// run before being overwritten, so no pinning guarantee is violated.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn set(self: &mut Pin<P>, value: P::Target)\n@@ -227,17 +373,21 @@ impl<P: DerefMut> Pin<P> {\n }\n \n impl<'a, T: ?Sized> Pin<&'a T> {\n-    /// Construct a new pin by mapping the interior value.\n+    /// Constructs a new pin by mapping the interior value.\n     ///\n     /// For example, if you  wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n+    /// However, there are several gotchas with these \"pinning projections\";\n+    /// see the [`pin` module] documentation for further details on that topic.\n     ///\n     /// # Safety\n     ///\n     /// This function is unsafe. You must guarantee that the data you return\n     /// will not move so long as the argument value does not move (for example,\n     /// because it is one of the fields of that value), and also that you do\n     /// not move out of the argument you receive to the interior function.\n+    ///\n+    /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub unsafe fn map_unchecked<U, F>(self: Pin<&'a T>, func: F) -> Pin<&'a U> where\n         F: FnOnce(&T) -> &U,\n@@ -249,11 +399,21 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n \n     /// Gets a shared reference out of a pin.\n     ///\n+    /// This is safe because it is not possible to move out of a shared reference.\n+    /// It may seem like there is an issue here with interior mutability: in fact,\n+    /// it *is* possible to move a `T` out of a `&RefCell<T>`. However, this is\n+    /// not a problem as long as there does not also exist a `Pin<&T>` pointing\n+    /// to the same data, and `RefCell` does not let you create a pinned reference\n+    /// to its contents. See the discussion on [\"pinning projections\"] for further\n+    /// details.\n+    ///\n     /// Note: `Pin` also implements `Deref` to the target, which can be used\n     /// to access the inner value. However, `Deref` only provides a reference\n     /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n     /// the `Pin` itself. This method allows turning the `Pin` into a reference\n     /// with the same lifetime as the original `Pin`.\n+    ///\n+    /// [\"pinning projections\"]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn get_ref(self: Pin<&'a T>) -> &'a T {\n@@ -306,13 +466,17 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// For example, if you  wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n+    /// However, there are several gotchas with these \"pinning projections\";\n+    /// see the [`pin` module] documentation for further details on that topic.\n     ///\n     /// # Safety\n     ///\n     /// This function is unsafe. You must guarantee that the data you return\n     /// will not move so long as the argument value does not move (for example,\n     /// because it is one of the fields of that value), and also that you do\n     /// not move out of the argument you receive to the interior function.\n+    ///\n+    /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub unsafe fn map_unchecked_mut<U, F>(self: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n         F: FnOnce(&mut T) -> &mut U,"}]}