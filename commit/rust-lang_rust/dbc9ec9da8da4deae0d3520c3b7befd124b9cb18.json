{"sha": "dbc9ec9da8da4deae0d3520c3b7befd124b9cb18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzllYzlkYThkYTRkZWFlMGQzNTIwYzNiN2JlZmQxMjRiOWNiMTg=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-08T08:07:39Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-08T10:26:34Z"}, "message": "Rollup merge of #53942 - nnethercote:faster-precompute, r=nikomatsakis\n\nRewrite `precompute_borrows_out_of_scope` for fewer hash table lookups.\n\nIt now does one hash table lookup per basic block, instead of one per\nstatement. This is worthwhile because this function is hot for NLL\nbuilds of `ucd`.\n\nI haven't measured the effect of this yet because I'm having trouble doing optimized builds of rustc that are suitable for profiling (#53916). I will do an online perf run instead.\n\nr? @nikomatsakis", "tree": {"sha": "532d3085bcb355f80c3dcbcfdf0eb5cd97e291c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/532d3085bcb355f80c3dcbcfdf0eb5cd97e291c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc9ec9da8da4deae0d3520c3b7befd124b9cb18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAluTo9oACgkQ/vbIBR0O\nATxuXg//Tjhvef1UtogefYQsyvJtpWfiE1aG/03mzPeHabvqIgknLeEO+kvDs08J\noRg+wRv1Vzx+mgXnhqbFsnM59H/69ZayLApo5aArdCIxOZleazvFv7p2CWF1pPHK\nIik0u97v07twrLF1aQaHExkohAZiUlEsTl5/OeQunoCq99cwDLXOW7zwWbeIn6/F\nLYDmoXPxjERfnh9OBtTL5tZBwc/WBCC9cngMDsgob4CSFcJgXRQpNFIBNri19VWl\np+Eb4SpZ2p/eL3s8vVaGUcB+vLZ1wSMv/mpajRIXAG/9JMpLY/bCUxdEpsBhmq8a\nGDybRfu8Hf0pMAiFU4fObszPPwfTDQVgQdUEYJb36OfVjZPrWsVLatKj/VsCj9jG\nT+tn84nzutmjgRd3a9M3IIacvXCmmhzQiTbXFwO8mTP4cmwzYCq4JWmFAvHW/uTW\nIIGAivVXGVzQuhUa7lm4lQ26rWaY5g4tXCvMKuDA/cQQk0GA6hlH6SGeYLnVi7Ax\neCnR9M5KcI1qIcFBWtzFGUb2qjSCxA/O3+Efbqryr/MxEZGCpyBMYE+obTQGDETC\nv8lWpCtyepGXBmUnXbU8tWFjpnz9H+lV6bWByGyYgMDk16J4hXX3C1UXM+8EIsir\n2h6tv16vdzN02aNlrmb6WUO0KeR+6gKZHOpT08VwycnirmuFJnk=\n=E7xR\n-----END PGP SIGNATURE-----", "payload": "tree 532d3085bcb355f80c3dcbcfdf0eb5cd97e291c2\nparent 7569d9266e607df6579916e871d65480aaa8b50a\nparent fb307e529d217c6602c1c0359b14947b6897265c\nauthor kennytm <kennytm@gmail.com> 1536394059 +0800\ncommitter kennytm <kennytm@gmail.com> 1536402394 +0800\n\nRollup merge of #53942 - nnethercote:faster-precompute, r=nikomatsakis\n\nRewrite `precompute_borrows_out_of_scope` for fewer hash table lookups.\n\nIt now does one hash table lookup per basic block, instead of one per\nstatement. This is worthwhile because this function is hot for NLL\nbuilds of `ucd`.\n\nI haven't measured the effect of this yet because I'm having trouble doing optimized builds of rustc that are suitable for profiling (#53916). I will do an online perf run instead.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9ec9da8da4deae0d3520c3b7befd124b9cb18", "html_url": "https://github.com/rust-lang/rust/commit/dbc9ec9da8da4deae0d3520c3b7befd124b9cb18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc9ec9da8da4deae0d3520c3b7befd124b9cb18/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7569d9266e607df6579916e871d65480aaa8b50a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7569d9266e607df6579916e871d65480aaa8b50a", "html_url": "https://github.com/rust-lang/rust/commit/7569d9266e607df6579916e871d65480aaa8b50a"}, {"sha": "fb307e529d217c6602c1c0359b14947b6897265c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb307e529d217c6602c1c0359b14947b6897265c", "html_url": "https://github.com/rust-lang/rust/commit/fb307e529d217c6602c1c0359b14947b6897265c"}], "stats": {"total": 120, "additions": 79, "deletions": 41}, "files": [{"sha": "995e70fb382fc0460e3f73773077465abd54f9d3", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 79, "deletions": 41, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/dbc9ec9da8da4deae0d3520c3b7befd124b9cb18/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc9ec9da8da4deae0d3520c3b7befd124b9cb18/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=dbc9ec9da8da4deae0d3520c3b7befd124b9cb18", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{RegionKind, RegionVid};\n use rustc::ty::RegionKind::ReScope;\n \n use rustc_data_structures::bitslice::{BitwiseOperator, Word};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n@@ -53,6 +53,13 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     _nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n }\n \n+struct StackEntry {\n+    bb: mir::BasicBlock,\n+    lo: usize,\n+    hi: usize,\n+    first_part_only: bool\n+}\n+\n fn precompute_borrows_out_of_scope<'tcx>(\n     mir: &Mir<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n@@ -61,48 +68,79 @@ fn precompute_borrows_out_of_scope<'tcx>(\n     borrow_region: RegionVid,\n     location: Location,\n ) {\n-    // Keep track of places we've locations to check and locations that we have checked.\n-    let mut stack = vec![ location ];\n-    let mut visited = FxHashSet();\n-    visited.insert(location);\n-\n-    debug!(\n-        \"borrow {:?} has region {:?} with value {:?}\",\n-        borrow_index,\n-        borrow_region,\n-        regioncx.region_value_str(borrow_region),\n-    );\n-    debug!(\"borrow {:?} starts at {:?}\", borrow_index, location);\n-    while let Some(location) = stack.pop() {\n-        // If region does not contain a point at the location, then add to list and skip\n-        // successor locations.\n-        if !regioncx.region_contains(borrow_region, location) {\n-            debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n-            borrows_out_of_scope_at_location\n-                .entry(location)\n-                .or_default()\n-                .push(borrow_index);\n-            continue;\n+    // We visit one BB at a time. The complication is that we may start in the\n+    // middle of the first BB visited (the one containing `location`), in which\n+    // case we may have to later on process the first part of that BB if there\n+    // is a path back to its start.\n+\n+    // For visited BBs, we record the index of the first statement processed.\n+    // (In fully processed BBs this index is 0.) Note also that we add BBs to\n+    // `visited` once they are added to `stack`, before they are actually\n+    // processed, because this avoids the need to look them up again on\n+    // completion.\n+    let mut visited = FxHashMap();\n+    visited.insert(location.block, location.statement_index);\n+\n+    let mut stack = vec![];\n+    stack.push(StackEntry {\n+        bb: location.block,\n+        lo: location.statement_index,\n+        hi: mir[location.block].statements.len(),\n+        first_part_only: false,\n+    });\n+\n+    while let Some(StackEntry { bb, lo, hi, first_part_only }) = stack.pop() {\n+        let mut finished_early = first_part_only;\n+        for i in lo ..= hi {\n+            let location = Location { block: bb, statement_index: i };\n+            // If region does not contain a point at the location, then add to list and skip\n+            // successor locations.\n+            if !regioncx.region_contains(borrow_region, location) {\n+                debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n+                borrows_out_of_scope_at_location\n+                    .entry(location)\n+                    .or_default()\n+                    .push(borrow_index);\n+                finished_early = true;\n+                break;\n+            }\n         }\n \n-        let bb_data = &mir[location.block];\n-        // If this is the last statement in the block, then add the\n-        // terminator successors next.\n-        if location.statement_index == bb_data.statements.len() {\n-            // Add successors to locations to visit, if not visited before.\n-            if let Some(ref terminator) = bb_data.terminator {\n-                for block in terminator.successors() {\n-                    let loc = block.start_location();\n-                    if visited.insert(loc) {\n-                        stack.push(loc);\n-                    }\n-                }\n-            }\n-        } else {\n-            // Visit next statement in block.\n-            let loc = location.successor_within_block();\n-            if visited.insert(loc) {\n-                stack.push(loc);\n+        if !finished_early {\n+            // Add successor BBs to the work list, if necessary.\n+            let bb_data = &mir[bb];\n+            assert!(hi == bb_data.statements.len());\n+            for &succ_bb in bb_data.terminator.as_ref().unwrap().successors() {\n+                visited.entry(succ_bb)\n+                    .and_modify(|lo| {\n+                        // `succ_bb` has been seen before. If it wasn't\n+                        // fully processed, add its first part to `stack`\n+                        // for processing.\n+                        if *lo > 0 {\n+                            stack.push(StackEntry {\n+                                bb: succ_bb,\n+                                lo: 0,\n+                                hi: *lo - 1,\n+                                first_part_only: true,\n+                            });\n+                        }\n+                        // And update this entry with 0, to represent the\n+                        // whole BB being processed.\n+                        *lo = 0;\n+                    })\n+                    .or_insert_with(|| {\n+                        // succ_bb hasn't been seen before. Add it to\n+                        // `stack` for processing.\n+                        stack.push(StackEntry {\n+                            bb: succ_bb,\n+                            lo: 0,\n+                            hi: mir[succ_bb].statements.len(),\n+                            first_part_only: false,\n+                        });\n+                        // Insert 0 for this BB, to represent the whole BB\n+                        // being processed.\n+                        0\n+                    });\n             }\n         }\n     }"}]}