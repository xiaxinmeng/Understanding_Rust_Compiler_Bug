{"sha": "a41e2fd963915c940a46a67825ec053afb004f87", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MWUyZmQ5NjM5MTVjOTQwYTQ2YTY3ODI1ZWMwNTNhZmIwMDRmODc=", "commit": {"author": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-05-22T23:00:43Z"}, "committer": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2020-11-05T18:24:49Z"}, "message": "Convert the recursive find_state to a loop\n\nThe basic conversion is a straightforward conversion of the linear\nrecursion to a loop forwards and backwards propagation of the result.\nBut this uses an optimization to avoid the need for extra space that\nwould otherwise be necessary to store the stack of unfinished states as\nthe function is not tail recursive.\n\nObserve that only non-root-nodes in cycles have a recursive call and\nthat every such call overwrites their own node state. Thus we reuse the\nnode state itself as temporary storage for the stack of unfinished\nstates by inverting the links to a chain back to the previous state\nupdate. When we hit the root or end of the full explored chain we\npropagate the node state update backwards by following the chain until\na node with a link to itself.", "tree": {"sha": "c345d0877d6f17c529086a907800188f5bfb8e36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c345d0877d6f17c529086a907800188f5bfb8e36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a41e2fd963915c940a46a67825ec053afb004f87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a41e2fd963915c940a46a67825ec053afb004f87", "html_url": "https://github.com/rust-lang/rust/commit/a41e2fd963915c940a46a67825ec053afb004f87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a41e2fd963915c940a46a67825ec053afb004f87/comments", "author": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fdf8a5630a621c44a0928a1e30d881b0e00022b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdf8a5630a621c44a0928a1e30d881b0e00022b", "html_url": "https://github.com/rust-lang/rust/commit/4fdf8a5630a621c44a0928a1e30d881b0e00022b"}], "stats": {"total": 132, "additions": 110, "deletions": 22}, "files": [{"sha": "f1a22de47a73fef2cf1f746d985da1e96126616d", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 110, "deletions": 22, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a41e2fd963915c940a46a67825ec053afb004f87/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41e2fd963915c940a46a67825ec053afb004f87/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=a41e2fd963915c940a46a67825ec053afb004f87", "patch": "@@ -274,30 +274,118 @@ where\n     /// of `r2` (and updates `r` to reflect current result). This is\n     /// basically the \"find\" part of a standard union-find algorithm\n     /// (with path compression).\n-    fn find_state(&mut self, r: G::Node) -> NodeState<G::Node, S> {\n-        debug!(\"find_state(r = {:?} in state {:?})\", r, self.node_states[r]);\n-        match self.node_states[r] {\n-            NodeState::InCycle { scc_index } => NodeState::InCycle { scc_index },\n-            NodeState::BeingVisited { depth } => NodeState::BeingVisited { depth },\n-            NodeState::NotVisited => NodeState::NotVisited,\n-            NodeState::InCycleWith { parent } => {\n-                let parent_state = self.find_state(parent);\n-                debug!(\"find_state: parent_state = {:?}\", parent_state);\n-                match parent_state {\n-                    NodeState::InCycle { .. } => {\n-                        self.node_states[r] = parent_state;\n-                        parent_state\n-                    }\n+    fn find_state(&mut self, mut node: G::Node) -> NodeState<G::Node, S> {\n+        // To avoid recursion we temporarily reuse the `parent` of each\n+        // InCycleWith link to encode a downwards link while compressing\n+        // the path. After we have found the root or deepest node being\n+        // visited, we traverse the reverse links and correct the node\n+        // states on the way.\n+        //\n+        // **Note**: This mutation requires that this is a leaf function\n+        // or at least that none of the called functions inspects the\n+        // current node states. Luckily, we are a leaf.\n+\n+        // Remember one previous link. The termination condition when\n+        // following links downwards is then simply as soon as we have\n+        // found the initial self-loop.\n+        let mut previous_node = node;\n+\n+        // Ultimately assigned by the parent when following\n+        // `InCycleWith` upwards.\n+        let node_state = loop {\n+            debug!(\"find_state(r = {:?} in state {:?})\", node, self.node_states[node]);\n+            match self.node_states[node] {\n+                NodeState::InCycle { scc_index } => break NodeState::InCycle { scc_index },\n+                NodeState::BeingVisited { depth } => break NodeState::BeingVisited { depth },\n+                NodeState::NotVisited => break NodeState::NotVisited,\n+                NodeState::InCycleWith { parent } => {\n+                    // We test this, to be extremely sure that we never\n+                    // ever break our termination condition for the\n+                    // reverse iteration loop.\n+                    assert!(node != parent, \"Node can not be in cycle with itself\");\n+                    // Store the previous node as an inverted list link\n+                    self.node_states[node] = NodeState::InCycleWith { parent: previous_node };\n+                    // Update to parent node.\n+                    previous_node = node;\n+                    node = parent;\n+                }\n+            }\n+        };\n \n-                    NodeState::BeingVisited { depth } => {\n-                        self.node_states[r] =\n-                            NodeState::InCycleWith { parent: self.node_stack[depth] };\n-                        parent_state\n-                    }\n+        // The states form a graph where up to one outgoing link is stored at\n+        // each node. Initially in general,\n+        //\n+        //                                                  E\n+        //                                                  ^\n+        //                                                  |\n+        //                                InCycleWith/BeingVisited/NotVisited\n+        //                                                  |\n+        //   A-InCycleWith->B-InCycleWith\u2026>C-InCycleWith->D-+\n+        //   |\n+        //   = node, previous_node\n+        //\n+        // After the first loop, this will look like\n+        //                                                  E\n+        //                                                  ^\n+        //                                                  |\n+        //                                InCycleWith/BeingVisited/NotVisited\n+        //                                                  |\n+        // +>A<-InCycleWith-B<\u2026InCycleWith-C<-InCycleWith-D-+\n+        // | |                             |              |\n+        // | InCycleWith                   |              = node\n+        // +-+                             =previous_node\n+        //\n+        // Note in particular that A will be linked to itself in a self-cycle\n+        // and no other self-cycles occur due to how InCycleWith is assigned in\n+        // the find phase implemented by `walk_unvisited_node`.\n+        //\n+        // We now want to compress the path, that is assign the state of the\n+        // link D-E to all other links.\n+        //\n+        // We can then walk backwards, starting from `previous_node`, and assign\n+        // each node in the list with the updated state. The loop terminates\n+        // when we reach the self-cycle.\n+\n+        // Move backwards until we found the node where we started. We\n+        // will know when we hit the state where previous_node == node.\n+        loop {\n+            // Back at the beginning, we can return.\n+            if previous_node == node {\n+                return node_state;\n+            }\n+            // Update to previous node in the link.\n+            match self.node_states[previous_node] {\n+                NodeState::InCycleWith { parent: previous } => {\n+                    node = previous_node;\n+                    previous_node = previous;\n+                }\n+                // Only InCycleWith nodes were added to the reverse linked list.\n+                other => panic!(\"Invalid previous link while compressing cycle: {:?}\", other),\n+            }\n \n-                    NodeState::NotVisited | NodeState::InCycleWith { .. } => {\n-                        panic!(\"invalid parent state: {:?}\", parent_state)\n-                    }\n+            debug!(\"find_state: parent_state = {:?}\", node_state);\n+\n+            // Update the node state from the parent state. The assigned\n+            // state is actually a loop invariant but it will only be\n+            // evaluated if there is at least one backlink to follow.\n+            // Fully trusting llvm here to find this loop optimization.\n+            match node_state {\n+                // Path compression, make current node point to the same root.\n+                NodeState::InCycle { .. } => {\n+                    self.node_states[node] = node_state;\n+                }\n+                // Still visiting nodes, compress to cycle to the node\n+                // at that depth.\n+                NodeState::BeingVisited { depth } => {\n+                    self.node_states[node] =\n+                        NodeState::InCycleWith { parent: self.node_stack[depth] };\n+                }\n+                // These are never allowed as parent nodes. InCycleWith\n+                // should have been followed to a real parent and\n+                // NotVisited can not be part of a cycle since it should\n+                // have instead gotten explored.\n+                NodeState::NotVisited | NodeState::InCycleWith { .. } => {\n+                    panic!(\"invalid parent state: {:?}\", node_state)\n                 }\n             }\n         }"}]}