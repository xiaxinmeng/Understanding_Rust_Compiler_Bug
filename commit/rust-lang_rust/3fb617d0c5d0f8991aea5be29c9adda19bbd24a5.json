{"sha": "3fb617d0c5d0f8991aea5be29c9adda19bbd24a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYjYxN2QwYzVkMGY4OTkxYWVhNWJlMjljOWFkZGExOWJiZDI0YTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-05T14:49:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-10T08:11:35Z"}, "message": "more comments for these sublte games we are playing with allocations in the miri engine", "tree": {"sha": "701ecaf485608331070ce75ac81e01a570788357", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/701ecaf485608331070ce75ac81e01a570788357"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fb617d0c5d0f8991aea5be29c9adda19bbd24a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fb617d0c5d0f8991aea5be29c9adda19bbd24a5", "html_url": "https://github.com/rust-lang/rust/commit/3fb617d0c5d0f8991aea5be29c9adda19bbd24a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fb617d0c5d0f8991aea5be29c9adda19bbd24a5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83667d64a2ae9c85722930f02d05e7b2efa8d853", "url": "https://api.github.com/repos/rust-lang/rust/commits/83667d64a2ae9c85722930f02d05e7b2efa8d853", "html_url": "https://github.com/rust-lang/rust/commit/83667d64a2ae9c85722930f02d05e7b2efa8d853"}], "stats": {"total": 70, "additions": 40, "deletions": 30}, "files": [{"sha": "a444f0bafd23c1f3d7d7b24de03ead89bb79923f", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fb617d0c5d0f8991aea5be29c9adda19bbd24a5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb617d0c5d0f8991aea5be29c9adda19bbd24a5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=3fb617d0c5d0f8991aea5be29c9adda19bbd24a5", "patch": "@@ -122,7 +122,8 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Called for read access to a foreign static item.\n     ///\n     /// This will only be called once per static and machine; the result is cached in\n-    /// the machine memory.\n+    /// the machine memory. (This relies on `AllocMap::get_or` being able to add the\n+    /// owned allocation to the map even when the map is shared.)\n     fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n@@ -133,7 +134,8 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ///\n     /// This should avoid copying if no work has to be done! If this returns an owned\n     /// allocation (because a copy had to be done to add the tags), machine memory will\n-    /// cache the result.\n+    /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n+    /// owned allocation to the map even when the map is shared.)\n     fn static_with_default_tag(\n         alloc: &'_ Allocation\n     ) -> Cow<'_, Allocation<Self::PointerTag>>;"}, {"sha": "c8777bb9a98c32166b35c56958056ebbf88fb51f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3fb617d0c5d0f8991aea5be29c9adda19bbd24a5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb617d0c5d0f8991aea5be29c9adda19bbd24a5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=3fb617d0c5d0f8991aea5be29c9adda19bbd24a5", "patch": "@@ -321,14 +321,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Allocation accessors\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    /// Helper function to obtain the global (tcx) allocation for a static\n+    /// Helper function to obtain the global (tcx) allocation for a static.\n+    /// This attempts to return a reference to an existing allocation if\n+    /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n+    /// this machine use the same pointer tag, so it is indirected through\n+    /// `M::static_with_default_tag`.\n     fn get_static_alloc(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         id: AllocId,\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let def_id = match alloc {\n             Some(AllocType::Memory(mem)) => {\n+                // We got tcx memory. Let the machine figure out whether and how to\n+                // turn that into memory with the right pointer tag.\n                 return Ok(M::static_with_default_tag(mem))\n             }\n             Some(AllocType::Function(..)) => {\n@@ -356,6 +362,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             EvalErrorKind::ReferencedConstant(err).into()\n         }).map(|const_val| {\n             if let ConstValue::ByRef(_, allocation, _) = const_val.val {\n+                // We got tcx memory. Let the machine figure out whether and how to\n+                // turn that into memory with the right pointer tag.\n                 M::static_with_default_tag(allocation)\n             } else {\n                 bug!(\"Matching on non-ByRef static\")\n@@ -372,7 +380,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             let alloc = Self::get_static_alloc(self.tcx, id).map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n-                    // We got a ref, cheaply return that as an \"error\"\n+                    // We got a ref, cheaply return that as an \"error\" so that the\n+                    // map does not get mutated.\n                     Err(Ok(alloc))\n                 }\n                 Cow::Owned(alloc) => {\n@@ -392,30 +401,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_size_and_align(&self, id: AllocId) -> (Size, Align) {\n-        if let Ok(alloc) = self.get(id) {\n-            return (Size::from_bytes(alloc.bytes.len() as u64), alloc.align);\n-        }\n-        // Could also be a fn ptr or extern static\n-        match self.tcx.alloc_map.lock().get(id) {\n-            Some(AllocType::Function(..)) => (Size::ZERO, Align::from_bytes(1, 1).unwrap()),\n-            Some(AllocType::Static(did)) => {\n-                // The only way `get` couldn\u00c4t have worked here is if this is an extern static\n-                assert!(self.tcx.is_foreign_item(did));\n-                // Use size and align of the type\n-                let ty = self.tcx.type_of(did);\n-                let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                (layout.size, layout.align)\n-            }\n-            _ => {\n-                // Must be a deallocated pointer\n-                *self.dead_alloc_map.get(&id).expect(\n-                    \"allocation missing in dead_alloc_map\"\n-                )\n-            }\n-        }\n-    }\n-\n     pub fn get_mut(\n         &mut self,\n         id: AllocId,\n@@ -429,8 +414,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 return err!(ModifiedConstantMemory);\n             }\n             let kind = M::STATIC_KIND.expect(\n-                \"I got an owned allocation that I have to copy but the machine does \\\n-                    not expect that to happen\"\n+                \"An allocation is being mutated but the machine does not expect that to happen\"\n             );\n             Ok((MemoryKind::Machine(kind), alloc.into_owned()))\n         });\n@@ -448,6 +432,30 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    pub fn get_size_and_align(&self, id: AllocId) -> (Size, Align) {\n+        if let Ok(alloc) = self.get(id) {\n+            return (Size::from_bytes(alloc.bytes.len() as u64), alloc.align);\n+        }\n+        // Could also be a fn ptr or extern static\n+        match self.tcx.alloc_map.lock().get(id) {\n+            Some(AllocType::Function(..)) => (Size::ZERO, Align::from_bytes(1, 1).unwrap()),\n+            Some(AllocType::Static(did)) => {\n+                // The only way `get` couldn't have worked here is if this is an extern static\n+                assert!(self.tcx.is_foreign_item(did));\n+                // Use size and align of the type\n+                let ty = self.tcx.type_of(did);\n+                let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                (layout.size, layout.align)\n+            }\n+            _ => {\n+                // Must be a deallocated pointer\n+                *self.dead_alloc_map.get(&id).expect(\n+                    \"allocation missing in dead_alloc_map\"\n+                )\n+            }\n+        }\n+    }\n+\n     pub fn get_fn(&self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx, Instance<'tcx>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);"}]}