{"sha": "1916e3c4aad7b0e0de1cfd190819609f55520996", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MTZlM2M0YWFkN2IwZTBkZTFjZmQxOTA4MTk2MDlmNTU1MjA5OTY=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-10-01T19:46:17Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-11-03T20:27:40Z"}, "message": "Copy `AsciiExt` methods to `str` directly\n\nThis is done in order to deprecate AsciiExt eventually. Note that\nthis commit contains a bunch of `cfg(stage0)` statements. This is\ndue to a new compiler feature this commit depends on: the\n`slice_u8` lang item. Once this lang item is available in the\nstage0 compiler, all those cfg flags (and more) can be removed.", "tree": {"sha": "38dbc0bdb12d7be38420776c4ed4a125f61698ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38dbc0bdb12d7be38420776c4ed4a125f61698ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1916e3c4aad7b0e0de1cfd190819609f55520996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1916e3c4aad7b0e0de1cfd190819609f55520996", "html_url": "https://github.com/rust-lang/rust/commit/1916e3c4aad7b0e0de1cfd190819609f55520996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1916e3c4aad7b0e0de1cfd190819609f55520996/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a1d11a733b856cfaedd82f1c1ff50b87541692d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a1d11a733b856cfaedd82f1c1ff50b87541692d", "html_url": "https://github.com/rust-lang/rust/commit/5a1d11a733b856cfaedd82f1c1ff50b87541692d"}], "stats": {"total": 295, "additions": 290, "deletions": 5}, "files": [{"sha": "7590003a681ddaa140dc6d5e0b63bf99430b0a6b", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1916e3c4aad7b0e0de1cfd190819609f55520996/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1916e3c4aad7b0e0de1cfd190819609f55520996/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=1916e3c4aad7b0e0de1cfd190819609f55520996", "patch": "@@ -1533,7 +1533,7 @@ impl<T> [T] {\n     }\n }\n \n-// TODO(LukasKalbertodt): the `not(stage0)` constraint can be removed in the\n+// FIXME(LukasKalbertodt): the `not(stage0)` constraint can be removed in the\n // future once the stage0 compiler is new enough to know about the `slice_u8`\n // lang item.\n #[lang = \"slice_u8\"]"}, {"sha": "2c257b8c736787c94c799b42592ec2a409b605a5", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/1916e3c4aad7b0e0de1cfd190819609f55520996/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1916e3c4aad7b0e0de1cfd190819609f55520996/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=1916e3c4aad7b0e0de1cfd190819609f55520996", "patch": "@@ -2070,6 +2070,282 @@ impl str {\n         s.extend((0..n).map(|_| self));\n         s\n     }\n+\n+    /// Checks if all characters in this string are within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = \"hello!\\n\";\n+    /// let non_ascii = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        // We can treat each byte as character here: all multibyte characters\n+        // start with a byte that is not in the ascii range, so we will stop\n+        // there already.\n+        self.bytes().all(|b| b.is_ascii())\n+    }\n+\n+    /// Returns a copy of this string where each character is mapped to its\n+    /// ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s.to_ascii_uppercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`to_uppercase`]: #method.to_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn to_ascii_uppercase(&self) -> String {\n+        let mut bytes = self.as_bytes().to_vec();\n+        bytes.make_ascii_uppercase();\n+        // make_ascii_uppercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(bytes) }\n+    }\n+\n+    /// Returns a copy of this string where each character is mapped to its\n+    /// ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s.to_ascii_lowercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`to_lowercase`]: #method.to_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn to_ascii_lowercase(&self) -> String {\n+        let mut bytes = self.as_bytes().to_vec();\n+        bytes.make_ascii_lowercase();\n+        // make_ascii_lowercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(bytes) }\n+    }\n+\n+    /// Checks that two strings are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\n+    /// assert!(\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00f6S\"));\n+    /// assert!(!\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00d6S\"));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n+        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n+    }\n+\n+    /// Converts this string to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_uppercase()\n+    }\n+\n+    /// Converts this string to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_lowercase()\n+    }\n+\n+    /// Checks if all characters of this string are ASCII alphabetic\n+    /// characters:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII uppercase characters:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// // Only ascii uppercase characters\n+    /// assert!(\"HELLO\".is_ascii_uppercase());\n+    ///\n+    /// // While all characters are ascii, 'y' and 'e' are not uppercase\n+    /// assert!(!\"Bye\".is_ascii_uppercase());\n+    ///\n+    /// // While all characters are uppercase, '\u00dc' is not ascii\n+    /// assert!(!\"TSCH\u00dcSS\".is_ascii_uppercase());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII lowercase characters:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// // Only ascii uppercase characters\n+    /// assert!(\"hello\".is_ascii_lowercase());\n+    ///\n+    /// // While all characters are ascii, 'B' is not lowercase\n+    /// assert!(!\"Bye\".is_ascii_lowercase());\n+    ///\n+    /// // While all characters are lowercase, '\u00dc' is not ascii\n+    /// assert!(!\"tsch\u00fcss\".is_ascii_lowercase());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII alphanumeric\n+    /// characters:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_digit())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII hexadecimal digits:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', or\n+    /// - U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII punctuation\n+    /// characters:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII graphic characters:\n+    /// U+0021 '@' ... U+007E '~'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII whitespace characters:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII control characters:\n+    ///\n+    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n+    /// - U+007F DELETE.\n+    ///\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_control())\n+    }\n }\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking"}, {"sha": "200264a25834d6dddf049786a4046ca8cee0e912", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1916e3c4aad7b0e0de1cfd190819609f55520996/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1916e3c4aad7b0e0de1cfd190819609f55520996/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=1916e3c4aad7b0e0de1cfd190819609f55520996", "patch": "@@ -298,6 +298,10 @@ pub trait AsciiExt {\n     fn is_ascii_control(&self) -> bool { unimplemented!(); }\n }\n \n+// FIXME(LukasKalbertodt): this impl block can be removed in the future. This is\n+// possible once the stage0 compiler is new enough to contain the inherent\n+// ascii methods for `[str]`. See FIXME comment further down.\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for str {\n     type Owned = String;\n@@ -389,9 +393,9 @@ impl AsciiExt for str {\n     }\n }\n \n-// TODO(LukasKalbertodt): this impl block can be removed in the future. This is\n+// FIXME(LukasKalbertodt): this impl block can be removed in the future. This is\n // possible once the stage0 compiler is new enough to contain the inherent\n-// ascii methods for `[u8]`. See TODO comment further down.\n+// ascii methods for `[u8]`. See FIXME comment further down.\n #[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for [u8] {\n@@ -546,12 +550,18 @@ macro_rules! impl_by_delegating {\n impl_by_delegating!(u8, u8);\n impl_by_delegating!(char, char);\n \n-// TODO(LukasKalbertodt): the macro invocation should replace the impl block\n+// FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n // for `[u8]` above. But this is not possible until the stage0 compiler is new\n // enough to contain the inherent ascii methods for `[u8]`.\n #[cfg(not(stage0))]\n impl_by_delegating!([u8], Vec<u8>);\n \n+// FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n+// for `str` above. But this is not possible until the stage0 compiler is new\n+// enough to contain the inherent ascii methods for `str`.\n+#[cfg(not(stage0))]\n+impl_by_delegating!(str, String);\n+\n /// An iterator over the escaped version of a byte.\n ///\n /// This `struct` is created by the [`escape_default`] function. See its"}, {"sha": "195aac5292fb8278db3c88fda6de9911d3df0215", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1916e3c4aad7b0e0de1cfd190819609f55520996/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1916e3c4aad7b0e0de1cfd190819609f55520996/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1916e3c4aad7b0e0de1cfd190819609f55520996", "patch": "@@ -35,7 +35,6 @@ use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n use symbol::Symbol;\n \n-use std::ascii::AsciiExt;\n use std::env;\n \n macro_rules! set {"}]}