{"sha": "d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YzBmN2QxYzA3YTA2MGI2ZDA2YmRkNjBiMjRjNzhiZDJjOWE2YzM=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-08-02T02:38:10Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-08-09T14:32:33Z"}, "message": "librustc: Don't use the same alloca for match binding which we reassign to in arm body.", "tree": {"sha": "9e6a64c8ad673cd396fb7e060602a41afdf73e92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e6a64c8ad673cd396fb7e060602a41afdf73e92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3", "html_url": "https://github.com/rust-lang/rust/commit/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1712ab2300df3a319c4e9595cd7fa4fd1c8a3aab", "url": "https://api.github.com/repos/rust-lang/rust/commits/1712ab2300df3a319c4e9595cd7fa4fd1c8a3aab", "html_url": "https://github.com/rust-lang/rust/commit/1712ab2300df3a319c4e9595cd7fa4fd1c8a3aab"}], "stats": {"total": 139, "additions": 136, "deletions": 3}, "files": [{"sha": "d8cbf5a2341e57c3e550afa2792a9c523f0421f1", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3", "patch": "@@ -189,7 +189,9 @@\n #![allow(non_camel_case_types)]\n \n use back::abi;\n+use mc = middle::mem_categorization;\n use driver::config::FullDebugInfo;\n+use euv = middle::expr_use_visitor;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef};\n use middle::const_eval;\n@@ -1292,13 +1294,55 @@ pub fn trans_match<'a>(\n     trans_match_inner(bcx, match_expr.id, discr_expr, arms, dest)\n }\n \n-fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n+/// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n+fn is_discr_reassigned(bcx: &Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n+    match discr.node {\n+        ast::ExprPath(..) => match bcx.def(discr.id) {\n+            def::DefLocal(vid, _) | def::DefBinding(vid, _) => {\n+                let mut rc = ReassignmentChecker {\n+                    node: vid,\n+                    reassigned: false\n+                };\n+                {\n+                    let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx);\n+                    visitor.walk_expr(body);\n+                }\n+                rc.reassigned\n+            }\n+            _ => false\n+        },\n+        _ => false\n+    }\n+}\n+\n+struct ReassignmentChecker {\n+    node: ast::NodeId,\n+    reassigned: bool\n+}\n+\n+impl euv::Delegate for ReassignmentChecker {\n+    fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}\n+    fn consume_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::ConsumeMode) {}\n+    fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,\n+              _: ty::BorrowKind, _: euv::LoanCause) {}\n+    fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n+    fn mutate(&mut self, _: ast::NodeId, _: Span, cmt: mc::cmt, _: euv::MutateMode) {\n+        match cmt.cat {\n+            mc::cat_local(vid) => self.reassigned = self.node == vid,\n+            _ => {}\n+        }\n+    }\n+}\n+\n+fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>,\n+                      discr: &ast::Expr, body: &ast::Expr) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n     // from the various alternatives.\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n+    let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = HashMap::new();\n     pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n         let ident = path1.node;\n@@ -1310,7 +1354,7 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n         let trmode;\n         match bm {\n             ast::BindByValue(_)\n-                if !ty::type_moves_by_default(tcx, variable_ty) => {\n+                if !ty::type_moves_by_default(tcx, variable_ty) || reassigned => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n                                  \"__llmatch\");\n@@ -1371,7 +1415,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n         bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n         arm: arm,\n-        bindings_map: create_bindings_map(bcx, *arm.pats.get(0))\n+        bindings_map: create_bindings_map(bcx, *arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n     let mut static_inliner = StaticInliner { tcx: scope_cx.tcx() };"}, {"sha": "84f380e862a4d1253ae74b7c53859847029a8bf3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3", "patch": "@@ -16,6 +16,7 @@ use driver::session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef};\n use llvm::{True, False, Bool};\n+use mc = middle::mem_categorization;\n use middle::def;\n use middle::lang_items::LangItem;\n use middle::subst;\n@@ -481,6 +482,36 @@ impl<'a> Block<'a> {\n     }\n }\n \n+impl<'a> mc::Typer for Block<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        self.tcx()\n+    }\n+\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+        Ok(node_id_type(self, id))\n+    }\n+\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+        self.tcx().method_map.borrow().find(&method_call).map(|method| method.ty)\n+    }\n+\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+        &self.tcx().adjustments\n+    }\n+\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.tcx().method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n+    }\n+\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId> {\n+        self.tcx().region_maps.temporary_scope(rvalue_id)\n+    }\n+\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n+        self.tcx().upvar_borrow_map.borrow().get_copy(&upvar_id)\n+    }\n+}\n+\n pub struct Result<'a> {\n     pub bcx: &'a Block<'a>,\n     pub val: ValueRef"}, {"sha": "1a1618fbc48fa1768f1460c9017a709e4cdca040", "filename": "src/test/run-pass/issue-15571.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/src%2Ftest%2Frun-pass%2Fissue-15571.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/src%2Ftest%2Frun-pass%2Fissue-15571.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15571.rs?ref=d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let mut foo = Some(box 5i);\n+    match foo {\n+        None => {},\n+        Some(x) => {\n+            foo = Some(x);\n+        }\n+    };\n+    println!(\"'{}'\", foo.unwrap());\n+}"}, {"sha": "9cc571c7819cdc5d1366b61ff7f41a7160a71da9", "filename": "src/test/run-pass/issue-16151.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/src%2Ftest%2Frun-pass%2Fissue-16151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3/src%2Ftest%2Frun-pass%2Fissue-16151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16151.rs?ref=d7c0f7d1c07a060b6d06bdd60b24c78bd2c9a6c3", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+static mut DROP_COUNT: uint = 0;\n+\n+struct Fragment;\n+\n+impl Drop for Fragment {\n+    fn drop(&mut self) {\n+        unsafe {\n+            DROP_COUNT += 1;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    {\n+        let mut fragments = vec![Fragment, Fragment, Fragment];\n+        let _new_fragments: Vec<Fragment> = mem::replace(&mut fragments, vec![])\n+            .move_iter()\n+            .skip_while(|_fragment| {\n+                true\n+            }).collect();\n+    }\n+    unsafe {\n+        assert_eq!(DROP_COUNT, 3);\n+    }\n+}\n+"}]}