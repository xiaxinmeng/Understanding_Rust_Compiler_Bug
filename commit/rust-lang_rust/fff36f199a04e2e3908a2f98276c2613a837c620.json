{"sha": "fff36f199a04e2e3908a2f98276c2613a837c620", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZjM2ZjE5OWEwNGUyZTM5MDhhMmY5ODI3NmMyNjEzYTgzN2M2MjA=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-02-10T03:24:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-10T03:24:25Z"}, "message": "Rollup merge of #81909 - wcampbell0x2a:remove-unnecessary-refs, r=estebank\n\n[compiler/rustc_typeck/src/check/expr.rs] Remove unnecessary refs in pattern matching", "tree": {"sha": "c9e98a3f594a673375ea549018677adba4c0d578", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9e98a3f594a673375ea549018677adba4c0d578"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fff36f199a04e2e3908a2f98276c2613a837c620", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgI1HpCRBK7hj4Ov3rIwAAdHIIADFlX9cjIN2TRhHj1cUmhRjH\naeTH3enFmvmlrPbxYkudRCPQY+9ijQufSlBTLcVf9Z5xTaB5FTIKuq4HNEl8y1KZ\nE70KV2ItCOQR2M5oj5V6phU2x727rP6AFAx8TNp61v9BDpvrVUbfSxR5TePNvWhs\nLeOAE6ml5dV+2MV/uTPxYzSdMzkJML9lziZCWHQcyqobVd+63DJeFpIffeeAmJFO\nWgUZTTExSAa93ZqoCQEp20ZRE1CiJ+z2lYnICc7lK5AxnYr8zPODB35P/EE50SiJ\nevLEZDh1OFMSurqKnZxi+mqydEQNAeaZmnSBNs7o9Zz8snXsgKMUPTh1+Cjw5rw=\n=d6L5\n-----END PGP SIGNATURE-----\n", "payload": "tree c9e98a3f594a673375ea549018677adba4c0d578\nparent bf0c2d53828b7b76afb12dd0016192b5212f6ae1\nparent 7554c7742e7d53f4a66a8a5ea704652ee9bef25e\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1612927465 +0900\ncommitter GitHub <noreply@github.com> 1612927465 +0900\n\nRollup merge of #81909 - wcampbell0x2a:remove-unnecessary-refs, r=estebank\n\n[compiler/rustc_typeck/src/check/expr.rs] Remove unnecessary refs in pattern matching\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fff36f199a04e2e3908a2f98276c2613a837c620", "html_url": "https://github.com/rust-lang/rust/commit/fff36f199a04e2e3908a2f98276c2613a837c620", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fff36f199a04e2e3908a2f98276c2613a837c620/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf0c2d53828b7b76afb12dd0016192b5212f6ae1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf0c2d53828b7b76afb12dd0016192b5212f6ae1", "html_url": "https://github.com/rust-lang/rust/commit/bf0c2d53828b7b76afb12dd0016192b5212f6ae1"}, {"sha": "7554c7742e7d53f4a66a8a5ea704652ee9bef25e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7554c7742e7d53f4a66a8a5ea704652ee9bef25e", "html_url": "https://github.com/rust-lang/rust/commit/7554c7742e7d53f4a66a8a5ea704652ee9bef25e"}], "stats": {"total": 70, "additions": 34, "deletions": 36}, "files": [{"sha": "44813313fa37cb63975136b1eccb1bc7b8a67530", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fff36f199a04e2e3908a2f98276c2613a837c620/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fff36f199a04e2e3908a2f98276c2613a837c620/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=fff36f199a04e2e3908a2f98276c2613a837c620", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // without the final expr (e.g. `try { return; }`). We don't want to generate an\n         // unreachable_code lint for it since warnings for autogenerated code are confusing.\n         let is_try_block_generated_unit_expr = match expr.kind {\n-            ExprKind::Call(_, ref args) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {\n+            ExprKind::Call(_, args) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {\n                 args.len() == 1 && args[0].span.is_desugaring(DesugaringKind::TryBlock)\n             }\n \n@@ -193,9 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // diverging expression (e.g. it arose from desugaring of `try { return }`),\n             // we skip issuing a warning because it is autogenerated code.\n             ExprKind::Call(..) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {}\n-            ExprKind::Call(ref callee, _) => {\n-                self.warn_if_unreachable(expr.hir_id, callee.span, \"call\")\n-            }\n+            ExprKind::Call(callee, _) => self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n             ExprKind::MethodCall(_, ref span, _, _) => {\n                 self.warn_if_unreachable(expr.hir_id, *span, \"call\")\n             }\n@@ -231,23 +229,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tcx = self.tcx;\n         match expr.kind {\n-            ExprKind::Box(ref subexpr) => self.check_expr_box(subexpr, expected),\n+            ExprKind::Box(subexpr) => self.check_expr_box(subexpr, expected),\n             ExprKind::Lit(ref lit) => self.check_lit(&lit, expected),\n-            ExprKind::Binary(op, ref lhs, ref rhs) => self.check_binop(expr, op, lhs, rhs),\n-            ExprKind::Assign(ref lhs, ref rhs, ref span) => {\n+            ExprKind::Binary(op, lhs, rhs) => self.check_binop(expr, op, lhs, rhs),\n+            ExprKind::Assign(lhs, rhs, ref span) => {\n                 self.check_expr_assign(expr, expected, lhs, rhs, span)\n             }\n-            ExprKind::AssignOp(op, ref lhs, ref rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n-            ExprKind::Unary(unop, ref oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n-            ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n+            ExprKind::AssignOp(op, lhs, rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n+            ExprKind::Unary(unop, oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n+            ExprKind::AddrOf(kind, mutbl, oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(QPath::LangItem(lang_item, _)) => {\n                 self.check_lang_item_path(lang_item, expr)\n             }\n             ExprKind::Path(ref qpath) => self.check_expr_path(qpath, expr),\n             ExprKind::InlineAsm(asm) => self.check_expr_asm(asm),\n-            ExprKind::LlvmInlineAsm(ref asm) => {\n+            ExprKind::LlvmInlineAsm(asm) => {\n                 for expr in asm.outputs_exprs.iter().chain(asm.inputs_exprs.iter()) {\n                     self.check_expr(expr);\n                 }\n@@ -265,42 +263,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n-            ExprKind::Loop(ref body, _, source, _) => {\n+            ExprKind::Loop(body, _, source, _) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n-            ExprKind::Match(ref discrim, ref arms, match_src) => {\n+            ExprKind::Match(discrim, arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n             }\n-            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n+            ExprKind::Closure(capture, decl, body_id, _, gen) => {\n                 self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n             }\n-            ExprKind::Block(ref body, _) => self.check_block_with_expected(&body, expected),\n-            ExprKind::Call(ref callee, ref args) => self.check_call(expr, &callee, args, expected),\n-            ExprKind::MethodCall(ref segment, span, ref args, _) => {\n+            ExprKind::Block(body, _) => self.check_block_with_expected(&body, expected),\n+            ExprKind::Call(callee, args) => self.check_call(expr, &callee, args, expected),\n+            ExprKind::MethodCall(segment, span, args, _) => {\n                 self.check_method_call(expr, segment, span, args, expected)\n             }\n-            ExprKind::Cast(ref e, ref t) => self.check_expr_cast(e, t, expr),\n-            ExprKind::Type(ref e, ref t) => {\n+            ExprKind::Cast(e, t) => self.check_expr_cast(e, t, expr),\n+            ExprKind::Type(e, t) => {\n                 let ty = self.to_ty_saving_user_provided_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n             ExprKind::If(cond, then_expr, opt_else_expr) => {\n                 self.check_then_else(cond, then_expr, opt_else_expr, expr.span, expected)\n             }\n-            ExprKind::DropTemps(ref e) => self.check_expr_with_expectation(e, expected),\n-            ExprKind::Array(ref args) => self.check_expr_array(args, expected, expr),\n+            ExprKind::DropTemps(e) => self.check_expr_with_expectation(e, expected),\n+            ExprKind::Array(args) => self.check_expr_array(args, expected, expr),\n             ExprKind::ConstBlock(ref anon_const) => self.to_const(anon_const).ty,\n-            ExprKind::Repeat(ref element, ref count) => {\n+            ExprKind::Repeat(element, ref count) => {\n                 self.check_expr_repeat(element, count, expected, expr)\n             }\n-            ExprKind::Tup(ref elts) => self.check_expr_tuple(elts, expected, expr),\n-            ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n+            ExprKind::Tup(elts) => self.check_expr_tuple(elts, expected, expr),\n+            ExprKind::Struct(qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(ref base, field) => self.check_field(expr, &base, field),\n-            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, expr),\n-            ExprKind::Yield(ref value, ref src) => self.check_expr_yield(value, expr, src),\n+            ExprKind::Field(base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n+            ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.ty_error(),\n         }\n     }\n@@ -541,7 +539,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         if let Ok(target_id) = destination.target_id {\n             let (e_ty, cause);\n-            if let Some(ref e) = expr_opt {\n+            if let Some(e) = expr_opt {\n                 // If this is a break with a value, we need to type-check\n                 // the expression. Get an expected type from the loop context.\n                 let opt_coerce_to = {\n@@ -650,12 +648,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // We still need to assign a type to the inner expression to\n             // prevent the ICE in #43162.\n-            if let Some(ref e) = expr_opt {\n+            if let Some(e) = expr_opt {\n                 self.check_expr_with_hint(e, err);\n \n                 // ... except when we try to 'break rust;'.\n                 // ICE this expression in particular (see #43162).\n-                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = e.kind {\n                     if path.segments.len() == 1 && path.segments[0].ident.name == sym::rust {\n                         fatally_break_rust(self.tcx.sess);\n                     }\n@@ -674,7 +672,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n             self.tcx.sess.emit_err(ReturnStmtOutsideOfFnBody { span: expr.span });\n-        } else if let Some(ref e) = expr_opt {\n+        } else if let Some(e) = expr_opt {\n             if self.ret_coercion_span.get().is_none() {\n                 self.ret_coercion_span.set(Some(e.span));\n             }\n@@ -1133,13 +1131,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n             let ty = self.resolve_vars_with_obligations(ty);\n             match ty.kind() {\n-                ty::Tuple(ref flds) => Some(&flds[..]),\n+                ty::Tuple(flds) => Some(&flds[..]),\n                 _ => None,\n             }\n         });\n \n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n-            Some(ref fs) if i < fs.len() => {\n+            Some(fs) if i < fs.len() => {\n                 let ety = fs[i].expect_ty();\n                 self.check_expr_coercable_to_type(&e, ety, None);\n                 ety\n@@ -1328,7 +1326,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for field in fields {\n             self.check_expr(&field.expr);\n         }\n-        if let Some(ref base) = *base_expr {\n+        if let Some(base) = *base_expr {\n             self.check_expr(&base);\n         }\n     }\n@@ -1488,7 +1486,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n             _ => {\n                 // prevent all specified fields from being suggested\n-                let skip_fields = skip_fields.iter().map(|ref x| x.ident.name);\n+                let skip_fields = skip_fields.iter().map(|x| x.ident.name);\n                 if let Some(field_name) =\n                     Self::suggest_field_name(variant, field.ident.name, skip_fields.collect())\n                 {\n@@ -1617,7 +1615,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n                 }\n-                ty::Tuple(ref tys) => {\n+                ty::Tuple(tys) => {\n                     let fstr = field.as_str();\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {"}]}